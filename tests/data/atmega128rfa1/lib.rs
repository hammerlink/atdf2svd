# ! [doc = "Peripheral access API for ATMEGA128RFA1 microcontrollers (generated using svd2rust v0.28.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS : u8 = 4 ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."]
type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."]
type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Read datasheet or reference manual to find what values are allowed to pass."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc (hidden)]
pub struct FieldReaderRaw < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , FI > FieldReaderRaw < U , FI > where U : Copy , { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitReaderRaw < T > { pub (crate) bits : bool , _reg : marker :: PhantomData < T > , } impl < FI > BitReaderRaw < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < U , FI > = FieldReaderRaw < U , FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI > = BitReaderRaw < FI > ; impl < U , FI > FieldReader < U , FI > where U : Copy , { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , FI > PartialEq < FI > for FieldReader < U , FI > where U : PartialEq , FI : Copy , U : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& U :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc (hidden)]
pub struct FieldWriterRaw < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (N , FI , Safety) > , } impl < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > FieldWriterRaw < 'a , U , REG , N , FI , Safety , WI , O > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitWriterRaw < 'a , U , REG , FI , M , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , U , REG , FI , M , const O : u8 > BitWriterRaw < 'a , U , REG , FI , M , O > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Unsafe , WI , O > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Safe , WI , O > ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , U , REG , FI , const O : u8 > = BitWriterRaw <'a , U , REG , FI , $ mwv , O >; impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; } } ; } macro_rules ! impl_bit_proxy { ($ writer : ident) => { impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, U : RawReg , bool : From < FI >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w . bits |= (U :: from (value) & U :: one ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { unsafe { self . bits (N :: from (variant)) } } } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { self . bits (N :: from (variant)) } } impl_bit_proxy ! (BitWriter) ; impl_bit_proxy ! (BitWriter1S) ; impl_bit_proxy ! (BitWriter0C) ; impl_bit_proxy ! (BitWriter1C) ; impl_bit_proxy ! (BitWriter0S) ; impl_bit_proxy ! (BitWriter1T) ; impl_bit_proxy ! (BitWriter0T) ; impl < 'a , U , REG , FI , const OF : u8 > BitWriter < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } } # [doc (hidden)]
pub mod interrupt { # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "0 - External Pin,Power-on Reset,Brown-out Reset,Watchdog Reset,and JTAG AVR Reset. See Datasheet."]
RESET = 0 , # [doc = "1 - External Interrupt Request 0"]
INT0 = 1 , # [doc = "2 - External Interrupt Request 1"]
INT1 = 2 , # [doc = "3 - External Interrupt Request 2"]
INT2 = 3 , # [doc = "4 - External Interrupt Request 3"]
INT3 = 4 , # [doc = "5 - External Interrupt Request 4"]
INT4 = 5 , # [doc = "6 - External Interrupt Request 5"]
INT5 = 6 , # [doc = "7 - External Interrupt Request 6"]
INT6 = 7 , # [doc = "8 - External Interrupt Request 7"]
INT7 = 8 , # [doc = "9 - Pin Change Interrupt Request 0"]
PCINT0 = 9 , # [doc = "10 - Pin Change Interrupt Request 1"]
PCINT1 = 10 , # [doc = "11 - Pin Change Interrupt Request 2"]
PCINT2 = 11 , # [doc = "12 - Watchdog Time-out Interrupt"]
WDT = 12 , # [doc = "13 - Timer/Counter2 Compare Match A"]
TIMER2_COMPA = 13 , # [doc = "14 - Timer/Counter2 Compare Match B"]
TIMER2_COMPB = 14 , # [doc = "15 - Timer/Counter2 Overflow"]
TIMER2_OVF = 15 , # [doc = "16 - Timer/Counter1 Capture Event"]
TIMER1_CAPT = 16 , # [doc = "17 - Timer/Counter1 Compare Match A"]
TIMER1_COMPA = 17 , # [doc = "18 - Timer/Counter1 Compare Match B"]
TIMER1_COMPB = 18 , # [doc = "19 - Timer/Counter1 Compare Match C"]
TIMER1_COMPC = 19 , # [doc = "20 - Timer/Counter1 Overflow"]
TIMER1_OVF = 20 , # [doc = "21 - Timer/Counter0 Compare Match A"]
TIMER0_COMPA = 21 , # [doc = "22 - Timer/Counter0 Compare Match B"]
TIMER0_COMPB = 22 , # [doc = "23 - Timer/Counter0 Overflow"]
TIMER0_OVF = 23 , # [doc = "24 - SPI Serial Transfer Complete"]
SPI_STC = 24 , # [doc = "25 - USART0, Rx Complete"]
USART0_RX = 25 , # [doc = "26 - USART0 Data register Empty"]
USART0_UDRE = 26 , # [doc = "27 - USART0, Tx Complete"]
USART0_TX = 27 , # [doc = "28 - Analog Comparator"]
ANALOG_COMP = 28 , # [doc = "29 - ADC Conversion Complete"]
ADC = 29 , # [doc = "30 - EEPROM Ready"]
EE_READY = 30 , # [doc = "31 - Timer/Counter3 Capture Event"]
TIMER3_CAPT = 31 , # [doc = "32 - Timer/Counter3 Compare Match A"]
TIMER3_COMPA = 32 , # [doc = "33 - Timer/Counter3 Compare Match B"]
TIMER3_COMPB = 33 , # [doc = "34 - Timer/Counter3 Compare Match C"]
TIMER3_COMPC = 34 , # [doc = "35 - Timer/Counter3 Overflow"]
TIMER3_OVF = 35 , # [doc = "36 - USART1, Rx Complete"]
USART1_RX = 36 , # [doc = "37 - USART1 Data register Empty"]
USART1_UDRE = 37 , # [doc = "38 - USART1, Tx Complete"]
USART1_TX = 38 , # [doc = "39 - 2-wire Serial Interface"]
TWI = 39 , # [doc = "40 - Store Program Memory Read"]
SPM_READY = 40 , # [doc = "41 - Timer/Counter4 Capture Event"]
TIMER4_CAPT = 41 , # [doc = "42 - Timer/Counter4 Compare Match A"]
TIMER4_COMPA = 42 , # [doc = "43 - Timer/Counter4 Compare Match B"]
TIMER4_COMPB = 43 , # [doc = "44 - Timer/Counter4 Compare Match C"]
TIMER4_COMPC = 44 , # [doc = "45 - Timer/Counter4 Overflow"]
TIMER4_OVF = 45 , # [doc = "46 - Timer/Counter5 Capture Event"]
TIMER5_CAPT = 46 , # [doc = "47 - Timer/Counter5 Compare Match A"]
TIMER5_COMPA = 47 , # [doc = "48 - Timer/Counter5 Compare Match B"]
TIMER5_COMPB = 48 , # [doc = "49 - Timer/Counter5 Compare Match C"]
TIMER5_COMPC = 49 , # [doc = "50 - Timer/Counter5 Overflow"]
TIMER5_OVF = 50 , # [doc = "51 - USART2, Rx Complete"]
USART2_RX = 51 , # [doc = "52 - USART2 Data register Empty"]
USART2_UDRE = 52 , # [doc = "53 - USART2, Tx Complete"]
USART2_TX = 53 , # [doc = "54 - USART3, Rx Complete"]
USART3_RX = 54 , # [doc = "55 - USART3 Data register Empty"]
USART3_UDRE = 55 , # [doc = "56 - USART3, Tx Complete"]
USART3_TX = 56 , # [doc = "57 - TRX24 - PLL lock interrupt"]
TRX24_PLL_LOCK = 57 , # [doc = "58 - TRX24 - PLL unlock interrupt"]
TRX24_PLL_UNLOCK = 58 , # [doc = "59 - TRX24 - Receive start interrupt"]
TRX24_RX_START = 59 , # [doc = "60 - TRX24 - RX_END interrupt"]
TRX24_RX_END = 60 , # [doc = "61 - TRX24 - CCA/ED done interrupt"]
TRX24_CCA_ED_DONE = 61 , # [doc = "62 - TRX24 - XAH - AMI"]
TRX24_XAH_AMI = 62 , # [doc = "63 - TRX24 - TX_END interrupt"]
TRX24_TX_END = 63 , # [doc = "64 - TRX24 AWAKE - tranceiver is reaching state TRX_OFF"]
TRX24_AWAKE = 64 , # [doc = "65 - Symbol counter - compare match 1 interrupt"]
SCNT_CMP1 = 65 , # [doc = "66 - Symbol counter - compare match 2 interrupt"]
SCNT_CMP2 = 66 , # [doc = "67 - Symbol counter - compare match 3 interrupt"]
SCNT_CMP3 = 67 , # [doc = "68 - Symbol counter - overflow interrupt"]
SCNT_OVFL = 68 , # [doc = "69 - Symbol counter - backoff interrupt"]
SCNT_BACKOFF = 69 , # [doc = "70 - AES engine ready interrupt"]
AES_READY = 70 , # [doc = "71 - Battery monitor indicates supply voltage below threshold"]
BAT_LOW = 71 , } # [doc = r" TryFromInterruptError"]
# [derive (Debug , Copy , Clone)]
pub struct TryFromInterruptError (()) ; impl Interrupt { # [doc = r" Attempt to convert a given value into an `Interrupt`"]
# [inline]
pub fn try_from (value : u8) -> Result < Self , TryFromInterruptError > { match value { 0 => Ok (Interrupt :: RESET) , 1 => Ok (Interrupt :: INT0) , 2 => Ok (Interrupt :: INT1) , 3 => Ok (Interrupt :: INT2) , 4 => Ok (Interrupt :: INT3) , 5 => Ok (Interrupt :: INT4) , 6 => Ok (Interrupt :: INT5) , 7 => Ok (Interrupt :: INT6) , 8 => Ok (Interrupt :: INT7) , 9 => Ok (Interrupt :: PCINT0) , 10 => Ok (Interrupt :: PCINT1) , 11 => Ok (Interrupt :: PCINT2) , 12 => Ok (Interrupt :: WDT) , 13 => Ok (Interrupt :: TIMER2_COMPA) , 14 => Ok (Interrupt :: TIMER2_COMPB) , 15 => Ok (Interrupt :: TIMER2_OVF) , 16 => Ok (Interrupt :: TIMER1_CAPT) , 17 => Ok (Interrupt :: TIMER1_COMPA) , 18 => Ok (Interrupt :: TIMER1_COMPB) , 19 => Ok (Interrupt :: TIMER1_COMPC) , 20 => Ok (Interrupt :: TIMER1_OVF) , 21 => Ok (Interrupt :: TIMER0_COMPA) , 22 => Ok (Interrupt :: TIMER0_COMPB) , 23 => Ok (Interrupt :: TIMER0_OVF) , 24 => Ok (Interrupt :: SPI_STC) , 25 => Ok (Interrupt :: USART0_RX) , 26 => Ok (Interrupt :: USART0_UDRE) , 27 => Ok (Interrupt :: USART0_TX) , 28 => Ok (Interrupt :: ANALOG_COMP) , 29 => Ok (Interrupt :: ADC) , 30 => Ok (Interrupt :: EE_READY) , 31 => Ok (Interrupt :: TIMER3_CAPT) , 32 => Ok (Interrupt :: TIMER3_COMPA) , 33 => Ok (Interrupt :: TIMER3_COMPB) , 34 => Ok (Interrupt :: TIMER3_COMPC) , 35 => Ok (Interrupt :: TIMER3_OVF) , 36 => Ok (Interrupt :: USART1_RX) , 37 => Ok (Interrupt :: USART1_UDRE) , 38 => Ok (Interrupt :: USART1_TX) , 39 => Ok (Interrupt :: TWI) , 40 => Ok (Interrupt :: SPM_READY) , 41 => Ok (Interrupt :: TIMER4_CAPT) , 42 => Ok (Interrupt :: TIMER4_COMPA) , 43 => Ok (Interrupt :: TIMER4_COMPB) , 44 => Ok (Interrupt :: TIMER4_COMPC) , 45 => Ok (Interrupt :: TIMER4_OVF) , 46 => Ok (Interrupt :: TIMER5_CAPT) , 47 => Ok (Interrupt :: TIMER5_COMPA) , 48 => Ok (Interrupt :: TIMER5_COMPB) , 49 => Ok (Interrupt :: TIMER5_COMPC) , 50 => Ok (Interrupt :: TIMER5_OVF) , 51 => Ok (Interrupt :: USART2_RX) , 52 => Ok (Interrupt :: USART2_UDRE) , 53 => Ok (Interrupt :: USART2_TX) , 54 => Ok (Interrupt :: USART3_RX) , 55 => Ok (Interrupt :: USART3_UDRE) , 56 => Ok (Interrupt :: USART3_TX) , 57 => Ok (Interrupt :: TRX24_PLL_LOCK) , 58 => Ok (Interrupt :: TRX24_PLL_UNLOCK) , 59 => Ok (Interrupt :: TRX24_RX_START) , 60 => Ok (Interrupt :: TRX24_RX_END) , 61 => Ok (Interrupt :: TRX24_CCA_ED_DONE) , 62 => Ok (Interrupt :: TRX24_XAH_AMI) , 63 => Ok (Interrupt :: TRX24_TX_END) , 64 => Ok (Interrupt :: TRX24_AWAKE) , 65 => Ok (Interrupt :: SCNT_CMP1) , 66 => Ok (Interrupt :: SCNT_CMP2) , 67 => Ok (Interrupt :: SCNT_CMP3) , 68 => Ok (Interrupt :: SCNT_OVFL) , 69 => Ok (Interrupt :: SCNT_BACKOFF) , 70 => Ok (Interrupt :: AES_READY) , 71 => Ok (Interrupt :: BAT_LOW) , _ => Err (TryFromInterruptError (())) , } } } } pub use self :: interrupt :: Interrupt ; # [doc = "Analog Comparator"]
pub struct AC { _marker : PhantomData < * const () > } unsafe impl Send for AC { } impl AC { # [doc = r"Pointer to the register block"]
pub const PTR : * const ac :: RegisterBlock = 0x50 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ac :: RegisterBlock { Self :: PTR } } impl Deref for AC { type Target = ac :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for AC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AC") . finish () } } # [doc = "Analog Comparator"]
pub mod ac { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Analog Comparator Control And Status Register"]
pub acsr : ACSR , _reserved1 : [u8 ; 0x2a]
, # [doc = "0x2b - ADC Control and Status Register B"]
pub adcsrb : ADCSRB , _reserved2 : [u8 ; 0x03]
, # [doc = "0x2f - Digital Input Disable Register 1"]
pub didr1 : DIDR1 , } # [doc = "ACSR (rw) register accessor: an alias for `Reg<ACSR_SPEC>`"]
pub type ACSR = crate :: Reg < acsr :: ACSR_SPEC > ; # [doc = "Analog Comparator Control And Status Register"]
pub mod acsr { # [doc = "Register `ACSR` reader"]
pub struct R (crate :: R < ACSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ACSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ACSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ACSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ACSR` writer"]
pub struct W (crate :: W < ACSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ACSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ACSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ACSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ACIS` reader - Analog Comparator Interrupt Mode Select"]
pub type ACIS_R = crate :: FieldReader < u8 , ACIS_A > ; # [doc = "Analog Comparator Interrupt Mode Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ACIS_A { # [doc = "0: Interrupt on Toggle"]
INTERRUPT_ON_TOGGLE = 0 , # [doc = "2: Interrupt on Falling Edge"]
INTERRUPT_ON_FALLING_EDGE = 2 , # [doc = "3: Interrupt on Rising Edge"]
INTERRUPT_ON_RISING_EDGE = 3 , } impl From < ACIS_A > for u8 { # [inline (always)]
fn from (variant : ACIS_A) -> Self { variant as _ } } impl ACIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACIS_A { match self . bits { 0 => ACIS_A :: INTERRUPT_ON_TOGGLE , 2 => ACIS_A :: INTERRUPT_ON_FALLING_EDGE , 3 => ACIS_A :: INTERRUPT_ON_RISING_EDGE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INTERRUPT_ON_TOGGLE`"]
# [inline (always)]
pub fn is_interrupt_on_toggle (& self) -> bool { * self == ACIS_A :: INTERRUPT_ON_TOGGLE } # [doc = "Checks if the value of the field is `INTERRUPT_ON_FALLING_EDGE`"]
# [inline (always)]
pub fn is_interrupt_on_falling_edge (& self) -> bool { * self == ACIS_A :: INTERRUPT_ON_FALLING_EDGE } # [doc = "Checks if the value of the field is `INTERRUPT_ON_RISING_EDGE`"]
# [inline (always)]
pub fn is_interrupt_on_rising_edge (& self) -> bool { * self == ACIS_A :: INTERRUPT_ON_RISING_EDGE } } # [doc = "Field `ACIS` writer - Analog Comparator Interrupt Mode Select"]
pub type ACIS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ACSR_SPEC , u8 , ACIS_A , 2 , O > ; impl < 'a , const O : u8 > ACIS_W < 'a , O > { # [doc = "Interrupt on Toggle"]
# [inline (always)]
pub fn interrupt_on_toggle (self) -> & 'a mut W { self . variant (ACIS_A :: INTERRUPT_ON_TOGGLE) } # [doc = "Interrupt on Falling Edge"]
# [inline (always)]
pub fn interrupt_on_falling_edge (self) -> & 'a mut W { self . variant (ACIS_A :: INTERRUPT_ON_FALLING_EDGE) } # [doc = "Interrupt on Rising Edge"]
# [inline (always)]
pub fn interrupt_on_rising_edge (self) -> & 'a mut W { self . variant (ACIS_A :: INTERRUPT_ON_RISING_EDGE) } } # [doc = "Field `ACIC` reader - Analog Comparator Input Capture Enable"]
pub type ACIC_R = crate :: BitReader < bool > ; # [doc = "Field `ACIC` writer - Analog Comparator Input Capture Enable"]
pub type ACIC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACIE` reader - Analog Comparator Interrupt Enable"]
pub type ACIE_R = crate :: BitReader < bool > ; # [doc = "Field `ACIE` writer - Analog Comparator Interrupt Enable"]
pub type ACIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACI` reader - Analog Comparator Interrupt Flag"]
pub type ACI_R = crate :: BitReader < bool > ; # [doc = "Field `ACI` writer - Analog Comparator Interrupt Flag"]
pub type ACI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACO` reader - Analog Compare Output"]
pub type ACO_R = crate :: BitReader < bool > ; # [doc = "Field `ACO` writer - Analog Compare Output"]
pub type ACO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACBG` reader - Analog Comparator Bandgap Select"]
pub type ACBG_R = crate :: BitReader < bool > ; # [doc = "Field `ACBG` writer - Analog Comparator Bandgap Select"]
pub type ACBG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACD` reader - Analog Comparator Disable"]
pub type ACD_R = crate :: BitReader < bool > ; # [doc = "Field `ACD` writer - Analog Comparator Disable"]
pub type ACD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Analog Comparator Interrupt Mode Select"]
# [inline (always)]
pub fn acis (& self) -> ACIS_R { ACIS_R :: new (self . bits & 3) } # [doc = "Bit 2 - Analog Comparator Input Capture Enable"]
# [inline (always)]
pub fn acic (& self) -> ACIC_R { ACIC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Analog Comparator Interrupt Enable"]
# [inline (always)]
pub fn acie (& self) -> ACIE_R { ACIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Analog Comparator Interrupt Flag"]
# [inline (always)]
pub fn aci (& self) -> ACI_R { ACI_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Analog Compare Output"]
# [inline (always)]
pub fn aco (& self) -> ACO_R { ACO_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Analog Comparator Bandgap Select"]
# [inline (always)]
pub fn acbg (& self) -> ACBG_R { ACBG_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Analog Comparator Disable"]
# [inline (always)]
pub fn acd (& self) -> ACD_R { ACD_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Analog Comparator Interrupt Mode Select"]
# [inline (always)]
# [must_use]
pub fn acis (& mut self) -> ACIS_W < 0 > { ACIS_W :: new (self) } # [doc = "Bit 2 - Analog Comparator Input Capture Enable"]
# [inline (always)]
# [must_use]
pub fn acic (& mut self) -> ACIC_W < 2 > { ACIC_W :: new (self) } # [doc = "Bit 3 - Analog Comparator Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn acie (& mut self) -> ACIE_W < 3 > { ACIE_W :: new (self) } # [doc = "Bit 4 - Analog Comparator Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn aci (& mut self) -> ACI_W < 4 > { ACI_W :: new (self) } # [doc = "Bit 5 - Analog Compare Output"]
# [inline (always)]
# [must_use]
pub fn aco (& mut self) -> ACO_W < 5 > { ACO_W :: new (self) } # [doc = "Bit 6 - Analog Comparator Bandgap Select"]
# [inline (always)]
# [must_use]
pub fn acbg (& mut self) -> ACBG_W < 6 > { ACBG_W :: new (self) } # [doc = "Bit 7 - Analog Comparator Disable"]
# [inline (always)]
# [must_use]
pub fn acd (& mut self) -> ACD_W < 7 > { ACD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator Control And Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [acsr](index.html) module"]
pub struct ACSR_SPEC ; impl crate :: RegisterSpec for ACSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [acsr::R](R) reader structure"]
impl crate :: Readable for ACSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [acsr::W](W) writer structure"]
impl crate :: Writable for ACSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ACSR to value 0"]
impl crate :: Resettable for ACSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCSRB (rw) register accessor: an alias for `Reg<ADCSRB_SPEC>`"]
pub type ADCSRB = crate :: Reg < adcsrb :: ADCSRB_SPEC > ; # [doc = "ADC Control and Status Register B"]
pub mod adcsrb { # [doc = "Register `ADCSRB` reader"]
pub struct R (crate :: R < ADCSRB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCSRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCSRB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCSRB_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCSRB` writer"]
pub struct W (crate :: W < ADCSRB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCSRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCSRB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCSRB_SPEC >) -> Self { W (writer) } } # [doc = "Field `ACME` reader - Analog Comparator Multiplexer Enable"]
pub type ACME_R = crate :: BitReader < bool > ; # [doc = "Field `ACME` writer - Analog Comparator Multiplexer Enable"]
pub type ACME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRB_SPEC , bool , O > ; impl R { # [doc = "Bit 6 - Analog Comparator Multiplexer Enable"]
# [inline (always)]
pub fn acme (& self) -> ACME_R { ACME_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 6 - Analog Comparator Multiplexer Enable"]
# [inline (always)]
# [must_use]
pub fn acme (& mut self) -> ACME_W < 6 > { ACME_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "ADC Control and Status Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcsrb](index.html) module"]
pub struct ADCSRB_SPEC ; impl crate :: RegisterSpec for ADCSRB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcsrb::R](R) reader structure"]
impl crate :: Readable for ADCSRB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcsrb::W](W) writer structure"]
impl crate :: Writable for ADCSRB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCSRB to value 0"]
impl crate :: Resettable for ADCSRB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIDR1 (rw) register accessor: an alias for `Reg<DIDR1_SPEC>`"]
pub type DIDR1 = crate :: Reg < didr1 :: DIDR1_SPEC > ; # [doc = "Digital Input Disable Register 1"]
pub mod didr1 { # [doc = "Register `DIDR1` reader"]
pub struct R (crate :: R < DIDR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIDR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIDR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIDR1` writer"]
pub struct W (crate :: W < DIDR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIDR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIDR1_SPEC >) -> Self { W (writer) } } # [doc = "Field `AIN0D` reader - AIN0 Digital Input Disable"]
pub type AIN0D_R = crate :: BitReader < bool > ; # [doc = "Field `AIN0D` writer - AIN0 Digital Input Disable"]
pub type AIN0D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR1_SPEC , bool , O > ; # [doc = "Field `AIN1D` reader - AIN1 Digital Input Disable"]
pub type AIN1D_R = crate :: BitReader < bool > ; # [doc = "Field `AIN1D` writer - AIN1 Digital Input Disable"]
pub type AIN1D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - AIN0 Digital Input Disable"]
# [inline (always)]
pub fn ain0d (& self) -> AIN0D_R { AIN0D_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - AIN1 Digital Input Disable"]
# [inline (always)]
pub fn ain1d (& self) -> AIN1D_R { AIN1D_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - AIN0 Digital Input Disable"]
# [inline (always)]
# [must_use]
pub fn ain0d (& mut self) -> AIN0D_W < 0 > { AIN0D_W :: new (self) } # [doc = "Bit 1 - AIN1 Digital Input Disable"]
# [inline (always)]
# [must_use]
pub fn ain1d (& mut self) -> AIN1D_W < 1 > { AIN1D_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Digital Input Disable Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [didr1](index.html) module"]
pub struct DIDR1_SPEC ; impl crate :: RegisterSpec for DIDR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [didr1::R](R) reader structure"]
impl crate :: Readable for DIDR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [didr1::W](W) writer structure"]
impl crate :: Writable for DIDR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIDR1 to value 0"]
impl crate :: Resettable for DIDR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Analog-to-Digital Converter"]
pub struct ADC { _marker : PhantomData < * const () > } unsafe impl Send for ADC { } impl ADC { # [doc = r"Pointer to the register block"]
pub const PTR : * const adc :: RegisterBlock = 0x77 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adc :: RegisterBlock { Self :: PTR } } impl Deref for ADC { type Target = adc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC") . finish () } } # [doc = "Analog-to-Digital Converter"]
pub mod adc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - The ADC Control and Status Register C"]
pub adcsrc : ADCSRC , # [doc = "0x01 - ADC Data Register Bytes"]
pub adc : ADC , # [doc = "0x03 - The ADC Control and Status Register A"]
pub adcsra : ADCSRA , # [doc = "0x04 - The ADC Control and Status Register B"]
pub adcsrb : ADCSRB , # [doc = "0x05 - The ADC Multiplexer Selection Register"]
pub admux : ADMUX , # [doc = "0x06 - Digital Input Disable Register 2"]
pub didr2 : DIDR2 , # [doc = "0x07 - Digital Input Disable Register 0"]
pub didr0 : DIDR0 , } # [doc = "ADC (rw) register accessor: an alias for `Reg<ADC_SPEC>`"]
pub type ADC = crate :: Reg < adc :: ADC_SPEC > ; # [doc = "ADC Data Register Bytes"]
pub mod adc { # [doc = "Register `ADC` reader"]
pub struct R (crate :: R < ADC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADC_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADC` writer"]
pub struct W (crate :: W < ADC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "ADC Data Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adc](index.html) module"]
pub struct ADC_SPEC ; impl crate :: RegisterSpec for ADC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adc::R](R) reader structure"]
impl crate :: Readable for ADC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adc::W](W) writer structure"]
impl crate :: Writable for ADC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADC to value 0"]
impl crate :: Resettable for ADC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCSRA (rw) register accessor: an alias for `Reg<ADCSRA_SPEC>`"]
pub type ADCSRA = crate :: Reg < adcsra :: ADCSRA_SPEC > ; # [doc = "The ADC Control and Status Register A"]
pub mod adcsra { # [doc = "Register `ADCSRA` reader"]
pub struct R (crate :: R < ADCSRA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCSRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCSRA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCSRA_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCSRA` writer"]
pub struct W (crate :: W < ADCSRA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCSRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCSRA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCSRA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADPS` reader - ADC Prescaler Select Bits"]
pub type ADPS_R = crate :: FieldReader < u8 , ADPS_A > ; # [doc = "ADC Prescaler Select Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ADPS_A { # [doc = "1: 2"]
_2 = 1 , # [doc = "2: 4"]
_4 = 2 , # [doc = "3: 8"]
_8 = 3 , # [doc = "4: 16"]
_16 = 4 , # [doc = "5: 32"]
_32 = 5 , # [doc = "6: 64"]
_64 = 6 , # [doc = "7: 128"]
_128 = 7 , } impl From < ADPS_A > for u8 { # [inline (always)]
fn from (variant : ADPS_A) -> Self { variant as _ } } impl ADPS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ADPS_A > { match self . bits { 1 => Some (ADPS_A :: _2) , 2 => Some (ADPS_A :: _4) , 3 => Some (ADPS_A :: _8) , 4 => Some (ADPS_A :: _16) , 5 => Some (ADPS_A :: _32) , 6 => Some (ADPS_A :: _64) , 7 => Some (ADPS_A :: _128) , _ => None , } } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == ADPS_A :: _2 } # [doc = "Checks if the value of the field is `_4`"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == ADPS_A :: _4 } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == ADPS_A :: _8 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == ADPS_A :: _16 } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == ADPS_A :: _32 } # [doc = "Checks if the value of the field is `_64`"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == ADPS_A :: _64 } # [doc = "Checks if the value of the field is `_128`"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == ADPS_A :: _128 } } # [doc = "Field `ADPS` writer - ADC Prescaler Select Bits"]
pub type ADPS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ADCSRA_SPEC , u8 , ADPS_A , 3 , O > ; impl < 'a , const O : u8 > ADPS_W < 'a , O > { # [doc = "2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (ADPS_A :: _2) } # [doc = "4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut W { self . variant (ADPS_A :: _4) } # [doc = "8"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut W { self . variant (ADPS_A :: _8) } # [doc = "16"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (ADPS_A :: _16) } # [doc = "32"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut W { self . variant (ADPS_A :: _32) } # [doc = "64"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut W { self . variant (ADPS_A :: _64) } # [doc = "128"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut W { self . variant (ADPS_A :: _128) } } # [doc = "Field `ADIE` reader - ADC Interrupt Enable"]
pub type ADIE_R = crate :: BitReader < bool > ; # [doc = "Field `ADIE` writer - ADC Interrupt Enable"]
pub type ADIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; # [doc = "Field `ADIF` reader - ADC Interrupt Flag"]
pub type ADIF_R = crate :: BitReader < bool > ; # [doc = "Field `ADIF` writer - ADC Interrupt Flag"]
pub type ADIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; # [doc = "Field `ADATE` reader - ADC Auto Trigger Enable"]
pub type ADATE_R = crate :: BitReader < bool > ; # [doc = "Field `ADATE` writer - ADC Auto Trigger Enable"]
pub type ADATE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; # [doc = "Field `ADSC` reader - ADC Start Conversion"]
pub type ADSC_R = crate :: BitReader < bool > ; # [doc = "Field `ADSC` writer - ADC Start Conversion"]
pub type ADSC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; # [doc = "Field `ADEN` reader - ADC Enable"]
pub type ADEN_R = crate :: BitReader < bool > ; # [doc = "Field `ADEN` writer - ADC Enable"]
pub type ADEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - ADC Prescaler Select Bits"]
# [inline (always)]
pub fn adps (& self) -> ADPS_R { ADPS_R :: new (self . bits & 7) } # [doc = "Bit 3 - ADC Interrupt Enable"]
# [inline (always)]
pub fn adie (& self) -> ADIE_R { ADIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - ADC Interrupt Flag"]
# [inline (always)]
pub fn adif (& self) -> ADIF_R { ADIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - ADC Auto Trigger Enable"]
# [inline (always)]
pub fn adate (& self) -> ADATE_R { ADATE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - ADC Start Conversion"]
# [inline (always)]
pub fn adsc (& self) -> ADSC_R { ADSC_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - ADC Enable"]
# [inline (always)]
pub fn aden (& self) -> ADEN_R { ADEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - ADC Prescaler Select Bits"]
# [inline (always)]
# [must_use]
pub fn adps (& mut self) -> ADPS_W < 0 > { ADPS_W :: new (self) } # [doc = "Bit 3 - ADC Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn adie (& mut self) -> ADIE_W < 3 > { ADIE_W :: new (self) } # [doc = "Bit 4 - ADC Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn adif (& mut self) -> ADIF_W < 4 > { ADIF_W :: new (self) } # [doc = "Bit 5 - ADC Auto Trigger Enable"]
# [inline (always)]
# [must_use]
pub fn adate (& mut self) -> ADATE_W < 5 > { ADATE_W :: new (self) } # [doc = "Bit 6 - ADC Start Conversion"]
# [inline (always)]
# [must_use]
pub fn adsc (& mut self) -> ADSC_W < 6 > { ADSC_W :: new (self) } # [doc = "Bit 7 - ADC Enable"]
# [inline (always)]
# [must_use]
pub fn aden (& mut self) -> ADEN_W < 7 > { ADEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The ADC Control and Status Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcsra](index.html) module"]
pub struct ADCSRA_SPEC ; impl crate :: RegisterSpec for ADCSRA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcsra::R](R) reader structure"]
impl crate :: Readable for ADCSRA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcsra::W](W) writer structure"]
impl crate :: Writable for ADCSRA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCSRA to value 0"]
impl crate :: Resettable for ADCSRA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCSRB (rw) register accessor: an alias for `Reg<ADCSRB_SPEC>`"]
pub type ADCSRB = crate :: Reg < adcsrb :: ADCSRB_SPEC > ; # [doc = "The ADC Control and Status Register B"]
pub mod adcsrb { # [doc = "Register `ADCSRB` reader"]
pub struct R (crate :: R < ADCSRB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCSRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCSRB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCSRB_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCSRB` writer"]
pub struct W (crate :: W < ADCSRB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCSRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCSRB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCSRB_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADTS` reader - ADC Auto Trigger Source"]
pub type ADTS_R = crate :: FieldReader < u8 , ADTS_A > ; # [doc = "ADC Auto Trigger Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ADTS_A { # [doc = "0: Free Running mode"]
FREE_RUNNING_MODE = 0 , # [doc = "1: Analog Comparator"]
ANALOG_COMPARATOR = 1 , # [doc = "2: External Interrupt Request 0"]
EXTERNAL_INTERRUPT_REQUEST_0 = 2 , # [doc = "3: Timer/Counter0 Compare Match A"]
TIMER_COUNTER0_COMPARE_MATCH_A = 3 , # [doc = "4: Timer/Counter0 Overflow"]
TIMER_COUNTER0_OVERFLOW = 4 , # [doc = "5: Timer/Counter1 Compare Match B"]
TIMER_COUNTER1_COMPARE_MATCH_B = 5 , # [doc = "6: Timer/Counter1 Overflow"]
TIMER_COUNTER1_OVERFLOW = 6 , # [doc = "7: Timer/Counter1 Capture Event"]
TIMER_COUNTER1_CAPTURE_EVENT = 7 , } impl From < ADTS_A > for u8 { # [inline (always)]
fn from (variant : ADTS_A) -> Self { variant as _ } } impl ADTS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADTS_A { match self . bits { 0 => ADTS_A :: FREE_RUNNING_MODE , 1 => ADTS_A :: ANALOG_COMPARATOR , 2 => ADTS_A :: EXTERNAL_INTERRUPT_REQUEST_0 , 3 => ADTS_A :: TIMER_COUNTER0_COMPARE_MATCH_A , 4 => ADTS_A :: TIMER_COUNTER0_OVERFLOW , 5 => ADTS_A :: TIMER_COUNTER1_COMPARE_MATCH_B , 6 => ADTS_A :: TIMER_COUNTER1_OVERFLOW , 7 => ADTS_A :: TIMER_COUNTER1_CAPTURE_EVENT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FREE_RUNNING_MODE`"]
# [inline (always)]
pub fn is_free_running_mode (& self) -> bool { * self == ADTS_A :: FREE_RUNNING_MODE } # [doc = "Checks if the value of the field is `ANALOG_COMPARATOR`"]
# [inline (always)]
pub fn is_analog_comparator (& self) -> bool { * self == ADTS_A :: ANALOG_COMPARATOR } # [doc = "Checks if the value of the field is `EXTERNAL_INTERRUPT_REQUEST_0`"]
# [inline (always)]
pub fn is_external_interrupt_request_0 (& self) -> bool { * self == ADTS_A :: EXTERNAL_INTERRUPT_REQUEST_0 } # [doc = "Checks if the value of the field is `TIMER_COUNTER0_COMPARE_MATCH_A`"]
# [inline (always)]
pub fn is_timer_counter0_compare_match_a (& self) -> bool { * self == ADTS_A :: TIMER_COUNTER0_COMPARE_MATCH_A } # [doc = "Checks if the value of the field is `TIMER_COUNTER0_OVERFLOW`"]
# [inline (always)]
pub fn is_timer_counter0_overflow (& self) -> bool { * self == ADTS_A :: TIMER_COUNTER0_OVERFLOW } # [doc = "Checks if the value of the field is `TIMER_COUNTER1_COMPARE_MATCH_B`"]
# [inline (always)]
pub fn is_timer_counter1_compare_match_b (& self) -> bool { * self == ADTS_A :: TIMER_COUNTER1_COMPARE_MATCH_B } # [doc = "Checks if the value of the field is `TIMER_COUNTER1_OVERFLOW`"]
# [inline (always)]
pub fn is_timer_counter1_overflow (& self) -> bool { * self == ADTS_A :: TIMER_COUNTER1_OVERFLOW } # [doc = "Checks if the value of the field is `TIMER_COUNTER1_CAPTURE_EVENT`"]
# [inline (always)]
pub fn is_timer_counter1_capture_event (& self) -> bool { * self == ADTS_A :: TIMER_COUNTER1_CAPTURE_EVENT } } # [doc = "Field `ADTS` writer - ADC Auto Trigger Source"]
pub type ADTS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ADCSRB_SPEC , u8 , ADTS_A , 3 , O > ; impl < 'a , const O : u8 > ADTS_W < 'a , O > { # [doc = "Free Running mode"]
# [inline (always)]
pub fn free_running_mode (self) -> & 'a mut W { self . variant (ADTS_A :: FREE_RUNNING_MODE) } # [doc = "Analog Comparator"]
# [inline (always)]
pub fn analog_comparator (self) -> & 'a mut W { self . variant (ADTS_A :: ANALOG_COMPARATOR) } # [doc = "External Interrupt Request 0"]
# [inline (always)]
pub fn external_interrupt_request_0 (self) -> & 'a mut W { self . variant (ADTS_A :: EXTERNAL_INTERRUPT_REQUEST_0) } # [doc = "Timer/Counter0 Compare Match A"]
# [inline (always)]
pub fn timer_counter0_compare_match_a (self) -> & 'a mut W { self . variant (ADTS_A :: TIMER_COUNTER0_COMPARE_MATCH_A) } # [doc = "Timer/Counter0 Overflow"]
# [inline (always)]
pub fn timer_counter0_overflow (self) -> & 'a mut W { self . variant (ADTS_A :: TIMER_COUNTER0_OVERFLOW) } # [doc = "Timer/Counter1 Compare Match B"]
# [inline (always)]
pub fn timer_counter1_compare_match_b (self) -> & 'a mut W { self . variant (ADTS_A :: TIMER_COUNTER1_COMPARE_MATCH_B) } # [doc = "Timer/Counter1 Overflow"]
# [inline (always)]
pub fn timer_counter1_overflow (self) -> & 'a mut W { self . variant (ADTS_A :: TIMER_COUNTER1_OVERFLOW) } # [doc = "Timer/Counter1 Capture Event"]
# [inline (always)]
pub fn timer_counter1_capture_event (self) -> & 'a mut W { self . variant (ADTS_A :: TIMER_COUNTER1_CAPTURE_EVENT) } } # [doc = "Field `MUX5` reader - Analog Channel and Gain Selection Bits"]
pub type MUX5_R = crate :: BitReader < bool > ; # [doc = "Field `MUX5` writer - Analog Channel and Gain Selection Bits"]
pub type MUX5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRB_SPEC , bool , O > ; # [doc = "Field `ACCH` reader - Analog Channel Change"]
pub type ACCH_R = crate :: BitReader < bool > ; # [doc = "Field `ACCH` writer - Analog Channel Change"]
pub type ACCH_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRB_SPEC , bool , O > ; # [doc = "Field `REFOK` reader - Reference Voltage OK"]
pub type REFOK_R = crate :: BitReader < bool > ; # [doc = "Field `REFOK` writer - Reference Voltage OK"]
pub type REFOK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRB_SPEC , bool , O > ; # [doc = "Field `ACME` reader - Analog Comparator Multiplexer Enable"]
pub type ACME_R = crate :: BitReader < bool > ; # [doc = "Field `ACME` writer - Analog Comparator Multiplexer Enable"]
pub type ACME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRB_SPEC , bool , O > ; # [doc = "Field `AVDDOK` reader - AVDD Supply Voltage OK"]
pub type AVDDOK_R = crate :: BitReader < bool > ; # [doc = "Field `AVDDOK` writer - AVDD Supply Voltage OK"]
pub type AVDDOK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - ADC Auto Trigger Source"]
# [inline (always)]
pub fn adts (& self) -> ADTS_R { ADTS_R :: new (self . bits & 7) } # [doc = "Bit 3 - Analog Channel and Gain Selection Bits"]
# [inline (always)]
pub fn mux5 (& self) -> MUX5_R { MUX5_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Analog Channel Change"]
# [inline (always)]
pub fn acch (& self) -> ACCH_R { ACCH_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Reference Voltage OK"]
# [inline (always)]
pub fn refok (& self) -> REFOK_R { REFOK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Analog Comparator Multiplexer Enable"]
# [inline (always)]
pub fn acme (& self) -> ACME_R { ACME_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - AVDD Supply Voltage OK"]
# [inline (always)]
pub fn avddok (& self) -> AVDDOK_R { AVDDOK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - ADC Auto Trigger Source"]
# [inline (always)]
# [must_use]
pub fn adts (& mut self) -> ADTS_W < 0 > { ADTS_W :: new (self) } # [doc = "Bit 3 - Analog Channel and Gain Selection Bits"]
# [inline (always)]
# [must_use]
pub fn mux5 (& mut self) -> MUX5_W < 3 > { MUX5_W :: new (self) } # [doc = "Bit 4 - Analog Channel Change"]
# [inline (always)]
# [must_use]
pub fn acch (& mut self) -> ACCH_W < 4 > { ACCH_W :: new (self) } # [doc = "Bit 5 - Reference Voltage OK"]
# [inline (always)]
# [must_use]
pub fn refok (& mut self) -> REFOK_W < 5 > { REFOK_W :: new (self) } # [doc = "Bit 6 - Analog Comparator Multiplexer Enable"]
# [inline (always)]
# [must_use]
pub fn acme (& mut self) -> ACME_W < 6 > { ACME_W :: new (self) } # [doc = "Bit 7 - AVDD Supply Voltage OK"]
# [inline (always)]
# [must_use]
pub fn avddok (& mut self) -> AVDDOK_W < 7 > { AVDDOK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The ADC Control and Status Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcsrb](index.html) module"]
pub struct ADCSRB_SPEC ; impl crate :: RegisterSpec for ADCSRB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcsrb::R](R) reader structure"]
impl crate :: Readable for ADCSRB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcsrb::W](W) writer structure"]
impl crate :: Writable for ADCSRB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCSRB to value 0"]
impl crate :: Resettable for ADCSRB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCSRC (rw) register accessor: an alias for `Reg<ADCSRC_SPEC>`"]
pub type ADCSRC = crate :: Reg < adcsrc :: ADCSRC_SPEC > ; # [doc = "The ADC Control and Status Register C"]
pub mod adcsrc { # [doc = "Register `ADCSRC` reader"]
pub struct R (crate :: R < ADCSRC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCSRC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCSRC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCSRC_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCSRC` writer"]
pub struct W (crate :: W < ADCSRC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCSRC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCSRC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCSRC_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADSUT` reader - ADC Start-up Time"]
pub type ADSUT_R = crate :: FieldReader < u8 , ADSUT_A > ; # [doc = "ADC Start-up Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ADSUT_A { # [doc = "0: 3 ADC clock cycles"]
_3_ADC_CLOCK_CYCLES = 0 , # [doc = "1: 7 ADC clock cycles"]
_7_ADC_CLOCK_CYCLES = 1 , # [doc = "2: 11 ADC clock cycles"]
_11_ADC_CLOCK_CYCLES = 2 , # [doc = "3: 15 ADC clock cycles"]
_15_ADC_CLOCK_CYCLES = 3 , } impl From < ADSUT_A > for u8 { # [inline (always)]
fn from (variant : ADSUT_A) -> Self { variant as _ } } impl ADSUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ADSUT_A > { match self . bits { 0 => Some (ADSUT_A :: _3_ADC_CLOCK_CYCLES) , 1 => Some (ADSUT_A :: _7_ADC_CLOCK_CYCLES) , 2 => Some (ADSUT_A :: _11_ADC_CLOCK_CYCLES) , 3 => Some (ADSUT_A :: _15_ADC_CLOCK_CYCLES) , _ => None , } } # [doc = "Checks if the value of the field is `_3_ADC_CLOCK_CYCLES`"]
# [inline (always)]
pub fn is_3_adc_clock_cycles (& self) -> bool { * self == ADSUT_A :: _3_ADC_CLOCK_CYCLES } # [doc = "Checks if the value of the field is `_7_ADC_CLOCK_CYCLES`"]
# [inline (always)]
pub fn is_7_adc_clock_cycles (& self) -> bool { * self == ADSUT_A :: _7_ADC_CLOCK_CYCLES } # [doc = "Checks if the value of the field is `_11_ADC_CLOCK_CYCLES`"]
# [inline (always)]
pub fn is_11_adc_clock_cycles (& self) -> bool { * self == ADSUT_A :: _11_ADC_CLOCK_CYCLES } # [doc = "Checks if the value of the field is `_15_ADC_CLOCK_CYCLES`"]
# [inline (always)]
pub fn is_15_adc_clock_cycles (& self) -> bool { * self == ADSUT_A :: _15_ADC_CLOCK_CYCLES } } # [doc = "Field `ADSUT` writer - ADC Start-up Time"]
pub type ADSUT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ADCSRC_SPEC , u8 , ADSUT_A , 5 , O > ; impl < 'a , const O : u8 > ADSUT_W < 'a , O > { # [doc = "3 ADC clock cycles"]
# [inline (always)]
pub fn _3_adc_clock_cycles (self) -> & 'a mut W { self . variant (ADSUT_A :: _3_ADC_CLOCK_CYCLES) } # [doc = "7 ADC clock cycles"]
# [inline (always)]
pub fn _7_adc_clock_cycles (self) -> & 'a mut W { self . variant (ADSUT_A :: _7_ADC_CLOCK_CYCLES) } # [doc = "11 ADC clock cycles"]
# [inline (always)]
pub fn _11_adc_clock_cycles (self) -> & 'a mut W { self . variant (ADSUT_A :: _11_ADC_CLOCK_CYCLES) } # [doc = "15 ADC clock cycles"]
# [inline (always)]
pub fn _15_adc_clock_cycles (self) -> & 'a mut W { self . variant (ADSUT_A :: _15_ADC_CLOCK_CYCLES) } } # [doc = "Field `Res0` reader - Reserved"]
pub type RES0_R = crate :: BitReader < bool > ; # [doc = "Field `Res0` writer - Reserved"]
pub type RES0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRC_SPEC , bool , O > ; # [doc = "Field `ADTHT` reader - ADC Track-and-Hold Time"]
pub type ADTHT_R = crate :: FieldReader < u8 , ADTHT_A > ; # [doc = "ADC Track-and-Hold Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ADTHT_A { # [doc = "0: Single ended: 1, differential 3 ADC clock cycles"]
SINGLE_ENDED_1_DIFFERENTIAL_3_ADC_CLOCK_CYCLES = 0 , # [doc = "1: Single ended: 2, differential 5 ADC clock cycles"]
SINGLE_ENDED_2_DIFFERENTIAL_5_ADC_CLOCK_CYCLES = 1 , # [doc = "2: Single ended: 3, differential 7 ADC clock cycles"]
SINGLE_ENDED_3_DIFFERENTIAL_7_ADC_CLOCK_CYCLES = 2 , # [doc = "3: Single ended: 4, differential 9 ADC clock cycles"]
SINGLE_ENDED_4_DIFFERENTIAL_9_ADC_CLOCK_CYCLES = 3 , } impl From < ADTHT_A > for u8 { # [inline (always)]
fn from (variant : ADTHT_A) -> Self { variant as _ } } impl ADTHT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADTHT_A { match self . bits { 0 => ADTHT_A :: SINGLE_ENDED_1_DIFFERENTIAL_3_ADC_CLOCK_CYCLES , 1 => ADTHT_A :: SINGLE_ENDED_2_DIFFERENTIAL_5_ADC_CLOCK_CYCLES , 2 => ADTHT_A :: SINGLE_ENDED_3_DIFFERENTIAL_7_ADC_CLOCK_CYCLES , 3 => ADTHT_A :: SINGLE_ENDED_4_DIFFERENTIAL_9_ADC_CLOCK_CYCLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `SINGLE_ENDED_1_DIFFERENTIAL_3_ADC_CLOCK_CYCLES`"]
# [inline (always)]
pub fn is_single_ended_1_differential_3_adc_clock_cycles (& self) -> bool { * self == ADTHT_A :: SINGLE_ENDED_1_DIFFERENTIAL_3_ADC_CLOCK_CYCLES } # [doc = "Checks if the value of the field is `SINGLE_ENDED_2_DIFFERENTIAL_5_ADC_CLOCK_CYCLES`"]
# [inline (always)]
pub fn is_single_ended_2_differential_5_adc_clock_cycles (& self) -> bool { * self == ADTHT_A :: SINGLE_ENDED_2_DIFFERENTIAL_5_ADC_CLOCK_CYCLES } # [doc = "Checks if the value of the field is `SINGLE_ENDED_3_DIFFERENTIAL_7_ADC_CLOCK_CYCLES`"]
# [inline (always)]
pub fn is_single_ended_3_differential_7_adc_clock_cycles (& self) -> bool { * self == ADTHT_A :: SINGLE_ENDED_3_DIFFERENTIAL_7_ADC_CLOCK_CYCLES } # [doc = "Checks if the value of the field is `SINGLE_ENDED_4_DIFFERENTIAL_9_ADC_CLOCK_CYCLES`"]
# [inline (always)]
pub fn is_single_ended_4_differential_9_adc_clock_cycles (& self) -> bool { * self == ADTHT_A :: SINGLE_ENDED_4_DIFFERENTIAL_9_ADC_CLOCK_CYCLES } } # [doc = "Field `ADTHT` writer - ADC Track-and-Hold Time"]
pub type ADTHT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ADCSRC_SPEC , u8 , ADTHT_A , 2 , O > ; impl < 'a , const O : u8 > ADTHT_W < 'a , O > { # [doc = "Single ended: 1, differential 3 ADC clock cycles"]
# [inline (always)]
pub fn single_ended_1_differential_3_adc_clock_cycles (self) -> & 'a mut W { self . variant (ADTHT_A :: SINGLE_ENDED_1_DIFFERENTIAL_3_ADC_CLOCK_CYCLES) } # [doc = "Single ended: 2, differential 5 ADC clock cycles"]
# [inline (always)]
pub fn single_ended_2_differential_5_adc_clock_cycles (self) -> & 'a mut W { self . variant (ADTHT_A :: SINGLE_ENDED_2_DIFFERENTIAL_5_ADC_CLOCK_CYCLES) } # [doc = "Single ended: 3, differential 7 ADC clock cycles"]
# [inline (always)]
pub fn single_ended_3_differential_7_adc_clock_cycles (self) -> & 'a mut W { self . variant (ADTHT_A :: SINGLE_ENDED_3_DIFFERENTIAL_7_ADC_CLOCK_CYCLES) } # [doc = "Single ended: 4, differential 9 ADC clock cycles"]
# [inline (always)]
pub fn single_ended_4_differential_9_adc_clock_cycles (self) -> & 'a mut W { self . variant (ADTHT_A :: SINGLE_ENDED_4_DIFFERENTIAL_9_ADC_CLOCK_CYCLES) } } impl R { # [doc = "Bits 0:4 - ADC Start-up Time"]
# [inline (always)]
pub fn adsut (& self) -> ADSUT_R { ADSUT_R :: new (self . bits & 0x1f) } # [doc = "Bit 5 - Reserved"]
# [inline (always)]
pub fn res0 (& self) -> RES0_R { RES0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - ADC Track-and-Hold Time"]
# [inline (always)]
pub fn adtht (& self) -> ADTHT_R { ADTHT_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:4 - ADC Start-up Time"]
# [inline (always)]
# [must_use]
pub fn adsut (& mut self) -> ADSUT_W < 0 > { ADSUT_W :: new (self) } # [doc = "Bit 5 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res0 (& mut self) -> RES0_W < 5 > { RES0_W :: new (self) } # [doc = "Bits 6:7 - ADC Track-and-Hold Time"]
# [inline (always)]
# [must_use]
pub fn adtht (& mut self) -> ADTHT_W < 6 > { ADTHT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The ADC Control and Status Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcsrc](index.html) module"]
pub struct ADCSRC_SPEC ; impl crate :: RegisterSpec for ADCSRC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcsrc::R](R) reader structure"]
impl crate :: Readable for ADCSRC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcsrc::W](W) writer structure"]
impl crate :: Writable for ADCSRC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCSRC to value 0"]
impl crate :: Resettable for ADCSRC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADMUX (rw) register accessor: an alias for `Reg<ADMUX_SPEC>`"]
pub type ADMUX = crate :: Reg < admux :: ADMUX_SPEC > ; # [doc = "The ADC Multiplexer Selection Register"]
pub mod admux { # [doc = "Register `ADMUX` reader"]
pub struct R (crate :: R < ADMUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADMUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADMUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADMUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADMUX` writer"]
pub struct W (crate :: W < ADMUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADMUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADMUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADMUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUX` reader - Analog Channel and Gain Selection Bits"]
pub type MUX_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MUX` writer - Analog Channel and Gain Selection Bits"]
pub type MUX_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ADMUX_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `ADLAR` reader - ADC Left Adjust Result"]
pub type ADLAR_R = crate :: BitReader < bool > ; # [doc = "Field `ADLAR` writer - ADC Left Adjust Result"]
pub type ADLAR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADMUX_SPEC , bool , O > ; # [doc = "Field `REFS` reader - Reference Selection Bits"]
pub type REFS_R = crate :: FieldReader < u8 , REFS_A > ; # [doc = "Reference Selection Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFS_A { # [doc = "0: AREF, Internal reference voltage generation turned off"]
AREF_INTERNAL_REFERENCE_VOLTAGE_GENERATION_TURNED_OFF = 0 , # [doc = "1: AVDD with external capacitor at AREF pin"]
AVDD_WITH_EXTERNAL_CAPACITOR_AT_AREF_PIN = 1 , # [doc = "2: Internal 1.5V Voltage Reference (no external capacitor at AREF pin)"]
INTERNAL_1_5V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN = 2 , # [doc = "3: Internal 1.6V Voltage Reference (no external capacitor at AREF pin)"]
INTERNAL_1_6V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN = 3 , } impl From < REFS_A > for u8 { # [inline (always)]
fn from (variant : REFS_A) -> Self { variant as _ } } impl REFS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> REFS_A { match self . bits { 0 => REFS_A :: AREF_INTERNAL_REFERENCE_VOLTAGE_GENERATION_TURNED_OFF , 1 => REFS_A :: AVDD_WITH_EXTERNAL_CAPACITOR_AT_AREF_PIN , 2 => REFS_A :: INTERNAL_1_5V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN , 3 => REFS_A :: INTERNAL_1_6V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `AREF_INTERNAL_REFERENCE_VOLTAGE_GENERATION_TURNED_OFF`"]
# [inline (always)]
pub fn is_aref_internal_reference_voltage_generation_turned_off (& self) -> bool { * self == REFS_A :: AREF_INTERNAL_REFERENCE_VOLTAGE_GENERATION_TURNED_OFF } # [doc = "Checks if the value of the field is `AVDD_WITH_EXTERNAL_CAPACITOR_AT_AREF_PIN`"]
# [inline (always)]
pub fn is_avdd_with_external_capacitor_at_aref_pin (& self) -> bool { * self == REFS_A :: AVDD_WITH_EXTERNAL_CAPACITOR_AT_AREF_PIN } # [doc = "Checks if the value of the field is `INTERNAL_1_5V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN`"]
# [inline (always)]
pub fn is_internal_1_5v_voltage_reference_no_external_capacitor_at_aref_pin (& self) -> bool { * self == REFS_A :: INTERNAL_1_5V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN } # [doc = "Checks if the value of the field is `INTERNAL_1_6V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN`"]
# [inline (always)]
pub fn is_internal_1_6v_voltage_reference_no_external_capacitor_at_aref_pin (& self) -> bool { * self == REFS_A :: INTERNAL_1_6V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN } } # [doc = "Field `REFS` writer - Reference Selection Bits"]
pub type REFS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ADMUX_SPEC , u8 , REFS_A , 2 , O > ; impl < 'a , const O : u8 > REFS_W < 'a , O > { # [doc = "AREF, Internal reference voltage generation turned off"]
# [inline (always)]
pub fn aref_internal_reference_voltage_generation_turned_off (self) -> & 'a mut W { self . variant (REFS_A :: AREF_INTERNAL_REFERENCE_VOLTAGE_GENERATION_TURNED_OFF) } # [doc = "AVDD with external capacitor at AREF pin"]
# [inline (always)]
pub fn avdd_with_external_capacitor_at_aref_pin (self) -> & 'a mut W { self . variant (REFS_A :: AVDD_WITH_EXTERNAL_CAPACITOR_AT_AREF_PIN) } # [doc = "Internal 1.5V Voltage Reference (no external capacitor at AREF pin)"]
# [inline (always)]
pub fn internal_1_5v_voltage_reference_no_external_capacitor_at_aref_pin (self) -> & 'a mut W { self . variant (REFS_A :: INTERNAL_1_5V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN) } # [doc = "Internal 1.6V Voltage Reference (no external capacitor at AREF pin)"]
# [inline (always)]
pub fn internal_1_6v_voltage_reference_no_external_capacitor_at_aref_pin (self) -> & 'a mut W { self . variant (REFS_A :: INTERNAL_1_6V_VOLTAGE_REFERENCE_NO_EXTERNAL_CAPACITOR_AT_AREF_PIN) } } impl R { # [doc = "Bits 0:4 - Analog Channel and Gain Selection Bits"]
# [inline (always)]
pub fn mux (& self) -> MUX_R { MUX_R :: new (self . bits & 0x1f) } # [doc = "Bit 5 - ADC Left Adjust Result"]
# [inline (always)]
pub fn adlar (& self) -> ADLAR_R { ADLAR_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Reference Selection Bits"]
# [inline (always)]
pub fn refs (& self) -> REFS_R { REFS_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:4 - Analog Channel and Gain Selection Bits"]
# [inline (always)]
# [must_use]
pub fn mux (& mut self) -> MUX_W < 0 > { MUX_W :: new (self) } # [doc = "Bit 5 - ADC Left Adjust Result"]
# [inline (always)]
# [must_use]
pub fn adlar (& mut self) -> ADLAR_W < 5 > { ADLAR_W :: new (self) } # [doc = "Bits 6:7 - Reference Selection Bits"]
# [inline (always)]
# [must_use]
pub fn refs (& mut self) -> REFS_W < 6 > { REFS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The ADC Multiplexer Selection Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [admux](index.html) module"]
pub struct ADMUX_SPEC ; impl crate :: RegisterSpec for ADMUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [admux::R](R) reader structure"]
impl crate :: Readable for ADMUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [admux::W](W) writer structure"]
impl crate :: Writable for ADMUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADMUX to value 0"]
impl crate :: Resettable for ADMUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIDR0 (rw) register accessor: an alias for `Reg<DIDR0_SPEC>`"]
pub type DIDR0 = crate :: Reg < didr0 :: DIDR0_SPEC > ; # [doc = "Digital Input Disable Register 0"]
pub mod didr0 { # [doc = "Register `DIDR0` reader"]
pub struct R (crate :: R < DIDR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIDR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIDR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIDR0` writer"]
pub struct W (crate :: W < DIDR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIDR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIDR0_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADC0D` reader - Disable ADC7:0 Digital Input"]
pub type ADC0D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC0D` writer - Disable ADC7:0 Digital Input"]
pub type ADC0D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC1D` reader - Disable ADC7:0 Digital Input"]
pub type ADC1D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC1D` writer - Disable ADC7:0 Digital Input"]
pub type ADC1D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC2D` reader - Disable ADC7:0 Digital Input"]
pub type ADC2D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC2D` writer - Disable ADC7:0 Digital Input"]
pub type ADC2D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC3D` reader - Disable ADC7:0 Digital Input"]
pub type ADC3D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC3D` writer - Disable ADC7:0 Digital Input"]
pub type ADC3D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC4D` reader - Disable ADC7:0 Digital Input"]
pub type ADC4D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC4D` writer - Disable ADC7:0 Digital Input"]
pub type ADC4D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC5D` reader - Disable ADC7:0 Digital Input"]
pub type ADC5D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC5D` writer - Disable ADC7:0 Digital Input"]
pub type ADC5D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC6D` reader - Disable ADC7:0 Digital Input"]
pub type ADC6D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC6D` writer - Disable ADC7:0 Digital Input"]
pub type ADC6D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC7D` reader - Disable ADC7:0 Digital Input"]
pub type ADC7D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC7D` writer - Disable ADC7:0 Digital Input"]
pub type ADC7D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Disable ADC7:0 Digital Input"]
# [inline (always)]
pub fn adc0d (& self) -> ADC0D_R { ADC0D_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Disable ADC7:0 Digital Input"]
# [inline (always)]
pub fn adc1d (& self) -> ADC1D_R { ADC1D_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Disable ADC7:0 Digital Input"]
# [inline (always)]
pub fn adc2d (& self) -> ADC2D_R { ADC2D_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Disable ADC7:0 Digital Input"]
# [inline (always)]
pub fn adc3d (& self) -> ADC3D_R { ADC3D_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Disable ADC7:0 Digital Input"]
# [inline (always)]
pub fn adc4d (& self) -> ADC4D_R { ADC4D_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Disable ADC7:0 Digital Input"]
# [inline (always)]
pub fn adc5d (& self) -> ADC5D_R { ADC5D_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Disable ADC7:0 Digital Input"]
# [inline (always)]
pub fn adc6d (& self) -> ADC6D_R { ADC6D_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Disable ADC7:0 Digital Input"]
# [inline (always)]
pub fn adc7d (& self) -> ADC7D_R { ADC7D_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Disable ADC7:0 Digital Input"]
# [inline (always)]
# [must_use]
pub fn adc0d (& mut self) -> ADC0D_W < 0 > { ADC0D_W :: new (self) } # [doc = "Bit 1 - Disable ADC7:0 Digital Input"]
# [inline (always)]
# [must_use]
pub fn adc1d (& mut self) -> ADC1D_W < 1 > { ADC1D_W :: new (self) } # [doc = "Bit 2 - Disable ADC7:0 Digital Input"]
# [inline (always)]
# [must_use]
pub fn adc2d (& mut self) -> ADC2D_W < 2 > { ADC2D_W :: new (self) } # [doc = "Bit 3 - Disable ADC7:0 Digital Input"]
# [inline (always)]
# [must_use]
pub fn adc3d (& mut self) -> ADC3D_W < 3 > { ADC3D_W :: new (self) } # [doc = "Bit 4 - Disable ADC7:0 Digital Input"]
# [inline (always)]
# [must_use]
pub fn adc4d (& mut self) -> ADC4D_W < 4 > { ADC4D_W :: new (self) } # [doc = "Bit 5 - Disable ADC7:0 Digital Input"]
# [inline (always)]
# [must_use]
pub fn adc5d (& mut self) -> ADC5D_W < 5 > { ADC5D_W :: new (self) } # [doc = "Bit 6 - Disable ADC7:0 Digital Input"]
# [inline (always)]
# [must_use]
pub fn adc6d (& mut self) -> ADC6D_W < 6 > { ADC6D_W :: new (self) } # [doc = "Bit 7 - Disable ADC7:0 Digital Input"]
# [inline (always)]
# [must_use]
pub fn adc7d (& mut self) -> ADC7D_W < 7 > { ADC7D_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Digital Input Disable Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [didr0](index.html) module"]
pub struct DIDR0_SPEC ; impl crate :: RegisterSpec for DIDR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [didr0::R](R) reader structure"]
impl crate :: Readable for DIDR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [didr0::W](W) writer structure"]
impl crate :: Writable for DIDR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIDR0 to value 0"]
impl crate :: Resettable for DIDR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIDR2 (rw) register accessor: an alias for `Reg<DIDR2_SPEC>`"]
pub type DIDR2 = crate :: Reg < didr2 :: DIDR2_SPEC > ; # [doc = "Digital Input Disable Register 2"]
pub mod didr2 { # [doc = "Register `DIDR2` reader"]
pub struct R (crate :: R < DIDR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIDR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIDR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIDR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIDR2` writer"]
pub struct W (crate :: W < DIDR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIDR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIDR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIDR2_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADC8D` reader - Reserved Bits"]
pub type ADC8D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC8D` writer - Reserved Bits"]
pub type ADC8D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR2_SPEC , bool , O > ; # [doc = "Field `ADC9D` reader - Reserved Bits"]
pub type ADC9D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC9D` writer - Reserved Bits"]
pub type ADC9D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR2_SPEC , bool , O > ; # [doc = "Field `ADC10D` reader - Reserved Bits"]
pub type ADC10D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC10D` writer - Reserved Bits"]
pub type ADC10D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR2_SPEC , bool , O > ; # [doc = "Field `ADC11D` reader - Reserved Bits"]
pub type ADC11D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC11D` writer - Reserved Bits"]
pub type ADC11D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR2_SPEC , bool , O > ; # [doc = "Field `ADC12D` reader - Reserved Bits"]
pub type ADC12D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC12D` writer - Reserved Bits"]
pub type ADC12D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR2_SPEC , bool , O > ; # [doc = "Field `ADC13D` reader - Reserved Bits"]
pub type ADC13D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC13D` writer - Reserved Bits"]
pub type ADC13D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR2_SPEC , bool , O > ; # [doc = "Field `ADC14D` reader - Reserved Bits"]
pub type ADC14D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC14D` writer - Reserved Bits"]
pub type ADC14D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR2_SPEC , bool , O > ; # [doc = "Field `ADC15D` reader - Reserved Bits"]
pub type ADC15D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC15D` writer - Reserved Bits"]
pub type ADC15D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR2_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Reserved Bits"]
# [inline (always)]
pub fn adc8d (& self) -> ADC8D_R { ADC8D_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Reserved Bits"]
# [inline (always)]
pub fn adc9d (& self) -> ADC9D_R { ADC9D_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Reserved Bits"]
# [inline (always)]
pub fn adc10d (& self) -> ADC10D_R { ADC10D_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Reserved Bits"]
# [inline (always)]
pub fn adc11d (& self) -> ADC11D_R { ADC11D_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Reserved Bits"]
# [inline (always)]
pub fn adc12d (& self) -> ADC12D_R { ADC12D_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Reserved Bits"]
# [inline (always)]
pub fn adc13d (& self) -> ADC13D_R { ADC13D_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Reserved Bits"]
# [inline (always)]
pub fn adc14d (& self) -> ADC14D_R { ADC14D_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Reserved Bits"]
# [inline (always)]
pub fn adc15d (& self) -> ADC15D_R { ADC15D_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Reserved Bits"]
# [inline (always)]
# [must_use]
pub fn adc8d (& mut self) -> ADC8D_W < 0 > { ADC8D_W :: new (self) } # [doc = "Bit 1 - Reserved Bits"]
# [inline (always)]
# [must_use]
pub fn adc9d (& mut self) -> ADC9D_W < 1 > { ADC9D_W :: new (self) } # [doc = "Bit 2 - Reserved Bits"]
# [inline (always)]
# [must_use]
pub fn adc10d (& mut self) -> ADC10D_W < 2 > { ADC10D_W :: new (self) } # [doc = "Bit 3 - Reserved Bits"]
# [inline (always)]
# [must_use]
pub fn adc11d (& mut self) -> ADC11D_W < 3 > { ADC11D_W :: new (self) } # [doc = "Bit 4 - Reserved Bits"]
# [inline (always)]
# [must_use]
pub fn adc12d (& mut self) -> ADC12D_W < 4 > { ADC12D_W :: new (self) } # [doc = "Bit 5 - Reserved Bits"]
# [inline (always)]
# [must_use]
pub fn adc13d (& mut self) -> ADC13D_W < 5 > { ADC13D_W :: new (self) } # [doc = "Bit 6 - Reserved Bits"]
# [inline (always)]
# [must_use]
pub fn adc14d (& mut self) -> ADC14D_W < 6 > { ADC14D_W :: new (self) } # [doc = "Bit 7 - Reserved Bits"]
# [inline (always)]
# [must_use]
pub fn adc15d (& mut self) -> ADC15D_W < 7 > { ADC15D_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Digital Input Disable Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [didr2](index.html) module"]
pub struct DIDR2_SPEC ; impl crate :: RegisterSpec for DIDR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [didr2::R](R) reader structure"]
impl crate :: Readable for DIDR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [didr2::W](W) writer structure"]
impl crate :: Writable for DIDR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIDR2 to value 0"]
impl crate :: Resettable for DIDR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Bootloader"]
pub struct BOOT_LOAD { _marker : PhantomData < * const () > } unsafe impl Send for BOOT_LOAD { } impl BOOT_LOAD { # [doc = r"Pointer to the register block"]
pub const PTR : * const boot_load :: RegisterBlock = 0x57 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const boot_load :: RegisterBlock { Self :: PTR } } impl Deref for BOOT_LOAD { type Target = boot_load :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for BOOT_LOAD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("BOOT_LOAD") . finish () } } # [doc = "Bootloader"]
pub mod boot_load { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Store Program Memory Control Register"]
pub spmcsr : SPMCSR , } # [doc = "SPMCSR (rw) register accessor: an alias for `Reg<SPMCSR_SPEC>`"]
pub type SPMCSR = crate :: Reg < spmcsr :: SPMCSR_SPEC > ; # [doc = "Store Program Memory Control Register"]
pub mod spmcsr { # [doc = "Register `SPMCSR` reader"]
pub struct R (crate :: R < SPMCSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPMCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPMCSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPMCSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPMCSR` writer"]
pub struct W (crate :: W < SPMCSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPMCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPMCSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPMCSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPMEN` reader - Store Program Memory Enable"]
pub type SPMEN_R = crate :: BitReader < bool > ; # [doc = "Field `SPMEN` writer - Store Program Memory Enable"]
pub type SPMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `PGERS` reader - Page Erase"]
pub type PGERS_R = crate :: BitReader < bool > ; # [doc = "Field `PGERS` writer - Page Erase"]
pub type PGERS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `PGWRT` reader - Page Write"]
pub type PGWRT_R = crate :: BitReader < bool > ; # [doc = "Field `PGWRT` writer - Page Write"]
pub type PGWRT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `BLBSET` reader - Boot Lock Bit Set"]
pub type BLBSET_R = crate :: BitReader < bool > ; # [doc = "Field `BLBSET` writer - Boot Lock Bit Set"]
pub type BLBSET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `RWWSRE` reader - Read While Write Section Read Enable"]
pub type RWWSRE_R = crate :: BitReader < bool > ; # [doc = "Field `RWWSRE` writer - Read While Write Section Read Enable"]
pub type RWWSRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `SIGRD` reader - Signature Row Read"]
pub type SIGRD_R = crate :: BitReader < bool > ; # [doc = "Field `SIGRD` writer - Signature Row Read"]
pub type SIGRD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `RWWSB` reader - Read While Write Section Busy"]
pub type RWWSB_R = crate :: BitReader < bool > ; # [doc = "Field `RWWSB` writer - Read While Write Section Busy"]
pub type RWWSB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `SPMIE` reader - SPM Interrupt Enable"]
pub type SPMIE_R = crate :: BitReader < bool > ; # [doc = "Field `SPMIE` writer - SPM Interrupt Enable"]
pub type SPMIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Store Program Memory Enable"]
# [inline (always)]
pub fn spmen (& self) -> SPMEN_R { SPMEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Page Erase"]
# [inline (always)]
pub fn pgers (& self) -> PGERS_R { PGERS_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Page Write"]
# [inline (always)]
pub fn pgwrt (& self) -> PGWRT_R { PGWRT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Boot Lock Bit Set"]
# [inline (always)]
pub fn blbset (& self) -> BLBSET_R { BLBSET_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Read While Write Section Read Enable"]
# [inline (always)]
pub fn rwwsre (& self) -> RWWSRE_R { RWWSRE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Signature Row Read"]
# [inline (always)]
pub fn sigrd (& self) -> SIGRD_R { SIGRD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Read While Write Section Busy"]
# [inline (always)]
pub fn rwwsb (& self) -> RWWSB_R { RWWSB_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - SPM Interrupt Enable"]
# [inline (always)]
pub fn spmie (& self) -> SPMIE_R { SPMIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Store Program Memory Enable"]
# [inline (always)]
# [must_use]
pub fn spmen (& mut self) -> SPMEN_W < 0 > { SPMEN_W :: new (self) } # [doc = "Bit 1 - Page Erase"]
# [inline (always)]
# [must_use]
pub fn pgers (& mut self) -> PGERS_W < 1 > { PGERS_W :: new (self) } # [doc = "Bit 2 - Page Write"]
# [inline (always)]
# [must_use]
pub fn pgwrt (& mut self) -> PGWRT_W < 2 > { PGWRT_W :: new (self) } # [doc = "Bit 3 - Boot Lock Bit Set"]
# [inline (always)]
# [must_use]
pub fn blbset (& mut self) -> BLBSET_W < 3 > { BLBSET_W :: new (self) } # [doc = "Bit 4 - Read While Write Section Read Enable"]
# [inline (always)]
# [must_use]
pub fn rwwsre (& mut self) -> RWWSRE_W < 4 > { RWWSRE_W :: new (self) } # [doc = "Bit 5 - Signature Row Read"]
# [inline (always)]
# [must_use]
pub fn sigrd (& mut self) -> SIGRD_W < 5 > { SIGRD_W :: new (self) } # [doc = "Bit 6 - Read While Write Section Busy"]
# [inline (always)]
# [must_use]
pub fn rwwsb (& mut self) -> RWWSB_W < 6 > { RWWSB_W :: new (self) } # [doc = "Bit 7 - SPM Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn spmie (& mut self) -> SPMIE_W < 7 > { SPMIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Store Program Memory Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spmcsr](index.html) module"]
pub struct SPMCSR_SPEC ; impl crate :: RegisterSpec for SPMCSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spmcsr::R](R) reader structure"]
impl crate :: Readable for SPMCSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spmcsr::W](W) writer structure"]
impl crate :: Writable for SPMCSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPMCSR to value 0"]
impl crate :: Resettable for SPMCSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "CPU Registers"]
pub struct CPU { _marker : PhantomData < * const () > } unsafe impl Send for CPU { } impl CPU { # [doc = r"Pointer to the register block"]
pub const PTR : * const cpu :: RegisterBlock = 0x3e as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const cpu :: RegisterBlock { Self :: PTR } } impl Deref for CPU { type Target = cpu :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CPU { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CPU") . finish () } } # [doc = "CPU Registers"]
pub mod cpu { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - General Purpose IO Register 0"]
pub gpior0 : GPIOR0 , _reserved1 : [u8 ; 0x0b]
, # [doc = "0x0c - General Purpose IO Register 1"]
pub gpior1 : GPIOR1 , # [doc = "0x0d - General Purpose I/O Register 2"]
pub gpior2 : GPIOR2 , _reserved3 : [u8 ; 0x07]
, # [doc = "0x15 - Sleep Mode Control Register"]
pub smcr : SMCR , # [doc = "0x16 - MCU Status Register"]
pub mcusr : MCUSR , # [doc = "0x17 - MCU Control Register"]
pub mcucr : MCUCR , _reserved6 : [u8 ; 0x05]
, # [doc = "0x1d - Extended Z-pointer Register for ELPM/SPM"]
pub rampz : RAMPZ , _reserved7 : [u8 ; 0x05]
, # [doc = "0x23 - Clock Prescale Register"]
pub clkpr : CLKPR , _reserved8 : [u8 ; 0x01]
, # [doc = "0x25 - Power Reduction Register 2"]
pub prr2 : PRR2 , # [doc = "0x26 - Power Reduction Register0"]
pub prr0 : PRR0 , # [doc = "0x27 - Power Reduction Register 1"]
pub prr1 : PRR1 , # [doc = "0x28 - Oscillator Calibration Value"]
pub osccal : OSCCAL , } # [doc = "CLKPR (rw) register accessor: an alias for `Reg<CLKPR_SPEC>`"]
pub type CLKPR = crate :: Reg < clkpr :: CLKPR_SPEC > ; # [doc = "Clock Prescale Register"]
pub mod clkpr { # [doc = "Register `CLKPR` reader"]
pub struct R (crate :: R < CLKPR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKPR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKPR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKPR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKPR` writer"]
pub struct W (crate :: W < CLKPR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKPR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKPR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKPR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKPS` reader - Clock Prescaler Select Bits"]
pub type CLKPS_R = crate :: FieldReader < u8 , CLKPS_A > ; # [doc = "Clock Prescaler Select Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKPS_A { # [doc = "0: Division factor 1 / RC-Oscillator 2"]
DIVISION_FACTOR_1_RC_OSCILLATOR_2 = 0 , # [doc = "1: Division factor 2 / RC-Oscillator 4"]
DIVISION_FACTOR_2_RC_OSCILLATOR_4 = 1 , # [doc = "2: Division factor 4 / RC-Oscillator 8"]
DIVISION_FACTOR_4_RC_OSCILLATOR_8 = 2 , # [doc = "3: Division factor 8 / RC-Oscillator 16"]
DIVISION_FACTOR_8_RC_OSCILLATOR_16 = 3 , # [doc = "4: Division factor 16 / RC-Oscillator 32"]
DIVISION_FACTOR_16_RC_OSCILLATOR_32 = 4 , # [doc = "5: Division factor 32 / RC-Oscillator 64"]
DIVISION_FACTOR_32_RC_OSCILLATOR_64 = 5 , # [doc = "6: Division factor 64 / RC-Oscillator 128"]
DIVISION_FACTOR_64_RC_OSCILLATOR_128 = 6 , # [doc = "7: Division factor 128 / RC-Oscillator 256"]
DIVISION_FACTOR_128_RC_OSCILLATOR_256 = 7 , # [doc = "8: Division factor 256 / RC-Oscillator 512"]
DIVISION_FACTOR_256_RC_OSCILLATOR_512 = 8 , # [doc = "15: Division factor 1 only permitted for RC-Oscillator. Flash and EEPROM programming is not allowed."]
DIVISION_FACTOR_1_ONLY_PERMITTED_FOR_RC_OSCILLATOR_FLASH_AND_EEPROM_PROGRAMMING_IS_NOT_ALLOWED = 15 , } impl From < CLKPS_A > for u8 { # [inline (always)]
fn from (variant : CLKPS_A) -> Self { variant as _ } } impl CLKPS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKPS_A > { match self . bits { 0 => Some (CLKPS_A :: DIVISION_FACTOR_1_RC_OSCILLATOR_2) , 1 => Some (CLKPS_A :: DIVISION_FACTOR_2_RC_OSCILLATOR_4) , 2 => Some (CLKPS_A :: DIVISION_FACTOR_4_RC_OSCILLATOR_8) , 3 => Some (CLKPS_A :: DIVISION_FACTOR_8_RC_OSCILLATOR_16) , 4 => Some (CLKPS_A :: DIVISION_FACTOR_16_RC_OSCILLATOR_32) , 5 => Some (CLKPS_A :: DIVISION_FACTOR_32_RC_OSCILLATOR_64) , 6 => Some (CLKPS_A :: DIVISION_FACTOR_64_RC_OSCILLATOR_128) , 7 => Some (CLKPS_A :: DIVISION_FACTOR_128_RC_OSCILLATOR_256) , 8 => Some (CLKPS_A :: DIVISION_FACTOR_256_RC_OSCILLATOR_512) , 15 => Some (CLKPS_A :: DIVISION_FACTOR_1_ONLY_PERMITTED_FOR_RC_OSCILLATOR_FLASH_AND_EEPROM_PROGRAMMING_IS_NOT_ALLOWED) , _ => None , } } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_1_RC_OSCILLATOR_2`"]
# [inline (always)]
pub fn is_division_factor_1_rc_oscillator_2 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_1_RC_OSCILLATOR_2 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_2_RC_OSCILLATOR_4`"]
# [inline (always)]
pub fn is_division_factor_2_rc_oscillator_4 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_2_RC_OSCILLATOR_4 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_4_RC_OSCILLATOR_8`"]
# [inline (always)]
pub fn is_division_factor_4_rc_oscillator_8 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_4_RC_OSCILLATOR_8 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_8_RC_OSCILLATOR_16`"]
# [inline (always)]
pub fn is_division_factor_8_rc_oscillator_16 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_8_RC_OSCILLATOR_16 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_16_RC_OSCILLATOR_32`"]
# [inline (always)]
pub fn is_division_factor_16_rc_oscillator_32 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_16_RC_OSCILLATOR_32 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_32_RC_OSCILLATOR_64`"]
# [inline (always)]
pub fn is_division_factor_32_rc_oscillator_64 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_32_RC_OSCILLATOR_64 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_64_RC_OSCILLATOR_128`"]
# [inline (always)]
pub fn is_division_factor_64_rc_oscillator_128 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_64_RC_OSCILLATOR_128 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_128_RC_OSCILLATOR_256`"]
# [inline (always)]
pub fn is_division_factor_128_rc_oscillator_256 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_128_RC_OSCILLATOR_256 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_256_RC_OSCILLATOR_512`"]
# [inline (always)]
pub fn is_division_factor_256_rc_oscillator_512 (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_256_RC_OSCILLATOR_512 } # [doc = "Checks if the value of the field is `DIVISION_FACTOR_1_ONLY_PERMITTED_FOR_RC_OSCILLATOR_FLASH_AND_EEPROM_PROGRAMMING_IS_NOT_ALLOWED`"]
# [inline (always)]
pub fn is_division_factor_1_only_permitted_for_rc_oscillator_flash_and_eeprom_programming_is_not_allowed (& self) -> bool { * self == CLKPS_A :: DIVISION_FACTOR_1_ONLY_PERMITTED_FOR_RC_OSCILLATOR_FLASH_AND_EEPROM_PROGRAMMING_IS_NOT_ALLOWED } } # [doc = "Field `CLKPS` writer - Clock Prescaler Select Bits"]
pub type CLKPS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CLKPR_SPEC , u8 , CLKPS_A , 4 , O > ; impl < 'a , const O : u8 > CLKPS_W < 'a , O > { # [doc = "Division factor 1 / RC-Oscillator 2"]
# [inline (always)]
pub fn division_factor_1_rc_oscillator_2 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_1_RC_OSCILLATOR_2) } # [doc = "Division factor 2 / RC-Oscillator 4"]
# [inline (always)]
pub fn division_factor_2_rc_oscillator_4 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_2_RC_OSCILLATOR_4) } # [doc = "Division factor 4 / RC-Oscillator 8"]
# [inline (always)]
pub fn division_factor_4_rc_oscillator_8 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_4_RC_OSCILLATOR_8) } # [doc = "Division factor 8 / RC-Oscillator 16"]
# [inline (always)]
pub fn division_factor_8_rc_oscillator_16 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_8_RC_OSCILLATOR_16) } # [doc = "Division factor 16 / RC-Oscillator 32"]
# [inline (always)]
pub fn division_factor_16_rc_oscillator_32 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_16_RC_OSCILLATOR_32) } # [doc = "Division factor 32 / RC-Oscillator 64"]
# [inline (always)]
pub fn division_factor_32_rc_oscillator_64 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_32_RC_OSCILLATOR_64) } # [doc = "Division factor 64 / RC-Oscillator 128"]
# [inline (always)]
pub fn division_factor_64_rc_oscillator_128 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_64_RC_OSCILLATOR_128) } # [doc = "Division factor 128 / RC-Oscillator 256"]
# [inline (always)]
pub fn division_factor_128_rc_oscillator_256 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_128_RC_OSCILLATOR_256) } # [doc = "Division factor 256 / RC-Oscillator 512"]
# [inline (always)]
pub fn division_factor_256_rc_oscillator_512 (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_256_RC_OSCILLATOR_512) } # [doc = "Division factor 1 only permitted for RC-Oscillator. Flash and EEPROM programming is not allowed."]
# [inline (always)]
pub fn division_factor_1_only_permitted_for_rc_oscillator_flash_and_eeprom_programming_is_not_allowed (self) -> & 'a mut W { self . variant (CLKPS_A :: DIVISION_FACTOR_1_ONLY_PERMITTED_FOR_RC_OSCILLATOR_FLASH_AND_EEPROM_PROGRAMMING_IS_NOT_ALLOWED) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CLKPR_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `CLKPCE` reader - Clock Prescaler Change Enable"]
pub type CLKPCE_R = crate :: BitReader < bool > ; # [doc = "Field `CLKPCE` writer - Clock Prescaler Change Enable"]
pub type CLKPCE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CLKPR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:3 - Clock Prescaler Select Bits"]
# [inline (always)]
pub fn clkps (& self) -> CLKPS_R { CLKPS_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:6 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 4) & 7) } # [doc = "Bit 7 - Clock Prescaler Change Enable"]
# [inline (always)]
pub fn clkpce (& self) -> CLKPCE_R { CLKPCE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Clock Prescaler Select Bits"]
# [inline (always)]
# [must_use]
pub fn clkps (& mut self) -> CLKPS_W < 0 > { CLKPS_W :: new (self) } # [doc = "Bits 4:6 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 4 > { RES_W :: new (self) } # [doc = "Bit 7 - Clock Prescaler Change Enable"]
# [inline (always)]
# [must_use]
pub fn clkpce (& mut self) -> CLKPCE_W < 7 > { CLKPCE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Prescale Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clkpr](index.html) module"]
pub struct CLKPR_SPEC ; impl crate :: RegisterSpec for CLKPR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [clkpr::R](R) reader structure"]
impl crate :: Readable for CLKPR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clkpr::W](W) writer structure"]
impl crate :: Writable for CLKPR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CLKPR to value 0"]
impl crate :: Resettable for CLKPR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR0 (rw) register accessor: an alias for `Reg<GPIOR0_SPEC>`"]
pub type GPIOR0 = crate :: Reg < gpior0 :: GPIOR0_SPEC > ; # [doc = "General Purpose IO Register 0"]
pub mod gpior0 { # [doc = "Register `GPIOR0` reader"]
pub struct R (crate :: R < GPIOR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR0` writer"]
pub struct W (crate :: W < GPIOR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR0_SPEC >) -> Self { W (writer) } } # [doc = "Field `GPIOR00` reader - General Purpose I/O Register 0 Value"]
pub type GPIOR00_R = crate :: BitReader < bool > ; # [doc = "Field `GPIOR00` writer - General Purpose I/O Register 0 Value"]
pub type GPIOR00_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GPIOR0_SPEC , bool , O > ; # [doc = "Field `GPIOR01` reader - General Purpose I/O Register 0 Value"]
pub type GPIOR01_R = crate :: BitReader < bool > ; # [doc = "Field `GPIOR01` writer - General Purpose I/O Register 0 Value"]
pub type GPIOR01_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GPIOR0_SPEC , bool , O > ; # [doc = "Field `GPIOR02` reader - General Purpose I/O Register 0 Value"]
pub type GPIOR02_R = crate :: BitReader < bool > ; # [doc = "Field `GPIOR02` writer - General Purpose I/O Register 0 Value"]
pub type GPIOR02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GPIOR0_SPEC , bool , O > ; # [doc = "Field `GPIOR03` reader - General Purpose I/O Register 0 Value"]
pub type GPIOR03_R = crate :: BitReader < bool > ; # [doc = "Field `GPIOR03` writer - General Purpose I/O Register 0 Value"]
pub type GPIOR03_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GPIOR0_SPEC , bool , O > ; # [doc = "Field `GPIOR04` reader - General Purpose I/O Register 0 Value"]
pub type GPIOR04_R = crate :: BitReader < bool > ; # [doc = "Field `GPIOR04` writer - General Purpose I/O Register 0 Value"]
pub type GPIOR04_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GPIOR0_SPEC , bool , O > ; # [doc = "Field `GPIOR05` reader - General Purpose I/O Register 0 Value"]
pub type GPIOR05_R = crate :: BitReader < bool > ; # [doc = "Field `GPIOR05` writer - General Purpose I/O Register 0 Value"]
pub type GPIOR05_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GPIOR0_SPEC , bool , O > ; # [doc = "Field `GPIOR06` reader - General Purpose I/O Register 0 Value"]
pub type GPIOR06_R = crate :: BitReader < bool > ; # [doc = "Field `GPIOR06` writer - General Purpose I/O Register 0 Value"]
pub type GPIOR06_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GPIOR0_SPEC , bool , O > ; # [doc = "Field `GPIOR07` reader - General Purpose I/O Register 0 Value"]
pub type GPIOR07_R = crate :: BitReader < bool > ; # [doc = "Field `GPIOR07` writer - General Purpose I/O Register 0 Value"]
pub type GPIOR07_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GPIOR0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - General Purpose I/O Register 0 Value"]
# [inline (always)]
pub fn gpior00 (& self) -> GPIOR00_R { GPIOR00_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - General Purpose I/O Register 0 Value"]
# [inline (always)]
pub fn gpior01 (& self) -> GPIOR01_R { GPIOR01_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - General Purpose I/O Register 0 Value"]
# [inline (always)]
pub fn gpior02 (& self) -> GPIOR02_R { GPIOR02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - General Purpose I/O Register 0 Value"]
# [inline (always)]
pub fn gpior03 (& self) -> GPIOR03_R { GPIOR03_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - General Purpose I/O Register 0 Value"]
# [inline (always)]
pub fn gpior04 (& self) -> GPIOR04_R { GPIOR04_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - General Purpose I/O Register 0 Value"]
# [inline (always)]
pub fn gpior05 (& self) -> GPIOR05_R { GPIOR05_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - General Purpose I/O Register 0 Value"]
# [inline (always)]
pub fn gpior06 (& self) -> GPIOR06_R { GPIOR06_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - General Purpose I/O Register 0 Value"]
# [inline (always)]
pub fn gpior07 (& self) -> GPIOR07_R { GPIOR07_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - General Purpose I/O Register 0 Value"]
# [inline (always)]
# [must_use]
pub fn gpior00 (& mut self) -> GPIOR00_W < 0 > { GPIOR00_W :: new (self) } # [doc = "Bit 1 - General Purpose I/O Register 0 Value"]
# [inline (always)]
# [must_use]
pub fn gpior01 (& mut self) -> GPIOR01_W < 1 > { GPIOR01_W :: new (self) } # [doc = "Bit 2 - General Purpose I/O Register 0 Value"]
# [inline (always)]
# [must_use]
pub fn gpior02 (& mut self) -> GPIOR02_W < 2 > { GPIOR02_W :: new (self) } # [doc = "Bit 3 - General Purpose I/O Register 0 Value"]
# [inline (always)]
# [must_use]
pub fn gpior03 (& mut self) -> GPIOR03_W < 3 > { GPIOR03_W :: new (self) } # [doc = "Bit 4 - General Purpose I/O Register 0 Value"]
# [inline (always)]
# [must_use]
pub fn gpior04 (& mut self) -> GPIOR04_W < 4 > { GPIOR04_W :: new (self) } # [doc = "Bit 5 - General Purpose I/O Register 0 Value"]
# [inline (always)]
# [must_use]
pub fn gpior05 (& mut self) -> GPIOR05_W < 5 > { GPIOR05_W :: new (self) } # [doc = "Bit 6 - General Purpose I/O Register 0 Value"]
# [inline (always)]
# [must_use]
pub fn gpior06 (& mut self) -> GPIOR06_W < 6 > { GPIOR06_W :: new (self) } # [doc = "Bit 7 - General Purpose I/O Register 0 Value"]
# [inline (always)]
# [must_use]
pub fn gpior07 (& mut self) -> GPIOR07_W < 7 > { GPIOR07_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Purpose IO Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior0](index.html) module"]
pub struct GPIOR0_SPEC ; impl crate :: RegisterSpec for GPIOR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior0::R](R) reader structure"]
impl crate :: Readable for GPIOR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior0::W](W) writer structure"]
impl crate :: Writable for GPIOR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR0 to value 0"]
impl crate :: Resettable for GPIOR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR1 (rw) register accessor: an alias for `Reg<GPIOR1_SPEC>`"]
pub type GPIOR1 = crate :: Reg < gpior1 :: GPIOR1_SPEC > ; # [doc = "General Purpose IO Register 1"]
pub mod gpior1 { # [doc = "Register `GPIOR1` reader"]
pub struct R (crate :: R < GPIOR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR1` writer"]
pub struct W (crate :: W < GPIOR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR1_SPEC >) -> Self { W (writer) } } # [doc = "Field `GPIOR` reader - General Purpose I/O Register 1 Value"]
pub type GPIOR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `GPIOR` writer - General Purpose I/O Register 1 Value"]
pub type GPIOR_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , GPIOR1_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - General Purpose I/O Register 1 Value"]
# [inline (always)]
pub fn gpior (& self) -> GPIOR_R { GPIOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - General Purpose I/O Register 1 Value"]
# [inline (always)]
# [must_use]
pub fn gpior (& mut self) -> GPIOR_W < 0 > { GPIOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior1](index.html) module"]
pub struct GPIOR1_SPEC ; impl crate :: RegisterSpec for GPIOR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior1::R](R) reader structure"]
impl crate :: Readable for GPIOR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior1::W](W) writer structure"]
impl crate :: Writable for GPIOR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR1 to value 0"]
impl crate :: Resettable for GPIOR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR2 (rw) register accessor: an alias for `Reg<GPIOR2_SPEC>`"]
pub type GPIOR2 = crate :: Reg < gpior2 :: GPIOR2_SPEC > ; # [doc = "General Purpose I/O Register 2"]
pub mod gpior2 { # [doc = "Register `GPIOR2` reader"]
pub struct R (crate :: R < GPIOR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR2` writer"]
pub struct W (crate :: W < GPIOR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR2_SPEC >) -> Self { W (writer) } } # [doc = "Field `GPIOR` reader - General Purpose I/O Register 2 Value"]
pub type GPIOR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `GPIOR` writer - General Purpose I/O Register 2 Value"]
pub type GPIOR_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , GPIOR2_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - General Purpose I/O Register 2 Value"]
# [inline (always)]
pub fn gpior (& self) -> GPIOR_R { GPIOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - General Purpose I/O Register 2 Value"]
# [inline (always)]
# [must_use]
pub fn gpior (& mut self) -> GPIOR_W < 0 > { GPIOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose I/O Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior2](index.html) module"]
pub struct GPIOR2_SPEC ; impl crate :: RegisterSpec for GPIOR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior2::R](R) reader structure"]
impl crate :: Readable for GPIOR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior2::W](W) writer structure"]
impl crate :: Writable for GPIOR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR2 to value 0"]
impl crate :: Resettable for GPIOR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCUCR (rw) register accessor: an alias for `Reg<MCUCR_SPEC>`"]
pub type MCUCR = crate :: Reg < mcucr :: MCUCR_SPEC > ; # [doc = "MCU Control Register"]
pub mod mcucr { # [doc = "Register `MCUCR` reader"]
pub struct R (crate :: R < MCUCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCUCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCUCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCUCR` writer"]
pub struct W (crate :: W < MCUCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCUCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCUCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `IVCE` reader - Interrupt Vector Change Enable"]
pub type IVCE_R = crate :: BitReader < bool > ; # [doc = "Field `IVCE` writer - Interrupt Vector Change Enable"]
pub type IVCE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; # [doc = "Field `IVSEL` reader - Interrupt Vector Select"]
pub type IVSEL_R = crate :: BitReader < bool > ; # [doc = "Field `IVSEL` writer - Interrupt Vector Select"]
pub type IVSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; # [doc = "Field `PUD` reader - Pull-up Disable"]
pub type PUD_R = crate :: BitReader < bool > ; # [doc = "Field `PUD` writer - Pull-up Disable"]
pub type PUD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; # [doc = "Field `JTD` reader - JTAG Interface Disable"]
pub type JTD_R = crate :: BitReader < bool > ; # [doc = "Field `JTD` writer - JTAG Interface Disable"]
pub type JTD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Interrupt Vector Change Enable"]
# [inline (always)]
pub fn ivce (& self) -> IVCE_R { IVCE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Interrupt Vector Select"]
# [inline (always)]
pub fn ivsel (& self) -> IVSEL_R { IVSEL_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Pull-up Disable"]
# [inline (always)]
pub fn pud (& self) -> PUD_R { PUD_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 7 - JTAG Interface Disable"]
# [inline (always)]
pub fn jtd (& self) -> JTD_R { JTD_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Interrupt Vector Change Enable"]
# [inline (always)]
# [must_use]
pub fn ivce (& mut self) -> IVCE_W < 0 > { IVCE_W :: new (self) } # [doc = "Bit 1 - Interrupt Vector Select"]
# [inline (always)]
# [must_use]
pub fn ivsel (& mut self) -> IVSEL_W < 1 > { IVSEL_W :: new (self) } # [doc = "Bit 4 - Pull-up Disable"]
# [inline (always)]
# [must_use]
pub fn pud (& mut self) -> PUD_W < 4 > { PUD_W :: new (self) } # [doc = "Bit 7 - JTAG Interface Disable"]
# [inline (always)]
# [must_use]
pub fn jtd (& mut self) -> JTD_W < 7 > { JTD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCU Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcucr](index.html) module"]
pub struct MCUCR_SPEC ; impl crate :: RegisterSpec for MCUCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mcucr::R](R) reader structure"]
impl crate :: Readable for MCUCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mcucr::W](W) writer structure"]
impl crate :: Writable for MCUCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCUCR to value 0"]
impl crate :: Resettable for MCUCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCUSR (rw) register accessor: an alias for `Reg<MCUSR_SPEC>`"]
pub type MCUSR = crate :: Reg < mcusr :: MCUSR_SPEC > ; # [doc = "MCU Status Register"]
pub mod mcusr { # [doc = "Register `MCUSR` reader"]
pub struct R (crate :: R < MCUSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCUSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCUSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCUSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCUSR` writer"]
pub struct W (crate :: W < MCUSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCUSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCUSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCUSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PORF` reader - Power-on Reset Flag"]
pub type PORF_R = crate :: BitReader < bool > ; # [doc = "Field `PORF` writer - Power-on Reset Flag"]
pub type PORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; # [doc = "Field `EXTRF` reader - External Reset Flag"]
pub type EXTRF_R = crate :: BitReader < bool > ; # [doc = "Field `EXTRF` writer - External Reset Flag"]
pub type EXTRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; # [doc = "Field `BORF` reader - Brown-out Reset Flag"]
pub type BORF_R = crate :: BitReader < bool > ; # [doc = "Field `BORF` writer - Brown-out Reset Flag"]
pub type BORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; # [doc = "Field `WDRF` reader - Watchdog Reset Flag"]
pub type WDRF_R = crate :: BitReader < bool > ; # [doc = "Field `WDRF` writer - Watchdog Reset Flag"]
pub type WDRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; # [doc = "Field `JTRF` reader - JTAG Reset Flag"]
pub type JTRF_R = crate :: BitReader < bool > ; # [doc = "Field `JTRF` writer - JTAG Reset Flag"]
pub type JTRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MCUSR_SPEC , u8 , u8 , 3 , O > ; impl R { # [doc = "Bit 0 - Power-on Reset Flag"]
# [inline (always)]
pub fn porf (& self) -> PORF_R { PORF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Reset Flag"]
# [inline (always)]
pub fn extrf (& self) -> EXTRF_R { EXTRF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Brown-out Reset Flag"]
# [inline (always)]
pub fn borf (& self) -> BORF_R { BORF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Watchdog Reset Flag"]
# [inline (always)]
pub fn wdrf (& self) -> WDRF_R { WDRF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - JTAG Reset Flag"]
# [inline (always)]
pub fn jtrf (& self) -> JTRF_R { JTRF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bit 0 - Power-on Reset Flag"]
# [inline (always)]
# [must_use]
pub fn porf (& mut self) -> PORF_W < 0 > { PORF_W :: new (self) } # [doc = "Bit 1 - External Reset Flag"]
# [inline (always)]
# [must_use]
pub fn extrf (& mut self) -> EXTRF_W < 1 > { EXTRF_W :: new (self) } # [doc = "Bit 2 - Brown-out Reset Flag"]
# [inline (always)]
# [must_use]
pub fn borf (& mut self) -> BORF_W < 2 > { BORF_W :: new (self) } # [doc = "Bit 3 - Watchdog Reset Flag"]
# [inline (always)]
# [must_use]
pub fn wdrf (& mut self) -> WDRF_W < 3 > { WDRF_W :: new (self) } # [doc = "Bit 4 - JTAG Reset Flag"]
# [inline (always)]
# [must_use]
pub fn jtrf (& mut self) -> JTRF_W < 4 > { JTRF_W :: new (self) } # [doc = "Bits 5:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 5 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCU Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcusr](index.html) module"]
pub struct MCUSR_SPEC ; impl crate :: RegisterSpec for MCUSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mcusr::R](R) reader structure"]
impl crate :: Readable for MCUSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mcusr::W](W) writer structure"]
impl crate :: Writable for MCUSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCUSR to value 0"]
impl crate :: Resettable for MCUSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCAL (rw) register accessor: an alias for `Reg<OSCCAL_SPEC>`"]
pub type OSCCAL = crate :: Reg < osccal :: OSCCAL_SPEC > ; # [doc = "Oscillator Calibration Value"]
pub mod osccal { # [doc = "Register `OSCCAL` reader"]
pub struct R (crate :: R < OSCCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSCCAL` writer"]
pub struct W (crate :: W < OSCCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSCCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSCCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSCCAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAL` reader - Oscillator Calibration Tuning Value"]
pub type CAL_R = crate :: FieldReader < u8 , CAL_A > ; # [doc = "Oscillator Calibration Tuning Value\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CAL_A { # [doc = "0: Calibration value for lowest oscillator frequency"]
CALIBRATION_VALUE_FOR_LOWEST_OSCILLATOR_FREQUENCY = 0 , # [doc = "127: End value of low frequency range calibration"]
END_VALUE_OF_LOW_FREQUENCY_RANGE_CALIBRATION = 127 , # [doc = "128: Start value of high frequency range calibration"]
START_VALUE_OF_HIGH_FREQUENCY_RANGE_CALIBRATION = 128 , # [doc = "255: Calibration value for highest oscillator frequency"]
CALIBRATION_VALUE_FOR_HIGHEST_OSCILLATOR_FREQUENCY = 255 , } impl From < CAL_A > for u8 { # [inline (always)]
fn from (variant : CAL_A) -> Self { variant as _ } } impl CAL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CAL_A > { match self . bits { 0 => Some (CAL_A :: CALIBRATION_VALUE_FOR_LOWEST_OSCILLATOR_FREQUENCY) , 127 => Some (CAL_A :: END_VALUE_OF_LOW_FREQUENCY_RANGE_CALIBRATION) , 128 => Some (CAL_A :: START_VALUE_OF_HIGH_FREQUENCY_RANGE_CALIBRATION) , 255 => Some (CAL_A :: CALIBRATION_VALUE_FOR_HIGHEST_OSCILLATOR_FREQUENCY) , _ => None , } } # [doc = "Checks if the value of the field is `CALIBRATION_VALUE_FOR_LOWEST_OSCILLATOR_FREQUENCY`"]
# [inline (always)]
pub fn is_calibration_value_for_lowest_oscillator_frequency (& self) -> bool { * self == CAL_A :: CALIBRATION_VALUE_FOR_LOWEST_OSCILLATOR_FREQUENCY } # [doc = "Checks if the value of the field is `END_VALUE_OF_LOW_FREQUENCY_RANGE_CALIBRATION`"]
# [inline (always)]
pub fn is_end_value_of_low_frequency_range_calibration (& self) -> bool { * self == CAL_A :: END_VALUE_OF_LOW_FREQUENCY_RANGE_CALIBRATION } # [doc = "Checks if the value of the field is `START_VALUE_OF_HIGH_FREQUENCY_RANGE_CALIBRATION`"]
# [inline (always)]
pub fn is_start_value_of_high_frequency_range_calibration (& self) -> bool { * self == CAL_A :: START_VALUE_OF_HIGH_FREQUENCY_RANGE_CALIBRATION } # [doc = "Checks if the value of the field is `CALIBRATION_VALUE_FOR_HIGHEST_OSCILLATOR_FREQUENCY`"]
# [inline (always)]
pub fn is_calibration_value_for_highest_oscillator_frequency (& self) -> bool { * self == CAL_A :: CALIBRATION_VALUE_FOR_HIGHEST_OSCILLATOR_FREQUENCY } } # [doc = "Field `CAL` writer - Oscillator Calibration Tuning Value"]
pub type CAL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , OSCCAL_SPEC , u8 , CAL_A , 8 , O > ; impl < 'a , const O : u8 > CAL_W < 'a , O > { # [doc = "Calibration value for lowest oscillator frequency"]
# [inline (always)]
pub fn calibration_value_for_lowest_oscillator_frequency (self) -> & 'a mut W { self . variant (CAL_A :: CALIBRATION_VALUE_FOR_LOWEST_OSCILLATOR_FREQUENCY) } # [doc = "End value of low frequency range calibration"]
# [inline (always)]
pub fn end_value_of_low_frequency_range_calibration (self) -> & 'a mut W { self . variant (CAL_A :: END_VALUE_OF_LOW_FREQUENCY_RANGE_CALIBRATION) } # [doc = "Start value of high frequency range calibration"]
# [inline (always)]
pub fn start_value_of_high_frequency_range_calibration (self) -> & 'a mut W { self . variant (CAL_A :: START_VALUE_OF_HIGH_FREQUENCY_RANGE_CALIBRATION) } # [doc = "Calibration value for highest oscillator frequency"]
# [inline (always)]
pub fn calibration_value_for_highest_oscillator_frequency (self) -> & 'a mut W { self . variant (CAL_A :: CALIBRATION_VALUE_FOR_HIGHEST_OSCILLATOR_FREQUENCY) } } # [doc = "Field `OSCCAL` reader - Oscillator Calibration"]
pub type OSCCAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `OSCCAL` writer - Oscillator Calibration"]
pub type OSCCAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OSCCAL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Oscillator Calibration Tuning Value"]
# [inline (always)]
pub fn cal (& self) -> CAL_R { CAL_R :: new (self . bits) } # [doc = "Bits 0:7 - Oscillator Calibration"]
# [inline (always)]
pub fn osccal (& self) -> OSCCAL_R { OSCCAL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Oscillator Calibration Tuning Value"]
# [inline (always)]
# [must_use]
pub fn cal (& mut self) -> CAL_W < 0 > { CAL_W :: new (self) } # [doc = "Bits 0:7 - Oscillator Calibration"]
# [inline (always)]
# [must_use]
pub fn osccal (& mut self) -> OSCCAL_W < 0 > { OSCCAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Oscillator Calibration Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccal](index.html) module"]
pub struct OSCCAL_SPEC ; impl crate :: RegisterSpec for OSCCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccal::R](R) reader structure"]
impl crate :: Readable for OSCCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osccal::W](W) writer structure"]
impl crate :: Writable for OSCCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSCCAL to value 0"]
impl crate :: Resettable for OSCCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRR0 (rw) register accessor: an alias for `Reg<PRR0_SPEC>`"]
pub type PRR0 = crate :: Reg < prr0 :: PRR0_SPEC > ; # [doc = "Power Reduction Register0"]
pub mod prr0 { # [doc = "Register `PRR0` reader"]
pub struct R (crate :: R < PRR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRR0` writer"]
pub struct W (crate :: W < PRR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRR0_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRADC` reader - Power Reduction ADC"]
pub type PRADC_R = crate :: BitReader < bool > ; # [doc = "Field `PRADC` writer - Power Reduction ADC"]
pub type PRADC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR0_SPEC , bool , O > ; # [doc = "Field `PRUSART0` reader - Power Reduction USART0"]
pub type PRUSART0_R = crate :: BitReader < bool > ; # [doc = "Field `PRUSART0` writer - Power Reduction USART0"]
pub type PRUSART0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR0_SPEC , bool , O > ; # [doc = "Field `PRSPI` reader - Power Reduction Serial Peripheral Interface"]
pub type PRSPI_R = crate :: BitReader < bool > ; # [doc = "Field `PRSPI` writer - Power Reduction Serial Peripheral Interface"]
pub type PRSPI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR0_SPEC , bool , O > ; # [doc = "Field `PRTIM1` reader - Power Reduction Timer/Counter1"]
pub type PRTIM1_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM1` writer - Power Reduction Timer/Counter1"]
pub type PRTIM1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR0_SPEC , bool , O > ; # [doc = "Field `PRPGA` reader - Power Reduction PGA"]
pub type PRPGA_R = crate :: BitReader < bool > ; # [doc = "Field `PRPGA` writer - Power Reduction PGA"]
pub type PRPGA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR0_SPEC , bool , O > ; # [doc = "Field `PRTIM0` reader - Power Reduction Timer/Counter0"]
pub type PRTIM0_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM0` writer - Power Reduction Timer/Counter0"]
pub type PRTIM0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR0_SPEC , bool , O > ; # [doc = "Field `PRTIM2` reader - Power Reduction Timer/Counter2"]
pub type PRTIM2_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM2` writer - Power Reduction Timer/Counter2"]
pub type PRTIM2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR0_SPEC , bool , O > ; # [doc = "Field `PRTWI` reader - Power Reduction TWI"]
pub type PRTWI_R = crate :: BitReader < bool > ; # [doc = "Field `PRTWI` writer - Power Reduction TWI"]
pub type PRTWI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Power Reduction ADC"]
# [inline (always)]
pub fn pradc (& self) -> PRADC_R { PRADC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Power Reduction USART0"]
# [inline (always)]
pub fn prusart0 (& self) -> PRUSART0_R { PRUSART0_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Power Reduction Serial Peripheral Interface"]
# [inline (always)]
pub fn prspi (& self) -> PRSPI_R { PRSPI_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Power Reduction Timer/Counter1"]
# [inline (always)]
pub fn prtim1 (& self) -> PRTIM1_R { PRTIM1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Power Reduction PGA"]
# [inline (always)]
pub fn prpga (& self) -> PRPGA_R { PRPGA_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Power Reduction Timer/Counter0"]
# [inline (always)]
pub fn prtim0 (& self) -> PRTIM0_R { PRTIM0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Power Reduction Timer/Counter2"]
# [inline (always)]
pub fn prtim2 (& self) -> PRTIM2_R { PRTIM2_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Power Reduction TWI"]
# [inline (always)]
pub fn prtwi (& self) -> PRTWI_R { PRTWI_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Power Reduction ADC"]
# [inline (always)]
# [must_use]
pub fn pradc (& mut self) -> PRADC_W < 0 > { PRADC_W :: new (self) } # [doc = "Bit 1 - Power Reduction USART0"]
# [inline (always)]
# [must_use]
pub fn prusart0 (& mut self) -> PRUSART0_W < 1 > { PRUSART0_W :: new (self) } # [doc = "Bit 2 - Power Reduction Serial Peripheral Interface"]
# [inline (always)]
# [must_use]
pub fn prspi (& mut self) -> PRSPI_W < 2 > { PRSPI_W :: new (self) } # [doc = "Bit 3 - Power Reduction Timer/Counter1"]
# [inline (always)]
# [must_use]
pub fn prtim1 (& mut self) -> PRTIM1_W < 3 > { PRTIM1_W :: new (self) } # [doc = "Bit 4 - Power Reduction PGA"]
# [inline (always)]
# [must_use]
pub fn prpga (& mut self) -> PRPGA_W < 4 > { PRPGA_W :: new (self) } # [doc = "Bit 5 - Power Reduction Timer/Counter0"]
# [inline (always)]
# [must_use]
pub fn prtim0 (& mut self) -> PRTIM0_W < 5 > { PRTIM0_W :: new (self) } # [doc = "Bit 6 - Power Reduction Timer/Counter2"]
# [inline (always)]
# [must_use]
pub fn prtim2 (& mut self) -> PRTIM2_W < 6 > { PRTIM2_W :: new (self) } # [doc = "Bit 7 - Power Reduction TWI"]
# [inline (always)]
# [must_use]
pub fn prtwi (& mut self) -> PRTWI_W < 7 > { PRTWI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Register0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prr0](index.html) module"]
pub struct PRR0_SPEC ; impl crate :: RegisterSpec for PRR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prr0::R](R) reader structure"]
impl crate :: Readable for PRR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prr0::W](W) writer structure"]
impl crate :: Writable for PRR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRR0 to value 0"]
impl crate :: Resettable for PRR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRR1 (rw) register accessor: an alias for `Reg<PRR1_SPEC>`"]
pub type PRR1 = crate :: Reg < prr1 :: PRR1_SPEC > ; # [doc = "Power Reduction Register 1"]
pub mod prr1 { # [doc = "Register `PRR1` reader"]
pub struct R (crate :: R < PRR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRR1` writer"]
pub struct W (crate :: W < PRR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRR1_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRUSART1` reader - Power Reduction USART1"]
pub type PRUSART1_R = crate :: BitReader < bool > ; # [doc = "Field `PRUSART1` writer - Power Reduction USART1"]
pub type PRUSART1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR1_SPEC , bool , O > ; # [doc = "Field `PRTIM3` reader - Power Reduction Timer/Counter3"]
pub type PRTIM3_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM3` writer - Power Reduction Timer/Counter3"]
pub type PRTIM3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR1_SPEC , bool , O > ; # [doc = "Field `PRTIM4` reader - Power Reduction Timer/Counter4"]
pub type PRTIM4_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM4` writer - Power Reduction Timer/Counter4"]
pub type PRTIM4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR1_SPEC , bool , O > ; # [doc = "Field `PRTIM5` reader - Power Reduction Timer/Counter5"]
pub type PRTIM5_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM5` writer - Power Reduction Timer/Counter5"]
pub type PRTIM5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR1_SPEC , bool , O > ; # [doc = "Field `PRTRX24` reader - Power Reduction Transceiver"]
pub type PRTRX24_R = crate :: BitReader < bool > ; # [doc = "Field `PRTRX24` writer - Power Reduction Transceiver"]
pub type PRTRX24_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Power Reduction USART1"]
# [inline (always)]
pub fn prusart1 (& self) -> PRUSART1_R { PRUSART1_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 3 - Power Reduction Timer/Counter3"]
# [inline (always)]
pub fn prtim3 (& self) -> PRTIM3_R { PRTIM3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Power Reduction Timer/Counter4"]
# [inline (always)]
pub fn prtim4 (& self) -> PRTIM4_R { PRTIM4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Power Reduction Timer/Counter5"]
# [inline (always)]
pub fn prtim5 (& self) -> PRTIM5_R { PRTIM5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Power Reduction Transceiver"]
# [inline (always)]
pub fn prtrx24 (& self) -> PRTRX24_R { PRTRX24_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Power Reduction USART1"]
# [inline (always)]
# [must_use]
pub fn prusart1 (& mut self) -> PRUSART1_W < 0 > { PRUSART1_W :: new (self) } # [doc = "Bit 3 - Power Reduction Timer/Counter3"]
# [inline (always)]
# [must_use]
pub fn prtim3 (& mut self) -> PRTIM3_W < 3 > { PRTIM3_W :: new (self) } # [doc = "Bit 4 - Power Reduction Timer/Counter4"]
# [inline (always)]
# [must_use]
pub fn prtim4 (& mut self) -> PRTIM4_W < 4 > { PRTIM4_W :: new (self) } # [doc = "Bit 5 - Power Reduction Timer/Counter5"]
# [inline (always)]
# [must_use]
pub fn prtim5 (& mut self) -> PRTIM5_W < 5 > { PRTIM5_W :: new (self) } # [doc = "Bit 6 - Power Reduction Transceiver"]
# [inline (always)]
# [must_use]
pub fn prtrx24 (& mut self) -> PRTRX24_W < 6 > { PRTRX24_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prr1](index.html) module"]
pub struct PRR1_SPEC ; impl crate :: RegisterSpec for PRR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prr1::R](R) reader structure"]
impl crate :: Readable for PRR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prr1::W](W) writer structure"]
impl crate :: Writable for PRR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRR1 to value 0"]
impl crate :: Resettable for PRR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRR2 (rw) register accessor: an alias for `Reg<PRR2_SPEC>`"]
pub type PRR2 = crate :: Reg < prr2 :: PRR2_SPEC > ; # [doc = "Power Reduction Register 2"]
pub mod prr2 { # [doc = "Register `PRR2` reader"]
pub struct R (crate :: R < PRR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRR2` writer"]
pub struct W (crate :: W < PRR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRR2_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRRAM0` reader - Power Reduction SRAM0"]
pub type PRRAM0_R = crate :: BitReader < bool > ; # [doc = "Field `PRRAM0` writer - Power Reduction SRAM0"]
pub type PRRAM0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR2_SPEC , bool , O > ; # [doc = "Field `PRRAM1` reader - Power Reduction SRAM1"]
pub type PRRAM1_R = crate :: BitReader < bool > ; # [doc = "Field `PRRAM1` writer - Power Reduction SRAM1"]
pub type PRRAM1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR2_SPEC , bool , O > ; # [doc = "Field `PRRAM2` reader - Power Reduction SRAM2"]
pub type PRRAM2_R = crate :: BitReader < bool > ; # [doc = "Field `PRRAM2` writer - Power Reduction SRAM2"]
pub type PRRAM2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR2_SPEC , bool , O > ; # [doc = "Field `PRRAM3` reader - Power Reduction SRAM3"]
pub type PRRAM3_R = crate :: BitReader < bool > ; # [doc = "Field `PRRAM3` writer - Power Reduction SRAM3"]
pub type PRRAM3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR2_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Power Reduction SRAM0"]
# [inline (always)]
pub fn prram0 (& self) -> PRRAM0_R { PRRAM0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Power Reduction SRAM1"]
# [inline (always)]
pub fn prram1 (& self) -> PRRAM1_R { PRRAM1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Power Reduction SRAM2"]
# [inline (always)]
pub fn prram2 (& self) -> PRRAM2_R { PRRAM2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Power Reduction SRAM3"]
# [inline (always)]
pub fn prram3 (& self) -> PRRAM3_R { PRRAM3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Power Reduction SRAM0"]
# [inline (always)]
# [must_use]
pub fn prram0 (& mut self) -> PRRAM0_W < 0 > { PRRAM0_W :: new (self) } # [doc = "Bit 1 - Power Reduction SRAM1"]
# [inline (always)]
# [must_use]
pub fn prram1 (& mut self) -> PRRAM1_W < 1 > { PRRAM1_W :: new (self) } # [doc = "Bit 2 - Power Reduction SRAM2"]
# [inline (always)]
# [must_use]
pub fn prram2 (& mut self) -> PRRAM2_W < 2 > { PRRAM2_W :: new (self) } # [doc = "Bit 3 - Power Reduction SRAM3"]
# [inline (always)]
# [must_use]
pub fn prram3 (& mut self) -> PRRAM3_W < 3 > { PRRAM3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prr2](index.html) module"]
pub struct PRR2_SPEC ; impl crate :: RegisterSpec for PRR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prr2::R](R) reader structure"]
impl crate :: Readable for PRR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prr2::W](W) writer structure"]
impl crate :: Writable for PRR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRR2 to value 0"]
impl crate :: Resettable for PRR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RAMPZ (rw) register accessor: an alias for `Reg<RAMPZ_SPEC>`"]
pub type RAMPZ = crate :: Reg < rampz :: RAMPZ_SPEC > ; # [doc = "Extended Z-pointer Register for ELPM/SPM"]
pub mod rampz { # [doc = "Register `RAMPZ` reader"]
pub struct R (crate :: R < RAMPZ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAMPZ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAMPZ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAMPZ_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAMPZ` writer"]
pub struct W (crate :: W < RAMPZ_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAMPZ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAMPZ_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAMPZ_SPEC >) -> Self { W (writer) } } # [doc = "Field `RAMPZ` reader - Extended Z-Pointer Value"]
pub type RAMPZ_R = crate :: FieldReader < u8 , RAMPZ_A > ; # [doc = "Extended Z-Pointer Value\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RAMPZ_A { # [doc = "0: Default value of Z-pointer MSB's."]
DEFAULT_VALUE_OF_Z_POINTER_MSB_S = 0 , } impl From < RAMPZ_A > for u8 { # [inline (always)]
fn from (variant : RAMPZ_A) -> Self { variant as _ } } impl RAMPZ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RAMPZ_A > { match self . bits { 0 => Some (RAMPZ_A :: DEFAULT_VALUE_OF_Z_POINTER_MSB_S) , _ => None , } } # [doc = "Checks if the value of the field is `DEFAULT_VALUE_OF_Z_POINTER_MSB_S`"]
# [inline (always)]
pub fn is_default_value_of_z_pointer_msb_s (& self) -> bool { * self == RAMPZ_A :: DEFAULT_VALUE_OF_Z_POINTER_MSB_S } } # [doc = "Field `RAMPZ` writer - Extended Z-Pointer Value"]
pub type RAMPZ_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , RAMPZ_SPEC , u8 , RAMPZ_A , 2 , O > ; impl < 'a , const O : u8 > RAMPZ_W < 'a , O > { # [doc = "Default value of Z-pointer MSB's."]
# [inline (always)]
pub fn default_value_of_z_pointer_msb_s (self) -> & 'a mut W { self . variant (RAMPZ_A :: DEFAULT_VALUE_OF_Z_POINTER_MSB_S) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , RAMPZ_SPEC , u8 , u8 , 6 , O > ; impl R { # [doc = "Bits 0:1 - Extended Z-Pointer Value"]
# [inline (always)]
pub fn rampz (& self) -> RAMPZ_R { RAMPZ_R :: new (self . bits & 3) } # [doc = "Bits 2:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 2) & 0x3f) } } impl W { # [doc = "Bits 0:1 - Extended Z-Pointer Value"]
# [inline (always)]
# [must_use]
pub fn rampz (& mut self) -> RAMPZ_W < 0 > { RAMPZ_W :: new (self) } # [doc = "Bits 2:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 2 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Extended Z-pointer Register for ELPM/SPM\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rampz](index.html) module"]
pub struct RAMPZ_SPEC ; impl crate :: RegisterSpec for RAMPZ_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rampz::R](R) reader structure"]
impl crate :: Readable for RAMPZ_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rampz::W](W) writer structure"]
impl crate :: Writable for RAMPZ_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RAMPZ to value 0"]
impl crate :: Resettable for RAMPZ_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SMCR (rw) register accessor: an alias for `Reg<SMCR_SPEC>`"]
pub type SMCR = crate :: Reg < smcr :: SMCR_SPEC > ; # [doc = "Sleep Mode Control Register"]
pub mod smcr { # [doc = "Register `SMCR` reader"]
pub struct R (crate :: R < SMCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SMCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SMCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SMCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SMCR` writer"]
pub struct W (crate :: W < SMCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SMCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SMCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SMCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SE` reader - Sleep Enable"]
pub type SE_R = crate :: BitReader < bool > ; # [doc = "Field `SE` writer - Sleep Enable"]
pub type SE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SMCR_SPEC , bool , O > ; # [doc = "Field `SM` reader - Sleep Mode Select bits"]
pub type SM_R = crate :: FieldReader < u8 , SM_A > ; # [doc = "Sleep Mode Select bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SM_A { # [doc = "0: Idle"]
IDLE = 0 , # [doc = "1: ADC Noise Reduction (If Available)"]
ADC = 1 , # [doc = "2: Power Down"]
PDOWN = 2 , # [doc = "3: Power Save"]
PSAVE = 3 , # [doc = "4: Reserved"]
VAL_0X04 = 4 , # [doc = "5: Reserved"]
VAL_0X05 = 5 , # [doc = "6: Standby"]
STDBY = 6 , # [doc = "7: Extended Standby"]
ESTDBY = 7 , } impl From < SM_A > for u8 { # [inline (always)]
fn from (variant : SM_A) -> Self { variant as _ } } impl SM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SM_A { match self . bits { 0 => SM_A :: IDLE , 1 => SM_A :: ADC , 2 => SM_A :: PDOWN , 3 => SM_A :: PSAVE , 4 => SM_A :: VAL_0X04 , 5 => SM_A :: VAL_0X05 , 6 => SM_A :: STDBY , 7 => SM_A :: ESTDBY , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `IDLE`"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == SM_A :: IDLE } # [doc = "Checks if the value of the field is `ADC`"]
# [inline (always)]
pub fn is_adc (& self) -> bool { * self == SM_A :: ADC } # [doc = "Checks if the value of the field is `PDOWN`"]
# [inline (always)]
pub fn is_pdown (& self) -> bool { * self == SM_A :: PDOWN } # [doc = "Checks if the value of the field is `PSAVE`"]
# [inline (always)]
pub fn is_psave (& self) -> bool { * self == SM_A :: PSAVE } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == SM_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == SM_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `STDBY`"]
# [inline (always)]
pub fn is_stdby (& self) -> bool { * self == SM_A :: STDBY } # [doc = "Checks if the value of the field is `ESTDBY`"]
# [inline (always)]
pub fn is_estdby (& self) -> bool { * self == SM_A :: ESTDBY } } # [doc = "Field `SM` writer - Sleep Mode Select bits"]
pub type SM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SMCR_SPEC , u8 , SM_A , 3 , O > ; impl < 'a , const O : u8 > SM_W < 'a , O > { # [doc = "Idle"]
# [inline (always)]
pub fn idle (self) -> & 'a mut W { self . variant (SM_A :: IDLE) } # [doc = "ADC Noise Reduction (If Available)"]
# [inline (always)]
pub fn adc (self) -> & 'a mut W { self . variant (SM_A :: ADC) } # [doc = "Power Down"]
# [inline (always)]
pub fn pdown (self) -> & 'a mut W { self . variant (SM_A :: PDOWN) } # [doc = "Power Save"]
# [inline (always)]
pub fn psave (self) -> & 'a mut W { self . variant (SM_A :: PSAVE) } # [doc = "Reserved"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (SM_A :: VAL_0X04) } # [doc = "Reserved"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (SM_A :: VAL_0X05) } # [doc = "Standby"]
# [inline (always)]
pub fn stdby (self) -> & 'a mut W { self . variant (SM_A :: STDBY) } # [doc = "Extended Standby"]
# [inline (always)]
pub fn estdby (self) -> & 'a mut W { self . variant (SM_A :: ESTDBY) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SMCR_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bit 0 - Sleep Enable"]
# [inline (always)]
pub fn se (& self) -> SE_R { SE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Sleep Mode Select bits"]
# [inline (always)]
pub fn sm (& self) -> SM_R { SM_R :: new ((self . bits >> 1) & 7) } # [doc = "Bits 4:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bit 0 - Sleep Enable"]
# [inline (always)]
# [must_use]
pub fn se (& mut self) -> SE_W < 0 > { SE_W :: new (self) } # [doc = "Bits 1:3 - Sleep Mode Select bits"]
# [inline (always)]
# [must_use]
pub fn sm (& mut self) -> SM_W < 1 > { SM_W :: new (self) } # [doc = "Bits 4:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 4 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sleep Mode Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](index.html) module"]
pub struct SMCR_SPEC ; impl crate :: RegisterSpec for SMCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [smcr::R](R) reader structure"]
impl crate :: Readable for SMCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [smcr::W](W) writer structure"]
impl crate :: Writable for SMCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SMCR to value 0"]
impl crate :: Resettable for SMCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "EEPROM"]
pub struct EEPROM { _marker : PhantomData < * const () > } unsafe impl Send for EEPROM { } impl EEPROM { # [doc = r"Pointer to the register block"]
pub const PTR : * const eeprom :: RegisterBlock = 0x3f as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const eeprom :: RegisterBlock { Self :: PTR } } impl Deref for EEPROM { type Target = eeprom :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EEPROM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EEPROM") . finish () } } # [doc = "EEPROM"]
pub mod eeprom { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - EEPROM Control Register"]
pub eecr : EECR , # [doc = "0x01 - EEPROM Data Register"]
pub eedr : EEDR , # [doc = "0x02 - EEPROM Address Register Bytes"]
pub eear : EEAR , } # [doc = "EEAR (rw) register accessor: an alias for `Reg<EEAR_SPEC>`"]
pub type EEAR = crate :: Reg < eear :: EEAR_SPEC > ; # [doc = "EEPROM Address Register Bytes"]
pub mod eear { # [doc = "Register `EEAR` reader"]
pub struct R (crate :: R < EEAR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EEAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EEAR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EEAR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EEAR` writer"]
pub struct W (crate :: W < EEAR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EEAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EEAR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EEAR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "EEPROM Address Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eear](index.html) module"]
pub struct EEAR_SPEC ; impl crate :: RegisterSpec for EEAR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [eear::R](R) reader structure"]
impl crate :: Readable for EEAR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eear::W](W) writer structure"]
impl crate :: Writable for EEAR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EEAR to value 0"]
impl crate :: Resettable for EEAR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EECR (rw) register accessor: an alias for `Reg<EECR_SPEC>`"]
pub type EECR = crate :: Reg < eecr :: EECR_SPEC > ; # [doc = "EEPROM Control Register"]
pub mod eecr { # [doc = "Register `EECR` reader"]
pub struct R (crate :: R < EECR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EECR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EECR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EECR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EECR` writer"]
pub struct W (crate :: W < EECR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EECR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EECR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EECR_SPEC >) -> Self { W (writer) } } # [doc = "Field `EERE` reader - EEPROM Read Enable"]
pub type EERE_R = crate :: BitReader < bool > ; # [doc = "Field `EERE` writer - EEPROM Read Enable"]
pub type EERE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EECR_SPEC , bool , O > ; # [doc = "Field `EEPE` reader - EEPROM Programming Enable"]
pub type EEPE_R = crate :: BitReader < bool > ; # [doc = "Field `EEPE` writer - EEPROM Programming Enable"]
pub type EEPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EECR_SPEC , bool , O > ; # [doc = "Field `EEMPE` reader - EEPROM Master Write Enable"]
pub type EEMPE_R = crate :: BitReader < bool > ; # [doc = "Field `EEMPE` writer - EEPROM Master Write Enable"]
pub type EEMPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EECR_SPEC , bool , O > ; # [doc = "Field `EERIE` reader - EEPROM Ready Interrupt Enable"]
pub type EERIE_R = crate :: BitReader < bool > ; # [doc = "Field `EERIE` writer - EEPROM Ready Interrupt Enable"]
pub type EERIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EECR_SPEC , bool , O > ; # [doc = "Field `EEPM` reader - EEPROM Programming Mode"]
pub type EEPM_R = crate :: FieldReader < u8 , EEPM_A > ; # [doc = "EEPROM Programming Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EEPM_A { # [doc = "0: Erase and Write in one operation (Atomic Operation)"]
ERASE_AND_WRITE_IN_ONE_OPERATION_ATOMIC_OPERATION = 0 , # [doc = "1: Erase only"]
ERASE_ONLY = 1 , # [doc = "2: Write only"]
WRITE_ONLY = 2 , # [doc = "3: Reserved for future use"]
RESERVED_FOR_FUTURE_USE = 3 , } impl From < EEPM_A > for u8 { # [inline (always)]
fn from (variant : EEPM_A) -> Self { variant as _ } } impl EEPM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EEPM_A { match self . bits { 0 => EEPM_A :: ERASE_AND_WRITE_IN_ONE_OPERATION_ATOMIC_OPERATION , 1 => EEPM_A :: ERASE_ONLY , 2 => EEPM_A :: WRITE_ONLY , 3 => EEPM_A :: RESERVED_FOR_FUTURE_USE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ERASE_AND_WRITE_IN_ONE_OPERATION_ATOMIC_OPERATION`"]
# [inline (always)]
pub fn is_erase_and_write_in_one_operation_atomic_operation (& self) -> bool { * self == EEPM_A :: ERASE_AND_WRITE_IN_ONE_OPERATION_ATOMIC_OPERATION } # [doc = "Checks if the value of the field is `ERASE_ONLY`"]
# [inline (always)]
pub fn is_erase_only (& self) -> bool { * self == EEPM_A :: ERASE_ONLY } # [doc = "Checks if the value of the field is `WRITE_ONLY`"]
# [inline (always)]
pub fn is_write_only (& self) -> bool { * self == EEPM_A :: WRITE_ONLY } # [doc = "Checks if the value of the field is `RESERVED_FOR_FUTURE_USE`"]
# [inline (always)]
pub fn is_reserved_for_future_use (& self) -> bool { * self == EEPM_A :: RESERVED_FOR_FUTURE_USE } } # [doc = "Field `EEPM` writer - EEPROM Programming Mode"]
pub type EEPM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EECR_SPEC , u8 , EEPM_A , 2 , O > ; impl < 'a , const O : u8 > EEPM_W < 'a , O > { # [doc = "Erase and Write in one operation (Atomic Operation)"]
# [inline (always)]
pub fn erase_and_write_in_one_operation_atomic_operation (self) -> & 'a mut W { self . variant (EEPM_A :: ERASE_AND_WRITE_IN_ONE_OPERATION_ATOMIC_OPERATION) } # [doc = "Erase only"]
# [inline (always)]
pub fn erase_only (self) -> & 'a mut W { self . variant (EEPM_A :: ERASE_ONLY) } # [doc = "Write only"]
# [inline (always)]
pub fn write_only (self) -> & 'a mut W { self . variant (EEPM_A :: WRITE_ONLY) } # [doc = "Reserved for future use"]
# [inline (always)]
pub fn reserved_for_future_use (self) -> & 'a mut W { self . variant (EEPM_A :: RESERVED_FOR_FUTURE_USE) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EECR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - EEPROM Read Enable"]
# [inline (always)]
pub fn eere (& self) -> EERE_R { EERE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EEPROM Programming Enable"]
# [inline (always)]
pub fn eepe (& self) -> EEPE_R { EEPE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - EEPROM Master Write Enable"]
# [inline (always)]
pub fn eempe (& self) -> EEMPE_R { EEMPE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - EEPROM Ready Interrupt Enable"]
# [inline (always)]
pub fn eerie (& self) -> EERIE_R { EERIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - EEPROM Programming Mode"]
# [inline (always)]
pub fn eepm (& self) -> EEPM_R { EEPM_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - EEPROM Read Enable"]
# [inline (always)]
# [must_use]
pub fn eere (& mut self) -> EERE_W < 0 > { EERE_W :: new (self) } # [doc = "Bit 1 - EEPROM Programming Enable"]
# [inline (always)]
# [must_use]
pub fn eepe (& mut self) -> EEPE_W < 1 > { EEPE_W :: new (self) } # [doc = "Bit 2 - EEPROM Master Write Enable"]
# [inline (always)]
# [must_use]
pub fn eempe (& mut self) -> EEMPE_W < 2 > { EEMPE_W :: new (self) } # [doc = "Bit 3 - EEPROM Ready Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn eerie (& mut self) -> EERIE_W < 3 > { EERIE_W :: new (self) } # [doc = "Bits 4:5 - EEPROM Programming Mode"]
# [inline (always)]
# [must_use]
pub fn eepm (& mut self) -> EEPM_W < 4 > { EEPM_W :: new (self) } # [doc = "Bits 6:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 6 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "EEPROM Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eecr](index.html) module"]
pub struct EECR_SPEC ; impl crate :: RegisterSpec for EECR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eecr::R](R) reader structure"]
impl crate :: Readable for EECR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eecr::W](W) writer structure"]
impl crate :: Writable for EECR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EECR to value 0"]
impl crate :: Resettable for EECR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EEDR (rw) register accessor: an alias for `Reg<EEDR_SPEC>`"]
pub type EEDR = crate :: Reg < eedr :: EEDR_SPEC > ; # [doc = "EEPROM Data Register"]
pub mod eedr { # [doc = "Register `EEDR` reader"]
pub struct R (crate :: R < EEDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EEDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EEDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EEDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EEDR` writer"]
pub struct W (crate :: W < EEDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EEDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EEDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EEDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "EEPROM Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eedr](index.html) module"]
pub struct EEDR_SPEC ; impl crate :: RegisterSpec for EEDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eedr::R](R) reader structure"]
impl crate :: Readable for EEDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eedr::W](W) writer structure"]
impl crate :: Writable for EEDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EEDR to value 0"]
impl crate :: Resettable for EEDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "External Interrupts"]
pub struct EXINT { _marker : PhantomData < * const () > } unsafe impl Send for EXINT { } impl EXINT { # [doc = r"Pointer to the register block"]
pub const PTR : * const exint :: RegisterBlock = 0x3b as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const exint :: RegisterBlock { Self :: PTR } } impl Deref for EXINT { type Target = exint :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EXINT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EXINT") . finish () } } # [doc = "External Interrupts"]
pub mod exint { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Pin Change Interrupt Flag Register"]
pub pcifr : PCIFR , # [doc = "0x01 - External Interrupt Flag Register"]
pub eifr : EIFR , # [doc = "0x02 - External Interrupt Mask Register"]
pub eimsk : EIMSK , _reserved3 : [u8 ; 0x2a]
, # [doc = "0x2d - Pin Change Interrupt Control Register"]
pub pcicr : PCICR , # [doc = "0x2e - External Interrupt Control Register A"]
pub eicra : EICRA , # [doc = "0x2f - External Interrupt Control Register B"]
pub eicrb : EICRB , # [doc = "0x30 - Pin Change Mask Register 0"]
pub pcmsk0 : PCMSK0 , # [doc = "0x31 - Pin Change Mask Register 1"]
pub pcmsk1 : PCMSK1 , # [doc = "0x32 - Pin Change Mask Register 2"]
pub pcmsk2 : PCMSK2 , } # [doc = "EICRA (rw) register accessor: an alias for `Reg<EICRA_SPEC>`"]
pub type EICRA = crate :: Reg < eicra :: EICRA_SPEC > ; # [doc = "External Interrupt Control Register A"]
pub mod eicra { # [doc = "Register `EICRA` reader"]
pub struct R (crate :: R < EICRA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EICRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EICRA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EICRA_SPEC >) -> Self { R (reader) } } # [doc = "Register `EICRA` writer"]
pub struct W (crate :: W < EICRA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EICRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EICRA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EICRA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC0` reader - External Interrupt 0 Sense Control Bit"]
pub type ISC0_R = crate :: FieldReader < u8 , ISC0_A > ; # [doc = "External Interrupt 0 Sense Control Bit\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC0_A { # [doc = "0: The low level of INTn generates an interrupt request."]
THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST = 0 , # [doc = "1: Any edge of INTn generates asynchronously an interrupt request."]
ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 1 , # [doc = "2: The falling edge of INTn generates asynchronously an interrupt request."]
THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 2 , # [doc = "3: The rising edge of INTn generates asynchronously an interrupt request."]
THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 3 , } impl From < ISC0_A > for u8 { # [inline (always)]
fn from (variant : ISC0_A) -> Self { variant as _ } } impl ISC0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC0_A { match self . bits { 0 => ISC0_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST , 1 => ISC0_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 2 => ISC0_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 3 => ISC0_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_low_level_of_intn_generates_an_interrupt_request (& self) -> bool { * self == ISC0_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_any_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC0_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC0_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC0_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } } # [doc = "Field `ISC0` writer - External Interrupt 0 Sense Control Bit"]
pub type ISC0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRA_SPEC , u8 , ISC0_A , 2 , O > ; impl < 'a , const O : u8 > ISC0_W < 'a , O > { # [doc = "The low level of INTn generates an interrupt request."]
# [inline (always)]
pub fn the_low_level_of_intn_generates_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC0_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST) } # [doc = "Any edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn any_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC0_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The falling edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC0_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The rising edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC0_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } } # [doc = "Field `ISC1` reader - External Interrupt 1 Sense Control Bit"]
pub type ISC1_R = crate :: FieldReader < u8 , ISC1_A > ; # [doc = "External Interrupt 1 Sense Control Bit\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC1_A { # [doc = "0: The low level of INTn generates an interrupt request."]
THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST = 0 , # [doc = "1: Any edge of INTn generates asynchronously an interrupt request."]
ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 1 , # [doc = "2: The falling edge of INTn generates asynchronously an interrupt request."]
THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 2 , # [doc = "3: The rising edge of INTn generates asynchronously an interrupt request."]
THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 3 , } impl From < ISC1_A > for u8 { # [inline (always)]
fn from (variant : ISC1_A) -> Self { variant as _ } } impl ISC1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC1_A { match self . bits { 0 => ISC1_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST , 1 => ISC1_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 2 => ISC1_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 3 => ISC1_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_low_level_of_intn_generates_an_interrupt_request (& self) -> bool { * self == ISC1_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_any_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC1_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC1_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC1_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } } # [doc = "Field `ISC1` writer - External Interrupt 1 Sense Control Bit"]
pub type ISC1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRA_SPEC , u8 , ISC1_A , 2 , O > ; impl < 'a , const O : u8 > ISC1_W < 'a , O > { # [doc = "The low level of INTn generates an interrupt request."]
# [inline (always)]
pub fn the_low_level_of_intn_generates_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC1_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST) } # [doc = "Any edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn any_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC1_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The falling edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC1_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The rising edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC1_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } } # [doc = "Field `ISC2` reader - External Interrupt 2 Sense Control Bit"]
pub type ISC2_R = crate :: FieldReader < u8 , ISC2_A > ; # [doc = "External Interrupt 2 Sense Control Bit\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC2_A { # [doc = "0: The low level of INTn generates an interrupt request."]
THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST = 0 , # [doc = "1: Any edge of INTn generates asynchronously an interrupt request."]
ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 1 , # [doc = "2: The falling edge of INTn generates asynchronously an interrupt request."]
THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 2 , # [doc = "3: The rising edge of INTn generates asynchronously an interrupt request."]
THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 3 , } impl From < ISC2_A > for u8 { # [inline (always)]
fn from (variant : ISC2_A) -> Self { variant as _ } } impl ISC2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC2_A { match self . bits { 0 => ISC2_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST , 1 => ISC2_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 2 => ISC2_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 3 => ISC2_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_low_level_of_intn_generates_an_interrupt_request (& self) -> bool { * self == ISC2_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_any_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC2_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC2_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC2_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } } # [doc = "Field `ISC2` writer - External Interrupt 2 Sense Control Bit"]
pub type ISC2_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRA_SPEC , u8 , ISC2_A , 2 , O > ; impl < 'a , const O : u8 > ISC2_W < 'a , O > { # [doc = "The low level of INTn generates an interrupt request."]
# [inline (always)]
pub fn the_low_level_of_intn_generates_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC2_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST) } # [doc = "Any edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn any_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC2_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The falling edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC2_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The rising edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC2_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } } # [doc = "Field `ISC3` reader - External Interrupt 3 Sense Control Bit"]
pub type ISC3_R = crate :: FieldReader < u8 , ISC3_A > ; # [doc = "External Interrupt 3 Sense Control Bit\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC3_A { # [doc = "0: The low level of INTn generates an interrupt request."]
THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST = 0 , # [doc = "1: Any edge of INTn generates asynchronously an interrupt request."]
ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 1 , # [doc = "2: The falling edge of INTn generates asynchronously an interrupt request."]
THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 2 , # [doc = "3: The rising edge of INTn generates asynchronously an interrupt request."]
THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 3 , } impl From < ISC3_A > for u8 { # [inline (always)]
fn from (variant : ISC3_A) -> Self { variant as _ } } impl ISC3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC3_A { match self . bits { 0 => ISC3_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST , 1 => ISC3_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 2 => ISC3_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 3 => ISC3_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_low_level_of_intn_generates_an_interrupt_request (& self) -> bool { * self == ISC3_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_any_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC3_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC3_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC3_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } } # [doc = "Field `ISC3` writer - External Interrupt 3 Sense Control Bit"]
pub type ISC3_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRA_SPEC , u8 , ISC3_A , 2 , O > ; impl < 'a , const O : u8 > ISC3_W < 'a , O > { # [doc = "The low level of INTn generates an interrupt request."]
# [inline (always)]
pub fn the_low_level_of_intn_generates_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC3_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST) } # [doc = "Any edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn any_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC3_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The falling edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC3_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The rising edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC3_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } } impl R { # [doc = "Bits 0:1 - External Interrupt 0 Sense Control Bit"]
# [inline (always)]
pub fn isc0 (& self) -> ISC0_R { ISC0_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - External Interrupt 1 Sense Control Bit"]
# [inline (always)]
pub fn isc1 (& self) -> ISC1_R { ISC1_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - External Interrupt 2 Sense Control Bit"]
# [inline (always)]
pub fn isc2 (& self) -> ISC2_R { ISC2_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - External Interrupt 3 Sense Control Bit"]
# [inline (always)]
pub fn isc3 (& self) -> ISC3_R { ISC3_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - External Interrupt 0 Sense Control Bit"]
# [inline (always)]
# [must_use]
pub fn isc0 (& mut self) -> ISC0_W < 0 > { ISC0_W :: new (self) } # [doc = "Bits 2:3 - External Interrupt 1 Sense Control Bit"]
# [inline (always)]
# [must_use]
pub fn isc1 (& mut self) -> ISC1_W < 2 > { ISC1_W :: new (self) } # [doc = "Bits 4:5 - External Interrupt 2 Sense Control Bit"]
# [inline (always)]
# [must_use]
pub fn isc2 (& mut self) -> ISC2_W < 4 > { ISC2_W :: new (self) } # [doc = "Bits 6:7 - External Interrupt 3 Sense Control Bit"]
# [inline (always)]
# [must_use]
pub fn isc3 (& mut self) -> ISC3_W < 6 > { ISC3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eicra](index.html) module"]
pub struct EICRA_SPEC ; impl crate :: RegisterSpec for EICRA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eicra::R](R) reader structure"]
impl crate :: Readable for EICRA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eicra::W](W) writer structure"]
impl crate :: Writable for EICRA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EICRA to value 0"]
impl crate :: Resettable for EICRA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EICRB (rw) register accessor: an alias for `Reg<EICRB_SPEC>`"]
pub type EICRB = crate :: Reg < eicrb :: EICRB_SPEC > ; # [doc = "External Interrupt Control Register B"]
pub mod eicrb { # [doc = "Register `EICRB` reader"]
pub struct R (crate :: R < EICRB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EICRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EICRB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EICRB_SPEC >) -> Self { R (reader) } } # [doc = "Register `EICRB` writer"]
pub struct W (crate :: W < EICRB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EICRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EICRB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EICRB_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC4` reader - External Interrupt 4 Sense Control Bit"]
pub type ISC4_R = crate :: FieldReader < u8 , ISC4_A > ; # [doc = "External Interrupt 4 Sense Control Bit\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC4_A { # [doc = "0: The low level of INTn generates an interrupt request."]
THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST = 0 , # [doc = "1: Any edge of INTn generates asynchronously an interrupt request."]
ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 1 , # [doc = "2: The falling edge of INTn generates asynchronously an interrupt request."]
THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 2 , # [doc = "3: The rising edge of INTn generates asynchronously an interrupt request."]
THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 3 , } impl From < ISC4_A > for u8 { # [inline (always)]
fn from (variant : ISC4_A) -> Self { variant as _ } } impl ISC4_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC4_A { match self . bits { 0 => ISC4_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST , 1 => ISC4_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 2 => ISC4_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 3 => ISC4_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_low_level_of_intn_generates_an_interrupt_request (& self) -> bool { * self == ISC4_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_any_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC4_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC4_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC4_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } } # [doc = "Field `ISC4` writer - External Interrupt 4 Sense Control Bit"]
pub type ISC4_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRB_SPEC , u8 , ISC4_A , 2 , O > ; impl < 'a , const O : u8 > ISC4_W < 'a , O > { # [doc = "The low level of INTn generates an interrupt request."]
# [inline (always)]
pub fn the_low_level_of_intn_generates_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC4_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST) } # [doc = "Any edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn any_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC4_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The falling edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC4_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The rising edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC4_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } } # [doc = "Field `ISC5` reader - External Interrupt 5 Sense Control Bit"]
pub type ISC5_R = crate :: FieldReader < u8 , ISC5_A > ; # [doc = "External Interrupt 5 Sense Control Bit\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC5_A { # [doc = "0: The low level of INTn generates an interrupt request."]
THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST = 0 , # [doc = "1: Any edge of INTn generates asynchronously an interrupt request."]
ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 1 , # [doc = "2: The falling edge of INTn generates asynchronously an interrupt request."]
THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 2 , # [doc = "3: The rising edge of INTn generates asynchronously an interrupt request."]
THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 3 , } impl From < ISC5_A > for u8 { # [inline (always)]
fn from (variant : ISC5_A) -> Self { variant as _ } } impl ISC5_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC5_A { match self . bits { 0 => ISC5_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST , 1 => ISC5_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 2 => ISC5_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 3 => ISC5_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_low_level_of_intn_generates_an_interrupt_request (& self) -> bool { * self == ISC5_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_any_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC5_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC5_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC5_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } } # [doc = "Field `ISC5` writer - External Interrupt 5 Sense Control Bit"]
pub type ISC5_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRB_SPEC , u8 , ISC5_A , 2 , O > ; impl < 'a , const O : u8 > ISC5_W < 'a , O > { # [doc = "The low level of INTn generates an interrupt request."]
# [inline (always)]
pub fn the_low_level_of_intn_generates_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC5_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST) } # [doc = "Any edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn any_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC5_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The falling edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC5_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The rising edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC5_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } } # [doc = "Field `ISC6` reader - External Interrupt 6 Sense Control Bit"]
pub type ISC6_R = crate :: FieldReader < u8 , ISC6_A > ; # [doc = "External Interrupt 6 Sense Control Bit\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC6_A { # [doc = "0: The low level of INTn generates an interrupt request."]
THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST = 0 , # [doc = "1: Any edge of INTn generates asynchronously an interrupt request."]
ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 1 , # [doc = "2: The falling edge of INTn generates asynchronously an interrupt request."]
THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 2 , # [doc = "3: The rising edge of INTn generates asynchronously an interrupt request."]
THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 3 , } impl From < ISC6_A > for u8 { # [inline (always)]
fn from (variant : ISC6_A) -> Self { variant as _ } } impl ISC6_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC6_A { match self . bits { 0 => ISC6_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST , 1 => ISC6_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 2 => ISC6_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 3 => ISC6_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_low_level_of_intn_generates_an_interrupt_request (& self) -> bool { * self == ISC6_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_any_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC6_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC6_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC6_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } } # [doc = "Field `ISC6` writer - External Interrupt 6 Sense Control Bit"]
pub type ISC6_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRB_SPEC , u8 , ISC6_A , 2 , O > ; impl < 'a , const O : u8 > ISC6_W < 'a , O > { # [doc = "The low level of INTn generates an interrupt request."]
# [inline (always)]
pub fn the_low_level_of_intn_generates_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC6_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST) } # [doc = "Any edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn any_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC6_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The falling edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC6_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The rising edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC6_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } } # [doc = "Field `ISC7` reader - External Interrupt 7 Sense Control Bit"]
pub type ISC7_R = crate :: FieldReader < u8 , ISC7_A > ; # [doc = "External Interrupt 7 Sense Control Bit\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC7_A { # [doc = "0: The low level of INTn generates an interrupt request."]
THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST = 0 , # [doc = "1: Any edge of INTn generates asynchronously an interrupt request."]
ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 1 , # [doc = "2: The falling edge of INTn generates asynchronously an interrupt request."]
THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 2 , # [doc = "3: The rising edge of INTn generates asynchronously an interrupt request."]
THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST = 3 , } impl From < ISC7_A > for u8 { # [inline (always)]
fn from (variant : ISC7_A) -> Self { variant as _ } } impl ISC7_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC7_A { match self . bits { 0 => ISC7_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST , 1 => ISC7_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 2 => ISC7_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , 3 => ISC7_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_low_level_of_intn_generates_an_interrupt_request (& self) -> bool { * self == ISC7_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_any_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC7_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC7_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (& self) -> bool { * self == ISC7_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST } } # [doc = "Field `ISC7` writer - External Interrupt 7 Sense Control Bit"]
pub type ISC7_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRB_SPEC , u8 , ISC7_A , 2 , O > ; impl < 'a , const O : u8 > ISC7_W < 'a , O > { # [doc = "The low level of INTn generates an interrupt request."]
# [inline (always)]
pub fn the_low_level_of_intn_generates_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC7_A :: THE_LOW_LEVEL_OF_INTN_GENERATES_AN_INTERRUPT_REQUEST) } # [doc = "Any edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn any_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC7_A :: ANY_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The falling edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_falling_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC7_A :: THE_FALLING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } # [doc = "The rising edge of INTn generates asynchronously an interrupt request."]
# [inline (always)]
pub fn the_rising_edge_of_intn_generates_asynchronously_an_interrupt_request (self) -> & 'a mut W { self . variant (ISC7_A :: THE_RISING_EDGE_OF_INTN_GENERATES_ASYNCHRONOUSLY_AN_INTERRUPT_REQUEST) } } impl R { # [doc = "Bits 0:1 - External Interrupt 4 Sense Control Bit"]
# [inline (always)]
pub fn isc4 (& self) -> ISC4_R { ISC4_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - External Interrupt 5 Sense Control Bit"]
# [inline (always)]
pub fn isc5 (& self) -> ISC5_R { ISC5_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - External Interrupt 6 Sense Control Bit"]
# [inline (always)]
pub fn isc6 (& self) -> ISC6_R { ISC6_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - External Interrupt 7 Sense Control Bit"]
# [inline (always)]
pub fn isc7 (& self) -> ISC7_R { ISC7_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - External Interrupt 4 Sense Control Bit"]
# [inline (always)]
# [must_use]
pub fn isc4 (& mut self) -> ISC4_W < 0 > { ISC4_W :: new (self) } # [doc = "Bits 2:3 - External Interrupt 5 Sense Control Bit"]
# [inline (always)]
# [must_use]
pub fn isc5 (& mut self) -> ISC5_W < 2 > { ISC5_W :: new (self) } # [doc = "Bits 4:5 - External Interrupt 6 Sense Control Bit"]
# [inline (always)]
# [must_use]
pub fn isc6 (& mut self) -> ISC6_W < 4 > { ISC6_W :: new (self) } # [doc = "Bits 6:7 - External Interrupt 7 Sense Control Bit"]
# [inline (always)]
# [must_use]
pub fn isc7 (& mut self) -> ISC7_W < 6 > { ISC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eicrb](index.html) module"]
pub struct EICRB_SPEC ; impl crate :: RegisterSpec for EICRB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eicrb::R](R) reader structure"]
impl crate :: Readable for EICRB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eicrb::W](W) writer structure"]
impl crate :: Writable for EICRB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EICRB to value 0"]
impl crate :: Resettable for EICRB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EIFR (rw) register accessor: an alias for `Reg<EIFR_SPEC>`"]
pub type EIFR = crate :: Reg < eifr :: EIFR_SPEC > ; # [doc = "External Interrupt Flag Register"]
pub mod eifr { # [doc = "Register `EIFR` reader"]
pub struct R (crate :: R < EIFR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EIFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EIFR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EIFR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EIFR` writer"]
pub struct W (crate :: W < EIFR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EIFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EIFR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EIFR_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTF` reader - External Interrupt Flag"]
pub type INTF_R = crate :: FieldReader < u8 , INTF_A > ; # [doc = "External Interrupt Flag\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTF_A { # [doc = "0: No edge or logic change on INT7:0 occurred."]
NO_EDGE_OR_LOGIC_CHANGE_ON_INT7_0_OCCURRED = 0 , # [doc = "1: A edge or logic change on INT0 occurred and triggered an interrupt request."]
A_EDGE_OR_LOGIC_CHANGE_ON_INT0_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST = 1 , # [doc = "128: A edge or logic change on INT7 occurred and triggered an interrupt request."]
A_EDGE_OR_LOGIC_CHANGE_ON_INT7_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST = 128 , } impl From < INTF_A > for u8 { # [inline (always)]
fn from (variant : INTF_A) -> Self { variant as _ } } impl INTF_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INTF_A > { match self . bits { 0 => Some (INTF_A :: NO_EDGE_OR_LOGIC_CHANGE_ON_INT7_0_OCCURRED) , 1 => Some (INTF_A :: A_EDGE_OR_LOGIC_CHANGE_ON_INT0_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST) , 128 => Some (INTF_A :: A_EDGE_OR_LOGIC_CHANGE_ON_INT7_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST) , _ => None , } } # [doc = "Checks if the value of the field is `NO_EDGE_OR_LOGIC_CHANGE_ON_INT7_0_OCCURRED`"]
# [inline (always)]
pub fn is_no_edge_or_logic_change_on_int7_0_occurred (& self) -> bool { * self == INTF_A :: NO_EDGE_OR_LOGIC_CHANGE_ON_INT7_0_OCCURRED } # [doc = "Checks if the value of the field is `A_EDGE_OR_LOGIC_CHANGE_ON_INT0_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_a_edge_or_logic_change_on_int0_occurred_and_triggered_an_interrupt_request (& self) -> bool { * self == INTF_A :: A_EDGE_OR_LOGIC_CHANGE_ON_INT0_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST } # [doc = "Checks if the value of the field is `A_EDGE_OR_LOGIC_CHANGE_ON_INT7_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST`"]
# [inline (always)]
pub fn is_a_edge_or_logic_change_on_int7_occurred_and_triggered_an_interrupt_request (& self) -> bool { * self == INTF_A :: A_EDGE_OR_LOGIC_CHANGE_ON_INT7_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST } } # [doc = "Field `INTF` writer - External Interrupt Flag"]
pub type INTF_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , EIFR_SPEC , u8 , INTF_A , 8 , O > ; impl < 'a , const O : u8 > INTF_W < 'a , O > { # [doc = "No edge or logic change on INT7:0 occurred."]
# [inline (always)]
pub fn no_edge_or_logic_change_on_int7_0_occurred (self) -> & 'a mut W { self . variant (INTF_A :: NO_EDGE_OR_LOGIC_CHANGE_ON_INT7_0_OCCURRED) } # [doc = "A edge or logic change on INT0 occurred and triggered an interrupt request."]
# [inline (always)]
pub fn a_edge_or_logic_change_on_int0_occurred_and_triggered_an_interrupt_request (self) -> & 'a mut W { self . variant (INTF_A :: A_EDGE_OR_LOGIC_CHANGE_ON_INT0_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST) } # [doc = "A edge or logic change on INT7 occurred and triggered an interrupt request."]
# [inline (always)]
pub fn a_edge_or_logic_change_on_int7_occurred_and_triggered_an_interrupt_request (self) -> & 'a mut W { self . variant (INTF_A :: A_EDGE_OR_LOGIC_CHANGE_ON_INT7_OCCURRED_AND_TRIGGERED_AN_INTERRUPT_REQUEST) } } impl R { # [doc = "Bits 0:7 - External Interrupt Flag"]
# [inline (always)]
pub fn intf (& self) -> INTF_R { INTF_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - External Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn intf (& mut self) -> INTF_W < 0 > { INTF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eifr](index.html) module"]
pub struct EIFR_SPEC ; impl crate :: RegisterSpec for EIFR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eifr::R](R) reader structure"]
impl crate :: Readable for EIFR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eifr::W](W) writer structure"]
impl crate :: Writable for EIFR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EIFR to value 0"]
impl crate :: Resettable for EIFR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EIMSK (rw) register accessor: an alias for `Reg<EIMSK_SPEC>`"]
pub type EIMSK = crate :: Reg < eimsk :: EIMSK_SPEC > ; # [doc = "External Interrupt Mask Register"]
pub mod eimsk { # [doc = "Register `EIMSK` reader"]
pub struct R (crate :: R < EIMSK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EIMSK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EIMSK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EIMSK_SPEC >) -> Self { R (reader) } } # [doc = "Register `EIMSK` writer"]
pub struct W (crate :: W < EIMSK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EIMSK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EIMSK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EIMSK_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - External Interrupt Request Enable"]
pub type INT_R = crate :: FieldReader < u8 , INT_A > ; # [doc = "External Interrupt Request Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT_A { # [doc = "0: All external pin interrupts are disabled."]
ALL_EXTERNAL_PIN_INTERRUPTS_ARE_DISABLED = 0 , # [doc = "255: All external pin interrupts are enabled."]
ALL_EXTERNAL_PIN_INTERRUPTS_ARE_ENABLED = 255 , } impl From < INT_A > for u8 { # [inline (always)]
fn from (variant : INT_A) -> Self { variant as _ } } impl INT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INT_A > { match self . bits { 0 => Some (INT_A :: ALL_EXTERNAL_PIN_INTERRUPTS_ARE_DISABLED) , 255 => Some (INT_A :: ALL_EXTERNAL_PIN_INTERRUPTS_ARE_ENABLED) , _ => None , } } # [doc = "Checks if the value of the field is `ALL_EXTERNAL_PIN_INTERRUPTS_ARE_DISABLED`"]
# [inline (always)]
pub fn is_all_external_pin_interrupts_are_disabled (& self) -> bool { * self == INT_A :: ALL_EXTERNAL_PIN_INTERRUPTS_ARE_DISABLED } # [doc = "Checks if the value of the field is `ALL_EXTERNAL_PIN_INTERRUPTS_ARE_ENABLED`"]
# [inline (always)]
pub fn is_all_external_pin_interrupts_are_enabled (& self) -> bool { * self == INT_A :: ALL_EXTERNAL_PIN_INTERRUPTS_ARE_ENABLED } } # [doc = "Field `INT` writer - External Interrupt Request Enable"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , EIMSK_SPEC , u8 , INT_A , 8 , O > ; impl < 'a , const O : u8 > INT_W < 'a , O > { # [doc = "All external pin interrupts are disabled."]
# [inline (always)]
pub fn all_external_pin_interrupts_are_disabled (self) -> & 'a mut W { self . variant (INT_A :: ALL_EXTERNAL_PIN_INTERRUPTS_ARE_DISABLED) } # [doc = "All external pin interrupts are enabled."]
# [inline (always)]
pub fn all_external_pin_interrupts_are_enabled (self) -> & 'a mut W { self . variant (INT_A :: ALL_EXTERNAL_PIN_INTERRUPTS_ARE_ENABLED) } } impl R { # [doc = "Bits 0:7 - External Interrupt Request Enable"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - External Interrupt Request Enable"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eimsk](index.html) module"]
pub struct EIMSK_SPEC ; impl crate :: RegisterSpec for EIMSK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eimsk::R](R) reader structure"]
impl crate :: Readable for EIMSK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eimsk::W](W) writer structure"]
impl crate :: Writable for EIMSK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EIMSK to value 0"]
impl crate :: Resettable for EIMSK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCICR (rw) register accessor: an alias for `Reg<PCICR_SPEC>`"]
pub type PCICR = crate :: Reg < pcicr :: PCICR_SPEC > ; # [doc = "Pin Change Interrupt Control Register"]
pub mod pcicr { # [doc = "Register `PCICR` reader"]
pub struct R (crate :: R < PCICR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCICR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCICR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCICR_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCICR` writer"]
pub struct W (crate :: W < PCICR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCICR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCICR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCICR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCIE` reader - Pin Change Interrupt Enables"]
pub type PCIE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCIE` writer - Pin Change Interrupt Enables"]
pub type PCIE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCICR_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCICR_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bits 0:2 - Pin Change Interrupt Enables"]
# [inline (always)]
pub fn pcie (& self) -> PCIE_R { PCIE_R :: new (self . bits & 7) } # [doc = "Bits 3:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 3) & 0x1f) } } impl W { # [doc = "Bits 0:2 - Pin Change Interrupt Enables"]
# [inline (always)]
# [must_use]
pub fn pcie (& mut self) -> PCIE_W < 0 > { PCIE_W :: new (self) } # [doc = "Bits 3:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 3 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin Change Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcicr](index.html) module"]
pub struct PCICR_SPEC ; impl crate :: RegisterSpec for PCICR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcicr::R](R) reader structure"]
impl crate :: Readable for PCICR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcicr::W](W) writer structure"]
impl crate :: Writable for PCICR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCICR to value 0"]
impl crate :: Resettable for PCICR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCIFR (rw) register accessor: an alias for `Reg<PCIFR_SPEC>`"]
pub type PCIFR = crate :: Reg < pcifr :: PCIFR_SPEC > ; # [doc = "Pin Change Interrupt Flag Register"]
pub mod pcifr { # [doc = "Register `PCIFR` reader"]
pub struct R (crate :: R < PCIFR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCIFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCIFR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCIFR_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCIFR` writer"]
pub struct W (crate :: W < PCIFR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCIFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCIFR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCIFR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCIF` reader - Pin Change Interrupt Flags"]
pub type PCIF_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCIF` writer - Pin Change Interrupt Flags"]
pub type PCIF_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCIFR_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCIFR_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bits 0:2 - Pin Change Interrupt Flags"]
# [inline (always)]
pub fn pcif (& self) -> PCIF_R { PCIF_R :: new (self . bits & 7) } # [doc = "Bits 3:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 3) & 0x1f) } } impl W { # [doc = "Bits 0:2 - Pin Change Interrupt Flags"]
# [inline (always)]
# [must_use]
pub fn pcif (& mut self) -> PCIF_W < 0 > { PCIF_W :: new (self) } # [doc = "Bits 3:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 3 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin Change Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcifr](index.html) module"]
pub struct PCIFR_SPEC ; impl crate :: RegisterSpec for PCIFR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcifr::R](R) reader structure"]
impl crate :: Readable for PCIFR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcifr::W](W) writer structure"]
impl crate :: Writable for PCIFR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCIFR to value 0"]
impl crate :: Resettable for PCIFR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCMSK0 (rw) register accessor: an alias for `Reg<PCMSK0_SPEC>`"]
pub type PCMSK0 = crate :: Reg < pcmsk0 :: PCMSK0_SPEC > ; # [doc = "Pin Change Mask Register 0"]
pub mod pcmsk0 { # [doc = "Register `PCMSK0` reader"]
pub struct R (crate :: R < PCMSK0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCMSK0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCMSK0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCMSK0_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCMSK0` writer"]
pub struct W (crate :: W < PCMSK0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCMSK0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCMSK0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCMSK0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Pin Change Mask Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcmsk0](index.html) module"]
pub struct PCMSK0_SPEC ; impl crate :: RegisterSpec for PCMSK0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcmsk0::R](R) reader structure"]
impl crate :: Readable for PCMSK0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcmsk0::W](W) writer structure"]
impl crate :: Writable for PCMSK0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCMSK0 to value 0"]
impl crate :: Resettable for PCMSK0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCMSK1 (rw) register accessor: an alias for `Reg<PCMSK1_SPEC>`"]
pub type PCMSK1 = crate :: Reg < pcmsk1 :: PCMSK1_SPEC > ; # [doc = "Pin Change Mask Register 1"]
pub mod pcmsk1 { # [doc = "Register `PCMSK1` reader"]
pub struct R (crate :: R < PCMSK1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCMSK1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCMSK1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCMSK1_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCMSK1` writer"]
pub struct W (crate :: W < PCMSK1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCMSK1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCMSK1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCMSK1_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCINT` reader - Pin Change Enable Mask"]
pub type PCINT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCINT` writer - Pin Change Enable Mask"]
pub type PCINT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCMSK1_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Change Enable Mask"]
# [inline (always)]
pub fn pcint (& self) -> PCINT_R { PCINT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Change Enable Mask"]
# [inline (always)]
# [must_use]
pub fn pcint (& mut self) -> PCINT_W < 0 > { PCINT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Pin Change Mask Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcmsk1](index.html) module"]
pub struct PCMSK1_SPEC ; impl crate :: RegisterSpec for PCMSK1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcmsk1::R](R) reader structure"]
impl crate :: Readable for PCMSK1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcmsk1::W](W) writer structure"]
impl crate :: Writable for PCMSK1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCMSK1 to value 0"]
impl crate :: Resettable for PCMSK1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCMSK2 (rw) register accessor: an alias for `Reg<PCMSK2_SPEC>`"]
pub type PCMSK2 = crate :: Reg < pcmsk2 :: PCMSK2_SPEC > ; # [doc = "Pin Change Mask Register 2"]
pub mod pcmsk2 { # [doc = "Register `PCMSK2` reader"]
pub struct R (crate :: R < PCMSK2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCMSK2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCMSK2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCMSK2_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCMSK2` writer"]
pub struct W (crate :: W < PCMSK2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCMSK2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCMSK2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCMSK2_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCINT` reader - Pin Change Enable Mask"]
pub type PCINT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCINT` writer - Pin Change Enable Mask"]
pub type PCINT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCMSK2_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Change Enable Mask"]
# [inline (always)]
pub fn pcint (& self) -> PCINT_R { PCINT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Change Enable Mask"]
# [inline (always)]
# [must_use]
pub fn pcint (& mut self) -> PCINT_W < 0 > { PCINT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Pin Change Mask Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcmsk2](index.html) module"]
pub struct PCMSK2_SPEC ; impl crate :: RegisterSpec for PCMSK2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcmsk2::R](R) reader structure"]
impl crate :: Readable for PCMSK2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcmsk2::W](W) writer structure"]
impl crate :: Writable for PCMSK2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCMSK2 to value 0"]
impl crate :: Resettable for PCMSK2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "FLASH Controller"]
pub struct FLASH { _marker : PhantomData < * const () > } unsafe impl Send for FLASH { } impl FLASH { # [doc = r"Pointer to the register block"]
pub const PTR : * const flash :: RegisterBlock = 0x67 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const flash :: RegisterBlock { Self :: PTR } } impl Deref for FLASH { type Target = flash :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FLASH { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FLASH") . finish () } } # [doc = "FLASH Controller"]
pub mod flash { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Reference Voltage Calibration Register"]
pub bgcr : BGCR , _reserved1 : [u8 ; 0x0d]
, # [doc = "0x0e - Flash Extended-Mode Control-Register"]
pub nemcr : NEMCR , } # [doc = "BGCR (rw) register accessor: an alias for `Reg<BGCR_SPEC>`"]
pub type BGCR = crate :: Reg < bgcr :: BGCR_SPEC > ; # [doc = "Reference Voltage Calibration Register"]
pub mod bgcr { # [doc = "Register `BGCR` reader"]
pub struct R (crate :: R < BGCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BGCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BGCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BGCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `BGCR` writer"]
pub struct W (crate :: W < BGCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BGCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BGCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BGCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `BGCAL` reader - Coarse Calibration Bits"]
pub type BGCAL_R = crate :: FieldReader < u8 , BGCAL_A > ; # [doc = "Coarse Calibration Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BGCAL_A { # [doc = "0: Setting for highest voltage"]
SETTING_FOR_HIGHEST_VOLTAGE = 0 , # [doc = "3: Voltage step up"]
VOLTAGE_STEP_UP = 3 , # [doc = "4: Center value"]
CENTER_VALUE = 4 , # [doc = "5: Voltage step down"]
VOLTAGE_STEP_DOWN = 5 , # [doc = "7: Setting for lowest voltage"]
SETTING_FOR_LOWEST_VOLTAGE = 7 , } impl From < BGCAL_A > for u8 { # [inline (always)]
fn from (variant : BGCAL_A) -> Self { variant as _ } } impl BGCAL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < BGCAL_A > { match self . bits { 0 => Some (BGCAL_A :: SETTING_FOR_HIGHEST_VOLTAGE) , 3 => Some (BGCAL_A :: VOLTAGE_STEP_UP) , 4 => Some (BGCAL_A :: CENTER_VALUE) , 5 => Some (BGCAL_A :: VOLTAGE_STEP_DOWN) , 7 => Some (BGCAL_A :: SETTING_FOR_LOWEST_VOLTAGE) , _ => None , } } # [doc = "Checks if the value of the field is `SETTING_FOR_HIGHEST_VOLTAGE`"]
# [inline (always)]
pub fn is_setting_for_highest_voltage (& self) -> bool { * self == BGCAL_A :: SETTING_FOR_HIGHEST_VOLTAGE } # [doc = "Checks if the value of the field is `VOLTAGE_STEP_UP`"]
# [inline (always)]
pub fn is_voltage_step_up (& self) -> bool { * self == BGCAL_A :: VOLTAGE_STEP_UP } # [doc = "Checks if the value of the field is `CENTER_VALUE`"]
# [inline (always)]
pub fn is_center_value (& self) -> bool { * self == BGCAL_A :: CENTER_VALUE } # [doc = "Checks if the value of the field is `VOLTAGE_STEP_DOWN`"]
# [inline (always)]
pub fn is_voltage_step_down (& self) -> bool { * self == BGCAL_A :: VOLTAGE_STEP_DOWN } # [doc = "Checks if the value of the field is `SETTING_FOR_LOWEST_VOLTAGE`"]
# [inline (always)]
pub fn is_setting_for_lowest_voltage (& self) -> bool { * self == BGCAL_A :: SETTING_FOR_LOWEST_VOLTAGE } } # [doc = "Field `BGCAL` writer - Coarse Calibration Bits"]
pub type BGCAL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , BGCR_SPEC , u8 , BGCAL_A , 3 , O > ; impl < 'a , const O : u8 > BGCAL_W < 'a , O > { # [doc = "Setting for highest voltage"]
# [inline (always)]
pub fn setting_for_highest_voltage (self) -> & 'a mut W { self . variant (BGCAL_A :: SETTING_FOR_HIGHEST_VOLTAGE) } # [doc = "Voltage step up"]
# [inline (always)]
pub fn voltage_step_up (self) -> & 'a mut W { self . variant (BGCAL_A :: VOLTAGE_STEP_UP) } # [doc = "Center value"]
# [inline (always)]
pub fn center_value (self) -> & 'a mut W { self . variant (BGCAL_A :: CENTER_VALUE) } # [doc = "Voltage step down"]
# [inline (always)]
pub fn voltage_step_down (self) -> & 'a mut W { self . variant (BGCAL_A :: VOLTAGE_STEP_DOWN) } # [doc = "Setting for lowest voltage"]
# [inline (always)]
pub fn setting_for_lowest_voltage (self) -> & 'a mut W { self . variant (BGCAL_A :: SETTING_FOR_LOWEST_VOLTAGE) } } # [doc = "Field `BGCAL_FINE` reader - Fine Calibration Bits"]
pub type BGCAL_FINE_R = crate :: FieldReader < u8 , BGCAL_FINE_A > ; # [doc = "Fine Calibration Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BGCAL_FINE_A { # [doc = "0: Center value"]
CENTER_VALUE = 0 , # [doc = "1: Voltage step up"]
VOLTAGE_STEP_UP = 1 , # [doc = "7: Setting for highest voltage"]
SETTING_FOR_HIGHEST_VOLTAGE = 7 , # [doc = "8: Voltage step down"]
VOLTAGE_STEP_DOWN = 8 , # [doc = "15: Setting for lowest voltage"]
SETTING_FOR_LOWEST_VOLTAGE = 15 , } impl From < BGCAL_FINE_A > for u8 { # [inline (always)]
fn from (variant : BGCAL_FINE_A) -> Self { variant as _ } } impl BGCAL_FINE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < BGCAL_FINE_A > { match self . bits { 0 => Some (BGCAL_FINE_A :: CENTER_VALUE) , 1 => Some (BGCAL_FINE_A :: VOLTAGE_STEP_UP) , 7 => Some (BGCAL_FINE_A :: SETTING_FOR_HIGHEST_VOLTAGE) , 8 => Some (BGCAL_FINE_A :: VOLTAGE_STEP_DOWN) , 15 => Some (BGCAL_FINE_A :: SETTING_FOR_LOWEST_VOLTAGE) , _ => None , } } # [doc = "Checks if the value of the field is `CENTER_VALUE`"]
# [inline (always)]
pub fn is_center_value (& self) -> bool { * self == BGCAL_FINE_A :: CENTER_VALUE } # [doc = "Checks if the value of the field is `VOLTAGE_STEP_UP`"]
# [inline (always)]
pub fn is_voltage_step_up (& self) -> bool { * self == BGCAL_FINE_A :: VOLTAGE_STEP_UP } # [doc = "Checks if the value of the field is `SETTING_FOR_HIGHEST_VOLTAGE`"]
# [inline (always)]
pub fn is_setting_for_highest_voltage (& self) -> bool { * self == BGCAL_FINE_A :: SETTING_FOR_HIGHEST_VOLTAGE } # [doc = "Checks if the value of the field is `VOLTAGE_STEP_DOWN`"]
# [inline (always)]
pub fn is_voltage_step_down (& self) -> bool { * self == BGCAL_FINE_A :: VOLTAGE_STEP_DOWN } # [doc = "Checks if the value of the field is `SETTING_FOR_LOWEST_VOLTAGE`"]
# [inline (always)]
pub fn is_setting_for_lowest_voltage (& self) -> bool { * self == BGCAL_FINE_A :: SETTING_FOR_LOWEST_VOLTAGE } } # [doc = "Field `BGCAL_FINE` writer - Fine Calibration Bits"]
pub type BGCAL_FINE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , BGCR_SPEC , u8 , BGCAL_FINE_A , 4 , O > ; impl < 'a , const O : u8 > BGCAL_FINE_W < 'a , O > { # [doc = "Center value"]
# [inline (always)]
pub fn center_value (self) -> & 'a mut W { self . variant (BGCAL_FINE_A :: CENTER_VALUE) } # [doc = "Voltage step up"]
# [inline (always)]
pub fn voltage_step_up (self) -> & 'a mut W { self . variant (BGCAL_FINE_A :: VOLTAGE_STEP_UP) } # [doc = "Setting for highest voltage"]
# [inline (always)]
pub fn setting_for_highest_voltage (self) -> & 'a mut W { self . variant (BGCAL_FINE_A :: SETTING_FOR_HIGHEST_VOLTAGE) } # [doc = "Voltage step down"]
# [inline (always)]
pub fn voltage_step_down (self) -> & 'a mut W { self . variant (BGCAL_FINE_A :: VOLTAGE_STEP_DOWN) } # [doc = "Setting for lowest voltage"]
# [inline (always)]
pub fn setting_for_lowest_voltage (self) -> & 'a mut W { self . variant (BGCAL_FINE_A :: SETTING_FOR_LOWEST_VOLTAGE) } } # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , BGCR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Coarse Calibration Bits"]
# [inline (always)]
pub fn bgcal (& self) -> BGCAL_R { BGCAL_R :: new (self . bits & 7) } # [doc = "Bits 3:6 - Fine Calibration Bits"]
# [inline (always)]
pub fn bgcal_fine (& self) -> BGCAL_FINE_R { BGCAL_FINE_R :: new ((self . bits >> 3) & 0x0f) } # [doc = "Bit 7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Coarse Calibration Bits"]
# [inline (always)]
# [must_use]
pub fn bgcal (& mut self) -> BGCAL_W < 0 > { BGCAL_W :: new (self) } # [doc = "Bits 3:6 - Fine Calibration Bits"]
# [inline (always)]
# [must_use]
pub fn bgcal_fine (& mut self) -> BGCAL_FINE_W < 3 > { BGCAL_FINE_W :: new (self) } # [doc = "Bit 7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 7 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Reference Voltage Calibration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bgcr](index.html) module"]
pub struct BGCR_SPEC ; impl crate :: RegisterSpec for BGCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [bgcr::R](R) reader structure"]
impl crate :: Readable for BGCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bgcr::W](W) writer structure"]
impl crate :: Writable for BGCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BGCR to value 0"]
impl crate :: Resettable for BGCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "NEMCR (rw) register accessor: an alias for `Reg<NEMCR_SPEC>`"]
pub type NEMCR = crate :: Reg < nemcr :: NEMCR_SPEC > ; # [doc = "Flash Extended-Mode Control-Register"]
pub mod nemcr { # [doc = "Register `NEMCR` reader"]
pub struct R (crate :: R < NEMCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < NEMCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < NEMCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < NEMCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `NEMCR` writer"]
pub struct W (crate :: W < NEMCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < NEMCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < NEMCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < NEMCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `AEAM` reader - Address for Extended Address Mode of Extra Rows"]
pub type AEAM_R = crate :: FieldReader < u8 , AEAM_A > ; # [doc = "Address for Extended Address Mode of Extra Rows\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum AEAM_A { # [doc = "0: Factory Row"]
FACTORY_ROW = 0 , # [doc = "1: User Row 1"]
USER_ROW_1 = 1 , # [doc = "2: User Row 2"]
USER_ROW_2 = 2 , # [doc = "3: User Row 3"]
USER_ROW_3 = 3 , } impl From < AEAM_A > for u8 { # [inline (always)]
fn from (variant : AEAM_A) -> Self { variant as _ } } impl AEAM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AEAM_A { match self . bits { 0 => AEAM_A :: FACTORY_ROW , 1 => AEAM_A :: USER_ROW_1 , 2 => AEAM_A :: USER_ROW_2 , 3 => AEAM_A :: USER_ROW_3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FACTORY_ROW`"]
# [inline (always)]
pub fn is_factory_row (& self) -> bool { * self == AEAM_A :: FACTORY_ROW } # [doc = "Checks if the value of the field is `USER_ROW_1`"]
# [inline (always)]
pub fn is_user_row_1 (& self) -> bool { * self == AEAM_A :: USER_ROW_1 } # [doc = "Checks if the value of the field is `USER_ROW_2`"]
# [inline (always)]
pub fn is_user_row_2 (& self) -> bool { * self == AEAM_A :: USER_ROW_2 } # [doc = "Checks if the value of the field is `USER_ROW_3`"]
# [inline (always)]
pub fn is_user_row_3 (& self) -> bool { * self == AEAM_A :: USER_ROW_3 } } # [doc = "Field `AEAM` writer - Address for Extended Address Mode of Extra Rows"]
pub type AEAM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , NEMCR_SPEC , u8 , AEAM_A , 2 , O > ; impl < 'a , const O : u8 > AEAM_W < 'a , O > { # [doc = "Factory Row"]
# [inline (always)]
pub fn factory_row (self) -> & 'a mut W { self . variant (AEAM_A :: FACTORY_ROW) } # [doc = "User Row 1"]
# [inline (always)]
pub fn user_row_1 (self) -> & 'a mut W { self . variant (AEAM_A :: USER_ROW_1) } # [doc = "User Row 2"]
# [inline (always)]
pub fn user_row_2 (self) -> & 'a mut W { self . variant (AEAM_A :: USER_ROW_2) } # [doc = "User Row 3"]
# [inline (always)]
pub fn user_row_3 (self) -> & 'a mut W { self . variant (AEAM_A :: USER_ROW_3) } } # [doc = "Field `ENEAM` reader - Enable Extended Address Mode for Extra Rows"]
pub type ENEAM_R = crate :: BitReader < bool > ; # [doc = "Field `ENEAM` writer - Enable Extended Address Mode for Extra Rows"]
pub type ENEAM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , NEMCR_SPEC , bool , O > ; impl R { # [doc = "Bits 4:5 - Address for Extended Address Mode of Extra Rows"]
# [inline (always)]
pub fn aeam (& self) -> AEAM_R { AEAM_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Enable Extended Address Mode for Extra Rows"]
# [inline (always)]
pub fn eneam (& self) -> ENEAM_R { ENEAM_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 4:5 - Address for Extended Address Mode of Extra Rows"]
# [inline (always)]
# [must_use]
pub fn aeam (& mut self) -> AEAM_W < 4 > { AEAM_W :: new (self) } # [doc = "Bit 6 - Enable Extended Address Mode for Extra Rows"]
# [inline (always)]
# [must_use]
pub fn eneam (& mut self) -> ENEAM_W < 6 > { ENEAM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Flash Extended-Mode Control-Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nemcr](index.html) module"]
pub struct NEMCR_SPEC ; impl crate :: RegisterSpec for NEMCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [nemcr::R](R) reader structure"]
impl crate :: Readable for NEMCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [nemcr::W](W) writer structure"]
impl crate :: Writable for NEMCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets NEMCR to value 0"]
impl crate :: Resettable for NEMCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Fuses"]
pub struct FUSE { _marker : PhantomData < * const () > } unsafe impl Send for FUSE { } impl FUSE { # [doc = r"Pointer to the register block"]
pub const PTR : * const fuse :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const fuse :: RegisterBlock { Self :: PTR } } impl Deref for FUSE { type Target = fuse :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FUSE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FUSE") . finish () } } # [doc = "Fuses"]
pub mod fuse { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - No Description."]
pub low : LOW , # [doc = "0x01 - No Description."]
pub high : HIGH , # [doc = "0x02 - No Description."]
pub extended : EXTENDED , } # [doc = "EXTENDED (rw) register accessor: an alias for `Reg<EXTENDED_SPEC>`"]
pub type EXTENDED = crate :: Reg < extended :: EXTENDED_SPEC > ; # [doc = "No Description."]
pub mod extended { # [doc = "Register `EXTENDED` reader"]
pub struct R (crate :: R < EXTENDED_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EXTENDED_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EXTENDED_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EXTENDED_SPEC >) -> Self { R (reader) } } # [doc = "Register `EXTENDED` writer"]
pub struct W (crate :: W < EXTENDED_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EXTENDED_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EXTENDED_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EXTENDED_SPEC >) -> Self { W (writer) } } # [doc = "Field `BODLEVEL` reader - Brown-out Detector trigger level"]
pub type BODLEVEL_R = crate :: FieldReader < u8 , BODLEVEL_A > ; # [doc = "Brown-out Detector trigger level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BODLEVEL_A { # [doc = "0: Brown-out detection at VCC=2.4 V"]
_2V4 = 0 , # [doc = "1: Brown-out detection at VCC=2.3 V"]
_2V3 = 1 , # [doc = "2: Brown-out detection at VCC=2.2 V"]
_2V2 = 2 , # [doc = "3: Brown-out detection at VCC=2.1 V"]
_2V1 = 3 , # [doc = "4: Brown-out detection at VCC=2.0 V"]
_2V0 = 4 , # [doc = "5: Brown-out detection at VCC=1.9 V"]
_1V9 = 5 , # [doc = "6: Brown-out detection at VCC=1.8 V"]
_1V8 = 6 , # [doc = "7: Brown-out detection disabled"]
DISABLED = 7 , } impl From < BODLEVEL_A > for u8 { # [inline (always)]
fn from (variant : BODLEVEL_A) -> Self { variant as _ } } impl BODLEVEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BODLEVEL_A { match self . bits { 0 => BODLEVEL_A :: _2V4 , 1 => BODLEVEL_A :: _2V3 , 2 => BODLEVEL_A :: _2V2 , 3 => BODLEVEL_A :: _2V1 , 4 => BODLEVEL_A :: _2V0 , 5 => BODLEVEL_A :: _1V9 , 6 => BODLEVEL_A :: _1V8 , 7 => BODLEVEL_A :: DISABLED , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_2V4`"]
# [inline (always)]
pub fn is_2v4 (& self) -> bool { * self == BODLEVEL_A :: _2V4 } # [doc = "Checks if the value of the field is `_2V3`"]
# [inline (always)]
pub fn is_2v3 (& self) -> bool { * self == BODLEVEL_A :: _2V3 } # [doc = "Checks if the value of the field is `_2V2`"]
# [inline (always)]
pub fn is_2v2 (& self) -> bool { * self == BODLEVEL_A :: _2V2 } # [doc = "Checks if the value of the field is `_2V1`"]
# [inline (always)]
pub fn is_2v1 (& self) -> bool { * self == BODLEVEL_A :: _2V1 } # [doc = "Checks if the value of the field is `_2V0`"]
# [inline (always)]
pub fn is_2v0 (& self) -> bool { * self == BODLEVEL_A :: _2V0 } # [doc = "Checks if the value of the field is `_1V9`"]
# [inline (always)]
pub fn is_1v9 (& self) -> bool { * self == BODLEVEL_A :: _1V9 } # [doc = "Checks if the value of the field is `_1V8`"]
# [inline (always)]
pub fn is_1v8 (& self) -> bool { * self == BODLEVEL_A :: _1V8 } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == BODLEVEL_A :: DISABLED } } # [doc = "Field `BODLEVEL` writer - Brown-out Detector trigger level"]
pub type BODLEVEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EXTENDED_SPEC , u8 , BODLEVEL_A , 3 , O > ; impl < 'a , const O : u8 > BODLEVEL_W < 'a , O > { # [doc = "Brown-out detection at VCC=2.4 V"]
# [inline (always)]
pub fn _2v4 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V4) } # [doc = "Brown-out detection at VCC=2.3 V"]
# [inline (always)]
pub fn _2v3 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V3) } # [doc = "Brown-out detection at VCC=2.2 V"]
# [inline (always)]
pub fn _2v2 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V2) } # [doc = "Brown-out detection at VCC=2.1 V"]
# [inline (always)]
pub fn _2v1 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V1) } # [doc = "Brown-out detection at VCC=2.0 V"]
# [inline (always)]
pub fn _2v0 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V0) } # [doc = "Brown-out detection at VCC=1.9 V"]
# [inline (always)]
pub fn _1v9 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _1V9) } # [doc = "Brown-out detection at VCC=1.8 V"]
# [inline (always)]
pub fn _1v8 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _1V8) } # [doc = "Brown-out detection disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (BODLEVEL_A :: DISABLED) } } impl R { # [doc = "Bits 0:2 - Brown-out Detector trigger level"]
# [inline (always)]
pub fn bodlevel (& self) -> BODLEVEL_R { BODLEVEL_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Brown-out Detector trigger level"]
# [inline (always)]
# [must_use]
pub fn bodlevel (& mut self) -> BODLEVEL_W < 0 > { BODLEVEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "No Description.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [extended](index.html) module"]
pub struct EXTENDED_SPEC ; impl crate :: RegisterSpec for EXTENDED_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [extended::R](R) reader structure"]
impl crate :: Readable for EXTENDED_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [extended::W](W) writer structure"]
impl crate :: Writable for EXTENDED_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EXTENDED to value 0"]
impl crate :: Resettable for EXTENDED_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "HIGH (rw) register accessor: an alias for `Reg<HIGH_SPEC>`"]
pub type HIGH = crate :: Reg < high :: HIGH_SPEC > ; # [doc = "No Description."]
pub mod high { # [doc = "Register `HIGH` reader"]
pub struct R (crate :: R < HIGH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < HIGH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < HIGH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < HIGH_SPEC >) -> Self { R (reader) } } # [doc = "Register `HIGH` writer"]
pub struct W (crate :: W < HIGH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < HIGH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < HIGH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < HIGH_SPEC >) -> Self { W (writer) } } # [doc = "Field `BOOTRST` reader - Boot Reset vector Enabled"]
pub type BOOTRST_R = crate :: BitReader < bool > ; # [doc = "Field `BOOTRST` writer - Boot Reset vector Enabled"]
pub type BOOTRST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `BOOTSZ` reader - Select Boot Size"]
pub type BOOTSZ_R = crate :: FieldReader < u8 , BOOTSZ_A > ; # [doc = "Select Boot Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BOOTSZ_A { # [doc = "0: Boot Flash size=4096 words start address=$F000"]
_4096W_F000 = 0 , # [doc = "1: Boot Flash size=2048 words start address=$F800"]
_2048W_F800 = 1 , # [doc = "2: Boot Flash size=1024 words start address=$FC00"]
_1024W_FC00 = 2 , # [doc = "3: Boot Flash size=512 words start address=$FE00"]
_512W_FE00 = 3 , } impl From < BOOTSZ_A > for u8 { # [inline (always)]
fn from (variant : BOOTSZ_A) -> Self { variant as _ } } impl BOOTSZ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BOOTSZ_A { match self . bits { 0 => BOOTSZ_A :: _4096W_F000 , 1 => BOOTSZ_A :: _2048W_F800 , 2 => BOOTSZ_A :: _1024W_FC00 , 3 => BOOTSZ_A :: _512W_FE00 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_4096W_F000`"]
# [inline (always)]
pub fn is_4096w_f000 (& self) -> bool { * self == BOOTSZ_A :: _4096W_F000 } # [doc = "Checks if the value of the field is `_2048W_F800`"]
# [inline (always)]
pub fn is_2048w_f800 (& self) -> bool { * self == BOOTSZ_A :: _2048W_F800 } # [doc = "Checks if the value of the field is `_1024W_FC00`"]
# [inline (always)]
pub fn is_1024w_fc00 (& self) -> bool { * self == BOOTSZ_A :: _1024W_FC00 } # [doc = "Checks if the value of the field is `_512W_FE00`"]
# [inline (always)]
pub fn is_512w_fe00 (& self) -> bool { * self == BOOTSZ_A :: _512W_FE00 } } # [doc = "Field `BOOTSZ` writer - Select Boot Size"]
pub type BOOTSZ_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , HIGH_SPEC , u8 , BOOTSZ_A , 2 , O > ; impl < 'a , const O : u8 > BOOTSZ_W < 'a , O > { # [doc = "Boot Flash size=4096 words start address=$F000"]
# [inline (always)]
pub fn _4096w_f000 (self) -> & 'a mut W { self . variant (BOOTSZ_A :: _4096W_F000) } # [doc = "Boot Flash size=2048 words start address=$F800"]
# [inline (always)]
pub fn _2048w_f800 (self) -> & 'a mut W { self . variant (BOOTSZ_A :: _2048W_F800) } # [doc = "Boot Flash size=1024 words start address=$FC00"]
# [inline (always)]
pub fn _1024w_fc00 (self) -> & 'a mut W { self . variant (BOOTSZ_A :: _1024W_FC00) } # [doc = "Boot Flash size=512 words start address=$FE00"]
# [inline (always)]
pub fn _512w_fe00 (self) -> & 'a mut W { self . variant (BOOTSZ_A :: _512W_FE00) } } # [doc = "Field `EESAVE` reader - Preserve EEPROM through the Chip Erase cycle"]
pub type EESAVE_R = crate :: BitReader < bool > ; # [doc = "Field `EESAVE` writer - Preserve EEPROM through the Chip Erase cycle"]
pub type EESAVE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `WDTON` reader - Watchdog timer always on"]
pub type WDTON_R = crate :: BitReader < bool > ; # [doc = "Field `WDTON` writer - Watchdog timer always on"]
pub type WDTON_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `SPIEN` reader - Serial program downloading (SPI) enabled"]
pub type SPIEN_R = crate :: BitReader < bool > ; # [doc = "Field `SPIEN` writer - Serial program downloading (SPI) enabled"]
pub type SPIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `JTAGEN` reader - JTAG Interface Enabled"]
pub type JTAGEN_R = crate :: BitReader < bool > ; # [doc = "Field `JTAGEN` writer - JTAG Interface Enabled"]
pub type JTAGEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `OCDEN` reader - On-Chip Debug Enabled"]
pub type OCDEN_R = crate :: BitReader < bool > ; # [doc = "Field `OCDEN` writer - On-Chip Debug Enabled"]
pub type OCDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Boot Reset vector Enabled"]
# [inline (always)]
pub fn bootrst (& self) -> BOOTRST_R { BOOTRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Select Boot Size"]
# [inline (always)]
pub fn bootsz (& self) -> BOOTSZ_R { BOOTSZ_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Preserve EEPROM through the Chip Erase cycle"]
# [inline (always)]
pub fn eesave (& self) -> EESAVE_R { EESAVE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Watchdog timer always on"]
# [inline (always)]
pub fn wdton (& self) -> WDTON_R { WDTON_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Serial program downloading (SPI) enabled"]
# [inline (always)]
pub fn spien (& self) -> SPIEN_R { SPIEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - JTAG Interface Enabled"]
# [inline (always)]
pub fn jtagen (& self) -> JTAGEN_R { JTAGEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - On-Chip Debug Enabled"]
# [inline (always)]
pub fn ocden (& self) -> OCDEN_R { OCDEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Boot Reset vector Enabled"]
# [inline (always)]
# [must_use]
pub fn bootrst (& mut self) -> BOOTRST_W < 0 > { BOOTRST_W :: new (self) } # [doc = "Bits 1:2 - Select Boot Size"]
# [inline (always)]
# [must_use]
pub fn bootsz (& mut self) -> BOOTSZ_W < 1 > { BOOTSZ_W :: new (self) } # [doc = "Bit 3 - Preserve EEPROM through the Chip Erase cycle"]
# [inline (always)]
# [must_use]
pub fn eesave (& mut self) -> EESAVE_W < 3 > { EESAVE_W :: new (self) } # [doc = "Bit 4 - Watchdog timer always on"]
# [inline (always)]
# [must_use]
pub fn wdton (& mut self) -> WDTON_W < 4 > { WDTON_W :: new (self) } # [doc = "Bit 5 - Serial program downloading (SPI) enabled"]
# [inline (always)]
# [must_use]
pub fn spien (& mut self) -> SPIEN_W < 5 > { SPIEN_W :: new (self) } # [doc = "Bit 6 - JTAG Interface Enabled"]
# [inline (always)]
# [must_use]
pub fn jtagen (& mut self) -> JTAGEN_W < 6 > { JTAGEN_W :: new (self) } # [doc = "Bit 7 - On-Chip Debug Enabled"]
# [inline (always)]
# [must_use]
pub fn ocden (& mut self) -> OCDEN_W < 7 > { OCDEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "No Description.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [high](index.html) module"]
pub struct HIGH_SPEC ; impl crate :: RegisterSpec for HIGH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [high::R](R) reader structure"]
impl crate :: Readable for HIGH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [high::W](W) writer structure"]
impl crate :: Writable for HIGH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HIGH to value 0"]
impl crate :: Resettable for HIGH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOW (rw) register accessor: an alias for `Reg<LOW_SPEC>`"]
pub type LOW = crate :: Reg < low :: LOW_SPEC > ; # [doc = "No Description."]
pub mod low { # [doc = "Register `LOW` reader"]
pub struct R (crate :: R < LOW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOW_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOW` writer"]
pub struct W (crate :: W < LOW_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOW_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOW_SPEC >) -> Self { W (writer) } } # [doc = "Field `CKSEL_SUT` reader - Select Clock Source : Start-up time"]
pub type CKSEL_SUT_R = crate :: FieldReader < u8 , CKSEL_SUT_A > ; # [doc = "Select Clock Source : Start-up time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CKSEL_SUT_A { # [doc = "0: Ext. Clock; Start-up time: 6 CK + 0 ms"]
EXTCLK_6CK_0MS = 0 , # [doc = "2: Int. RC Osc.; Start-up time: 6 CK + 0 ms"]
INTRCOSC_6CK_0MS = 2 , # [doc = "3: Int. 128kHz RC Osc.; Start-up time: 6 CK + 0 ms"]
INTRCOSC_128KHZ_6CK_0MS = 3 , # [doc = "6: Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms"]
TRXOSC_258CK_4MS1 = 6 , # [doc = "7: Tranceiver Oscillator; Start-up time: 1K CK + 65 ms"]
TRXOSC_1KCK_65MS = 7 , # [doc = "16: Ext. Clock; Start-up time: 6 CK + 4.1 ms"]
EXTCLK_6CK_4MS1 = 16 , # [doc = "18: Int. RC Osc.; Start-up time: 6 CK + 4.1 ms"]
INTRCOSC_6CK_4MS1 = 18 , # [doc = "19: Int. 128kHz RC Osc.; Start-up time: 6 CK + 4.1 ms"]
INTRCOSC_128KHZ_6CK_4MS1 = 19 , # [doc = "22: Tranceiver Oscillator; Start-up time: 258 CK + 65 ms"]
TRXOSC_258CK_65MS = 22 , # [doc = "23: Tranceiver Oscillator; Start-up time: 16K CK + 0 ms"]
TRXOSC_16KCK_0MS = 23 , # [doc = "32: Ext. Clock; Start-up time: 6 CK + 65 ms"]
EXTCLK_6CK_65MS = 32 , # [doc = "34: Int. RC Osc.; Start-up time: 6 CK + 65 ms"]
INTRCOSC_6CK_65MS = 34 , # [doc = "35: Int. 128kHz RC Osc.; Start-up time: 6 CK + 65 ms"]
INTRCOSC_128KHZ_6CK_65MS = 35 , # [doc = "38: Tranceiver Oscillator; Start-up time: 1K CK + 0 ms"]
TRXOSC_1KCK_0MS = 38 , # [doc = "39: Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms"]
TRXOSC_16KCK_4MS1 = 39 , # [doc = "54: Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms"]
TRXOSC_1KCK_4MS1 = 54 , # [doc = "55: Tranceiver Oscillator; Start-up time: 16K CK + 65 ms"]
TRXOSC_16KCK_65MS = 55 , } impl From < CKSEL_SUT_A > for u8 { # [inline (always)]
fn from (variant : CKSEL_SUT_A) -> Self { variant as _ } } impl CKSEL_SUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CKSEL_SUT_A > { match self . bits { 0 => Some (CKSEL_SUT_A :: EXTCLK_6CK_0MS) , 2 => Some (CKSEL_SUT_A :: INTRCOSC_6CK_0MS) , 3 => Some (CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_0MS) , 6 => Some (CKSEL_SUT_A :: TRXOSC_258CK_4MS1) , 7 => Some (CKSEL_SUT_A :: TRXOSC_1KCK_65MS) , 16 => Some (CKSEL_SUT_A :: EXTCLK_6CK_4MS1) , 18 => Some (CKSEL_SUT_A :: INTRCOSC_6CK_4MS1) , 19 => Some (CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_4MS1) , 22 => Some (CKSEL_SUT_A :: TRXOSC_258CK_65MS) , 23 => Some (CKSEL_SUT_A :: TRXOSC_16KCK_0MS) , 32 => Some (CKSEL_SUT_A :: EXTCLK_6CK_65MS) , 34 => Some (CKSEL_SUT_A :: INTRCOSC_6CK_65MS) , 35 => Some (CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_65MS) , 38 => Some (CKSEL_SUT_A :: TRXOSC_1KCK_0MS) , 39 => Some (CKSEL_SUT_A :: TRXOSC_16KCK_4MS1) , 54 => Some (CKSEL_SUT_A :: TRXOSC_1KCK_4MS1) , 55 => Some (CKSEL_SUT_A :: TRXOSC_16KCK_65MS) , _ => None , } } # [doc = "Checks if the value of the field is `EXTCLK_6CK_0MS`"]
# [inline (always)]
pub fn is_extclk_6ck_0ms (& self) -> bool { * self == CKSEL_SUT_A :: EXTCLK_6CK_0MS } # [doc = "Checks if the value of the field is `INTRCOSC_6CK_0MS`"]
# [inline (always)]
pub fn is_intrcosc_6ck_0ms (& self) -> bool { * self == CKSEL_SUT_A :: INTRCOSC_6CK_0MS } # [doc = "Checks if the value of the field is `INTRCOSC_128KHZ_6CK_0MS`"]
# [inline (always)]
pub fn is_intrcosc_128khz_6ck_0ms (& self) -> bool { * self == CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_0MS } # [doc = "Checks if the value of the field is `TRXOSC_258CK_4MS1`"]
# [inline (always)]
pub fn is_trxosc_258ck_4ms1 (& self) -> bool { * self == CKSEL_SUT_A :: TRXOSC_258CK_4MS1 } # [doc = "Checks if the value of the field is `TRXOSC_1KCK_65MS`"]
# [inline (always)]
pub fn is_trxosc_1kck_65ms (& self) -> bool { * self == CKSEL_SUT_A :: TRXOSC_1KCK_65MS } # [doc = "Checks if the value of the field is `EXTCLK_6CK_4MS1`"]
# [inline (always)]
pub fn is_extclk_6ck_4ms1 (& self) -> bool { * self == CKSEL_SUT_A :: EXTCLK_6CK_4MS1 } # [doc = "Checks if the value of the field is `INTRCOSC_6CK_4MS1`"]
# [inline (always)]
pub fn is_intrcosc_6ck_4ms1 (& self) -> bool { * self == CKSEL_SUT_A :: INTRCOSC_6CK_4MS1 } # [doc = "Checks if the value of the field is `INTRCOSC_128KHZ_6CK_4MS1`"]
# [inline (always)]
pub fn is_intrcosc_128khz_6ck_4ms1 (& self) -> bool { * self == CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_4MS1 } # [doc = "Checks if the value of the field is `TRXOSC_258CK_65MS`"]
# [inline (always)]
pub fn is_trxosc_258ck_65ms (& self) -> bool { * self == CKSEL_SUT_A :: TRXOSC_258CK_65MS } # [doc = "Checks if the value of the field is `TRXOSC_16KCK_0MS`"]
# [inline (always)]
pub fn is_trxosc_16kck_0ms (& self) -> bool { * self == CKSEL_SUT_A :: TRXOSC_16KCK_0MS } # [doc = "Checks if the value of the field is `EXTCLK_6CK_65MS`"]
# [inline (always)]
pub fn is_extclk_6ck_65ms (& self) -> bool { * self == CKSEL_SUT_A :: EXTCLK_6CK_65MS } # [doc = "Checks if the value of the field is `INTRCOSC_6CK_65MS`"]
# [inline (always)]
pub fn is_intrcosc_6ck_65ms (& self) -> bool { * self == CKSEL_SUT_A :: INTRCOSC_6CK_65MS } # [doc = "Checks if the value of the field is `INTRCOSC_128KHZ_6CK_65MS`"]
# [inline (always)]
pub fn is_intrcosc_128khz_6ck_65ms (& self) -> bool { * self == CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_65MS } # [doc = "Checks if the value of the field is `TRXOSC_1KCK_0MS`"]
# [inline (always)]
pub fn is_trxosc_1kck_0ms (& self) -> bool { * self == CKSEL_SUT_A :: TRXOSC_1KCK_0MS } # [doc = "Checks if the value of the field is `TRXOSC_16KCK_4MS1`"]
# [inline (always)]
pub fn is_trxosc_16kck_4ms1 (& self) -> bool { * self == CKSEL_SUT_A :: TRXOSC_16KCK_4MS1 } # [doc = "Checks if the value of the field is `TRXOSC_1KCK_4MS1`"]
# [inline (always)]
pub fn is_trxosc_1kck_4ms1 (& self) -> bool { * self == CKSEL_SUT_A :: TRXOSC_1KCK_4MS1 } # [doc = "Checks if the value of the field is `TRXOSC_16KCK_65MS`"]
# [inline (always)]
pub fn is_trxosc_16kck_65ms (& self) -> bool { * self == CKSEL_SUT_A :: TRXOSC_16KCK_65MS } } # [doc = "Field `CKSEL_SUT` writer - Select Clock Source : Start-up time"]
pub type CKSEL_SUT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LOW_SPEC , u8 , CKSEL_SUT_A , 6 , O > ; impl < 'a , const O : u8 > CKSEL_SUT_W < 'a , O > { # [doc = "Ext. Clock; Start-up time: 6 CK + 0 ms"]
# [inline (always)]
pub fn extclk_6ck_0ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: EXTCLK_6CK_0MS) } # [doc = "Int. RC Osc.; Start-up time: 6 CK + 0 ms"]
# [inline (always)]
pub fn intrcosc_6ck_0ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: INTRCOSC_6CK_0MS) } # [doc = "Int. 128kHz RC Osc.; Start-up time: 6 CK + 0 ms"]
# [inline (always)]
pub fn intrcosc_128khz_6ck_0ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_0MS) } # [doc = "Tranceiver Oscillator; Start-up time: 258 CK + 4.1 ms"]
# [inline (always)]
pub fn trxosc_258ck_4ms1 (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: TRXOSC_258CK_4MS1) } # [doc = "Tranceiver Oscillator; Start-up time: 1K CK + 65 ms"]
# [inline (always)]
pub fn trxosc_1kck_65ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: TRXOSC_1KCK_65MS) } # [doc = "Ext. Clock; Start-up time: 6 CK + 4.1 ms"]
# [inline (always)]
pub fn extclk_6ck_4ms1 (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: EXTCLK_6CK_4MS1) } # [doc = "Int. RC Osc.; Start-up time: 6 CK + 4.1 ms"]
# [inline (always)]
pub fn intrcosc_6ck_4ms1 (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: INTRCOSC_6CK_4MS1) } # [doc = "Int. 128kHz RC Osc.; Start-up time: 6 CK + 4.1 ms"]
# [inline (always)]
pub fn intrcosc_128khz_6ck_4ms1 (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_4MS1) } # [doc = "Tranceiver Oscillator; Start-up time: 258 CK + 65 ms"]
# [inline (always)]
pub fn trxosc_258ck_65ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: TRXOSC_258CK_65MS) } # [doc = "Tranceiver Oscillator; Start-up time: 16K CK + 0 ms"]
# [inline (always)]
pub fn trxosc_16kck_0ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: TRXOSC_16KCK_0MS) } # [doc = "Ext. Clock; Start-up time: 6 CK + 65 ms"]
# [inline (always)]
pub fn extclk_6ck_65ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: EXTCLK_6CK_65MS) } # [doc = "Int. RC Osc.; Start-up time: 6 CK + 65 ms"]
# [inline (always)]
pub fn intrcosc_6ck_65ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: INTRCOSC_6CK_65MS) } # [doc = "Int. 128kHz RC Osc.; Start-up time: 6 CK + 65 ms"]
# [inline (always)]
pub fn intrcosc_128khz_6ck_65ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: INTRCOSC_128KHZ_6CK_65MS) } # [doc = "Tranceiver Oscillator; Start-up time: 1K CK + 0 ms"]
# [inline (always)]
pub fn trxosc_1kck_0ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: TRXOSC_1KCK_0MS) } # [doc = "Tranceiver Oscillator; Start-up time: 16K CK + 4.1 ms"]
# [inline (always)]
pub fn trxosc_16kck_4ms1 (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: TRXOSC_16KCK_4MS1) } # [doc = "Tranceiver Oscillator; Start-up time: 1K CK + 4.1 ms"]
# [inline (always)]
pub fn trxosc_1kck_4ms1 (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: TRXOSC_1KCK_4MS1) } # [doc = "Tranceiver Oscillator; Start-up time: 16K CK + 65 ms"]
# [inline (always)]
pub fn trxosc_16kck_65ms (self) -> & 'a mut W { self . variant (CKSEL_SUT_A :: TRXOSC_16KCK_65MS) } } # [doc = "Field `CKOUT` reader - Clock output on PORTE7"]
pub type CKOUT_R = crate :: BitReader < bool > ; # [doc = "Field `CKOUT` writer - Clock output on PORTE7"]
pub type CKOUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LOW_SPEC , bool , O > ; # [doc = "Field `CKDIV8` reader - Divide clock by 8 internally"]
pub type CKDIV8_R = crate :: BitReader < bool > ; # [doc = "Field `CKDIV8` writer - Divide clock by 8 internally"]
pub type CKDIV8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LOW_SPEC , bool , O > ; impl R { # [doc = "Bits 0:5 - Select Clock Source : Start-up time"]
# [inline (always)]
pub fn cksel_sut (& self) -> CKSEL_SUT_R { CKSEL_SUT_R :: new (self . bits & 0x3f) } # [doc = "Bit 6 - Clock output on PORTE7"]
# [inline (always)]
pub fn ckout (& self) -> CKOUT_R { CKOUT_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Divide clock by 8 internally"]
# [inline (always)]
pub fn ckdiv8 (& self) -> CKDIV8_R { CKDIV8_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - Select Clock Source : Start-up time"]
# [inline (always)]
# [must_use]
pub fn cksel_sut (& mut self) -> CKSEL_SUT_W < 0 > { CKSEL_SUT_W :: new (self) } # [doc = "Bit 6 - Clock output on PORTE7"]
# [inline (always)]
# [must_use]
pub fn ckout (& mut self) -> CKOUT_W < 6 > { CKOUT_W :: new (self) } # [doc = "Bit 7 - Divide clock by 8 internally"]
# [inline (always)]
# [must_use]
pub fn ckdiv8 (& mut self) -> CKDIV8_W < 7 > { CKDIV8_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "No Description.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [low](index.html) module"]
pub struct LOW_SPEC ; impl crate :: RegisterSpec for LOW_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [low::R](R) reader structure"]
impl crate :: Readable for LOW_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [low::W](W) writer structure"]
impl crate :: Writable for LOW_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOW to value 0"]
impl crate :: Resettable for LOW_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "JTAG Interface"]
pub struct JTAG { _marker : PhantomData < * const () > } unsafe impl Send for JTAG { } impl JTAG { # [doc = r"Pointer to the register block"]
pub const PTR : * const jtag :: RegisterBlock = 0x51 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const jtag :: RegisterBlock { Self :: PTR } } impl Deref for JTAG { type Target = jtag :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for JTAG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("JTAG") . finish () } } # [doc = "JTAG Interface"]
pub mod jtag { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - On-Chip Debug Register"]
pub ocdr : OCDR , _reserved1 : [u8 ; 0x02]
, # [doc = "0x03 - MCU Status Register"]
pub mcusr : MCUSR , # [doc = "0x04 - MCU Control Register"]
pub mcucr : MCUCR , } # [doc = "MCUCR (rw) register accessor: an alias for `Reg<MCUCR_SPEC>`"]
pub type MCUCR = crate :: Reg < mcucr :: MCUCR_SPEC > ; # [doc = "MCU Control Register"]
pub mod mcucr { # [doc = "Register `MCUCR` reader"]
pub struct R (crate :: R < MCUCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCUCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCUCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCUCR` writer"]
pub struct W (crate :: W < MCUCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCUCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCUCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `JTD` reader - JTAG Interface Disable"]
pub type JTD_R = crate :: BitReader < bool > ; # [doc = "Field `JTD` writer - JTAG Interface Disable"]
pub type JTD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; impl R { # [doc = "Bit 7 - JTAG Interface Disable"]
# [inline (always)]
pub fn jtd (& self) -> JTD_R { JTD_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 7 - JTAG Interface Disable"]
# [inline (always)]
# [must_use]
pub fn jtd (& mut self) -> JTD_W < 7 > { JTD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCU Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcucr](index.html) module"]
pub struct MCUCR_SPEC ; impl crate :: RegisterSpec for MCUCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mcucr::R](R) reader structure"]
impl crate :: Readable for MCUCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mcucr::W](W) writer structure"]
impl crate :: Writable for MCUCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCUCR to value 0"]
impl crate :: Resettable for MCUCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCUSR (rw) register accessor: an alias for `Reg<MCUSR_SPEC>`"]
pub type MCUSR = crate :: Reg < mcusr :: MCUSR_SPEC > ; # [doc = "MCU Status Register"]
pub mod mcusr { # [doc = "Register `MCUSR` reader"]
pub struct R (crate :: R < MCUSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCUSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCUSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCUSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCUSR` writer"]
pub struct W (crate :: W < MCUSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCUSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCUSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCUSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `JTRF` reader - JTAG Reset Flag"]
pub type JTRF_R = crate :: BitReader < bool > ; # [doc = "Field `JTRF` writer - JTAG Reset Flag"]
pub type JTRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; impl R { # [doc = "Bit 4 - JTAG Reset Flag"]
# [inline (always)]
pub fn jtrf (& self) -> JTRF_R { JTRF_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 4 - JTAG Reset Flag"]
# [inline (always)]
# [must_use]
pub fn jtrf (& mut self) -> JTRF_W < 4 > { JTRF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCU Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcusr](index.html) module"]
pub struct MCUSR_SPEC ; impl crate :: RegisterSpec for MCUSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mcusr::R](R) reader structure"]
impl crate :: Readable for MCUSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mcusr::W](W) writer structure"]
impl crate :: Writable for MCUSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCUSR to value 0"]
impl crate :: Resettable for MCUSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCDR (rw) register accessor: an alias for `Reg<OCDR_SPEC>`"]
pub type OCDR = crate :: Reg < ocdr :: OCDR_SPEC > ; # [doc = "On-Chip Debug Register"]
pub mod ocdr { # [doc = "Register `OCDR` reader"]
pub struct R (crate :: R < OCDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCDR` writer"]
pub struct W (crate :: W < OCDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `OCDR` reader - On-Chip Debug Register Data"]
pub type OCDR_R = crate :: FieldReader < u8 , OCDR_A > ; # [doc = "On-Chip Debug Register Data\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OCDR_A { # [doc = "0: Refer to the debugger documentation for further information on how to use this register."]
REFER_TO_THE_DEBUGGER_DOCUMENTATION_FOR_FURTHER_INFORMATION_ON_HOW_TO_USE_THIS_REGISTER = 0 , } impl From < OCDR_A > for u8 { # [inline (always)]
fn from (variant : OCDR_A) -> Self { variant as _ } } impl OCDR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < OCDR_A > { match self . bits { 0 => Some (OCDR_A :: REFER_TO_THE_DEBUGGER_DOCUMENTATION_FOR_FURTHER_INFORMATION_ON_HOW_TO_USE_THIS_REGISTER) , _ => None , } } # [doc = "Checks if the value of the field is `REFER_TO_THE_DEBUGGER_DOCUMENTATION_FOR_FURTHER_INFORMATION_ON_HOW_TO_USE_THIS_REGISTER`"]
# [inline (always)]
pub fn is_refer_to_the_debugger_documentation_for_further_information_on_how_to_use_this_register (& self) -> bool { * self == OCDR_A :: REFER_TO_THE_DEBUGGER_DOCUMENTATION_FOR_FURTHER_INFORMATION_ON_HOW_TO_USE_THIS_REGISTER } } # [doc = "Field `OCDR` writer - On-Chip Debug Register Data"]
pub type OCDR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , OCDR_SPEC , u8 , OCDR_A , 8 , O > ; impl < 'a , const O : u8 > OCDR_W < 'a , O > { # [doc = "Refer to the debugger documentation for further information on how to use this register."]
# [inline (always)]
pub fn refer_to_the_debugger_documentation_for_further_information_on_how_to_use_this_register (self) -> & 'a mut W { self . variant (OCDR_A :: REFER_TO_THE_DEBUGGER_DOCUMENTATION_FOR_FURTHER_INFORMATION_ON_HOW_TO_USE_THIS_REGISTER) } } impl R { # [doc = "Bits 0:7 - On-Chip Debug Register Data"]
# [inline (always)]
pub fn ocdr (& self) -> OCDR_R { OCDR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - On-Chip Debug Register Data"]
# [inline (always)]
# [must_use]
pub fn ocdr (& mut self) -> OCDR_W < 0 > { OCDR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "On-Chip Debug Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocdr](index.html) module"]
pub struct OCDR_SPEC ; impl crate :: RegisterSpec for OCDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocdr::R](R) reader structure"]
impl crate :: Readable for OCDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocdr::W](W) writer structure"]
impl crate :: Writable for OCDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCDR to value 0"]
impl crate :: Resettable for OCDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Lockbits"]
pub struct LOCKBIT { _marker : PhantomData < * const () > } unsafe impl Send for LOCKBIT { } impl LOCKBIT { # [doc = r"Pointer to the register block"]
pub const PTR : * const lockbit :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const lockbit :: RegisterBlock { Self :: PTR } } impl Deref for LOCKBIT { type Target = lockbit :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for LOCKBIT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("LOCKBIT") . finish () } } # [doc = "Lockbits"]
pub mod lockbit { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - No Description."]
pub lockbit : LOCKBIT , } # [doc = "LOCKBIT (rw) register accessor: an alias for `Reg<LOCKBIT_SPEC>`"]
pub type LOCKBIT = crate :: Reg < lockbit :: LOCKBIT_SPEC > ; # [doc = "No Description."]
pub mod lockbit { # [doc = "Register `LOCKBIT` reader"]
pub struct R (crate :: R < LOCKBIT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKBIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKBIT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKBIT_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCKBIT` writer"]
pub struct W (crate :: W < LOCKBIT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCKBIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCKBIT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCKBIT_SPEC >) -> Self { W (writer) } } # [doc = "Field `LB` reader - Memory Lock"]
pub type LB_R = crate :: FieldReader < u8 , LB_A > ; # [doc = "Memory Lock\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LB_A { # [doc = "0: Further programming and verification disabled"]
PROG_VER_DISABLED = 0 , # [doc = "2: Further programming disabled"]
PROG_DISABLED = 2 , # [doc = "3: No memory lock features enabled"]
NO_LOCK = 3 , } impl From < LB_A > for u8 { # [inline (always)]
fn from (variant : LB_A) -> Self { variant as _ } } impl LB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LB_A > { match self . bits { 0 => Some (LB_A :: PROG_VER_DISABLED) , 2 => Some (LB_A :: PROG_DISABLED) , 3 => Some (LB_A :: NO_LOCK) , _ => None , } } # [doc = "Checks if the value of the field is `PROG_VER_DISABLED`"]
# [inline (always)]
pub fn is_prog_ver_disabled (& self) -> bool { * self == LB_A :: PROG_VER_DISABLED } # [doc = "Checks if the value of the field is `PROG_DISABLED`"]
# [inline (always)]
pub fn is_prog_disabled (& self) -> bool { * self == LB_A :: PROG_DISABLED } # [doc = "Checks if the value of the field is `NO_LOCK`"]
# [inline (always)]
pub fn is_no_lock (& self) -> bool { * self == LB_A :: NO_LOCK } } # [doc = "Field `LB` writer - Memory Lock"]
pub type LB_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LOCKBIT_SPEC , u8 , LB_A , 2 , O > ; impl < 'a , const O : u8 > LB_W < 'a , O > { # [doc = "Further programming and verification disabled"]
# [inline (always)]
pub fn prog_ver_disabled (self) -> & 'a mut W { self . variant (LB_A :: PROG_VER_DISABLED) } # [doc = "Further programming disabled"]
# [inline (always)]
pub fn prog_disabled (self) -> & 'a mut W { self . variant (LB_A :: PROG_DISABLED) } # [doc = "No memory lock features enabled"]
# [inline (always)]
pub fn no_lock (self) -> & 'a mut W { self . variant (LB_A :: NO_LOCK) } } # [doc = "Field `BLB0` reader - Boot Loader Protection Mode"]
pub type BLB0_R = crate :: FieldReader < u8 , BLB0_A > ; # [doc = "Boot Loader Protection Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLB0_A { # [doc = "0: LPM and SPM prohibited in Application Section"]
LPM_SPM_DISABLE = 0 , # [doc = "1: LPM prohibited in Application Section"]
LPM_DISABLE = 1 , # [doc = "2: SPM prohibited in Application Section"]
SPM_DISABLE = 2 , # [doc = "3: No lock on SPM and LPM in Application Section"]
NO_LOCK = 3 , } impl From < BLB0_A > for u8 { # [inline (always)]
fn from (variant : BLB0_A) -> Self { variant as _ } } impl BLB0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLB0_A { match self . bits { 0 => BLB0_A :: LPM_SPM_DISABLE , 1 => BLB0_A :: LPM_DISABLE , 2 => BLB0_A :: SPM_DISABLE , 3 => BLB0_A :: NO_LOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `LPM_SPM_DISABLE`"]
# [inline (always)]
pub fn is_lpm_spm_disable (& self) -> bool { * self == BLB0_A :: LPM_SPM_DISABLE } # [doc = "Checks if the value of the field is `LPM_DISABLE`"]
# [inline (always)]
pub fn is_lpm_disable (& self) -> bool { * self == BLB0_A :: LPM_DISABLE } # [doc = "Checks if the value of the field is `SPM_DISABLE`"]
# [inline (always)]
pub fn is_spm_disable (& self) -> bool { * self == BLB0_A :: SPM_DISABLE } # [doc = "Checks if the value of the field is `NO_LOCK`"]
# [inline (always)]
pub fn is_no_lock (& self) -> bool { * self == BLB0_A :: NO_LOCK } } # [doc = "Field `BLB0` writer - Boot Loader Protection Mode"]
pub type BLB0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBIT_SPEC , u8 , BLB0_A , 2 , O > ; impl < 'a , const O : u8 > BLB0_W < 'a , O > { # [doc = "LPM and SPM prohibited in Application Section"]
# [inline (always)]
pub fn lpm_spm_disable (self) -> & 'a mut W { self . variant (BLB0_A :: LPM_SPM_DISABLE) } # [doc = "LPM prohibited in Application Section"]
# [inline (always)]
pub fn lpm_disable (self) -> & 'a mut W { self . variant (BLB0_A :: LPM_DISABLE) } # [doc = "SPM prohibited in Application Section"]
# [inline (always)]
pub fn spm_disable (self) -> & 'a mut W { self . variant (BLB0_A :: SPM_DISABLE) } # [doc = "No lock on SPM and LPM in Application Section"]
# [inline (always)]
pub fn no_lock (self) -> & 'a mut W { self . variant (BLB0_A :: NO_LOCK) } } # [doc = "Field `BLB1` reader - Boot Loader Protection Mode"]
pub type BLB1_R = crate :: FieldReader < u8 , BLB1_A > ; # [doc = "Boot Loader Protection Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLB1_A { # [doc = "0: LPM and SPM prohibited in Boot Section"]
LPM_SPM_DISABLE = 0 , # [doc = "1: LPM prohibited in Boot Section"]
LPM_DISABLE = 1 , # [doc = "2: SPM prohibited in Boot Section"]
SPM_DISABLE = 2 , # [doc = "3: No lock on SPM and LPM in Boot Section"]
NO_LOCK = 3 , } impl From < BLB1_A > for u8 { # [inline (always)]
fn from (variant : BLB1_A) -> Self { variant as _ } } impl BLB1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLB1_A { match self . bits { 0 => BLB1_A :: LPM_SPM_DISABLE , 1 => BLB1_A :: LPM_DISABLE , 2 => BLB1_A :: SPM_DISABLE , 3 => BLB1_A :: NO_LOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `LPM_SPM_DISABLE`"]
# [inline (always)]
pub fn is_lpm_spm_disable (& self) -> bool { * self == BLB1_A :: LPM_SPM_DISABLE } # [doc = "Checks if the value of the field is `LPM_DISABLE`"]
# [inline (always)]
pub fn is_lpm_disable (& self) -> bool { * self == BLB1_A :: LPM_DISABLE } # [doc = "Checks if the value of the field is `SPM_DISABLE`"]
# [inline (always)]
pub fn is_spm_disable (& self) -> bool { * self == BLB1_A :: SPM_DISABLE } # [doc = "Checks if the value of the field is `NO_LOCK`"]
# [inline (always)]
pub fn is_no_lock (& self) -> bool { * self == BLB1_A :: NO_LOCK } } # [doc = "Field `BLB1` writer - Boot Loader Protection Mode"]
pub type BLB1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBIT_SPEC , u8 , BLB1_A , 2 , O > ; impl < 'a , const O : u8 > BLB1_W < 'a , O > { # [doc = "LPM and SPM prohibited in Boot Section"]
# [inline (always)]
pub fn lpm_spm_disable (self) -> & 'a mut W { self . variant (BLB1_A :: LPM_SPM_DISABLE) } # [doc = "LPM prohibited in Boot Section"]
# [inline (always)]
pub fn lpm_disable (self) -> & 'a mut W { self . variant (BLB1_A :: LPM_DISABLE) } # [doc = "SPM prohibited in Boot Section"]
# [inline (always)]
pub fn spm_disable (self) -> & 'a mut W { self . variant (BLB1_A :: SPM_DISABLE) } # [doc = "No lock on SPM and LPM in Boot Section"]
# [inline (always)]
pub fn no_lock (self) -> & 'a mut W { self . variant (BLB1_A :: NO_LOCK) } } impl R { # [doc = "Bits 0:1 - Memory Lock"]
# [inline (always)]
pub fn lb (& self) -> LB_R { LB_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Boot Loader Protection Mode"]
# [inline (always)]
pub fn blb0 (& self) -> BLB0_R { BLB0_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Boot Loader Protection Mode"]
# [inline (always)]
pub fn blb1 (& self) -> BLB1_R { BLB1_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Memory Lock"]
# [inline (always)]
# [must_use]
pub fn lb (& mut self) -> LB_W < 0 > { LB_W :: new (self) } # [doc = "Bits 2:3 - Boot Loader Protection Mode"]
# [inline (always)]
# [must_use]
pub fn blb0 (& mut self) -> BLB0_W < 2 > { BLB0_W :: new (self) } # [doc = "Bits 4:5 - Boot Loader Protection Mode"]
# [inline (always)]
# [must_use]
pub fn blb1 (& mut self) -> BLB1_W < 4 > { BLB1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "No Description.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockbit](index.html) module"]
pub struct LOCKBIT_SPEC ; impl crate :: RegisterSpec for LOCKBIT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lockbit::R](R) reader structure"]
impl crate :: Readable for LOCKBIT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lockbit::W](W) writer structure"]
impl crate :: Writable for LOCKBIT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOCKBIT to value 0"]
impl crate :: Resettable for LOCKBIT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTA { _marker : PhantomData < * const () > } unsafe impl Send for PORTA { } impl PORTA { # [doc = r"Pointer to the register block"]
pub const PTR : * const porta :: RegisterBlock = 0x20 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porta :: RegisterBlock { Self :: PTR } } impl Deref for PORTA { type Target = porta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTA") . finish () } } # [doc = "I/O Port"]
pub mod porta { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port A Input Pins Address"]
pub pina : PINA , # [doc = "0x01 - Port A Data Direction Register"]
pub ddra : DDRA , # [doc = "0x02 - Port A Data Register"]
pub porta : PORTA , } # [doc = "DDRA (rw) register accessor: an alias for `Reg<DDRA_SPEC>`"]
pub type DDRA = crate :: Reg < ddra :: DDRA_SPEC > ; # [doc = "Port A Data Direction Register"]
pub mod ddra { # [doc = "Register `DDRA` reader"]
pub struct R (crate :: R < DDRA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRA` writer"]
pub struct W (crate :: W < DDRA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port A Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddra](index.html) module"]
pub struct DDRA_SPEC ; impl crate :: RegisterSpec for DDRA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddra::R](R) reader structure"]
impl crate :: Readable for DDRA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddra::W](W) writer structure"]
impl crate :: Writable for DDRA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRA to value 0"]
impl crate :: Resettable for DDRA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PINA (rw) register accessor: an alias for `Reg<PINA_SPEC>`"]
pub type PINA = crate :: Reg < pina :: PINA_SPEC > ; # [doc = "Port A Input Pins Address"]
pub mod pina { # [doc = "Register `PINA` reader"]
pub struct R (crate :: R < PINA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINA_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINA` writer"]
pub struct W (crate :: W < PINA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port A Input Pins Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pina](index.html) module"]
pub struct PINA_SPEC ; impl crate :: RegisterSpec for PINA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pina::R](R) reader structure"]
impl crate :: Readable for PINA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pina::W](W) writer structure"]
impl crate :: Writable for PINA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PINA to value 0"]
impl crate :: Resettable for PINA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTA (rw) register accessor: an alias for `Reg<PORTA_SPEC>`"]
pub type PORTA = crate :: Reg < porta :: PORTA_SPEC > ; # [doc = "Port A Data Register"]
pub mod porta { # [doc = "Register `PORTA` reader"]
pub struct R (crate :: R < PORTA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTA_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTA` writer"]
pub struct W (crate :: W < PORTA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port A Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [porta](index.html) module"]
pub struct PORTA_SPEC ; impl crate :: RegisterSpec for PORTA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [porta::R](R) reader structure"]
impl crate :: Readable for PORTA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [porta::W](W) writer structure"]
impl crate :: Writable for PORTA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTA to value 0"]
impl crate :: Resettable for PORTA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTB { _marker : PhantomData < * const () > } unsafe impl Send for PORTB { } impl PORTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const portb :: RegisterBlock = 0x23 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portb :: RegisterBlock { Self :: PTR } } impl Deref for PORTB { type Target = portb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTB") . finish () } } # [doc = "I/O Port"]
pub mod portb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port B Input Pins Address"]
pub pinb : PINB , # [doc = "0x01 - Port B Data Direction Register"]
pub ddrb : DDRB , # [doc = "0x02 - Port B Data Register"]
pub portb : PORTB , } # [doc = "DDRB (rw) register accessor: an alias for `Reg<DDRB_SPEC>`"]
pub type DDRB = crate :: Reg < ddrb :: DDRB_SPEC > ; # [doc = "Port B Data Direction Register"]
pub mod ddrb { # [doc = "Register `DDRB` reader"]
pub struct R (crate :: R < DDRB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRB_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRB` writer"]
pub struct W (crate :: W < DDRB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port B Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddrb](index.html) module"]
pub struct DDRB_SPEC ; impl crate :: RegisterSpec for DDRB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddrb::R](R) reader structure"]
impl crate :: Readable for DDRB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddrb::W](W) writer structure"]
impl crate :: Writable for DDRB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRB to value 0"]
impl crate :: Resettable for DDRB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PINB (rw) register accessor: an alias for `Reg<PINB_SPEC>`"]
pub type PINB = crate :: Reg < pinb :: PINB_SPEC > ; # [doc = "Port B Input Pins Address"]
pub mod pinb { # [doc = "Register `PINB` reader"]
pub struct R (crate :: R < PINB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINB_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINB` writer"]
pub struct W (crate :: W < PINB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port B Input Pins Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pinb](index.html) module"]
pub struct PINB_SPEC ; impl crate :: RegisterSpec for PINB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pinb::R](R) reader structure"]
impl crate :: Readable for PINB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pinb::W](W) writer structure"]
impl crate :: Writable for PINB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PINB to value 0"]
impl crate :: Resettable for PINB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTB (rw) register accessor: an alias for `Reg<PORTB_SPEC>`"]
pub type PORTB = crate :: Reg < portb :: PORTB_SPEC > ; # [doc = "Port B Data Register"]
pub mod portb { # [doc = "Register `PORTB` reader"]
pub struct R (crate :: R < PORTB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTB_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTB` writer"]
pub struct W (crate :: W < PORTB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port B Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portb](index.html) module"]
pub struct PORTB_SPEC ; impl crate :: RegisterSpec for PORTB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portb::R](R) reader structure"]
impl crate :: Readable for PORTB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portb::W](W) writer structure"]
impl crate :: Writable for PORTB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTB to value 0"]
impl crate :: Resettable for PORTB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTC { _marker : PhantomData < * const () > } unsafe impl Send for PORTC { } impl PORTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const portc :: RegisterBlock = 0x26 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portc :: RegisterBlock { Self :: PTR } } impl Deref for PORTC { type Target = portc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTC") . finish () } } # [doc = "I/O Port"]
pub mod portc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port C Input Pins Address"]
pub pinc : PINC , # [doc = "0x01 - Port C Data Direction Register"]
pub ddrc : DDRC , # [doc = "0x02 - Port C Data Register"]
pub portc : PORTC , } # [doc = "DDRC (rw) register accessor: an alias for `Reg<DDRC_SPEC>`"]
pub type DDRC = crate :: Reg < ddrc :: DDRC_SPEC > ; # [doc = "Port C Data Direction Register"]
pub mod ddrc { # [doc = "Register `DDRC` reader"]
pub struct R (crate :: R < DDRC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRC_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRC` writer"]
pub struct W (crate :: W < DDRC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port C Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddrc](index.html) module"]
pub struct DDRC_SPEC ; impl crate :: RegisterSpec for DDRC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddrc::R](R) reader structure"]
impl crate :: Readable for DDRC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddrc::W](W) writer structure"]
impl crate :: Writable for DDRC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRC to value 0"]
impl crate :: Resettable for DDRC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PINC (rw) register accessor: an alias for `Reg<PINC_SPEC>`"]
pub type PINC = crate :: Reg < pinc :: PINC_SPEC > ; # [doc = "Port C Input Pins Address"]
pub mod pinc { # [doc = "Register `PINC` reader"]
pub struct R (crate :: R < PINC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINC_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINC` writer"]
pub struct W (crate :: W < PINC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port C Input Pins Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pinc](index.html) module"]
pub struct PINC_SPEC ; impl crate :: RegisterSpec for PINC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pinc::R](R) reader structure"]
impl crate :: Readable for PINC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pinc::W](W) writer structure"]
impl crate :: Writable for PINC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PINC to value 0"]
impl crate :: Resettable for PINC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTC (rw) register accessor: an alias for `Reg<PORTC_SPEC>`"]
pub type PORTC = crate :: Reg < portc :: PORTC_SPEC > ; # [doc = "Port C Data Register"]
pub mod portc { # [doc = "Register `PORTC` reader"]
pub struct R (crate :: R < PORTC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTC_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTC` writer"]
pub struct W (crate :: W < PORTC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port C Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portc](index.html) module"]
pub struct PORTC_SPEC ; impl crate :: RegisterSpec for PORTC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portc::R](R) reader structure"]
impl crate :: Readable for PORTC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portc::W](W) writer structure"]
impl crate :: Writable for PORTC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTC to value 0"]
impl crate :: Resettable for PORTC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTD { _marker : PhantomData < * const () > } unsafe impl Send for PORTD { } impl PORTD { # [doc = r"Pointer to the register block"]
pub const PTR : * const portd :: RegisterBlock = 0x29 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portd :: RegisterBlock { Self :: PTR } } impl Deref for PORTD { type Target = portd :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTD") . finish () } } # [doc = "I/O Port"]
pub mod portd { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port D Input Pins Address"]
pub pind : PIND , # [doc = "0x01 - Port D Data Direction Register"]
pub ddrd : DDRD , # [doc = "0x02 - Port D Data Register"]
pub portd : PORTD , } # [doc = "DDRD (rw) register accessor: an alias for `Reg<DDRD_SPEC>`"]
pub type DDRD = crate :: Reg < ddrd :: DDRD_SPEC > ; # [doc = "Port D Data Direction Register"]
pub mod ddrd { # [doc = "Register `DDRD` reader"]
pub struct R (crate :: R < DDRD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRD_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRD` writer"]
pub struct W (crate :: W < DDRD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port D Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddrd](index.html) module"]
pub struct DDRD_SPEC ; impl crate :: RegisterSpec for DDRD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddrd::R](R) reader structure"]
impl crate :: Readable for DDRD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddrd::W](W) writer structure"]
impl crate :: Writable for DDRD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRD to value 0"]
impl crate :: Resettable for DDRD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIND (rw) register accessor: an alias for `Reg<PIND_SPEC>`"]
pub type PIND = crate :: Reg < pind :: PIND_SPEC > ; # [doc = "Port D Input Pins Address"]
pub mod pind { # [doc = "Register `PIND` reader"]
pub struct R (crate :: R < PIND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIND_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIND` writer"]
pub struct W (crate :: W < PIND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIND_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port D Input Pins Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pind](index.html) module"]
pub struct PIND_SPEC ; impl crate :: RegisterSpec for PIND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pind::R](R) reader structure"]
impl crate :: Readable for PIND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pind::W](W) writer structure"]
impl crate :: Writable for PIND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIND to value 0"]
impl crate :: Resettable for PIND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTD (rw) register accessor: an alias for `Reg<PORTD_SPEC>`"]
pub type PORTD = crate :: Reg < portd :: PORTD_SPEC > ; # [doc = "Port D Data Register"]
pub mod portd { # [doc = "Register `PORTD` reader"]
pub struct R (crate :: R < PORTD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTD_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTD` writer"]
pub struct W (crate :: W < PORTD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port D Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portd](index.html) module"]
pub struct PORTD_SPEC ; impl crate :: RegisterSpec for PORTD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portd::R](R) reader structure"]
impl crate :: Readable for PORTD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portd::W](W) writer structure"]
impl crate :: Writable for PORTD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTD to value 0"]
impl crate :: Resettable for PORTD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTE { _marker : PhantomData < * const () > } unsafe impl Send for PORTE { } impl PORTE { # [doc = r"Pointer to the register block"]
pub const PTR : * const porte :: RegisterBlock = 0x2c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porte :: RegisterBlock { Self :: PTR } } impl Deref for PORTE { type Target = porte :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTE") . finish () } } # [doc = "I/O Port"]
pub mod porte { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port E Input Pins Address"]
pub pine : PINE , # [doc = "0x01 - Port E Data Direction Register"]
pub ddre : DDRE , # [doc = "0x02 - Port E Data Register"]
pub porte : PORTE , } # [doc = "DDRE (rw) register accessor: an alias for `Reg<DDRE_SPEC>`"]
pub type DDRE = crate :: Reg < ddre :: DDRE_SPEC > ; # [doc = "Port E Data Direction Register"]
pub mod ddre { # [doc = "Register `DDRE` reader"]
pub struct R (crate :: R < DDRE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRE_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRE` writer"]
pub struct W (crate :: W < DDRE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port E Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddre](index.html) module"]
pub struct DDRE_SPEC ; impl crate :: RegisterSpec for DDRE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddre::R](R) reader structure"]
impl crate :: Readable for DDRE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddre::W](W) writer structure"]
impl crate :: Writable for DDRE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRE to value 0"]
impl crate :: Resettable for DDRE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PINE (rw) register accessor: an alias for `Reg<PINE_SPEC>`"]
pub type PINE = crate :: Reg < pine :: PINE_SPEC > ; # [doc = "Port E Input Pins Address"]
pub mod pine { # [doc = "Register `PINE` reader"]
pub struct R (crate :: R < PINE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINE` writer"]
pub struct W (crate :: W < PINE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port E Input Pins Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pine](index.html) module"]
pub struct PINE_SPEC ; impl crate :: RegisterSpec for PINE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pine::R](R) reader structure"]
impl crate :: Readable for PINE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pine::W](W) writer structure"]
impl crate :: Writable for PINE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PINE to value 0"]
impl crate :: Resettable for PINE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTE (rw) register accessor: an alias for `Reg<PORTE_SPEC>`"]
pub type PORTE = crate :: Reg < porte :: PORTE_SPEC > ; # [doc = "Port E Data Register"]
pub mod porte { # [doc = "Register `PORTE` reader"]
pub struct R (crate :: R < PORTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTE` writer"]
pub struct W (crate :: W < PORTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port E Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [porte](index.html) module"]
pub struct PORTE_SPEC ; impl crate :: RegisterSpec for PORTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [porte::R](R) reader structure"]
impl crate :: Readable for PORTE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [porte::W](W) writer structure"]
impl crate :: Writable for PORTE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTE to value 0"]
impl crate :: Resettable for PORTE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTF { _marker : PhantomData < * const () > } unsafe impl Send for PORTF { } impl PORTF { # [doc = r"Pointer to the register block"]
pub const PTR : * const portf :: RegisterBlock = 0x2f as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portf :: RegisterBlock { Self :: PTR } } impl Deref for PORTF { type Target = portf :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTF") . finish () } } # [doc = "I/O Port"]
pub mod portf { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port F Input Pins Address"]
pub pinf : PINF , # [doc = "0x01 - Port F Data Direction Register"]
pub ddrf : DDRF , # [doc = "0x02 - Port F Data Register"]
pub portf : PORTF , } # [doc = "DDRF (rw) register accessor: an alias for `Reg<DDRF_SPEC>`"]
pub type DDRF = crate :: Reg < ddrf :: DDRF_SPEC > ; # [doc = "Port F Data Direction Register"]
pub mod ddrf { # [doc = "Register `DDRF` reader"]
pub struct R (crate :: R < DDRF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRF` writer"]
pub struct W (crate :: W < DDRF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port F Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddrf](index.html) module"]
pub struct DDRF_SPEC ; impl crate :: RegisterSpec for DDRF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddrf::R](R) reader structure"]
impl crate :: Readable for DDRF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddrf::W](W) writer structure"]
impl crate :: Writable for DDRF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRF to value 0"]
impl crate :: Resettable for DDRF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PINF (rw) register accessor: an alias for `Reg<PINF_SPEC>`"]
pub type PINF = crate :: Reg < pinf :: PINF_SPEC > ; # [doc = "Port F Input Pins Address"]
pub mod pinf { # [doc = "Register `PINF` reader"]
pub struct R (crate :: R < PINF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINF` writer"]
pub struct W (crate :: W < PINF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port F Input Pins Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pinf](index.html) module"]
pub struct PINF_SPEC ; impl crate :: RegisterSpec for PINF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pinf::R](R) reader structure"]
impl crate :: Readable for PINF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pinf::W](W) writer structure"]
impl crate :: Writable for PINF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PINF to value 0"]
impl crate :: Resettable for PINF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTF (rw) register accessor: an alias for `Reg<PORTF_SPEC>`"]
pub type PORTF = crate :: Reg < portf :: PORTF_SPEC > ; # [doc = "Port F Data Register"]
pub mod portf { # [doc = "Register `PORTF` reader"]
pub struct R (crate :: R < PORTF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTF` writer"]
pub struct W (crate :: W < PORTF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port F Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portf](index.html) module"]
pub struct PORTF_SPEC ; impl crate :: RegisterSpec for PORTF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portf::R](R) reader structure"]
impl crate :: Readable for PORTF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portf::W](W) writer structure"]
impl crate :: Writable for PORTF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTF to value 0"]
impl crate :: Resettable for PORTF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTG { _marker : PhantomData < * const () > } unsafe impl Send for PORTG { } impl PORTG { # [doc = r"Pointer to the register block"]
pub const PTR : * const portg :: RegisterBlock = 0x32 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portg :: RegisterBlock { Self :: PTR } } impl Deref for PORTG { type Target = portg :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTG") . finish () } } # [doc = "I/O Port"]
pub mod portg { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port G Input Pins Address"]
pub ping : PING , # [doc = "0x01 - Port G Data Direction Register"]
pub ddrg : DDRG , # [doc = "0x02 - Port G Data Register"]
pub portg : PORTG , } # [doc = "DDRG (rw) register accessor: an alias for `Reg<DDRG_SPEC>`"]
pub type DDRG = crate :: Reg < ddrg :: DDRG_SPEC > ; # [doc = "Port G Data Direction Register"]
pub mod ddrg { # [doc = "Register `DDRG` reader"]
pub struct R (crate :: R < DDRG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRG_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRG` writer"]
pub struct W (crate :: W < DDRG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port G Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddrg](index.html) module"]
pub struct DDRG_SPEC ; impl crate :: RegisterSpec for DDRG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddrg::R](R) reader structure"]
impl crate :: Readable for DDRG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddrg::W](W) writer structure"]
impl crate :: Writable for DDRG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRG to value 0"]
impl crate :: Resettable for DDRG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PING (rw) register accessor: an alias for `Reg<PING_SPEC>`"]
pub type PING = crate :: Reg < ping :: PING_SPEC > ; # [doc = "Port G Input Pins Address"]
pub mod ping { # [doc = "Register `PING` reader"]
pub struct R (crate :: R < PING_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PING_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PING_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PING_SPEC >) -> Self { R (reader) } } # [doc = "Register `PING` writer"]
pub struct W (crate :: W < PING_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PING_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PING_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PING_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port G Input Pins Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ping](index.html) module"]
pub struct PING_SPEC ; impl crate :: RegisterSpec for PING_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ping::R](R) reader structure"]
impl crate :: Readable for PING_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ping::W](W) writer structure"]
impl crate :: Writable for PING_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PING to value 0"]
impl crate :: Resettable for PING_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTG (rw) register accessor: an alias for `Reg<PORTG_SPEC>`"]
pub type PORTG = crate :: Reg < portg :: PORTG_SPEC > ; # [doc = "Port G Data Register"]
pub mod portg { # [doc = "Register `PORTG` reader"]
pub struct R (crate :: R < PORTG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTG_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTG` writer"]
pub struct W (crate :: W < PORTG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTG_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port G Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portg](index.html) module"]
pub struct PORTG_SPEC ; impl crate :: RegisterSpec for PORTG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portg::R](R) reader structure"]
impl crate :: Readable for PORTG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portg::W](W) writer structure"]
impl crate :: Writable for PORTG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTG to value 0"]
impl crate :: Resettable for PORTG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Power Controller"]
pub struct PWRCTRL { _marker : PhantomData < * const () > } unsafe impl Send for PWRCTRL { } impl PWRCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const pwrctrl :: RegisterBlock = 0x55 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pwrctrl :: RegisterBlock { Self :: PTR } } impl Deref for PWRCTRL { type Target = pwrctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PWRCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PWRCTRL") . finish () } } # [doc = "Power Controller"]
pub mod pwrctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - MCU Control Register"]
pub mcucr : MCUCR , _reserved1 : [u8 ; 0xd9]
, # [doc = "0xda - Low Leakage Voltage Regulator Control Register"]
pub llcr : LLCR , # [doc = "0xdb - Low Leakage Voltage Regulator Data Register (Low-Byte)"]
pub lldrl : LLDRL , # [doc = "0xdc - Low Leakage Voltage Regulator Data Register (High-Byte)"]
pub lldrh : LLDRH , # [doc = "0xdd - Data Retention Configuration Register of SRAM 3"]
pub drtram3 : DRTRAM3 , # [doc = "0xde - Data Retention Configuration Register of SRAM 2"]
pub drtram2 : DRTRAM2 , # [doc = "0xdf - Data Retention Configuration Register of SRAM 1"]
pub drtram1 : DRTRAM1 , # [doc = "0xe0 - Data Retention Configuration Register of SRAM 0"]
pub drtram0 : DRTRAM0 , # [doc = "0xe1 - Port Driver Strength Register 0"]
pub dpds0 : DPDS0 , # [doc = "0xe2 - Port Driver Strength Register 1"]
pub dpds1 : DPDS1 , _reserved10 : [u8 ; 0x01]
, # [doc = "0xe4 - Transceiver Pin Register"]
pub trxpr : TRXPR , } # [doc = "DPDS0 (rw) register accessor: an alias for `Reg<DPDS0_SPEC>`"]
pub type DPDS0 = crate :: Reg < dpds0 :: DPDS0_SPEC > ; # [doc = "Port Driver Strength Register 0"]
pub mod dpds0 { # [doc = "Register `DPDS0` reader"]
pub struct R (crate :: R < DPDS0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DPDS0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DPDS0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DPDS0_SPEC >) -> Self { R (reader) } } # [doc = "Register `DPDS0` writer"]
pub struct W (crate :: W < DPDS0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DPDS0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DPDS0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DPDS0_SPEC >) -> Self { W (writer) } } # [doc = "Field `PBDRV` reader - Driver Strength Port B"]
pub type PBDRV_R = crate :: FieldReader < u8 , PBDRV_A > ; # [doc = "Driver Strength Port B\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PBDRV_A { # [doc = "0: 2 mA"]
PAD_IO_2MA = 0 , # [doc = "1: 4 mA"]
PAD_IO_4MA = 1 , # [doc = "2: 6 mA"]
PAD_IO_6MA = 2 , # [doc = "3: 8 mA"]
PAD_IO_8MA = 3 , } impl From < PBDRV_A > for u8 { # [inline (always)]
fn from (variant : PBDRV_A) -> Self { variant as _ } } impl PBDRV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PBDRV_A { match self . bits { 0 => PBDRV_A :: PAD_IO_2MA , 1 => PBDRV_A :: PAD_IO_4MA , 2 => PBDRV_A :: PAD_IO_6MA , 3 => PBDRV_A :: PAD_IO_8MA , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PAD_IO_2MA`"]
# [inline (always)]
pub fn is_pad_io_2ma (& self) -> bool { * self == PBDRV_A :: PAD_IO_2MA } # [doc = "Checks if the value of the field is `PAD_IO_4MA`"]
# [inline (always)]
pub fn is_pad_io_4ma (& self) -> bool { * self == PBDRV_A :: PAD_IO_4MA } # [doc = "Checks if the value of the field is `PAD_IO_6MA`"]
# [inline (always)]
pub fn is_pad_io_6ma (& self) -> bool { * self == PBDRV_A :: PAD_IO_6MA } # [doc = "Checks if the value of the field is `PAD_IO_8MA`"]
# [inline (always)]
pub fn is_pad_io_8ma (& self) -> bool { * self == PBDRV_A :: PAD_IO_8MA } } # [doc = "Field `PBDRV` writer - Driver Strength Port B"]
pub type PBDRV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DPDS0_SPEC , u8 , PBDRV_A , 2 , O > ; impl < 'a , const O : u8 > PBDRV_W < 'a , O > { # [doc = "2 mA"]
# [inline (always)]
pub fn pad_io_2ma (self) -> & 'a mut W { self . variant (PBDRV_A :: PAD_IO_2MA) } # [doc = "4 mA"]
# [inline (always)]
pub fn pad_io_4ma (self) -> & 'a mut W { self . variant (PBDRV_A :: PAD_IO_4MA) } # [doc = "6 mA"]
# [inline (always)]
pub fn pad_io_6ma (self) -> & 'a mut W { self . variant (PBDRV_A :: PAD_IO_6MA) } # [doc = "8 mA"]
# [inline (always)]
pub fn pad_io_8ma (self) -> & 'a mut W { self . variant (PBDRV_A :: PAD_IO_8MA) } } # [doc = "Field `PDDRV` reader - Driver Strength Port D"]
pub type PDDRV_R = crate :: FieldReader < u8 , PDDRV_A > ; # [doc = "Driver Strength Port D\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PDDRV_A { # [doc = "0: 2 mA"]
PAD_IO_2MA = 0 , # [doc = "1: 4 mA"]
PAD_IO_4MA = 1 , # [doc = "2: 6 mA"]
PAD_IO_6MA = 2 , # [doc = "3: 8 mA"]
PAD_IO_8MA = 3 , } impl From < PDDRV_A > for u8 { # [inline (always)]
fn from (variant : PDDRV_A) -> Self { variant as _ } } impl PDDRV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PDDRV_A { match self . bits { 0 => PDDRV_A :: PAD_IO_2MA , 1 => PDDRV_A :: PAD_IO_4MA , 2 => PDDRV_A :: PAD_IO_6MA , 3 => PDDRV_A :: PAD_IO_8MA , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PAD_IO_2MA`"]
# [inline (always)]
pub fn is_pad_io_2ma (& self) -> bool { * self == PDDRV_A :: PAD_IO_2MA } # [doc = "Checks if the value of the field is `PAD_IO_4MA`"]
# [inline (always)]
pub fn is_pad_io_4ma (& self) -> bool { * self == PDDRV_A :: PAD_IO_4MA } # [doc = "Checks if the value of the field is `PAD_IO_6MA`"]
# [inline (always)]
pub fn is_pad_io_6ma (& self) -> bool { * self == PDDRV_A :: PAD_IO_6MA } # [doc = "Checks if the value of the field is `PAD_IO_8MA`"]
# [inline (always)]
pub fn is_pad_io_8ma (& self) -> bool { * self == PDDRV_A :: PAD_IO_8MA } } # [doc = "Field `PDDRV` writer - Driver Strength Port D"]
pub type PDDRV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DPDS0_SPEC , u8 , PDDRV_A , 2 , O > ; impl < 'a , const O : u8 > PDDRV_W < 'a , O > { # [doc = "2 mA"]
# [inline (always)]
pub fn pad_io_2ma (self) -> & 'a mut W { self . variant (PDDRV_A :: PAD_IO_2MA) } # [doc = "4 mA"]
# [inline (always)]
pub fn pad_io_4ma (self) -> & 'a mut W { self . variant (PDDRV_A :: PAD_IO_4MA) } # [doc = "6 mA"]
# [inline (always)]
pub fn pad_io_6ma (self) -> & 'a mut W { self . variant (PDDRV_A :: PAD_IO_6MA) } # [doc = "8 mA"]
# [inline (always)]
pub fn pad_io_8ma (self) -> & 'a mut W { self . variant (PDDRV_A :: PAD_IO_8MA) } } # [doc = "Field `PEDRV` reader - Driver Strength Port E"]
pub type PEDRV_R = crate :: FieldReader < u8 , PEDRV_A > ; # [doc = "Driver Strength Port E\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PEDRV_A { # [doc = "0: 2 mA"]
PAD_IO_2MA = 0 , # [doc = "1: 4 mA"]
PAD_IO_4MA = 1 , # [doc = "2: 6 mA"]
PAD_IO_6MA = 2 , # [doc = "3: 8 mA"]
PAD_IO_8MA = 3 , } impl From < PEDRV_A > for u8 { # [inline (always)]
fn from (variant : PEDRV_A) -> Self { variant as _ } } impl PEDRV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PEDRV_A { match self . bits { 0 => PEDRV_A :: PAD_IO_2MA , 1 => PEDRV_A :: PAD_IO_4MA , 2 => PEDRV_A :: PAD_IO_6MA , 3 => PEDRV_A :: PAD_IO_8MA , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PAD_IO_2MA`"]
# [inline (always)]
pub fn is_pad_io_2ma (& self) -> bool { * self == PEDRV_A :: PAD_IO_2MA } # [doc = "Checks if the value of the field is `PAD_IO_4MA`"]
# [inline (always)]
pub fn is_pad_io_4ma (& self) -> bool { * self == PEDRV_A :: PAD_IO_4MA } # [doc = "Checks if the value of the field is `PAD_IO_6MA`"]
# [inline (always)]
pub fn is_pad_io_6ma (& self) -> bool { * self == PEDRV_A :: PAD_IO_6MA } # [doc = "Checks if the value of the field is `PAD_IO_8MA`"]
# [inline (always)]
pub fn is_pad_io_8ma (& self) -> bool { * self == PEDRV_A :: PAD_IO_8MA } } # [doc = "Field `PEDRV` writer - Driver Strength Port E"]
pub type PEDRV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DPDS0_SPEC , u8 , PEDRV_A , 2 , O > ; impl < 'a , const O : u8 > PEDRV_W < 'a , O > { # [doc = "2 mA"]
# [inline (always)]
pub fn pad_io_2ma (self) -> & 'a mut W { self . variant (PEDRV_A :: PAD_IO_2MA) } # [doc = "4 mA"]
# [inline (always)]
pub fn pad_io_4ma (self) -> & 'a mut W { self . variant (PEDRV_A :: PAD_IO_4MA) } # [doc = "6 mA"]
# [inline (always)]
pub fn pad_io_6ma (self) -> & 'a mut W { self . variant (PEDRV_A :: PAD_IO_6MA) } # [doc = "8 mA"]
# [inline (always)]
pub fn pad_io_8ma (self) -> & 'a mut W { self . variant (PEDRV_A :: PAD_IO_8MA) } } # [doc = "Field `PFDRV` reader - Driver Strength Port F"]
pub type PFDRV_R = crate :: FieldReader < u8 , PFDRV_A > ; # [doc = "Driver Strength Port F\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PFDRV_A { # [doc = "0: 2 mA"]
PAD_IO_2MA = 0 , # [doc = "1: 4 mA"]
PAD_IO_4MA = 1 , # [doc = "2: 6 mA"]
PAD_IO_6MA = 2 , # [doc = "3: 8 mA"]
PAD_IO_8MA = 3 , } impl From < PFDRV_A > for u8 { # [inline (always)]
fn from (variant : PFDRV_A) -> Self { variant as _ } } impl PFDRV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PFDRV_A { match self . bits { 0 => PFDRV_A :: PAD_IO_2MA , 1 => PFDRV_A :: PAD_IO_4MA , 2 => PFDRV_A :: PAD_IO_6MA , 3 => PFDRV_A :: PAD_IO_8MA , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PAD_IO_2MA`"]
# [inline (always)]
pub fn is_pad_io_2ma (& self) -> bool { * self == PFDRV_A :: PAD_IO_2MA } # [doc = "Checks if the value of the field is `PAD_IO_4MA`"]
# [inline (always)]
pub fn is_pad_io_4ma (& self) -> bool { * self == PFDRV_A :: PAD_IO_4MA } # [doc = "Checks if the value of the field is `PAD_IO_6MA`"]
# [inline (always)]
pub fn is_pad_io_6ma (& self) -> bool { * self == PFDRV_A :: PAD_IO_6MA } # [doc = "Checks if the value of the field is `PAD_IO_8MA`"]
# [inline (always)]
pub fn is_pad_io_8ma (& self) -> bool { * self == PFDRV_A :: PAD_IO_8MA } } # [doc = "Field `PFDRV` writer - Driver Strength Port F"]
pub type PFDRV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DPDS0_SPEC , u8 , PFDRV_A , 2 , O > ; impl < 'a , const O : u8 > PFDRV_W < 'a , O > { # [doc = "2 mA"]
# [inline (always)]
pub fn pad_io_2ma (self) -> & 'a mut W { self . variant (PFDRV_A :: PAD_IO_2MA) } # [doc = "4 mA"]
# [inline (always)]
pub fn pad_io_4ma (self) -> & 'a mut W { self . variant (PFDRV_A :: PAD_IO_4MA) } # [doc = "6 mA"]
# [inline (always)]
pub fn pad_io_6ma (self) -> & 'a mut W { self . variant (PFDRV_A :: PAD_IO_6MA) } # [doc = "8 mA"]
# [inline (always)]
pub fn pad_io_8ma (self) -> & 'a mut W { self . variant (PFDRV_A :: PAD_IO_8MA) } } impl R { # [doc = "Bits 0:1 - Driver Strength Port B"]
# [inline (always)]
pub fn pbdrv (& self) -> PBDRV_R { PBDRV_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Driver Strength Port D"]
# [inline (always)]
pub fn pddrv (& self) -> PDDRV_R { PDDRV_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Driver Strength Port E"]
# [inline (always)]
pub fn pedrv (& self) -> PEDRV_R { PEDRV_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Driver Strength Port F"]
# [inline (always)]
pub fn pfdrv (& self) -> PFDRV_R { PFDRV_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Driver Strength Port B"]
# [inline (always)]
# [must_use]
pub fn pbdrv (& mut self) -> PBDRV_W < 0 > { PBDRV_W :: new (self) } # [doc = "Bits 2:3 - Driver Strength Port D"]
# [inline (always)]
# [must_use]
pub fn pddrv (& mut self) -> PDDRV_W < 2 > { PDDRV_W :: new (self) } # [doc = "Bits 4:5 - Driver Strength Port E"]
# [inline (always)]
# [must_use]
pub fn pedrv (& mut self) -> PEDRV_W < 4 > { PEDRV_W :: new (self) } # [doc = "Bits 6:7 - Driver Strength Port F"]
# [inline (always)]
# [must_use]
pub fn pfdrv (& mut self) -> PFDRV_W < 6 > { PFDRV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Driver Strength Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dpds0](index.html) module"]
pub struct DPDS0_SPEC ; impl crate :: RegisterSpec for DPDS0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dpds0::R](R) reader structure"]
impl crate :: Readable for DPDS0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dpds0::W](W) writer structure"]
impl crate :: Writable for DPDS0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DPDS0 to value 0"]
impl crate :: Resettable for DPDS0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DPDS1 (rw) register accessor: an alias for `Reg<DPDS1_SPEC>`"]
pub type DPDS1 = crate :: Reg < dpds1 :: DPDS1_SPEC > ; # [doc = "Port Driver Strength Register 1"]
pub mod dpds1 { # [doc = "Register `DPDS1` reader"]
pub struct R (crate :: R < DPDS1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DPDS1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DPDS1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DPDS1_SPEC >) -> Self { R (reader) } } # [doc = "Register `DPDS1` writer"]
pub struct W (crate :: W < DPDS1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DPDS1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DPDS1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DPDS1_SPEC >) -> Self { W (writer) } } # [doc = "Field `PGDRV` reader - Driver Strength Port G"]
pub type PGDRV_R = crate :: FieldReader < u8 , PGDRV_A > ; # [doc = "Driver Strength Port G\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PGDRV_A { # [doc = "0: 2 mA"]
PAD_IO_2MA = 0 , # [doc = "1: 4 mA"]
PAD_IO_4MA = 1 , # [doc = "2: 6 mA"]
PAD_IO_6MA = 2 , # [doc = "3: 8 mA"]
PAD_IO_8MA = 3 , } impl From < PGDRV_A > for u8 { # [inline (always)]
fn from (variant : PGDRV_A) -> Self { variant as _ } } impl PGDRV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PGDRV_A { match self . bits { 0 => PGDRV_A :: PAD_IO_2MA , 1 => PGDRV_A :: PAD_IO_4MA , 2 => PGDRV_A :: PAD_IO_6MA , 3 => PGDRV_A :: PAD_IO_8MA , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PAD_IO_2MA`"]
# [inline (always)]
pub fn is_pad_io_2ma (& self) -> bool { * self == PGDRV_A :: PAD_IO_2MA } # [doc = "Checks if the value of the field is `PAD_IO_4MA`"]
# [inline (always)]
pub fn is_pad_io_4ma (& self) -> bool { * self == PGDRV_A :: PAD_IO_4MA } # [doc = "Checks if the value of the field is `PAD_IO_6MA`"]
# [inline (always)]
pub fn is_pad_io_6ma (& self) -> bool { * self == PGDRV_A :: PAD_IO_6MA } # [doc = "Checks if the value of the field is `PAD_IO_8MA`"]
# [inline (always)]
pub fn is_pad_io_8ma (& self) -> bool { * self == PGDRV_A :: PAD_IO_8MA } } # [doc = "Field `PGDRV` writer - Driver Strength Port G"]
pub type PGDRV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DPDS1_SPEC , u8 , PGDRV_A , 2 , O > ; impl < 'a , const O : u8 > PGDRV_W < 'a , O > { # [doc = "2 mA"]
# [inline (always)]
pub fn pad_io_2ma (self) -> & 'a mut W { self . variant (PGDRV_A :: PAD_IO_2MA) } # [doc = "4 mA"]
# [inline (always)]
pub fn pad_io_4ma (self) -> & 'a mut W { self . variant (PGDRV_A :: PAD_IO_4MA) } # [doc = "6 mA"]
# [inline (always)]
pub fn pad_io_6ma (self) -> & 'a mut W { self . variant (PGDRV_A :: PAD_IO_6MA) } # [doc = "8 mA"]
# [inline (always)]
pub fn pad_io_8ma (self) -> & 'a mut W { self . variant (PGDRV_A :: PAD_IO_8MA) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DPDS1_SPEC , u8 , u8 , 6 , O > ; impl R { # [doc = "Bits 0:1 - Driver Strength Port G"]
# [inline (always)]
pub fn pgdrv (& self) -> PGDRV_R { PGDRV_R :: new (self . bits & 3) } # [doc = "Bits 2:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 2) & 0x3f) } } impl W { # [doc = "Bits 0:1 - Driver Strength Port G"]
# [inline (always)]
# [must_use]
pub fn pgdrv (& mut self) -> PGDRV_W < 0 > { PGDRV_W :: new (self) } # [doc = "Bits 2:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 2 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Driver Strength Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dpds1](index.html) module"]
pub struct DPDS1_SPEC ; impl crate :: RegisterSpec for DPDS1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dpds1::R](R) reader structure"]
impl crate :: Readable for DPDS1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dpds1::W](W) writer structure"]
impl crate :: Writable for DPDS1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DPDS1 to value 0"]
impl crate :: Resettable for DPDS1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DRTRAM0 (rw) register accessor: an alias for `Reg<DRTRAM0_SPEC>`"]
pub type DRTRAM0 = crate :: Reg < drtram0 :: DRTRAM0_SPEC > ; # [doc = "Data Retention Configuration Register of SRAM 0"]
pub mod drtram0 { # [doc = "Register `DRTRAM0` reader"]
pub struct R (crate :: R < DRTRAM0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DRTRAM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DRTRAM0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DRTRAM0_SPEC >) -> Self { R (reader) } } # [doc = "Register `DRTRAM0` writer"]
pub struct W (crate :: W < DRTRAM0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DRTRAM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DRTRAM0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DRTRAM0_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENDRT` reader - Enable SRAM Data Retention"]
pub type ENDRT_R = crate :: BitReader < bool > ; # [doc = "Field `ENDRT` writer - Enable SRAM Data Retention"]
pub type ENDRT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM0_SPEC , bool , O > ; # [doc = "Field `DRTSWOK` reader - DRT Switch OK"]
pub type DRTSWOK_R = crate :: BitReader < bool > ; # [doc = "Field `DRTSWOK` writer - DRT Switch OK"]
pub type DRTSWOK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM0_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DRTRAM0_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 4 - Enable SRAM Data Retention"]
# [inline (always)]
pub fn endrt (& self) -> ENDRT_R { ENDRT_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DRT Switch OK"]
# [inline (always)]
pub fn drtswok (& self) -> DRTSWOK_R { DRTSWOK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 4 - Enable SRAM Data Retention"]
# [inline (always)]
# [must_use]
pub fn endrt (& mut self) -> ENDRT_W < 4 > { ENDRT_W :: new (self) } # [doc = "Bit 5 - DRT Switch OK"]
# [inline (always)]
# [must_use]
pub fn drtswok (& mut self) -> DRTSWOK_W < 5 > { DRTSWOK_W :: new (self) } # [doc = "Bits 6:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 6 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Retention Configuration Register of SRAM 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [drtram0](index.html) module"]
pub struct DRTRAM0_SPEC ; impl crate :: RegisterSpec for DRTRAM0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [drtram0::R](R) reader structure"]
impl crate :: Readable for DRTRAM0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [drtram0::W](W) writer structure"]
impl crate :: Writable for DRTRAM0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DRTRAM0 to value 0"]
impl crate :: Resettable for DRTRAM0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DRTRAM1 (rw) register accessor: an alias for `Reg<DRTRAM1_SPEC>`"]
pub type DRTRAM1 = crate :: Reg < drtram1 :: DRTRAM1_SPEC > ; # [doc = "Data Retention Configuration Register of SRAM 1"]
pub mod drtram1 { # [doc = "Register `DRTRAM1` reader"]
pub struct R (crate :: R < DRTRAM1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DRTRAM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DRTRAM1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DRTRAM1_SPEC >) -> Self { R (reader) } } # [doc = "Register `DRTRAM1` writer"]
pub struct W (crate :: W < DRTRAM1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DRTRAM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DRTRAM1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DRTRAM1_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENDRT` reader - Enable SRAM Data Retention"]
pub type ENDRT_R = crate :: BitReader < bool > ; # [doc = "Field `ENDRT` writer - Enable SRAM Data Retention"]
pub type ENDRT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM1_SPEC , bool , O > ; # [doc = "Field `DRTSWOK` reader - DRT Switch OK"]
pub type DRTSWOK_R = crate :: BitReader < bool > ; # [doc = "Field `DRTSWOK` writer - DRT Switch OK"]
pub type DRTSWOK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM1_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DRTRAM1_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 4 - Enable SRAM Data Retention"]
# [inline (always)]
pub fn endrt (& self) -> ENDRT_R { ENDRT_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DRT Switch OK"]
# [inline (always)]
pub fn drtswok (& self) -> DRTSWOK_R { DRTSWOK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 4 - Enable SRAM Data Retention"]
# [inline (always)]
# [must_use]
pub fn endrt (& mut self) -> ENDRT_W < 4 > { ENDRT_W :: new (self) } # [doc = "Bit 5 - DRT Switch OK"]
# [inline (always)]
# [must_use]
pub fn drtswok (& mut self) -> DRTSWOK_W < 5 > { DRTSWOK_W :: new (self) } # [doc = "Bits 6:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 6 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Retention Configuration Register of SRAM 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [drtram1](index.html) module"]
pub struct DRTRAM1_SPEC ; impl crate :: RegisterSpec for DRTRAM1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [drtram1::R](R) reader structure"]
impl crate :: Readable for DRTRAM1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [drtram1::W](W) writer structure"]
impl crate :: Writable for DRTRAM1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DRTRAM1 to value 0"]
impl crate :: Resettable for DRTRAM1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DRTRAM2 (rw) register accessor: an alias for `Reg<DRTRAM2_SPEC>`"]
pub type DRTRAM2 = crate :: Reg < drtram2 :: DRTRAM2_SPEC > ; # [doc = "Data Retention Configuration Register of SRAM 2"]
pub mod drtram2 { # [doc = "Register `DRTRAM2` reader"]
pub struct R (crate :: R < DRTRAM2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DRTRAM2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DRTRAM2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DRTRAM2_SPEC >) -> Self { R (reader) } } # [doc = "Register `DRTRAM2` writer"]
pub struct W (crate :: W < DRTRAM2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DRTRAM2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DRTRAM2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DRTRAM2_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENDRT` reader - Enable SRAM Data Retention"]
pub type ENDRT_R = crate :: BitReader < bool > ; # [doc = "Field `ENDRT` writer - Enable SRAM Data Retention"]
pub type ENDRT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM2_SPEC , bool , O > ; # [doc = "Field `DRTSWOK` reader - DRT Switch OK"]
pub type DRTSWOK_R = crate :: BitReader < bool > ; # [doc = "Field `DRTSWOK` writer - DRT Switch OK"]
pub type DRTSWOK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM2_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM2_SPEC , bool , O > ; impl R { # [doc = "Bit 4 - Enable SRAM Data Retention"]
# [inline (always)]
pub fn endrt (& self) -> ENDRT_R { ENDRT_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DRT Switch OK"]
# [inline (always)]
pub fn drtswok (& self) -> DRTSWOK_R { DRTSWOK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 4 - Enable SRAM Data Retention"]
# [inline (always)]
# [must_use]
pub fn endrt (& mut self) -> ENDRT_W < 4 > { ENDRT_W :: new (self) } # [doc = "Bit 5 - DRT Switch OK"]
# [inline (always)]
# [must_use]
pub fn drtswok (& mut self) -> DRTSWOK_W < 5 > { DRTSWOK_W :: new (self) } # [doc = "Bit 6 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 6 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Retention Configuration Register of SRAM 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [drtram2](index.html) module"]
pub struct DRTRAM2_SPEC ; impl crate :: RegisterSpec for DRTRAM2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [drtram2::R](R) reader structure"]
impl crate :: Readable for DRTRAM2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [drtram2::W](W) writer structure"]
impl crate :: Writable for DRTRAM2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DRTRAM2 to value 0"]
impl crate :: Resettable for DRTRAM2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DRTRAM3 (rw) register accessor: an alias for `Reg<DRTRAM3_SPEC>`"]
pub type DRTRAM3 = crate :: Reg < drtram3 :: DRTRAM3_SPEC > ; # [doc = "Data Retention Configuration Register of SRAM 3"]
pub mod drtram3 { # [doc = "Register `DRTRAM3` reader"]
pub struct R (crate :: R < DRTRAM3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DRTRAM3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DRTRAM3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DRTRAM3_SPEC >) -> Self { R (reader) } } # [doc = "Register `DRTRAM3` writer"]
pub struct W (crate :: W < DRTRAM3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DRTRAM3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DRTRAM3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DRTRAM3_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENDRT` reader - Enable SRAM Data Retention"]
pub type ENDRT_R = crate :: BitReader < bool > ; # [doc = "Field `ENDRT` writer - Enable SRAM Data Retention"]
pub type ENDRT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM3_SPEC , bool , O > ; # [doc = "Field `DRTSWOK` reader - DRT Switch OK"]
pub type DRTSWOK_R = crate :: BitReader < bool > ; # [doc = "Field `DRTSWOK` writer - DRT Switch OK"]
pub type DRTSWOK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DRTRAM3_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DRTRAM3_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 4 - Enable SRAM Data Retention"]
# [inline (always)]
pub fn endrt (& self) -> ENDRT_R { ENDRT_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DRT Switch OK"]
# [inline (always)]
pub fn drtswok (& self) -> DRTSWOK_R { DRTSWOK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 4 - Enable SRAM Data Retention"]
# [inline (always)]
# [must_use]
pub fn endrt (& mut self) -> ENDRT_W < 4 > { ENDRT_W :: new (self) } # [doc = "Bit 5 - DRT Switch OK"]
# [inline (always)]
# [must_use]
pub fn drtswok (& mut self) -> DRTSWOK_W < 5 > { DRTSWOK_W :: new (self) } # [doc = "Bits 6:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 6 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Retention Configuration Register of SRAM 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [drtram3](index.html) module"]
pub struct DRTRAM3_SPEC ; impl crate :: RegisterSpec for DRTRAM3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [drtram3::R](R) reader structure"]
impl crate :: Readable for DRTRAM3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [drtram3::W](W) writer structure"]
impl crate :: Writable for DRTRAM3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DRTRAM3 to value 0"]
impl crate :: Resettable for DRTRAM3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LLCR (rw) register accessor: an alias for `Reg<LLCR_SPEC>`"]
pub type LLCR = crate :: Reg < llcr :: LLCR_SPEC > ; # [doc = "Low Leakage Voltage Regulator Control Register"]
pub mod llcr { # [doc = "Register `LLCR` reader"]
pub struct R (crate :: R < LLCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LLCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LLCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LLCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `LLCR` writer"]
pub struct W (crate :: W < LLCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LLCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LLCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LLCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `LLENCAL` reader - Enable Automatic Calibration"]
pub type LLENCAL_R = crate :: BitReader < bool > ; # [doc = "Field `LLENCAL` writer - Enable Automatic Calibration"]
pub type LLENCAL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LLCR_SPEC , bool , O > ; # [doc = "Field `LLSHORT` reader - Short Lower Calibration Circuit"]
pub type LLSHORT_R = crate :: BitReader < bool > ; # [doc = "Field `LLSHORT` writer - Short Lower Calibration Circuit"]
pub type LLSHORT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LLCR_SPEC , bool , O > ; # [doc = "Field `LLTCO` reader - Temperature Coefficient of Current Source"]
pub type LLTCO_R = crate :: BitReader < bool > ; # [doc = "Field `LLTCO` writer - Temperature Coefficient of Current Source"]
pub type LLTCO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LLCR_SPEC , bool , O > ; # [doc = "Field `LLCAL` reader - Calibration Active"]
pub type LLCAL_R = crate :: BitReader < bool > ; # [doc = "Field `LLCAL` writer - Calibration Active"]
pub type LLCAL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LLCR_SPEC , bool , O > ; # [doc = "Field `LLCOMP` reader - Comparator Output"]
pub type LLCOMP_R = crate :: BitReader < bool > ; # [doc = "Field `LLCOMP` writer - Comparator Output"]
pub type LLCOMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LLCR_SPEC , bool , O > ; # [doc = "Field `LLDONE` reader - Calibration Done"]
pub type LLDONE_R = crate :: BitReader < bool > ; # [doc = "Field `LLDONE` writer - Calibration Done"]
pub type LLDONE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LLCR_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LLCR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Enable Automatic Calibration"]
# [inline (always)]
pub fn llencal (& self) -> LLENCAL_R { LLENCAL_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Short Lower Calibration Circuit"]
# [inline (always)]
pub fn llshort (& self) -> LLSHORT_R { LLSHORT_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Temperature Coefficient of Current Source"]
# [inline (always)]
pub fn lltco (& self) -> LLTCO_R { LLTCO_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Calibration Active"]
# [inline (always)]
pub fn llcal (& self) -> LLCAL_R { LLCAL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Comparator Output"]
# [inline (always)]
pub fn llcomp (& self) -> LLCOMP_R { LLCOMP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Calibration Done"]
# [inline (always)]
pub fn lldone (& self) -> LLDONE_R { LLDONE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Enable Automatic Calibration"]
# [inline (always)]
# [must_use]
pub fn llencal (& mut self) -> LLENCAL_W < 0 > { LLENCAL_W :: new (self) } # [doc = "Bit 1 - Short Lower Calibration Circuit"]
# [inline (always)]
# [must_use]
pub fn llshort (& mut self) -> LLSHORT_W < 1 > { LLSHORT_W :: new (self) } # [doc = "Bit 2 - Temperature Coefficient of Current Source"]
# [inline (always)]
# [must_use]
pub fn lltco (& mut self) -> LLTCO_W < 2 > { LLTCO_W :: new (self) } # [doc = "Bit 3 - Calibration Active"]
# [inline (always)]
# [must_use]
pub fn llcal (& mut self) -> LLCAL_W < 3 > { LLCAL_W :: new (self) } # [doc = "Bit 4 - Comparator Output"]
# [inline (always)]
# [must_use]
pub fn llcomp (& mut self) -> LLCOMP_W < 4 > { LLCOMP_W :: new (self) } # [doc = "Bit 5 - Calibration Done"]
# [inline (always)]
# [must_use]
pub fn lldone (& mut self) -> LLDONE_W < 5 > { LLDONE_W :: new (self) } # [doc = "Bits 6:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 6 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Low Leakage Voltage Regulator Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [llcr](index.html) module"]
pub struct LLCR_SPEC ; impl crate :: RegisterSpec for LLCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [llcr::R](R) reader structure"]
impl crate :: Readable for LLCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [llcr::W](W) writer structure"]
impl crate :: Writable for LLCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LLCR to value 0"]
impl crate :: Resettable for LLCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LLDRH (rw) register accessor: an alias for `Reg<LLDRH_SPEC>`"]
pub type LLDRH = crate :: Reg < lldrh :: LLDRH_SPEC > ; # [doc = "Low Leakage Voltage Regulator Data Register (High-Byte)"]
pub mod lldrh { # [doc = "Register `LLDRH` reader"]
pub struct R (crate :: R < LLDRH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LLDRH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LLDRH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LLDRH_SPEC >) -> Self { R (reader) } } # [doc = "Register `LLDRH` writer"]
pub struct W (crate :: W < LLDRH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LLDRH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LLDRH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LLDRH_SPEC >) -> Self { W (writer) } } # [doc = "Field `LLDRH` reader - High-Byte Data Register Bits"]
pub type LLDRH_R = crate :: FieldReader < u8 , LLDRH_A > ; # [doc = "High-Byte Data Register Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LLDRH_A { # [doc = "0: Calibration limit for fast process corner/high output voltage"]
CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE = 0 , # [doc = "16: Calibration limit for slow process corner/low output voltage"]
CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE = 16 , } impl From < LLDRH_A > for u8 { # [inline (always)]
fn from (variant : LLDRH_A) -> Self { variant as _ } } impl LLDRH_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LLDRH_A > { match self . bits { 0 => Some (LLDRH_A :: CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE) , 16 => Some (LLDRH_A :: CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE) , _ => None , } } # [doc = "Checks if the value of the field is `CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE`"]
# [inline (always)]
pub fn is_calibration_limit_for_fast_process_corner_high_output_voltage (& self) -> bool { * self == LLDRH_A :: CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE } # [doc = "Checks if the value of the field is `CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE`"]
# [inline (always)]
pub fn is_calibration_limit_for_slow_process_corner_low_output_voltage (& self) -> bool { * self == LLDRH_A :: CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE } } # [doc = "Field `LLDRH` writer - High-Byte Data Register Bits"]
pub type LLDRH_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LLDRH_SPEC , u8 , LLDRH_A , 5 , O > ; impl < 'a , const O : u8 > LLDRH_W < 'a , O > { # [doc = "Calibration limit for fast process corner/high output voltage"]
# [inline (always)]
pub fn calibration_limit_for_fast_process_corner_high_output_voltage (self) -> & 'a mut W { self . variant (LLDRH_A :: CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE) } # [doc = "Calibration limit for slow process corner/low output voltage"]
# [inline (always)]
pub fn calibration_limit_for_slow_process_corner_low_output_voltage (self) -> & 'a mut W { self . variant (LLDRH_A :: CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LLDRH_SPEC , u8 , u8 , 3 , O > ; impl R { # [doc = "Bits 0:4 - High-Byte Data Register Bits"]
# [inline (always)]
pub fn lldrh (& self) -> LLDRH_R { LLDRH_R :: new (self . bits & 0x1f) } # [doc = "Bits 5:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:4 - High-Byte Data Register Bits"]
# [inline (always)]
# [must_use]
pub fn lldrh (& mut self) -> LLDRH_W < 0 > { LLDRH_W :: new (self) } # [doc = "Bits 5:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 5 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Low Leakage Voltage Regulator Data Register (High-Byte)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lldrh](index.html) module"]
pub struct LLDRH_SPEC ; impl crate :: RegisterSpec for LLDRH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lldrh::R](R) reader structure"]
impl crate :: Readable for LLDRH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lldrh::W](W) writer structure"]
impl crate :: Writable for LLDRH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LLDRH to value 0"]
impl crate :: Resettable for LLDRH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LLDRL (rw) register accessor: an alias for `Reg<LLDRL_SPEC>`"]
pub type LLDRL = crate :: Reg < lldrl :: LLDRL_SPEC > ; # [doc = "Low Leakage Voltage Regulator Data Register (Low-Byte)"]
pub mod lldrl { # [doc = "Register `LLDRL` reader"]
pub struct R (crate :: R < LLDRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LLDRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LLDRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LLDRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `LLDRL` writer"]
pub struct W (crate :: W < LLDRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LLDRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LLDRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LLDRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `LLDRL` reader - Low-Byte Data Register Bits"]
pub type LLDRL_R = crate :: FieldReader < u8 , LLDRL_A > ; # [doc = "Low-Byte Data Register Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LLDRL_A { # [doc = "0: Calibration limit for fast process corner/high output voltage"]
CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE = 0 , # [doc = "8: Calibration limit for slow process corner/low output voltage"]
CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE = 8 , } impl From < LLDRL_A > for u8 { # [inline (always)]
fn from (variant : LLDRL_A) -> Self { variant as _ } } impl LLDRL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LLDRL_A > { match self . bits { 0 => Some (LLDRL_A :: CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE) , 8 => Some (LLDRL_A :: CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE) , _ => None , } } # [doc = "Checks if the value of the field is `CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE`"]
# [inline (always)]
pub fn is_calibration_limit_for_fast_process_corner_high_output_voltage (& self) -> bool { * self == LLDRL_A :: CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE } # [doc = "Checks if the value of the field is `CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE`"]
# [inline (always)]
pub fn is_calibration_limit_for_slow_process_corner_low_output_voltage (& self) -> bool { * self == LLDRL_A :: CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE } } # [doc = "Field `LLDRL` writer - Low-Byte Data Register Bits"]
pub type LLDRL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LLDRL_SPEC , u8 , LLDRL_A , 4 , O > ; impl < 'a , const O : u8 > LLDRL_W < 'a , O > { # [doc = "Calibration limit for fast process corner/high output voltage"]
# [inline (always)]
pub fn calibration_limit_for_fast_process_corner_high_output_voltage (self) -> & 'a mut W { self . variant (LLDRL_A :: CALIBRATION_LIMIT_FOR_FAST_PROCESS_CORNER_HIGH_OUTPUT_VOLTAGE) } # [doc = "Calibration limit for slow process corner/low output voltage"]
# [inline (always)]
pub fn calibration_limit_for_slow_process_corner_low_output_voltage (self) -> & 'a mut W { self . variant (LLDRL_A :: CALIBRATION_LIMIT_FOR_SLOW_PROCESS_CORNER_LOW_OUTPUT_VOLTAGE) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LLDRL_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Low-Byte Data Register Bits"]
# [inline (always)]
pub fn lldrl (& self) -> LLDRL_R { LLDRL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Low-Byte Data Register Bits"]
# [inline (always)]
# [must_use]
pub fn lldrl (& mut self) -> LLDRL_W < 0 > { LLDRL_W :: new (self) } # [doc = "Bits 4:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 4 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Low Leakage Voltage Regulator Data Register (Low-Byte)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lldrl](index.html) module"]
pub struct LLDRL_SPEC ; impl crate :: RegisterSpec for LLDRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lldrl::R](R) reader structure"]
impl crate :: Readable for LLDRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lldrl::W](W) writer structure"]
impl crate :: Writable for LLDRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LLDRL to value 0"]
impl crate :: Resettable for LLDRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCUCR (rw) register accessor: an alias for `Reg<MCUCR_SPEC>`"]
pub type MCUCR = crate :: Reg < mcucr :: MCUCR_SPEC > ; # [doc = "MCU Control Register"]
pub mod mcucr { # [doc = "Register `MCUCR` reader"]
pub struct R (crate :: R < MCUCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCUCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCUCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCUCR` writer"]
pub struct W (crate :: W < MCUCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCUCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCUCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PUD` reader - Pull-up Disable"]
pub type PUD_R = crate :: BitReader < bool > ; # [doc = "Field `PUD` writer - Pull-up Disable"]
pub type PUD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; impl R { # [doc = "Bit 4 - Pull-up Disable"]
# [inline (always)]
pub fn pud (& self) -> PUD_R { PUD_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 4 - Pull-up Disable"]
# [inline (always)]
# [must_use]
pub fn pud (& mut self) -> PUD_W < 4 > { PUD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCU Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcucr](index.html) module"]
pub struct MCUCR_SPEC ; impl crate :: RegisterSpec for MCUCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mcucr::R](R) reader structure"]
impl crate :: Readable for MCUCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mcucr::W](W) writer structure"]
impl crate :: Writable for MCUCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCUCR to value 0"]
impl crate :: Resettable for MCUCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRXPR (rw) register accessor: an alias for `Reg<TRXPR_SPEC>`"]
pub type TRXPR = crate :: Reg < trxpr :: TRXPR_SPEC > ; # [doc = "Transceiver Pin Register"]
pub mod trxpr { # [doc = "Register `TRXPR` reader"]
pub struct R (crate :: R < TRXPR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRXPR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRXPR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRXPR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRXPR` writer"]
pub struct W (crate :: W < TRXPR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRXPR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRXPR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRXPR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRXRST` reader - Force Transceiver Reset"]
pub type TRXRST_R = crate :: BitReader < bool > ; # [doc = "Field `TRXRST` writer - Force Transceiver Reset"]
pub type TRXRST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRXPR_SPEC , bool , O > ; # [doc = "Field `SLPTR` reader - Multi-purpose Transceiver Control Bit"]
pub type SLPTR_R = crate :: BitReader < bool > ; # [doc = "Field `SLPTR` writer - Multi-purpose Transceiver Control Bit"]
pub type SLPTR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRXPR_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TRXPR_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bit 0 - Force Transceiver Reset"]
# [inline (always)]
pub fn trxrst (& self) -> TRXRST_R { TRXRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-purpose Transceiver Control Bit"]
# [inline (always)]
pub fn slptr (& self) -> SLPTR_R { SLPTR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 4:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bit 0 - Force Transceiver Reset"]
# [inline (always)]
# [must_use]
pub fn trxrst (& mut self) -> TRXRST_W < 0 > { TRXRST_W :: new (self) } # [doc = "Bit 1 - Multi-purpose Transceiver Control Bit"]
# [inline (always)]
# [must_use]
pub fn slptr (& mut self) -> SLPTR_W < 1 > { SLPTR_W :: new (self) } # [doc = "Bits 4:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 4 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Pin Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trxpr](index.html) module"]
pub struct TRXPR_SPEC ; impl crate :: RegisterSpec for TRXPR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [trxpr::R](R) reader structure"]
impl crate :: Readable for TRXPR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [trxpr::W](W) writer structure"]
impl crate :: Writable for TRXPR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRXPR to value 0"]
impl crate :: Resettable for TRXPR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct SPI { _marker : PhantomData < * const () > } unsafe impl Send for SPI { } impl SPI { # [doc = r"Pointer to the register block"]
pub const PTR : * const spi :: RegisterBlock = 0x4c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spi :: RegisterBlock { Self :: PTR } } impl Deref for SPI { type Target = spi :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPI { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPI") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod spi { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - SPI Control Register"]
pub spcr : SPCR , # [doc = "0x01 - SPI Status Register"]
pub spsr : SPSR , # [doc = "0x02 - SPI Data Register"]
pub spdr : SPDR , } # [doc = "SPCR (rw) register accessor: an alias for `Reg<SPCR_SPEC>`"]
pub type SPCR = crate :: Reg < spcr :: SPCR_SPEC > ; # [doc = "SPI Control Register"]
pub mod spcr { # [doc = "Register `SPCR` reader"]
pub struct R (crate :: R < SPCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPCR` writer"]
pub struct W (crate :: W < SPCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPR` reader - SPI Clock Rate Select 1 and 0"]
pub type SPR_R = crate :: FieldReader < u8 , SPR_A > ; # [doc = "SPI Clock Rate Select 1 and 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SPR_A { # [doc = "0: fosc/4"]
FOSC_4 = 0 , # [doc = "1: fosc/16"]
FOSC_16 = 1 , # [doc = "3: fosc/128"]
FOSC_128 = 3 , } impl From < SPR_A > for u8 { # [inline (always)]
fn from (variant : SPR_A) -> Self { variant as _ } } impl SPR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SPR_A > { match self . bits { 0 => Some (SPR_A :: FOSC_4) , 1 => Some (SPR_A :: FOSC_16) , 3 => Some (SPR_A :: FOSC_128) , _ => None , } } # [doc = "Checks if the value of the field is `FOSC_4`"]
# [inline (always)]
pub fn is_fosc_4 (& self) -> bool { * self == SPR_A :: FOSC_4 } # [doc = "Checks if the value of the field is `FOSC_16`"]
# [inline (always)]
pub fn is_fosc_16 (& self) -> bool { * self == SPR_A :: FOSC_16 } # [doc = "Checks if the value of the field is `FOSC_128`"]
# [inline (always)]
pub fn is_fosc_128 (& self) -> bool { * self == SPR_A :: FOSC_128 } } # [doc = "Field `SPR` writer - SPI Clock Rate Select 1 and 0"]
pub type SPR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SPCR_SPEC , u8 , SPR_A , 2 , O > ; impl < 'a , const O : u8 > SPR_W < 'a , O > { # [doc = "fosc/4"]
# [inline (always)]
pub fn fosc_4 (self) -> & 'a mut W { self . variant (SPR_A :: FOSC_4) } # [doc = "fosc/16"]
# [inline (always)]
pub fn fosc_16 (self) -> & 'a mut W { self . variant (SPR_A :: FOSC_16) } # [doc = "fosc/128"]
# [inline (always)]
pub fn fosc_128 (self) -> & 'a mut W { self . variant (SPR_A :: FOSC_128) } } # [doc = "Field `CPHA` reader - Clock Phase"]
pub type CPHA_R = crate :: BitReader < CPHA_A > ; # [doc = "Clock Phase\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CPHA_A { # [doc = "0: Sample (Leading Edge), Setup (Trailing Edge)"]
SAMPLE_LEADING_EDGE_SETUP_TRAILING_EDGE = 0 , # [doc = "1: Setup (Leading Edge), Sample (Trailing Edge)"]
SETUP_LEADING_EDGE_SAMPLE_TRAILING_EDGE = 1 , } impl From < CPHA_A > for bool { # [inline (always)]
fn from (variant : CPHA_A) -> Self { variant as u8 != 0 } } impl CPHA_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CPHA_A { match self . bits { false => CPHA_A :: SAMPLE_LEADING_EDGE_SETUP_TRAILING_EDGE , true => CPHA_A :: SETUP_LEADING_EDGE_SAMPLE_TRAILING_EDGE , } } # [doc = "Checks if the value of the field is `SAMPLE_LEADING_EDGE_SETUP_TRAILING_EDGE`"]
# [inline (always)]
pub fn is_sample_leading_edge_setup_trailing_edge (& self) -> bool { * self == CPHA_A :: SAMPLE_LEADING_EDGE_SETUP_TRAILING_EDGE } # [doc = "Checks if the value of the field is `SETUP_LEADING_EDGE_SAMPLE_TRAILING_EDGE`"]
# [inline (always)]
pub fn is_setup_leading_edge_sample_trailing_edge (& self) -> bool { * self == CPHA_A :: SETUP_LEADING_EDGE_SAMPLE_TRAILING_EDGE } } # [doc = "Field `CPHA` writer - Clock Phase"]
pub type CPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , CPHA_A , O > ; impl < 'a , const O : u8 > CPHA_W < 'a , O > { # [doc = "Sample (Leading Edge), Setup (Trailing Edge)"]
# [inline (always)]
pub fn sample_leading_edge_setup_trailing_edge (self) -> & 'a mut W { self . variant (CPHA_A :: SAMPLE_LEADING_EDGE_SETUP_TRAILING_EDGE) } # [doc = "Setup (Leading Edge), Sample (Trailing Edge)"]
# [inline (always)]
pub fn setup_leading_edge_sample_trailing_edge (self) -> & 'a mut W { self . variant (CPHA_A :: SETUP_LEADING_EDGE_SAMPLE_TRAILING_EDGE) } } # [doc = "Field `CPOL` reader - Clock polarity"]
pub type CPOL_R = crate :: BitReader < CPOL_A > ; # [doc = "Clock polarity\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CPOL_A { # [doc = "0: Rising (Leading Edge), Falling (Trailing Edge)"]
RISING_LEADING_EDGE_FALLING_TRAILING_EDGE = 0 , # [doc = "1: Falling (Leading Egde), Rising (Trailing Edge)"]
FALLING_LEADING_EGDE_RISING_TRAILING_EDGE = 1 , } impl From < CPOL_A > for bool { # [inline (always)]
fn from (variant : CPOL_A) -> Self { variant as u8 != 0 } } impl CPOL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CPOL_A { match self . bits { false => CPOL_A :: RISING_LEADING_EDGE_FALLING_TRAILING_EDGE , true => CPOL_A :: FALLING_LEADING_EGDE_RISING_TRAILING_EDGE , } } # [doc = "Checks if the value of the field is `RISING_LEADING_EDGE_FALLING_TRAILING_EDGE`"]
# [inline (always)]
pub fn is_rising_leading_edge_falling_trailing_edge (& self) -> bool { * self == CPOL_A :: RISING_LEADING_EDGE_FALLING_TRAILING_EDGE } # [doc = "Checks if the value of the field is `FALLING_LEADING_EGDE_RISING_TRAILING_EDGE`"]
# [inline (always)]
pub fn is_falling_leading_egde_rising_trailing_edge (& self) -> bool { * self == CPOL_A :: FALLING_LEADING_EGDE_RISING_TRAILING_EDGE } } # [doc = "Field `CPOL` writer - Clock polarity"]
pub type CPOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , CPOL_A , O > ; impl < 'a , const O : u8 > CPOL_W < 'a , O > { # [doc = "Rising (Leading Edge), Falling (Trailing Edge)"]
# [inline (always)]
pub fn rising_leading_edge_falling_trailing_edge (self) -> & 'a mut W { self . variant (CPOL_A :: RISING_LEADING_EDGE_FALLING_TRAILING_EDGE) } # [doc = "Falling (Leading Egde), Rising (Trailing Edge)"]
# [inline (always)]
pub fn falling_leading_egde_rising_trailing_edge (self) -> & 'a mut W { self . variant (CPOL_A :: FALLING_LEADING_EGDE_RISING_TRAILING_EDGE) } } # [doc = "Field `MSTR` reader - Master/Slave Select"]
pub type MSTR_R = crate :: BitReader < bool > ; # [doc = "Field `MSTR` writer - Master/Slave Select"]
pub type MSTR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; # [doc = "Field `DORD` reader - Data Order"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order"]
pub type DORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; # [doc = "Field `SPE` reader - SPI Enable"]
pub type SPE_R = crate :: BitReader < bool > ; # [doc = "Field `SPE` writer - SPI Enable"]
pub type SPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; # [doc = "Field `SPIE` reader - SPI Interrupt Enable"]
pub type SPIE_R = crate :: BitReader < bool > ; # [doc = "Field `SPIE` writer - SPI Interrupt Enable"]
pub type SPIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - SPI Clock Rate Select 1 and 0"]
# [inline (always)]
pub fn spr (& self) -> SPR_R { SPR_R :: new (self . bits & 3) } # [doc = "Bit 2 - Clock Phase"]
# [inline (always)]
pub fn cpha (& self) -> CPHA_R { CPHA_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Clock polarity"]
# [inline (always)]
pub fn cpol (& self) -> CPOL_R { CPOL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Master/Slave Select"]
# [inline (always)]
pub fn mstr (& self) -> MSTR_R { MSTR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Order"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - SPI Enable"]
# [inline (always)]
pub fn spe (& self) -> SPE_R { SPE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - SPI Interrupt Enable"]
# [inline (always)]
pub fn spie (& self) -> SPIE_R { SPIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - SPI Clock Rate Select 1 and 0"]
# [inline (always)]
# [must_use]
pub fn spr (& mut self) -> SPR_W < 0 > { SPR_W :: new (self) } # [doc = "Bit 2 - Clock Phase"]
# [inline (always)]
# [must_use]
pub fn cpha (& mut self) -> CPHA_W < 2 > { CPHA_W :: new (self) } # [doc = "Bit 3 - Clock polarity"]
# [inline (always)]
# [must_use]
pub fn cpol (& mut self) -> CPOL_W < 3 > { CPOL_W :: new (self) } # [doc = "Bit 4 - Master/Slave Select"]
# [inline (always)]
# [must_use]
pub fn mstr (& mut self) -> MSTR_W < 4 > { MSTR_W :: new (self) } # [doc = "Bit 5 - Data Order"]
# [inline (always)]
# [must_use]
pub fn dord (& mut self) -> DORD_W < 5 > { DORD_W :: new (self) } # [doc = "Bit 6 - SPI Enable"]
# [inline (always)]
# [must_use]
pub fn spe (& mut self) -> SPE_W < 6 > { SPE_W :: new (self) } # [doc = "Bit 7 - SPI Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn spie (& mut self) -> SPIE_W < 7 > { SPIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spcr](index.html) module"]
pub struct SPCR_SPEC ; impl crate :: RegisterSpec for SPCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spcr::R](R) reader structure"]
impl crate :: Readable for SPCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spcr::W](W) writer structure"]
impl crate :: Writable for SPCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPCR to value 0"]
impl crate :: Resettable for SPCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPDR (rw) register accessor: an alias for `Reg<SPDR_SPEC>`"]
pub type SPDR = crate :: Reg < spdr :: SPDR_SPEC > ; # [doc = "SPI Data Register"]
pub mod spdr { # [doc = "Register `SPDR` reader"]
pub struct R (crate :: R < SPDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPDR` writer"]
pub struct W (crate :: W < SPDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "SPI Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spdr](index.html) module"]
pub struct SPDR_SPEC ; impl crate :: RegisterSpec for SPDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spdr::R](R) reader structure"]
impl crate :: Readable for SPDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spdr::W](W) writer structure"]
impl crate :: Writable for SPDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPDR to value 0"]
impl crate :: Resettable for SPDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPSR (rw) register accessor: an alias for `Reg<SPSR_SPEC>`"]
pub type SPSR = crate :: Reg < spsr :: SPSR_SPEC > ; # [doc = "SPI Status Register"]
pub mod spsr { # [doc = "Register `SPSR` reader"]
pub struct R (crate :: R < SPSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPSR` writer"]
pub struct W (crate :: W < SPSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPI2X` reader - Double SPI Speed Bit"]
pub type SPI2X_R = crate :: BitReader < bool > ; # [doc = "Field `SPI2X` writer - Double SPI Speed Bit"]
pub type SPI2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPSR_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SPSR_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `WCOL` reader - Write Collision Flag"]
pub type WCOL_R = crate :: BitReader < bool > ; # [doc = "Field `WCOL` writer - Write Collision Flag"]
pub type WCOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPSR_SPEC , bool , O > ; # [doc = "Field `SPIF` reader - SPI Interrupt Flag"]
pub type SPIF_R = crate :: BitReader < bool > ; # [doc = "Field `SPIF` writer - SPI Interrupt Flag"]
pub type SPIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPSR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Double SPI Speed Bit"]
# [inline (always)]
pub fn spi2x (& self) -> SPI2X_R { SPI2X_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:5 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 1) & 0x1f) } # [doc = "Bit 6 - Write Collision Flag"]
# [inline (always)]
pub fn wcol (& self) -> WCOL_R { WCOL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - SPI Interrupt Flag"]
# [inline (always)]
pub fn spif (& self) -> SPIF_R { SPIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Double SPI Speed Bit"]
# [inline (always)]
# [must_use]
pub fn spi2x (& mut self) -> SPI2X_W < 0 > { SPI2X_W :: new (self) } # [doc = "Bits 1:5 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 1 > { RES_W :: new (self) } # [doc = "Bit 6 - Write Collision Flag"]
# [inline (always)]
# [must_use]
pub fn wcol (& mut self) -> WCOL_W < 6 > { WCOL_W :: new (self) } # [doc = "Bit 7 - SPI Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn spif (& mut self) -> SPIF_W < 7 > { SPIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spsr](index.html) module"]
pub struct SPSR_SPEC ; impl crate :: RegisterSpec for SPSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spsr::R](R) reader structure"]
impl crate :: Readable for SPSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spsr::W](W) writer structure"]
impl crate :: Writable for SPSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPSR to value 0"]
impl crate :: Resettable for SPSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "MAC Symbol Counter"]
pub struct SYMCNT { _marker : PhantomData < * const () > } unsafe impl Send for SYMCNT { } impl SYMCNT { # [doc = r"Pointer to the register block"]
pub const PTR : * const symcnt :: RegisterBlock = 0xdc as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const symcnt :: RegisterBlock { Self :: PTR } } impl Deref for SYMCNT { type Target = symcnt :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SYMCNT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYMCNT") . finish () } } # [doc = "MAC Symbol Counter"]
pub mod symcnt { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Symbol Counter Control Register 0"]
pub sccr0 : SCCR0 , # [doc = "0x01 - Symbol Counter Control Register 1"]
pub sccr1 : SCCR1 , # [doc = "0x02 - Symbol Counter Status Register"]
pub scsr : SCSR , # [doc = "0x03 - Symbol Counter Interrupt Mask Register"]
pub scirqm : SCIRQM , # [doc = "0x04 - Symbol Counter Interrupt Status Register"]
pub scirqs : SCIRQS , # [doc = "0x05 - Symbol Counter Register LL-Byte"]
pub sccntll : SCCNTLL , # [doc = "0x06 - Symbol Counter Register LH-Byte"]
pub sccntlh : SCCNTLH , # [doc = "0x07 - Symbol Counter Register HL-Byte"]
pub sccnthl : SCCNTHL , # [doc = "0x08 - Symbol Counter Register HH-Byte"]
pub sccnthh : SCCNTHH , # [doc = "0x09 - Symbol Counter Beacon Timestamp Register LL-Byte"]
pub scbtsrll : SCBTSRLL , # [doc = "0x0a - Symbol Counter Beacon Timestamp Register LH-Byte"]
pub scbtsrlh : SCBTSRLH , # [doc = "0x0b - Symbol Counter Beacon Timestamp Register HL-Byte"]
pub scbtsrhl : SCBTSRHL , # [doc = "0x0c - Symbol Counter Beacon Timestamp Register HH-Byte"]
pub scbtsrhh : SCBTSRHH , # [doc = "0x0d - Symbol Counter Frame Timestamp Register LL-Byte"]
pub sctsrll : SCTSRLL , # [doc = "0x0e - Symbol Counter Frame Timestamp Register LH-Byte"]
pub sctsrlh : SCTSRLH , # [doc = "0x0f - Symbol Counter Frame Timestamp Register HL-Byte"]
pub sctsrhl : SCTSRHL , # [doc = "0x10 - Symbol Counter Frame Timestamp Register HH-Byte"]
pub sctsrhh : SCTSRHH , # [doc = "0x11 - Symbol Counter Output Compare Register 3 LL-Byte"]
pub scocr3ll : SCOCR3LL , # [doc = "0x12 - Symbol Counter Output Compare Register 3 LH-Byte"]
pub scocr3lh : SCOCR3LH , # [doc = "0x13 - Symbol Counter Output Compare Register 3 HL-Byte"]
pub scocr3hl : SCOCR3HL , # [doc = "0x14 - Symbol Counter Output Compare Register 3 HH-Byte"]
pub scocr3hh : SCOCR3HH , # [doc = "0x15 - Symbol Counter Output Compare Register 2 LL-Byte"]
pub scocr2ll : SCOCR2LL , # [doc = "0x16 - Symbol Counter Output Compare Register 2 LH-Byte"]
pub scocr2lh : SCOCR2LH , # [doc = "0x17 - Symbol Counter Output Compare Register 2 HL-Byte"]
pub scocr2hl : SCOCR2HL , # [doc = "0x18 - Symbol Counter Output Compare Register 2 HH-Byte"]
pub scocr2hh : SCOCR2HH , # [doc = "0x19 - Symbol Counter Output Compare Register 1 LL-Byte"]
pub scocr1ll : SCOCR1LL , # [doc = "0x1a - Symbol Counter Output Compare Register 1 LH-Byte"]
pub scocr1lh : SCOCR1LH , # [doc = "0x1b - Symbol Counter Output Compare Register 1 HL-Byte"]
pub scocr1hl : SCOCR1HL , # [doc = "0x1c - Symbol Counter Output Compare Register 1 HH-Byte"]
pub scocr1hh : SCOCR1HH , } # [doc = "SCBTSRHH (rw) register accessor: an alias for `Reg<SCBTSRHH_SPEC>`"]
pub type SCBTSRHH = crate :: Reg < scbtsrhh :: SCBTSRHH_SPEC > ; # [doc = "Symbol Counter Beacon Timestamp Register HH-Byte"]
pub mod scbtsrhh { # [doc = "Register `SCBTSRHH` reader"]
pub struct R (crate :: R < SCBTSRHH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCBTSRHH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCBTSRHH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCBTSRHH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCBTSRHH` writer"]
pub struct W (crate :: W < SCBTSRHH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCBTSRHH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCBTSRHH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCBTSRHH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCBTSRHH` reader - Symbol Counter Beacon Timestamp Register HH-Byte"]
pub type SCBTSRHH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCBTSRHH` writer - Symbol Counter Beacon Timestamp Register HH-Byte"]
pub type SCBTSRHH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCBTSRHH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Beacon Timestamp Register HH-Byte"]
# [inline (always)]
pub fn scbtsrhh (& self) -> SCBTSRHH_R { SCBTSRHH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Beacon Timestamp Register HH-Byte"]
# [inline (always)]
# [must_use]
pub fn scbtsrhh (& mut self) -> SCBTSRHH_W < 0 > { SCBTSRHH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Beacon Timestamp Register HH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scbtsrhh](index.html) module"]
pub struct SCBTSRHH_SPEC ; impl crate :: RegisterSpec for SCBTSRHH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scbtsrhh::R](R) reader structure"]
impl crate :: Readable for SCBTSRHH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scbtsrhh::W](W) writer structure"]
impl crate :: Writable for SCBTSRHH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCBTSRHH to value 0"]
impl crate :: Resettable for SCBTSRHH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCBTSRHL (rw) register accessor: an alias for `Reg<SCBTSRHL_SPEC>`"]
pub type SCBTSRHL = crate :: Reg < scbtsrhl :: SCBTSRHL_SPEC > ; # [doc = "Symbol Counter Beacon Timestamp Register HL-Byte"]
pub mod scbtsrhl { # [doc = "Register `SCBTSRHL` reader"]
pub struct R (crate :: R < SCBTSRHL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCBTSRHL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCBTSRHL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCBTSRHL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCBTSRHL` writer"]
pub struct W (crate :: W < SCBTSRHL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCBTSRHL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCBTSRHL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCBTSRHL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCBTSRHL` reader - Symbol Counter Beacon Timestamp Register HL-Byte"]
pub type SCBTSRHL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCBTSRHL` writer - Symbol Counter Beacon Timestamp Register HL-Byte"]
pub type SCBTSRHL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCBTSRHL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Beacon Timestamp Register HL-Byte"]
# [inline (always)]
pub fn scbtsrhl (& self) -> SCBTSRHL_R { SCBTSRHL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Beacon Timestamp Register HL-Byte"]
# [inline (always)]
# [must_use]
pub fn scbtsrhl (& mut self) -> SCBTSRHL_W < 0 > { SCBTSRHL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Beacon Timestamp Register HL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scbtsrhl](index.html) module"]
pub struct SCBTSRHL_SPEC ; impl crate :: RegisterSpec for SCBTSRHL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scbtsrhl::R](R) reader structure"]
impl crate :: Readable for SCBTSRHL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scbtsrhl::W](W) writer structure"]
impl crate :: Writable for SCBTSRHL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCBTSRHL to value 0"]
impl crate :: Resettable for SCBTSRHL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCBTSRLH (rw) register accessor: an alias for `Reg<SCBTSRLH_SPEC>`"]
pub type SCBTSRLH = crate :: Reg < scbtsrlh :: SCBTSRLH_SPEC > ; # [doc = "Symbol Counter Beacon Timestamp Register LH-Byte"]
pub mod scbtsrlh { # [doc = "Register `SCBTSRLH` reader"]
pub struct R (crate :: R < SCBTSRLH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCBTSRLH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCBTSRLH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCBTSRLH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCBTSRLH` writer"]
pub struct W (crate :: W < SCBTSRLH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCBTSRLH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCBTSRLH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCBTSRLH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCBTSRLH` reader - Symbol Counter Beacon Timestamp Register LH-Byte"]
pub type SCBTSRLH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCBTSRLH` writer - Symbol Counter Beacon Timestamp Register LH-Byte"]
pub type SCBTSRLH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCBTSRLH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Beacon Timestamp Register LH-Byte"]
# [inline (always)]
pub fn scbtsrlh (& self) -> SCBTSRLH_R { SCBTSRLH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Beacon Timestamp Register LH-Byte"]
# [inline (always)]
# [must_use]
pub fn scbtsrlh (& mut self) -> SCBTSRLH_W < 0 > { SCBTSRLH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Beacon Timestamp Register LH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scbtsrlh](index.html) module"]
pub struct SCBTSRLH_SPEC ; impl crate :: RegisterSpec for SCBTSRLH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scbtsrlh::R](R) reader structure"]
impl crate :: Readable for SCBTSRLH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scbtsrlh::W](W) writer structure"]
impl crate :: Writable for SCBTSRLH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCBTSRLH to value 0"]
impl crate :: Resettable for SCBTSRLH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCBTSRLL (rw) register accessor: an alias for `Reg<SCBTSRLL_SPEC>`"]
pub type SCBTSRLL = crate :: Reg < scbtsrll :: SCBTSRLL_SPEC > ; # [doc = "Symbol Counter Beacon Timestamp Register LL-Byte"]
pub mod scbtsrll { # [doc = "Register `SCBTSRLL` reader"]
pub struct R (crate :: R < SCBTSRLL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCBTSRLL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCBTSRLL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCBTSRLL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCBTSRLL` writer"]
pub struct W (crate :: W < SCBTSRLL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCBTSRLL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCBTSRLL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCBTSRLL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCBTSRLL` reader - Symbol Counter Beacon Timestamp Register LL-Byte"]
pub type SCBTSRLL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCBTSRLL` writer - Symbol Counter Beacon Timestamp Register LL-Byte"]
pub type SCBTSRLL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCBTSRLL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Beacon Timestamp Register LL-Byte"]
# [inline (always)]
pub fn scbtsrll (& self) -> SCBTSRLL_R { SCBTSRLL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Beacon Timestamp Register LL-Byte"]
# [inline (always)]
# [must_use]
pub fn scbtsrll (& mut self) -> SCBTSRLL_W < 0 > { SCBTSRLL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Beacon Timestamp Register LL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scbtsrll](index.html) module"]
pub struct SCBTSRLL_SPEC ; impl crate :: RegisterSpec for SCBTSRLL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scbtsrll::R](R) reader structure"]
impl crate :: Readable for SCBTSRLL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scbtsrll::W](W) writer structure"]
impl crate :: Writable for SCBTSRLL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCBTSRLL to value 0"]
impl crate :: Resettable for SCBTSRLL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCCNTHH (rw) register accessor: an alias for `Reg<SCCNTHH_SPEC>`"]
pub type SCCNTHH = crate :: Reg < sccnthh :: SCCNTHH_SPEC > ; # [doc = "Symbol Counter Register HH-Byte"]
pub mod sccnthh { # [doc = "Register `SCCNTHH` reader"]
pub struct R (crate :: R < SCCNTHH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCCNTHH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCCNTHH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCCNTHH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCCNTHH` writer"]
pub struct W (crate :: W < SCCNTHH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCCNTHH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCCNTHH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCCNTHH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCCNTHH` reader - Symbol Counter Register HH-Byte"]
pub type SCCNTHH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCCNTHH` writer - Symbol Counter Register HH-Byte"]
pub type SCCNTHH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCCNTHH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Register HH-Byte"]
# [inline (always)]
pub fn sccnthh (& self) -> SCCNTHH_R { SCCNTHH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Register HH-Byte"]
# [inline (always)]
# [must_use]
pub fn sccnthh (& mut self) -> SCCNTHH_W < 0 > { SCCNTHH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Register HH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sccnthh](index.html) module"]
pub struct SCCNTHH_SPEC ; impl crate :: RegisterSpec for SCCNTHH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sccnthh::R](R) reader structure"]
impl crate :: Readable for SCCNTHH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sccnthh::W](W) writer structure"]
impl crate :: Writable for SCCNTHH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCCNTHH to value 0"]
impl crate :: Resettable for SCCNTHH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCCNTHL (rw) register accessor: an alias for `Reg<SCCNTHL_SPEC>`"]
pub type SCCNTHL = crate :: Reg < sccnthl :: SCCNTHL_SPEC > ; # [doc = "Symbol Counter Register HL-Byte"]
pub mod sccnthl { # [doc = "Register `SCCNTHL` reader"]
pub struct R (crate :: R < SCCNTHL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCCNTHL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCCNTHL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCCNTHL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCCNTHL` writer"]
pub struct W (crate :: W < SCCNTHL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCCNTHL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCCNTHL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCCNTHL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCCNTHL` reader - Symbol Counter Register HL-Byte"]
pub type SCCNTHL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCCNTHL` writer - Symbol Counter Register HL-Byte"]
pub type SCCNTHL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCCNTHL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Register HL-Byte"]
# [inline (always)]
pub fn sccnthl (& self) -> SCCNTHL_R { SCCNTHL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Register HL-Byte"]
# [inline (always)]
# [must_use]
pub fn sccnthl (& mut self) -> SCCNTHL_W < 0 > { SCCNTHL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Register HL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sccnthl](index.html) module"]
pub struct SCCNTHL_SPEC ; impl crate :: RegisterSpec for SCCNTHL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sccnthl::R](R) reader structure"]
impl crate :: Readable for SCCNTHL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sccnthl::W](W) writer structure"]
impl crate :: Writable for SCCNTHL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCCNTHL to value 0"]
impl crate :: Resettable for SCCNTHL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCCNTLH (rw) register accessor: an alias for `Reg<SCCNTLH_SPEC>`"]
pub type SCCNTLH = crate :: Reg < sccntlh :: SCCNTLH_SPEC > ; # [doc = "Symbol Counter Register LH-Byte"]
pub mod sccntlh { # [doc = "Register `SCCNTLH` reader"]
pub struct R (crate :: R < SCCNTLH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCCNTLH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCCNTLH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCCNTLH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCCNTLH` writer"]
pub struct W (crate :: W < SCCNTLH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCCNTLH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCCNTLH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCCNTLH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCCNTLH` reader - Symbol Counter Register LH-Byte"]
pub type SCCNTLH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCCNTLH` writer - Symbol Counter Register LH-Byte"]
pub type SCCNTLH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCCNTLH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Register LH-Byte"]
# [inline (always)]
pub fn sccntlh (& self) -> SCCNTLH_R { SCCNTLH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Register LH-Byte"]
# [inline (always)]
# [must_use]
pub fn sccntlh (& mut self) -> SCCNTLH_W < 0 > { SCCNTLH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Register LH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sccntlh](index.html) module"]
pub struct SCCNTLH_SPEC ; impl crate :: RegisterSpec for SCCNTLH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sccntlh::R](R) reader structure"]
impl crate :: Readable for SCCNTLH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sccntlh::W](W) writer structure"]
impl crate :: Writable for SCCNTLH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCCNTLH to value 0"]
impl crate :: Resettable for SCCNTLH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCCNTLL (rw) register accessor: an alias for `Reg<SCCNTLL_SPEC>`"]
pub type SCCNTLL = crate :: Reg < sccntll :: SCCNTLL_SPEC > ; # [doc = "Symbol Counter Register LL-Byte"]
pub mod sccntll { # [doc = "Register `SCCNTLL` reader"]
pub struct R (crate :: R < SCCNTLL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCCNTLL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCCNTLL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCCNTLL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCCNTLL` writer"]
pub struct W (crate :: W < SCCNTLL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCCNTLL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCCNTLL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCCNTLL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCCNTLL` reader - Symbol Counter Register LL-Byte"]
pub type SCCNTLL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCCNTLL` writer - Symbol Counter Register LL-Byte"]
pub type SCCNTLL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCCNTLL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Register LL-Byte"]
# [inline (always)]
pub fn sccntll (& self) -> SCCNTLL_R { SCCNTLL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Register LL-Byte"]
# [inline (always)]
# [must_use]
pub fn sccntll (& mut self) -> SCCNTLL_W < 0 > { SCCNTLL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Register LL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sccntll](index.html) module"]
pub struct SCCNTLL_SPEC ; impl crate :: RegisterSpec for SCCNTLL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sccntll::R](R) reader structure"]
impl crate :: Readable for SCCNTLL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sccntll::W](W) writer structure"]
impl crate :: Writable for SCCNTLL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCCNTLL to value 0"]
impl crate :: Resettable for SCCNTLL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCCR0 (rw) register accessor: an alias for `Reg<SCCR0_SPEC>`"]
pub type SCCR0 = crate :: Reg < sccr0 :: SCCR0_SPEC > ; # [doc = "Symbol Counter Control Register 0"]
pub mod sccr0 { # [doc = "Register `SCCR0` reader"]
pub struct R (crate :: R < SCCR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCCR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCCR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCCR0` writer"]
pub struct W (crate :: W < SCCR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCCR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCCR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCCR0_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCCMP` reader - Symbol Counter Compare Unit 3 Mode select"]
pub type SCCMP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCCMP` writer - Symbol Counter Compare Unit 3 Mode select"]
pub type SCCMP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCCR0_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `SCTSE` reader - Symbol Counter Automatic Timestamping enable"]
pub type SCTSE_R = crate :: BitReader < bool > ; # [doc = "Field `SCTSE` writer - Symbol Counter Automatic Timestamping enable"]
pub type SCTSE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCCR0_SPEC , bool , O > ; # [doc = "Field `SCCKSEL` reader - Symbol Counter Clock Source select"]
pub type SCCKSEL_R = crate :: BitReader < bool > ; # [doc = "Field `SCCKSEL` writer - Symbol Counter Clock Source select"]
pub type SCCKSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCCR0_SPEC , bool , O > ; # [doc = "Field `SCEN` reader - Symbol Counter enable"]
pub type SCEN_R = crate :: BitReader < bool > ; # [doc = "Field `SCEN` writer - Symbol Counter enable"]
pub type SCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCCR0_SPEC , bool , O > ; # [doc = "Field `SCMBTS` reader - Manual Beacon Timestamp"]
pub type SCMBTS_R = crate :: BitReader < bool > ; # [doc = "Field `SCMBTS` writer - Manual Beacon Timestamp"]
pub type SCMBTS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCCR0_SPEC , bool , O > ; # [doc = "Field `SCRES` reader - Symbol Counter Synchronization"]
pub type SCRES_R = crate :: BitReader < bool > ; # [doc = "Field `SCRES` writer - Symbol Counter Synchronization"]
pub type SCRES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCCR0_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Symbol Counter Compare Unit 3 Mode select"]
# [inline (always)]
pub fn sccmp (& self) -> SCCMP_R { SCCMP_R :: new (self . bits & 7) } # [doc = "Bit 3 - Symbol Counter Automatic Timestamping enable"]
# [inline (always)]
pub fn sctse (& self) -> SCTSE_R { SCTSE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Symbol Counter Clock Source select"]
# [inline (always)]
pub fn sccksel (& self) -> SCCKSEL_R { SCCKSEL_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Symbol Counter enable"]
# [inline (always)]
pub fn scen (& self) -> SCEN_R { SCEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Manual Beacon Timestamp"]
# [inline (always)]
pub fn scmbts (& self) -> SCMBTS_R { SCMBTS_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Symbol Counter Synchronization"]
# [inline (always)]
pub fn scres (& self) -> SCRES_R { SCRES_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Symbol Counter Compare Unit 3 Mode select"]
# [inline (always)]
# [must_use]
pub fn sccmp (& mut self) -> SCCMP_W < 0 > { SCCMP_W :: new (self) } # [doc = "Bit 3 - Symbol Counter Automatic Timestamping enable"]
# [inline (always)]
# [must_use]
pub fn sctse (& mut self) -> SCTSE_W < 3 > { SCTSE_W :: new (self) } # [doc = "Bit 4 - Symbol Counter Clock Source select"]
# [inline (always)]
# [must_use]
pub fn sccksel (& mut self) -> SCCKSEL_W < 4 > { SCCKSEL_W :: new (self) } # [doc = "Bit 5 - Symbol Counter enable"]
# [inline (always)]
# [must_use]
pub fn scen (& mut self) -> SCEN_W < 5 > { SCEN_W :: new (self) } # [doc = "Bit 6 - Manual Beacon Timestamp"]
# [inline (always)]
# [must_use]
pub fn scmbts (& mut self) -> SCMBTS_W < 6 > { SCMBTS_W :: new (self) } # [doc = "Bit 7 - Symbol Counter Synchronization"]
# [inline (always)]
# [must_use]
pub fn scres (& mut self) -> SCRES_W < 7 > { SCRES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Symbol Counter Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sccr0](index.html) module"]
pub struct SCCR0_SPEC ; impl crate :: RegisterSpec for SCCR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sccr0::R](R) reader structure"]
impl crate :: Readable for SCCR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sccr0::W](W) writer structure"]
impl crate :: Writable for SCCR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCCR0 to value 0"]
impl crate :: Resettable for SCCR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCCR1 (rw) register accessor: an alias for `Reg<SCCR1_SPEC>`"]
pub type SCCR1 = crate :: Reg < sccr1 :: SCCR1_SPEC > ; # [doc = "Symbol Counter Control Register 1"]
pub mod sccr1 { # [doc = "Register `SCCR1` reader"]
pub struct R (crate :: R < SCCR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCCR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCCR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCCR1` writer"]
pub struct W (crate :: W < SCCR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCCR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCCR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCCR1_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCENBO` reader - Backoff Slot Counter enable"]
pub type SCENBO_R = crate :: BitReader < bool > ; # [doc = "Field `SCENBO` writer - Backoff Slot Counter enable"]
pub type SCENBO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCCR1_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCCR1_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bit 0 - Backoff Slot Counter enable"]
# [inline (always)]
pub fn scenbo (& self) -> SCENBO_R { SCENBO_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 1) & 0x7f) } } impl W { # [doc = "Bit 0 - Backoff Slot Counter enable"]
# [inline (always)]
# [must_use]
pub fn scenbo (& mut self) -> SCENBO_W < 0 > { SCENBO_W :: new (self) } # [doc = "Bits 1:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 1 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Symbol Counter Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sccr1](index.html) module"]
pub struct SCCR1_SPEC ; impl crate :: RegisterSpec for SCCR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sccr1::R](R) reader structure"]
impl crate :: Readable for SCCR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sccr1::W](W) writer structure"]
impl crate :: Writable for SCCR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCCR1 to value 0"]
impl crate :: Resettable for SCCR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCIRQM (rw) register accessor: an alias for `Reg<SCIRQM_SPEC>`"]
pub type SCIRQM = crate :: Reg < scirqm :: SCIRQM_SPEC > ; # [doc = "Symbol Counter Interrupt Mask Register"]
pub mod scirqm { # [doc = "Register `SCIRQM` reader"]
pub struct R (crate :: R < SCIRQM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCIRQM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCIRQM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCIRQM_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCIRQM` writer"]
pub struct W (crate :: W < SCIRQM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCIRQM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCIRQM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCIRQM_SPEC >) -> Self { W (writer) } } # [doc = "Field `IRQMCP` reader - Symbol Counter Compare Match 3 IRQ enable"]
pub type IRQMCP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IRQMCP` writer - Symbol Counter Compare Match 3 IRQ enable"]
pub type IRQMCP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCIRQM_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `IRQMOF` reader - Symbol Counter Overflow IRQ enable"]
pub type IRQMOF_R = crate :: BitReader < bool > ; # [doc = "Field `IRQMOF` writer - Symbol Counter Overflow IRQ enable"]
pub type IRQMOF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCIRQM_SPEC , bool , O > ; # [doc = "Field `IRQMBO` reader - Backoff Slot Counter IRQ enable"]
pub type IRQMBO_R = crate :: BitReader < bool > ; # [doc = "Field `IRQMBO` writer - Backoff Slot Counter IRQ enable"]
pub type IRQMBO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCIRQM_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCIRQM_SPEC , u8 , u8 , 3 , O > ; impl R { # [doc = "Bits 0:2 - Symbol Counter Compare Match 3 IRQ enable"]
# [inline (always)]
pub fn irqmcp (& self) -> IRQMCP_R { IRQMCP_R :: new (self . bits & 7) } # [doc = "Bit 3 - Symbol Counter Overflow IRQ enable"]
# [inline (always)]
pub fn irqmof (& self) -> IRQMOF_R { IRQMOF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Backoff Slot Counter IRQ enable"]
# [inline (always)]
pub fn irqmbo (& self) -> IRQMBO_R { IRQMBO_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:2 - Symbol Counter Compare Match 3 IRQ enable"]
# [inline (always)]
# [must_use]
pub fn irqmcp (& mut self) -> IRQMCP_W < 0 > { IRQMCP_W :: new (self) } # [doc = "Bit 3 - Symbol Counter Overflow IRQ enable"]
# [inline (always)]
# [must_use]
pub fn irqmof (& mut self) -> IRQMOF_W < 3 > { IRQMOF_W :: new (self) } # [doc = "Bit 4 - Backoff Slot Counter IRQ enable"]
# [inline (always)]
# [must_use]
pub fn irqmbo (& mut self) -> IRQMBO_W < 4 > { IRQMBO_W :: new (self) } # [doc = "Bits 5:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 5 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Symbol Counter Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scirqm](index.html) module"]
pub struct SCIRQM_SPEC ; impl crate :: RegisterSpec for SCIRQM_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scirqm::R](R) reader structure"]
impl crate :: Readable for SCIRQM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scirqm::W](W) writer structure"]
impl crate :: Writable for SCIRQM_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCIRQM to value 0"]
impl crate :: Resettable for SCIRQM_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCIRQS (rw) register accessor: an alias for `Reg<SCIRQS_SPEC>`"]
pub type SCIRQS = crate :: Reg < scirqs :: SCIRQS_SPEC > ; # [doc = "Symbol Counter Interrupt Status Register"]
pub mod scirqs { # [doc = "Register `SCIRQS` reader"]
pub struct R (crate :: R < SCIRQS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCIRQS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCIRQS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCIRQS_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCIRQS` writer"]
pub struct W (crate :: W < SCIRQS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCIRQS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCIRQS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCIRQS_SPEC >) -> Self { W (writer) } } # [doc = "Field `IRQSCP` reader - Compare Unit 3 Compare Match IRQ"]
pub type IRQSCP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IRQSCP` writer - Compare Unit 3 Compare Match IRQ"]
pub type IRQSCP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCIRQS_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `IRQSOF` reader - Symbol Counter Overflow IRQ"]
pub type IRQSOF_R = crate :: BitReader < bool > ; # [doc = "Field `IRQSOF` writer - Symbol Counter Overflow IRQ"]
pub type IRQSOF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCIRQS_SPEC , bool , O > ; # [doc = "Field `IRQSBO` reader - Backoff Slot Counter IRQ"]
pub type IRQSBO_R = crate :: BitReader < bool > ; # [doc = "Field `IRQSBO` writer - Backoff Slot Counter IRQ"]
pub type IRQSBO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCIRQS_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCIRQS_SPEC , u8 , u8 , 3 , O > ; impl R { # [doc = "Bits 0:2 - Compare Unit 3 Compare Match IRQ"]
# [inline (always)]
pub fn irqscp (& self) -> IRQSCP_R { IRQSCP_R :: new (self . bits & 7) } # [doc = "Bit 3 - Symbol Counter Overflow IRQ"]
# [inline (always)]
pub fn irqsof (& self) -> IRQSOF_R { IRQSOF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Backoff Slot Counter IRQ"]
# [inline (always)]
pub fn irqsbo (& self) -> IRQSBO_R { IRQSBO_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:2 - Compare Unit 3 Compare Match IRQ"]
# [inline (always)]
# [must_use]
pub fn irqscp (& mut self) -> IRQSCP_W < 0 > { IRQSCP_W :: new (self) } # [doc = "Bit 3 - Symbol Counter Overflow IRQ"]
# [inline (always)]
# [must_use]
pub fn irqsof (& mut self) -> IRQSOF_W < 3 > { IRQSOF_W :: new (self) } # [doc = "Bit 4 - Backoff Slot Counter IRQ"]
# [inline (always)]
# [must_use]
pub fn irqsbo (& mut self) -> IRQSBO_W < 4 > { IRQSBO_W :: new (self) } # [doc = "Bits 5:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 5 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Symbol Counter Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scirqs](index.html) module"]
pub struct SCIRQS_SPEC ; impl crate :: RegisterSpec for SCIRQS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scirqs::R](R) reader structure"]
impl crate :: Readable for SCIRQS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scirqs::W](W) writer structure"]
impl crate :: Writable for SCIRQS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCIRQS to value 0"]
impl crate :: Resettable for SCIRQS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR1HH (rw) register accessor: an alias for `Reg<SCOCR1HH_SPEC>`"]
pub type SCOCR1HH = crate :: Reg < scocr1hh :: SCOCR1HH_SPEC > ; # [doc = "Symbol Counter Output Compare Register 1 HH-Byte"]
pub mod scocr1hh { # [doc = "Register `SCOCR1HH` reader"]
pub struct R (crate :: R < SCOCR1HH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR1HH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR1HH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR1HH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR1HH` writer"]
pub struct W (crate :: W < SCOCR1HH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR1HH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR1HH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR1HH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR1HH` reader - Symbol Counter Output Compare Register 1 HH-Byte"]
pub type SCOCR1HH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR1HH` writer - Symbol Counter Output Compare Register 1 HH-Byte"]
pub type SCOCR1HH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR1HH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 1 HH-Byte"]
# [inline (always)]
pub fn scocr1hh (& self) -> SCOCR1HH_R { SCOCR1HH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 1 HH-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr1hh (& mut self) -> SCOCR1HH_W < 0 > { SCOCR1HH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 1 HH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr1hh](index.html) module"]
pub struct SCOCR1HH_SPEC ; impl crate :: RegisterSpec for SCOCR1HH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr1hh::R](R) reader structure"]
impl crate :: Readable for SCOCR1HH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr1hh::W](W) writer structure"]
impl crate :: Writable for SCOCR1HH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR1HH to value 0"]
impl crate :: Resettable for SCOCR1HH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR1HL (rw) register accessor: an alias for `Reg<SCOCR1HL_SPEC>`"]
pub type SCOCR1HL = crate :: Reg < scocr1hl :: SCOCR1HL_SPEC > ; # [doc = "Symbol Counter Output Compare Register 1 HL-Byte"]
pub mod scocr1hl { # [doc = "Register `SCOCR1HL` reader"]
pub struct R (crate :: R < SCOCR1HL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR1HL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR1HL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR1HL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR1HL` writer"]
pub struct W (crate :: W < SCOCR1HL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR1HL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR1HL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR1HL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR1HL` reader - Symbol Counter Output Compare Register 1 HL-Byte"]
pub type SCOCR1HL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR1HL` writer - Symbol Counter Output Compare Register 1 HL-Byte"]
pub type SCOCR1HL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR1HL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 1 HL-Byte"]
# [inline (always)]
pub fn scocr1hl (& self) -> SCOCR1HL_R { SCOCR1HL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 1 HL-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr1hl (& mut self) -> SCOCR1HL_W < 0 > { SCOCR1HL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 1 HL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr1hl](index.html) module"]
pub struct SCOCR1HL_SPEC ; impl crate :: RegisterSpec for SCOCR1HL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr1hl::R](R) reader structure"]
impl crate :: Readable for SCOCR1HL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr1hl::W](W) writer structure"]
impl crate :: Writable for SCOCR1HL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR1HL to value 0"]
impl crate :: Resettable for SCOCR1HL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR1LH (rw) register accessor: an alias for `Reg<SCOCR1LH_SPEC>`"]
pub type SCOCR1LH = crate :: Reg < scocr1lh :: SCOCR1LH_SPEC > ; # [doc = "Symbol Counter Output Compare Register 1 LH-Byte"]
pub mod scocr1lh { # [doc = "Register `SCOCR1LH` reader"]
pub struct R (crate :: R < SCOCR1LH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR1LH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR1LH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR1LH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR1LH` writer"]
pub struct W (crate :: W < SCOCR1LH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR1LH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR1LH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR1LH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR1LH` reader - Symbol Counter Output Compare Register 1 LH-Byte"]
pub type SCOCR1LH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR1LH` writer - Symbol Counter Output Compare Register 1 LH-Byte"]
pub type SCOCR1LH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR1LH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 1 LH-Byte"]
# [inline (always)]
pub fn scocr1lh (& self) -> SCOCR1LH_R { SCOCR1LH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 1 LH-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr1lh (& mut self) -> SCOCR1LH_W < 0 > { SCOCR1LH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 1 LH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr1lh](index.html) module"]
pub struct SCOCR1LH_SPEC ; impl crate :: RegisterSpec for SCOCR1LH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr1lh::R](R) reader structure"]
impl crate :: Readable for SCOCR1LH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr1lh::W](W) writer structure"]
impl crate :: Writable for SCOCR1LH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR1LH to value 0"]
impl crate :: Resettable for SCOCR1LH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR1LL (rw) register accessor: an alias for `Reg<SCOCR1LL_SPEC>`"]
pub type SCOCR1LL = crate :: Reg < scocr1ll :: SCOCR1LL_SPEC > ; # [doc = "Symbol Counter Output Compare Register 1 LL-Byte"]
pub mod scocr1ll { # [doc = "Register `SCOCR1LL` reader"]
pub struct R (crate :: R < SCOCR1LL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR1LL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR1LL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR1LL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR1LL` writer"]
pub struct W (crate :: W < SCOCR1LL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR1LL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR1LL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR1LL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR1LL` reader - Symbol Counter Output Compare Register 1 LL-Byte"]
pub type SCOCR1LL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR1LL` writer - Symbol Counter Output Compare Register 1 LL-Byte"]
pub type SCOCR1LL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR1LL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 1 LL-Byte"]
# [inline (always)]
pub fn scocr1ll (& self) -> SCOCR1LL_R { SCOCR1LL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 1 LL-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr1ll (& mut self) -> SCOCR1LL_W < 0 > { SCOCR1LL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 1 LL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr1ll](index.html) module"]
pub struct SCOCR1LL_SPEC ; impl crate :: RegisterSpec for SCOCR1LL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr1ll::R](R) reader structure"]
impl crate :: Readable for SCOCR1LL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr1ll::W](W) writer structure"]
impl crate :: Writable for SCOCR1LL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR1LL to value 0"]
impl crate :: Resettable for SCOCR1LL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR2HH (rw) register accessor: an alias for `Reg<SCOCR2HH_SPEC>`"]
pub type SCOCR2HH = crate :: Reg < scocr2hh :: SCOCR2HH_SPEC > ; # [doc = "Symbol Counter Output Compare Register 2 HH-Byte"]
pub mod scocr2hh { # [doc = "Register `SCOCR2HH` reader"]
pub struct R (crate :: R < SCOCR2HH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR2HH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR2HH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR2HH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR2HH` writer"]
pub struct W (crate :: W < SCOCR2HH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR2HH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR2HH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR2HH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR2HH` reader - Symbol Counter Output Compare Register 2 HH-Byte"]
pub type SCOCR2HH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR2HH` writer - Symbol Counter Output Compare Register 2 HH-Byte"]
pub type SCOCR2HH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR2HH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 2 HH-Byte"]
# [inline (always)]
pub fn scocr2hh (& self) -> SCOCR2HH_R { SCOCR2HH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 2 HH-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr2hh (& mut self) -> SCOCR2HH_W < 0 > { SCOCR2HH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 2 HH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr2hh](index.html) module"]
pub struct SCOCR2HH_SPEC ; impl crate :: RegisterSpec for SCOCR2HH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr2hh::R](R) reader structure"]
impl crate :: Readable for SCOCR2HH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr2hh::W](W) writer structure"]
impl crate :: Writable for SCOCR2HH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR2HH to value 0"]
impl crate :: Resettable for SCOCR2HH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR2HL (rw) register accessor: an alias for `Reg<SCOCR2HL_SPEC>`"]
pub type SCOCR2HL = crate :: Reg < scocr2hl :: SCOCR2HL_SPEC > ; # [doc = "Symbol Counter Output Compare Register 2 HL-Byte"]
pub mod scocr2hl { # [doc = "Register `SCOCR2HL` reader"]
pub struct R (crate :: R < SCOCR2HL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR2HL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR2HL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR2HL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR2HL` writer"]
pub struct W (crate :: W < SCOCR2HL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR2HL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR2HL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR2HL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR2HL` reader - Symbol Counter Output Compare Register 2 HL-Byte"]
pub type SCOCR2HL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR2HL` writer - Symbol Counter Output Compare Register 2 HL-Byte"]
pub type SCOCR2HL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR2HL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 2 HL-Byte"]
# [inline (always)]
pub fn scocr2hl (& self) -> SCOCR2HL_R { SCOCR2HL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 2 HL-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr2hl (& mut self) -> SCOCR2HL_W < 0 > { SCOCR2HL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 2 HL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr2hl](index.html) module"]
pub struct SCOCR2HL_SPEC ; impl crate :: RegisterSpec for SCOCR2HL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr2hl::R](R) reader structure"]
impl crate :: Readable for SCOCR2HL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr2hl::W](W) writer structure"]
impl crate :: Writable for SCOCR2HL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR2HL to value 0"]
impl crate :: Resettable for SCOCR2HL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR2LH (rw) register accessor: an alias for `Reg<SCOCR2LH_SPEC>`"]
pub type SCOCR2LH = crate :: Reg < scocr2lh :: SCOCR2LH_SPEC > ; # [doc = "Symbol Counter Output Compare Register 2 LH-Byte"]
pub mod scocr2lh { # [doc = "Register `SCOCR2LH` reader"]
pub struct R (crate :: R < SCOCR2LH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR2LH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR2LH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR2LH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR2LH` writer"]
pub struct W (crate :: W < SCOCR2LH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR2LH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR2LH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR2LH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR2LH` reader - Symbol Counter Output Compare Register 2 LH-Byte"]
pub type SCOCR2LH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR2LH` writer - Symbol Counter Output Compare Register 2 LH-Byte"]
pub type SCOCR2LH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR2LH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 2 LH-Byte"]
# [inline (always)]
pub fn scocr2lh (& self) -> SCOCR2LH_R { SCOCR2LH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 2 LH-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr2lh (& mut self) -> SCOCR2LH_W < 0 > { SCOCR2LH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 2 LH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr2lh](index.html) module"]
pub struct SCOCR2LH_SPEC ; impl crate :: RegisterSpec for SCOCR2LH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr2lh::R](R) reader structure"]
impl crate :: Readable for SCOCR2LH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr2lh::W](W) writer structure"]
impl crate :: Writable for SCOCR2LH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR2LH to value 0"]
impl crate :: Resettable for SCOCR2LH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR2LL (rw) register accessor: an alias for `Reg<SCOCR2LL_SPEC>`"]
pub type SCOCR2LL = crate :: Reg < scocr2ll :: SCOCR2LL_SPEC > ; # [doc = "Symbol Counter Output Compare Register 2 LL-Byte"]
pub mod scocr2ll { # [doc = "Register `SCOCR2LL` reader"]
pub struct R (crate :: R < SCOCR2LL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR2LL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR2LL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR2LL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR2LL` writer"]
pub struct W (crate :: W < SCOCR2LL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR2LL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR2LL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR2LL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR2LL` reader - Symbol Counter Output Compare Register 2 LL-Byte"]
pub type SCOCR2LL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR2LL` writer - Symbol Counter Output Compare Register 2 LL-Byte"]
pub type SCOCR2LL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR2LL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 2 LL-Byte"]
# [inline (always)]
pub fn scocr2ll (& self) -> SCOCR2LL_R { SCOCR2LL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 2 LL-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr2ll (& mut self) -> SCOCR2LL_W < 0 > { SCOCR2LL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 2 LL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr2ll](index.html) module"]
pub struct SCOCR2LL_SPEC ; impl crate :: RegisterSpec for SCOCR2LL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr2ll::R](R) reader structure"]
impl crate :: Readable for SCOCR2LL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr2ll::W](W) writer structure"]
impl crate :: Writable for SCOCR2LL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR2LL to value 0"]
impl crate :: Resettable for SCOCR2LL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR3HH (rw) register accessor: an alias for `Reg<SCOCR3HH_SPEC>`"]
pub type SCOCR3HH = crate :: Reg < scocr3hh :: SCOCR3HH_SPEC > ; # [doc = "Symbol Counter Output Compare Register 3 HH-Byte"]
pub mod scocr3hh { # [doc = "Register `SCOCR3HH` reader"]
pub struct R (crate :: R < SCOCR3HH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR3HH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR3HH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR3HH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR3HH` writer"]
pub struct W (crate :: W < SCOCR3HH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR3HH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR3HH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR3HH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR3HH` reader - Symbol Counter Output Compare Register 3 HH-Byte"]
pub type SCOCR3HH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR3HH` writer - Symbol Counter Output Compare Register 3 HH-Byte"]
pub type SCOCR3HH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR3HH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 3 HH-Byte"]
# [inline (always)]
pub fn scocr3hh (& self) -> SCOCR3HH_R { SCOCR3HH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 3 HH-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr3hh (& mut self) -> SCOCR3HH_W < 0 > { SCOCR3HH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 3 HH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr3hh](index.html) module"]
pub struct SCOCR3HH_SPEC ; impl crate :: RegisterSpec for SCOCR3HH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr3hh::R](R) reader structure"]
impl crate :: Readable for SCOCR3HH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr3hh::W](W) writer structure"]
impl crate :: Writable for SCOCR3HH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR3HH to value 0"]
impl crate :: Resettable for SCOCR3HH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR3HL (rw) register accessor: an alias for `Reg<SCOCR3HL_SPEC>`"]
pub type SCOCR3HL = crate :: Reg < scocr3hl :: SCOCR3HL_SPEC > ; # [doc = "Symbol Counter Output Compare Register 3 HL-Byte"]
pub mod scocr3hl { # [doc = "Register `SCOCR3HL` reader"]
pub struct R (crate :: R < SCOCR3HL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR3HL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR3HL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR3HL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR3HL` writer"]
pub struct W (crate :: W < SCOCR3HL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR3HL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR3HL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR3HL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR3HL` reader - Symbol Counter Output Compare Register 3 HL-Byte"]
pub type SCOCR3HL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR3HL` writer - Symbol Counter Output Compare Register 3 HL-Byte"]
pub type SCOCR3HL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR3HL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 3 HL-Byte"]
# [inline (always)]
pub fn scocr3hl (& self) -> SCOCR3HL_R { SCOCR3HL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 3 HL-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr3hl (& mut self) -> SCOCR3HL_W < 0 > { SCOCR3HL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 3 HL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr3hl](index.html) module"]
pub struct SCOCR3HL_SPEC ; impl crate :: RegisterSpec for SCOCR3HL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr3hl::R](R) reader structure"]
impl crate :: Readable for SCOCR3HL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr3hl::W](W) writer structure"]
impl crate :: Writable for SCOCR3HL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR3HL to value 0"]
impl crate :: Resettable for SCOCR3HL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR3LH (rw) register accessor: an alias for `Reg<SCOCR3LH_SPEC>`"]
pub type SCOCR3LH = crate :: Reg < scocr3lh :: SCOCR3LH_SPEC > ; # [doc = "Symbol Counter Output Compare Register 3 LH-Byte"]
pub mod scocr3lh { # [doc = "Register `SCOCR3LH` reader"]
pub struct R (crate :: R < SCOCR3LH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR3LH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR3LH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR3LH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR3LH` writer"]
pub struct W (crate :: W < SCOCR3LH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR3LH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR3LH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR3LH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR3LH` reader - Symbol Counter Output Compare Register 3 LH-Byte"]
pub type SCOCR3LH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR3LH` writer - Symbol Counter Output Compare Register 3 LH-Byte"]
pub type SCOCR3LH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR3LH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 3 LH-Byte"]
# [inline (always)]
pub fn scocr3lh (& self) -> SCOCR3LH_R { SCOCR3LH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 3 LH-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr3lh (& mut self) -> SCOCR3LH_W < 0 > { SCOCR3LH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 3 LH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr3lh](index.html) module"]
pub struct SCOCR3LH_SPEC ; impl crate :: RegisterSpec for SCOCR3LH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr3lh::R](R) reader structure"]
impl crate :: Readable for SCOCR3LH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr3lh::W](W) writer structure"]
impl crate :: Writable for SCOCR3LH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR3LH to value 0"]
impl crate :: Resettable for SCOCR3LH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCOCR3LL (rw) register accessor: an alias for `Reg<SCOCR3LL_SPEC>`"]
pub type SCOCR3LL = crate :: Reg < scocr3ll :: SCOCR3LL_SPEC > ; # [doc = "Symbol Counter Output Compare Register 3 LL-Byte"]
pub mod scocr3ll { # [doc = "Register `SCOCR3LL` reader"]
pub struct R (crate :: R < SCOCR3LL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCOCR3LL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCOCR3LL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCOCR3LL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCOCR3LL` writer"]
pub struct W (crate :: W < SCOCR3LL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCOCR3LL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCOCR3LL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCOCR3LL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCOCR3LL` reader - Symbol Counter Output Compare Register 3 LL-Byte"]
pub type SCOCR3LL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCOCR3LL` writer - Symbol Counter Output Compare Register 3 LL-Byte"]
pub type SCOCR3LL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCOCR3LL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 3 LL-Byte"]
# [inline (always)]
pub fn scocr3ll (& self) -> SCOCR3LL_R { SCOCR3LL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Output Compare Register 3 LL-Byte"]
# [inline (always)]
# [must_use]
pub fn scocr3ll (& mut self) -> SCOCR3LL_W < 0 > { SCOCR3LL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Output Compare Register 3 LL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scocr3ll](index.html) module"]
pub struct SCOCR3LL_SPEC ; impl crate :: RegisterSpec for SCOCR3LL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scocr3ll::R](R) reader structure"]
impl crate :: Readable for SCOCR3LL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scocr3ll::W](W) writer structure"]
impl crate :: Writable for SCOCR3LL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCOCR3LL to value 0"]
impl crate :: Resettable for SCOCR3LL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCSR (rw) register accessor: an alias for `Reg<SCSR_SPEC>`"]
pub type SCSR = crate :: Reg < scsr :: SCSR_SPEC > ; # [doc = "Symbol Counter Status Register"]
pub mod scsr { # [doc = "Register `SCSR` reader"]
pub struct R (crate :: R < SCSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCSR` writer"]
pub struct W (crate :: W < SCSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCBSY` reader - Symbol Counter busy"]
pub type SCBSY_R = crate :: BitReader < bool > ; # [doc = "Field `SCBSY` writer - Symbol Counter busy"]
pub type SCBSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCSR_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCSR_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bit 0 - Symbol Counter busy"]
# [inline (always)]
pub fn scbsy (& self) -> SCBSY_R { SCBSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 1) & 0x7f) } } impl W { # [doc = "Bit 0 - Symbol Counter busy"]
# [inline (always)]
# [must_use]
pub fn scbsy (& mut self) -> SCBSY_W < 0 > { SCBSY_W :: new (self) } # [doc = "Bits 1:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 1 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Symbol Counter Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scsr](index.html) module"]
pub struct SCSR_SPEC ; impl crate :: RegisterSpec for SCSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scsr::R](R) reader structure"]
impl crate :: Readable for SCSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scsr::W](W) writer structure"]
impl crate :: Writable for SCSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCSR to value 0"]
impl crate :: Resettable for SCSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCTSRHH (rw) register accessor: an alias for `Reg<SCTSRHH_SPEC>`"]
pub type SCTSRHH = crate :: Reg < sctsrhh :: SCTSRHH_SPEC > ; # [doc = "Symbol Counter Frame Timestamp Register HH-Byte"]
pub mod sctsrhh { # [doc = "Register `SCTSRHH` reader"]
pub struct R (crate :: R < SCTSRHH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCTSRHH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCTSRHH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCTSRHH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCTSRHH` writer"]
pub struct W (crate :: W < SCTSRHH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCTSRHH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCTSRHH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCTSRHH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCTSRHH` reader - Symbol Counter Frame Timestamp Register HH-Byte"]
pub type SCTSRHH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCTSRHH` writer - Symbol Counter Frame Timestamp Register HH-Byte"]
pub type SCTSRHH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCTSRHH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Frame Timestamp Register HH-Byte"]
# [inline (always)]
pub fn sctsrhh (& self) -> SCTSRHH_R { SCTSRHH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Frame Timestamp Register HH-Byte"]
# [inline (always)]
# [must_use]
pub fn sctsrhh (& mut self) -> SCTSRHH_W < 0 > { SCTSRHH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Frame Timestamp Register HH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sctsrhh](index.html) module"]
pub struct SCTSRHH_SPEC ; impl crate :: RegisterSpec for SCTSRHH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sctsrhh::R](R) reader structure"]
impl crate :: Readable for SCTSRHH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sctsrhh::W](W) writer structure"]
impl crate :: Writable for SCTSRHH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTSRHH to value 0"]
impl crate :: Resettable for SCTSRHH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCTSRHL (rw) register accessor: an alias for `Reg<SCTSRHL_SPEC>`"]
pub type SCTSRHL = crate :: Reg < sctsrhl :: SCTSRHL_SPEC > ; # [doc = "Symbol Counter Frame Timestamp Register HL-Byte"]
pub mod sctsrhl { # [doc = "Register `SCTSRHL` reader"]
pub struct R (crate :: R < SCTSRHL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCTSRHL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCTSRHL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCTSRHL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCTSRHL` writer"]
pub struct W (crate :: W < SCTSRHL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCTSRHL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCTSRHL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCTSRHL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCTSRHL` reader - Symbol Counter Frame Timestamp Register HL-Byte"]
pub type SCTSRHL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCTSRHL` writer - Symbol Counter Frame Timestamp Register HL-Byte"]
pub type SCTSRHL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCTSRHL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Frame Timestamp Register HL-Byte"]
# [inline (always)]
pub fn sctsrhl (& self) -> SCTSRHL_R { SCTSRHL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Frame Timestamp Register HL-Byte"]
# [inline (always)]
# [must_use]
pub fn sctsrhl (& mut self) -> SCTSRHL_W < 0 > { SCTSRHL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Frame Timestamp Register HL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sctsrhl](index.html) module"]
pub struct SCTSRHL_SPEC ; impl crate :: RegisterSpec for SCTSRHL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sctsrhl::R](R) reader structure"]
impl crate :: Readable for SCTSRHL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sctsrhl::W](W) writer structure"]
impl crate :: Writable for SCTSRHL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTSRHL to value 0"]
impl crate :: Resettable for SCTSRHL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCTSRLH (rw) register accessor: an alias for `Reg<SCTSRLH_SPEC>`"]
pub type SCTSRLH = crate :: Reg < sctsrlh :: SCTSRLH_SPEC > ; # [doc = "Symbol Counter Frame Timestamp Register LH-Byte"]
pub mod sctsrlh { # [doc = "Register `SCTSRLH` reader"]
pub struct R (crate :: R < SCTSRLH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCTSRLH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCTSRLH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCTSRLH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCTSRLH` writer"]
pub struct W (crate :: W < SCTSRLH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCTSRLH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCTSRLH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCTSRLH_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCTSRLH` reader - Symbol Counter Frame Timestamp Register LH-Byte"]
pub type SCTSRLH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCTSRLH` writer - Symbol Counter Frame Timestamp Register LH-Byte"]
pub type SCTSRLH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCTSRLH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Frame Timestamp Register LH-Byte"]
# [inline (always)]
pub fn sctsrlh (& self) -> SCTSRLH_R { SCTSRLH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Frame Timestamp Register LH-Byte"]
# [inline (always)]
# [must_use]
pub fn sctsrlh (& mut self) -> SCTSRLH_W < 0 > { SCTSRLH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Frame Timestamp Register LH-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sctsrlh](index.html) module"]
pub struct SCTSRLH_SPEC ; impl crate :: RegisterSpec for SCTSRLH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sctsrlh::R](R) reader structure"]
impl crate :: Readable for SCTSRLH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sctsrlh::W](W) writer structure"]
impl crate :: Writable for SCTSRLH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTSRLH to value 0"]
impl crate :: Resettable for SCTSRLH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCTSRLL (rw) register accessor: an alias for `Reg<SCTSRLL_SPEC>`"]
pub type SCTSRLL = crate :: Reg < sctsrll :: SCTSRLL_SPEC > ; # [doc = "Symbol Counter Frame Timestamp Register LL-Byte"]
pub mod sctsrll { # [doc = "Register `SCTSRLL` reader"]
pub struct R (crate :: R < SCTSRLL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCTSRLL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCTSRLL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCTSRLL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCTSRLL` writer"]
pub struct W (crate :: W < SCTSRLL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCTSRLL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCTSRLL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCTSRLL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCTSRLL` reader - Symbol Counter Frame Timestamp Register LL-Byte"]
pub type SCTSRLL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCTSRLL` writer - Symbol Counter Frame Timestamp Register LL-Byte"]
pub type SCTSRLL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SCTSRLL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Symbol Counter Frame Timestamp Register LL-Byte"]
# [inline (always)]
pub fn sctsrll (& self) -> SCTSRLL_R { SCTSRLL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Symbol Counter Frame Timestamp Register LL-Byte"]
# [inline (always)]
# [must_use]
pub fn sctsrll (& mut self) -> SCTSRLL_W < 0 > { SCTSRLL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Symbol Counter Frame Timestamp Register LL-Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sctsrll](index.html) module"]
pub struct SCTSRLL_SPEC ; impl crate :: RegisterSpec for SCTSRLL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sctsrll::R](R) reader structure"]
impl crate :: Readable for SCTSRLL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sctsrll::W](W) writer structure"]
impl crate :: Writable for SCTSRLL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTSRLL to value 0"]
impl crate :: Resettable for SCTSRLL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 8-bit"]
pub struct TC0 { _marker : PhantomData < * const () > } unsafe impl Send for TC0 { } impl TC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc0 :: RegisterBlock = 0x35 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc0 :: RegisterBlock { Self :: PTR } } impl Deref for TC0 { type Target = tc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC0") . finish () } } # [doc = "Timer/Counter, 8-bit"]
pub mod tc0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter0 Interrupt Flag Register"]
pub tifr0 : TIFR0 , _reserved1 : [u8 ; 0x0d]
, # [doc = "0x0e - General Timer/Counter Control Register"]
pub gtccr : GTCCR , # [doc = "0x0f - Timer/Counter0 Control Register A"]
pub tccr0a : TCCR0A , # [doc = "0x10 - Timer/Counter0 Control Register B"]
pub tccr0b : TCCR0B , # [doc = "0x11 - Timer/Counter0 Register"]
pub tcnt0 : TCNT0 , # [doc = "0x12 - Timer/Counter0 Output Compare Register"]
pub ocr0a : OCR0A , # [doc = "0x13 - Timer/Counter0 Output Compare Register B"]
pub ocr0b : OCR0B , _reserved7 : [u8 ; 0x25]
, # [doc = "0x39 - Timer/Counter0 Interrupt Mask Register"]
pub timsk0 : TIMSK0 , } # [doc = "GTCCR (rw) register accessor: an alias for `Reg<GTCCR_SPEC>`"]
pub type GTCCR = crate :: Reg < gtccr :: GTCCR_SPEC > ; # [doc = "General Timer/Counter Control Register"]
pub mod gtccr { # [doc = "Register `GTCCR` reader"]
pub struct R (crate :: R < GTCCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GTCCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GTCCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `GTCCR` writer"]
pub struct W (crate :: W < GTCCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GTCCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GTCCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PSRSYNC` reader - Prescaler Reset for Synchronous Timer/Counters"]
pub type PSRSYNC_R = crate :: BitReader < bool > ; # [doc = "Field `PSRSYNC` writer - Prescaler Reset for Synchronous Timer/Counters"]
pub type PSRSYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; # [doc = "Field `PSRASY` reader - Prescaler Reset Timer/Counter2"]
pub type PSRASY_R = crate :: BitReader < bool > ; # [doc = "Field `PSRASY` writer - Prescaler Reset Timer/Counter2"]
pub type PSRASY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , GTCCR_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `TSM` reader - Timer/Counter Synchronization Mode"]
pub type TSM_R = crate :: BitReader < bool > ; # [doc = "Field `TSM` writer - Timer/Counter Synchronization Mode"]
pub type TSM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Prescaler Reset for Synchronous Timer/Counters"]
# [inline (always)]
pub fn psrsync (& self) -> PSRSYNC_R { PSRSYNC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Prescaler Reset Timer/Counter2"]
# [inline (always)]
pub fn psrasy (& self) -> PSRASY_R { PSRASY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:6 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 2) & 0x1f) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
pub fn tsm (& self) -> TSM_R { TSM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Prescaler Reset for Synchronous Timer/Counters"]
# [inline (always)]
# [must_use]
pub fn psrsync (& mut self) -> PSRSYNC_W < 0 > { PSRSYNC_W :: new (self) } # [doc = "Bit 1 - Prescaler Reset Timer/Counter2"]
# [inline (always)]
# [must_use]
pub fn psrasy (& mut self) -> PSRASY_W < 1 > { PSRASY_W :: new (self) } # [doc = "Bits 2:6 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 2 > { RES_W :: new (self) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
# [must_use]
pub fn tsm (& mut self) -> TSM_W < 7 > { TSM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Timer/Counter Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gtccr](index.html) module"]
pub struct GTCCR_SPEC ; impl crate :: RegisterSpec for GTCCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gtccr::R](R) reader structure"]
impl crate :: Readable for GTCCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gtccr::W](W) writer structure"]
impl crate :: Writable for GTCCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GTCCR to value 0"]
impl crate :: Resettable for GTCCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR0A (rw) register accessor: an alias for `Reg<OCR0A_SPEC>`"]
pub type OCR0A = crate :: Reg < ocr0a :: OCR0A_SPEC > ; # [doc = "Timer/Counter0 Output Compare Register"]
pub mod ocr0a { # [doc = "Register `OCR0A` reader"]
pub struct R (crate :: R < OCR0A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR0A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR0A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR0A` writer"]
pub struct W (crate :: W < OCR0A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR0A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR0A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter0 Output Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr0a](index.html) module"]
pub struct OCR0A_SPEC ; impl crate :: RegisterSpec for OCR0A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocr0a::R](R) reader structure"]
impl crate :: Readable for OCR0A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr0a::W](W) writer structure"]
impl crate :: Writable for OCR0A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR0A to value 0"]
impl crate :: Resettable for OCR0A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR0B (rw) register accessor: an alias for `Reg<OCR0B_SPEC>`"]
pub type OCR0B = crate :: Reg < ocr0b :: OCR0B_SPEC > ; # [doc = "Timer/Counter0 Output Compare Register B"]
pub mod ocr0b { # [doc = "Register `OCR0B` reader"]
pub struct R (crate :: R < OCR0B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR0B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR0B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR0B` writer"]
pub struct W (crate :: W < OCR0B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR0B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR0B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter0 Output Compare Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr0b](index.html) module"]
pub struct OCR0B_SPEC ; impl crate :: RegisterSpec for OCR0B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocr0b::R](R) reader structure"]
impl crate :: Readable for OCR0B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr0b::W](W) writer structure"]
impl crate :: Writable for OCR0B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR0B to value 0"]
impl crate :: Resettable for OCR0B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR0A (rw) register accessor: an alias for `Reg<TCCR0A_SPEC>`"]
pub type TCCR0A = crate :: Reg < tccr0a :: TCCR0A_SPEC > ; # [doc = "Timer/Counter0 Control Register A"]
pub mod tccr0a { # [doc = "Register `TCCR0A` reader"]
pub struct R (crate :: R < TCCR0A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR0A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR0A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR0A` writer"]
pub struct W (crate :: W < TCCR0A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR0A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR0A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM0` reader - Waveform Generation Mode"]
pub type WGM0_R = crate :: FieldReader < u8 , WGM0_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM0_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, TOP=0xFF"]
PWM_PHASE_CORRECT_TOP_0XFF = 1 , # [doc = "2: CTC, TOP = OCRA"]
CTC_TOP_OCRA = 2 , # [doc = "3: Fast PWM, TOP=0xFF"]
FAST_PWM_TOP_0XFF = 3 , } impl From < WGM0_A > for u8 { # [inline (always)]
fn from (variant : WGM0_A) -> Self { variant as _ } } impl WGM0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM0_A { match self . bits { 0 => WGM0_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM0_A :: PWM_PHASE_CORRECT_TOP_0XFF , 2 => WGM0_A :: CTC_TOP_OCRA , 3 => WGM0_A :: FAST_PWM_TOP_0XFF , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM0_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_TOP_0XFF`"]
# [inline (always)]
pub fn is_pwm_phase_correct_top_0xff (& self) -> bool { * self == WGM0_A :: PWM_PHASE_CORRECT_TOP_0XFF } # [doc = "Checks if the value of the field is `CTC_TOP_OCRA`"]
# [inline (always)]
pub fn is_ctc_top_ocra (& self) -> bool { * self == WGM0_A :: CTC_TOP_OCRA } # [doc = "Checks if the value of the field is `FAST_PWM_TOP_0XFF`"]
# [inline (always)]
pub fn is_fast_pwm_top_0xff (& self) -> bool { * self == WGM0_A :: FAST_PWM_TOP_0XFF } } # [doc = "Field `WGM0` writer - Waveform Generation Mode"]
pub type WGM0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0A_SPEC , u8 , WGM0_A , 2 , O > ; impl < 'a , const O : u8 > WGM0_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM0_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, TOP=0xFF"]
# [inline (always)]
pub fn pwm_phase_correct_top_0xff (self) -> & 'a mut W { self . variant (WGM0_A :: PWM_PHASE_CORRECT_TOP_0XFF) } # [doc = "CTC, TOP = OCRA"]
# [inline (always)]
pub fn ctc_top_ocra (self) -> & 'a mut W { self . variant (WGM0_A :: CTC_TOP_OCRA) } # [doc = "Fast PWM, TOP=0xFF"]
# [inline (always)]
pub fn fast_pwm_top_0xff (self) -> & 'a mut W { self . variant (WGM0_A :: FAST_PWM_TOP_0XFF) } } # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0A_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `COM0B` reader - Compare Match Output B Mode"]
pub type COM0B_R = crate :: FieldReader < u8 , COM0B_A > ; # [doc = "Compare Match Output B Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM0B_A { # [doc = "0: Normal port operation, OC0B disconnected"]
NORMAL_PORT_OPERATION_OC0B_DISCONNECTED = 0 , # [doc = "1: Toggle OC0B on Compare Match"]
TOGGLE_OC0B_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OC0B on Compare Match"]
CLEAR_OC0B_ON_COMPARE_MATCH = 2 , # [doc = "3: Set OC0B on Compare Match"]
SET_OC0B_ON_COMPARE_MATCH = 3 , } impl From < COM0B_A > for u8 { # [inline (always)]
fn from (variant : COM0B_A) -> Self { variant as _ } } impl COM0B_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM0B_A { match self . bits { 0 => COM0B_A :: NORMAL_PORT_OPERATION_OC0B_DISCONNECTED , 1 => COM0B_A :: TOGGLE_OC0B_ON_COMPARE_MATCH , 2 => COM0B_A :: CLEAR_OC0B_ON_COMPARE_MATCH , 3 => COM0B_A :: SET_OC0B_ON_COMPARE_MATCH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OC0B_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_oc0b_disconnected (& self) -> bool { * self == COM0B_A :: NORMAL_PORT_OPERATION_OC0B_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OC0B_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_oc0b_on_compare_match (& self) -> bool { * self == COM0B_A :: TOGGLE_OC0B_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OC0B_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_clear_oc0b_on_compare_match (& self) -> bool { * self == COM0B_A :: CLEAR_OC0B_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `SET_OC0B_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_set_oc0b_on_compare_match (& self) -> bool { * self == COM0B_A :: SET_OC0B_ON_COMPARE_MATCH } } # [doc = "Field `COM0B` writer - Compare Match Output B Mode"]
pub type COM0B_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0A_SPEC , u8 , COM0B_A , 2 , O > ; impl < 'a , const O : u8 > COM0B_W < 'a , O > { # [doc = "Normal port operation, OC0B disconnected"]
# [inline (always)]
pub fn normal_port_operation_oc0b_disconnected (self) -> & 'a mut W { self . variant (COM0B_A :: NORMAL_PORT_OPERATION_OC0B_DISCONNECTED) } # [doc = "Toggle OC0B on Compare Match"]
# [inline (always)]
pub fn toggle_oc0b_on_compare_match (self) -> & 'a mut W { self . variant (COM0B_A :: TOGGLE_OC0B_ON_COMPARE_MATCH) } # [doc = "Clear OC0B on Compare Match"]
# [inline (always)]
pub fn clear_oc0b_on_compare_match (self) -> & 'a mut W { self . variant (COM0B_A :: CLEAR_OC0B_ON_COMPARE_MATCH) } # [doc = "Set OC0B on Compare Match"]
# [inline (always)]
pub fn set_oc0b_on_compare_match (self) -> & 'a mut W { self . variant (COM0B_A :: SET_OC0B_ON_COMPARE_MATCH) } } # [doc = "Field `COM0A` reader - Compare Match Output A Mode"]
pub type COM0A_R = crate :: FieldReader < u8 , COM0A_A > ; # [doc = "Compare Match Output A Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM0A_A { # [doc = "0: Normal port operation, OC0A disconnected"]
NORMAL_PORT_OPERATION_OC0A_DISCONNECTED = 0 , # [doc = "1: Toggle OC0A on Compare Match"]
TOGGLE_OC0A_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OC0A on Compare Match"]
CLEAR_OC0A_ON_COMPARE_MATCH = 2 , # [doc = "3: Set OC0A on Compare Match"]
SET_OC0A_ON_COMPARE_MATCH = 3 , } impl From < COM0A_A > for u8 { # [inline (always)]
fn from (variant : COM0A_A) -> Self { variant as _ } } impl COM0A_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM0A_A { match self . bits { 0 => COM0A_A :: NORMAL_PORT_OPERATION_OC0A_DISCONNECTED , 1 => COM0A_A :: TOGGLE_OC0A_ON_COMPARE_MATCH , 2 => COM0A_A :: CLEAR_OC0A_ON_COMPARE_MATCH , 3 => COM0A_A :: SET_OC0A_ON_COMPARE_MATCH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OC0A_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_oc0a_disconnected (& self) -> bool { * self == COM0A_A :: NORMAL_PORT_OPERATION_OC0A_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OC0A_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_oc0a_on_compare_match (& self) -> bool { * self == COM0A_A :: TOGGLE_OC0A_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OC0A_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_clear_oc0a_on_compare_match (& self) -> bool { * self == COM0A_A :: CLEAR_OC0A_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `SET_OC0A_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_set_oc0a_on_compare_match (& self) -> bool { * self == COM0A_A :: SET_OC0A_ON_COMPARE_MATCH } } # [doc = "Field `COM0A` writer - Compare Match Output A Mode"]
pub type COM0A_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0A_SPEC , u8 , COM0A_A , 2 , O > ; impl < 'a , const O : u8 > COM0A_W < 'a , O > { # [doc = "Normal port operation, OC0A disconnected"]
# [inline (always)]
pub fn normal_port_operation_oc0a_disconnected (self) -> & 'a mut W { self . variant (COM0A_A :: NORMAL_PORT_OPERATION_OC0A_DISCONNECTED) } # [doc = "Toggle OC0A on Compare Match"]
# [inline (always)]
pub fn toggle_oc0a_on_compare_match (self) -> & 'a mut W { self . variant (COM0A_A :: TOGGLE_OC0A_ON_COMPARE_MATCH) } # [doc = "Clear OC0A on Compare Match"]
# [inline (always)]
pub fn clear_oc0a_on_compare_match (self) -> & 'a mut W { self . variant (COM0A_A :: CLEAR_OC0A_ON_COMPARE_MATCH) } # [doc = "Set OC0A on Compare Match"]
# [inline (always)]
pub fn set_oc0a_on_compare_match (self) -> & 'a mut W { self . variant (COM0A_A :: SET_OC0A_ON_COMPARE_MATCH) } } impl R { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm0 (& self) -> WGM0_R { WGM0_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare Match Output B Mode"]
# [inline (always)]
pub fn com0b (& self) -> COM0B_R { COM0B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Match Output A Mode"]
# [inline (always)]
pub fn com0a (& self) -> COM0A_R { COM0A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm0 (& mut self) -> WGM0_W < 0 > { WGM0_W :: new (self) } # [doc = "Bits 2:3 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 2 > { RES_W :: new (self) } # [doc = "Bits 4:5 - Compare Match Output B Mode"]
# [inline (always)]
# [must_use]
pub fn com0b (& mut self) -> COM0B_W < 4 > { COM0B_W :: new (self) } # [doc = "Bits 6:7 - Compare Match Output A Mode"]
# [inline (always)]
# [must_use]
pub fn com0a (& mut self) -> COM0A_W < 6 > { COM0A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter0 Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr0a](index.html) module"]
pub struct TCCR0A_SPEC ; impl crate :: RegisterSpec for TCCR0A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr0a::R](R) reader structure"]
impl crate :: Readable for TCCR0A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr0a::W](W) writer structure"]
impl crate :: Writable for TCCR0A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR0A to value 0"]
impl crate :: Resettable for TCCR0A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR0B (rw) register accessor: an alias for `Reg<TCCR0B_SPEC>`"]
pub type TCCR0B = crate :: Reg < tccr0b :: TCCR0B_SPEC > ; # [doc = "Timer/Counter0 Control Register B"]
pub mod tccr0b { # [doc = "Register `TCCR0B` reader"]
pub struct R (crate :: R < TCCR0B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR0B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR0B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR0B` writer"]
pub struct W (crate :: W < TCCR0B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR0B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR0B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS0` reader - Clock Select"]
pub type CS0_R = crate :: FieldReader < u8 , CS0_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS0_A { # [doc = "0: No clock source (Timer/Counter0 stopped)"]
NO_CLOCK_SOURCE_TIMER_COUNTER0_STOPPED = 0 , # [doc = "1: clk_IO/1 (no prescaling)"]
CLK_IO_1_NO_PRESCALING = 1 , # [doc = "2: clk_IO/8 (from prescaler)"]
CLK_IO_8_FROM_PRESCALER = 2 , # [doc = "3: clk_IO/64 (from prescaler)"]
CLK_IO_64_FROM_PRESCALER = 3 , # [doc = "4: clk_IO/256 (from prescaler)"]
CLK_IO_256_FROM_PRESCALER = 4 , # [doc = "5: clk_IO/1024 (from prescaler)"]
CLK_IO_1024_FROM_PRESCALER = 5 , # [doc = "6: External clock source on T0 pin, clock on falling edge"]
EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_FALLING_EDGE = 6 , # [doc = "7: External clock source on T0 pin, clock on rising edge"]
EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_RISING_EDGE = 7 , } impl From < CS0_A > for u8 { # [inline (always)]
fn from (variant : CS0_A) -> Self { variant as _ } } impl CS0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CS0_A { match self . bits { 0 => CS0_A :: NO_CLOCK_SOURCE_TIMER_COUNTER0_STOPPED , 1 => CS0_A :: CLK_IO_1_NO_PRESCALING , 2 => CS0_A :: CLK_IO_8_FROM_PRESCALER , 3 => CS0_A :: CLK_IO_64_FROM_PRESCALER , 4 => CS0_A :: CLK_IO_256_FROM_PRESCALER , 5 => CS0_A :: CLK_IO_1024_FROM_PRESCALER , 6 => CS0_A :: EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_FALLING_EDGE , 7 => CS0_A :: EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_RISING_EDGE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NO_CLOCK_SOURCE_TIMER_COUNTER0_STOPPED`"]
# [inline (always)]
pub fn is_no_clock_source_timer_counter0_stopped (& self) -> bool { * self == CS0_A :: NO_CLOCK_SOURCE_TIMER_COUNTER0_STOPPED } # [doc = "Checks if the value of the field is `CLK_IO_1_NO_PRESCALING`"]
# [inline (always)]
pub fn is_clk_io_1_no_prescaling (& self) -> bool { * self == CS0_A :: CLK_IO_1_NO_PRESCALING } # [doc = "Checks if the value of the field is `CLK_IO_8_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_8_from_prescaler (& self) -> bool { * self == CS0_A :: CLK_IO_8_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_64_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_64_from_prescaler (& self) -> bool { * self == CS0_A :: CLK_IO_64_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_256_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_256_from_prescaler (& self) -> bool { * self == CS0_A :: CLK_IO_256_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_1024_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_1024_from_prescaler (& self) -> bool { * self == CS0_A :: CLK_IO_1024_FROM_PRESCALER } # [doc = "Checks if the value of the field is `EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_FALLING_EDGE`"]
# [inline (always)]
pub fn is_external_clock_source_on_t0_pin_clock_on_falling_edge (& self) -> bool { * self == CS0_A :: EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_FALLING_EDGE } # [doc = "Checks if the value of the field is `EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_RISING_EDGE`"]
# [inline (always)]
pub fn is_external_clock_source_on_t0_pin_clock_on_rising_edge (& self) -> bool { * self == CS0_A :: EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_RISING_EDGE } } # [doc = "Field `CS0` writer - Clock Select"]
pub type CS0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0B_SPEC , u8 , CS0_A , 3 , O > ; impl < 'a , const O : u8 > CS0_W < 'a , O > { # [doc = "No clock source (Timer/Counter0 stopped)"]
# [inline (always)]
pub fn no_clock_source_timer_counter0_stopped (self) -> & 'a mut W { self . variant (CS0_A :: NO_CLOCK_SOURCE_TIMER_COUNTER0_STOPPED) } # [doc = "clk_IO/1 (no prescaling)"]
# [inline (always)]
pub fn clk_io_1_no_prescaling (self) -> & 'a mut W { self . variant (CS0_A :: CLK_IO_1_NO_PRESCALING) } # [doc = "clk_IO/8 (from prescaler)"]
# [inline (always)]
pub fn clk_io_8_from_prescaler (self) -> & 'a mut W { self . variant (CS0_A :: CLK_IO_8_FROM_PRESCALER) } # [doc = "clk_IO/64 (from prescaler)"]
# [inline (always)]
pub fn clk_io_64_from_prescaler (self) -> & 'a mut W { self . variant (CS0_A :: CLK_IO_64_FROM_PRESCALER) } # [doc = "clk_IO/256 (from prescaler)"]
# [inline (always)]
pub fn clk_io_256_from_prescaler (self) -> & 'a mut W { self . variant (CS0_A :: CLK_IO_256_FROM_PRESCALER) } # [doc = "clk_IO/1024 (from prescaler)"]
# [inline (always)]
pub fn clk_io_1024_from_prescaler (self) -> & 'a mut W { self . variant (CS0_A :: CLK_IO_1024_FROM_PRESCALER) } # [doc = "External clock source on T0 pin, clock on falling edge"]
# [inline (always)]
pub fn external_clock_source_on_t0_pin_clock_on_falling_edge (self) -> & 'a mut W { self . variant (CS0_A :: EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_FALLING_EDGE) } # [doc = "External clock source on T0 pin, clock on rising edge"]
# [inline (always)]
pub fn external_clock_source_on_t0_pin_clock_on_rising_edge (self) -> & 'a mut W { self . variant (CS0_A :: EXTERNAL_CLOCK_SOURCE_ON_T0_PIN_CLOCK_ON_RISING_EDGE) } } # [doc = "Field `WGM02` reader - No Description."]
pub type WGM02_R = crate :: BitReader < bool > ; # [doc = "Field `WGM02` writer - No Description."]
pub type WGM02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR0B_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0B_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `FOC0B` reader - Force Output Compare B"]
pub type FOC0B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC0B` writer - Force Output Compare B"]
pub type FOC0B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR0B_SPEC , bool , O > ; # [doc = "Field `FOC0A` reader - Force Output Compare A"]
pub type FOC0A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC0A` writer - Force Output Compare A"]
pub type FOC0A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR0B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
pub fn cs0 (& self) -> CS0_R { CS0_R :: new (self . bits & 7) } # [doc = "Bit 3 - No Description."]
# [inline (always)]
pub fn wgm02 (& self) -> WGM02_R { WGM02_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Force Output Compare B"]
# [inline (always)]
pub fn foc0b (& self) -> FOC0B_R { FOC0B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Force Output Compare A"]
# [inline (always)]
pub fn foc0a (& self) -> FOC0A_R { FOC0A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn cs0 (& mut self) -> CS0_W < 0 > { CS0_W :: new (self) } # [doc = "Bit 3 - No Description."]
# [inline (always)]
# [must_use]
pub fn wgm02 (& mut self) -> WGM02_W < 3 > { WGM02_W :: new (self) } # [doc = "Bits 4:5 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 4 > { RES_W :: new (self) } # [doc = "Bit 6 - Force Output Compare B"]
# [inline (always)]
# [must_use]
pub fn foc0b (& mut self) -> FOC0B_W < 6 > { FOC0B_W :: new (self) } # [doc = "Bit 7 - Force Output Compare A"]
# [inline (always)]
# [must_use]
pub fn foc0a (& mut self) -> FOC0A_W < 7 > { FOC0A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter0 Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr0b](index.html) module"]
pub struct TCCR0B_SPEC ; impl crate :: RegisterSpec for TCCR0B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr0b::R](R) reader structure"]
impl crate :: Readable for TCCR0B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr0b::W](W) writer structure"]
impl crate :: Writable for TCCR0B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR0B to value 0"]
impl crate :: Resettable for TCCR0B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT0 (rw) register accessor: an alias for `Reg<TCNT0_SPEC>`"]
pub type TCNT0 = crate :: Reg < tcnt0 :: TCNT0_SPEC > ; # [doc = "Timer/Counter0 Register"]
pub mod tcnt0 { # [doc = "Register `TCNT0` reader"]
pub struct R (crate :: R < TCNT0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT0` writer"]
pub struct W (crate :: W < TCNT0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter0 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt0](index.html) module"]
pub struct TCNT0_SPEC ; impl crate :: RegisterSpec for TCNT0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tcnt0::R](R) reader structure"]
impl crate :: Readable for TCNT0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt0::W](W) writer structure"]
impl crate :: Writable for TCNT0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT0 to value 0"]
impl crate :: Resettable for TCNT0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR0 (rw) register accessor: an alias for `Reg<TIFR0_SPEC>`"]
pub type TIFR0 = crate :: Reg < tifr0 :: TIFR0_SPEC > ; # [doc = "Timer/Counter0 Interrupt Flag Register"]
pub mod tifr0 { # [doc = "Register `TIFR0` reader"]
pub struct R (crate :: R < TIFR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR0` writer"]
pub struct W (crate :: W < TIFR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR0_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV0` reader - Timer/Counter0 Overflow Flag"]
pub type TOV0_R = crate :: BitReader < bool > ; # [doc = "Field `TOV0` writer - Timer/Counter0 Overflow Flag"]
pub type TOV0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR0_SPEC , bool , O > ; # [doc = "Field `OCF0A` reader - Timer/Counter0 Output Compare A Match Flag"]
pub type OCF0A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF0A` writer - Timer/Counter0 Output Compare A Match Flag"]
pub type OCF0A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR0_SPEC , bool , O > ; # [doc = "Field `OCF0B` reader - Timer/Counter0 Output Compare B Match Flag"]
pub type OCF0B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF0B` writer - Timer/Counter0 Output Compare B Match Flag"]
pub type OCF0B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR0_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TIFR0_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bit 0 - Timer/Counter0 Overflow Flag"]
# [inline (always)]
pub fn tov0 (& self) -> TOV0_R { TOV0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter0 Output Compare A Match Flag"]
# [inline (always)]
pub fn ocf0a (& self) -> OCF0A_R { OCF0A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter0 Output Compare B Match Flag"]
# [inline (always)]
pub fn ocf0b (& self) -> OCF0B_R { OCF0B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 3) & 0x1f) } } impl W { # [doc = "Bit 0 - Timer/Counter0 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov0 (& mut self) -> TOV0_W < 0 > { TOV0_W :: new (self) } # [doc = "Bit 1 - Timer/Counter0 Output Compare A Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf0a (& mut self) -> OCF0A_W < 1 > { OCF0A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter0 Output Compare B Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf0b (& mut self) -> OCF0B_W < 2 > { OCF0B_W :: new (self) } # [doc = "Bits 3:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 3 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter0 Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr0](index.html) module"]
pub struct TIFR0_SPEC ; impl crate :: RegisterSpec for TIFR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr0::R](R) reader structure"]
impl crate :: Readable for TIFR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr0::W](W) writer structure"]
impl crate :: Writable for TIFR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR0 to value 0"]
impl crate :: Resettable for TIFR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK0 (rw) register accessor: an alias for `Reg<TIMSK0_SPEC>`"]
pub type TIMSK0 = crate :: Reg < timsk0 :: TIMSK0_SPEC > ; # [doc = "Timer/Counter0 Interrupt Mask Register"]
pub mod timsk0 { # [doc = "Register `TIMSK0` reader"]
pub struct R (crate :: R < TIMSK0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK0` writer"]
pub struct W (crate :: W < TIMSK0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK0_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE0` reader - Timer/Counter0 Overflow Interrupt Enable"]
pub type TOIE0_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE0` writer - Timer/Counter0 Overflow Interrupt Enable"]
pub type TOIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK0_SPEC , bool , O > ; # [doc = "Field `OCIE0A` reader - Timer/Counter0 Output Compare Match A Interrupt Enable"]
pub type OCIE0A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE0A` writer - Timer/Counter0 Output Compare Match A Interrupt Enable"]
pub type OCIE0A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK0_SPEC , bool , O > ; # [doc = "Field `OCIE0B` reader - Timer/Counter0 Output Compare Match B Interrupt Enable"]
pub type OCIE0B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE0B` writer - Timer/Counter0 Output Compare Match B Interrupt Enable"]
pub type OCIE0B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK0_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TIMSK0_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bit 0 - Timer/Counter0 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie0 (& self) -> TOIE0_R { TOIE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter0 Output Compare Match A Interrupt Enable"]
# [inline (always)]
pub fn ocie0a (& self) -> OCIE0A_R { OCIE0A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter0 Output Compare Match B Interrupt Enable"]
# [inline (always)]
pub fn ocie0b (& self) -> OCIE0B_R { OCIE0B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 3) & 0x1f) } } impl W { # [doc = "Bit 0 - Timer/Counter0 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie0 (& mut self) -> TOIE0_W < 0 > { TOIE0_W :: new (self) } # [doc = "Bit 1 - Timer/Counter0 Output Compare Match A Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie0a (& mut self) -> OCIE0A_W < 1 > { OCIE0A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter0 Output Compare Match B Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie0b (& mut self) -> OCIE0B_W < 2 > { OCIE0B_W :: new (self) } # [doc = "Bits 3:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 3 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter0 Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk0](index.html) module"]
pub struct TIMSK0_SPEC ; impl crate :: RegisterSpec for TIMSK0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk0::R](R) reader structure"]
impl crate :: Readable for TIMSK0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk0::W](W) writer structure"]
impl crate :: Writable for TIMSK0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK0 to value 0"]
impl crate :: Resettable for TIMSK0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 16-bit"]
pub struct TC1 { _marker : PhantomData < * const () > } unsafe impl Send for TC1 { } impl TC1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc1 :: RegisterBlock = 0x36 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc1 :: RegisterBlock { Self :: PTR } } impl Deref for TC1 { type Target = tc1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC1") . finish () } } # [doc = "Timer/Counter, 16-bit"]
pub mod tc1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter1 Interrupt Flag Register"]
pub tifr1 : TIFR1 , _reserved1 : [u8 ; 0x38]
, # [doc = "0x39 - Timer/Counter1 Interrupt Mask Register"]
pub timsk1 : TIMSK1 , _reserved2 : [u8 ; 0x10]
, # [doc = "0x4a - Timer/Counter1 Control Register A"]
pub tccr1a : TCCR1A , # [doc = "0x4b - Timer/Counter1 Control Register B"]
pub tccr1b : TCCR1B , # [doc = "0x4c - Timer/Counter1 Control Register C"]
pub tccr1c : TCCR1C , _reserved5 : [u8 ; 0x01]
, # [doc = "0x4e - Timer/Counter1 Bytes"]
pub tcnt1 : TCNT1 , # [doc = "0x50 - Timer/Counter1 Input Capture Register Bytes"]
pub icr1 : ICR1 , # [doc = "0x52 - Timer/Counter1 Output Compare Register A Bytes"]
pub ocr1a : OCR1A , # [doc = "0x54 - Timer/Counter1 Output Compare Register B Bytes"]
pub ocr1b : OCR1B , # [doc = "0x56 - Timer/Counter1 Output Compare Register C Bytes"]
pub ocr1c : OCR1C , } # [doc = "ICR1 (rw) register accessor: an alias for `Reg<ICR1_SPEC>`"]
pub type ICR1 = crate :: Reg < icr1 :: ICR1_SPEC > ; # [doc = "Timer/Counter1 Input Capture Register Bytes"]
pub mod icr1 { # [doc = "Register `ICR1` reader"]
pub struct R (crate :: R < ICR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ICR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ICR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ICR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `ICR1` writer"]
pub struct W (crate :: W < ICR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ICR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ICR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ICR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Input Capture Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr1](index.html) module"]
pub struct ICR1_SPEC ; impl crate :: RegisterSpec for ICR1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [icr1::R](R) reader structure"]
impl crate :: Readable for ICR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [icr1::W](W) writer structure"]
impl crate :: Writable for ICR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ICR1 to value 0"]
impl crate :: Resettable for ICR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR1A (rw) register accessor: an alias for `Reg<OCR1A_SPEC>`"]
pub type OCR1A = crate :: Reg < ocr1a :: OCR1A_SPEC > ; # [doc = "Timer/Counter1 Output Compare Register A Bytes"]
pub mod ocr1a { # [doc = "Register `OCR1A` reader"]
pub struct R (crate :: R < OCR1A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR1A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR1A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR1A` writer"]
pub struct W (crate :: W < OCR1A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR1A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR1A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Output Compare Register A Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr1a](index.html) module"]
pub struct OCR1A_SPEC ; impl crate :: RegisterSpec for OCR1A_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr1a::R](R) reader structure"]
impl crate :: Readable for OCR1A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr1a::W](W) writer structure"]
impl crate :: Writable for OCR1A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR1A to value 0"]
impl crate :: Resettable for OCR1A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR1B (rw) register accessor: an alias for `Reg<OCR1B_SPEC>`"]
pub type OCR1B = crate :: Reg < ocr1b :: OCR1B_SPEC > ; # [doc = "Timer/Counter1 Output Compare Register B Bytes"]
pub mod ocr1b { # [doc = "Register `OCR1B` reader"]
pub struct R (crate :: R < OCR1B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR1B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR1B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR1B` writer"]
pub struct W (crate :: W < OCR1B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR1B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR1B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Output Compare Register B Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr1b](index.html) module"]
pub struct OCR1B_SPEC ; impl crate :: RegisterSpec for OCR1B_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr1b::R](R) reader structure"]
impl crate :: Readable for OCR1B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr1b::W](W) writer structure"]
impl crate :: Writable for OCR1B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR1B to value 0"]
impl crate :: Resettable for OCR1B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR1C (rw) register accessor: an alias for `Reg<OCR1C_SPEC>`"]
pub type OCR1C = crate :: Reg < ocr1c :: OCR1C_SPEC > ; # [doc = "Timer/Counter1 Output Compare Register C Bytes"]
pub mod ocr1c { # [doc = "Register `OCR1C` reader"]
pub struct R (crate :: R < OCR1C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR1C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR1C_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR1C` writer"]
pub struct W (crate :: W < OCR1C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR1C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR1C_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Output Compare Register C Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr1c](index.html) module"]
pub struct OCR1C_SPEC ; impl crate :: RegisterSpec for OCR1C_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr1c::R](R) reader structure"]
impl crate :: Readable for OCR1C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr1c::W](W) writer structure"]
impl crate :: Writable for OCR1C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR1C to value 0"]
impl crate :: Resettable for OCR1C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR1A (rw) register accessor: an alias for `Reg<TCCR1A_SPEC>`"]
pub type TCCR1A = crate :: Reg < tccr1a :: TCCR1A_SPEC > ; # [doc = "Timer/Counter1 Control Register A"]
pub mod tccr1a { # [doc = "Register `TCCR1A` reader"]
pub struct R (crate :: R < TCCR1A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR1A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR1A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR1A` writer"]
pub struct W (crate :: W < TCCR1A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR1A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR1A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM1` reader - Waveform Generation Mode"]
pub type WGM1_R = crate :: FieldReader < u8 , WGM1_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM1_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, 8-bit"]
PWM_PHASE_CORRECT_8_BIT = 1 , # [doc = "2: PWM, phase correct, 9-bit"]
PWM_PHASE_CORRECT_9_BIT = 2 , # [doc = "3: PWM, phase correct, 10-bit"]
PWM_PHASE_CORRECT_10_BIT = 3 , } impl From < WGM1_A > for u8 { # [inline (always)]
fn from (variant : WGM1_A) -> Self { variant as _ } } impl WGM1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM1_A { match self . bits { 0 => WGM1_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM1_A :: PWM_PHASE_CORRECT_8_BIT , 2 => WGM1_A :: PWM_PHASE_CORRECT_9_BIT , 3 => WGM1_A :: PWM_PHASE_CORRECT_10_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM1_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_8_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_8_bit (& self) -> bool { * self == WGM1_A :: PWM_PHASE_CORRECT_8_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_9_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_9_bit (& self) -> bool { * self == WGM1_A :: PWM_PHASE_CORRECT_9_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_10_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_10_bit (& self) -> bool { * self == WGM1_A :: PWM_PHASE_CORRECT_10_BIT } } # [doc = "Field `WGM1` writer - Waveform Generation Mode"]
pub type WGM1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1A_SPEC , u8 , WGM1_A , 2 , O > ; impl < 'a , const O : u8 > WGM1_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM1_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, 8-bit"]
# [inline (always)]
pub fn pwm_phase_correct_8_bit (self) -> & 'a mut W { self . variant (WGM1_A :: PWM_PHASE_CORRECT_8_BIT) } # [doc = "PWM, phase correct, 9-bit"]
# [inline (always)]
pub fn pwm_phase_correct_9_bit (self) -> & 'a mut W { self . variant (WGM1_A :: PWM_PHASE_CORRECT_9_BIT) } # [doc = "PWM, phase correct, 10-bit"]
# [inline (always)]
pub fn pwm_phase_correct_10_bit (self) -> & 'a mut W { self . variant (WGM1_A :: PWM_PHASE_CORRECT_10_BIT) } } # [doc = "Field `COM1C` reader - Compare Output Mode for Channel C"]
pub type COM1C_R = crate :: FieldReader < u8 , COM1C_A > ; # [doc = "Compare Output Mode for Channel C\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM1C_A { # [doc = "0: Normal port operation, OCnA/OCnB/OCnC disconnected."]
NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED = 0 , # [doc = "1: Toggle OCnA/OCnB/OCnC on Compare Match."]
TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL = 2 , # [doc = "3: Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL = 3 , } impl From < COM1C_A > for u8 { # [inline (always)]
fn from (variant : COM1C_A) -> Self { variant as _ } } impl COM1C_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM1C_A { match self . bits { 0 => COM1C_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED , 1 => COM1C_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH , 2 => COM1C_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL , 3 => COM1C_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_ocna_ocnb_ocnc_disconnected (& self) -> bool { * self == COM1C_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_ocna_ocnb_ocnc_on_compare_match (& self) -> bool { * self == COM1C_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL`"]
# [inline (always)]
pub fn is_clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (& self) -> bool { * self == COM1C_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL } # [doc = "Checks if the value of the field is `SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL`"]
# [inline (always)]
pub fn is_set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (& self) -> bool { * self == COM1C_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL } } # [doc = "Field `COM1C` writer - Compare Output Mode for Channel C"]
pub type COM1C_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1A_SPEC , u8 , COM1C_A , 2 , O > ; impl < 'a , const O : u8 > COM1C_W < 'a , O > { # [doc = "Normal port operation, OCnA/OCnB/OCnC disconnected."]
# [inline (always)]
pub fn normal_port_operation_ocna_ocnb_ocnc_disconnected (self) -> & 'a mut W { self . variant (COM1C_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED) } # [doc = "Toggle OCnA/OCnB/OCnC on Compare Match."]
# [inline (always)]
pub fn toggle_ocna_ocnb_ocnc_on_compare_match (self) -> & 'a mut W { self . variant (COM1C_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH) } # [doc = "Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
# [inline (always)]
pub fn clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (self) -> & 'a mut W { self . variant (COM1C_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL) } # [doc = "Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
# [inline (always)]
pub fn set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (self) -> & 'a mut W { self . variant (COM1C_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL) } } # [doc = "Field `COM1B` reader - Compare Output Mode for Channel B"]
pub type COM1B_R = crate :: FieldReader < u8 , COM1B_A > ; # [doc = "Compare Output Mode for Channel B\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM1B_A { # [doc = "0: Normal port operation, OCnA/OCnB/OCnC disconnected."]
NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED = 0 , # [doc = "1: Toggle OCnA/OCnB/OCnC on Compare Match."]
TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL = 2 , # [doc = "3: Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL = 3 , } impl From < COM1B_A > for u8 { # [inline (always)]
fn from (variant : COM1B_A) -> Self { variant as _ } } impl COM1B_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM1B_A { match self . bits { 0 => COM1B_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED , 1 => COM1B_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH , 2 => COM1B_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL , 3 => COM1B_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_ocna_ocnb_ocnc_disconnected (& self) -> bool { * self == COM1B_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_ocna_ocnb_ocnc_on_compare_match (& self) -> bool { * self == COM1B_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL`"]
# [inline (always)]
pub fn is_clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (& self) -> bool { * self == COM1B_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL } # [doc = "Checks if the value of the field is `SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL`"]
# [inline (always)]
pub fn is_set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (& self) -> bool { * self == COM1B_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL } } # [doc = "Field `COM1B` writer - Compare Output Mode for Channel B"]
pub type COM1B_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1A_SPEC , u8 , COM1B_A , 2 , O > ; impl < 'a , const O : u8 > COM1B_W < 'a , O > { # [doc = "Normal port operation, OCnA/OCnB/OCnC disconnected."]
# [inline (always)]
pub fn normal_port_operation_ocna_ocnb_ocnc_disconnected (self) -> & 'a mut W { self . variant (COM1B_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED) } # [doc = "Toggle OCnA/OCnB/OCnC on Compare Match."]
# [inline (always)]
pub fn toggle_ocna_ocnb_ocnc_on_compare_match (self) -> & 'a mut W { self . variant (COM1B_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH) } # [doc = "Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
# [inline (always)]
pub fn clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (self) -> & 'a mut W { self . variant (COM1B_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL) } # [doc = "Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
# [inline (always)]
pub fn set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (self) -> & 'a mut W { self . variant (COM1B_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL) } } # [doc = "Field `COM1A` reader - Compare Output Mode for Channel A"]
pub type COM1A_R = crate :: FieldReader < u8 , COM1A_A > ; # [doc = "Compare Output Mode for Channel A\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM1A_A { # [doc = "0: Normal port operation, OCnA/OCnB/OCnC disconnected."]
NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED = 0 , # [doc = "1: Toggle OCnA/OCnB/OCnC on Compare Match."]
TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL = 2 , # [doc = "3: Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL = 3 , } impl From < COM1A_A > for u8 { # [inline (always)]
fn from (variant : COM1A_A) -> Self { variant as _ } } impl COM1A_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM1A_A { match self . bits { 0 => COM1A_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED , 1 => COM1A_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH , 2 => COM1A_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL , 3 => COM1A_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_ocna_ocnb_ocnc_disconnected (& self) -> bool { * self == COM1A_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_ocna_ocnb_ocnc_on_compare_match (& self) -> bool { * self == COM1A_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL`"]
# [inline (always)]
pub fn is_clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (& self) -> bool { * self == COM1A_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL } # [doc = "Checks if the value of the field is `SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL`"]
# [inline (always)]
pub fn is_set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (& self) -> bool { * self == COM1A_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL } } # [doc = "Field `COM1A` writer - Compare Output Mode for Channel A"]
pub type COM1A_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1A_SPEC , u8 , COM1A_A , 2 , O > ; impl < 'a , const O : u8 > COM1A_W < 'a , O > { # [doc = "Normal port operation, OCnA/OCnB/OCnC disconnected."]
# [inline (always)]
pub fn normal_port_operation_ocna_ocnb_ocnc_disconnected (self) -> & 'a mut W { self . variant (COM1A_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED) } # [doc = "Toggle OCnA/OCnB/OCnC on Compare Match."]
# [inline (always)]
pub fn toggle_ocna_ocnb_ocnc_on_compare_match (self) -> & 'a mut W { self . variant (COM1A_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH) } # [doc = "Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
# [inline (always)]
pub fn clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (self) -> & 'a mut W { self . variant (COM1A_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL) } # [doc = "Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
# [inline (always)]
pub fn set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (self) -> & 'a mut W { self . variant (COM1A_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL) } } impl R { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm1 (& self) -> WGM1_R { WGM1_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare Output Mode for Channel C"]
# [inline (always)]
pub fn com1c (& self) -> COM1C_R { COM1C_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare Output Mode for Channel B"]
# [inline (always)]
pub fn com1b (& self) -> COM1B_R { COM1B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Output Mode for Channel A"]
# [inline (always)]
pub fn com1a (& self) -> COM1A_R { COM1A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm1 (& mut self) -> WGM1_W < 0 > { WGM1_W :: new (self) } # [doc = "Bits 2:3 - Compare Output Mode for Channel C"]
# [inline (always)]
# [must_use]
pub fn com1c (& mut self) -> COM1C_W < 2 > { COM1C_W :: new (self) } # [doc = "Bits 4:5 - Compare Output Mode for Channel B"]
# [inline (always)]
# [must_use]
pub fn com1b (& mut self) -> COM1B_W < 4 > { COM1B_W :: new (self) } # [doc = "Bits 6:7 - Compare Output Mode for Channel A"]
# [inline (always)]
# [must_use]
pub fn com1a (& mut self) -> COM1A_W < 6 > { COM1A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter1 Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr1a](index.html) module"]
pub struct TCCR1A_SPEC ; impl crate :: RegisterSpec for TCCR1A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr1a::R](R) reader structure"]
impl crate :: Readable for TCCR1A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr1a::W](W) writer structure"]
impl crate :: Writable for TCCR1A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR1A to value 0"]
impl crate :: Resettable for TCCR1A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR1B (rw) register accessor: an alias for `Reg<TCCR1B_SPEC>`"]
pub type TCCR1B = crate :: Reg < tccr1b :: TCCR1B_SPEC > ; # [doc = "Timer/Counter1 Control Register B"]
pub mod tccr1b { # [doc = "Register `TCCR1B` reader"]
pub struct R (crate :: R < TCCR1B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR1B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR1B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR1B` writer"]
pub struct W (crate :: W < TCCR1B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR1B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR1B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS1` reader - Clock Select"]
pub type CS1_R = crate :: FieldReader < u8 , CS1_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS1_A { # [doc = "0: No clock source (Timer/Counter stopped)"]
NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED = 0 , # [doc = "1: clk_IO/1 (no prescaling)"]
CLK_IO_1_NO_PRESCALING = 1 , # [doc = "2: clk_IO/8 (from prescaler)"]
CLK_IO_8_FROM_PRESCALER = 2 , # [doc = "3: clk_IO/64 (from prescaler)"]
CLK_IO_64_FROM_PRESCALER = 3 , # [doc = "4: clk_IO/256 (from prescaler)"]
CLK_IO_256_FROM_PRESCALER = 4 , # [doc = "5: clk_IO/1024 (from prescaler)"]
CLK_IO_1024_FROM_PRESCALER = 5 , # [doc = "6: External clock source on Tn pin, clock on falling edge"]
EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE = 6 , # [doc = "7: External clock source on Tn pin, clock on rising edge"]
EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE = 7 , } impl From < CS1_A > for u8 { # [inline (always)]
fn from (variant : CS1_A) -> Self { variant as _ } } impl CS1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CS1_A { match self . bits { 0 => CS1_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED , 1 => CS1_A :: CLK_IO_1_NO_PRESCALING , 2 => CS1_A :: CLK_IO_8_FROM_PRESCALER , 3 => CS1_A :: CLK_IO_64_FROM_PRESCALER , 4 => CS1_A :: CLK_IO_256_FROM_PRESCALER , 5 => CS1_A :: CLK_IO_1024_FROM_PRESCALER , 6 => CS1_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE , 7 => CS1_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED`"]
# [inline (always)]
pub fn is_no_clock_source_timer_counter_stopped (& self) -> bool { * self == CS1_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED } # [doc = "Checks if the value of the field is `CLK_IO_1_NO_PRESCALING`"]
# [inline (always)]
pub fn is_clk_io_1_no_prescaling (& self) -> bool { * self == CS1_A :: CLK_IO_1_NO_PRESCALING } # [doc = "Checks if the value of the field is `CLK_IO_8_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_8_from_prescaler (& self) -> bool { * self == CS1_A :: CLK_IO_8_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_64_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_64_from_prescaler (& self) -> bool { * self == CS1_A :: CLK_IO_64_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_256_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_256_from_prescaler (& self) -> bool { * self == CS1_A :: CLK_IO_256_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_1024_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_1024_from_prescaler (& self) -> bool { * self == CS1_A :: CLK_IO_1024_FROM_PRESCALER } # [doc = "Checks if the value of the field is `EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE`"]
# [inline (always)]
pub fn is_external_clock_source_on_tn_pin_clock_on_falling_edge (& self) -> bool { * self == CS1_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE } # [doc = "Checks if the value of the field is `EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE`"]
# [inline (always)]
pub fn is_external_clock_source_on_tn_pin_clock_on_rising_edge (& self) -> bool { * self == CS1_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE } } # [doc = "Field `CS1` writer - Clock Select"]
pub type CS1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1B_SPEC , u8 , CS1_A , 3 , O > ; impl < 'a , const O : u8 > CS1_W < 'a , O > { # [doc = "No clock source (Timer/Counter stopped)"]
# [inline (always)]
pub fn no_clock_source_timer_counter_stopped (self) -> & 'a mut W { self . variant (CS1_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED) } # [doc = "clk_IO/1 (no prescaling)"]
# [inline (always)]
pub fn clk_io_1_no_prescaling (self) -> & 'a mut W { self . variant (CS1_A :: CLK_IO_1_NO_PRESCALING) } # [doc = "clk_IO/8 (from prescaler)"]
# [inline (always)]
pub fn clk_io_8_from_prescaler (self) -> & 'a mut W { self . variant (CS1_A :: CLK_IO_8_FROM_PRESCALER) } # [doc = "clk_IO/64 (from prescaler)"]
# [inline (always)]
pub fn clk_io_64_from_prescaler (self) -> & 'a mut W { self . variant (CS1_A :: CLK_IO_64_FROM_PRESCALER) } # [doc = "clk_IO/256 (from prescaler)"]
# [inline (always)]
pub fn clk_io_256_from_prescaler (self) -> & 'a mut W { self . variant (CS1_A :: CLK_IO_256_FROM_PRESCALER) } # [doc = "clk_IO/1024 (from prescaler)"]
# [inline (always)]
pub fn clk_io_1024_from_prescaler (self) -> & 'a mut W { self . variant (CS1_A :: CLK_IO_1024_FROM_PRESCALER) } # [doc = "External clock source on Tn pin, clock on falling edge"]
# [inline (always)]
pub fn external_clock_source_on_tn_pin_clock_on_falling_edge (self) -> & 'a mut W { self . variant (CS1_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE) } # [doc = "External clock source on Tn pin, clock on rising edge"]
# [inline (always)]
pub fn external_clock_source_on_tn_pin_clock_on_rising_edge (self) -> & 'a mut W { self . variant (CS1_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE) } } # [doc = "Field `WGM1` reader - Waveform Generation Mode"]
pub type WGM1_R = crate :: FieldReader < u8 , WGM1_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM1_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, 8-bit"]
PWM_PHASE_CORRECT_8_BIT = 1 , # [doc = "2: PWM, phase correct, 9-bit"]
PWM_PHASE_CORRECT_9_BIT = 2 , # [doc = "3: PWM, phase correct, 10-bit"]
PWM_PHASE_CORRECT_10_BIT = 3 , } impl From < WGM1_A > for u8 { # [inline (always)]
fn from (variant : WGM1_A) -> Self { variant as _ } } impl WGM1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM1_A { match self . bits { 0 => WGM1_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM1_A :: PWM_PHASE_CORRECT_8_BIT , 2 => WGM1_A :: PWM_PHASE_CORRECT_9_BIT , 3 => WGM1_A :: PWM_PHASE_CORRECT_10_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM1_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_8_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_8_bit (& self) -> bool { * self == WGM1_A :: PWM_PHASE_CORRECT_8_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_9_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_9_bit (& self) -> bool { * self == WGM1_A :: PWM_PHASE_CORRECT_9_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_10_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_10_bit (& self) -> bool { * self == WGM1_A :: PWM_PHASE_CORRECT_10_BIT } } # [doc = "Field `WGM1` writer - Waveform Generation Mode"]
pub type WGM1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1B_SPEC , u8 , WGM1_A , 2 , O > ; impl < 'a , const O : u8 > WGM1_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM1_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, 8-bit"]
# [inline (always)]
pub fn pwm_phase_correct_8_bit (self) -> & 'a mut W { self . variant (WGM1_A :: PWM_PHASE_CORRECT_8_BIT) } # [doc = "PWM, phase correct, 9-bit"]
# [inline (always)]
pub fn pwm_phase_correct_9_bit (self) -> & 'a mut W { self . variant (WGM1_A :: PWM_PHASE_CORRECT_9_BIT) } # [doc = "PWM, phase correct, 10-bit"]
# [inline (always)]
pub fn pwm_phase_correct_10_bit (self) -> & 'a mut W { self . variant (WGM1_A :: PWM_PHASE_CORRECT_10_BIT) } } # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1B_SPEC , bool , O > ; # [doc = "Field `ICES1` reader - Input Capture 1 Edge Select"]
pub type ICES1_R = crate :: BitReader < bool > ; # [doc = "Field `ICES1` writer - Input Capture 1 Edge Select"]
pub type ICES1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1B_SPEC , bool , O > ; # [doc = "Field `ICNC1` reader - Input Capture 1 Noise Canceller"]
pub type ICNC1_R = crate :: BitReader < bool > ; # [doc = "Field `ICNC1` writer - Input Capture 1 Noise Canceller"]
pub type ICNC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
pub fn cs1 (& self) -> CS1_R { CS1_R :: new (self . bits & 7) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm1 (& self) -> WGM1_R { WGM1_R :: new ((self . bits >> 3) & 3) } # [doc = "Bit 5 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Input Capture 1 Edge Select"]
# [inline (always)]
pub fn ices1 (& self) -> ICES1_R { ICES1_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Input Capture 1 Noise Canceller"]
# [inline (always)]
pub fn icnc1 (& self) -> ICNC1_R { ICNC1_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn cs1 (& mut self) -> CS1_W < 0 > { CS1_W :: new (self) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm1 (& mut self) -> WGM1_W < 3 > { WGM1_W :: new (self) } # [doc = "Bit 5 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 5 > { RES_W :: new (self) } # [doc = "Bit 6 - Input Capture 1 Edge Select"]
# [inline (always)]
# [must_use]
pub fn ices1 (& mut self) -> ICES1_W < 6 > { ICES1_W :: new (self) } # [doc = "Bit 7 - Input Capture 1 Noise Canceller"]
# [inline (always)]
# [must_use]
pub fn icnc1 (& mut self) -> ICNC1_W < 7 > { ICNC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter1 Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr1b](index.html) module"]
pub struct TCCR1B_SPEC ; impl crate :: RegisterSpec for TCCR1B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr1b::R](R) reader structure"]
impl crate :: Readable for TCCR1B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr1b::W](W) writer structure"]
impl crate :: Writable for TCCR1B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR1B to value 0"]
impl crate :: Resettable for TCCR1B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR1C (rw) register accessor: an alias for `Reg<TCCR1C_SPEC>`"]
pub type TCCR1C = crate :: Reg < tccr1c :: TCCR1C_SPEC > ; # [doc = "Timer/Counter1 Control Register C"]
pub mod tccr1c { # [doc = "Register `TCCR1C` reader"]
pub struct R (crate :: R < TCCR1C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR1C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR1C_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR1C` writer"]
pub struct W (crate :: W < TCCR1C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR1C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR1C_SPEC >) -> Self { W (writer) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1C_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `FOC1C` reader - Force Output Compare for Channel C"]
pub type FOC1C_R = crate :: BitReader < bool > ; # [doc = "Field `FOC1C` writer - Force Output Compare for Channel C"]
pub type FOC1C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1C_SPEC , bool , O > ; # [doc = "Field `FOC1B` reader - Force Output Compare for Channel B"]
pub type FOC1B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC1B` writer - Force Output Compare for Channel B"]
pub type FOC1B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1C_SPEC , bool , O > ; # [doc = "Field `FOC1A` reader - Force Output Compare for Channel A"]
pub type FOC1A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC1A` writer - Force Output Compare for Channel A"]
pub type FOC1A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1C_SPEC , bool , O > ; impl R { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (self . bits & 0x1f) } # [doc = "Bit 5 - Force Output Compare for Channel C"]
# [inline (always)]
pub fn foc1c (& self) -> FOC1C_R { FOC1C_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Force Output Compare for Channel B"]
# [inline (always)]
pub fn foc1b (& self) -> FOC1B_R { FOC1B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Force Output Compare for Channel A"]
# [inline (always)]
pub fn foc1a (& self) -> FOC1A_R { FOC1A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 0 > { RES_W :: new (self) } # [doc = "Bit 5 - Force Output Compare for Channel C"]
# [inline (always)]
# [must_use]
pub fn foc1c (& mut self) -> FOC1C_W < 5 > { FOC1C_W :: new (self) } # [doc = "Bit 6 - Force Output Compare for Channel B"]
# [inline (always)]
# [must_use]
pub fn foc1b (& mut self) -> FOC1B_W < 6 > { FOC1B_W :: new (self) } # [doc = "Bit 7 - Force Output Compare for Channel A"]
# [inline (always)]
# [must_use]
pub fn foc1a (& mut self) -> FOC1A_W < 7 > { FOC1A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter1 Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr1c](index.html) module"]
pub struct TCCR1C_SPEC ; impl crate :: RegisterSpec for TCCR1C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr1c::R](R) reader structure"]
impl crate :: Readable for TCCR1C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr1c::W](W) writer structure"]
impl crate :: Writable for TCCR1C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR1C to value 0"]
impl crate :: Resettable for TCCR1C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT1 (rw) register accessor: an alias for `Reg<TCNT1_SPEC>`"]
pub type TCNT1 = crate :: Reg < tcnt1 :: TCNT1_SPEC > ; # [doc = "Timer/Counter1 Bytes"]
pub mod tcnt1 { # [doc = "Register `TCNT1` reader"]
pub struct R (crate :: R < TCNT1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT1` writer"]
pub struct W (crate :: W < TCNT1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt1](index.html) module"]
pub struct TCNT1_SPEC ; impl crate :: RegisterSpec for TCNT1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [tcnt1::R](R) reader structure"]
impl crate :: Readable for TCNT1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt1::W](W) writer structure"]
impl crate :: Writable for TCNT1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT1 to value 0"]
impl crate :: Resettable for TCNT1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR1 (rw) register accessor: an alias for `Reg<TIFR1_SPEC>`"]
pub type TIFR1 = crate :: Reg < tifr1 :: TIFR1_SPEC > ; # [doc = "Timer/Counter1 Interrupt Flag Register"]
pub mod tifr1 { # [doc = "Register `TIFR1` reader"]
pub struct R (crate :: R < TIFR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR1` writer"]
pub struct W (crate :: W < TIFR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR1_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV1` reader - Timer/Counter1 Overflow Flag"]
pub type TOV1_R = crate :: BitReader < bool > ; # [doc = "Field `TOV1` writer - Timer/Counter1 Overflow Flag"]
pub type TOV1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; # [doc = "Field `OCF1A` reader - Timer/Counter1 Output Compare A Match Flag"]
pub type OCF1A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF1A` writer - Timer/Counter1 Output Compare A Match Flag"]
pub type OCF1A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; # [doc = "Field `OCF1B` reader - Timer/Counter1 Output Compare B Match Flag"]
pub type OCF1B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF1B` writer - Timer/Counter1 Output Compare B Match Flag"]
pub type OCF1B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; # [doc = "Field `OCF1C` reader - Timer/Counter1 Output Compare C Match Flag"]
pub type OCF1C_R = crate :: BitReader < bool > ; # [doc = "Field `OCF1C` writer - Timer/Counter1 Output Compare C Match Flag"]
pub type OCF1C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; # [doc = "Field `ICF1` reader - Timer/Counter1 Input Capture Flag"]
pub type ICF1_R = crate :: BitReader < bool > ; # [doc = "Field `ICF1` writer - Timer/Counter1 Input Capture Flag"]
pub type ICF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter1 Overflow Flag"]
# [inline (always)]
pub fn tov1 (& self) -> TOV1_R { TOV1_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter1 Output Compare A Match Flag"]
# [inline (always)]
pub fn ocf1a (& self) -> OCF1A_R { OCF1A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter1 Output Compare B Match Flag"]
# [inline (always)]
pub fn ocf1b (& self) -> OCF1B_R { OCF1B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter1 Output Compare C Match Flag"]
# [inline (always)]
pub fn ocf1c (& self) -> OCF1C_R { OCF1C_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter1 Input Capture Flag"]
# [inline (always)]
pub fn icf1 (& self) -> ICF1_R { ICF1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter1 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov1 (& mut self) -> TOV1_W < 0 > { TOV1_W :: new (self) } # [doc = "Bit 1 - Timer/Counter1 Output Compare A Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf1a (& mut self) -> OCF1A_W < 1 > { OCF1A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter1 Output Compare B Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf1b (& mut self) -> OCF1B_W < 2 > { OCF1B_W :: new (self) } # [doc = "Bit 3 - Timer/Counter1 Output Compare C Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf1c (& mut self) -> OCF1C_W < 3 > { OCF1C_W :: new (self) } # [doc = "Bit 5 - Timer/Counter1 Input Capture Flag"]
# [inline (always)]
# [must_use]
pub fn icf1 (& mut self) -> ICF1_W < 5 > { ICF1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter1 Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr1](index.html) module"]
pub struct TIFR1_SPEC ; impl crate :: RegisterSpec for TIFR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr1::R](R) reader structure"]
impl crate :: Readable for TIFR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr1::W](W) writer structure"]
impl crate :: Writable for TIFR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR1 to value 0"]
impl crate :: Resettable for TIFR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK1 (rw) register accessor: an alias for `Reg<TIMSK1_SPEC>`"]
pub type TIMSK1 = crate :: Reg < timsk1 :: TIMSK1_SPEC > ; # [doc = "Timer/Counter1 Interrupt Mask Register"]
pub mod timsk1 { # [doc = "Register `TIMSK1` reader"]
pub struct R (crate :: R < TIMSK1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK1` writer"]
pub struct W (crate :: W < TIMSK1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK1_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE1` reader - Timer/Counter1 Overflow Interrupt Enable"]
pub type TOIE1_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE1` writer - Timer/Counter1 Overflow Interrupt Enable"]
pub type TOIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; # [doc = "Field `OCIE1A` reader - Timer/Counter1 Output Compare A Match Interrupt Enable"]
pub type OCIE1A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE1A` writer - Timer/Counter1 Output Compare A Match Interrupt Enable"]
pub type OCIE1A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; # [doc = "Field `OCIE1B` reader - Timer/Counter1 Output Compare B Match Interrupt Enable"]
pub type OCIE1B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE1B` writer - Timer/Counter1 Output Compare B Match Interrupt Enable"]
pub type OCIE1B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; # [doc = "Field `OCIE1C` reader - Timer/Counter1 Output Compare C Match Interrupt Enable"]
pub type OCIE1C_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE1C` writer - Timer/Counter1 Output Compare C Match Interrupt Enable"]
pub type OCIE1C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; # [doc = "Field `ICIE1` reader - Timer/Counter1 Input Capture Interrupt Enable"]
pub type ICIE1_R = crate :: BitReader < bool > ; # [doc = "Field `ICIE1` writer - Timer/Counter1 Input Capture Interrupt Enable"]
pub type ICIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter1 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie1 (& self) -> TOIE1_R { TOIE1_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter1 Output Compare A Match Interrupt Enable"]
# [inline (always)]
pub fn ocie1a (& self) -> OCIE1A_R { OCIE1A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter1 Output Compare B Match Interrupt Enable"]
# [inline (always)]
pub fn ocie1b (& self) -> OCIE1B_R { OCIE1B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter1 Output Compare C Match Interrupt Enable"]
# [inline (always)]
pub fn ocie1c (& self) -> OCIE1C_R { OCIE1C_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter1 Input Capture Interrupt Enable"]
# [inline (always)]
pub fn icie1 (& self) -> ICIE1_R { ICIE1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter1 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie1 (& mut self) -> TOIE1_W < 0 > { TOIE1_W :: new (self) } # [doc = "Bit 1 - Timer/Counter1 Output Compare A Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie1a (& mut self) -> OCIE1A_W < 1 > { OCIE1A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter1 Output Compare B Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie1b (& mut self) -> OCIE1B_W < 2 > { OCIE1B_W :: new (self) } # [doc = "Bit 3 - Timer/Counter1 Output Compare C Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie1c (& mut self) -> OCIE1C_W < 3 > { OCIE1C_W :: new (self) } # [doc = "Bit 5 - Timer/Counter1 Input Capture Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn icie1 (& mut self) -> ICIE1_W < 5 > { ICIE1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter1 Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk1](index.html) module"]
pub struct TIMSK1_SPEC ; impl crate :: RegisterSpec for TIMSK1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk1::R](R) reader structure"]
impl crate :: Readable for TIMSK1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk1::W](W) writer structure"]
impl crate :: Writable for TIMSK1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK1 to value 0"]
impl crate :: Resettable for TIMSK1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 8-bit Async"]
pub struct TC2 { _marker : PhantomData < * const () > } unsafe impl Send for TC2 { } impl TC2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc2 :: RegisterBlock = 0x37 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc2 :: RegisterBlock { Self :: PTR } } impl Deref for TC2 { type Target = tc2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC2") . finish () } } # [doc = "Timer/Counter, 8-bit Async"]
pub mod tc2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter Interrupt Flag Register"]
pub tifr2 : TIFR2 , _reserved1 : [u8 ; 0x0b]
, # [doc = "0x0c - General Timer Counter Control register"]
pub gtccr : GTCCR , _reserved2 : [u8 ; 0x2c]
, # [doc = "0x39 - Timer/Counter Interrupt Mask register"]
pub timsk2 : TIMSK2 , _reserved3 : [u8 ; 0x3f]
, # [doc = "0x79 - Timer/Counter2 Control Register A"]
pub tccr2a : TCCR2A , # [doc = "0x7a - Timer/Counter2 Control Register B"]
pub tccr2b : TCCR2B , # [doc = "0x7b - Timer/Counter2"]
pub tcnt2 : TCNT2 , # [doc = "0x7c - Timer/Counter2 Output Compare Register A"]
pub ocr2a : OCR2A , # [doc = "0x7d - Timer/Counter2 Output Compare Register B"]
pub ocr2b : OCR2B , _reserved8 : [u8 ; 0x01]
, # [doc = "0x7f - Asynchronous Status Register"]
pub assr : ASSR , } # [doc = "ASSR (rw) register accessor: an alias for `Reg<ASSR_SPEC>`"]
pub type ASSR = crate :: Reg < assr :: ASSR_SPEC > ; # [doc = "Asynchronous Status Register"]
pub mod assr { # [doc = "Register `ASSR` reader"]
pub struct R (crate :: R < ASSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASSR` writer"]
pub struct W (crate :: W < ASSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TCR2BUB` reader - Timer/Counter2 Control Register B Update Busy"]
pub type TCR2BUB_R = crate :: BitReader < bool > ; # [doc = "Field `TCR2BUB` writer - Timer/Counter2 Control Register B Update Busy"]
pub type TCR2BUB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `TCR2AUB` reader - Timer/Counter2 Control Register A Update Busy"]
pub type TCR2AUB_R = crate :: BitReader < bool > ; # [doc = "Field `TCR2AUB` writer - Timer/Counter2 Control Register A Update Busy"]
pub type TCR2AUB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `OCR2BUB` reader - Timer/Counter2 Output Compare Register B Update Busy"]
pub type OCR2BUB_R = crate :: BitReader < bool > ; # [doc = "Field `OCR2BUB` writer - Timer/Counter2 Output Compare Register B Update Busy"]
pub type OCR2BUB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `OCR2AUB` reader - Timer/Counter2 Output Compare Register A Update Busy"]
pub type OCR2AUB_R = crate :: BitReader < bool > ; # [doc = "Field `OCR2AUB` writer - Timer/Counter2 Output Compare Register A Update Busy"]
pub type OCR2AUB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `TCN2UB` reader - Timer/Counter2 Update Busy"]
pub type TCN2UB_R = crate :: BitReader < bool > ; # [doc = "Field `TCN2UB` writer - Timer/Counter2 Update Busy"]
pub type TCN2UB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `AS2` reader - Timer/Counter2 Asynchronous Mode"]
pub type AS2_R = crate :: BitReader < bool > ; # [doc = "Field `AS2` writer - Timer/Counter2 Asynchronous Mode"]
pub type AS2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `EXCLK` reader - Enable External Clock Input"]
pub type EXCLK_R = crate :: BitReader < bool > ; # [doc = "Field `EXCLK` writer - Enable External Clock Input"]
pub type EXCLK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `EXCLKAMR` reader - Enable External Clock Input for AMR"]
pub type EXCLKAMR_R = crate :: BitReader < bool > ; # [doc = "Field `EXCLKAMR` writer - Enable External Clock Input for AMR"]
pub type EXCLKAMR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter2 Control Register B Update Busy"]
# [inline (always)]
pub fn tcr2bub (& self) -> TCR2BUB_R { TCR2BUB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter2 Control Register A Update Busy"]
# [inline (always)]
pub fn tcr2aub (& self) -> TCR2AUB_R { TCR2AUB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter2 Output Compare Register B Update Busy"]
# [inline (always)]
pub fn ocr2bub (& self) -> OCR2BUB_R { OCR2BUB_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter2 Output Compare Register A Update Busy"]
# [inline (always)]
pub fn ocr2aub (& self) -> OCR2AUB_R { OCR2AUB_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Timer/Counter2 Update Busy"]
# [inline (always)]
pub fn tcn2ub (& self) -> TCN2UB_R { TCN2UB_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter2 Asynchronous Mode"]
# [inline (always)]
pub fn as2 (& self) -> AS2_R { AS2_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Enable External Clock Input"]
# [inline (always)]
pub fn exclk (& self) -> EXCLK_R { EXCLK_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Enable External Clock Input for AMR"]
# [inline (always)]
pub fn exclkamr (& self) -> EXCLKAMR_R { EXCLKAMR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter2 Control Register B Update Busy"]
# [inline (always)]
# [must_use]
pub fn tcr2bub (& mut self) -> TCR2BUB_W < 0 > { TCR2BUB_W :: new (self) } # [doc = "Bit 1 - Timer/Counter2 Control Register A Update Busy"]
# [inline (always)]
# [must_use]
pub fn tcr2aub (& mut self) -> TCR2AUB_W < 1 > { TCR2AUB_W :: new (self) } # [doc = "Bit 2 - Timer/Counter2 Output Compare Register B Update Busy"]
# [inline (always)]
# [must_use]
pub fn ocr2bub (& mut self) -> OCR2BUB_W < 2 > { OCR2BUB_W :: new (self) } # [doc = "Bit 3 - Timer/Counter2 Output Compare Register A Update Busy"]
# [inline (always)]
# [must_use]
pub fn ocr2aub (& mut self) -> OCR2AUB_W < 3 > { OCR2AUB_W :: new (self) } # [doc = "Bit 4 - Timer/Counter2 Update Busy"]
# [inline (always)]
# [must_use]
pub fn tcn2ub (& mut self) -> TCN2UB_W < 4 > { TCN2UB_W :: new (self) } # [doc = "Bit 5 - Timer/Counter2 Asynchronous Mode"]
# [inline (always)]
# [must_use]
pub fn as2 (& mut self) -> AS2_W < 5 > { AS2_W :: new (self) } # [doc = "Bit 6 - Enable External Clock Input"]
# [inline (always)]
# [must_use]
pub fn exclk (& mut self) -> EXCLK_W < 6 > { EXCLK_W :: new (self) } # [doc = "Bit 7 - Enable External Clock Input for AMR"]
# [inline (always)]
# [must_use]
pub fn exclkamr (& mut self) -> EXCLKAMR_W < 7 > { EXCLKAMR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [assr](index.html) module"]
pub struct ASSR_SPEC ; impl crate :: RegisterSpec for ASSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [assr::R](R) reader structure"]
impl crate :: Readable for ASSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [assr::W](W) writer structure"]
impl crate :: Writable for ASSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASSR to value 0"]
impl crate :: Resettable for ASSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GTCCR (rw) register accessor: an alias for `Reg<GTCCR_SPEC>`"]
pub type GTCCR = crate :: Reg < gtccr :: GTCCR_SPEC > ; # [doc = "General Timer Counter Control register"]
pub mod gtccr { # [doc = "Register `GTCCR` reader"]
pub struct R (crate :: R < GTCCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GTCCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GTCCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `GTCCR` writer"]
pub struct W (crate :: W < GTCCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GTCCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GTCCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PSRASY` reader - Prescaler Reset Timer/Counter2"]
pub type PSRASY_R = crate :: BitReader < bool > ; # [doc = "Field `PSRASY` writer - Prescaler Reset Timer/Counter2"]
pub type PSRASY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; # [doc = "Field `TSM` reader - Timer/Counter Synchronization Mode"]
pub type TSM_R = crate :: BitReader < bool > ; # [doc = "Field `TSM` writer - Timer/Counter Synchronization Mode"]
pub type TSM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - Prescaler Reset Timer/Counter2"]
# [inline (always)]
pub fn psrasy (& self) -> PSRASY_R { PSRASY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
pub fn tsm (& self) -> TSM_R { TSM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 1 - Prescaler Reset Timer/Counter2"]
# [inline (always)]
# [must_use]
pub fn psrasy (& mut self) -> PSRASY_W < 1 > { PSRASY_W :: new (self) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
# [must_use]
pub fn tsm (& mut self) -> TSM_W < 7 > { TSM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Timer Counter Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gtccr](index.html) module"]
pub struct GTCCR_SPEC ; impl crate :: RegisterSpec for GTCCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gtccr::R](R) reader structure"]
impl crate :: Readable for GTCCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gtccr::W](W) writer structure"]
impl crate :: Writable for GTCCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GTCCR to value 0"]
impl crate :: Resettable for GTCCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR2A (rw) register accessor: an alias for `Reg<OCR2A_SPEC>`"]
pub type OCR2A = crate :: Reg < ocr2a :: OCR2A_SPEC > ; # [doc = "Timer/Counter2 Output Compare Register A"]
pub mod ocr2a { # [doc = "Register `OCR2A` reader"]
pub struct R (crate :: R < OCR2A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR2A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR2A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR2A` writer"]
pub struct W (crate :: W < OCR2A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR2A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR2A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter2 Output Compare Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr2a](index.html) module"]
pub struct OCR2A_SPEC ; impl crate :: RegisterSpec for OCR2A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocr2a::R](R) reader structure"]
impl crate :: Readable for OCR2A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr2a::W](W) writer structure"]
impl crate :: Writable for OCR2A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR2A to value 0"]
impl crate :: Resettable for OCR2A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR2B (rw) register accessor: an alias for `Reg<OCR2B_SPEC>`"]
pub type OCR2B = crate :: Reg < ocr2b :: OCR2B_SPEC > ; # [doc = "Timer/Counter2 Output Compare Register B"]
pub mod ocr2b { # [doc = "Register `OCR2B` reader"]
pub struct R (crate :: R < OCR2B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR2B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR2B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR2B` writer"]
pub struct W (crate :: W < OCR2B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR2B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR2B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter2 Output Compare Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr2b](index.html) module"]
pub struct OCR2B_SPEC ; impl crate :: RegisterSpec for OCR2B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocr2b::R](R) reader structure"]
impl crate :: Readable for OCR2B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr2b::W](W) writer structure"]
impl crate :: Writable for OCR2B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR2B to value 0"]
impl crate :: Resettable for OCR2B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR2A (rw) register accessor: an alias for `Reg<TCCR2A_SPEC>`"]
pub type TCCR2A = crate :: Reg < tccr2a :: TCCR2A_SPEC > ; # [doc = "Timer/Counter2 Control Register A"]
pub mod tccr2a { # [doc = "Register `TCCR2A` reader"]
pub struct R (crate :: R < TCCR2A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR2A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR2A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR2A` writer"]
pub struct W (crate :: W < TCCR2A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR2A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR2A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM2` reader - Waveform Generation Mode"]
pub type WGM2_R = crate :: FieldReader < u8 , WGM2_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM2_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, TOP=0xFF"]
PWM_PHASE_CORRECT_TOP_0XFF = 1 , # [doc = "2: CTC, TOP = OCRA"]
CTC_TOP_OCRA = 2 , # [doc = "3: Fast PWM, TOP=0xFF"]
FAST_PWM_TOP_0XFF = 3 , } impl From < WGM2_A > for u8 { # [inline (always)]
fn from (variant : WGM2_A) -> Self { variant as _ } } impl WGM2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM2_A { match self . bits { 0 => WGM2_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM2_A :: PWM_PHASE_CORRECT_TOP_0XFF , 2 => WGM2_A :: CTC_TOP_OCRA , 3 => WGM2_A :: FAST_PWM_TOP_0XFF , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM2_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_TOP_0XFF`"]
# [inline (always)]
pub fn is_pwm_phase_correct_top_0xff (& self) -> bool { * self == WGM2_A :: PWM_PHASE_CORRECT_TOP_0XFF } # [doc = "Checks if the value of the field is `CTC_TOP_OCRA`"]
# [inline (always)]
pub fn is_ctc_top_ocra (& self) -> bool { * self == WGM2_A :: CTC_TOP_OCRA } # [doc = "Checks if the value of the field is `FAST_PWM_TOP_0XFF`"]
# [inline (always)]
pub fn is_fast_pwm_top_0xff (& self) -> bool { * self == WGM2_A :: FAST_PWM_TOP_0XFF } } # [doc = "Field `WGM2` writer - Waveform Generation Mode"]
pub type WGM2_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2A_SPEC , u8 , WGM2_A , 2 , O > ; impl < 'a , const O : u8 > WGM2_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM2_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, TOP=0xFF"]
# [inline (always)]
pub fn pwm_phase_correct_top_0xff (self) -> & 'a mut W { self . variant (WGM2_A :: PWM_PHASE_CORRECT_TOP_0XFF) } # [doc = "CTC, TOP = OCRA"]
# [inline (always)]
pub fn ctc_top_ocra (self) -> & 'a mut W { self . variant (WGM2_A :: CTC_TOP_OCRA) } # [doc = "Fast PWM, TOP=0xFF"]
# [inline (always)]
pub fn fast_pwm_top_0xff (self) -> & 'a mut W { self . variant (WGM2_A :: FAST_PWM_TOP_0XFF) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2A_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `COM2B` reader - Compare Match Output B Mode"]
pub type COM2B_R = crate :: FieldReader < u8 , COM2B_A > ; # [doc = "Compare Match Output B Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM2B_A { # [doc = "0: Normal port operation, OC2B disconnected"]
NORMAL_PORT_OPERATION_OC2B_DISCONNECTED = 0 , # [doc = "1: Toggle OC2B on Compare Match"]
TOGGLE_OC2B_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OC2B on Compare Match"]
CLEAR_OC2B_ON_COMPARE_MATCH = 2 , # [doc = "3: Set OC2B on Compare Match"]
SET_OC2B_ON_COMPARE_MATCH = 3 , } impl From < COM2B_A > for u8 { # [inline (always)]
fn from (variant : COM2B_A) -> Self { variant as _ } } impl COM2B_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM2B_A { match self . bits { 0 => COM2B_A :: NORMAL_PORT_OPERATION_OC2B_DISCONNECTED , 1 => COM2B_A :: TOGGLE_OC2B_ON_COMPARE_MATCH , 2 => COM2B_A :: CLEAR_OC2B_ON_COMPARE_MATCH , 3 => COM2B_A :: SET_OC2B_ON_COMPARE_MATCH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OC2B_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_oc2b_disconnected (& self) -> bool { * self == COM2B_A :: NORMAL_PORT_OPERATION_OC2B_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OC2B_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_oc2b_on_compare_match (& self) -> bool { * self == COM2B_A :: TOGGLE_OC2B_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OC2B_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_clear_oc2b_on_compare_match (& self) -> bool { * self == COM2B_A :: CLEAR_OC2B_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `SET_OC2B_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_set_oc2b_on_compare_match (& self) -> bool { * self == COM2B_A :: SET_OC2B_ON_COMPARE_MATCH } } # [doc = "Field `COM2B` writer - Compare Match Output B Mode"]
pub type COM2B_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2A_SPEC , u8 , COM2B_A , 2 , O > ; impl < 'a , const O : u8 > COM2B_W < 'a , O > { # [doc = "Normal port operation, OC2B disconnected"]
# [inline (always)]
pub fn normal_port_operation_oc2b_disconnected (self) -> & 'a mut W { self . variant (COM2B_A :: NORMAL_PORT_OPERATION_OC2B_DISCONNECTED) } # [doc = "Toggle OC2B on Compare Match"]
# [inline (always)]
pub fn toggle_oc2b_on_compare_match (self) -> & 'a mut W { self . variant (COM2B_A :: TOGGLE_OC2B_ON_COMPARE_MATCH) } # [doc = "Clear OC2B on Compare Match"]
# [inline (always)]
pub fn clear_oc2b_on_compare_match (self) -> & 'a mut W { self . variant (COM2B_A :: CLEAR_OC2B_ON_COMPARE_MATCH) } # [doc = "Set OC2B on Compare Match"]
# [inline (always)]
pub fn set_oc2b_on_compare_match (self) -> & 'a mut W { self . variant (COM2B_A :: SET_OC2B_ON_COMPARE_MATCH) } } # [doc = "Field `COM2A` reader - Compare Match Output A Mode"]
pub type COM2A_R = crate :: FieldReader < u8 , COM2A_A > ; # [doc = "Compare Match Output A Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM2A_A { # [doc = "0: Normal port operation, OC2A disconnected"]
NORMAL_PORT_OPERATION_OC2A_DISCONNECTED = 0 , # [doc = "1: Toggle OC2A on Compare Match"]
TOGGLE_OC2A_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OC2A on Compare Match"]
CLEAR_OC2A_ON_COMPARE_MATCH = 2 , # [doc = "3: Set OC2A on Compare Match"]
SET_OC2A_ON_COMPARE_MATCH = 3 , } impl From < COM2A_A > for u8 { # [inline (always)]
fn from (variant : COM2A_A) -> Self { variant as _ } } impl COM2A_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM2A_A { match self . bits { 0 => COM2A_A :: NORMAL_PORT_OPERATION_OC2A_DISCONNECTED , 1 => COM2A_A :: TOGGLE_OC2A_ON_COMPARE_MATCH , 2 => COM2A_A :: CLEAR_OC2A_ON_COMPARE_MATCH , 3 => COM2A_A :: SET_OC2A_ON_COMPARE_MATCH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OC2A_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_oc2a_disconnected (& self) -> bool { * self == COM2A_A :: NORMAL_PORT_OPERATION_OC2A_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OC2A_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_oc2a_on_compare_match (& self) -> bool { * self == COM2A_A :: TOGGLE_OC2A_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OC2A_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_clear_oc2a_on_compare_match (& self) -> bool { * self == COM2A_A :: CLEAR_OC2A_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `SET_OC2A_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_set_oc2a_on_compare_match (& self) -> bool { * self == COM2A_A :: SET_OC2A_ON_COMPARE_MATCH } } # [doc = "Field `COM2A` writer - Compare Match Output A Mode"]
pub type COM2A_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2A_SPEC , u8 , COM2A_A , 2 , O > ; impl < 'a , const O : u8 > COM2A_W < 'a , O > { # [doc = "Normal port operation, OC2A disconnected"]
# [inline (always)]
pub fn normal_port_operation_oc2a_disconnected (self) -> & 'a mut W { self . variant (COM2A_A :: NORMAL_PORT_OPERATION_OC2A_DISCONNECTED) } # [doc = "Toggle OC2A on Compare Match"]
# [inline (always)]
pub fn toggle_oc2a_on_compare_match (self) -> & 'a mut W { self . variant (COM2A_A :: TOGGLE_OC2A_ON_COMPARE_MATCH) } # [doc = "Clear OC2A on Compare Match"]
# [inline (always)]
pub fn clear_oc2a_on_compare_match (self) -> & 'a mut W { self . variant (COM2A_A :: CLEAR_OC2A_ON_COMPARE_MATCH) } # [doc = "Set OC2A on Compare Match"]
# [inline (always)]
pub fn set_oc2a_on_compare_match (self) -> & 'a mut W { self . variant (COM2A_A :: SET_OC2A_ON_COMPARE_MATCH) } } impl R { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm2 (& self) -> WGM2_R { WGM2_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare Match Output B Mode"]
# [inline (always)]
pub fn com2b (& self) -> COM2B_R { COM2B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Match Output A Mode"]
# [inline (always)]
pub fn com2a (& self) -> COM2A_R { COM2A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm2 (& mut self) -> WGM2_W < 0 > { WGM2_W :: new (self) } # [doc = "Bits 2:3 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 2 > { RES_W :: new (self) } # [doc = "Bits 4:5 - Compare Match Output B Mode"]
# [inline (always)]
# [must_use]
pub fn com2b (& mut self) -> COM2B_W < 4 > { COM2B_W :: new (self) } # [doc = "Bits 6:7 - Compare Match Output A Mode"]
# [inline (always)]
# [must_use]
pub fn com2a (& mut self) -> COM2A_W < 6 > { COM2A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter2 Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr2a](index.html) module"]
pub struct TCCR2A_SPEC ; impl crate :: RegisterSpec for TCCR2A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr2a::R](R) reader structure"]
impl crate :: Readable for TCCR2A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr2a::W](W) writer structure"]
impl crate :: Writable for TCCR2A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR2A to value 0"]
impl crate :: Resettable for TCCR2A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR2B (rw) register accessor: an alias for `Reg<TCCR2B_SPEC>`"]
pub type TCCR2B = crate :: Reg < tccr2b :: TCCR2B_SPEC > ; # [doc = "Timer/Counter2 Control Register B"]
pub mod tccr2b { # [doc = "Register `TCCR2B` reader"]
pub struct R (crate :: R < TCCR2B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR2B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR2B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR2B` writer"]
pub struct W (crate :: W < TCCR2B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR2B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR2B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS2` reader - Clock Select"]
pub type CS2_R = crate :: FieldReader < u8 , CS2_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS2_A { # [doc = "0: No clock source (Timer/Counter2 stopped)"]
NO_CLOCK_SOURCE_TIMER_COUNTER2_STOPPED = 0 , # [doc = "1: clk_T2S/1 (no prescaling)"]
CLK_T2S_1_NO_PRESCALING = 1 , # [doc = "2: clk_T2S/8 (from prescaler)"]
CLK_T2S_8_FROM_PRESCALER = 2 , # [doc = "3: clk_T2S/32 (from prescaler)"]
CLK_T2S_32_FROM_PRESCALER = 3 , # [doc = "4: clk_T2S/64 (from prescaler)"]
CLK_T2S_64_FROM_PRESCALER = 4 , # [doc = "5: clk_T2S/128 (from prescaler)"]
CLK_T2S_128_FROM_PRESCALER = 5 , # [doc = "6: clk_T2S/256 (from prescaler)"]
CLK_T2S_256_FROM_PRESCALER = 6 , # [doc = "7: clk_T2S/1024 (from prescaler)"]
CLK_T2S_1024_FROM_PRESCALER = 7 , } impl From < CS2_A > for u8 { # [inline (always)]
fn from (variant : CS2_A) -> Self { variant as _ } } impl CS2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CS2_A { match self . bits { 0 => CS2_A :: NO_CLOCK_SOURCE_TIMER_COUNTER2_STOPPED , 1 => CS2_A :: CLK_T2S_1_NO_PRESCALING , 2 => CS2_A :: CLK_T2S_8_FROM_PRESCALER , 3 => CS2_A :: CLK_T2S_32_FROM_PRESCALER , 4 => CS2_A :: CLK_T2S_64_FROM_PRESCALER , 5 => CS2_A :: CLK_T2S_128_FROM_PRESCALER , 6 => CS2_A :: CLK_T2S_256_FROM_PRESCALER , 7 => CS2_A :: CLK_T2S_1024_FROM_PRESCALER , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NO_CLOCK_SOURCE_TIMER_COUNTER2_STOPPED`"]
# [inline (always)]
pub fn is_no_clock_source_timer_counter2_stopped (& self) -> bool { * self == CS2_A :: NO_CLOCK_SOURCE_TIMER_COUNTER2_STOPPED } # [doc = "Checks if the value of the field is `CLK_T2S_1_NO_PRESCALING`"]
# [inline (always)]
pub fn is_clk_t2s_1_no_prescaling (& self) -> bool { * self == CS2_A :: CLK_T2S_1_NO_PRESCALING } # [doc = "Checks if the value of the field is `CLK_T2S_8_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_t2s_8_from_prescaler (& self) -> bool { * self == CS2_A :: CLK_T2S_8_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_T2S_32_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_t2s_32_from_prescaler (& self) -> bool { * self == CS2_A :: CLK_T2S_32_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_T2S_64_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_t2s_64_from_prescaler (& self) -> bool { * self == CS2_A :: CLK_T2S_64_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_T2S_128_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_t2s_128_from_prescaler (& self) -> bool { * self == CS2_A :: CLK_T2S_128_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_T2S_256_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_t2s_256_from_prescaler (& self) -> bool { * self == CS2_A :: CLK_T2S_256_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_T2S_1024_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_t2s_1024_from_prescaler (& self) -> bool { * self == CS2_A :: CLK_T2S_1024_FROM_PRESCALER } } # [doc = "Field `CS2` writer - Clock Select"]
pub type CS2_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2B_SPEC , u8 , CS2_A , 3 , O > ; impl < 'a , const O : u8 > CS2_W < 'a , O > { # [doc = "No clock source (Timer/Counter2 stopped)"]
# [inline (always)]
pub fn no_clock_source_timer_counter2_stopped (self) -> & 'a mut W { self . variant (CS2_A :: NO_CLOCK_SOURCE_TIMER_COUNTER2_STOPPED) } # [doc = "clk_T2S/1 (no prescaling)"]
# [inline (always)]
pub fn clk_t2s_1_no_prescaling (self) -> & 'a mut W { self . variant (CS2_A :: CLK_T2S_1_NO_PRESCALING) } # [doc = "clk_T2S/8 (from prescaler)"]
# [inline (always)]
pub fn clk_t2s_8_from_prescaler (self) -> & 'a mut W { self . variant (CS2_A :: CLK_T2S_8_FROM_PRESCALER) } # [doc = "clk_T2S/32 (from prescaler)"]
# [inline (always)]
pub fn clk_t2s_32_from_prescaler (self) -> & 'a mut W { self . variant (CS2_A :: CLK_T2S_32_FROM_PRESCALER) } # [doc = "clk_T2S/64 (from prescaler)"]
# [inline (always)]
pub fn clk_t2s_64_from_prescaler (self) -> & 'a mut W { self . variant (CS2_A :: CLK_T2S_64_FROM_PRESCALER) } # [doc = "clk_T2S/128 (from prescaler)"]
# [inline (always)]
pub fn clk_t2s_128_from_prescaler (self) -> & 'a mut W { self . variant (CS2_A :: CLK_T2S_128_FROM_PRESCALER) } # [doc = "clk_T2S/256 (from prescaler)"]
# [inline (always)]
pub fn clk_t2s_256_from_prescaler (self) -> & 'a mut W { self . variant (CS2_A :: CLK_T2S_256_FROM_PRESCALER) } # [doc = "clk_T2S/1024 (from prescaler)"]
# [inline (always)]
pub fn clk_t2s_1024_from_prescaler (self) -> & 'a mut W { self . variant (CS2_A :: CLK_T2S_1024_FROM_PRESCALER) } } # [doc = "Field `WGM22` reader - Waveform Generation Mode"]
pub type WGM22_R = crate :: BitReader < bool > ; # [doc = "Field `WGM22` writer - Waveform Generation Mode"]
pub type WGM22_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR2B_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2B_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `FOC2B` reader - Force Output Compare B"]
pub type FOC2B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC2B` writer - Force Output Compare B"]
pub type FOC2B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR2B_SPEC , bool , O > ; # [doc = "Field `FOC2A` reader - Force Output Compare A"]
pub type FOC2A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC2A` writer - Force Output Compare A"]
pub type FOC2A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR2B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
pub fn cs2 (& self) -> CS2_R { CS2_R :: new (self . bits & 7) } # [doc = "Bit 3 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm22 (& self) -> WGM22_R { WGM22_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Force Output Compare B"]
# [inline (always)]
pub fn foc2b (& self) -> FOC2B_R { FOC2B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Force Output Compare A"]
# [inline (always)]
pub fn foc2a (& self) -> FOC2A_R { FOC2A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn cs2 (& mut self) -> CS2_W < 0 > { CS2_W :: new (self) } # [doc = "Bit 3 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm22 (& mut self) -> WGM22_W < 3 > { WGM22_W :: new (self) } # [doc = "Bits 4:5 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 4 > { RES_W :: new (self) } # [doc = "Bit 6 - Force Output Compare B"]
# [inline (always)]
# [must_use]
pub fn foc2b (& mut self) -> FOC2B_W < 6 > { FOC2B_W :: new (self) } # [doc = "Bit 7 - Force Output Compare A"]
# [inline (always)]
# [must_use]
pub fn foc2a (& mut self) -> FOC2A_W < 7 > { FOC2A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter2 Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr2b](index.html) module"]
pub struct TCCR2B_SPEC ; impl crate :: RegisterSpec for TCCR2B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr2b::R](R) reader structure"]
impl crate :: Readable for TCCR2B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr2b::W](W) writer structure"]
impl crate :: Writable for TCCR2B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR2B to value 0"]
impl crate :: Resettable for TCCR2B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT2 (rw) register accessor: an alias for `Reg<TCNT2_SPEC>`"]
pub type TCNT2 = crate :: Reg < tcnt2 :: TCNT2_SPEC > ; # [doc = "Timer/Counter2"]
pub mod tcnt2 { # [doc = "Register `TCNT2` reader"]
pub struct R (crate :: R < TCNT2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT2` writer"]
pub struct W (crate :: W < TCNT2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt2](index.html) module"]
pub struct TCNT2_SPEC ; impl crate :: RegisterSpec for TCNT2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tcnt2::R](R) reader structure"]
impl crate :: Readable for TCNT2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt2::W](W) writer structure"]
impl crate :: Writable for TCNT2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT2 to value 0"]
impl crate :: Resettable for TCNT2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR2 (rw) register accessor: an alias for `Reg<TIFR2_SPEC>`"]
pub type TIFR2 = crate :: Reg < tifr2 :: TIFR2_SPEC > ; # [doc = "Timer/Counter Interrupt Flag Register"]
pub mod tifr2 { # [doc = "Register `TIFR2` reader"]
pub struct R (crate :: R < TIFR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR2` writer"]
pub struct W (crate :: W < TIFR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR2_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV2` reader - Timer/Counter2 Overflow Flag"]
pub type TOV2_R = crate :: BitReader < bool > ; # [doc = "Field `TOV2` writer - Timer/Counter2 Overflow Flag"]
pub type TOV2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR2_SPEC , bool , O > ; # [doc = "Field `OCF2A` reader - Output Compare Flag 2 A"]
pub type OCF2A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF2A` writer - Output Compare Flag 2 A"]
pub type OCF2A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR2_SPEC , bool , O > ; # [doc = "Field `OCF2B` reader - Output Compare Flag 2 B"]
pub type OCF2B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF2B` writer - Output Compare Flag 2 B"]
pub type OCF2B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR2_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TIFR2_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bit 0 - Timer/Counter2 Overflow Flag"]
# [inline (always)]
pub fn tov2 (& self) -> TOV2_R { TOV2_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Output Compare Flag 2 A"]
# [inline (always)]
pub fn ocf2a (& self) -> OCF2A_R { OCF2A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Output Compare Flag 2 B"]
# [inline (always)]
pub fn ocf2b (& self) -> OCF2B_R { OCF2B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 3) & 0x1f) } } impl W { # [doc = "Bit 0 - Timer/Counter2 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov2 (& mut self) -> TOV2_W < 0 > { TOV2_W :: new (self) } # [doc = "Bit 1 - Output Compare Flag 2 A"]
# [inline (always)]
# [must_use]
pub fn ocf2a (& mut self) -> OCF2A_W < 1 > { OCF2A_W :: new (self) } # [doc = "Bit 2 - Output Compare Flag 2 B"]
# [inline (always)]
# [must_use]
pub fn ocf2b (& mut self) -> OCF2B_W < 2 > { OCF2B_W :: new (self) } # [doc = "Bits 3:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 3 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr2](index.html) module"]
pub struct TIFR2_SPEC ; impl crate :: RegisterSpec for TIFR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr2::R](R) reader structure"]
impl crate :: Readable for TIFR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr2::W](W) writer structure"]
impl crate :: Writable for TIFR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR2 to value 0"]
impl crate :: Resettable for TIFR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK2 (rw) register accessor: an alias for `Reg<TIMSK2_SPEC>`"]
pub type TIMSK2 = crate :: Reg < timsk2 :: TIMSK2_SPEC > ; # [doc = "Timer/Counter Interrupt Mask register"]
pub mod timsk2 { # [doc = "Register `TIMSK2` reader"]
pub struct R (crate :: R < TIMSK2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK2` writer"]
pub struct W (crate :: W < TIMSK2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK2_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE2` reader - Timer/Counter2 Overflow Interrupt Enable"]
pub type TOIE2_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE2` writer - Timer/Counter2 Overflow Interrupt Enable"]
pub type TOIE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK2_SPEC , bool , O > ; # [doc = "Field `OCIE2A` reader - Timer/Counter2 Output Compare Match A Interrupt Enable"]
pub type OCIE2A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE2A` writer - Timer/Counter2 Output Compare Match A Interrupt Enable"]
pub type OCIE2A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK2_SPEC , bool , O > ; # [doc = "Field `OCIE2B` reader - Timer/Counter2 Output Compare Match B Interrupt Enable"]
pub type OCIE2B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE2B` writer - Timer/Counter2 Output Compare Match B Interrupt Enable"]
pub type OCIE2B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK2_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TIMSK2_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bit 0 - Timer/Counter2 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie2 (& self) -> TOIE2_R { TOIE2_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter2 Output Compare Match A Interrupt Enable"]
# [inline (always)]
pub fn ocie2a (& self) -> OCIE2A_R { OCIE2A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter2 Output Compare Match B Interrupt Enable"]
# [inline (always)]
pub fn ocie2b (& self) -> OCIE2B_R { OCIE2B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:7 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 3) & 0x1f) } } impl W { # [doc = "Bit 0 - Timer/Counter2 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie2 (& mut self) -> TOIE2_W < 0 > { TOIE2_W :: new (self) } # [doc = "Bit 1 - Timer/Counter2 Output Compare Match A Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie2a (& mut self) -> OCIE2A_W < 1 > { OCIE2A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter2 Output Compare Match B Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie2b (& mut self) -> OCIE2B_W < 2 > { OCIE2B_W :: new (self) } # [doc = "Bits 3:7 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 3 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter Interrupt Mask register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk2](index.html) module"]
pub struct TIMSK2_SPEC ; impl crate :: RegisterSpec for TIMSK2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk2::R](R) reader structure"]
impl crate :: Readable for TIMSK2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk2::W](W) writer structure"]
impl crate :: Writable for TIMSK2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK2 to value 0"]
impl crate :: Resettable for TIMSK2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 16-bit"]
pub struct TC3 { _marker : PhantomData < * const () > } unsafe impl Send for TC3 { } impl TC3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc3 :: RegisterBlock = 0x38 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc3 :: RegisterBlock { Self :: PTR } } impl Deref for TC3 { type Target = tc3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC3") . finish () } } # [doc = "Timer/Counter, 16-bit"]
pub mod tc3 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter3 Interrupt Flag Register"]
pub tifr3 : TIFR3 , _reserved1 : [u8 ; 0x38]
, # [doc = "0x39 - Timer/Counter3 Interrupt Mask Register"]
pub timsk3 : TIMSK3 , _reserved2 : [u8 ; 0x1e]
, # [doc = "0x58 - Timer/Counter3 Control Register A"]
pub tccr3a : TCCR3A , # [doc = "0x59 - Timer/Counter3 Control Register B"]
pub tccr3b : TCCR3B , # [doc = "0x5a - Timer/Counter3 Control Register C"]
pub tccr3c : TCCR3C , _reserved5 : [u8 ; 0x01]
, # [doc = "0x5c - Timer/Counter3 Bytes"]
pub tcnt3 : TCNT3 , # [doc = "0x5e - Timer/Counter3 Input Capture Register Bytes"]
pub icr3 : ICR3 , # [doc = "0x60 - Timer/Counter3 Output Compare Register A Bytes"]
pub ocr3a : OCR3A , # [doc = "0x62 - Timer/Counter3 Output Compare Register B Bytes"]
pub ocr3b : OCR3B , # [doc = "0x64 - Timer/Counter3 Output Compare Register C Bytes"]
pub ocr3c : OCR3C , } # [doc = "ICR3 (rw) register accessor: an alias for `Reg<ICR3_SPEC>`"]
pub type ICR3 = crate :: Reg < icr3 :: ICR3_SPEC > ; # [doc = "Timer/Counter3 Input Capture Register Bytes"]
pub mod icr3 { # [doc = "Register `ICR3` reader"]
pub struct R (crate :: R < ICR3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ICR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ICR3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ICR3_SPEC >) -> Self { R (reader) } } # [doc = "Register `ICR3` writer"]
pub struct W (crate :: W < ICR3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ICR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ICR3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ICR3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter3 Input Capture Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr3](index.html) module"]
pub struct ICR3_SPEC ; impl crate :: RegisterSpec for ICR3_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [icr3::R](R) reader structure"]
impl crate :: Readable for ICR3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [icr3::W](W) writer structure"]
impl crate :: Writable for ICR3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ICR3 to value 0"]
impl crate :: Resettable for ICR3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR3A (rw) register accessor: an alias for `Reg<OCR3A_SPEC>`"]
pub type OCR3A = crate :: Reg < ocr3a :: OCR3A_SPEC > ; # [doc = "Timer/Counter3 Output Compare Register A Bytes"]
pub mod ocr3a { # [doc = "Register `OCR3A` reader"]
pub struct R (crate :: R < OCR3A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR3A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR3A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR3A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR3A` writer"]
pub struct W (crate :: W < OCR3A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR3A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR3A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR3A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter3 Output Compare Register A Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr3a](index.html) module"]
pub struct OCR3A_SPEC ; impl crate :: RegisterSpec for OCR3A_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr3a::R](R) reader structure"]
impl crate :: Readable for OCR3A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr3a::W](W) writer structure"]
impl crate :: Writable for OCR3A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR3A to value 0"]
impl crate :: Resettable for OCR3A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR3B (rw) register accessor: an alias for `Reg<OCR3B_SPEC>`"]
pub type OCR3B = crate :: Reg < ocr3b :: OCR3B_SPEC > ; # [doc = "Timer/Counter3 Output Compare Register B Bytes"]
pub mod ocr3b { # [doc = "Register `OCR3B` reader"]
pub struct R (crate :: R < OCR3B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR3B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR3B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR3B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR3B` writer"]
pub struct W (crate :: W < OCR3B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR3B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR3B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR3B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter3 Output Compare Register B Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr3b](index.html) module"]
pub struct OCR3B_SPEC ; impl crate :: RegisterSpec for OCR3B_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr3b::R](R) reader structure"]
impl crate :: Readable for OCR3B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr3b::W](W) writer structure"]
impl crate :: Writable for OCR3B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR3B to value 0"]
impl crate :: Resettable for OCR3B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR3C (rw) register accessor: an alias for `Reg<OCR3C_SPEC>`"]
pub type OCR3C = crate :: Reg < ocr3c :: OCR3C_SPEC > ; # [doc = "Timer/Counter3 Output Compare Register C Bytes"]
pub mod ocr3c { # [doc = "Register `OCR3C` reader"]
pub struct R (crate :: R < OCR3C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR3C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR3C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR3C_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR3C` writer"]
pub struct W (crate :: W < OCR3C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR3C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR3C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR3C_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter3 Output Compare Register C Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr3c](index.html) module"]
pub struct OCR3C_SPEC ; impl crate :: RegisterSpec for OCR3C_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr3c::R](R) reader structure"]
impl crate :: Readable for OCR3C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr3c::W](W) writer structure"]
impl crate :: Writable for OCR3C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR3C to value 0"]
impl crate :: Resettable for OCR3C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR3A (rw) register accessor: an alias for `Reg<TCCR3A_SPEC>`"]
pub type TCCR3A = crate :: Reg < tccr3a :: TCCR3A_SPEC > ; # [doc = "Timer/Counter3 Control Register A"]
pub mod tccr3a { # [doc = "Register `TCCR3A` reader"]
pub struct R (crate :: R < TCCR3A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR3A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR3A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR3A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR3A` writer"]
pub struct W (crate :: W < TCCR3A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR3A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR3A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR3A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM3` reader - Waveform Generation Mode"]
pub type WGM3_R = crate :: FieldReader < u8 , WGM3_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM3_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, 8-bit"]
PWM_PHASE_CORRECT_8_BIT = 1 , # [doc = "2: PWM, phase correct, 9-bit"]
PWM_PHASE_CORRECT_9_BIT = 2 , # [doc = "3: PWM, phase correct, 10-bit"]
PWM_PHASE_CORRECT_10_BIT = 3 , } impl From < WGM3_A > for u8 { # [inline (always)]
fn from (variant : WGM3_A) -> Self { variant as _ } } impl WGM3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM3_A { match self . bits { 0 => WGM3_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM3_A :: PWM_PHASE_CORRECT_8_BIT , 2 => WGM3_A :: PWM_PHASE_CORRECT_9_BIT , 3 => WGM3_A :: PWM_PHASE_CORRECT_10_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM3_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_8_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_8_bit (& self) -> bool { * self == WGM3_A :: PWM_PHASE_CORRECT_8_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_9_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_9_bit (& self) -> bool { * self == WGM3_A :: PWM_PHASE_CORRECT_9_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_10_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_10_bit (& self) -> bool { * self == WGM3_A :: PWM_PHASE_CORRECT_10_BIT } } # [doc = "Field `WGM3` writer - Waveform Generation Mode"]
pub type WGM3_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR3A_SPEC , u8 , WGM3_A , 2 , O > ; impl < 'a , const O : u8 > WGM3_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM3_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, 8-bit"]
# [inline (always)]
pub fn pwm_phase_correct_8_bit (self) -> & 'a mut W { self . variant (WGM3_A :: PWM_PHASE_CORRECT_8_BIT) } # [doc = "PWM, phase correct, 9-bit"]
# [inline (always)]
pub fn pwm_phase_correct_9_bit (self) -> & 'a mut W { self . variant (WGM3_A :: PWM_PHASE_CORRECT_9_BIT) } # [doc = "PWM, phase correct, 10-bit"]
# [inline (always)]
pub fn pwm_phase_correct_10_bit (self) -> & 'a mut W { self . variant (WGM3_A :: PWM_PHASE_CORRECT_10_BIT) } } # [doc = "Field `COM3C` reader - Compare Output Mode for Channel C"]
pub type COM3C_R = crate :: FieldReader < u8 , COM3C_A > ; # [doc = "Compare Output Mode for Channel C\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM3C_A { # [doc = "0: Normal port operation, OCnA/OCnB/OCnC disconnected."]
NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED = 0 , # [doc = "1: Toggle OCnA/OCnB/OCnC on Compare Match."]
TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL = 2 , # [doc = "3: Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL = 3 , } impl From < COM3C_A > for u8 { # [inline (always)]
fn from (variant : COM3C_A) -> Self { variant as _ } } impl COM3C_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM3C_A { match self . bits { 0 => COM3C_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED , 1 => COM3C_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH , 2 => COM3C_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL , 3 => COM3C_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_ocna_ocnb_ocnc_disconnected (& self) -> bool { * self == COM3C_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_ocna_ocnb_ocnc_on_compare_match (& self) -> bool { * self == COM3C_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL`"]
# [inline (always)]
pub fn is_clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (& self) -> bool { * self == COM3C_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL } # [doc = "Checks if the value of the field is `SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL`"]
# [inline (always)]
pub fn is_set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (& self) -> bool { * self == COM3C_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL } } # [doc = "Field `COM3C` writer - Compare Output Mode for Channel C"]
pub type COM3C_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR3A_SPEC , u8 , COM3C_A , 2 , O > ; impl < 'a , const O : u8 > COM3C_W < 'a , O > { # [doc = "Normal port operation, OCnA/OCnB/OCnC disconnected."]
# [inline (always)]
pub fn normal_port_operation_ocna_ocnb_ocnc_disconnected (self) -> & 'a mut W { self . variant (COM3C_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED) } # [doc = "Toggle OCnA/OCnB/OCnC on Compare Match."]
# [inline (always)]
pub fn toggle_ocna_ocnb_ocnc_on_compare_match (self) -> & 'a mut W { self . variant (COM3C_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH) } # [doc = "Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
# [inline (always)]
pub fn clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (self) -> & 'a mut W { self . variant (COM3C_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL) } # [doc = "Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
# [inline (always)]
pub fn set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (self) -> & 'a mut W { self . variant (COM3C_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL) } } # [doc = "Field `COM3B` reader - Compare Output Mode for Channel B"]
pub type COM3B_R = crate :: FieldReader < u8 , COM3B_A > ; # [doc = "Compare Output Mode for Channel B\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM3B_A { # [doc = "0: Normal port operation, OCnA/OCnB/OCnC disconnected."]
NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED = 0 , # [doc = "1: Toggle OCnA/OCnB/OCnC on Compare Match."]
TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL = 2 , # [doc = "3: Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL = 3 , } impl From < COM3B_A > for u8 { # [inline (always)]
fn from (variant : COM3B_A) -> Self { variant as _ } } impl COM3B_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM3B_A { match self . bits { 0 => COM3B_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED , 1 => COM3B_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH , 2 => COM3B_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL , 3 => COM3B_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_ocna_ocnb_ocnc_disconnected (& self) -> bool { * self == COM3B_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_ocna_ocnb_ocnc_on_compare_match (& self) -> bool { * self == COM3B_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL`"]
# [inline (always)]
pub fn is_clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (& self) -> bool { * self == COM3B_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL } # [doc = "Checks if the value of the field is `SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL`"]
# [inline (always)]
pub fn is_set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (& self) -> bool { * self == COM3B_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL } } # [doc = "Field `COM3B` writer - Compare Output Mode for Channel B"]
pub type COM3B_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR3A_SPEC , u8 , COM3B_A , 2 , O > ; impl < 'a , const O : u8 > COM3B_W < 'a , O > { # [doc = "Normal port operation, OCnA/OCnB/OCnC disconnected."]
# [inline (always)]
pub fn normal_port_operation_ocna_ocnb_ocnc_disconnected (self) -> & 'a mut W { self . variant (COM3B_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED) } # [doc = "Toggle OCnA/OCnB/OCnC on Compare Match."]
# [inline (always)]
pub fn toggle_ocna_ocnb_ocnc_on_compare_match (self) -> & 'a mut W { self . variant (COM3B_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH) } # [doc = "Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
# [inline (always)]
pub fn clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (self) -> & 'a mut W { self . variant (COM3B_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL) } # [doc = "Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
# [inline (always)]
pub fn set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (self) -> & 'a mut W { self . variant (COM3B_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL) } } # [doc = "Field `COM3A` reader - Compare Output Mode for Channel A"]
pub type COM3A_R = crate :: FieldReader < u8 , COM3A_A > ; # [doc = "Compare Output Mode for Channel A\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM3A_A { # [doc = "0: Normal port operation, OCnA/OCnB/OCnC disconnected."]
NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED = 0 , # [doc = "1: Toggle OCnA/OCnB/OCnC on Compare Match."]
TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH = 1 , # [doc = "2: Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL = 2 , # [doc = "3: Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL = 3 , } impl From < COM3A_A > for u8 { # [inline (always)]
fn from (variant : COM3A_A) -> Self { variant as _ } } impl COM3A_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COM3A_A { match self . bits { 0 => COM3A_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED , 1 => COM3A_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH , 2 => COM3A_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL , 3 => COM3A_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED`"]
# [inline (always)]
pub fn is_normal_port_operation_ocna_ocnb_ocnc_disconnected (& self) -> bool { * self == COM3A_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED } # [doc = "Checks if the value of the field is `TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH`"]
# [inline (always)]
pub fn is_toggle_ocna_ocnb_ocnc_on_compare_match (& self) -> bool { * self == COM3A_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH } # [doc = "Checks if the value of the field is `CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL`"]
# [inline (always)]
pub fn is_clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (& self) -> bool { * self == COM3A_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL } # [doc = "Checks if the value of the field is `SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL`"]
# [inline (always)]
pub fn is_set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (& self) -> bool { * self == COM3A_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL } } # [doc = "Field `COM3A` writer - Compare Output Mode for Channel A"]
pub type COM3A_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR3A_SPEC , u8 , COM3A_A , 2 , O > ; impl < 'a , const O : u8 > COM3A_W < 'a , O > { # [doc = "Normal port operation, OCnA/OCnB/OCnC disconnected."]
# [inline (always)]
pub fn normal_port_operation_ocna_ocnb_ocnc_disconnected (self) -> & 'a mut W { self . variant (COM3A_A :: NORMAL_PORT_OPERATION_OCNA_OCNB_OCNC_DISCONNECTED) } # [doc = "Toggle OCnA/OCnB/OCnC on Compare Match."]
# [inline (always)]
pub fn toggle_ocna_ocnb_ocnc_on_compare_match (self) -> & 'a mut W { self . variant (COM3A_A :: TOGGLE_OCNA_OCNB_OCNC_ON_COMPARE_MATCH) } # [doc = "Clear OCnA/OCnB/OCnC on Compare Match (set output to low level)."]
# [inline (always)]
pub fn clear_ocna_ocnb_ocnc_on_compare_match_set_output_to_low_level (self) -> & 'a mut W { self . variant (COM3A_A :: CLEAR_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_LOW_LEVEL) } # [doc = "Set OCnA/OCnB/OCnC on Compare Match (set output to high level)."]
# [inline (always)]
pub fn set_ocna_ocnb_ocnc_on_compare_match_set_output_to_high_level (self) -> & 'a mut W { self . variant (COM3A_A :: SET_OCNA_OCNB_OCNC_ON_COMPARE_MATCH_SET_OUTPUT_TO_HIGH_LEVEL) } } impl R { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm3 (& self) -> WGM3_R { WGM3_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare Output Mode for Channel C"]
# [inline (always)]
pub fn com3c (& self) -> COM3C_R { COM3C_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare Output Mode for Channel B"]
# [inline (always)]
pub fn com3b (& self) -> COM3B_R { COM3B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Output Mode for Channel A"]
# [inline (always)]
pub fn com3a (& self) -> COM3A_R { COM3A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm3 (& mut self) -> WGM3_W < 0 > { WGM3_W :: new (self) } # [doc = "Bits 2:3 - Compare Output Mode for Channel C"]
# [inline (always)]
# [must_use]
pub fn com3c (& mut self) -> COM3C_W < 2 > { COM3C_W :: new (self) } # [doc = "Bits 4:5 - Compare Output Mode for Channel B"]
# [inline (always)]
# [must_use]
pub fn com3b (& mut self) -> COM3B_W < 4 > { COM3B_W :: new (self) } # [doc = "Bits 6:7 - Compare Output Mode for Channel A"]
# [inline (always)]
# [must_use]
pub fn com3a (& mut self) -> COM3A_W < 6 > { COM3A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter3 Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr3a](index.html) module"]
pub struct TCCR3A_SPEC ; impl crate :: RegisterSpec for TCCR3A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr3a::R](R) reader structure"]
impl crate :: Readable for TCCR3A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr3a::W](W) writer structure"]
impl crate :: Writable for TCCR3A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR3A to value 0"]
impl crate :: Resettable for TCCR3A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR3B (rw) register accessor: an alias for `Reg<TCCR3B_SPEC>`"]
pub type TCCR3B = crate :: Reg < tccr3b :: TCCR3B_SPEC > ; # [doc = "Timer/Counter3 Control Register B"]
pub mod tccr3b { # [doc = "Register `TCCR3B` reader"]
pub struct R (crate :: R < TCCR3B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR3B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR3B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR3B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR3B` writer"]
pub struct W (crate :: W < TCCR3B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR3B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR3B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR3B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS3` reader - Clock Select"]
pub type CS3_R = crate :: FieldReader < u8 , CS3_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS3_A { # [doc = "0: No clock source (Timer/Counter stopped)"]
NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED = 0 , # [doc = "1: clk_IO/1 (no prescaling)"]
CLK_IO_1_NO_PRESCALING = 1 , # [doc = "2: clk_IO/8 (from prescaler)"]
CLK_IO_8_FROM_PRESCALER = 2 , # [doc = "3: clk_IO/64 (from prescaler)"]
CLK_IO_64_FROM_PRESCALER = 3 , # [doc = "4: clk_IO/256 (from prescaler)"]
CLK_IO_256_FROM_PRESCALER = 4 , # [doc = "5: clk_IO/1024 (from prescaler)"]
CLK_IO_1024_FROM_PRESCALER = 5 , # [doc = "6: External clock source on Tn pin, clock on falling edge"]
EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE = 6 , # [doc = "7: External clock source on Tn pin, clock on rising edge"]
EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE = 7 , } impl From < CS3_A > for u8 { # [inline (always)]
fn from (variant : CS3_A) -> Self { variant as _ } } impl CS3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CS3_A { match self . bits { 0 => CS3_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED , 1 => CS3_A :: CLK_IO_1_NO_PRESCALING , 2 => CS3_A :: CLK_IO_8_FROM_PRESCALER , 3 => CS3_A :: CLK_IO_64_FROM_PRESCALER , 4 => CS3_A :: CLK_IO_256_FROM_PRESCALER , 5 => CS3_A :: CLK_IO_1024_FROM_PRESCALER , 6 => CS3_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE , 7 => CS3_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED`"]
# [inline (always)]
pub fn is_no_clock_source_timer_counter_stopped (& self) -> bool { * self == CS3_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED } # [doc = "Checks if the value of the field is `CLK_IO_1_NO_PRESCALING`"]
# [inline (always)]
pub fn is_clk_io_1_no_prescaling (& self) -> bool { * self == CS3_A :: CLK_IO_1_NO_PRESCALING } # [doc = "Checks if the value of the field is `CLK_IO_8_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_8_from_prescaler (& self) -> bool { * self == CS3_A :: CLK_IO_8_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_64_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_64_from_prescaler (& self) -> bool { * self == CS3_A :: CLK_IO_64_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_256_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_256_from_prescaler (& self) -> bool { * self == CS3_A :: CLK_IO_256_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_1024_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_1024_from_prescaler (& self) -> bool { * self == CS3_A :: CLK_IO_1024_FROM_PRESCALER } # [doc = "Checks if the value of the field is `EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE`"]
# [inline (always)]
pub fn is_external_clock_source_on_tn_pin_clock_on_falling_edge (& self) -> bool { * self == CS3_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE } # [doc = "Checks if the value of the field is `EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE`"]
# [inline (always)]
pub fn is_external_clock_source_on_tn_pin_clock_on_rising_edge (& self) -> bool { * self == CS3_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE } } # [doc = "Field `CS3` writer - Clock Select"]
pub type CS3_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR3B_SPEC , u8 , CS3_A , 3 , O > ; impl < 'a , const O : u8 > CS3_W < 'a , O > { # [doc = "No clock source (Timer/Counter stopped)"]
# [inline (always)]
pub fn no_clock_source_timer_counter_stopped (self) -> & 'a mut W { self . variant (CS3_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED) } # [doc = "clk_IO/1 (no prescaling)"]
# [inline (always)]
pub fn clk_io_1_no_prescaling (self) -> & 'a mut W { self . variant (CS3_A :: CLK_IO_1_NO_PRESCALING) } # [doc = "clk_IO/8 (from prescaler)"]
# [inline (always)]
pub fn clk_io_8_from_prescaler (self) -> & 'a mut W { self . variant (CS3_A :: CLK_IO_8_FROM_PRESCALER) } # [doc = "clk_IO/64 (from prescaler)"]
# [inline (always)]
pub fn clk_io_64_from_prescaler (self) -> & 'a mut W { self . variant (CS3_A :: CLK_IO_64_FROM_PRESCALER) } # [doc = "clk_IO/256 (from prescaler)"]
# [inline (always)]
pub fn clk_io_256_from_prescaler (self) -> & 'a mut W { self . variant (CS3_A :: CLK_IO_256_FROM_PRESCALER) } # [doc = "clk_IO/1024 (from prescaler)"]
# [inline (always)]
pub fn clk_io_1024_from_prescaler (self) -> & 'a mut W { self . variant (CS3_A :: CLK_IO_1024_FROM_PRESCALER) } # [doc = "External clock source on Tn pin, clock on falling edge"]
# [inline (always)]
pub fn external_clock_source_on_tn_pin_clock_on_falling_edge (self) -> & 'a mut W { self . variant (CS3_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_FALLING_EDGE) } # [doc = "External clock source on Tn pin, clock on rising edge"]
# [inline (always)]
pub fn external_clock_source_on_tn_pin_clock_on_rising_edge (self) -> & 'a mut W { self . variant (CS3_A :: EXTERNAL_CLOCK_SOURCE_ON_TN_PIN_CLOCK_ON_RISING_EDGE) } } # [doc = "Field `WGM3` reader - Waveform Generation Mode"]
pub type WGM3_R = crate :: FieldReader < u8 , WGM3_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM3_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, 8-bit"]
PWM_PHASE_CORRECT_8_BIT = 1 , # [doc = "2: PWM, phase correct, 9-bit"]
PWM_PHASE_CORRECT_9_BIT = 2 , # [doc = "3: PWM, phase correct, 10-bit"]
PWM_PHASE_CORRECT_10_BIT = 3 , } impl From < WGM3_A > for u8 { # [inline (always)]
fn from (variant : WGM3_A) -> Self { variant as _ } } impl WGM3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM3_A { match self . bits { 0 => WGM3_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM3_A :: PWM_PHASE_CORRECT_8_BIT , 2 => WGM3_A :: PWM_PHASE_CORRECT_9_BIT , 3 => WGM3_A :: PWM_PHASE_CORRECT_10_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM3_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_8_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_8_bit (& self) -> bool { * self == WGM3_A :: PWM_PHASE_CORRECT_8_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_9_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_9_bit (& self) -> bool { * self == WGM3_A :: PWM_PHASE_CORRECT_9_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_10_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_10_bit (& self) -> bool { * self == WGM3_A :: PWM_PHASE_CORRECT_10_BIT } } # [doc = "Field `WGM3` writer - Waveform Generation Mode"]
pub type WGM3_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR3B_SPEC , u8 , WGM3_A , 2 , O > ; impl < 'a , const O : u8 > WGM3_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM3_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, 8-bit"]
# [inline (always)]
pub fn pwm_phase_correct_8_bit (self) -> & 'a mut W { self . variant (WGM3_A :: PWM_PHASE_CORRECT_8_BIT) } # [doc = "PWM, phase correct, 9-bit"]
# [inline (always)]
pub fn pwm_phase_correct_9_bit (self) -> & 'a mut W { self . variant (WGM3_A :: PWM_PHASE_CORRECT_9_BIT) } # [doc = "PWM, phase correct, 10-bit"]
# [inline (always)]
pub fn pwm_phase_correct_10_bit (self) -> & 'a mut W { self . variant (WGM3_A :: PWM_PHASE_CORRECT_10_BIT) } } # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR3B_SPEC , bool , O > ; # [doc = "Field `ICES3` reader - Input Capture 3 Edge Select"]
pub type ICES3_R = crate :: BitReader < bool > ; # [doc = "Field `ICES3` writer - Input Capture 3 Edge Select"]
pub type ICES3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR3B_SPEC , bool , O > ; # [doc = "Field `ICNC3` reader - Input Capture 3 Noise Canceller"]
pub type ICNC3_R = crate :: BitReader < bool > ; # [doc = "Field `ICNC3` writer - Input Capture 3 Noise Canceller"]
pub type ICNC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR3B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
pub fn cs3 (& self) -> CS3_R { CS3_R :: new (self . bits & 7) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm3 (& self) -> WGM3_R { WGM3_R :: new ((self . bits >> 3) & 3) } # [doc = "Bit 5 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Input Capture 3 Edge Select"]
# [inline (always)]
pub fn ices3 (& self) -> ICES3_R { ICES3_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Input Capture 3 Noise Canceller"]
# [inline (always)]
pub fn icnc3 (& self) -> ICNC3_R { ICNC3_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn cs3 (& mut self) -> CS3_W < 0 > { CS3_W :: new (self) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm3 (& mut self) -> WGM3_W < 3 > { WGM3_W :: new (self) } # [doc = "Bit 5 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 5 > { RES_W :: new (self) } # [doc = "Bit 6 - Input Capture 3 Edge Select"]
# [inline (always)]
# [must_use]
pub fn ices3 (& mut self) -> ICES3_W < 6 > { ICES3_W :: new (self) } # [doc = "Bit 7 - Input Capture 3 Noise Canceller"]
# [inline (always)]
# [must_use]
pub fn icnc3 (& mut self) -> ICNC3_W < 7 > { ICNC3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter3 Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr3b](index.html) module"]
pub struct TCCR3B_SPEC ; impl crate :: RegisterSpec for TCCR3B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr3b::R](R) reader structure"]
impl crate :: Readable for TCCR3B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr3b::W](W) writer structure"]
impl crate :: Writable for TCCR3B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR3B to value 0"]
impl crate :: Resettable for TCCR3B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR3C (rw) register accessor: an alias for `Reg<TCCR3C_SPEC>`"]
pub type TCCR3C = crate :: Reg < tccr3c :: TCCR3C_SPEC > ; # [doc = "Timer/Counter3 Control Register C"]
pub mod tccr3c { # [doc = "Register `TCCR3C` reader"]
pub struct R (crate :: R < TCCR3C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR3C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR3C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR3C_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR3C` writer"]
pub struct W (crate :: W < TCCR3C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR3C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR3C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR3C_SPEC >) -> Self { W (writer) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR3C_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `FOC3C` reader - Force Output Compare for Channel C"]
pub type FOC3C_R = crate :: BitReader < bool > ; # [doc = "Field `FOC3C` writer - Force Output Compare for Channel C"]
pub type FOC3C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR3C_SPEC , bool , O > ; # [doc = "Field `FOC3B` reader - Force Output Compare for Channel B"]
pub type FOC3B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC3B` writer - Force Output Compare for Channel B"]
pub type FOC3B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR3C_SPEC , bool , O > ; # [doc = "Field `FOC3A` reader - Force Output Compare for Channel A"]
pub type FOC3A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC3A` writer - Force Output Compare for Channel A"]
pub type FOC3A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR3C_SPEC , bool , O > ; impl R { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (self . bits & 0x1f) } # [doc = "Bit 5 - Force Output Compare for Channel C"]
# [inline (always)]
pub fn foc3c (& self) -> FOC3C_R { FOC3C_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Force Output Compare for Channel B"]
# [inline (always)]
pub fn foc3b (& self) -> FOC3B_R { FOC3B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Force Output Compare for Channel A"]
# [inline (always)]
pub fn foc3a (& self) -> FOC3A_R { FOC3A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 0 > { RES_W :: new (self) } # [doc = "Bit 5 - Force Output Compare for Channel C"]
# [inline (always)]
# [must_use]
pub fn foc3c (& mut self) -> FOC3C_W < 5 > { FOC3C_W :: new (self) } # [doc = "Bit 6 - Force Output Compare for Channel B"]
# [inline (always)]
# [must_use]
pub fn foc3b (& mut self) -> FOC3B_W < 6 > { FOC3B_W :: new (self) } # [doc = "Bit 7 - Force Output Compare for Channel A"]
# [inline (always)]
# [must_use]
pub fn foc3a (& mut self) -> FOC3A_W < 7 > { FOC3A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter3 Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr3c](index.html) module"]
pub struct TCCR3C_SPEC ; impl crate :: RegisterSpec for TCCR3C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr3c::R](R) reader structure"]
impl crate :: Readable for TCCR3C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr3c::W](W) writer structure"]
impl crate :: Writable for TCCR3C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR3C to value 0"]
impl crate :: Resettable for TCCR3C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT3 (rw) register accessor: an alias for `Reg<TCNT3_SPEC>`"]
pub type TCNT3 = crate :: Reg < tcnt3 :: TCNT3_SPEC > ; # [doc = "Timer/Counter3 Bytes"]
pub mod tcnt3 { # [doc = "Register `TCNT3` reader"]
pub struct R (crate :: R < TCNT3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT3_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT3` writer"]
pub struct W (crate :: W < TCNT3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter3 Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt3](index.html) module"]
pub struct TCNT3_SPEC ; impl crate :: RegisterSpec for TCNT3_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [tcnt3::R](R) reader structure"]
impl crate :: Readable for TCNT3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt3::W](W) writer structure"]
impl crate :: Writable for TCNT3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT3 to value 0"]
impl crate :: Resettable for TCNT3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR3 (rw) register accessor: an alias for `Reg<TIFR3_SPEC>`"]
pub type TIFR3 = crate :: Reg < tifr3 :: TIFR3_SPEC > ; # [doc = "Timer/Counter3 Interrupt Flag Register"]
pub mod tifr3 { # [doc = "Register `TIFR3` reader"]
pub struct R (crate :: R < TIFR3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR3_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR3` writer"]
pub struct W (crate :: W < TIFR3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR3_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV3` reader - Timer/Counter3 Overflow Flag"]
pub type TOV3_R = crate :: BitReader < bool > ; # [doc = "Field `TOV3` writer - Timer/Counter3 Overflow Flag"]
pub type TOV3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR3_SPEC , bool , O > ; # [doc = "Field `OCF3A` reader - Timer/Counter3 Output Compare A Match Flag"]
pub type OCF3A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF3A` writer - Timer/Counter3 Output Compare A Match Flag"]
pub type OCF3A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR3_SPEC , bool , O > ; # [doc = "Field `OCF3B` reader - Timer/Counter3 Output Compare B Match Flag"]
pub type OCF3B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF3B` writer - Timer/Counter3 Output Compare B Match Flag"]
pub type OCF3B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR3_SPEC , bool , O > ; # [doc = "Field `OCF3C` reader - Timer/Counter3 Output Compare C Match Flag"]
pub type OCF3C_R = crate :: BitReader < bool > ; # [doc = "Field `OCF3C` writer - Timer/Counter3 Output Compare C Match Flag"]
pub type OCF3C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR3_SPEC , bool , O > ; # [doc = "Field `ICF3` reader - Timer/Counter3 Input Capture Flag"]
pub type ICF3_R = crate :: BitReader < bool > ; # [doc = "Field `ICF3` writer - Timer/Counter3 Input Capture Flag"]
pub type ICF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR3_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter3 Overflow Flag"]
# [inline (always)]
pub fn tov3 (& self) -> TOV3_R { TOV3_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter3 Output Compare A Match Flag"]
# [inline (always)]
pub fn ocf3a (& self) -> OCF3A_R { OCF3A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter3 Output Compare B Match Flag"]
# [inline (always)]
pub fn ocf3b (& self) -> OCF3B_R { OCF3B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter3 Output Compare C Match Flag"]
# [inline (always)]
pub fn ocf3c (& self) -> OCF3C_R { OCF3C_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter3 Input Capture Flag"]
# [inline (always)]
pub fn icf3 (& self) -> ICF3_R { ICF3_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter3 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov3 (& mut self) -> TOV3_W < 0 > { TOV3_W :: new (self) } # [doc = "Bit 1 - Timer/Counter3 Output Compare A Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf3a (& mut self) -> OCF3A_W < 1 > { OCF3A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter3 Output Compare B Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf3b (& mut self) -> OCF3B_W < 2 > { OCF3B_W :: new (self) } # [doc = "Bit 3 - Timer/Counter3 Output Compare C Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf3c (& mut self) -> OCF3C_W < 3 > { OCF3C_W :: new (self) } # [doc = "Bit 5 - Timer/Counter3 Input Capture Flag"]
# [inline (always)]
# [must_use]
pub fn icf3 (& mut self) -> ICF3_W < 5 > { ICF3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter3 Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr3](index.html) module"]
pub struct TIFR3_SPEC ; impl crate :: RegisterSpec for TIFR3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr3::R](R) reader structure"]
impl crate :: Readable for TIFR3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr3::W](W) writer structure"]
impl crate :: Writable for TIFR3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR3 to value 0"]
impl crate :: Resettable for TIFR3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK3 (rw) register accessor: an alias for `Reg<TIMSK3_SPEC>`"]
pub type TIMSK3 = crate :: Reg < timsk3 :: TIMSK3_SPEC > ; # [doc = "Timer/Counter3 Interrupt Mask Register"]
pub mod timsk3 { # [doc = "Register `TIMSK3` reader"]
pub struct R (crate :: R < TIMSK3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK3_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK3` writer"]
pub struct W (crate :: W < TIMSK3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK3_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE3` reader - Timer/Counter3 Overflow Interrupt Enable"]
pub type TOIE3_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE3` writer - Timer/Counter3 Overflow Interrupt Enable"]
pub type TOIE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK3_SPEC , bool , O > ; # [doc = "Field `OCIE3A` reader - Timer/Counter3 Output Compare A Match Interrupt Enable"]
pub type OCIE3A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE3A` writer - Timer/Counter3 Output Compare A Match Interrupt Enable"]
pub type OCIE3A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK3_SPEC , bool , O > ; # [doc = "Field `OCIE3B` reader - Timer/Counter3 Output Compare B Match Interrupt Enable"]
pub type OCIE3B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE3B` writer - Timer/Counter3 Output Compare B Match Interrupt Enable"]
pub type OCIE3B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK3_SPEC , bool , O > ; # [doc = "Field `OCIE3C` reader - Timer/Counter3 Output Compare C Match Interrupt Enable"]
pub type OCIE3C_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE3C` writer - Timer/Counter3 Output Compare C Match Interrupt Enable"]
pub type OCIE3C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK3_SPEC , bool , O > ; # [doc = "Field `ICIE3` reader - Timer/Counter3 Input Capture Interrupt Enable"]
pub type ICIE3_R = crate :: BitReader < bool > ; # [doc = "Field `ICIE3` writer - Timer/Counter3 Input Capture Interrupt Enable"]
pub type ICIE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK3_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter3 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie3 (& self) -> TOIE3_R { TOIE3_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter3 Output Compare A Match Interrupt Enable"]
# [inline (always)]
pub fn ocie3a (& self) -> OCIE3A_R { OCIE3A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter3 Output Compare B Match Interrupt Enable"]
# [inline (always)]
pub fn ocie3b (& self) -> OCIE3B_R { OCIE3B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter3 Output Compare C Match Interrupt Enable"]
# [inline (always)]
pub fn ocie3c (& self) -> OCIE3C_R { OCIE3C_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter3 Input Capture Interrupt Enable"]
# [inline (always)]
pub fn icie3 (& self) -> ICIE3_R { ICIE3_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter3 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie3 (& mut self) -> TOIE3_W < 0 > { TOIE3_W :: new (self) } # [doc = "Bit 1 - Timer/Counter3 Output Compare A Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie3a (& mut self) -> OCIE3A_W < 1 > { OCIE3A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter3 Output Compare B Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie3b (& mut self) -> OCIE3B_W < 2 > { OCIE3B_W :: new (self) } # [doc = "Bit 3 - Timer/Counter3 Output Compare C Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie3c (& mut self) -> OCIE3C_W < 3 > { OCIE3C_W :: new (self) } # [doc = "Bit 5 - Timer/Counter3 Input Capture Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn icie3 (& mut self) -> ICIE3_W < 5 > { ICIE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter3 Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk3](index.html) module"]
pub struct TIMSK3_SPEC ; impl crate :: RegisterSpec for TIMSK3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk3::R](R) reader structure"]
impl crate :: Readable for TIMSK3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk3::W](W) writer structure"]
impl crate :: Writable for TIMSK3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK3 to value 0"]
impl crate :: Resettable for TIMSK3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 16-bit"]
pub struct TC4 { _marker : PhantomData < * const () > } unsafe impl Send for TC4 { } impl TC4 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc4 :: RegisterBlock = 0x39 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc4 :: RegisterBlock { Self :: PTR } } impl Deref for TC4 { type Target = tc4 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC4") . finish () } } # [doc = "Timer/Counter, 16-bit"]
pub mod tc4 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter4 Interrupt Flag Register"]
pub tifr4 : TIFR4 , _reserved1 : [u8 ; 0x38]
, # [doc = "0x39 - Timer/Counter4 Interrupt Mask Register"]
pub timsk4 : TIMSK4 , _reserved2 : [u8 ; 0x2d]
, # [doc = "0x67 - Timer/Counter4 Control Register A"]
pub tccr4a : TCCR4A , # [doc = "0x68 - Timer/Counter4 Control Register B"]
pub tccr4b : TCCR4B , # [doc = "0x69 - Timer/Counter4 Control Register C"]
pub tccr4c : TCCR4C , _reserved5 : [u8 ; 0x01]
, # [doc = "0x6b - Timer/Counter4 Bytes"]
pub tcnt4 : TCNT4 , # [doc = "0x6d - Timer/Counter4 Input Capture Register Bytes"]
pub icr4 : ICR4 , # [doc = "0x6f - Timer/Counter4 Output Compare Register A Bytes"]
pub ocr4a : OCR4A , # [doc = "0x71 - Timer/Counter4 Output Compare Register B Bytes"]
pub ocr4b : OCR4B , # [doc = "0x73 - Timer/Counter4 Output Compare Register C Bytes"]
pub ocr4c : OCR4C , } # [doc = "ICR4 (rw) register accessor: an alias for `Reg<ICR4_SPEC>`"]
pub type ICR4 = crate :: Reg < icr4 :: ICR4_SPEC > ; # [doc = "Timer/Counter4 Input Capture Register Bytes"]
pub mod icr4 { # [doc = "Register `ICR4` reader"]
pub struct R (crate :: R < ICR4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ICR4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ICR4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ICR4_SPEC >) -> Self { R (reader) } } # [doc = "Register `ICR4` writer"]
pub struct W (crate :: W < ICR4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ICR4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ICR4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ICR4_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter4 Input Capture Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr4](index.html) module"]
pub struct ICR4_SPEC ; impl crate :: RegisterSpec for ICR4_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [icr4::R](R) reader structure"]
impl crate :: Readable for ICR4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [icr4::W](W) writer structure"]
impl crate :: Writable for ICR4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ICR4 to value 0"]
impl crate :: Resettable for ICR4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR4A (rw) register accessor: an alias for `Reg<OCR4A_SPEC>`"]
pub type OCR4A = crate :: Reg < ocr4a :: OCR4A_SPEC > ; # [doc = "Timer/Counter4 Output Compare Register A Bytes"]
pub mod ocr4a { # [doc = "Register `OCR4A` reader"]
pub struct R (crate :: R < OCR4A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR4A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR4A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR4A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR4A` writer"]
pub struct W (crate :: W < OCR4A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR4A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR4A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR4A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter4 Output Compare Register A Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr4a](index.html) module"]
pub struct OCR4A_SPEC ; impl crate :: RegisterSpec for OCR4A_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr4a::R](R) reader structure"]
impl crate :: Readable for OCR4A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr4a::W](W) writer structure"]
impl crate :: Writable for OCR4A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR4A to value 0"]
impl crate :: Resettable for OCR4A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR4B (rw) register accessor: an alias for `Reg<OCR4B_SPEC>`"]
pub type OCR4B = crate :: Reg < ocr4b :: OCR4B_SPEC > ; # [doc = "Timer/Counter4 Output Compare Register B Bytes"]
pub mod ocr4b { # [doc = "Register `OCR4B` reader"]
pub struct R (crate :: R < OCR4B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR4B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR4B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR4B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR4B` writer"]
pub struct W (crate :: W < OCR4B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR4B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR4B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR4B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter4 Output Compare Register B Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr4b](index.html) module"]
pub struct OCR4B_SPEC ; impl crate :: RegisterSpec for OCR4B_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr4b::R](R) reader structure"]
impl crate :: Readable for OCR4B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr4b::W](W) writer structure"]
impl crate :: Writable for OCR4B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR4B to value 0"]
impl crate :: Resettable for OCR4B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR4C (rw) register accessor: an alias for `Reg<OCR4C_SPEC>`"]
pub type OCR4C = crate :: Reg < ocr4c :: OCR4C_SPEC > ; # [doc = "Timer/Counter4 Output Compare Register C Bytes"]
pub mod ocr4c { # [doc = "Register `OCR4C` reader"]
pub struct R (crate :: R < OCR4C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR4C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR4C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR4C_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR4C` writer"]
pub struct W (crate :: W < OCR4C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR4C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR4C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR4C_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter4 Output Compare Register C Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr4c](index.html) module"]
pub struct OCR4C_SPEC ; impl crate :: RegisterSpec for OCR4C_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr4c::R](R) reader structure"]
impl crate :: Readable for OCR4C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr4c::W](W) writer structure"]
impl crate :: Writable for OCR4C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR4C to value 0"]
impl crate :: Resettable for OCR4C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR4A (rw) register accessor: an alias for `Reg<TCCR4A_SPEC>`"]
pub type TCCR4A = crate :: Reg < tccr4a :: TCCR4A_SPEC > ; # [doc = "Timer/Counter4 Control Register A"]
pub mod tccr4a { # [doc = "Register `TCCR4A` reader"]
pub struct R (crate :: R < TCCR4A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR4A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR4A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR4A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR4A` writer"]
pub struct W (crate :: W < TCCR4A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR4A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR4A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR4A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM4` reader - Waveform Generation Mode"]
pub type WGM4_R = crate :: FieldReader < u8 , WGM4_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM4_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, 8-bit"]
PWM_PHASE_CORRECT_8_BIT = 1 , # [doc = "2: PWM, phase correct, 9-bit"]
PWM_PHASE_CORRECT_9_BIT = 2 , # [doc = "3: PWM, phase correct, 10-bit"]
PWM_PHASE_CORRECT_10_BIT = 3 , } impl From < WGM4_A > for u8 { # [inline (always)]
fn from (variant : WGM4_A) -> Self { variant as _ } } impl WGM4_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM4_A { match self . bits { 0 => WGM4_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM4_A :: PWM_PHASE_CORRECT_8_BIT , 2 => WGM4_A :: PWM_PHASE_CORRECT_9_BIT , 3 => WGM4_A :: PWM_PHASE_CORRECT_10_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM4_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_8_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_8_bit (& self) -> bool { * self == WGM4_A :: PWM_PHASE_CORRECT_8_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_9_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_9_bit (& self) -> bool { * self == WGM4_A :: PWM_PHASE_CORRECT_9_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_10_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_10_bit (& self) -> bool { * self == WGM4_A :: PWM_PHASE_CORRECT_10_BIT } } # [doc = "Field `WGM4` writer - Waveform Generation Mode"]
pub type WGM4_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR4A_SPEC , u8 , WGM4_A , 2 , O > ; impl < 'a , const O : u8 > WGM4_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM4_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, 8-bit"]
# [inline (always)]
pub fn pwm_phase_correct_8_bit (self) -> & 'a mut W { self . variant (WGM4_A :: PWM_PHASE_CORRECT_8_BIT) } # [doc = "PWM, phase correct, 9-bit"]
# [inline (always)]
pub fn pwm_phase_correct_9_bit (self) -> & 'a mut W { self . variant (WGM4_A :: PWM_PHASE_CORRECT_9_BIT) } # [doc = "PWM, phase correct, 10-bit"]
# [inline (always)]
pub fn pwm_phase_correct_10_bit (self) -> & 'a mut W { self . variant (WGM4_A :: PWM_PHASE_CORRECT_10_BIT) } } # [doc = "Field `COM4C` reader - Compare Output Mode for Channel C"]
pub type COM4C_R = crate :: FieldReader < u8 , COM4C_A > ; # [doc = "Compare Output Mode for Channel C\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM4C_A { # [doc = "0: Normal operation"]
NORMAL_OPERATION = 0 , } impl From < COM4C_A > for u8 { # [inline (always)]
fn from (variant : COM4C_A) -> Self { variant as _ } } impl COM4C_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < COM4C_A > { match self . bits { 0 => Some (COM4C_A :: NORMAL_OPERATION) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL_OPERATION`"]
# [inline (always)]
pub fn is_normal_operation (& self) -> bool { * self == COM4C_A :: NORMAL_OPERATION } } # [doc = "Field `COM4C` writer - Compare Output Mode for Channel C"]
pub type COM4C_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCCR4A_SPEC , u8 , COM4C_A , 2 , O > ; impl < 'a , const O : u8 > COM4C_W < 'a , O > { # [doc = "Normal operation"]
# [inline (always)]
pub fn normal_operation (self) -> & 'a mut W { self . variant (COM4C_A :: NORMAL_OPERATION) } } # [doc = "Field `COM4B` reader - Compare Output Mode for Channel B"]
pub type COM4B_R = crate :: FieldReader < u8 , COM4B_A > ; # [doc = "Compare Output Mode for Channel B\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM4B_A { # [doc = "0: Normal operation"]
NORMAL_OPERATION = 0 , } impl From < COM4B_A > for u8 { # [inline (always)]
fn from (variant : COM4B_A) -> Self { variant as _ } } impl COM4B_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < COM4B_A > { match self . bits { 0 => Some (COM4B_A :: NORMAL_OPERATION) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL_OPERATION`"]
# [inline (always)]
pub fn is_normal_operation (& self) -> bool { * self == COM4B_A :: NORMAL_OPERATION } } # [doc = "Field `COM4B` writer - Compare Output Mode for Channel B"]
pub type COM4B_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCCR4A_SPEC , u8 , COM4B_A , 2 , O > ; impl < 'a , const O : u8 > COM4B_W < 'a , O > { # [doc = "Normal operation"]
# [inline (always)]
pub fn normal_operation (self) -> & 'a mut W { self . variant (COM4B_A :: NORMAL_OPERATION) } } # [doc = "Field `COM4A` reader - Compare Output Mode for Channel A"]
pub type COM4A_R = crate :: FieldReader < u8 , COM4A_A > ; # [doc = "Compare Output Mode for Channel A\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM4A_A { # [doc = "0: Normal operation"]
NORMAL_OPERATION = 0 , } impl From < COM4A_A > for u8 { # [inline (always)]
fn from (variant : COM4A_A) -> Self { variant as _ } } impl COM4A_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < COM4A_A > { match self . bits { 0 => Some (COM4A_A :: NORMAL_OPERATION) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL_OPERATION`"]
# [inline (always)]
pub fn is_normal_operation (& self) -> bool { * self == COM4A_A :: NORMAL_OPERATION } } # [doc = "Field `COM4A` writer - Compare Output Mode for Channel A"]
pub type COM4A_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCCR4A_SPEC , u8 , COM4A_A , 2 , O > ; impl < 'a , const O : u8 > COM4A_W < 'a , O > { # [doc = "Normal operation"]
# [inline (always)]
pub fn normal_operation (self) -> & 'a mut W { self . variant (COM4A_A :: NORMAL_OPERATION) } } impl R { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm4 (& self) -> WGM4_R { WGM4_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare Output Mode for Channel C"]
# [inline (always)]
pub fn com4c (& self) -> COM4C_R { COM4C_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare Output Mode for Channel B"]
# [inline (always)]
pub fn com4b (& self) -> COM4B_R { COM4B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Output Mode for Channel A"]
# [inline (always)]
pub fn com4a (& self) -> COM4A_R { COM4A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm4 (& mut self) -> WGM4_W < 0 > { WGM4_W :: new (self) } # [doc = "Bits 2:3 - Compare Output Mode for Channel C"]
# [inline (always)]
# [must_use]
pub fn com4c (& mut self) -> COM4C_W < 2 > { COM4C_W :: new (self) } # [doc = "Bits 4:5 - Compare Output Mode for Channel B"]
# [inline (always)]
# [must_use]
pub fn com4b (& mut self) -> COM4B_W < 4 > { COM4B_W :: new (self) } # [doc = "Bits 6:7 - Compare Output Mode for Channel A"]
# [inline (always)]
# [must_use]
pub fn com4a (& mut self) -> COM4A_W < 6 > { COM4A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter4 Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr4a](index.html) module"]
pub struct TCCR4A_SPEC ; impl crate :: RegisterSpec for TCCR4A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr4a::R](R) reader structure"]
impl crate :: Readable for TCCR4A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr4a::W](W) writer structure"]
impl crate :: Writable for TCCR4A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR4A to value 0"]
impl crate :: Resettable for TCCR4A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR4B (rw) register accessor: an alias for `Reg<TCCR4B_SPEC>`"]
pub type TCCR4B = crate :: Reg < tccr4b :: TCCR4B_SPEC > ; # [doc = "Timer/Counter4 Control Register B"]
pub mod tccr4b { # [doc = "Register `TCCR4B` reader"]
pub struct R (crate :: R < TCCR4B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR4B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR4B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR4B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR4B` writer"]
pub struct W (crate :: W < TCCR4B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR4B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR4B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR4B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS4` reader - Clock Select"]
pub type CS4_R = crate :: FieldReader < u8 , CS4_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS4_A { # [doc = "0: No clock source (Timer/Counter stopped)"]
NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED = 0 , # [doc = "1: clk_IO/1 (no prescaling)"]
CLK_IO_1_NO_PRESCALING = 1 , # [doc = "2: clk_IO/8 (from prescaler)"]
CLK_IO_8_FROM_PRESCALER = 2 , # [doc = "3: clk_IO/64 (from prescaler)"]
CLK_IO_64_FROM_PRESCALER = 3 , # [doc = "4: clk_IO/256 (from prescaler)"]
CLK_IO_256_FROM_PRESCALER = 4 , # [doc = "5: clk_IO/1024 (from prescaler)"]
CLK_IO_1024_FROM_PRESCALER = 5 , } impl From < CS4_A > for u8 { # [inline (always)]
fn from (variant : CS4_A) -> Self { variant as _ } } impl CS4_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CS4_A > { match self . bits { 0 => Some (CS4_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED) , 1 => Some (CS4_A :: CLK_IO_1_NO_PRESCALING) , 2 => Some (CS4_A :: CLK_IO_8_FROM_PRESCALER) , 3 => Some (CS4_A :: CLK_IO_64_FROM_PRESCALER) , 4 => Some (CS4_A :: CLK_IO_256_FROM_PRESCALER) , 5 => Some (CS4_A :: CLK_IO_1024_FROM_PRESCALER) , _ => None , } } # [doc = "Checks if the value of the field is `NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED`"]
# [inline (always)]
pub fn is_no_clock_source_timer_counter_stopped (& self) -> bool { * self == CS4_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED } # [doc = "Checks if the value of the field is `CLK_IO_1_NO_PRESCALING`"]
# [inline (always)]
pub fn is_clk_io_1_no_prescaling (& self) -> bool { * self == CS4_A :: CLK_IO_1_NO_PRESCALING } # [doc = "Checks if the value of the field is `CLK_IO_8_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_8_from_prescaler (& self) -> bool { * self == CS4_A :: CLK_IO_8_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_64_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_64_from_prescaler (& self) -> bool { * self == CS4_A :: CLK_IO_64_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_256_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_256_from_prescaler (& self) -> bool { * self == CS4_A :: CLK_IO_256_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_1024_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_1024_from_prescaler (& self) -> bool { * self == CS4_A :: CLK_IO_1024_FROM_PRESCALER } } # [doc = "Field `CS4` writer - Clock Select"]
pub type CS4_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCCR4B_SPEC , u8 , CS4_A , 3 , O > ; impl < 'a , const O : u8 > CS4_W < 'a , O > { # [doc = "No clock source (Timer/Counter stopped)"]
# [inline (always)]
pub fn no_clock_source_timer_counter_stopped (self) -> & 'a mut W { self . variant (CS4_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED) } # [doc = "clk_IO/1 (no prescaling)"]
# [inline (always)]
pub fn clk_io_1_no_prescaling (self) -> & 'a mut W { self . variant (CS4_A :: CLK_IO_1_NO_PRESCALING) } # [doc = "clk_IO/8 (from prescaler)"]
# [inline (always)]
pub fn clk_io_8_from_prescaler (self) -> & 'a mut W { self . variant (CS4_A :: CLK_IO_8_FROM_PRESCALER) } # [doc = "clk_IO/64 (from prescaler)"]
# [inline (always)]
pub fn clk_io_64_from_prescaler (self) -> & 'a mut W { self . variant (CS4_A :: CLK_IO_64_FROM_PRESCALER) } # [doc = "clk_IO/256 (from prescaler)"]
# [inline (always)]
pub fn clk_io_256_from_prescaler (self) -> & 'a mut W { self . variant (CS4_A :: CLK_IO_256_FROM_PRESCALER) } # [doc = "clk_IO/1024 (from prescaler)"]
# [inline (always)]
pub fn clk_io_1024_from_prescaler (self) -> & 'a mut W { self . variant (CS4_A :: CLK_IO_1024_FROM_PRESCALER) } } # [doc = "Field `WGM4` reader - Waveform Generation Mode"]
pub type WGM4_R = crate :: FieldReader < u8 , WGM4_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM4_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, 8-bit"]
PWM_PHASE_CORRECT_8_BIT = 1 , # [doc = "2: PWM, phase correct, 9-bit"]
PWM_PHASE_CORRECT_9_BIT = 2 , # [doc = "3: PWM, phase correct, 10-bit"]
PWM_PHASE_CORRECT_10_BIT = 3 , } impl From < WGM4_A > for u8 { # [inline (always)]
fn from (variant : WGM4_A) -> Self { variant as _ } } impl WGM4_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM4_A { match self . bits { 0 => WGM4_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM4_A :: PWM_PHASE_CORRECT_8_BIT , 2 => WGM4_A :: PWM_PHASE_CORRECT_9_BIT , 3 => WGM4_A :: PWM_PHASE_CORRECT_10_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM4_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_8_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_8_bit (& self) -> bool { * self == WGM4_A :: PWM_PHASE_CORRECT_8_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_9_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_9_bit (& self) -> bool { * self == WGM4_A :: PWM_PHASE_CORRECT_9_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_10_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_10_bit (& self) -> bool { * self == WGM4_A :: PWM_PHASE_CORRECT_10_BIT } } # [doc = "Field `WGM4` writer - Waveform Generation Mode"]
pub type WGM4_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR4B_SPEC , u8 , WGM4_A , 2 , O > ; impl < 'a , const O : u8 > WGM4_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM4_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, 8-bit"]
# [inline (always)]
pub fn pwm_phase_correct_8_bit (self) -> & 'a mut W { self . variant (WGM4_A :: PWM_PHASE_CORRECT_8_BIT) } # [doc = "PWM, phase correct, 9-bit"]
# [inline (always)]
pub fn pwm_phase_correct_9_bit (self) -> & 'a mut W { self . variant (WGM4_A :: PWM_PHASE_CORRECT_9_BIT) } # [doc = "PWM, phase correct, 10-bit"]
# [inline (always)]
pub fn pwm_phase_correct_10_bit (self) -> & 'a mut W { self . variant (WGM4_A :: PWM_PHASE_CORRECT_10_BIT) } } # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR4B_SPEC , bool , O > ; # [doc = "Field `ICES4` reader - Input Capture 4 Edge Select"]
pub type ICES4_R = crate :: BitReader < bool > ; # [doc = "Field `ICES4` writer - Input Capture 4 Edge Select"]
pub type ICES4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR4B_SPEC , bool , O > ; # [doc = "Field `ICNC4` reader - Input Capture 4 Noise Canceller"]
pub type ICNC4_R = crate :: BitReader < bool > ; # [doc = "Field `ICNC4` writer - Input Capture 4 Noise Canceller"]
pub type ICNC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR4B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
pub fn cs4 (& self) -> CS4_R { CS4_R :: new (self . bits & 7) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm4 (& self) -> WGM4_R { WGM4_R :: new ((self . bits >> 3) & 3) } # [doc = "Bit 5 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Input Capture 4 Edge Select"]
# [inline (always)]
pub fn ices4 (& self) -> ICES4_R { ICES4_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Input Capture 4 Noise Canceller"]
# [inline (always)]
pub fn icnc4 (& self) -> ICNC4_R { ICNC4_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn cs4 (& mut self) -> CS4_W < 0 > { CS4_W :: new (self) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm4 (& mut self) -> WGM4_W < 3 > { WGM4_W :: new (self) } # [doc = "Bit 5 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 5 > { RES_W :: new (self) } # [doc = "Bit 6 - Input Capture 4 Edge Select"]
# [inline (always)]
# [must_use]
pub fn ices4 (& mut self) -> ICES4_W < 6 > { ICES4_W :: new (self) } # [doc = "Bit 7 - Input Capture 4 Noise Canceller"]
# [inline (always)]
# [must_use]
pub fn icnc4 (& mut self) -> ICNC4_W < 7 > { ICNC4_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter4 Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr4b](index.html) module"]
pub struct TCCR4B_SPEC ; impl crate :: RegisterSpec for TCCR4B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr4b::R](R) reader structure"]
impl crate :: Readable for TCCR4B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr4b::W](W) writer structure"]
impl crate :: Writable for TCCR4B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR4B to value 0"]
impl crate :: Resettable for TCCR4B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR4C (rw) register accessor: an alias for `Reg<TCCR4C_SPEC>`"]
pub type TCCR4C = crate :: Reg < tccr4c :: TCCR4C_SPEC > ; # [doc = "Timer/Counter4 Control Register C"]
pub mod tccr4c { # [doc = "Register `TCCR4C` reader"]
pub struct R (crate :: R < TCCR4C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR4C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR4C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR4C_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR4C` writer"]
pub struct W (crate :: W < TCCR4C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR4C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR4C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR4C_SPEC >) -> Self { W (writer) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR4C_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `FOC4C` reader - Force Output Compare for Channel C"]
pub type FOC4C_R = crate :: BitReader < bool > ; # [doc = "Field `FOC4C` writer - Force Output Compare for Channel C"]
pub type FOC4C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR4C_SPEC , bool , O > ; # [doc = "Field `FOC4B` reader - Force Output Compare for Channel B"]
pub type FOC4B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC4B` writer - Force Output Compare for Channel B"]
pub type FOC4B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR4C_SPEC , bool , O > ; # [doc = "Field `FOC4A` reader - Force Output Compare for Channel A"]
pub type FOC4A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC4A` writer - Force Output Compare for Channel A"]
pub type FOC4A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR4C_SPEC , bool , O > ; impl R { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (self . bits & 0x1f) } # [doc = "Bit 5 - Force Output Compare for Channel C"]
# [inline (always)]
pub fn foc4c (& self) -> FOC4C_R { FOC4C_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Force Output Compare for Channel B"]
# [inline (always)]
pub fn foc4b (& self) -> FOC4B_R { FOC4B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Force Output Compare for Channel A"]
# [inline (always)]
pub fn foc4a (& self) -> FOC4A_R { FOC4A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 0 > { RES_W :: new (self) } # [doc = "Bit 5 - Force Output Compare for Channel C"]
# [inline (always)]
# [must_use]
pub fn foc4c (& mut self) -> FOC4C_W < 5 > { FOC4C_W :: new (self) } # [doc = "Bit 6 - Force Output Compare for Channel B"]
# [inline (always)]
# [must_use]
pub fn foc4b (& mut self) -> FOC4B_W < 6 > { FOC4B_W :: new (self) } # [doc = "Bit 7 - Force Output Compare for Channel A"]
# [inline (always)]
# [must_use]
pub fn foc4a (& mut self) -> FOC4A_W < 7 > { FOC4A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter4 Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr4c](index.html) module"]
pub struct TCCR4C_SPEC ; impl crate :: RegisterSpec for TCCR4C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr4c::R](R) reader structure"]
impl crate :: Readable for TCCR4C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr4c::W](W) writer structure"]
impl crate :: Writable for TCCR4C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR4C to value 0"]
impl crate :: Resettable for TCCR4C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT4 (rw) register accessor: an alias for `Reg<TCNT4_SPEC>`"]
pub type TCNT4 = crate :: Reg < tcnt4 :: TCNT4_SPEC > ; # [doc = "Timer/Counter4 Bytes"]
pub mod tcnt4 { # [doc = "Register `TCNT4` reader"]
pub struct R (crate :: R < TCNT4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT4_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT4` writer"]
pub struct W (crate :: W < TCNT4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT4_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter4 Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt4](index.html) module"]
pub struct TCNT4_SPEC ; impl crate :: RegisterSpec for TCNT4_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [tcnt4::R](R) reader structure"]
impl crate :: Readable for TCNT4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt4::W](W) writer structure"]
impl crate :: Writable for TCNT4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT4 to value 0"]
impl crate :: Resettable for TCNT4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR4 (rw) register accessor: an alias for `Reg<TIFR4_SPEC>`"]
pub type TIFR4 = crate :: Reg < tifr4 :: TIFR4_SPEC > ; # [doc = "Timer/Counter4 Interrupt Flag Register"]
pub mod tifr4 { # [doc = "Register `TIFR4` reader"]
pub struct R (crate :: R < TIFR4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR4_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR4` writer"]
pub struct W (crate :: W < TIFR4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR4_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV4` reader - Timer/Counter4 Overflow Flag"]
pub type TOV4_R = crate :: BitReader < bool > ; # [doc = "Field `TOV4` writer - Timer/Counter4 Overflow Flag"]
pub type TOV4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR4_SPEC , bool , O > ; # [doc = "Field `OCF4A` reader - Timer/Counter4 Output Compare A Match Flag"]
pub type OCF4A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF4A` writer - Timer/Counter4 Output Compare A Match Flag"]
pub type OCF4A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR4_SPEC , bool , O > ; # [doc = "Field `OCF4B` reader - Timer/Counter4 Output Compare B Match Flag"]
pub type OCF4B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF4B` writer - Timer/Counter4 Output Compare B Match Flag"]
pub type OCF4B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR4_SPEC , bool , O > ; # [doc = "Field `OCF4C` reader - Timer/Counter4 Output Compare C Match Flag"]
pub type OCF4C_R = crate :: BitReader < bool > ; # [doc = "Field `OCF4C` writer - Timer/Counter4 Output Compare C Match Flag"]
pub type OCF4C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR4_SPEC , bool , O > ; # [doc = "Field `ICF4` reader - Timer/Counter4 Input Capture Flag"]
pub type ICF4_R = crate :: BitReader < bool > ; # [doc = "Field `ICF4` writer - Timer/Counter4 Input Capture Flag"]
pub type ICF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR4_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter4 Overflow Flag"]
# [inline (always)]
pub fn tov4 (& self) -> TOV4_R { TOV4_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter4 Output Compare A Match Flag"]
# [inline (always)]
pub fn ocf4a (& self) -> OCF4A_R { OCF4A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter4 Output Compare B Match Flag"]
# [inline (always)]
pub fn ocf4b (& self) -> OCF4B_R { OCF4B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter4 Output Compare C Match Flag"]
# [inline (always)]
pub fn ocf4c (& self) -> OCF4C_R { OCF4C_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter4 Input Capture Flag"]
# [inline (always)]
pub fn icf4 (& self) -> ICF4_R { ICF4_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter4 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov4 (& mut self) -> TOV4_W < 0 > { TOV4_W :: new (self) } # [doc = "Bit 1 - Timer/Counter4 Output Compare A Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf4a (& mut self) -> OCF4A_W < 1 > { OCF4A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter4 Output Compare B Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf4b (& mut self) -> OCF4B_W < 2 > { OCF4B_W :: new (self) } # [doc = "Bit 3 - Timer/Counter4 Output Compare C Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf4c (& mut self) -> OCF4C_W < 3 > { OCF4C_W :: new (self) } # [doc = "Bit 5 - Timer/Counter4 Input Capture Flag"]
# [inline (always)]
# [must_use]
pub fn icf4 (& mut self) -> ICF4_W < 5 > { ICF4_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter4 Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr4](index.html) module"]
pub struct TIFR4_SPEC ; impl crate :: RegisterSpec for TIFR4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr4::R](R) reader structure"]
impl crate :: Readable for TIFR4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr4::W](W) writer structure"]
impl crate :: Writable for TIFR4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR4 to value 0"]
impl crate :: Resettable for TIFR4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK4 (rw) register accessor: an alias for `Reg<TIMSK4_SPEC>`"]
pub type TIMSK4 = crate :: Reg < timsk4 :: TIMSK4_SPEC > ; # [doc = "Timer/Counter4 Interrupt Mask Register"]
pub mod timsk4 { # [doc = "Register `TIMSK4` reader"]
pub struct R (crate :: R < TIMSK4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK4_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK4` writer"]
pub struct W (crate :: W < TIMSK4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK4_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE4` reader - Timer/Counter4 Overflow Interrupt Enable"]
pub type TOIE4_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE4` writer - Timer/Counter4 Overflow Interrupt Enable"]
pub type TOIE4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK4_SPEC , bool , O > ; # [doc = "Field `OCIE4A` reader - Timer/Counter4 Output Compare A Match Interrupt Enable"]
pub type OCIE4A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE4A` writer - Timer/Counter4 Output Compare A Match Interrupt Enable"]
pub type OCIE4A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK4_SPEC , bool , O > ; # [doc = "Field `OCIE4B` reader - Timer/Counter4 Output Compare B Match Interrupt Enable"]
pub type OCIE4B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE4B` writer - Timer/Counter4 Output Compare B Match Interrupt Enable"]
pub type OCIE4B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK4_SPEC , bool , O > ; # [doc = "Field `OCIE4C` reader - Timer/Counter4 Output Compare C Match Interrupt Enable"]
pub type OCIE4C_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE4C` writer - Timer/Counter4 Output Compare C Match Interrupt Enable"]
pub type OCIE4C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK4_SPEC , bool , O > ; # [doc = "Field `ICIE4` reader - Timer/Counter4 Input Capture Interrupt Enable"]
pub type ICIE4_R = crate :: BitReader < bool > ; # [doc = "Field `ICIE4` writer - Timer/Counter4 Input Capture Interrupt Enable"]
pub type ICIE4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK4_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter4 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie4 (& self) -> TOIE4_R { TOIE4_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter4 Output Compare A Match Interrupt Enable"]
# [inline (always)]
pub fn ocie4a (& self) -> OCIE4A_R { OCIE4A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter4 Output Compare B Match Interrupt Enable"]
# [inline (always)]
pub fn ocie4b (& self) -> OCIE4B_R { OCIE4B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter4 Output Compare C Match Interrupt Enable"]
# [inline (always)]
pub fn ocie4c (& self) -> OCIE4C_R { OCIE4C_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter4 Input Capture Interrupt Enable"]
# [inline (always)]
pub fn icie4 (& self) -> ICIE4_R { ICIE4_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter4 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie4 (& mut self) -> TOIE4_W < 0 > { TOIE4_W :: new (self) } # [doc = "Bit 1 - Timer/Counter4 Output Compare A Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie4a (& mut self) -> OCIE4A_W < 1 > { OCIE4A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter4 Output Compare B Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie4b (& mut self) -> OCIE4B_W < 2 > { OCIE4B_W :: new (self) } # [doc = "Bit 3 - Timer/Counter4 Output Compare C Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie4c (& mut self) -> OCIE4C_W < 3 > { OCIE4C_W :: new (self) } # [doc = "Bit 5 - Timer/Counter4 Input Capture Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn icie4 (& mut self) -> ICIE4_W < 5 > { ICIE4_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter4 Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk4](index.html) module"]
pub struct TIMSK4_SPEC ; impl crate :: RegisterSpec for TIMSK4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk4::R](R) reader structure"]
impl crate :: Readable for TIMSK4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk4::W](W) writer structure"]
impl crate :: Writable for TIMSK4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK4 to value 0"]
impl crate :: Resettable for TIMSK4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 16-bit"]
pub struct TC5 { _marker : PhantomData < * const () > } unsafe impl Send for TC5 { } impl TC5 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc5 :: RegisterBlock = 0x3a as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc5 :: RegisterBlock { Self :: PTR } } impl Deref for TC5 { type Target = tc5 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC5") . finish () } } # [doc = "Timer/Counter, 16-bit"]
pub mod tc5 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter5 Interrupt Flag Register"]
pub tifr5 : TIFR5 , _reserved1 : [u8 ; 0x38]
, # [doc = "0x39 - Timer/Counter5 Interrupt Mask Register"]
pub timsk5 : TIMSK5 , _reserved2 : [u8 ; 0xac]
, # [doc = "0xe6 - Timer/Counter5 Control Register A"]
pub tccr5a : TCCR5A , # [doc = "0xe7 - Timer/Counter5 Control Register B"]
pub tccr5b : TCCR5B , # [doc = "0xe8 - Timer/Counter5 Control Register C"]
pub tccr5c : TCCR5C , _reserved5 : [u8 ; 0x01]
, # [doc = "0xea - Timer/Counter5 Bytes"]
pub tcnt5 : TCNT5 , # [doc = "0xec - Timer/Counter5 Input Capture Register Bytes"]
pub icr5 : ICR5 , # [doc = "0xee - Timer/Counter5 Output Compare Register A Bytes"]
pub ocr5a : OCR5A , # [doc = "0xf0 - Timer/Counter5 Output Compare Register B Bytes"]
pub ocr5b : OCR5B , # [doc = "0xf2 - Timer/Counter5 Output Compare Register C Bytes"]
pub ocr5c : OCR5C , } # [doc = "ICR5 (rw) register accessor: an alias for `Reg<ICR5_SPEC>`"]
pub type ICR5 = crate :: Reg < icr5 :: ICR5_SPEC > ; # [doc = "Timer/Counter5 Input Capture Register Bytes"]
pub mod icr5 { # [doc = "Register `ICR5` reader"]
pub struct R (crate :: R < ICR5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ICR5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ICR5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ICR5_SPEC >) -> Self { R (reader) } } # [doc = "Register `ICR5` writer"]
pub struct W (crate :: W < ICR5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ICR5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ICR5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ICR5_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter5 Input Capture Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr5](index.html) module"]
pub struct ICR5_SPEC ; impl crate :: RegisterSpec for ICR5_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [icr5::R](R) reader structure"]
impl crate :: Readable for ICR5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [icr5::W](W) writer structure"]
impl crate :: Writable for ICR5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ICR5 to value 0"]
impl crate :: Resettable for ICR5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR5A (rw) register accessor: an alias for `Reg<OCR5A_SPEC>`"]
pub type OCR5A = crate :: Reg < ocr5a :: OCR5A_SPEC > ; # [doc = "Timer/Counter5 Output Compare Register A Bytes"]
pub mod ocr5a { # [doc = "Register `OCR5A` reader"]
pub struct R (crate :: R < OCR5A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR5A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR5A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR5A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR5A` writer"]
pub struct W (crate :: W < OCR5A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR5A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR5A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR5A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter5 Output Compare Register A Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr5a](index.html) module"]
pub struct OCR5A_SPEC ; impl crate :: RegisterSpec for OCR5A_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr5a::R](R) reader structure"]
impl crate :: Readable for OCR5A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr5a::W](W) writer structure"]
impl crate :: Writable for OCR5A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR5A to value 0"]
impl crate :: Resettable for OCR5A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR5B (rw) register accessor: an alias for `Reg<OCR5B_SPEC>`"]
pub type OCR5B = crate :: Reg < ocr5b :: OCR5B_SPEC > ; # [doc = "Timer/Counter5 Output Compare Register B Bytes"]
pub mod ocr5b { # [doc = "Register `OCR5B` reader"]
pub struct R (crate :: R < OCR5B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR5B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR5B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR5B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR5B` writer"]
pub struct W (crate :: W < OCR5B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR5B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR5B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR5B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter5 Output Compare Register B Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr5b](index.html) module"]
pub struct OCR5B_SPEC ; impl crate :: RegisterSpec for OCR5B_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr5b::R](R) reader structure"]
impl crate :: Readable for OCR5B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr5b::W](W) writer structure"]
impl crate :: Writable for OCR5B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR5B to value 0"]
impl crate :: Resettable for OCR5B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR5C (rw) register accessor: an alias for `Reg<OCR5C_SPEC>`"]
pub type OCR5C = crate :: Reg < ocr5c :: OCR5C_SPEC > ; # [doc = "Timer/Counter5 Output Compare Register C Bytes"]
pub mod ocr5c { # [doc = "Register `OCR5C` reader"]
pub struct R (crate :: R < OCR5C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR5C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR5C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR5C_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR5C` writer"]
pub struct W (crate :: W < OCR5C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR5C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR5C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR5C_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter5 Output Compare Register C Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr5c](index.html) module"]
pub struct OCR5C_SPEC ; impl crate :: RegisterSpec for OCR5C_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr5c::R](R) reader structure"]
impl crate :: Readable for OCR5C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr5c::W](W) writer structure"]
impl crate :: Writable for OCR5C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR5C to value 0"]
impl crate :: Resettable for OCR5C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR5A (rw) register accessor: an alias for `Reg<TCCR5A_SPEC>`"]
pub type TCCR5A = crate :: Reg < tccr5a :: TCCR5A_SPEC > ; # [doc = "Timer/Counter5 Control Register A"]
pub mod tccr5a { # [doc = "Register `TCCR5A` reader"]
pub struct R (crate :: R < TCCR5A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR5A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR5A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR5A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR5A` writer"]
pub struct W (crate :: W < TCCR5A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR5A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR5A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR5A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM5` reader - Waveform Generation Mode"]
pub type WGM5_R = crate :: FieldReader < u8 , WGM5_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM5_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, 8-bit"]
PWM_PHASE_CORRECT_8_BIT = 1 , # [doc = "2: PWM, phase correct, 9-bit"]
PWM_PHASE_CORRECT_9_BIT = 2 , # [doc = "3: PWM, phase correct, 10-bit"]
PWM_PHASE_CORRECT_10_BIT = 3 , } impl From < WGM5_A > for u8 { # [inline (always)]
fn from (variant : WGM5_A) -> Self { variant as _ } } impl WGM5_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM5_A { match self . bits { 0 => WGM5_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM5_A :: PWM_PHASE_CORRECT_8_BIT , 2 => WGM5_A :: PWM_PHASE_CORRECT_9_BIT , 3 => WGM5_A :: PWM_PHASE_CORRECT_10_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM5_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_8_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_8_bit (& self) -> bool { * self == WGM5_A :: PWM_PHASE_CORRECT_8_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_9_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_9_bit (& self) -> bool { * self == WGM5_A :: PWM_PHASE_CORRECT_9_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_10_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_10_bit (& self) -> bool { * self == WGM5_A :: PWM_PHASE_CORRECT_10_BIT } } # [doc = "Field `WGM5` writer - Waveform Generation Mode"]
pub type WGM5_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR5A_SPEC , u8 , WGM5_A , 2 , O > ; impl < 'a , const O : u8 > WGM5_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM5_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, 8-bit"]
# [inline (always)]
pub fn pwm_phase_correct_8_bit (self) -> & 'a mut W { self . variant (WGM5_A :: PWM_PHASE_CORRECT_8_BIT) } # [doc = "PWM, phase correct, 9-bit"]
# [inline (always)]
pub fn pwm_phase_correct_9_bit (self) -> & 'a mut W { self . variant (WGM5_A :: PWM_PHASE_CORRECT_9_BIT) } # [doc = "PWM, phase correct, 10-bit"]
# [inline (always)]
pub fn pwm_phase_correct_10_bit (self) -> & 'a mut W { self . variant (WGM5_A :: PWM_PHASE_CORRECT_10_BIT) } } # [doc = "Field `COM5C` reader - Compare Output Mode for Channel C"]
pub type COM5C_R = crate :: FieldReader < u8 , COM5C_A > ; # [doc = "Compare Output Mode for Channel C\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM5C_A { # [doc = "0: Normal operation"]
NORMAL_OPERATION = 0 , } impl From < COM5C_A > for u8 { # [inline (always)]
fn from (variant : COM5C_A) -> Self { variant as _ } } impl COM5C_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < COM5C_A > { match self . bits { 0 => Some (COM5C_A :: NORMAL_OPERATION) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL_OPERATION`"]
# [inline (always)]
pub fn is_normal_operation (& self) -> bool { * self == COM5C_A :: NORMAL_OPERATION } } # [doc = "Field `COM5C` writer - Compare Output Mode for Channel C"]
pub type COM5C_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCCR5A_SPEC , u8 , COM5C_A , 2 , O > ; impl < 'a , const O : u8 > COM5C_W < 'a , O > { # [doc = "Normal operation"]
# [inline (always)]
pub fn normal_operation (self) -> & 'a mut W { self . variant (COM5C_A :: NORMAL_OPERATION) } } # [doc = "Field `COM5B` reader - Compare Output Mode for Channel B"]
pub type COM5B_R = crate :: FieldReader < u8 , COM5B_A > ; # [doc = "Compare Output Mode for Channel B\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM5B_A { # [doc = "0: Normal operation"]
NORMAL_OPERATION = 0 , } impl From < COM5B_A > for u8 { # [inline (always)]
fn from (variant : COM5B_A) -> Self { variant as _ } } impl COM5B_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < COM5B_A > { match self . bits { 0 => Some (COM5B_A :: NORMAL_OPERATION) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL_OPERATION`"]
# [inline (always)]
pub fn is_normal_operation (& self) -> bool { * self == COM5B_A :: NORMAL_OPERATION } } # [doc = "Field `COM5B` writer - Compare Output Mode for Channel B"]
pub type COM5B_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCCR5A_SPEC , u8 , COM5B_A , 2 , O > ; impl < 'a , const O : u8 > COM5B_W < 'a , O > { # [doc = "Normal operation"]
# [inline (always)]
pub fn normal_operation (self) -> & 'a mut W { self . variant (COM5B_A :: NORMAL_OPERATION) } } # [doc = "Field `COM5A` reader - Compare Output Mode for Channel A"]
pub type COM5A_R = crate :: FieldReader < u8 , COM5A_A > ; # [doc = "Compare Output Mode for Channel A\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COM5A_A { # [doc = "0: Normal operation"]
NORMAL_OPERATION = 0 , } impl From < COM5A_A > for u8 { # [inline (always)]
fn from (variant : COM5A_A) -> Self { variant as _ } } impl COM5A_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < COM5A_A > { match self . bits { 0 => Some (COM5A_A :: NORMAL_OPERATION) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL_OPERATION`"]
# [inline (always)]
pub fn is_normal_operation (& self) -> bool { * self == COM5A_A :: NORMAL_OPERATION } } # [doc = "Field `COM5A` writer - Compare Output Mode for Channel A"]
pub type COM5A_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCCR5A_SPEC , u8 , COM5A_A , 2 , O > ; impl < 'a , const O : u8 > COM5A_W < 'a , O > { # [doc = "Normal operation"]
# [inline (always)]
pub fn normal_operation (self) -> & 'a mut W { self . variant (COM5A_A :: NORMAL_OPERATION) } } impl R { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm5 (& self) -> WGM5_R { WGM5_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare Output Mode for Channel C"]
# [inline (always)]
pub fn com5c (& self) -> COM5C_R { COM5C_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare Output Mode for Channel B"]
# [inline (always)]
pub fn com5b (& self) -> COM5B_R { COM5B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Output Mode for Channel A"]
# [inline (always)]
pub fn com5a (& self) -> COM5A_R { COM5A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm5 (& mut self) -> WGM5_W < 0 > { WGM5_W :: new (self) } # [doc = "Bits 2:3 - Compare Output Mode for Channel C"]
# [inline (always)]
# [must_use]
pub fn com5c (& mut self) -> COM5C_W < 2 > { COM5C_W :: new (self) } # [doc = "Bits 4:5 - Compare Output Mode for Channel B"]
# [inline (always)]
# [must_use]
pub fn com5b (& mut self) -> COM5B_W < 4 > { COM5B_W :: new (self) } # [doc = "Bits 6:7 - Compare Output Mode for Channel A"]
# [inline (always)]
# [must_use]
pub fn com5a (& mut self) -> COM5A_W < 6 > { COM5A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter5 Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr5a](index.html) module"]
pub struct TCCR5A_SPEC ; impl crate :: RegisterSpec for TCCR5A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr5a::R](R) reader structure"]
impl crate :: Readable for TCCR5A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr5a::W](W) writer structure"]
impl crate :: Writable for TCCR5A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR5A to value 0"]
impl crate :: Resettable for TCCR5A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR5B (rw) register accessor: an alias for `Reg<TCCR5B_SPEC>`"]
pub type TCCR5B = crate :: Reg < tccr5b :: TCCR5B_SPEC > ; # [doc = "Timer/Counter5 Control Register B"]
pub mod tccr5b { # [doc = "Register `TCCR5B` reader"]
pub struct R (crate :: R < TCCR5B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR5B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR5B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR5B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR5B` writer"]
pub struct W (crate :: W < TCCR5B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR5B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR5B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR5B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS5` reader - Clock Select"]
pub type CS5_R = crate :: FieldReader < u8 , CS5_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS5_A { # [doc = "0: No clock source (Timer/Counter stopped)"]
NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED = 0 , # [doc = "1: clk_IO/1 (no prescaling)"]
CLK_IO_1_NO_PRESCALING = 1 , # [doc = "2: clk_IO/8 (from prescaler)"]
CLK_IO_8_FROM_PRESCALER = 2 , # [doc = "3: clk_IO/64 (from prescaler)"]
CLK_IO_64_FROM_PRESCALER = 3 , # [doc = "4: clk_IO/256 (from prescaler)"]
CLK_IO_256_FROM_PRESCALER = 4 , # [doc = "5: clk_IO/1024 (from prescaler)"]
CLK_IO_1024_FROM_PRESCALER = 5 , } impl From < CS5_A > for u8 { # [inline (always)]
fn from (variant : CS5_A) -> Self { variant as _ } } impl CS5_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CS5_A > { match self . bits { 0 => Some (CS5_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED) , 1 => Some (CS5_A :: CLK_IO_1_NO_PRESCALING) , 2 => Some (CS5_A :: CLK_IO_8_FROM_PRESCALER) , 3 => Some (CS5_A :: CLK_IO_64_FROM_PRESCALER) , 4 => Some (CS5_A :: CLK_IO_256_FROM_PRESCALER) , 5 => Some (CS5_A :: CLK_IO_1024_FROM_PRESCALER) , _ => None , } } # [doc = "Checks if the value of the field is `NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED`"]
# [inline (always)]
pub fn is_no_clock_source_timer_counter_stopped (& self) -> bool { * self == CS5_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED } # [doc = "Checks if the value of the field is `CLK_IO_1_NO_PRESCALING`"]
# [inline (always)]
pub fn is_clk_io_1_no_prescaling (& self) -> bool { * self == CS5_A :: CLK_IO_1_NO_PRESCALING } # [doc = "Checks if the value of the field is `CLK_IO_8_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_8_from_prescaler (& self) -> bool { * self == CS5_A :: CLK_IO_8_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_64_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_64_from_prescaler (& self) -> bool { * self == CS5_A :: CLK_IO_64_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_256_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_256_from_prescaler (& self) -> bool { * self == CS5_A :: CLK_IO_256_FROM_PRESCALER } # [doc = "Checks if the value of the field is `CLK_IO_1024_FROM_PRESCALER`"]
# [inline (always)]
pub fn is_clk_io_1024_from_prescaler (& self) -> bool { * self == CS5_A :: CLK_IO_1024_FROM_PRESCALER } } # [doc = "Field `CS5` writer - Clock Select"]
pub type CS5_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCCR5B_SPEC , u8 , CS5_A , 3 , O > ; impl < 'a , const O : u8 > CS5_W < 'a , O > { # [doc = "No clock source (Timer/Counter stopped)"]
# [inline (always)]
pub fn no_clock_source_timer_counter_stopped (self) -> & 'a mut W { self . variant (CS5_A :: NO_CLOCK_SOURCE_TIMER_COUNTER_STOPPED) } # [doc = "clk_IO/1 (no prescaling)"]
# [inline (always)]
pub fn clk_io_1_no_prescaling (self) -> & 'a mut W { self . variant (CS5_A :: CLK_IO_1_NO_PRESCALING) } # [doc = "clk_IO/8 (from prescaler)"]
# [inline (always)]
pub fn clk_io_8_from_prescaler (self) -> & 'a mut W { self . variant (CS5_A :: CLK_IO_8_FROM_PRESCALER) } # [doc = "clk_IO/64 (from prescaler)"]
# [inline (always)]
pub fn clk_io_64_from_prescaler (self) -> & 'a mut W { self . variant (CS5_A :: CLK_IO_64_FROM_PRESCALER) } # [doc = "clk_IO/256 (from prescaler)"]
# [inline (always)]
pub fn clk_io_256_from_prescaler (self) -> & 'a mut W { self . variant (CS5_A :: CLK_IO_256_FROM_PRESCALER) } # [doc = "clk_IO/1024 (from prescaler)"]
# [inline (always)]
pub fn clk_io_1024_from_prescaler (self) -> & 'a mut W { self . variant (CS5_A :: CLK_IO_1024_FROM_PRESCALER) } } # [doc = "Field `WGM5` reader - Waveform Generation Mode"]
pub type WGM5_R = crate :: FieldReader < u8 , WGM5_A > ; # [doc = "Waveform Generation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGM5_A { # [doc = "0: Normal mode of operation"]
NORMAL_MODE_OF_OPERATION = 0 , # [doc = "1: PWM, phase correct, 8-bit"]
PWM_PHASE_CORRECT_8_BIT = 1 , # [doc = "2: PWM, phase correct, 9-bit"]
PWM_PHASE_CORRECT_9_BIT = 2 , # [doc = "3: PWM, phase correct, 10-bit"]
PWM_PHASE_CORRECT_10_BIT = 3 , } impl From < WGM5_A > for u8 { # [inline (always)]
fn from (variant : WGM5_A) -> Self { variant as _ } } impl WGM5_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGM5_A { match self . bits { 0 => WGM5_A :: NORMAL_MODE_OF_OPERATION , 1 => WGM5_A :: PWM_PHASE_CORRECT_8_BIT , 2 => WGM5_A :: PWM_PHASE_CORRECT_9_BIT , 3 => WGM5_A :: PWM_PHASE_CORRECT_10_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL_MODE_OF_OPERATION`"]
# [inline (always)]
pub fn is_normal_mode_of_operation (& self) -> bool { * self == WGM5_A :: NORMAL_MODE_OF_OPERATION } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_8_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_8_bit (& self) -> bool { * self == WGM5_A :: PWM_PHASE_CORRECT_8_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_9_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_9_bit (& self) -> bool { * self == WGM5_A :: PWM_PHASE_CORRECT_9_BIT } # [doc = "Checks if the value of the field is `PWM_PHASE_CORRECT_10_BIT`"]
# [inline (always)]
pub fn is_pwm_phase_correct_10_bit (& self) -> bool { * self == WGM5_A :: PWM_PHASE_CORRECT_10_BIT } } # [doc = "Field `WGM5` writer - Waveform Generation Mode"]
pub type WGM5_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR5B_SPEC , u8 , WGM5_A , 2 , O > ; impl < 'a , const O : u8 > WGM5_W < 'a , O > { # [doc = "Normal mode of operation"]
# [inline (always)]
pub fn normal_mode_of_operation (self) -> & 'a mut W { self . variant (WGM5_A :: NORMAL_MODE_OF_OPERATION) } # [doc = "PWM, phase correct, 8-bit"]
# [inline (always)]
pub fn pwm_phase_correct_8_bit (self) -> & 'a mut W { self . variant (WGM5_A :: PWM_PHASE_CORRECT_8_BIT) } # [doc = "PWM, phase correct, 9-bit"]
# [inline (always)]
pub fn pwm_phase_correct_9_bit (self) -> & 'a mut W { self . variant (WGM5_A :: PWM_PHASE_CORRECT_9_BIT) } # [doc = "PWM, phase correct, 10-bit"]
# [inline (always)]
pub fn pwm_phase_correct_10_bit (self) -> & 'a mut W { self . variant (WGM5_A :: PWM_PHASE_CORRECT_10_BIT) } } # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR5B_SPEC , bool , O > ; # [doc = "Field `ICES5` reader - Input Capture 5 Edge Select"]
pub type ICES5_R = crate :: BitReader < bool > ; # [doc = "Field `ICES5` writer - Input Capture 5 Edge Select"]
pub type ICES5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR5B_SPEC , bool , O > ; # [doc = "Field `ICNC5` reader - Input Capture 5 Noise Canceller"]
pub type ICNC5_R = crate :: BitReader < bool > ; # [doc = "Field `ICNC5` writer - Input Capture 5 Noise Canceller"]
pub type ICNC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR5B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
pub fn cs5 (& self) -> CS5_R { CS5_R :: new (self . bits & 7) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm5 (& self) -> WGM5_R { WGM5_R :: new ((self . bits >> 3) & 3) } # [doc = "Bit 5 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Input Capture 5 Edge Select"]
# [inline (always)]
pub fn ices5 (& self) -> ICES5_R { ICES5_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Input Capture 5 Noise Canceller"]
# [inline (always)]
pub fn icnc5 (& self) -> ICNC5_R { ICNC5_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn cs5 (& mut self) -> CS5_W < 0 > { CS5_W :: new (self) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm5 (& mut self) -> WGM5_W < 3 > { WGM5_W :: new (self) } # [doc = "Bit 5 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 5 > { RES_W :: new (self) } # [doc = "Bit 6 - Input Capture 5 Edge Select"]
# [inline (always)]
# [must_use]
pub fn ices5 (& mut self) -> ICES5_W < 6 > { ICES5_W :: new (self) } # [doc = "Bit 7 - Input Capture 5 Noise Canceller"]
# [inline (always)]
# [must_use]
pub fn icnc5 (& mut self) -> ICNC5_W < 7 > { ICNC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter5 Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr5b](index.html) module"]
pub struct TCCR5B_SPEC ; impl crate :: RegisterSpec for TCCR5B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr5b::R](R) reader structure"]
impl crate :: Readable for TCCR5B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr5b::W](W) writer structure"]
impl crate :: Writable for TCCR5B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR5B to value 0"]
impl crate :: Resettable for TCCR5B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR5C (rw) register accessor: an alias for `Reg<TCCR5C_SPEC>`"]
pub type TCCR5C = crate :: Reg < tccr5c :: TCCR5C_SPEC > ; # [doc = "Timer/Counter5 Control Register C"]
pub mod tccr5c { # [doc = "Register `TCCR5C` reader"]
pub struct R (crate :: R < TCCR5C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR5C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR5C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR5C_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR5C` writer"]
pub struct W (crate :: W < TCCR5C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR5C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR5C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR5C_SPEC >) -> Self { W (writer) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR5C_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `FOC5C` reader - Force Output Compare for Channel C"]
pub type FOC5C_R = crate :: BitReader < bool > ; # [doc = "Field `FOC5C` writer - Force Output Compare for Channel C"]
pub type FOC5C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR5C_SPEC , bool , O > ; # [doc = "Field `FOC5B` reader - Force Output Compare for Channel B"]
pub type FOC5B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC5B` writer - Force Output Compare for Channel B"]
pub type FOC5B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR5C_SPEC , bool , O > ; # [doc = "Field `FOC5A` reader - Force Output Compare for Channel A"]
pub type FOC5A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC5A` writer - Force Output Compare for Channel A"]
pub type FOC5A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR5C_SPEC , bool , O > ; impl R { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (self . bits & 0x1f) } # [doc = "Bit 5 - Force Output Compare for Channel C"]
# [inline (always)]
pub fn foc5c (& self) -> FOC5C_R { FOC5C_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Force Output Compare for Channel B"]
# [inline (always)]
pub fn foc5b (& self) -> FOC5B_R { FOC5B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Force Output Compare for Channel A"]
# [inline (always)]
pub fn foc5a (& self) -> FOC5A_R { FOC5A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 0 > { RES_W :: new (self) } # [doc = "Bit 5 - Force Output Compare for Channel C"]
# [inline (always)]
# [must_use]
pub fn foc5c (& mut self) -> FOC5C_W < 5 > { FOC5C_W :: new (self) } # [doc = "Bit 6 - Force Output Compare for Channel B"]
# [inline (always)]
# [must_use]
pub fn foc5b (& mut self) -> FOC5B_W < 6 > { FOC5B_W :: new (self) } # [doc = "Bit 7 - Force Output Compare for Channel A"]
# [inline (always)]
# [must_use]
pub fn foc5a (& mut self) -> FOC5A_W < 7 > { FOC5A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter5 Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr5c](index.html) module"]
pub struct TCCR5C_SPEC ; impl crate :: RegisterSpec for TCCR5C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr5c::R](R) reader structure"]
impl crate :: Readable for TCCR5C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr5c::W](W) writer structure"]
impl crate :: Writable for TCCR5C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR5C to value 0"]
impl crate :: Resettable for TCCR5C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT5 (rw) register accessor: an alias for `Reg<TCNT5_SPEC>`"]
pub type TCNT5 = crate :: Reg < tcnt5 :: TCNT5_SPEC > ; # [doc = "Timer/Counter5 Bytes"]
pub mod tcnt5 { # [doc = "Register `TCNT5` reader"]
pub struct R (crate :: R < TCNT5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT5_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT5` writer"]
pub struct W (crate :: W < TCNT5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT5_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter5 Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt5](index.html) module"]
pub struct TCNT5_SPEC ; impl crate :: RegisterSpec for TCNT5_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [tcnt5::R](R) reader structure"]
impl crate :: Readable for TCNT5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt5::W](W) writer structure"]
impl crate :: Writable for TCNT5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT5 to value 0"]
impl crate :: Resettable for TCNT5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR5 (rw) register accessor: an alias for `Reg<TIFR5_SPEC>`"]
pub type TIFR5 = crate :: Reg < tifr5 :: TIFR5_SPEC > ; # [doc = "Timer/Counter5 Interrupt Flag Register"]
pub mod tifr5 { # [doc = "Register `TIFR5` reader"]
pub struct R (crate :: R < TIFR5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR5_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR5` writer"]
pub struct W (crate :: W < TIFR5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR5_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV5` reader - Timer/Counter5 Overflow Flag"]
pub type TOV5_R = crate :: BitReader < bool > ; # [doc = "Field `TOV5` writer - Timer/Counter5 Overflow Flag"]
pub type TOV5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR5_SPEC , bool , O > ; # [doc = "Field `OCF5A` reader - Timer/Counter5 Output Compare A Match Flag"]
pub type OCF5A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF5A` writer - Timer/Counter5 Output Compare A Match Flag"]
pub type OCF5A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR5_SPEC , bool , O > ; # [doc = "Field `OCF5B` reader - Timer/Counter5 Output Compare B Match Flag"]
pub type OCF5B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF5B` writer - Timer/Counter5 Output Compare B Match Flag"]
pub type OCF5B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR5_SPEC , bool , O > ; # [doc = "Field `OCF5C` reader - Timer/Counter5 Output Compare C Match Flag"]
pub type OCF5C_R = crate :: BitReader < bool > ; # [doc = "Field `OCF5C` writer - Timer/Counter5 Output Compare C Match Flag"]
pub type OCF5C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR5_SPEC , bool , O > ; # [doc = "Field `ICF5` reader - Timer/Counter5 Input Capture Flag"]
pub type ICF5_R = crate :: BitReader < bool > ; # [doc = "Field `ICF5` writer - Timer/Counter5 Input Capture Flag"]
pub type ICF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR5_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter5 Overflow Flag"]
# [inline (always)]
pub fn tov5 (& self) -> TOV5_R { TOV5_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter5 Output Compare A Match Flag"]
# [inline (always)]
pub fn ocf5a (& self) -> OCF5A_R { OCF5A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter5 Output Compare B Match Flag"]
# [inline (always)]
pub fn ocf5b (& self) -> OCF5B_R { OCF5B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter5 Output Compare C Match Flag"]
# [inline (always)]
pub fn ocf5c (& self) -> OCF5C_R { OCF5C_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter5 Input Capture Flag"]
# [inline (always)]
pub fn icf5 (& self) -> ICF5_R { ICF5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter5 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov5 (& mut self) -> TOV5_W < 0 > { TOV5_W :: new (self) } # [doc = "Bit 1 - Timer/Counter5 Output Compare A Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf5a (& mut self) -> OCF5A_W < 1 > { OCF5A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter5 Output Compare B Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf5b (& mut self) -> OCF5B_W < 2 > { OCF5B_W :: new (self) } # [doc = "Bit 3 - Timer/Counter5 Output Compare C Match Flag"]
# [inline (always)]
# [must_use]
pub fn ocf5c (& mut self) -> OCF5C_W < 3 > { OCF5C_W :: new (self) } # [doc = "Bit 5 - Timer/Counter5 Input Capture Flag"]
# [inline (always)]
# [must_use]
pub fn icf5 (& mut self) -> ICF5_W < 5 > { ICF5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter5 Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr5](index.html) module"]
pub struct TIFR5_SPEC ; impl crate :: RegisterSpec for TIFR5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr5::R](R) reader structure"]
impl crate :: Readable for TIFR5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr5::W](W) writer structure"]
impl crate :: Writable for TIFR5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR5 to value 0"]
impl crate :: Resettable for TIFR5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK5 (rw) register accessor: an alias for `Reg<TIMSK5_SPEC>`"]
pub type TIMSK5 = crate :: Reg < timsk5 :: TIMSK5_SPEC > ; # [doc = "Timer/Counter5 Interrupt Mask Register"]
pub mod timsk5 { # [doc = "Register `TIMSK5` reader"]
pub struct R (crate :: R < TIMSK5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK5_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK5` writer"]
pub struct W (crate :: W < TIMSK5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK5_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE5` reader - Timer/Counter5 Overflow Interrupt Enable"]
pub type TOIE5_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE5` writer - Timer/Counter5 Overflow Interrupt Enable"]
pub type TOIE5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK5_SPEC , bool , O > ; # [doc = "Field `OCIE5A` reader - Timer/Counter5 Output Compare A Match Interrupt Enable"]
pub type OCIE5A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE5A` writer - Timer/Counter5 Output Compare A Match Interrupt Enable"]
pub type OCIE5A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK5_SPEC , bool , O > ; # [doc = "Field `OCIE5B` reader - Timer/Counter5 Output Compare B Match Interrupt Enable"]
pub type OCIE5B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE5B` writer - Timer/Counter5 Output Compare B Match Interrupt Enable"]
pub type OCIE5B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK5_SPEC , bool , O > ; # [doc = "Field `OCIE5C` reader - Timer/Counter5 Output Compare C Match Interrupt Enable"]
pub type OCIE5C_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE5C` writer - Timer/Counter5 Output Compare C Match Interrupt Enable"]
pub type OCIE5C_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK5_SPEC , bool , O > ; # [doc = "Field `ICIE5` reader - Timer/Counter5 Input Capture Interrupt Enable"]
pub type ICIE5_R = crate :: BitReader < bool > ; # [doc = "Field `ICIE5` writer - Timer/Counter5 Input Capture Interrupt Enable"]
pub type ICIE5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK5_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter5 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie5 (& self) -> TOIE5_R { TOIE5_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter5 Output Compare A Match Interrupt Enable"]
# [inline (always)]
pub fn ocie5a (& self) -> OCIE5A_R { OCIE5A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter5 Output Compare B Match Interrupt Enable"]
# [inline (always)]
pub fn ocie5b (& self) -> OCIE5B_R { OCIE5B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer/Counter5 Output Compare C Match Interrupt Enable"]
# [inline (always)]
pub fn ocie5c (& self) -> OCIE5C_R { OCIE5C_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter5 Input Capture Interrupt Enable"]
# [inline (always)]
pub fn icie5 (& self) -> ICIE5_R { ICIE5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter5 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie5 (& mut self) -> TOIE5_W < 0 > { TOIE5_W :: new (self) } # [doc = "Bit 1 - Timer/Counter5 Output Compare A Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie5a (& mut self) -> OCIE5A_W < 1 > { OCIE5A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter5 Output Compare B Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie5b (& mut self) -> OCIE5B_W < 2 > { OCIE5B_W :: new (self) } # [doc = "Bit 3 - Timer/Counter5 Output Compare C Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie5c (& mut self) -> OCIE5C_W < 3 > { OCIE5C_W :: new (self) } # [doc = "Bit 5 - Timer/Counter5 Input Capture Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn icie5 (& mut self) -> ICIE5_W < 5 > { ICIE5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter5 Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk5](index.html) module"]
pub struct TIMSK5_SPEC ; impl crate :: RegisterSpec for TIMSK5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk5::R](R) reader structure"]
impl crate :: Readable for TIMSK5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk5::W](W) writer structure"]
impl crate :: Writable for TIMSK5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK5 to value 0"]
impl crate :: Resettable for TIMSK5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Low-Power 2.4 GHz Transceiver"]
pub struct TRX24 { _marker : PhantomData < * const () > } unsafe impl Send for TRX24 { } impl TRX24 { # [doc = r"Pointer to the register block"]
pub const PTR : * const trx24 :: RegisterBlock = 0x013c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const trx24 :: RegisterBlock { Self :: PTR } } impl Deref for TRX24 { type Target = trx24 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TRX24 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TRX24") . finish () } } # [doc = "Low-Power 2.4 GHz Transceiver"]
pub mod trx24 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - AES Control Register"]
pub aes_ctrl : AES_CTRL , # [doc = "0x01 - AES Status Register"]
pub aes_status : AES_STATUS , # [doc = "0x02 - AES Plain and Cipher Text Buffer Register"]
pub aes_state : AES_STATE , # [doc = "0x03 - AES Encryption and Decryption Key Buffer Register"]
pub aes_key : AES_KEY , _reserved4 : [u8 ; 0x01]
, # [doc = "0x05 - Transceiver Status Register"]
pub trx_status : TRX_STATUS , # [doc = "0x06 - Transceiver State Control Register"]
pub trx_state : TRX_STATE , # [doc = "0x07 - Reserved"]
pub trx_ctrl_0 : TRX_CTRL_0 , # [doc = "0x08 - Transceiver Control Register 1"]
pub trx_ctrl_1 : TRX_CTRL_1 , # [doc = "0x09 - Transceiver Transmit Power Control Register"]
pub phy_tx_pwr : PHY_TX_PWR , # [doc = "0x0a - Receiver Signal Strength Indicator Register"]
pub phy_rssi : PHY_RSSI , # [doc = "0x0b - Transceiver Energy Detection Level Register"]
pub phy_ed_level : PHY_ED_LEVEL , # [doc = "0x0c - Transceiver Clear Channel Assessment (CCA) Control Register"]
pub phy_cc_cca : PHY_CC_CCA , # [doc = "0x0d - Transceiver CCA Threshold Setting Register"]
pub cca_thres : CCA_THRES , # [doc = "0x0e - Transceiver Receive Control Register"]
pub rx_ctrl : RX_CTRL , # [doc = "0x0f - Start of Frame Delimiter Value Register"]
pub sfd_value : SFD_VALUE , # [doc = "0x10 - Transceiver Control Register 2"]
pub trx_ctrl_2 : TRX_CTRL_2 , # [doc = "0x11 - Antenna Diversity Control Register"]
pub ant_div : ANT_DIV , # [doc = "0x12 - Transceiver Interrupt Enable Register"]
pub irq_mask : IRQ_MASK , # [doc = "0x13 - Transceiver Interrupt Status Register"]
pub irq_status : IRQ_STATUS , # [doc = "0x14 - Voltage Regulator Control and Status Register"]
pub vreg_ctrl : VREG_CTRL , # [doc = "0x15 - Battery Monitor Control and Status Register"]
pub batmon : BATMON , # [doc = "0x16 - Crystal Oscillator Control Register"]
pub xosc_ctrl : XOSC_CTRL , _reserved22 : [u8 ; 0x02]
, # [doc = "0x19 - Transceiver Receiver Sensitivity Control Register"]
pub rx_syn : RX_SYN , _reserved23 : [u8 ; 0x01]
, # [doc = "0x1b - Transceiver Acknowledgment Frame Control Register 1"]
pub xah_ctrl_1 : XAH_CTRL_1 , # [doc = "0x1c - Transceiver Filter Tuning Control Register"]
pub ftn_ctrl : FTN_CTRL , _reserved25 : [u8 ; 0x01]
, # [doc = "0x1e - Transceiver Center Frequency Calibration Control Register"]
pub pll_cf : PLL_CF , # [doc = "0x1f - Transceiver Delay Cell Calibration Control Register"]
pub pll_dcu : PLL_DCU , # [doc = "0x20 - Device Identification Register (Part Number)"]
pub part_num : PART_NUM , # [doc = "0x21 - Device Identification Register (Version Number)"]
pub version_num : VERSION_NUM , # [doc = "0x22 - Device Identification Register (Manufacture ID Low Byte)"]
pub man_id_0 : MAN_ID_0 , # [doc = "0x23 - Device Identification Register (Manufacture ID High Byte)"]
pub man_id_1 : MAN_ID_1 , # [doc = "0x24 - Transceiver MAC Short Address Register (Low Byte)"]
pub short_addr_0 : SHORT_ADDR_0 , # [doc = "0x25 - Transceiver MAC Short Address Register (High Byte)"]
pub short_addr_1 : SHORT_ADDR_1 , # [doc = "0x26 - Transceiver Personal Area Network ID Register (Low Byte)"]
pub pan_id_0 : PAN_ID_0 , # [doc = "0x27 - Transceiver Personal Area Network ID Register (High Byte)"]
pub pan_id_1 : PAN_ID_1 , # [doc = "0x28 - Transceiver MAC IEEE Address Register 0"]
pub ieee_addr_0 : IEEE_ADDR_0 , # [doc = "0x29 - Transceiver MAC IEEE Address Register 1"]
pub ieee_addr_1 : IEEE_ADDR_1 , # [doc = "0x2a - Transceiver MAC IEEE Address Register 2"]
pub ieee_addr_2 : IEEE_ADDR_2 , # [doc = "0x2b - Transceiver MAC IEEE Address Register 3"]
pub ieee_addr_3 : IEEE_ADDR_3 , # [doc = "0x2c - Transceiver MAC IEEE Address Register 4"]
pub ieee_addr_4 : IEEE_ADDR_4 , # [doc = "0x2d - Transceiver MAC IEEE Address Register 5"]
pub ieee_addr_5 : IEEE_ADDR_5 , # [doc = "0x2e - Transceiver MAC IEEE Address Register 6"]
pub ieee_addr_6 : IEEE_ADDR_6 , # [doc = "0x2f - Transceiver MAC IEEE Address Register 7"]
pub ieee_addr_7 : IEEE_ADDR_7 , # [doc = "0x30 - Transceiver Extended Operating Mode Control Register"]
pub xah_ctrl_0 : XAH_CTRL_0 , # [doc = "0x31 - Transceiver CSMA-CA Random Number Generator Seed Register"]
pub csma_seed_0 : CSMA_SEED_0 , # [doc = "0x32 - Transceiver Acknowledgment Frame Control Register 2"]
pub csma_seed_1 : CSMA_SEED_1 , # [doc = "0x33 - Transceiver CSMA-CA Back-off Exponent Control Register"]
pub csma_be : CSMA_BE , _reserved47 : [u8 ; 0x06]
, # [doc = "0x3a - Transceiver Digital Test Control Register"]
pub tst_ctrl_digi : TST_CTRL_DIGI , _reserved48 : [u8 ; 0x04]
, # [doc = "0x3f - Transceiver Received Frame Length Register"]
pub tst_rx_length : TST_RX_LENGTH , _reserved49 : [u8 ; 0x04]
, # [doc = "0x44 - Start of frame buffer"]
pub trxfbst : TRXFBST , _reserved50 : [u8 ; 0x7e]
, # [doc = "0xc3 - End of frame buffer"]
pub trxfbend : TRXFBEND , } # [doc = "AES_CTRL (rw) register accessor: an alias for `Reg<AES_CTRL_SPEC>`"]
pub type AES_CTRL = crate :: Reg < aes_ctrl :: AES_CTRL_SPEC > ; # [doc = "AES Control Register"]
pub mod aes_ctrl { # [doc = "Register `AES_CTRL` reader"]
pub struct R (crate :: R < AES_CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AES_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AES_CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AES_CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AES_CTRL` writer"]
pub struct W (crate :: W < AES_CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AES_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AES_CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AES_CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `AES_IM` reader - AES Interrupt Enable"]
pub type AES_IM_R = crate :: BitReader < bool > ; # [doc = "Field `AES_IM` writer - AES Interrupt Enable"]
pub type AES_IM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AES_CTRL_SPEC , bool , O > ; # [doc = "Field `AES_DIR` reader - Set AES Operation Direction"]
pub type AES_DIR_R = crate :: BitReader < AES_DIR_A > ; # [doc = "Set AES Operation Direction\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AES_DIR_A { # [doc = "0: AES operation is encryption."]
AES_DIR_ENC = 0 , # [doc = "1: AES operation is decryption."]
AES_DIR_DEC = 1 , } impl From < AES_DIR_A > for bool { # [inline (always)]
fn from (variant : AES_DIR_A) -> Self { variant as u8 != 0 } } impl AES_DIR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AES_DIR_A { match self . bits { false => AES_DIR_A :: AES_DIR_ENC , true => AES_DIR_A :: AES_DIR_DEC , } } # [doc = "Checks if the value of the field is `AES_DIR_ENC`"]
# [inline (always)]
pub fn is_aes_dir_enc (& self) -> bool { * self == AES_DIR_A :: AES_DIR_ENC } # [doc = "Checks if the value of the field is `AES_DIR_DEC`"]
# [inline (always)]
pub fn is_aes_dir_dec (& self) -> bool { * self == AES_DIR_A :: AES_DIR_DEC } } # [doc = "Field `AES_DIR` writer - Set AES Operation Direction"]
pub type AES_DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AES_CTRL_SPEC , AES_DIR_A , O > ; impl < 'a , const O : u8 > AES_DIR_W < 'a , O > { # [doc = "AES operation is encryption."]
# [inline (always)]
pub fn aes_dir_enc (self) -> & 'a mut W { self . variant (AES_DIR_A :: AES_DIR_ENC) } # [doc = "AES operation is decryption."]
# [inline (always)]
pub fn aes_dir_dec (self) -> & 'a mut W { self . variant (AES_DIR_A :: AES_DIR_DEC) } } # [doc = "Field `AES_MODE` reader - Set AES Operation Mode"]
pub type AES_MODE_R = crate :: BitReader < AES_MODE_A > ; # [doc = "Set AES Operation Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AES_MODE_A { # [doc = "0: AES Mode is ECB (Electronic Code Book)."]
AES_MODE_ECB = 0 , # [doc = "1: AES Mode is CBC (Cipher Block Chaining)."]
AES_MODE_CBC = 1 , } impl From < AES_MODE_A > for bool { # [inline (always)]
fn from (variant : AES_MODE_A) -> Self { variant as u8 != 0 } } impl AES_MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AES_MODE_A { match self . bits { false => AES_MODE_A :: AES_MODE_ECB , true => AES_MODE_A :: AES_MODE_CBC , } } # [doc = "Checks if the value of the field is `AES_MODE_ECB`"]
# [inline (always)]
pub fn is_aes_mode_ecb (& self) -> bool { * self == AES_MODE_A :: AES_MODE_ECB } # [doc = "Checks if the value of the field is `AES_MODE_CBC`"]
# [inline (always)]
pub fn is_aes_mode_cbc (& self) -> bool { * self == AES_MODE_A :: AES_MODE_CBC } } # [doc = "Field `AES_MODE` writer - Set AES Operation Mode"]
pub type AES_MODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AES_CTRL_SPEC , AES_MODE_A , O > ; impl < 'a , const O : u8 > AES_MODE_W < 'a , O > { # [doc = "AES Mode is ECB (Electronic Code Book)."]
# [inline (always)]
pub fn aes_mode_ecb (self) -> & 'a mut W { self . variant (AES_MODE_A :: AES_MODE_ECB) } # [doc = "AES Mode is CBC (Cipher Block Chaining)."]
# [inline (always)]
pub fn aes_mode_cbc (self) -> & 'a mut W { self . variant (AES_MODE_A :: AES_MODE_CBC) } } # [doc = "Field `AES_REQUEST` reader - Request AES Operation."]
pub type AES_REQUEST_R = crate :: BitReader < bool > ; # [doc = "Field `AES_REQUEST` writer - Request AES Operation."]
pub type AES_REQUEST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AES_CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 2 - AES Interrupt Enable"]
# [inline (always)]
pub fn aes_im (& self) -> AES_IM_R { AES_IM_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Set AES Operation Direction"]
# [inline (always)]
pub fn aes_dir (& self) -> AES_DIR_R { AES_DIR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Set AES Operation Mode"]
# [inline (always)]
pub fn aes_mode (& self) -> AES_MODE_R { AES_MODE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 7 - Request AES Operation."]
# [inline (always)]
pub fn aes_request (& self) -> AES_REQUEST_R { AES_REQUEST_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 2 - AES Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn aes_im (& mut self) -> AES_IM_W < 2 > { AES_IM_W :: new (self) } # [doc = "Bit 3 - Set AES Operation Direction"]
# [inline (always)]
# [must_use]
pub fn aes_dir (& mut self) -> AES_DIR_W < 3 > { AES_DIR_W :: new (self) } # [doc = "Bit 5 - Set AES Operation Mode"]
# [inline (always)]
# [must_use]
pub fn aes_mode (& mut self) -> AES_MODE_W < 5 > { AES_MODE_W :: new (self) } # [doc = "Bit 7 - Request AES Operation."]
# [inline (always)]
# [must_use]
pub fn aes_request (& mut self) -> AES_REQUEST_W < 7 > { AES_REQUEST_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "AES Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [aes_ctrl](index.html) module"]
pub struct AES_CTRL_SPEC ; impl crate :: RegisterSpec for AES_CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [aes_ctrl::R](R) reader structure"]
impl crate :: Readable for AES_CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [aes_ctrl::W](W) writer structure"]
impl crate :: Writable for AES_CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AES_CTRL to value 0"]
impl crate :: Resettable for AES_CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AES_KEY (rw) register accessor: an alias for `Reg<AES_KEY_SPEC>`"]
pub type AES_KEY = crate :: Reg < aes_key :: AES_KEY_SPEC > ; # [doc = "AES Encryption and Decryption Key Buffer Register"]
pub mod aes_key { # [doc = "Register `AES_KEY` reader"]
pub struct R (crate :: R < AES_KEY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AES_KEY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AES_KEY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AES_KEY_SPEC >) -> Self { R (reader) } } # [doc = "Register `AES_KEY` writer"]
pub struct W (crate :: W < AES_KEY_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AES_KEY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AES_KEY_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AES_KEY_SPEC >) -> Self { W (writer) } } # [doc = "Field `AES_KEY` reader - AES Encryption/Decryption Key Buffer"]
pub type AES_KEY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `AES_KEY` writer - AES Encryption/Decryption Key Buffer"]
pub type AES_KEY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AES_KEY_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - AES Encryption/Decryption Key Buffer"]
# [inline (always)]
pub fn aes_key (& self) -> AES_KEY_R { AES_KEY_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - AES Encryption/Decryption Key Buffer"]
# [inline (always)]
# [must_use]
pub fn aes_key (& mut self) -> AES_KEY_W < 0 > { AES_KEY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "AES Encryption and Decryption Key Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [aes_key](index.html) module"]
pub struct AES_KEY_SPEC ; impl crate :: RegisterSpec for AES_KEY_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [aes_key::R](R) reader structure"]
impl crate :: Readable for AES_KEY_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [aes_key::W](W) writer structure"]
impl crate :: Writable for AES_KEY_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AES_KEY to value 0"]
impl crate :: Resettable for AES_KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AES_STATE (rw) register accessor: an alias for `Reg<AES_STATE_SPEC>`"]
pub type AES_STATE = crate :: Reg < aes_state :: AES_STATE_SPEC > ; # [doc = "AES Plain and Cipher Text Buffer Register"]
pub mod aes_state { # [doc = "Register `AES_STATE` reader"]
pub struct R (crate :: R < AES_STATE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AES_STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AES_STATE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AES_STATE_SPEC >) -> Self { R (reader) } } # [doc = "Register `AES_STATE` writer"]
pub struct W (crate :: W < AES_STATE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AES_STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AES_STATE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AES_STATE_SPEC >) -> Self { W (writer) } } # [doc = "Field `AES_STATE` reader - AES Plain and Cipher Text Buffer"]
pub type AES_STATE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `AES_STATE` writer - AES Plain and Cipher Text Buffer"]
pub type AES_STATE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AES_STATE_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - AES Plain and Cipher Text Buffer"]
# [inline (always)]
pub fn aes_state (& self) -> AES_STATE_R { AES_STATE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - AES Plain and Cipher Text Buffer"]
# [inline (always)]
# [must_use]
pub fn aes_state (& mut self) -> AES_STATE_W < 0 > { AES_STATE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "AES Plain and Cipher Text Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [aes_state](index.html) module"]
pub struct AES_STATE_SPEC ; impl crate :: RegisterSpec for AES_STATE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [aes_state::R](R) reader structure"]
impl crate :: Readable for AES_STATE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [aes_state::W](W) writer structure"]
impl crate :: Writable for AES_STATE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AES_STATE to value 0"]
impl crate :: Resettable for AES_STATE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AES_STATUS (rw) register accessor: an alias for `Reg<AES_STATUS_SPEC>`"]
pub type AES_STATUS = crate :: Reg < aes_status :: AES_STATUS_SPEC > ; # [doc = "AES Status Register"]
pub mod aes_status { # [doc = "Register `AES_STATUS` reader"]
pub struct R (crate :: R < AES_STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AES_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AES_STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AES_STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `AES_STATUS` writer"]
pub struct W (crate :: W < AES_STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AES_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AES_STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AES_STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `AES_DONE` reader - AES Operation Finished with Success"]
pub type AES_DONE_R = crate :: BitReader < bool > ; # [doc = "Field `AES_DONE` writer - AES Operation Finished with Success"]
pub type AES_DONE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AES_STATUS_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AES_STATUS_SPEC , u8 , u8 , 6 , O > ; # [doc = "Field `AES_ER` reader - AES Operation Finished with Error"]
pub type AES_ER_R = crate :: BitReader < bool > ; # [doc = "Field `AES_ER` writer - AES Operation Finished with Error"]
pub type AES_ER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AES_STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - AES Operation Finished with Success"]
# [inline (always)]
pub fn aes_done (& self) -> AES_DONE_R { AES_DONE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:6 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 1) & 0x3f) } # [doc = "Bit 7 - AES Operation Finished with Error"]
# [inline (always)]
pub fn aes_er (& self) -> AES_ER_R { AES_ER_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - AES Operation Finished with Success"]
# [inline (always)]
# [must_use]
pub fn aes_done (& mut self) -> AES_DONE_W < 0 > { AES_DONE_W :: new (self) } # [doc = "Bits 1:6 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 1 > { RES_W :: new (self) } # [doc = "Bit 7 - AES Operation Finished with Error"]
# [inline (always)]
# [must_use]
pub fn aes_er (& mut self) -> AES_ER_W < 7 > { AES_ER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "AES Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [aes_status](index.html) module"]
pub struct AES_STATUS_SPEC ; impl crate :: RegisterSpec for AES_STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [aes_status::R](R) reader structure"]
impl crate :: Readable for AES_STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [aes_status::W](W) writer structure"]
impl crate :: Writable for AES_STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AES_STATUS to value 0"]
impl crate :: Resettable for AES_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ANT_DIV (rw) register accessor: an alias for `Reg<ANT_DIV_SPEC>`"]
pub type ANT_DIV = crate :: Reg < ant_div :: ANT_DIV_SPEC > ; # [doc = "Antenna Diversity Control Register"]
pub mod ant_div { # [doc = "Register `ANT_DIV` reader"]
pub struct R (crate :: R < ANT_DIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ANT_DIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ANT_DIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ANT_DIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `ANT_DIV` writer"]
pub struct W (crate :: W < ANT_DIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ANT_DIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ANT_DIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ANT_DIV_SPEC >) -> Self { W (writer) } } # [doc = "Field `ANT_CTRL` reader - Static Antenna Diversity Switch Control"]
pub type ANT_CTRL_R = crate :: FieldReader < u8 , ANT_CTRL_A > ; # [doc = "Static Antenna Diversity Switch Control\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ANT_CTRL_A { # [doc = "1: Antenna 1: DIG1=H, DIG2=L"]
ANT_1 = 1 , # [doc = "2: Antenna 0: DIG1=L, DIG2=H"]
ANT_0 = 2 , # [doc = "3: Default value for ANT_EXT_SW_EN=0; Mandatory setting for applications not using Antenna Diversity"]
ANT_RESET = 3 , } impl From < ANT_CTRL_A > for u8 { # [inline (always)]
fn from (variant : ANT_CTRL_A) -> Self { variant as _ } } impl ANT_CTRL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ANT_CTRL_A { match self . bits { 1 => ANT_CTRL_A :: ANT_1 , 2 => ANT_CTRL_A :: ANT_0 , 3 => ANT_CTRL_A :: ANT_RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ANT_1`"]
# [inline (always)]
pub fn is_ant_1 (& self) -> bool { * self == ANT_CTRL_A :: ANT_1 } # [doc = "Checks if the value of the field is `ANT_0`"]
# [inline (always)]
pub fn is_ant_0 (& self) -> bool { * self == ANT_CTRL_A :: ANT_0 } # [doc = "Checks if the value of the field is `ANT_RESET`"]
# [inline (always)]
pub fn is_ant_reset (& self) -> bool { * self == ANT_CTRL_A :: ANT_RESET } } # [doc = "Field `ANT_CTRL` writer - Static Antenna Diversity Switch Control"]
pub type ANT_CTRL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ANT_DIV_SPEC , u8 , ANT_CTRL_A , 2 , O > ; impl < 'a , const O : u8 > ANT_CTRL_W < 'a , O > { # [doc = "Antenna 1: DIG1=H, DIG2=L"]
# [inline (always)]
pub fn ant_1 (self) -> & 'a mut W { self . variant (ANT_CTRL_A :: ANT_1) } # [doc = "Antenna 0: DIG1=L, DIG2=H"]
# [inline (always)]
pub fn ant_0 (self) -> & 'a mut W { self . variant (ANT_CTRL_A :: ANT_0) } # [doc = "Default value for ANT_EXT_SW_EN=0; Mandatory setting for applications not using Antenna Diversity"]
# [inline (always)]
pub fn ant_reset (self) -> & 'a mut W { self . variant (ANT_CTRL_A :: ANT_RESET) } } # [doc = "Field `ANT_EXT_SW_EN` reader - Enable External Antenna Switch Control"]
pub type ANT_EXT_SW_EN_R = crate :: BitReader < ANT_EXT_SW_EN_A > ; # [doc = "Enable External Antenna Switch Control\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ANT_EXT_SW_EN_A { # [doc = "0: Antenna Diversity RF switch control disabled"]
ANT_DIV_EXT_SW_DIS = 0 , # [doc = "1: Antenna Diversity RF switch control enabled"]
ANT_DIV_EXT_SW_EN = 1 , } impl From < ANT_EXT_SW_EN_A > for bool { # [inline (always)]
fn from (variant : ANT_EXT_SW_EN_A) -> Self { variant as u8 != 0 } } impl ANT_EXT_SW_EN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ANT_EXT_SW_EN_A { match self . bits { false => ANT_EXT_SW_EN_A :: ANT_DIV_EXT_SW_DIS , true => ANT_EXT_SW_EN_A :: ANT_DIV_EXT_SW_EN , } } # [doc = "Checks if the value of the field is `ANT_DIV_EXT_SW_DIS`"]
# [inline (always)]
pub fn is_ant_div_ext_sw_dis (& self) -> bool { * self == ANT_EXT_SW_EN_A :: ANT_DIV_EXT_SW_DIS } # [doc = "Checks if the value of the field is `ANT_DIV_EXT_SW_EN`"]
# [inline (always)]
pub fn is_ant_div_ext_sw_en (& self) -> bool { * self == ANT_EXT_SW_EN_A :: ANT_DIV_EXT_SW_EN } } # [doc = "Field `ANT_EXT_SW_EN` writer - Enable External Antenna Switch Control"]
pub type ANT_EXT_SW_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ANT_DIV_SPEC , ANT_EXT_SW_EN_A , O > ; impl < 'a , const O : u8 > ANT_EXT_SW_EN_W < 'a , O > { # [doc = "Antenna Diversity RF switch control disabled"]
# [inline (always)]
pub fn ant_div_ext_sw_dis (self) -> & 'a mut W { self . variant (ANT_EXT_SW_EN_A :: ANT_DIV_EXT_SW_DIS) } # [doc = "Antenna Diversity RF switch control enabled"]
# [inline (always)]
pub fn ant_div_ext_sw_en (self) -> & 'a mut W { self . variant (ANT_EXT_SW_EN_A :: ANT_DIV_EXT_SW_EN) } } # [doc = "Field `ANT_DIV_EN` reader - Enable Antenna Diversity"]
pub type ANT_DIV_EN_R = crate :: BitReader < ANT_DIV_EN_A > ; # [doc = "Enable Antenna Diversity\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ANT_DIV_EN_A { # [doc = "0: Antenna Diversity algorithm disabled"]
ANTENNA_DIVERSITY_ALGORITHM_DISABLED = 0 , # [doc = "1: Antenna Diversity algorithm enabled"]
ANTENNA_DIVERSITY_ALGORITHM_ENABLED = 1 , } impl From < ANT_DIV_EN_A > for bool { # [inline (always)]
fn from (variant : ANT_DIV_EN_A) -> Self { variant as u8 != 0 } } impl ANT_DIV_EN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ANT_DIV_EN_A { match self . bits { false => ANT_DIV_EN_A :: ANTENNA_DIVERSITY_ALGORITHM_DISABLED , true => ANT_DIV_EN_A :: ANTENNA_DIVERSITY_ALGORITHM_ENABLED , } } # [doc = "Checks if the value of the field is `ANTENNA_DIVERSITY_ALGORITHM_DISABLED`"]
# [inline (always)]
pub fn is_antenna_diversity_algorithm_disabled (& self) -> bool { * self == ANT_DIV_EN_A :: ANTENNA_DIVERSITY_ALGORITHM_DISABLED } # [doc = "Checks if the value of the field is `ANTENNA_DIVERSITY_ALGORITHM_ENABLED`"]
# [inline (always)]
pub fn is_antenna_diversity_algorithm_enabled (& self) -> bool { * self == ANT_DIV_EN_A :: ANTENNA_DIVERSITY_ALGORITHM_ENABLED } } # [doc = "Field `ANT_DIV_EN` writer - Enable Antenna Diversity"]
pub type ANT_DIV_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ANT_DIV_SPEC , ANT_DIV_EN_A , O > ; impl < 'a , const O : u8 > ANT_DIV_EN_W < 'a , O > { # [doc = "Antenna Diversity algorithm disabled"]
# [inline (always)]
pub fn antenna_diversity_algorithm_disabled (self) -> & 'a mut W { self . variant (ANT_DIV_EN_A :: ANTENNA_DIVERSITY_ALGORITHM_DISABLED) } # [doc = "Antenna Diversity algorithm enabled"]
# [inline (always)]
pub fn antenna_diversity_algorithm_enabled (self) -> & 'a mut W { self . variant (ANT_DIV_EN_A :: ANTENNA_DIVERSITY_ALGORITHM_ENABLED) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ANT_DIV_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `ANT_SEL` reader - Antenna Diversity Antenna Status"]
pub type ANT_SEL_R = crate :: BitReader < ANT_SEL_A > ; # [doc = "Antenna Diversity Antenna Status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ANT_SEL_A { # [doc = "0: Antenna 0"]
ANTENNA_0 = 0 , # [doc = "1: Antenna 1"]
ANTENNA_1 = 1 , } impl From < ANT_SEL_A > for bool { # [inline (always)]
fn from (variant : ANT_SEL_A) -> Self { variant as u8 != 0 } } impl ANT_SEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ANT_SEL_A { match self . bits { false => ANT_SEL_A :: ANTENNA_0 , true => ANT_SEL_A :: ANTENNA_1 , } } # [doc = "Checks if the value of the field is `ANTENNA_0`"]
# [inline (always)]
pub fn is_antenna_0 (& self) -> bool { * self == ANT_SEL_A :: ANTENNA_0 } # [doc = "Checks if the value of the field is `ANTENNA_1`"]
# [inline (always)]
pub fn is_antenna_1 (& self) -> bool { * self == ANT_SEL_A :: ANTENNA_1 } } # [doc = "Field `ANT_SEL` writer - Antenna Diversity Antenna Status"]
pub type ANT_SEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ANT_DIV_SPEC , ANT_SEL_A , O > ; impl < 'a , const O : u8 > ANT_SEL_W < 'a , O > { # [doc = "Antenna 0"]
# [inline (always)]
pub fn antenna_0 (self) -> & 'a mut W { self . variant (ANT_SEL_A :: ANTENNA_0) } # [doc = "Antenna 1"]
# [inline (always)]
pub fn antenna_1 (self) -> & 'a mut W { self . variant (ANT_SEL_A :: ANTENNA_1) } } impl R { # [doc = "Bits 0:1 - Static Antenna Diversity Switch Control"]
# [inline (always)]
pub fn ant_ctrl (& self) -> ANT_CTRL_R { ANT_CTRL_R :: new (self . bits & 3) } # [doc = "Bit 2 - Enable External Antenna Switch Control"]
# [inline (always)]
pub fn ant_ext_sw_en (& self) -> ANT_EXT_SW_EN_R { ANT_EXT_SW_EN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Enable Antenna Diversity"]
# [inline (always)]
pub fn ant_div_en (& self) -> ANT_DIV_EN_R { ANT_DIV_EN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:6 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 4) & 7) } # [doc = "Bit 7 - Antenna Diversity Antenna Status"]
# [inline (always)]
pub fn ant_sel (& self) -> ANT_SEL_R { ANT_SEL_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Static Antenna Diversity Switch Control"]
# [inline (always)]
# [must_use]
pub fn ant_ctrl (& mut self) -> ANT_CTRL_W < 0 > { ANT_CTRL_W :: new (self) } # [doc = "Bit 2 - Enable External Antenna Switch Control"]
# [inline (always)]
# [must_use]
pub fn ant_ext_sw_en (& mut self) -> ANT_EXT_SW_EN_W < 2 > { ANT_EXT_SW_EN_W :: new (self) } # [doc = "Bit 3 - Enable Antenna Diversity"]
# [inline (always)]
# [must_use]
pub fn ant_div_en (& mut self) -> ANT_DIV_EN_W < 3 > { ANT_DIV_EN_W :: new (self) } # [doc = "Bits 4:6 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 4 > { RES_W :: new (self) } # [doc = "Bit 7 - Antenna Diversity Antenna Status"]
# [inline (always)]
# [must_use]
pub fn ant_sel (& mut self) -> ANT_SEL_W < 7 > { ANT_SEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Antenna Diversity Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ant_div](index.html) module"]
pub struct ANT_DIV_SPEC ; impl crate :: RegisterSpec for ANT_DIV_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ant_div::R](R) reader structure"]
impl crate :: Readable for ANT_DIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ant_div::W](W) writer structure"]
impl crate :: Writable for ANT_DIV_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ANT_DIV to value 0"]
impl crate :: Resettable for ANT_DIV_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BATMON (rw) register accessor: an alias for `Reg<BATMON_SPEC>`"]
pub type BATMON = crate :: Reg < batmon :: BATMON_SPEC > ; # [doc = "Battery Monitor Control and Status Register"]
pub mod batmon { # [doc = "Register `BATMON` reader"]
pub struct R (crate :: R < BATMON_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BATMON_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BATMON_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BATMON_SPEC >) -> Self { R (reader) } } # [doc = "Register `BATMON` writer"]
pub struct W (crate :: W < BATMON_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BATMON_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BATMON_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BATMON_SPEC >) -> Self { W (writer) } } # [doc = "Field `BATMON_VTH` reader - Battery Monitor Threshold Voltage"]
pub type BATMON_VTH_R = crate :: FieldReader < u8 , BATMON_VTH_A > ; # [doc = "Battery Monitor Threshold Voltage\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BATMON_VTH_A { # [doc = "0: 2.550V (BATMON_HR=1) 1.70V (BATMON_HR=0)"]
_2_550V_BATMON_HR_1_1_70V_BATMON_HR_0 = 0 , # [doc = "1: 2.625V (BATMON_HR=1) 1.75V (BATMON_HR=0)"]
_2_625V_BATMON_HR_1_1_75V_BATMON_HR_0 = 1 , # [doc = "2: 2.700V (BATMON_HR=1) 1.80V (BATMON_HR=0)"]
_2_700V_BATMON_HR_1_1_80V_BATMON_HR_0 = 2 , # [doc = "3: 2.775V (BATMON_HR=1) 1.85V (BATMON_HR=0)"]
_2_775V_BATMON_HR_1_1_85V_BATMON_HR_0 = 3 , # [doc = "4: 2.850V (BATMON_HR=1) 1.90V (BATMON_HR=0)"]
_2_850V_BATMON_HR_1_1_90V_BATMON_HR_0 = 4 , # [doc = "5: 2.925V (BATMON_HR=1) 1.95V (BATMON_HR=0)"]
_2_925V_BATMON_HR_1_1_95V_BATMON_HR_0 = 5 , # [doc = "6: 3.000V (BATMON_HR=1) 2.00V (BATMON_HR=0)"]
_3_000V_BATMON_HR_1_2_00V_BATMON_HR_0 = 6 , # [doc = "7: 3.075V (BATMON_HR=1) 2.05V (BATMON_HR=0)"]
_3_075V_BATMON_HR_1_2_05V_BATMON_HR_0 = 7 , # [doc = "8: 3.150V (BATMON_HR=1) 2.10V (BATMON_HR=0)"]
_3_150V_BATMON_HR_1_2_10V_BATMON_HR_0 = 8 , # [doc = "9: 3.225V (BATMON_HR=1) 2.15V (BATMON_HR=0)"]
_3_225V_BATMON_HR_1_2_15V_BATMON_HR_0 = 9 , # [doc = "10: 3.300V (BATMON_HR=1) 2.20V (BATMON_HR=0)"]
_3_300V_BATMON_HR_1_2_20V_BATMON_HR_0 = 10 , # [doc = "11: 3.375V (BATMON_HR=1) 2.25V (BATMON_HR=0)"]
_3_375V_BATMON_HR_1_2_25V_BATMON_HR_0 = 11 , # [doc = "12: 3.450V (BATMON_HR=1) 2.30V (BATMON_HR=0)"]
_3_450V_BATMON_HR_1_2_30V_BATMON_HR_0 = 12 , # [doc = "13: 3.525V (BATMON_HR=1) 2.35V (BATMON_HR=0)"]
_3_525V_BATMON_HR_1_2_35V_BATMON_HR_0 = 13 , # [doc = "14: 3.600V (BATMON_HR=1) 2.40V (BATMON_HR=0)"]
_3_600V_BATMON_HR_1_2_40V_BATMON_HR_0 = 14 , # [doc = "15: 3.675V (BATMON_HR=1) 2.45V (BATMON_HR=0)"]
_3_675V_BATMON_HR_1_2_45V_BATMON_HR_0 = 15 , } impl From < BATMON_VTH_A > for u8 { # [inline (always)]
fn from (variant : BATMON_VTH_A) -> Self { variant as _ } } impl BATMON_VTH_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BATMON_VTH_A { match self . bits { 0 => BATMON_VTH_A :: _2_550V_BATMON_HR_1_1_70V_BATMON_HR_0 , 1 => BATMON_VTH_A :: _2_625V_BATMON_HR_1_1_75V_BATMON_HR_0 , 2 => BATMON_VTH_A :: _2_700V_BATMON_HR_1_1_80V_BATMON_HR_0 , 3 => BATMON_VTH_A :: _2_775V_BATMON_HR_1_1_85V_BATMON_HR_0 , 4 => BATMON_VTH_A :: _2_850V_BATMON_HR_1_1_90V_BATMON_HR_0 , 5 => BATMON_VTH_A :: _2_925V_BATMON_HR_1_1_95V_BATMON_HR_0 , 6 => BATMON_VTH_A :: _3_000V_BATMON_HR_1_2_00V_BATMON_HR_0 , 7 => BATMON_VTH_A :: _3_075V_BATMON_HR_1_2_05V_BATMON_HR_0 , 8 => BATMON_VTH_A :: _3_150V_BATMON_HR_1_2_10V_BATMON_HR_0 , 9 => BATMON_VTH_A :: _3_225V_BATMON_HR_1_2_15V_BATMON_HR_0 , 10 => BATMON_VTH_A :: _3_300V_BATMON_HR_1_2_20V_BATMON_HR_0 , 11 => BATMON_VTH_A :: _3_375V_BATMON_HR_1_2_25V_BATMON_HR_0 , 12 => BATMON_VTH_A :: _3_450V_BATMON_HR_1_2_30V_BATMON_HR_0 , 13 => BATMON_VTH_A :: _3_525V_BATMON_HR_1_2_35V_BATMON_HR_0 , 14 => BATMON_VTH_A :: _3_600V_BATMON_HR_1_2_40V_BATMON_HR_0 , 15 => BATMON_VTH_A :: _3_675V_BATMON_HR_1_2_45V_BATMON_HR_0 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_2_550V_BATMON_HR_1_1_70V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_2_550v_batmon_hr_1_1_70v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _2_550V_BATMON_HR_1_1_70V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_2_625V_BATMON_HR_1_1_75V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_2_625v_batmon_hr_1_1_75v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _2_625V_BATMON_HR_1_1_75V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_2_700V_BATMON_HR_1_1_80V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_2_700v_batmon_hr_1_1_80v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _2_700V_BATMON_HR_1_1_80V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_2_775V_BATMON_HR_1_1_85V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_2_775v_batmon_hr_1_1_85v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _2_775V_BATMON_HR_1_1_85V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_2_850V_BATMON_HR_1_1_90V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_2_850v_batmon_hr_1_1_90v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _2_850V_BATMON_HR_1_1_90V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_2_925V_BATMON_HR_1_1_95V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_2_925v_batmon_hr_1_1_95v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _2_925V_BATMON_HR_1_1_95V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_000V_BATMON_HR_1_2_00V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_000v_batmon_hr_1_2_00v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_000V_BATMON_HR_1_2_00V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_075V_BATMON_HR_1_2_05V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_075v_batmon_hr_1_2_05v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_075V_BATMON_HR_1_2_05V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_150V_BATMON_HR_1_2_10V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_150v_batmon_hr_1_2_10v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_150V_BATMON_HR_1_2_10V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_225V_BATMON_HR_1_2_15V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_225v_batmon_hr_1_2_15v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_225V_BATMON_HR_1_2_15V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_300V_BATMON_HR_1_2_20V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_300v_batmon_hr_1_2_20v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_300V_BATMON_HR_1_2_20V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_375V_BATMON_HR_1_2_25V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_375v_batmon_hr_1_2_25v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_375V_BATMON_HR_1_2_25V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_450V_BATMON_HR_1_2_30V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_450v_batmon_hr_1_2_30v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_450V_BATMON_HR_1_2_30V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_525V_BATMON_HR_1_2_35V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_525v_batmon_hr_1_2_35v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_525V_BATMON_HR_1_2_35V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_600V_BATMON_HR_1_2_40V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_600v_batmon_hr_1_2_40v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_600V_BATMON_HR_1_2_40V_BATMON_HR_0 } # [doc = "Checks if the value of the field is `_3_675V_BATMON_HR_1_2_45V_BATMON_HR_0`"]
# [inline (always)]
pub fn is_3_675v_batmon_hr_1_2_45v_batmon_hr_0 (& self) -> bool { * self == BATMON_VTH_A :: _3_675V_BATMON_HR_1_2_45V_BATMON_HR_0 } } # [doc = "Field `BATMON_VTH` writer - Battery Monitor Threshold Voltage"]
pub type BATMON_VTH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BATMON_SPEC , u8 , BATMON_VTH_A , 4 , O > ; impl < 'a , const O : u8 > BATMON_VTH_W < 'a , O > { # [doc = "2.550V (BATMON_HR=1) 1.70V (BATMON_HR=0)"]
# [inline (always)]
pub fn _2_550v_batmon_hr_1_1_70v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _2_550V_BATMON_HR_1_1_70V_BATMON_HR_0) } # [doc = "2.625V (BATMON_HR=1) 1.75V (BATMON_HR=0)"]
# [inline (always)]
pub fn _2_625v_batmon_hr_1_1_75v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _2_625V_BATMON_HR_1_1_75V_BATMON_HR_0) } # [doc = "2.700V (BATMON_HR=1) 1.80V (BATMON_HR=0)"]
# [inline (always)]
pub fn _2_700v_batmon_hr_1_1_80v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _2_700V_BATMON_HR_1_1_80V_BATMON_HR_0) } # [doc = "2.775V (BATMON_HR=1) 1.85V (BATMON_HR=0)"]
# [inline (always)]
pub fn _2_775v_batmon_hr_1_1_85v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _2_775V_BATMON_HR_1_1_85V_BATMON_HR_0) } # [doc = "2.850V (BATMON_HR=1) 1.90V (BATMON_HR=0)"]
# [inline (always)]
pub fn _2_850v_batmon_hr_1_1_90v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _2_850V_BATMON_HR_1_1_90V_BATMON_HR_0) } # [doc = "2.925V (BATMON_HR=1) 1.95V (BATMON_HR=0)"]
# [inline (always)]
pub fn _2_925v_batmon_hr_1_1_95v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _2_925V_BATMON_HR_1_1_95V_BATMON_HR_0) } # [doc = "3.000V (BATMON_HR=1) 2.00V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_000v_batmon_hr_1_2_00v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_000V_BATMON_HR_1_2_00V_BATMON_HR_0) } # [doc = "3.075V (BATMON_HR=1) 2.05V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_075v_batmon_hr_1_2_05v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_075V_BATMON_HR_1_2_05V_BATMON_HR_0) } # [doc = "3.150V (BATMON_HR=1) 2.10V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_150v_batmon_hr_1_2_10v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_150V_BATMON_HR_1_2_10V_BATMON_HR_0) } # [doc = "3.225V (BATMON_HR=1) 2.15V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_225v_batmon_hr_1_2_15v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_225V_BATMON_HR_1_2_15V_BATMON_HR_0) } # [doc = "3.300V (BATMON_HR=1) 2.20V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_300v_batmon_hr_1_2_20v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_300V_BATMON_HR_1_2_20V_BATMON_HR_0) } # [doc = "3.375V (BATMON_HR=1) 2.25V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_375v_batmon_hr_1_2_25v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_375V_BATMON_HR_1_2_25V_BATMON_HR_0) } # [doc = "3.450V (BATMON_HR=1) 2.30V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_450v_batmon_hr_1_2_30v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_450V_BATMON_HR_1_2_30V_BATMON_HR_0) } # [doc = "3.525V (BATMON_HR=1) 2.35V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_525v_batmon_hr_1_2_35v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_525V_BATMON_HR_1_2_35V_BATMON_HR_0) } # [doc = "3.600V (BATMON_HR=1) 2.40V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_600v_batmon_hr_1_2_40v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_600V_BATMON_HR_1_2_40V_BATMON_HR_0) } # [doc = "3.675V (BATMON_HR=1) 2.45V (BATMON_HR=0)"]
# [inline (always)]
pub fn _3_675v_batmon_hr_1_2_45v_batmon_hr_0 (self) -> & 'a mut W { self . variant (BATMON_VTH_A :: _3_675V_BATMON_HR_1_2_45V_BATMON_HR_0) } } # [doc = "Field `BATMON_HR` reader - Battery Monitor Voltage Range"]
pub type BATMON_HR_R = crate :: BitReader < BATMON_HR_A > ; # [doc = "Battery Monitor Voltage Range\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum BATMON_HR_A { # [doc = "0: Enables the low range, see BATMON_VTH"]
BATMON_HR_DIS = 0 , # [doc = "1: Enables the high range, see BATMON_VTH"]
BATMON_HR_EN = 1 , } impl From < BATMON_HR_A > for bool { # [inline (always)]
fn from (variant : BATMON_HR_A) -> Self { variant as u8 != 0 } } impl BATMON_HR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BATMON_HR_A { match self . bits { false => BATMON_HR_A :: BATMON_HR_DIS , true => BATMON_HR_A :: BATMON_HR_EN , } } # [doc = "Checks if the value of the field is `BATMON_HR_DIS`"]
# [inline (always)]
pub fn is_batmon_hr_dis (& self) -> bool { * self == BATMON_HR_A :: BATMON_HR_DIS } # [doc = "Checks if the value of the field is `BATMON_HR_EN`"]
# [inline (always)]
pub fn is_batmon_hr_en (& self) -> bool { * self == BATMON_HR_A :: BATMON_HR_EN } } # [doc = "Field `BATMON_HR` writer - Battery Monitor Voltage Range"]
pub type BATMON_HR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , BATMON_SPEC , BATMON_HR_A , O > ; impl < 'a , const O : u8 > BATMON_HR_W < 'a , O > { # [doc = "Enables the low range, see BATMON_VTH"]
# [inline (always)]
pub fn batmon_hr_dis (self) -> & 'a mut W { self . variant (BATMON_HR_A :: BATMON_HR_DIS) } # [doc = "Enables the high range, see BATMON_VTH"]
# [inline (always)]
pub fn batmon_hr_en (self) -> & 'a mut W { self . variant (BATMON_HR_A :: BATMON_HR_EN) } } # [doc = "Field `BATMON_OK` reader - Battery Monitor Status"]
pub type BATMON_OK_R = crate :: BitReader < BATMON_OK_A > ; # [doc = "Battery Monitor Status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum BATMON_OK_A { # [doc = "0: The battery voltage is below the threshold."]
THE_BATTERY_VOLTAGE_IS_BELOW_THE_THRESHOLD = 0 , # [doc = "1: The battery voltage is above the threshold."]
THE_BATTERY_VOLTAGE_IS_ABOVE_THE_THRESHOLD = 1 , } impl From < BATMON_OK_A > for bool { # [inline (always)]
fn from (variant : BATMON_OK_A) -> Self { variant as u8 != 0 } } impl BATMON_OK_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BATMON_OK_A { match self . bits { false => BATMON_OK_A :: THE_BATTERY_VOLTAGE_IS_BELOW_THE_THRESHOLD , true => BATMON_OK_A :: THE_BATTERY_VOLTAGE_IS_ABOVE_THE_THRESHOLD , } } # [doc = "Checks if the value of the field is `THE_BATTERY_VOLTAGE_IS_BELOW_THE_THRESHOLD`"]
# [inline (always)]
pub fn is_the_battery_voltage_is_below_the_threshold (& self) -> bool { * self == BATMON_OK_A :: THE_BATTERY_VOLTAGE_IS_BELOW_THE_THRESHOLD } # [doc = "Checks if the value of the field is `THE_BATTERY_VOLTAGE_IS_ABOVE_THE_THRESHOLD`"]
# [inline (always)]
pub fn is_the_battery_voltage_is_above_the_threshold (& self) -> bool { * self == BATMON_OK_A :: THE_BATTERY_VOLTAGE_IS_ABOVE_THE_THRESHOLD } } # [doc = "Field `BATMON_OK` writer - Battery Monitor Status"]
pub type BATMON_OK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , BATMON_SPEC , BATMON_OK_A , O > ; impl < 'a , const O : u8 > BATMON_OK_W < 'a , O > { # [doc = "The battery voltage is below the threshold."]
# [inline (always)]
pub fn the_battery_voltage_is_below_the_threshold (self) -> & 'a mut W { self . variant (BATMON_OK_A :: THE_BATTERY_VOLTAGE_IS_BELOW_THE_THRESHOLD) } # [doc = "The battery voltage is above the threshold."]
# [inline (always)]
pub fn the_battery_voltage_is_above_the_threshold (self) -> & 'a mut W { self . variant (BATMON_OK_A :: THE_BATTERY_VOLTAGE_IS_ABOVE_THE_THRESHOLD) } } # [doc = "Field `BAT_LOW_EN` reader - Battery Monitor Interrupt Enable"]
pub type BAT_LOW_EN_R = crate :: BitReader < bool > ; # [doc = "Field `BAT_LOW_EN` writer - Battery Monitor Interrupt Enable"]
pub type BAT_LOW_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , BATMON_SPEC , bool , O > ; # [doc = "Field `BAT_LOW` reader - Battery Monitor Interrupt Status"]
pub type BAT_LOW_R = crate :: BitReader < bool > ; # [doc = "Field `BAT_LOW` writer - Battery Monitor Interrupt Status"]
pub type BAT_LOW_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , BATMON_SPEC , bool , O > ; impl R { # [doc = "Bits 0:3 - Battery Monitor Threshold Voltage"]
# [inline (always)]
pub fn batmon_vth (& self) -> BATMON_VTH_R { BATMON_VTH_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Battery Monitor Voltage Range"]
# [inline (always)]
pub fn batmon_hr (& self) -> BATMON_HR_R { BATMON_HR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Battery Monitor Status"]
# [inline (always)]
pub fn batmon_ok (& self) -> BATMON_OK_R { BATMON_OK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Battery Monitor Interrupt Enable"]
# [inline (always)]
pub fn bat_low_en (& self) -> BAT_LOW_EN_R { BAT_LOW_EN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Battery Monitor Interrupt Status"]
# [inline (always)]
pub fn bat_low (& self) -> BAT_LOW_R { BAT_LOW_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Battery Monitor Threshold Voltage"]
# [inline (always)]
# [must_use]
pub fn batmon_vth (& mut self) -> BATMON_VTH_W < 0 > { BATMON_VTH_W :: new (self) } # [doc = "Bit 4 - Battery Monitor Voltage Range"]
# [inline (always)]
# [must_use]
pub fn batmon_hr (& mut self) -> BATMON_HR_W < 4 > { BATMON_HR_W :: new (self) } # [doc = "Bit 5 - Battery Monitor Status"]
# [inline (always)]
# [must_use]
pub fn batmon_ok (& mut self) -> BATMON_OK_W < 5 > { BATMON_OK_W :: new (self) } # [doc = "Bit 6 - Battery Monitor Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn bat_low_en (& mut self) -> BAT_LOW_EN_W < 6 > { BAT_LOW_EN_W :: new (self) } # [doc = "Bit 7 - Battery Monitor Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn bat_low (& mut self) -> BAT_LOW_W < 7 > { BAT_LOW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Battery Monitor Control and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [batmon](index.html) module"]
pub struct BATMON_SPEC ; impl crate :: RegisterSpec for BATMON_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [batmon::R](R) reader structure"]
impl crate :: Readable for BATMON_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [batmon::W](W) writer structure"]
impl crate :: Writable for BATMON_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BATMON to value 0"]
impl crate :: Resettable for BATMON_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCA_THRES (rw) register accessor: an alias for `Reg<CCA_THRES_SPEC>`"]
pub type CCA_THRES = crate :: Reg < cca_thres :: CCA_THRES_SPEC > ; # [doc = "Transceiver CCA Threshold Setting Register"]
pub mod cca_thres { # [doc = "Register `CCA_THRES` reader"]
pub struct R (crate :: R < CCA_THRES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_THRES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_THRES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_THRES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA_THRES` writer"]
pub struct W (crate :: W < CCA_THRES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_THRES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_THRES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_THRES_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCA_ED_THRES` reader - ED Threshold Level for CCA Measurement"]
pub type CCA_ED_THRES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CCA_ED_THRES` writer - ED Threshold Level for CCA Measurement"]
pub type CCA_ED_THRES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CCA_THRES_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `CCA_CS_THRES` reader - CS Threshold Level for CCA Measurement"]
pub type CCA_CS_THRES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CCA_CS_THRES` writer - CS Threshold Level for CCA Measurement"]
pub type CCA_CS_THRES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CCA_THRES_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - ED Threshold Level for CCA Measurement"]
# [inline (always)]
pub fn cca_ed_thres (& self) -> CCA_ED_THRES_R { CCA_ED_THRES_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - CS Threshold Level for CCA Measurement"]
# [inline (always)]
pub fn cca_cs_thres (& self) -> CCA_CS_THRES_R { CCA_CS_THRES_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - ED Threshold Level for CCA Measurement"]
# [inline (always)]
# [must_use]
pub fn cca_ed_thres (& mut self) -> CCA_ED_THRES_W < 0 > { CCA_ED_THRES_W :: new (self) } # [doc = "Bits 4:7 - CS Threshold Level for CCA Measurement"]
# [inline (always)]
# [must_use]
pub fn cca_cs_thres (& mut self) -> CCA_CS_THRES_W < 4 > { CCA_CS_THRES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver CCA Threshold Setting Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca_thres](index.html) module"]
pub struct CCA_THRES_SPEC ; impl crate :: RegisterSpec for CCA_THRES_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [cca_thres::R](R) reader structure"]
impl crate :: Readable for CCA_THRES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca_thres::W](W) writer structure"]
impl crate :: Writable for CCA_THRES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA_THRES to value 0"]
impl crate :: Resettable for CCA_THRES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CSMA_BE (rw) register accessor: an alias for `Reg<CSMA_BE_SPEC>`"]
pub type CSMA_BE = crate :: Reg < csma_be :: CSMA_BE_SPEC > ; # [doc = "Transceiver CSMA-CA Back-off Exponent Control Register"]
pub mod csma_be { # [doc = "Register `CSMA_BE` reader"]
pub struct R (crate :: R < CSMA_BE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSMA_BE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSMA_BE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSMA_BE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSMA_BE` writer"]
pub struct W (crate :: W < CSMA_BE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSMA_BE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSMA_BE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSMA_BE_SPEC >) -> Self { W (writer) } } # [doc = "Field `MIN_BE` reader - Minimum Back-off Exponent"]
pub type MIN_BE_R = crate :: FieldReader < u8 , MIN_BE_A > ; # [doc = "Minimum Back-off Exponent\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MIN_BE_A { # [doc = "0: Minimum value of minimum back-off exponent."]
MINIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT = 0 , # [doc = "8: Maximum value of minimum back-off exponent. MIN_BE must be smaller or equal to MAX_BE."]
MAXIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT_MIN_BE_MUST_BE_SMALLER_OR_EQUAL_TO_MAX_BE = 8 , } impl From < MIN_BE_A > for u8 { # [inline (always)]
fn from (variant : MIN_BE_A) -> Self { variant as _ } } impl MIN_BE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MIN_BE_A > { match self . bits { 0 => Some (MIN_BE_A :: MINIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT) , 8 => Some (MIN_BE_A :: MAXIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT_MIN_BE_MUST_BE_SMALLER_OR_EQUAL_TO_MAX_BE) , _ => None , } } # [doc = "Checks if the value of the field is `MINIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT`"]
# [inline (always)]
pub fn is_minimum_value_of_minimum_back_off_exponent (& self) -> bool { * self == MIN_BE_A :: MINIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT } # [doc = "Checks if the value of the field is `MAXIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT_MIN_BE_MUST_BE_SMALLER_OR_EQUAL_TO_MAX_BE`"]
# [inline (always)]
pub fn is_maximum_value_of_minimum_back_off_exponent_min_be_must_be_smaller_or_equal_to_max_be (& self) -> bool { * self == MIN_BE_A :: MAXIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT_MIN_BE_MUST_BE_SMALLER_OR_EQUAL_TO_MAX_BE } } # [doc = "Field `MIN_BE` writer - Minimum Back-off Exponent"]
pub type MIN_BE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CSMA_BE_SPEC , u8 , MIN_BE_A , 4 , O > ; impl < 'a , const O : u8 > MIN_BE_W < 'a , O > { # [doc = "Minimum value of minimum back-off exponent."]
# [inline (always)]
pub fn minimum_value_of_minimum_back_off_exponent (self) -> & 'a mut W { self . variant (MIN_BE_A :: MINIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT) } # [doc = "Maximum value of minimum back-off exponent. MIN_BE must be smaller or equal to MAX_BE."]
# [inline (always)]
pub fn maximum_value_of_minimum_back_off_exponent_min_be_must_be_smaller_or_equal_to_max_be (self) -> & 'a mut W { self . variant (MIN_BE_A :: MAXIMUM_VALUE_OF_MINIMUM_BACK_OFF_EXPONENT_MIN_BE_MUST_BE_SMALLER_OR_EQUAL_TO_MAX_BE) } } # [doc = "Field `MAX_BE` reader - Maximum Back-off Exponent"]
pub type MAX_BE_R = crate :: FieldReader < u8 , MAX_BE_A > ; # [doc = "Maximum Back-off Exponent\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MAX_BE_A { # [doc = "2: This value is not valid for the maximum back-off exponent."]
THIS_VALUE_IS_NOT_VALID_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT = 2 , # [doc = "3: Minimum, IEEE compliant value for the maximum back-off exponent."]
MINIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT = 3 , # [doc = "8: Maximum, IEEE compliant value for the maximum back-off exponent."]
MAXIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT = 8 , } impl From < MAX_BE_A > for u8 { # [inline (always)]
fn from (variant : MAX_BE_A) -> Self { variant as _ } } impl MAX_BE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MAX_BE_A > { match self . bits { 2 => Some (MAX_BE_A :: THIS_VALUE_IS_NOT_VALID_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT) , 3 => Some (MAX_BE_A :: MINIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT) , 8 => Some (MAX_BE_A :: MAXIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT) , _ => None , } } # [doc = "Checks if the value of the field is `THIS_VALUE_IS_NOT_VALID_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT`"]
# [inline (always)]
pub fn is_this_value_is_not_valid_for_the_maximum_back_off_exponent (& self) -> bool { * self == MAX_BE_A :: THIS_VALUE_IS_NOT_VALID_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT } # [doc = "Checks if the value of the field is `MINIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT`"]
# [inline (always)]
pub fn is_minimum_ieee_compliant_value_for_the_maximum_back_off_exponent (& self) -> bool { * self == MAX_BE_A :: MINIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT } # [doc = "Checks if the value of the field is `MAXIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT`"]
# [inline (always)]
pub fn is_maximum_ieee_compliant_value_for_the_maximum_back_off_exponent (& self) -> bool { * self == MAX_BE_A :: MAXIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT } } # [doc = "Field `MAX_BE` writer - Maximum Back-off Exponent"]
pub type MAX_BE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CSMA_BE_SPEC , u8 , MAX_BE_A , 4 , O > ; impl < 'a , const O : u8 > MAX_BE_W < 'a , O > { # [doc = "This value is not valid for the maximum back-off exponent."]
# [inline (always)]
pub fn this_value_is_not_valid_for_the_maximum_back_off_exponent (self) -> & 'a mut W { self . variant (MAX_BE_A :: THIS_VALUE_IS_NOT_VALID_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT) } # [doc = "Minimum, IEEE compliant value for the maximum back-off exponent."]
# [inline (always)]
pub fn minimum_ieee_compliant_value_for_the_maximum_back_off_exponent (self) -> & 'a mut W { self . variant (MAX_BE_A :: MINIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT) } # [doc = "Maximum, IEEE compliant value for the maximum back-off exponent."]
# [inline (always)]
pub fn maximum_ieee_compliant_value_for_the_maximum_back_off_exponent (self) -> & 'a mut W { self . variant (MAX_BE_A :: MAXIMUM_IEEE_COMPLIANT_VALUE_FOR_THE_MAXIMUM_BACK_OFF_EXPONENT) } } impl R { # [doc = "Bits 0:3 - Minimum Back-off Exponent"]
# [inline (always)]
pub fn min_be (& self) -> MIN_BE_R { MIN_BE_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Maximum Back-off Exponent"]
# [inline (always)]
pub fn max_be (& self) -> MAX_BE_R { MAX_BE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Minimum Back-off Exponent"]
# [inline (always)]
# [must_use]
pub fn min_be (& mut self) -> MIN_BE_W < 0 > { MIN_BE_W :: new (self) } # [doc = "Bits 4:7 - Maximum Back-off Exponent"]
# [inline (always)]
# [must_use]
pub fn max_be (& mut self) -> MAX_BE_W < 4 > { MAX_BE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver CSMA-CA Back-off Exponent Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csma_be](index.html) module"]
pub struct CSMA_BE_SPEC ; impl crate :: RegisterSpec for CSMA_BE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [csma_be::R](R) reader structure"]
impl crate :: Readable for CSMA_BE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csma_be::W](W) writer structure"]
impl crate :: Writable for CSMA_BE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CSMA_BE to value 0"]
impl crate :: Resettable for CSMA_BE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CSMA_SEED_0 (rw) register accessor: an alias for `Reg<CSMA_SEED_0_SPEC>`"]
pub type CSMA_SEED_0 = crate :: Reg < csma_seed_0 :: CSMA_SEED_0_SPEC > ; # [doc = "Transceiver CSMA-CA Random Number Generator Seed Register"]
pub mod csma_seed_0 { # [doc = "Register `CSMA_SEED_0` reader"]
pub struct R (crate :: R < CSMA_SEED_0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSMA_SEED_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSMA_SEED_0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSMA_SEED_0_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSMA_SEED_0` writer"]
pub struct W (crate :: W < CSMA_SEED_0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSMA_SEED_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSMA_SEED_0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSMA_SEED_0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CSMA_SEED_00` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_00_R = crate :: BitReader < bool > ; # [doc = "Field `CSMA_SEED_00` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_00_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_0_SPEC , bool , O > ; # [doc = "Field `CSMA_SEED_01` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_01_R = crate :: BitReader < bool > ; # [doc = "Field `CSMA_SEED_01` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_01_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_0_SPEC , bool , O > ; # [doc = "Field `CSMA_SEED_02` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_02_R = crate :: BitReader < bool > ; # [doc = "Field `CSMA_SEED_02` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_0_SPEC , bool , O > ; # [doc = "Field `CSMA_SEED_03` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_03_R = crate :: BitReader < bool > ; # [doc = "Field `CSMA_SEED_03` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_03_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_0_SPEC , bool , O > ; # [doc = "Field `CSMA_SEED_04` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_04_R = crate :: BitReader < bool > ; # [doc = "Field `CSMA_SEED_04` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_04_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_0_SPEC , bool , O > ; # [doc = "Field `CSMA_SEED_05` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_05_R = crate :: BitReader < bool > ; # [doc = "Field `CSMA_SEED_05` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_05_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_0_SPEC , bool , O > ; # [doc = "Field `CSMA_SEED_06` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_06_R = crate :: BitReader < bool > ; # [doc = "Field `CSMA_SEED_06` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_06_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_0_SPEC , bool , O > ; # [doc = "Field `CSMA_SEED_07` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_07_R = crate :: BitReader < bool > ; # [doc = "Field `CSMA_SEED_07` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_07_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_00 (& self) -> CSMA_SEED_00_R { CSMA_SEED_00_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_01 (& self) -> CSMA_SEED_01_R { CSMA_SEED_01_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_02 (& self) -> CSMA_SEED_02_R { CSMA_SEED_02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_03 (& self) -> CSMA_SEED_03_R { CSMA_SEED_03_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_04 (& self) -> CSMA_SEED_04_R { CSMA_SEED_04_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_05 (& self) -> CSMA_SEED_05_R { CSMA_SEED_05_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_06 (& self) -> CSMA_SEED_06_R { CSMA_SEED_06_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_07 (& self) -> CSMA_SEED_07_R { CSMA_SEED_07_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_00 (& mut self) -> CSMA_SEED_00_W < 0 > { CSMA_SEED_00_W :: new (self) } # [doc = "Bit 1 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_01 (& mut self) -> CSMA_SEED_01_W < 1 > { CSMA_SEED_01_W :: new (self) } # [doc = "Bit 2 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_02 (& mut self) -> CSMA_SEED_02_W < 2 > { CSMA_SEED_02_W :: new (self) } # [doc = "Bit 3 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_03 (& mut self) -> CSMA_SEED_03_W < 3 > { CSMA_SEED_03_W :: new (self) } # [doc = "Bit 4 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_04 (& mut self) -> CSMA_SEED_04_W < 4 > { CSMA_SEED_04_W :: new (self) } # [doc = "Bit 5 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_05 (& mut self) -> CSMA_SEED_05_W < 5 > { CSMA_SEED_05_W :: new (self) } # [doc = "Bit 6 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_06 (& mut self) -> CSMA_SEED_06_W < 6 > { CSMA_SEED_06_W :: new (self) } # [doc = "Bit 7 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_07 (& mut self) -> CSMA_SEED_07_W < 7 > { CSMA_SEED_07_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver CSMA-CA Random Number Generator Seed Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csma_seed_0](index.html) module"]
pub struct CSMA_SEED_0_SPEC ; impl crate :: RegisterSpec for CSMA_SEED_0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [csma_seed_0::R](R) reader structure"]
impl crate :: Readable for CSMA_SEED_0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csma_seed_0::W](W) writer structure"]
impl crate :: Writable for CSMA_SEED_0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CSMA_SEED_0 to value 0"]
impl crate :: Resettable for CSMA_SEED_0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CSMA_SEED_1 (rw) register accessor: an alias for `Reg<CSMA_SEED_1_SPEC>`"]
pub type CSMA_SEED_1 = crate :: Reg < csma_seed_1 :: CSMA_SEED_1_SPEC > ; # [doc = "Transceiver Acknowledgment Frame Control Register 2"]
pub mod csma_seed_1 { # [doc = "Register `CSMA_SEED_1` reader"]
pub struct R (crate :: R < CSMA_SEED_1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CSMA_SEED_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CSMA_SEED_1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CSMA_SEED_1_SPEC >) -> Self { R (reader) } } # [doc = "Register `CSMA_SEED_1` writer"]
pub struct W (crate :: W < CSMA_SEED_1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CSMA_SEED_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CSMA_SEED_1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CSMA_SEED_1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CSMA_SEED_1` reader - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_1_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CSMA_SEED_1` writer - Seed Value for CSMA Random Number Generator"]
pub type CSMA_SEED_1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CSMA_SEED_1_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `AACK_I_AM_COORD` reader - Set Personal Area Network Coordinator"]
pub type AACK_I_AM_COORD_R = crate :: BitReader < bool > ; # [doc = "Field `AACK_I_AM_COORD` writer - Set Personal Area Network Coordinator"]
pub type AACK_I_AM_COORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_1_SPEC , bool , O > ; # [doc = "Field `AACK_DIS_ACK` reader - Disable Acknowledgment Frame Transmission"]
pub type AACK_DIS_ACK_R = crate :: BitReader < bool > ; # [doc = "Field `AACK_DIS_ACK` writer - Disable Acknowledgment Frame Transmission"]
pub type AACK_DIS_ACK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_1_SPEC , bool , O > ; # [doc = "Field `AACK_SET_PD` reader - Set Frame Pending Sub-field"]
pub type AACK_SET_PD_R = crate :: BitReader < bool > ; # [doc = "Field `AACK_SET_PD` writer - Set Frame Pending Sub-field"]
pub type AACK_SET_PD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CSMA_SEED_1_SPEC , bool , O > ; # [doc = "Field `AACK_FVN_MODE` reader - Acknowledgment Frame Filter Mode"]
pub type AACK_FVN_MODE_R = crate :: FieldReader < u8 , AACK_FVN_MODE_A > ; # [doc = "Acknowledgment Frame Filter Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum AACK_FVN_MODE_A { # [doc = "0: Acknowledge frames with version number 0"]
ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0 = 0 , # [doc = "1: Acknowledge frames with version number 0 or 1"]
ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1 = 1 , # [doc = "2: Acknowledge frames with version number 0 or 1 or 2"]
ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1_OR_2 = 2 , # [doc = "3: Acknowledge frames independent of frame version number"]
ACKNOWLEDGE_FRAMES_INDEPENDENT_OF_FRAME_VERSION_NUMBER = 3 , } impl From < AACK_FVN_MODE_A > for u8 { # [inline (always)]
fn from (variant : AACK_FVN_MODE_A) -> Self { variant as _ } } impl AACK_FVN_MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AACK_FVN_MODE_A { match self . bits { 0 => AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0 , 1 => AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1 , 2 => AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1_OR_2 , 3 => AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_INDEPENDENT_OF_FRAME_VERSION_NUMBER , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0`"]
# [inline (always)]
pub fn is_acknowledge_frames_with_version_number_0 (& self) -> bool { * self == AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0 } # [doc = "Checks if the value of the field is `ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1`"]
# [inline (always)]
pub fn is_acknowledge_frames_with_version_number_0_or_1 (& self) -> bool { * self == AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1 } # [doc = "Checks if the value of the field is `ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1_OR_2`"]
# [inline (always)]
pub fn is_acknowledge_frames_with_version_number_0_or_1_or_2 (& self) -> bool { * self == AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1_OR_2 } # [doc = "Checks if the value of the field is `ACKNOWLEDGE_FRAMES_INDEPENDENT_OF_FRAME_VERSION_NUMBER`"]
# [inline (always)]
pub fn is_acknowledge_frames_independent_of_frame_version_number (& self) -> bool { * self == AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_INDEPENDENT_OF_FRAME_VERSION_NUMBER } } # [doc = "Field `AACK_FVN_MODE` writer - Acknowledgment Frame Filter Mode"]
pub type AACK_FVN_MODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CSMA_SEED_1_SPEC , u8 , AACK_FVN_MODE_A , 2 , O > ; impl < 'a , const O : u8 > AACK_FVN_MODE_W < 'a , O > { # [doc = "Acknowledge frames with version number 0"]
# [inline (always)]
pub fn acknowledge_frames_with_version_number_0 (self) -> & 'a mut W { self . variant (AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0) } # [doc = "Acknowledge frames with version number 0 or 1"]
# [inline (always)]
pub fn acknowledge_frames_with_version_number_0_or_1 (self) -> & 'a mut W { self . variant (AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1) } # [doc = "Acknowledge frames with version number 0 or 1 or 2"]
# [inline (always)]
pub fn acknowledge_frames_with_version_number_0_or_1_or_2 (self) -> & 'a mut W { self . variant (AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_WITH_VERSION_NUMBER_0_OR_1_OR_2) } # [doc = "Acknowledge frames independent of frame version number"]
# [inline (always)]
pub fn acknowledge_frames_independent_of_frame_version_number (self) -> & 'a mut W { self . variant (AACK_FVN_MODE_A :: ACKNOWLEDGE_FRAMES_INDEPENDENT_OF_FRAME_VERSION_NUMBER) } } impl R { # [doc = "Bits 0:2 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
pub fn csma_seed_1 (& self) -> CSMA_SEED_1_R { CSMA_SEED_1_R :: new (self . bits & 7) } # [doc = "Bit 3 - Set Personal Area Network Coordinator"]
# [inline (always)]
pub fn aack_i_am_coord (& self) -> AACK_I_AM_COORD_R { AACK_I_AM_COORD_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Disable Acknowledgment Frame Transmission"]
# [inline (always)]
pub fn aack_dis_ack (& self) -> AACK_DIS_ACK_R { AACK_DIS_ACK_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Set Frame Pending Sub-field"]
# [inline (always)]
pub fn aack_set_pd (& self) -> AACK_SET_PD_R { AACK_SET_PD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Acknowledgment Frame Filter Mode"]
# [inline (always)]
pub fn aack_fvn_mode (& self) -> AACK_FVN_MODE_R { AACK_FVN_MODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Seed Value for CSMA Random Number Generator"]
# [inline (always)]
# [must_use]
pub fn csma_seed_1 (& mut self) -> CSMA_SEED_1_W < 0 > { CSMA_SEED_1_W :: new (self) } # [doc = "Bit 3 - Set Personal Area Network Coordinator"]
# [inline (always)]
# [must_use]
pub fn aack_i_am_coord (& mut self) -> AACK_I_AM_COORD_W < 3 > { AACK_I_AM_COORD_W :: new (self) } # [doc = "Bit 4 - Disable Acknowledgment Frame Transmission"]
# [inline (always)]
# [must_use]
pub fn aack_dis_ack (& mut self) -> AACK_DIS_ACK_W < 4 > { AACK_DIS_ACK_W :: new (self) } # [doc = "Bit 5 - Set Frame Pending Sub-field"]
# [inline (always)]
# [must_use]
pub fn aack_set_pd (& mut self) -> AACK_SET_PD_W < 5 > { AACK_SET_PD_W :: new (self) } # [doc = "Bits 6:7 - Acknowledgment Frame Filter Mode"]
# [inline (always)]
# [must_use]
pub fn aack_fvn_mode (& mut self) -> AACK_FVN_MODE_W < 6 > { AACK_FVN_MODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Acknowledgment Frame Control Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [csma_seed_1](index.html) module"]
pub struct CSMA_SEED_1_SPEC ; impl crate :: RegisterSpec for CSMA_SEED_1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [csma_seed_1::R](R) reader structure"]
impl crate :: Readable for CSMA_SEED_1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [csma_seed_1::W](W) writer structure"]
impl crate :: Writable for CSMA_SEED_1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CSMA_SEED_1 to value 0"]
impl crate :: Resettable for CSMA_SEED_1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FTN_CTRL (rw) register accessor: an alias for `Reg<FTN_CTRL_SPEC>`"]
pub type FTN_CTRL = crate :: Reg < ftn_ctrl :: FTN_CTRL_SPEC > ; # [doc = "Transceiver Filter Tuning Control Register"]
pub mod ftn_ctrl { # [doc = "Register `FTN_CTRL` reader"]
pub struct R (crate :: R < FTN_CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FTN_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FTN_CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FTN_CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `FTN_CTRL` writer"]
pub struct W (crate :: W < FTN_CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FTN_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FTN_CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FTN_CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `FTN_START` reader - Start Calibration Loop of Filter Tuning Network"]
pub type FTN_START_R = crate :: BitReader < bool > ; # [doc = "Field `FTN_START` writer - Start Calibration Loop of Filter Tuning Network"]
pub type FTN_START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FTN_CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 7 - Start Calibration Loop of Filter Tuning Network"]
# [inline (always)]
pub fn ftn_start (& self) -> FTN_START_R { FTN_START_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 7 - Start Calibration Loop of Filter Tuning Network"]
# [inline (always)]
# [must_use]
pub fn ftn_start (& mut self) -> FTN_START_W < 7 > { FTN_START_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Filter Tuning Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ftn_ctrl](index.html) module"]
pub struct FTN_CTRL_SPEC ; impl crate :: RegisterSpec for FTN_CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ftn_ctrl::R](R) reader structure"]
impl crate :: Readable for FTN_CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ftn_ctrl::W](W) writer structure"]
impl crate :: Writable for FTN_CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FTN_CTRL to value 0"]
impl crate :: Resettable for FTN_CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IEEE_ADDR_0 (rw) register accessor: an alias for `Reg<IEEE_ADDR_0_SPEC>`"]
pub type IEEE_ADDR_0 = crate :: Reg < ieee_addr_0 :: IEEE_ADDR_0_SPEC > ; # [doc = "Transceiver MAC IEEE Address Register 0"]
pub mod ieee_addr_0 { # [doc = "Register `IEEE_ADDR_0` reader"]
pub struct R (crate :: R < IEEE_ADDR_0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IEEE_ADDR_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IEEE_ADDR_0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IEEE_ADDR_0_SPEC >) -> Self { R (reader) } } # [doc = "Register `IEEE_ADDR_0` writer"]
pub struct W (crate :: W < IEEE_ADDR_0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IEEE_ADDR_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IEEE_ADDR_0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IEEE_ADDR_0_SPEC >) -> Self { W (writer) } } # [doc = "Field `IEEE_ADDR_00` reader - MAC IEEE Address"]
pub type IEEE_ADDR_00_R = crate :: BitReader < bool > ; # [doc = "Field `IEEE_ADDR_00` writer - MAC IEEE Address"]
pub type IEEE_ADDR_00_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IEEE_ADDR_0_SPEC , bool , O > ; # [doc = "Field `IEEE_ADDR_01` reader - MAC IEEE Address"]
pub type IEEE_ADDR_01_R = crate :: BitReader < bool > ; # [doc = "Field `IEEE_ADDR_01` writer - MAC IEEE Address"]
pub type IEEE_ADDR_01_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IEEE_ADDR_0_SPEC , bool , O > ; # [doc = "Field `IEEE_ADDR_02` reader - MAC IEEE Address"]
pub type IEEE_ADDR_02_R = crate :: BitReader < bool > ; # [doc = "Field `IEEE_ADDR_02` writer - MAC IEEE Address"]
pub type IEEE_ADDR_02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IEEE_ADDR_0_SPEC , bool , O > ; # [doc = "Field `IEEE_ADDR_03` reader - MAC IEEE Address"]
pub type IEEE_ADDR_03_R = crate :: BitReader < bool > ; # [doc = "Field `IEEE_ADDR_03` writer - MAC IEEE Address"]
pub type IEEE_ADDR_03_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IEEE_ADDR_0_SPEC , bool , O > ; # [doc = "Field `IEEE_ADDR_04` reader - MAC IEEE Address"]
pub type IEEE_ADDR_04_R = crate :: BitReader < bool > ; # [doc = "Field `IEEE_ADDR_04` writer - MAC IEEE Address"]
pub type IEEE_ADDR_04_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IEEE_ADDR_0_SPEC , bool , O > ; # [doc = "Field `IEEE_ADDR_05` reader - MAC IEEE Address"]
pub type IEEE_ADDR_05_R = crate :: BitReader < bool > ; # [doc = "Field `IEEE_ADDR_05` writer - MAC IEEE Address"]
pub type IEEE_ADDR_05_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IEEE_ADDR_0_SPEC , bool , O > ; # [doc = "Field `IEEE_ADDR_06` reader - MAC IEEE Address"]
pub type IEEE_ADDR_06_R = crate :: BitReader < bool > ; # [doc = "Field `IEEE_ADDR_06` writer - MAC IEEE Address"]
pub type IEEE_ADDR_06_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IEEE_ADDR_0_SPEC , bool , O > ; # [doc = "Field `IEEE_ADDR_07` reader - MAC IEEE Address"]
pub type IEEE_ADDR_07_R = crate :: BitReader < bool > ; # [doc = "Field `IEEE_ADDR_07` writer - MAC IEEE Address"]
pub type IEEE_ADDR_07_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IEEE_ADDR_0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_00 (& self) -> IEEE_ADDR_00_R { IEEE_ADDR_00_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_01 (& self) -> IEEE_ADDR_01_R { IEEE_ADDR_01_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_02 (& self) -> IEEE_ADDR_02_R { IEEE_ADDR_02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_03 (& self) -> IEEE_ADDR_03_R { IEEE_ADDR_03_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_04 (& self) -> IEEE_ADDR_04_R { IEEE_ADDR_04_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_05 (& self) -> IEEE_ADDR_05_R { IEEE_ADDR_05_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_06 (& self) -> IEEE_ADDR_06_R { IEEE_ADDR_06_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_07 (& self) -> IEEE_ADDR_07_R { IEEE_ADDR_07_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_00 (& mut self) -> IEEE_ADDR_00_W < 0 > { IEEE_ADDR_00_W :: new (self) } # [doc = "Bit 1 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_01 (& mut self) -> IEEE_ADDR_01_W < 1 > { IEEE_ADDR_01_W :: new (self) } # [doc = "Bit 2 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_02 (& mut self) -> IEEE_ADDR_02_W < 2 > { IEEE_ADDR_02_W :: new (self) } # [doc = "Bit 3 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_03 (& mut self) -> IEEE_ADDR_03_W < 3 > { IEEE_ADDR_03_W :: new (self) } # [doc = "Bit 4 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_04 (& mut self) -> IEEE_ADDR_04_W < 4 > { IEEE_ADDR_04_W :: new (self) } # [doc = "Bit 5 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_05 (& mut self) -> IEEE_ADDR_05_W < 5 > { IEEE_ADDR_05_W :: new (self) } # [doc = "Bit 6 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_06 (& mut self) -> IEEE_ADDR_06_W < 6 > { IEEE_ADDR_06_W :: new (self) } # [doc = "Bit 7 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_07 (& mut self) -> IEEE_ADDR_07_W < 7 > { IEEE_ADDR_07_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver MAC IEEE Address Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ieee_addr_0](index.html) module"]
pub struct IEEE_ADDR_0_SPEC ; impl crate :: RegisterSpec for IEEE_ADDR_0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ieee_addr_0::R](R) reader structure"]
impl crate :: Readable for IEEE_ADDR_0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ieee_addr_0::W](W) writer structure"]
impl crate :: Writable for IEEE_ADDR_0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IEEE_ADDR_0 to value 0"]
impl crate :: Resettable for IEEE_ADDR_0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IEEE_ADDR_1 (rw) register accessor: an alias for `Reg<IEEE_ADDR_1_SPEC>`"]
pub type IEEE_ADDR_1 = crate :: Reg < ieee_addr_1 :: IEEE_ADDR_1_SPEC > ; # [doc = "Transceiver MAC IEEE Address Register 1"]
pub mod ieee_addr_1 { # [doc = "Register `IEEE_ADDR_1` reader"]
pub struct R (crate :: R < IEEE_ADDR_1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IEEE_ADDR_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IEEE_ADDR_1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IEEE_ADDR_1_SPEC >) -> Self { R (reader) } } # [doc = "Register `IEEE_ADDR_1` writer"]
pub struct W (crate :: W < IEEE_ADDR_1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IEEE_ADDR_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IEEE_ADDR_1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IEEE_ADDR_1_SPEC >) -> Self { W (writer) } } # [doc = "Field `IEEE_ADDR_` reader - MAC IEEE Address"]
pub type IEEE_ADDR__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IEEE_ADDR_` writer - MAC IEEE Address"]
pub type IEEE_ADDR__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , IEEE_ADDR_1_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_ (& self) -> IEEE_ADDR__R { IEEE_ADDR__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_ (& mut self) -> IEEE_ADDR__W < 0 > { IEEE_ADDR__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver MAC IEEE Address Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ieee_addr_1](index.html) module"]
pub struct IEEE_ADDR_1_SPEC ; impl crate :: RegisterSpec for IEEE_ADDR_1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ieee_addr_1::R](R) reader structure"]
impl crate :: Readable for IEEE_ADDR_1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ieee_addr_1::W](W) writer structure"]
impl crate :: Writable for IEEE_ADDR_1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IEEE_ADDR_1 to value 0"]
impl crate :: Resettable for IEEE_ADDR_1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IEEE_ADDR_2 (rw) register accessor: an alias for `Reg<IEEE_ADDR_2_SPEC>`"]
pub type IEEE_ADDR_2 = crate :: Reg < ieee_addr_2 :: IEEE_ADDR_2_SPEC > ; # [doc = "Transceiver MAC IEEE Address Register 2"]
pub mod ieee_addr_2 { # [doc = "Register `IEEE_ADDR_2` reader"]
pub struct R (crate :: R < IEEE_ADDR_2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IEEE_ADDR_2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IEEE_ADDR_2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IEEE_ADDR_2_SPEC >) -> Self { R (reader) } } # [doc = "Register `IEEE_ADDR_2` writer"]
pub struct W (crate :: W < IEEE_ADDR_2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IEEE_ADDR_2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IEEE_ADDR_2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IEEE_ADDR_2_SPEC >) -> Self { W (writer) } } # [doc = "Field `IEEE_ADDR_` reader - MAC IEEE Address"]
pub type IEEE_ADDR__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IEEE_ADDR_` writer - MAC IEEE Address"]
pub type IEEE_ADDR__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , IEEE_ADDR_2_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_ (& self) -> IEEE_ADDR__R { IEEE_ADDR__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_ (& mut self) -> IEEE_ADDR__W < 0 > { IEEE_ADDR__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver MAC IEEE Address Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ieee_addr_2](index.html) module"]
pub struct IEEE_ADDR_2_SPEC ; impl crate :: RegisterSpec for IEEE_ADDR_2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ieee_addr_2::R](R) reader structure"]
impl crate :: Readable for IEEE_ADDR_2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ieee_addr_2::W](W) writer structure"]
impl crate :: Writable for IEEE_ADDR_2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IEEE_ADDR_2 to value 0"]
impl crate :: Resettable for IEEE_ADDR_2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IEEE_ADDR_3 (rw) register accessor: an alias for `Reg<IEEE_ADDR_3_SPEC>`"]
pub type IEEE_ADDR_3 = crate :: Reg < ieee_addr_3 :: IEEE_ADDR_3_SPEC > ; # [doc = "Transceiver MAC IEEE Address Register 3"]
pub mod ieee_addr_3 { # [doc = "Register `IEEE_ADDR_3` reader"]
pub struct R (crate :: R < IEEE_ADDR_3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IEEE_ADDR_3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IEEE_ADDR_3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IEEE_ADDR_3_SPEC >) -> Self { R (reader) } } # [doc = "Register `IEEE_ADDR_3` writer"]
pub struct W (crate :: W < IEEE_ADDR_3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IEEE_ADDR_3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IEEE_ADDR_3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IEEE_ADDR_3_SPEC >) -> Self { W (writer) } } # [doc = "Field `IEEE_ADDR_` reader - MAC IEEE Address"]
pub type IEEE_ADDR__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IEEE_ADDR_` writer - MAC IEEE Address"]
pub type IEEE_ADDR__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , IEEE_ADDR_3_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_ (& self) -> IEEE_ADDR__R { IEEE_ADDR__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_ (& mut self) -> IEEE_ADDR__W < 0 > { IEEE_ADDR__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver MAC IEEE Address Register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ieee_addr_3](index.html) module"]
pub struct IEEE_ADDR_3_SPEC ; impl crate :: RegisterSpec for IEEE_ADDR_3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ieee_addr_3::R](R) reader structure"]
impl crate :: Readable for IEEE_ADDR_3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ieee_addr_3::W](W) writer structure"]
impl crate :: Writable for IEEE_ADDR_3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IEEE_ADDR_3 to value 0"]
impl crate :: Resettable for IEEE_ADDR_3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IEEE_ADDR_4 (rw) register accessor: an alias for `Reg<IEEE_ADDR_4_SPEC>`"]
pub type IEEE_ADDR_4 = crate :: Reg < ieee_addr_4 :: IEEE_ADDR_4_SPEC > ; # [doc = "Transceiver MAC IEEE Address Register 4"]
pub mod ieee_addr_4 { # [doc = "Register `IEEE_ADDR_4` reader"]
pub struct R (crate :: R < IEEE_ADDR_4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IEEE_ADDR_4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IEEE_ADDR_4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IEEE_ADDR_4_SPEC >) -> Self { R (reader) } } # [doc = "Register `IEEE_ADDR_4` writer"]
pub struct W (crate :: W < IEEE_ADDR_4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IEEE_ADDR_4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IEEE_ADDR_4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IEEE_ADDR_4_SPEC >) -> Self { W (writer) } } # [doc = "Field `IEEE_ADDR_` reader - MAC IEEE Address"]
pub type IEEE_ADDR__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IEEE_ADDR_` writer - MAC IEEE Address"]
pub type IEEE_ADDR__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , IEEE_ADDR_4_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_ (& self) -> IEEE_ADDR__R { IEEE_ADDR__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_ (& mut self) -> IEEE_ADDR__W < 0 > { IEEE_ADDR__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver MAC IEEE Address Register 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ieee_addr_4](index.html) module"]
pub struct IEEE_ADDR_4_SPEC ; impl crate :: RegisterSpec for IEEE_ADDR_4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ieee_addr_4::R](R) reader structure"]
impl crate :: Readable for IEEE_ADDR_4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ieee_addr_4::W](W) writer structure"]
impl crate :: Writable for IEEE_ADDR_4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IEEE_ADDR_4 to value 0"]
impl crate :: Resettable for IEEE_ADDR_4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IEEE_ADDR_5 (rw) register accessor: an alias for `Reg<IEEE_ADDR_5_SPEC>`"]
pub type IEEE_ADDR_5 = crate :: Reg < ieee_addr_5 :: IEEE_ADDR_5_SPEC > ; # [doc = "Transceiver MAC IEEE Address Register 5"]
pub mod ieee_addr_5 { # [doc = "Register `IEEE_ADDR_5` reader"]
pub struct R (crate :: R < IEEE_ADDR_5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IEEE_ADDR_5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IEEE_ADDR_5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IEEE_ADDR_5_SPEC >) -> Self { R (reader) } } # [doc = "Register `IEEE_ADDR_5` writer"]
pub struct W (crate :: W < IEEE_ADDR_5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IEEE_ADDR_5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IEEE_ADDR_5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IEEE_ADDR_5_SPEC >) -> Self { W (writer) } } # [doc = "Field `IEEE_ADDR_` reader - MAC IEEE Address"]
pub type IEEE_ADDR__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IEEE_ADDR_` writer - MAC IEEE Address"]
pub type IEEE_ADDR__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , IEEE_ADDR_5_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_ (& self) -> IEEE_ADDR__R { IEEE_ADDR__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_ (& mut self) -> IEEE_ADDR__W < 0 > { IEEE_ADDR__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver MAC IEEE Address Register 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ieee_addr_5](index.html) module"]
pub struct IEEE_ADDR_5_SPEC ; impl crate :: RegisterSpec for IEEE_ADDR_5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ieee_addr_5::R](R) reader structure"]
impl crate :: Readable for IEEE_ADDR_5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ieee_addr_5::W](W) writer structure"]
impl crate :: Writable for IEEE_ADDR_5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IEEE_ADDR_5 to value 0"]
impl crate :: Resettable for IEEE_ADDR_5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IEEE_ADDR_6 (rw) register accessor: an alias for `Reg<IEEE_ADDR_6_SPEC>`"]
pub type IEEE_ADDR_6 = crate :: Reg < ieee_addr_6 :: IEEE_ADDR_6_SPEC > ; # [doc = "Transceiver MAC IEEE Address Register 6"]
pub mod ieee_addr_6 { # [doc = "Register `IEEE_ADDR_6` reader"]
pub struct R (crate :: R < IEEE_ADDR_6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IEEE_ADDR_6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IEEE_ADDR_6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IEEE_ADDR_6_SPEC >) -> Self { R (reader) } } # [doc = "Register `IEEE_ADDR_6` writer"]
pub struct W (crate :: W < IEEE_ADDR_6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IEEE_ADDR_6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IEEE_ADDR_6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IEEE_ADDR_6_SPEC >) -> Self { W (writer) } } # [doc = "Field `IEEE_ADDR_` reader - MAC IEEE Address"]
pub type IEEE_ADDR__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IEEE_ADDR_` writer - MAC IEEE Address"]
pub type IEEE_ADDR__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , IEEE_ADDR_6_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_ (& self) -> IEEE_ADDR__R { IEEE_ADDR__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_ (& mut self) -> IEEE_ADDR__W < 0 > { IEEE_ADDR__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver MAC IEEE Address Register 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ieee_addr_6](index.html) module"]
pub struct IEEE_ADDR_6_SPEC ; impl crate :: RegisterSpec for IEEE_ADDR_6_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ieee_addr_6::R](R) reader structure"]
impl crate :: Readable for IEEE_ADDR_6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ieee_addr_6::W](W) writer structure"]
impl crate :: Writable for IEEE_ADDR_6_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IEEE_ADDR_6 to value 0"]
impl crate :: Resettable for IEEE_ADDR_6_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IEEE_ADDR_7 (rw) register accessor: an alias for `Reg<IEEE_ADDR_7_SPEC>`"]
pub type IEEE_ADDR_7 = crate :: Reg < ieee_addr_7 :: IEEE_ADDR_7_SPEC > ; # [doc = "Transceiver MAC IEEE Address Register 7"]
pub mod ieee_addr_7 { # [doc = "Register `IEEE_ADDR_7` reader"]
pub struct R (crate :: R < IEEE_ADDR_7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IEEE_ADDR_7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IEEE_ADDR_7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IEEE_ADDR_7_SPEC >) -> Self { R (reader) } } # [doc = "Register `IEEE_ADDR_7` writer"]
pub struct W (crate :: W < IEEE_ADDR_7_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IEEE_ADDR_7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IEEE_ADDR_7_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IEEE_ADDR_7_SPEC >) -> Self { W (writer) } } # [doc = "Field `IEEE_ADDR_` reader - MAC IEEE Address"]
pub type IEEE_ADDR__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `IEEE_ADDR_` writer - MAC IEEE Address"]
pub type IEEE_ADDR__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , IEEE_ADDR_7_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
pub fn ieee_addr_ (& self) -> IEEE_ADDR__R { IEEE_ADDR__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC IEEE Address"]
# [inline (always)]
# [must_use]
pub fn ieee_addr_ (& mut self) -> IEEE_ADDR__W < 0 > { IEEE_ADDR__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver MAC IEEE Address Register 7\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ieee_addr_7](index.html) module"]
pub struct IEEE_ADDR_7_SPEC ; impl crate :: RegisterSpec for IEEE_ADDR_7_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ieee_addr_7::R](R) reader structure"]
impl crate :: Readable for IEEE_ADDR_7_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ieee_addr_7::W](W) writer structure"]
impl crate :: Writable for IEEE_ADDR_7_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IEEE_ADDR_7 to value 0"]
impl crate :: Resettable for IEEE_ADDR_7_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IRQ_MASK (rw) register accessor: an alias for `Reg<IRQ_MASK_SPEC>`"]
pub type IRQ_MASK = crate :: Reg < irq_mask :: IRQ_MASK_SPEC > ; # [doc = "Transceiver Interrupt Enable Register"]
pub mod irq_mask { # [doc = "Register `IRQ_MASK` reader"]
pub struct R (crate :: R < IRQ_MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_MASK` writer"]
pub struct W (crate :: W < IRQ_MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_MASK_SPEC >) -> Self { W (writer) } } # [doc = "Field `PLL_LOCK_EN` reader - PLL Lock Interrupt Enable"]
pub type PLL_LOCK_EN_R = crate :: BitReader < bool > ; # [doc = "Field `PLL_LOCK_EN` writer - PLL Lock Interrupt Enable"]
pub type PLL_LOCK_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_MASK_SPEC , bool , O > ; # [doc = "Field `PLL_UNLOCK_EN` reader - PLL Unlock Interrupt Enable"]
pub type PLL_UNLOCK_EN_R = crate :: BitReader < bool > ; # [doc = "Field `PLL_UNLOCK_EN` writer - PLL Unlock Interrupt Enable"]
pub type PLL_UNLOCK_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_MASK_SPEC , bool , O > ; # [doc = "Field `RX_START_EN` reader - RX_START Interrupt Enable"]
pub type RX_START_EN_R = crate :: BitReader < bool > ; # [doc = "Field `RX_START_EN` writer - RX_START Interrupt Enable"]
pub type RX_START_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_MASK_SPEC , bool , O > ; # [doc = "Field `RX_END_EN` reader - RX_END Interrupt Enable"]
pub type RX_END_EN_R = crate :: BitReader < bool > ; # [doc = "Field `RX_END_EN` writer - RX_END Interrupt Enable"]
pub type RX_END_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_MASK_SPEC , bool , O > ; # [doc = "Field `CCA_ED_DONE_EN` reader - End of ED Measurement Interrupt Enable"]
pub type CCA_ED_DONE_EN_R = crate :: BitReader < bool > ; # [doc = "Field `CCA_ED_DONE_EN` writer - End of ED Measurement Interrupt Enable"]
pub type CCA_ED_DONE_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_MASK_SPEC , bool , O > ; # [doc = "Field `AMI_EN` reader - Address Match Interrupt Enable"]
pub type AMI_EN_R = crate :: BitReader < bool > ; # [doc = "Field `AMI_EN` writer - Address Match Interrupt Enable"]
pub type AMI_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_MASK_SPEC , bool , O > ; # [doc = "Field `TX_END_EN` reader - TX_END Interrupt Enable"]
pub type TX_END_EN_R = crate :: BitReader < bool > ; # [doc = "Field `TX_END_EN` writer - TX_END Interrupt Enable"]
pub type TX_END_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_MASK_SPEC , bool , O > ; # [doc = "Field `AWAKE_EN` reader - Awake Interrupt Enable"]
pub type AWAKE_EN_R = crate :: BitReader < bool > ; # [doc = "Field `AWAKE_EN` writer - Awake Interrupt Enable"]
pub type AWAKE_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_MASK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - PLL Lock Interrupt Enable"]
# [inline (always)]
pub fn pll_lock_en (& self) -> PLL_LOCK_EN_R { PLL_LOCK_EN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - PLL Unlock Interrupt Enable"]
# [inline (always)]
pub fn pll_unlock_en (& self) -> PLL_UNLOCK_EN_R { PLL_UNLOCK_EN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - RX_START Interrupt Enable"]
# [inline (always)]
pub fn rx_start_en (& self) -> RX_START_EN_R { RX_START_EN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - RX_END Interrupt Enable"]
# [inline (always)]
pub fn rx_end_en (& self) -> RX_END_EN_R { RX_END_EN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - End of ED Measurement Interrupt Enable"]
# [inline (always)]
pub fn cca_ed_done_en (& self) -> CCA_ED_DONE_EN_R { CCA_ED_DONE_EN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Address Match Interrupt Enable"]
# [inline (always)]
pub fn ami_en (& self) -> AMI_EN_R { AMI_EN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TX_END Interrupt Enable"]
# [inline (always)]
pub fn tx_end_en (& self) -> TX_END_EN_R { TX_END_EN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Awake Interrupt Enable"]
# [inline (always)]
pub fn awake_en (& self) -> AWAKE_EN_R { AWAKE_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - PLL Lock Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn pll_lock_en (& mut self) -> PLL_LOCK_EN_W < 0 > { PLL_LOCK_EN_W :: new (self) } # [doc = "Bit 1 - PLL Unlock Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn pll_unlock_en (& mut self) -> PLL_UNLOCK_EN_W < 1 > { PLL_UNLOCK_EN_W :: new (self) } # [doc = "Bit 2 - RX_START Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rx_start_en (& mut self) -> RX_START_EN_W < 2 > { RX_START_EN_W :: new (self) } # [doc = "Bit 3 - RX_END Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rx_end_en (& mut self) -> RX_END_EN_W < 3 > { RX_END_EN_W :: new (self) } # [doc = "Bit 4 - End of ED Measurement Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn cca_ed_done_en (& mut self) -> CCA_ED_DONE_EN_W < 4 > { CCA_ED_DONE_EN_W :: new (self) } # [doc = "Bit 5 - Address Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ami_en (& mut self) -> AMI_EN_W < 5 > { AMI_EN_W :: new (self) } # [doc = "Bit 6 - TX_END Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn tx_end_en (& mut self) -> TX_END_EN_W < 6 > { TX_END_EN_W :: new (self) } # [doc = "Bit 7 - Awake Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn awake_en (& mut self) -> AWAKE_EN_W < 7 > { AWAKE_EN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_mask](index.html) module"]
pub struct IRQ_MASK_SPEC ; impl crate :: RegisterSpec for IRQ_MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [irq_mask::R](R) reader structure"]
impl crate :: Readable for IRQ_MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_mask::W](W) writer structure"]
impl crate :: Writable for IRQ_MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IRQ_MASK to value 0"]
impl crate :: Resettable for IRQ_MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IRQ_STATUS (rw) register accessor: an alias for `Reg<IRQ_STATUS_SPEC>`"]
pub type IRQ_STATUS = crate :: Reg < irq_status :: IRQ_STATUS_SPEC > ; # [doc = "Transceiver Interrupt Status Register"]
pub mod irq_status { # [doc = "Register `IRQ_STATUS` reader"]
pub struct R (crate :: R < IRQ_STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IRQ_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IRQ_STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IRQ_STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `IRQ_STATUS` writer"]
pub struct W (crate :: W < IRQ_STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IRQ_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IRQ_STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IRQ_STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PLL_LOCK` reader - PLL Lock Interrupt Status"]
pub type PLL_LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `PLL_LOCK` writer - PLL Lock Interrupt Status"]
pub type PLL_LOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_STATUS_SPEC , bool , O > ; # [doc = "Field `PLL_UNLOCK` reader - PLL Unlock Interrupt Status"]
pub type PLL_UNLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `PLL_UNLOCK` writer - PLL Unlock Interrupt Status"]
pub type PLL_UNLOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_STATUS_SPEC , bool , O > ; # [doc = "Field `RX_START` reader - RX_START Interrupt Status"]
pub type RX_START_R = crate :: BitReader < bool > ; # [doc = "Field `RX_START` writer - RX_START Interrupt Status"]
pub type RX_START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_STATUS_SPEC , bool , O > ; # [doc = "Field `RX_END` reader - RX_END Interrupt Status"]
pub type RX_END_R = crate :: BitReader < bool > ; # [doc = "Field `RX_END` writer - RX_END Interrupt Status"]
pub type RX_END_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_STATUS_SPEC , bool , O > ; # [doc = "Field `CCA_ED_DONE` reader - End of ED Measurement Interrupt Status"]
pub type CCA_ED_DONE_R = crate :: BitReader < bool > ; # [doc = "Field `CCA_ED_DONE` writer - End of ED Measurement Interrupt Status"]
pub type CCA_ED_DONE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_STATUS_SPEC , bool , O > ; # [doc = "Field `AMI` reader - Address Match Interrupt Status"]
pub type AMI_R = crate :: BitReader < bool > ; # [doc = "Field `AMI` writer - Address Match Interrupt Status"]
pub type AMI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_STATUS_SPEC , bool , O > ; # [doc = "Field `TX_END` reader - TX_END Interrupt Status"]
pub type TX_END_R = crate :: BitReader < bool > ; # [doc = "Field `TX_END` writer - TX_END Interrupt Status"]
pub type TX_END_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_STATUS_SPEC , bool , O > ; # [doc = "Field `AWAKE` reader - Awake Interrupt Status"]
pub type AWAKE_R = crate :: BitReader < bool > ; # [doc = "Field `AWAKE` writer - Awake Interrupt Status"]
pub type AWAKE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IRQ_STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - PLL Lock Interrupt Status"]
# [inline (always)]
pub fn pll_lock (& self) -> PLL_LOCK_R { PLL_LOCK_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - PLL Unlock Interrupt Status"]
# [inline (always)]
pub fn pll_unlock (& self) -> PLL_UNLOCK_R { PLL_UNLOCK_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - RX_START Interrupt Status"]
# [inline (always)]
pub fn rx_start (& self) -> RX_START_R { RX_START_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - RX_END Interrupt Status"]
# [inline (always)]
pub fn rx_end (& self) -> RX_END_R { RX_END_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - End of ED Measurement Interrupt Status"]
# [inline (always)]
pub fn cca_ed_done (& self) -> CCA_ED_DONE_R { CCA_ED_DONE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Address Match Interrupt Status"]
# [inline (always)]
pub fn ami (& self) -> AMI_R { AMI_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TX_END Interrupt Status"]
# [inline (always)]
pub fn tx_end (& self) -> TX_END_R { TX_END_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Awake Interrupt Status"]
# [inline (always)]
pub fn awake (& self) -> AWAKE_R { AWAKE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - PLL Lock Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn pll_lock (& mut self) -> PLL_LOCK_W < 0 > { PLL_LOCK_W :: new (self) } # [doc = "Bit 1 - PLL Unlock Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn pll_unlock (& mut self) -> PLL_UNLOCK_W < 1 > { PLL_UNLOCK_W :: new (self) } # [doc = "Bit 2 - RX_START Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn rx_start (& mut self) -> RX_START_W < 2 > { RX_START_W :: new (self) } # [doc = "Bit 3 - RX_END Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn rx_end (& mut self) -> RX_END_W < 3 > { RX_END_W :: new (self) } # [doc = "Bit 4 - End of ED Measurement Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn cca_ed_done (& mut self) -> CCA_ED_DONE_W < 4 > { CCA_ED_DONE_W :: new (self) } # [doc = "Bit 5 - Address Match Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn ami (& mut self) -> AMI_W < 5 > { AMI_W :: new (self) } # [doc = "Bit 6 - TX_END Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn tx_end (& mut self) -> TX_END_W < 6 > { TX_END_W :: new (self) } # [doc = "Bit 7 - Awake Interrupt Status"]
# [inline (always)]
# [must_use]
pub fn awake (& mut self) -> AWAKE_W < 7 > { AWAKE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irq_status](index.html) module"]
pub struct IRQ_STATUS_SPEC ; impl crate :: RegisterSpec for IRQ_STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [irq_status::R](R) reader structure"]
impl crate :: Readable for IRQ_STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [irq_status::W](W) writer structure"]
impl crate :: Writable for IRQ_STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IRQ_STATUS to value 0"]
impl crate :: Resettable for IRQ_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MAN_ID_0 (rw) register accessor: an alias for `Reg<MAN_ID_0_SPEC>`"]
pub type MAN_ID_0 = crate :: Reg < man_id_0 :: MAN_ID_0_SPEC > ; # [doc = "Device Identification Register (Manufacture ID Low Byte)"]
pub mod man_id_0 { # [doc = "Register `MAN_ID_0` reader"]
pub struct R (crate :: R < MAN_ID_0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MAN_ID_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MAN_ID_0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MAN_ID_0_SPEC >) -> Self { R (reader) } } # [doc = "Register `MAN_ID_0` writer"]
pub struct W (crate :: W < MAN_ID_0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MAN_ID_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MAN_ID_0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MAN_ID_0_SPEC >) -> Self { W (writer) } } # [doc = "Field `MAN_ID_00` reader - Manufacturer ID (Low Byte)"]
pub type MAN_ID_00_R = crate :: BitReader < bool > ; # [doc = "Field `MAN_ID_00` writer - Manufacturer ID (Low Byte)"]
pub type MAN_ID_00_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MAN_ID_0_SPEC , bool , O > ; # [doc = "Field `MAN_ID_01` reader - Manufacturer ID (Low Byte)"]
pub type MAN_ID_01_R = crate :: BitReader < bool > ; # [doc = "Field `MAN_ID_01` writer - Manufacturer ID (Low Byte)"]
pub type MAN_ID_01_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MAN_ID_0_SPEC , bool , O > ; # [doc = "Field `MAN_ID_02` reader - Manufacturer ID (Low Byte)"]
pub type MAN_ID_02_R = crate :: BitReader < bool > ; # [doc = "Field `MAN_ID_02` writer - Manufacturer ID (Low Byte)"]
pub type MAN_ID_02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MAN_ID_0_SPEC , bool , O > ; # [doc = "Field `MAN_ID_03` reader - Manufacturer ID (Low Byte)"]
pub type MAN_ID_03_R = crate :: BitReader < bool > ; # [doc = "Field `MAN_ID_03` writer - Manufacturer ID (Low Byte)"]
pub type MAN_ID_03_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MAN_ID_0_SPEC , bool , O > ; # [doc = "Field `MAN_ID_04` reader - Manufacturer ID (Low Byte)"]
pub type MAN_ID_04_R = crate :: BitReader < bool > ; # [doc = "Field `MAN_ID_04` writer - Manufacturer ID (Low Byte)"]
pub type MAN_ID_04_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MAN_ID_0_SPEC , bool , O > ; # [doc = "Field `MAN_ID_05` reader - Manufacturer ID (Low Byte)"]
pub type MAN_ID_05_R = crate :: BitReader < bool > ; # [doc = "Field `MAN_ID_05` writer - Manufacturer ID (Low Byte)"]
pub type MAN_ID_05_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MAN_ID_0_SPEC , bool , O > ; # [doc = "Field `MAN_ID_06` reader - Manufacturer ID (Low Byte)"]
pub type MAN_ID_06_R = crate :: BitReader < bool > ; # [doc = "Field `MAN_ID_06` writer - Manufacturer ID (Low Byte)"]
pub type MAN_ID_06_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MAN_ID_0_SPEC , bool , O > ; # [doc = "Field `MAN_ID_07` reader - Manufacturer ID (Low Byte)"]
pub type MAN_ID_07_R = crate :: BitReader < bool > ; # [doc = "Field `MAN_ID_07` writer - Manufacturer ID (Low Byte)"]
pub type MAN_ID_07_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MAN_ID_0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Manufacturer ID (Low Byte)"]
# [inline (always)]
pub fn man_id_00 (& self) -> MAN_ID_00_R { MAN_ID_00_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Manufacturer ID (Low Byte)"]
# [inline (always)]
pub fn man_id_01 (& self) -> MAN_ID_01_R { MAN_ID_01_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Manufacturer ID (Low Byte)"]
# [inline (always)]
pub fn man_id_02 (& self) -> MAN_ID_02_R { MAN_ID_02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Manufacturer ID (Low Byte)"]
# [inline (always)]
pub fn man_id_03 (& self) -> MAN_ID_03_R { MAN_ID_03_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Manufacturer ID (Low Byte)"]
# [inline (always)]
pub fn man_id_04 (& self) -> MAN_ID_04_R { MAN_ID_04_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Manufacturer ID (Low Byte)"]
# [inline (always)]
pub fn man_id_05 (& self) -> MAN_ID_05_R { MAN_ID_05_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Manufacturer ID (Low Byte)"]
# [inline (always)]
pub fn man_id_06 (& self) -> MAN_ID_06_R { MAN_ID_06_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Manufacturer ID (Low Byte)"]
# [inline (always)]
pub fn man_id_07 (& self) -> MAN_ID_07_R { MAN_ID_07_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Manufacturer ID (Low Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_00 (& mut self) -> MAN_ID_00_W < 0 > { MAN_ID_00_W :: new (self) } # [doc = "Bit 1 - Manufacturer ID (Low Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_01 (& mut self) -> MAN_ID_01_W < 1 > { MAN_ID_01_W :: new (self) } # [doc = "Bit 2 - Manufacturer ID (Low Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_02 (& mut self) -> MAN_ID_02_W < 2 > { MAN_ID_02_W :: new (self) } # [doc = "Bit 3 - Manufacturer ID (Low Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_03 (& mut self) -> MAN_ID_03_W < 3 > { MAN_ID_03_W :: new (self) } # [doc = "Bit 4 - Manufacturer ID (Low Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_04 (& mut self) -> MAN_ID_04_W < 4 > { MAN_ID_04_W :: new (self) } # [doc = "Bit 5 - Manufacturer ID (Low Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_05 (& mut self) -> MAN_ID_05_W < 5 > { MAN_ID_05_W :: new (self) } # [doc = "Bit 6 - Manufacturer ID (Low Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_06 (& mut self) -> MAN_ID_06_W < 6 > { MAN_ID_06_W :: new (self) } # [doc = "Bit 7 - Manufacturer ID (Low Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_07 (& mut self) -> MAN_ID_07_W < 7 > { MAN_ID_07_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Device Identification Register (Manufacture ID Low Byte)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [man_id_0](index.html) module"]
pub struct MAN_ID_0_SPEC ; impl crate :: RegisterSpec for MAN_ID_0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [man_id_0::R](R) reader structure"]
impl crate :: Readable for MAN_ID_0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [man_id_0::W](W) writer structure"]
impl crate :: Writable for MAN_ID_0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MAN_ID_0 to value 0"]
impl crate :: Resettable for MAN_ID_0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MAN_ID_1 (rw) register accessor: an alias for `Reg<MAN_ID_1_SPEC>`"]
pub type MAN_ID_1 = crate :: Reg < man_id_1 :: MAN_ID_1_SPEC > ; # [doc = "Device Identification Register (Manufacture ID High Byte)"]
pub mod man_id_1 { # [doc = "Register `MAN_ID_1` reader"]
pub struct R (crate :: R < MAN_ID_1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MAN_ID_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MAN_ID_1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MAN_ID_1_SPEC >) -> Self { R (reader) } } # [doc = "Register `MAN_ID_1` writer"]
pub struct W (crate :: W < MAN_ID_1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MAN_ID_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MAN_ID_1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MAN_ID_1_SPEC >) -> Self { W (writer) } } # [doc = "Field `MAN_ID_` reader - Manufacturer ID (High Byte)"]
pub type MAN_ID__R = crate :: FieldReader < u8 , MAN_ID__A > ; # [doc = "Manufacturer ID (High Byte)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MAN_ID__A { # [doc = "0: Atmel JEDEC manufacturer ID, bits \\[15:8\\]
of 32 bit manufacturer ID: 00 00 00 1F"]
ATMEL_BYTE_1 = 0 , } impl From < MAN_ID__A > for u8 { # [inline (always)]
fn from (variant : MAN_ID__A) -> Self { variant as _ } } impl MAN_ID__R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MAN_ID__A > { match self . bits { 0 => Some (MAN_ID__A :: ATMEL_BYTE_1) , _ => None , } } # [doc = "Checks if the value of the field is `ATMEL_BYTE_1`"]
# [inline (always)]
pub fn is_atmel_byte_1 (& self) -> bool { * self == MAN_ID__A :: ATMEL_BYTE_1 } } # [doc = "Field `MAN_ID_` writer - Manufacturer ID (High Byte)"]
pub type MAN_ID__W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , MAN_ID_1_SPEC , u8 , MAN_ID__A , 8 , O > ; impl < 'a , const O : u8 > MAN_ID__W < 'a , O > { # [doc = "Atmel JEDEC manufacturer ID, bits \\[15:8\\]
of 32 bit manufacturer ID: 00 00 00 1F"]
# [inline (always)]
pub fn atmel_byte_1 (self) -> & 'a mut W { self . variant (MAN_ID__A :: ATMEL_BYTE_1) } } impl R { # [doc = "Bits 0:7 - Manufacturer ID (High Byte)"]
# [inline (always)]
pub fn man_id_ (& self) -> MAN_ID__R { MAN_ID__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Manufacturer ID (High Byte)"]
# [inline (always)]
# [must_use]
pub fn man_id_ (& mut self) -> MAN_ID__W < 0 > { MAN_ID__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Device Identification Register (Manufacture ID High Byte)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [man_id_1](index.html) module"]
pub struct MAN_ID_1_SPEC ; impl crate :: RegisterSpec for MAN_ID_1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [man_id_1::R](R) reader structure"]
impl crate :: Readable for MAN_ID_1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [man_id_1::W](W) writer structure"]
impl crate :: Writable for MAN_ID_1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MAN_ID_1 to value 0"]
impl crate :: Resettable for MAN_ID_1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PAN_ID_0 (rw) register accessor: an alias for `Reg<PAN_ID_0_SPEC>`"]
pub type PAN_ID_0 = crate :: Reg < pan_id_0 :: PAN_ID_0_SPEC > ; # [doc = "Transceiver Personal Area Network ID Register (Low Byte)"]
pub mod pan_id_0 { # [doc = "Register `PAN_ID_0` reader"]
pub struct R (crate :: R < PAN_ID_0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PAN_ID_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PAN_ID_0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PAN_ID_0_SPEC >) -> Self { R (reader) } } # [doc = "Register `PAN_ID_0` writer"]
pub struct W (crate :: W < PAN_ID_0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PAN_ID_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PAN_ID_0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PAN_ID_0_SPEC >) -> Self { W (writer) } } # [doc = "Field `PAN_ID_00` reader - MAC Personal Area Network ID"]
pub type PAN_ID_00_R = crate :: BitReader < bool > ; # [doc = "Field `PAN_ID_00` writer - MAC Personal Area Network ID"]
pub type PAN_ID_00_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PAN_ID_0_SPEC , bool , O > ; # [doc = "Field `PAN_ID_01` reader - MAC Personal Area Network ID"]
pub type PAN_ID_01_R = crate :: BitReader < bool > ; # [doc = "Field `PAN_ID_01` writer - MAC Personal Area Network ID"]
pub type PAN_ID_01_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PAN_ID_0_SPEC , bool , O > ; # [doc = "Field `PAN_ID_02` reader - MAC Personal Area Network ID"]
pub type PAN_ID_02_R = crate :: BitReader < bool > ; # [doc = "Field `PAN_ID_02` writer - MAC Personal Area Network ID"]
pub type PAN_ID_02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PAN_ID_0_SPEC , bool , O > ; # [doc = "Field `PAN_ID_03` reader - MAC Personal Area Network ID"]
pub type PAN_ID_03_R = crate :: BitReader < bool > ; # [doc = "Field `PAN_ID_03` writer - MAC Personal Area Network ID"]
pub type PAN_ID_03_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PAN_ID_0_SPEC , bool , O > ; # [doc = "Field `PAN_ID_04` reader - MAC Personal Area Network ID"]
pub type PAN_ID_04_R = crate :: BitReader < bool > ; # [doc = "Field `PAN_ID_04` writer - MAC Personal Area Network ID"]
pub type PAN_ID_04_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PAN_ID_0_SPEC , bool , O > ; # [doc = "Field `PAN_ID_05` reader - MAC Personal Area Network ID"]
pub type PAN_ID_05_R = crate :: BitReader < bool > ; # [doc = "Field `PAN_ID_05` writer - MAC Personal Area Network ID"]
pub type PAN_ID_05_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PAN_ID_0_SPEC , bool , O > ; # [doc = "Field `PAN_ID_06` reader - MAC Personal Area Network ID"]
pub type PAN_ID_06_R = crate :: BitReader < bool > ; # [doc = "Field `PAN_ID_06` writer - MAC Personal Area Network ID"]
pub type PAN_ID_06_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PAN_ID_0_SPEC , bool , O > ; # [doc = "Field `PAN_ID_07` reader - MAC Personal Area Network ID"]
pub type PAN_ID_07_R = crate :: BitReader < bool > ; # [doc = "Field `PAN_ID_07` writer - MAC Personal Area Network ID"]
pub type PAN_ID_07_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PAN_ID_0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_00 (& self) -> PAN_ID_00_R { PAN_ID_00_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_01 (& self) -> PAN_ID_01_R { PAN_ID_01_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_02 (& self) -> PAN_ID_02_R { PAN_ID_02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_03 (& self) -> PAN_ID_03_R { PAN_ID_03_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_04 (& self) -> PAN_ID_04_R { PAN_ID_04_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_05 (& self) -> PAN_ID_05_R { PAN_ID_05_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_06 (& self) -> PAN_ID_06_R { PAN_ID_06_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_07 (& self) -> PAN_ID_07_R { PAN_ID_07_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_00 (& mut self) -> PAN_ID_00_W < 0 > { PAN_ID_00_W :: new (self) } # [doc = "Bit 1 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_01 (& mut self) -> PAN_ID_01_W < 1 > { PAN_ID_01_W :: new (self) } # [doc = "Bit 2 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_02 (& mut self) -> PAN_ID_02_W < 2 > { PAN_ID_02_W :: new (self) } # [doc = "Bit 3 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_03 (& mut self) -> PAN_ID_03_W < 3 > { PAN_ID_03_W :: new (self) } # [doc = "Bit 4 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_04 (& mut self) -> PAN_ID_04_W < 4 > { PAN_ID_04_W :: new (self) } # [doc = "Bit 5 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_05 (& mut self) -> PAN_ID_05_W < 5 > { PAN_ID_05_W :: new (self) } # [doc = "Bit 6 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_06 (& mut self) -> PAN_ID_06_W < 6 > { PAN_ID_06_W :: new (self) } # [doc = "Bit 7 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_07 (& mut self) -> PAN_ID_07_W < 7 > { PAN_ID_07_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Personal Area Network ID Register (Low Byte)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pan_id_0](index.html) module"]
pub struct PAN_ID_0_SPEC ; impl crate :: RegisterSpec for PAN_ID_0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pan_id_0::R](R) reader structure"]
impl crate :: Readable for PAN_ID_0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pan_id_0::W](W) writer structure"]
impl crate :: Writable for PAN_ID_0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PAN_ID_0 to value 0"]
impl crate :: Resettable for PAN_ID_0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PAN_ID_1 (rw) register accessor: an alias for `Reg<PAN_ID_1_SPEC>`"]
pub type PAN_ID_1 = crate :: Reg < pan_id_1 :: PAN_ID_1_SPEC > ; # [doc = "Transceiver Personal Area Network ID Register (High Byte)"]
pub mod pan_id_1 { # [doc = "Register `PAN_ID_1` reader"]
pub struct R (crate :: R < PAN_ID_1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PAN_ID_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PAN_ID_1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PAN_ID_1_SPEC >) -> Self { R (reader) } } # [doc = "Register `PAN_ID_1` writer"]
pub struct W (crate :: W < PAN_ID_1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PAN_ID_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PAN_ID_1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PAN_ID_1_SPEC >) -> Self { W (writer) } } # [doc = "Field `PAN_ID_` reader - MAC Personal Area Network ID"]
pub type PAN_ID__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PAN_ID_` writer - MAC Personal Area Network ID"]
pub type PAN_ID__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PAN_ID_1_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC Personal Area Network ID"]
# [inline (always)]
pub fn pan_id_ (& self) -> PAN_ID__R { PAN_ID__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC Personal Area Network ID"]
# [inline (always)]
# [must_use]
pub fn pan_id_ (& mut self) -> PAN_ID__W < 0 > { PAN_ID__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver Personal Area Network ID Register (High Byte)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pan_id_1](index.html) module"]
pub struct PAN_ID_1_SPEC ; impl crate :: RegisterSpec for PAN_ID_1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pan_id_1::R](R) reader structure"]
impl crate :: Readable for PAN_ID_1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pan_id_1::W](W) writer structure"]
impl crate :: Writable for PAN_ID_1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PAN_ID_1 to value 0"]
impl crate :: Resettable for PAN_ID_1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PART_NUM (rw) register accessor: an alias for `Reg<PART_NUM_SPEC>`"]
pub type PART_NUM = crate :: Reg < part_num :: PART_NUM_SPEC > ; # [doc = "Device Identification Register (Part Number)"]
pub mod part_num { # [doc = "Register `PART_NUM` reader"]
pub struct R (crate :: R < PART_NUM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PART_NUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PART_NUM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PART_NUM_SPEC >) -> Self { R (reader) } } # [doc = "Register `PART_NUM` writer"]
pub struct W (crate :: W < PART_NUM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PART_NUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PART_NUM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PART_NUM_SPEC >) -> Self { W (writer) } } # [doc = "Field `PART_NUM` reader - Part Number"]
pub type PART_NUM_R = crate :: FieldReader < u8 , PART_NUM_A > ; # [doc = "Part Number\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PART_NUM_A { # [doc = "131: ATmega128RFA1 part number"]
P_ATMEGA128RFA1 = 131 , } impl From < PART_NUM_A > for u8 { # [inline (always)]
fn from (variant : PART_NUM_A) -> Self { variant as _ } } impl PART_NUM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PART_NUM_A > { match self . bits { 131 => Some (PART_NUM_A :: P_ATMEGA128RFA1) , _ => None , } } # [doc = "Checks if the value of the field is `P_ATMEGA128RFA1`"]
# [inline (always)]
pub fn is_p_atmega128rfa1 (& self) -> bool { * self == PART_NUM_A :: P_ATMEGA128RFA1 } } # [doc = "Field `PART_NUM` writer - Part Number"]
pub type PART_NUM_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PART_NUM_SPEC , u8 , PART_NUM_A , 8 , O > ; impl < 'a , const O : u8 > PART_NUM_W < 'a , O > { # [doc = "ATmega128RFA1 part number"]
# [inline (always)]
pub fn p_atmega128rfa1 (self) -> & 'a mut W { self . variant (PART_NUM_A :: P_ATMEGA128RFA1) } } impl R { # [doc = "Bits 0:7 - Part Number"]
# [inline (always)]
pub fn part_num (& self) -> PART_NUM_R { PART_NUM_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Part Number"]
# [inline (always)]
# [must_use]
pub fn part_num (& mut self) -> PART_NUM_W < 0 > { PART_NUM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Device Identification Register (Part Number)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [part_num](index.html) module"]
pub struct PART_NUM_SPEC ; impl crate :: RegisterSpec for PART_NUM_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [part_num::R](R) reader structure"]
impl crate :: Readable for PART_NUM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [part_num::W](W) writer structure"]
impl crate :: Writable for PART_NUM_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PART_NUM to value 0"]
impl crate :: Resettable for PART_NUM_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PHY_CC_CCA (rw) register accessor: an alias for `Reg<PHY_CC_CCA_SPEC>`"]
pub type PHY_CC_CCA = crate :: Reg < phy_cc_cca :: PHY_CC_CCA_SPEC > ; # [doc = "Transceiver Clear Channel Assessment (CCA) Control Register"]
pub mod phy_cc_cca { # [doc = "Register `PHY_CC_CCA` reader"]
pub struct R (crate :: R < PHY_CC_CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PHY_CC_CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PHY_CC_CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PHY_CC_CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `PHY_CC_CCA` writer"]
pub struct W (crate :: W < PHY_CC_CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PHY_CC_CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PHY_CC_CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PHY_CC_CCA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - RX/TX Channel Selection"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "RX/TX Channel Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "11: 2405 MHz"]
F_2405MHZ = 11 , # [doc = "12: 2410 MHz"]
F_2410MHZ = 12 , # [doc = "13: 2415 MHz"]
F_2415MHZ = 13 , # [doc = "14: 2420 MHz"]
F_2420MHZ = 14 , # [doc = "15: 2425 MHz"]
F_2425MHZ = 15 , # [doc = "16: 2430 MHz"]
F_2430MHZ = 16 , # [doc = "17: 2435 MHz"]
F_2435MHZ = 17 , # [doc = "18: 2440 MHz"]
F_2440MHZ = 18 , # [doc = "19: 2445 MHz"]
F_2445MHZ = 19 , # [doc = "20: 2450 MHz"]
F_2450MHZ = 20 , # [doc = "21: 2455 MHz"]
F_2455MHZ = 21 , # [doc = "22: 2460 MHz"]
F_2460MHZ = 22 , # [doc = "23: 2465 MHz"]
F_2465MHZ = 23 , # [doc = "24: 2470 MHz"]
F_2470MHZ = 24 , # [doc = "25: 2475 MHz"]
F_2475MHZ = 25 , # [doc = "26: 2480 MHz"]
F_2480MHZ = 26 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 11 => Some (CHANNEL_A :: F_2405MHZ) , 12 => Some (CHANNEL_A :: F_2410MHZ) , 13 => Some (CHANNEL_A :: F_2415MHZ) , 14 => Some (CHANNEL_A :: F_2420MHZ) , 15 => Some (CHANNEL_A :: F_2425MHZ) , 16 => Some (CHANNEL_A :: F_2430MHZ) , 17 => Some (CHANNEL_A :: F_2435MHZ) , 18 => Some (CHANNEL_A :: F_2440MHZ) , 19 => Some (CHANNEL_A :: F_2445MHZ) , 20 => Some (CHANNEL_A :: F_2450MHZ) , 21 => Some (CHANNEL_A :: F_2455MHZ) , 22 => Some (CHANNEL_A :: F_2460MHZ) , 23 => Some (CHANNEL_A :: F_2465MHZ) , 24 => Some (CHANNEL_A :: F_2470MHZ) , 25 => Some (CHANNEL_A :: F_2475MHZ) , 26 => Some (CHANNEL_A :: F_2480MHZ) , _ => None , } } # [doc = "Checks if the value of the field is `F_2405MHZ`"]
# [inline (always)]
pub fn is_f_2405mhz (& self) -> bool { * self == CHANNEL_A :: F_2405MHZ } # [doc = "Checks if the value of the field is `F_2410MHZ`"]
# [inline (always)]
pub fn is_f_2410mhz (& self) -> bool { * self == CHANNEL_A :: F_2410MHZ } # [doc = "Checks if the value of the field is `F_2415MHZ`"]
# [inline (always)]
pub fn is_f_2415mhz (& self) -> bool { * self == CHANNEL_A :: F_2415MHZ } # [doc = "Checks if the value of the field is `F_2420MHZ`"]
# [inline (always)]
pub fn is_f_2420mhz (& self) -> bool { * self == CHANNEL_A :: F_2420MHZ } # [doc = "Checks if the value of the field is `F_2425MHZ`"]
# [inline (always)]
pub fn is_f_2425mhz (& self) -> bool { * self == CHANNEL_A :: F_2425MHZ } # [doc = "Checks if the value of the field is `F_2430MHZ`"]
# [inline (always)]
pub fn is_f_2430mhz (& self) -> bool { * self == CHANNEL_A :: F_2430MHZ } # [doc = "Checks if the value of the field is `F_2435MHZ`"]
# [inline (always)]
pub fn is_f_2435mhz (& self) -> bool { * self == CHANNEL_A :: F_2435MHZ } # [doc = "Checks if the value of the field is `F_2440MHZ`"]
# [inline (always)]
pub fn is_f_2440mhz (& self) -> bool { * self == CHANNEL_A :: F_2440MHZ } # [doc = "Checks if the value of the field is `F_2445MHZ`"]
# [inline (always)]
pub fn is_f_2445mhz (& self) -> bool { * self == CHANNEL_A :: F_2445MHZ } # [doc = "Checks if the value of the field is `F_2450MHZ`"]
# [inline (always)]
pub fn is_f_2450mhz (& self) -> bool { * self == CHANNEL_A :: F_2450MHZ } # [doc = "Checks if the value of the field is `F_2455MHZ`"]
# [inline (always)]
pub fn is_f_2455mhz (& self) -> bool { * self == CHANNEL_A :: F_2455MHZ } # [doc = "Checks if the value of the field is `F_2460MHZ`"]
# [inline (always)]
pub fn is_f_2460mhz (& self) -> bool { * self == CHANNEL_A :: F_2460MHZ } # [doc = "Checks if the value of the field is `F_2465MHZ`"]
# [inline (always)]
pub fn is_f_2465mhz (& self) -> bool { * self == CHANNEL_A :: F_2465MHZ } # [doc = "Checks if the value of the field is `F_2470MHZ`"]
# [inline (always)]
pub fn is_f_2470mhz (& self) -> bool { * self == CHANNEL_A :: F_2470MHZ } # [doc = "Checks if the value of the field is `F_2475MHZ`"]
# [inline (always)]
pub fn is_f_2475mhz (& self) -> bool { * self == CHANNEL_A :: F_2475MHZ } # [doc = "Checks if the value of the field is `F_2480MHZ`"]
# [inline (always)]
pub fn is_f_2480mhz (& self) -> bool { * self == CHANNEL_A :: F_2480MHZ } } # [doc = "Field `CHANNEL` writer - RX/TX Channel Selection"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PHY_CC_CCA_SPEC , u8 , CHANNEL_A , 5 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "2405 MHz"]
# [inline (always)]
pub fn f_2405mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2405MHZ) } # [doc = "2410 MHz"]
# [inline (always)]
pub fn f_2410mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2410MHZ) } # [doc = "2415 MHz"]
# [inline (always)]
pub fn f_2415mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2415MHZ) } # [doc = "2420 MHz"]
# [inline (always)]
pub fn f_2420mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2420MHZ) } # [doc = "2425 MHz"]
# [inline (always)]
pub fn f_2425mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2425MHZ) } # [doc = "2430 MHz"]
# [inline (always)]
pub fn f_2430mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2430MHZ) } # [doc = "2435 MHz"]
# [inline (always)]
pub fn f_2435mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2435MHZ) } # [doc = "2440 MHz"]
# [inline (always)]
pub fn f_2440mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2440MHZ) } # [doc = "2445 MHz"]
# [inline (always)]
pub fn f_2445mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2445MHZ) } # [doc = "2450 MHz"]
# [inline (always)]
pub fn f_2450mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2450MHZ) } # [doc = "2455 MHz"]
# [inline (always)]
pub fn f_2455mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2455MHZ) } # [doc = "2460 MHz"]
# [inline (always)]
pub fn f_2460mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2460MHZ) } # [doc = "2465 MHz"]
# [inline (always)]
pub fn f_2465mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2465MHZ) } # [doc = "2470 MHz"]
# [inline (always)]
pub fn f_2470mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2470MHZ) } # [doc = "2475 MHz"]
# [inline (always)]
pub fn f_2475mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2475MHZ) } # [doc = "2480 MHz"]
# [inline (always)]
pub fn f_2480mhz (self) -> & 'a mut W { self . variant (CHANNEL_A :: F_2480MHZ) } } # [doc = "Field `CCA_MODE` reader - Select CCA Measurement Mode"]
pub type CCA_MODE_R = crate :: FieldReader < u8 , CCA_MODE_A > ; # [doc = "Select CCA Measurement Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCA_MODE_A { # [doc = "0: Mode 3a, Carrier sense OR energy above threshold"]
CCA_CS_OR_ED = 0 , # [doc = "1: Mode 1, Energy above threshold"]
CCA_ED = 1 , # [doc = "2: Mode 2, Carrier sense only"]
CCA_CS = 2 , # [doc = "3: Mode 3b, Carrier sense AND energy above threshold"]
CCA_CS_AND_ED = 3 , } impl From < CCA_MODE_A > for u8 { # [inline (always)]
fn from (variant : CCA_MODE_A) -> Self { variant as _ } } impl CCA_MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCA_MODE_A { match self . bits { 0 => CCA_MODE_A :: CCA_CS_OR_ED , 1 => CCA_MODE_A :: CCA_ED , 2 => CCA_MODE_A :: CCA_CS , 3 => CCA_MODE_A :: CCA_CS_AND_ED , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CCA_CS_OR_ED`"]
# [inline (always)]
pub fn is_cca_cs_or_ed (& self) -> bool { * self == CCA_MODE_A :: CCA_CS_OR_ED } # [doc = "Checks if the value of the field is `CCA_ED`"]
# [inline (always)]
pub fn is_cca_ed (& self) -> bool { * self == CCA_MODE_A :: CCA_ED } # [doc = "Checks if the value of the field is `CCA_CS`"]
# [inline (always)]
pub fn is_cca_cs (& self) -> bool { * self == CCA_MODE_A :: CCA_CS } # [doc = "Checks if the value of the field is `CCA_CS_AND_ED`"]
# [inline (always)]
pub fn is_cca_cs_and_ed (& self) -> bool { * self == CCA_MODE_A :: CCA_CS_AND_ED } } # [doc = "Field `CCA_MODE` writer - Select CCA Measurement Mode"]
pub type CCA_MODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PHY_CC_CCA_SPEC , u8 , CCA_MODE_A , 2 , O > ; impl < 'a , const O : u8 > CCA_MODE_W < 'a , O > { # [doc = "Mode 3a, Carrier sense OR energy above threshold"]
# [inline (always)]
pub fn cca_cs_or_ed (self) -> & 'a mut W { self . variant (CCA_MODE_A :: CCA_CS_OR_ED) } # [doc = "Mode 1, Energy above threshold"]
# [inline (always)]
pub fn cca_ed (self) -> & 'a mut W { self . variant (CCA_MODE_A :: CCA_ED) } # [doc = "Mode 2, Carrier sense only"]
# [inline (always)]
pub fn cca_cs (self) -> & 'a mut W { self . variant (CCA_MODE_A :: CCA_CS) } # [doc = "Mode 3b, Carrier sense AND energy above threshold"]
# [inline (always)]
pub fn cca_cs_and_ed (self) -> & 'a mut W { self . variant (CCA_MODE_A :: CCA_CS_AND_ED) } } # [doc = "Field `CCA_REQUEST` reader - Manual CCA Measurement Request"]
pub type CCA_REQUEST_R = crate :: BitReader < bool > ; # [doc = "Field `CCA_REQUEST` writer - Manual CCA Measurement Request"]
pub type CCA_REQUEST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PHY_CC_CCA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:4 - RX/TX Channel Selection"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits & 0x1f) } # [doc = "Bits 5:6 - Select CCA Measurement Mode"]
# [inline (always)]
pub fn cca_mode (& self) -> CCA_MODE_R { CCA_MODE_R :: new ((self . bits >> 5) & 3) } # [doc = "Bit 7 - Manual CCA Measurement Request"]
# [inline (always)]
pub fn cca_request (& self) -> CCA_REQUEST_R { CCA_REQUEST_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - RX/TX Channel Selection"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Bits 5:6 - Select CCA Measurement Mode"]
# [inline (always)]
# [must_use]
pub fn cca_mode (& mut self) -> CCA_MODE_W < 5 > { CCA_MODE_W :: new (self) } # [doc = "Bit 7 - Manual CCA Measurement Request"]
# [inline (always)]
# [must_use]
pub fn cca_request (& mut self) -> CCA_REQUEST_W < 7 > { CCA_REQUEST_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Clear Channel Assessment (CCA) Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [phy_cc_cca](index.html) module"]
pub struct PHY_CC_CCA_SPEC ; impl crate :: RegisterSpec for PHY_CC_CCA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [phy_cc_cca::R](R) reader structure"]
impl crate :: Readable for PHY_CC_CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [phy_cc_cca::W](W) writer structure"]
impl crate :: Writable for PHY_CC_CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PHY_CC_CCA to value 0"]
impl crate :: Resettable for PHY_CC_CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PHY_ED_LEVEL (rw) register accessor: an alias for `Reg<PHY_ED_LEVEL_SPEC>`"]
pub type PHY_ED_LEVEL = crate :: Reg < phy_ed_level :: PHY_ED_LEVEL_SPEC > ; # [doc = "Transceiver Energy Detection Level Register"]
pub mod phy_ed_level { # [doc = "Register `PHY_ED_LEVEL` reader"]
pub struct R (crate :: R < PHY_ED_LEVEL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PHY_ED_LEVEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PHY_ED_LEVEL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PHY_ED_LEVEL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PHY_ED_LEVEL` writer"]
pub struct W (crate :: W < PHY_ED_LEVEL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PHY_ED_LEVEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PHY_ED_LEVEL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PHY_ED_LEVEL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ED_LEVEL` reader - Energy Detection Level"]
pub type ED_LEVEL_R = crate :: FieldReader < u8 , ED_LEVEL_A > ; # [doc = "Energy Detection Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ED_LEVEL_A { # [doc = "0: Minimum result of last ED measurement"]
ED_MIN = 0 , # [doc = "1: P(RF) = RSSI_BASE_VAL+ED \\[dBm\\]"]
ED_MIN_PLUS_1D_B = 1 , # [doc = "2: ..."]
VAL_0X02 = 2 , # [doc = "84: Maximum result of last ED measurement"]
ED_MAX = 84 , # [doc = "255: Reset value"]
ED_RESET = 255 , } impl From < ED_LEVEL_A > for u8 { # [inline (always)]
fn from (variant : ED_LEVEL_A) -> Self { variant as _ } } impl ED_LEVEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ED_LEVEL_A > { match self . bits { 0 => Some (ED_LEVEL_A :: ED_MIN) , 1 => Some (ED_LEVEL_A :: ED_MIN_PLUS_1D_B) , 2 => Some (ED_LEVEL_A :: VAL_0X02) , 84 => Some (ED_LEVEL_A :: ED_MAX) , 255 => Some (ED_LEVEL_A :: ED_RESET) , _ => None , } } # [doc = "Checks if the value of the field is `ED_MIN`"]
# [inline (always)]
pub fn is_ed_min (& self) -> bool { * self == ED_LEVEL_A :: ED_MIN } # [doc = "Checks if the value of the field is `ED_MIN_PLUS_1D_B`"]
# [inline (always)]
pub fn is_ed_min_plus_1d_b (& self) -> bool { * self == ED_LEVEL_A :: ED_MIN_PLUS_1D_B } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == ED_LEVEL_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `ED_MAX`"]
# [inline (always)]
pub fn is_ed_max (& self) -> bool { * self == ED_LEVEL_A :: ED_MAX } # [doc = "Checks if the value of the field is `ED_RESET`"]
# [inline (always)]
pub fn is_ed_reset (& self) -> bool { * self == ED_LEVEL_A :: ED_RESET } } # [doc = "Field `ED_LEVEL` writer - Energy Detection Level"]
pub type ED_LEVEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PHY_ED_LEVEL_SPEC , u8 , ED_LEVEL_A , 8 , O > ; impl < 'a , const O : u8 > ED_LEVEL_W < 'a , O > { # [doc = "Minimum result of last ED measurement"]
# [inline (always)]
pub fn ed_min (self) -> & 'a mut W { self . variant (ED_LEVEL_A :: ED_MIN) } # [doc = "P(RF) = RSSI_BASE_VAL+ED \\[dBm\\]"]
# [inline (always)]
pub fn ed_min_plus_1d_b (self) -> & 'a mut W { self . variant (ED_LEVEL_A :: ED_MIN_PLUS_1D_B) } # [doc = "..."]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (ED_LEVEL_A :: VAL_0X02) } # [doc = "Maximum result of last ED measurement"]
# [inline (always)]
pub fn ed_max (self) -> & 'a mut W { self . variant (ED_LEVEL_A :: ED_MAX) } # [doc = "Reset value"]
# [inline (always)]
pub fn ed_reset (self) -> & 'a mut W { self . variant (ED_LEVEL_A :: ED_RESET) } } impl R { # [doc = "Bits 0:7 - Energy Detection Level"]
# [inline (always)]
pub fn ed_level (& self) -> ED_LEVEL_R { ED_LEVEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Energy Detection Level"]
# [inline (always)]
# [must_use]
pub fn ed_level (& mut self) -> ED_LEVEL_W < 0 > { ED_LEVEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Energy Detection Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [phy_ed_level](index.html) module"]
pub struct PHY_ED_LEVEL_SPEC ; impl crate :: RegisterSpec for PHY_ED_LEVEL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [phy_ed_level::R](R) reader structure"]
impl crate :: Readable for PHY_ED_LEVEL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [phy_ed_level::W](W) writer structure"]
impl crate :: Writable for PHY_ED_LEVEL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PHY_ED_LEVEL to value 0"]
impl crate :: Resettable for PHY_ED_LEVEL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PHY_RSSI (rw) register accessor: an alias for `Reg<PHY_RSSI_SPEC>`"]
pub type PHY_RSSI = crate :: Reg < phy_rssi :: PHY_RSSI_SPEC > ; # [doc = "Receiver Signal Strength Indicator Register"]
pub mod phy_rssi { # [doc = "Register `PHY_RSSI` reader"]
pub struct R (crate :: R < PHY_RSSI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PHY_RSSI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PHY_RSSI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PHY_RSSI_SPEC >) -> Self { R (reader) } } # [doc = "Register `PHY_RSSI` writer"]
pub struct W (crate :: W < PHY_RSSI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PHY_RSSI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PHY_RSSI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PHY_RSSI_SPEC >) -> Self { W (writer) } } # [doc = "Field `RSSI` reader - Receiver Signal Strength Indicator"]
pub type RSSI_R = crate :: FieldReader < u8 , RSSI_A > ; # [doc = "Receiver Signal Strength Indicator\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RSSI_A { # [doc = "0: Minimum RSSI value: P(RF) < -90 dBm"]
RSSI_MIN = 0 , # [doc = "1: P(RF) = RSSI_BASE_VAL+3 · (RSSI-1) \\[dBm\\]"]
RSSI_MIN_PLUS_3D_B = 1 , # [doc = "2: ..."]
VAL_2 = 2 , # [doc = "28: Maximum RSSI value: P(RF) ≥ -10 dBm"]
RSSI_MAX = 28 , } impl From < RSSI_A > for u8 { # [inline (always)]
fn from (variant : RSSI_A) -> Self { variant as _ } } impl RSSI_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RSSI_A > { match self . bits { 0 => Some (RSSI_A :: RSSI_MIN) , 1 => Some (RSSI_A :: RSSI_MIN_PLUS_3D_B) , 2 => Some (RSSI_A :: VAL_2) , 28 => Some (RSSI_A :: RSSI_MAX) , _ => None , } } # [doc = "Checks if the value of the field is `RSSI_MIN`"]
# [inline (always)]
pub fn is_rssi_min (& self) -> bool { * self == RSSI_A :: RSSI_MIN } # [doc = "Checks if the value of the field is `RSSI_MIN_PLUS_3D_B`"]
# [inline (always)]
pub fn is_rssi_min_plus_3d_b (& self) -> bool { * self == RSSI_A :: RSSI_MIN_PLUS_3D_B } # [doc = "Checks if the value of the field is `VAL_2`"]
# [inline (always)]
pub fn is_val_2 (& self) -> bool { * self == RSSI_A :: VAL_2 } # [doc = "Checks if the value of the field is `RSSI_MAX`"]
# [inline (always)]
pub fn is_rssi_max (& self) -> bool { * self == RSSI_A :: RSSI_MAX } } # [doc = "Field `RSSI` writer - Receiver Signal Strength Indicator"]
pub type RSSI_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PHY_RSSI_SPEC , u8 , RSSI_A , 5 , O > ; impl < 'a , const O : u8 > RSSI_W < 'a , O > { # [doc = "Minimum RSSI value: P(RF) < -90 dBm"]
# [inline (always)]
pub fn rssi_min (self) -> & 'a mut W { self . variant (RSSI_A :: RSSI_MIN) } # [doc = "P(RF) = RSSI_BASE_VAL+3 · (RSSI-1) \\[dBm\\]"]
# [inline (always)]
pub fn rssi_min_plus_3d_b (self) -> & 'a mut W { self . variant (RSSI_A :: RSSI_MIN_PLUS_3D_B) } # [doc = "..."]
# [inline (always)]
pub fn val_2 (self) -> & 'a mut W { self . variant (RSSI_A :: VAL_2) } # [doc = "Maximum RSSI value: P(RF) ≥ -10 dBm"]
# [inline (always)]
pub fn rssi_max (self) -> & 'a mut W { self . variant (RSSI_A :: RSSI_MAX) } } # [doc = "Field `RND_VALUE` reader - Random Value"]
pub type RND_VALUE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RND_VALUE` writer - Random Value"]
pub type RND_VALUE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PHY_RSSI_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `RX_CRC_VALID` reader - Received Frame CRC Status"]
pub type RX_CRC_VALID_R = crate :: BitReader < RX_CRC_VALID_A > ; # [doc = "Received Frame CRC Status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RX_CRC_VALID_A { # [doc = "0: CRC (FCS) not valid"]
CRC_INVALID = 0 , # [doc = "1: CRC (FCS) valid"]
CRC_VALID = 1 , } impl From < RX_CRC_VALID_A > for bool { # [inline (always)]
fn from (variant : RX_CRC_VALID_A) -> Self { variant as u8 != 0 } } impl RX_CRC_VALID_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RX_CRC_VALID_A { match self . bits { false => RX_CRC_VALID_A :: CRC_INVALID , true => RX_CRC_VALID_A :: CRC_VALID , } } # [doc = "Checks if the value of the field is `CRC_INVALID`"]
# [inline (always)]
pub fn is_crc_invalid (& self) -> bool { * self == RX_CRC_VALID_A :: CRC_INVALID } # [doc = "Checks if the value of the field is `CRC_VALID`"]
# [inline (always)]
pub fn is_crc_valid (& self) -> bool { * self == RX_CRC_VALID_A :: CRC_VALID } } # [doc = "Field `RX_CRC_VALID` writer - Received Frame CRC Status"]
pub type RX_CRC_VALID_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PHY_RSSI_SPEC , RX_CRC_VALID_A , O > ; impl < 'a , const O : u8 > RX_CRC_VALID_W < 'a , O > { # [doc = "CRC (FCS) not valid"]
# [inline (always)]
pub fn crc_invalid (self) -> & 'a mut W { self . variant (RX_CRC_VALID_A :: CRC_INVALID) } # [doc = "CRC (FCS) valid"]
# [inline (always)]
pub fn crc_valid (self) -> & 'a mut W { self . variant (RX_CRC_VALID_A :: CRC_VALID) } } impl R { # [doc = "Bits 0:4 - Receiver Signal Strength Indicator"]
# [inline (always)]
pub fn rssi (& self) -> RSSI_R { RSSI_R :: new (self . bits & 0x1f) } # [doc = "Bits 5:6 - Random Value"]
# [inline (always)]
pub fn rnd_value (& self) -> RND_VALUE_R { RND_VALUE_R :: new ((self . bits >> 5) & 3) } # [doc = "Bit 7 - Received Frame CRC Status"]
# [inline (always)]
pub fn rx_crc_valid (& self) -> RX_CRC_VALID_R { RX_CRC_VALID_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Receiver Signal Strength Indicator"]
# [inline (always)]
# [must_use]
pub fn rssi (& mut self) -> RSSI_W < 0 > { RSSI_W :: new (self) } # [doc = "Bits 5:6 - Random Value"]
# [inline (always)]
# [must_use]
pub fn rnd_value (& mut self) -> RND_VALUE_W < 5 > { RND_VALUE_W :: new (self) } # [doc = "Bit 7 - Received Frame CRC Status"]
# [inline (always)]
# [must_use]
pub fn rx_crc_valid (& mut self) -> RX_CRC_VALID_W < 7 > { RX_CRC_VALID_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Receiver Signal Strength Indicator Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [phy_rssi](index.html) module"]
pub struct PHY_RSSI_SPEC ; impl crate :: RegisterSpec for PHY_RSSI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [phy_rssi::R](R) reader structure"]
impl crate :: Readable for PHY_RSSI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [phy_rssi::W](W) writer structure"]
impl crate :: Writable for PHY_RSSI_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PHY_RSSI to value 0"]
impl crate :: Resettable for PHY_RSSI_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PHY_TX_PWR (rw) register accessor: an alias for `Reg<PHY_TX_PWR_SPEC>`"]
pub type PHY_TX_PWR = crate :: Reg < phy_tx_pwr :: PHY_TX_PWR_SPEC > ; # [doc = "Transceiver Transmit Power Control Register"]
pub mod phy_tx_pwr { # [doc = "Register `PHY_TX_PWR` reader"]
pub struct R (crate :: R < PHY_TX_PWR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PHY_TX_PWR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PHY_TX_PWR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PHY_TX_PWR_SPEC >) -> Self { R (reader) } } # [doc = "Register `PHY_TX_PWR` writer"]
pub struct W (crate :: W < PHY_TX_PWR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PHY_TX_PWR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PHY_TX_PWR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PHY_TX_PWR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TX_PWR` reader - Transmit Power Setting"]
pub type TX_PWR_R = crate :: FieldReader < u8 , TX_PWR_A > ; # [doc = "Transmit Power Setting\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TX_PWR_A { # [doc = "0: 3.0 dBm"]
_3_0_DBM = 0 , # [doc = "1: 2.8 dBm"]
_2_8_DBM = 1 , # [doc = "2: 2.3 dBm"]
_2_3_DBM = 2 , # [doc = "3: 1.8 dBm"]
_1_8_DBM = 3 , # [doc = "4: 1.3 dBm"]
_1_3_DBM = 4 , # [doc = "5: 0.7 dBm"]
_0_7_DBM = 5 , # [doc = "6: 0.0 dBm"]
_0_0_DBM = 6 , # [doc = "7: -1 dBm"]
_1_DBM = 7 , # [doc = "8: -2 dBm"]
_2_DBM = 8 , # [doc = "9: -3 dBm"]
_3_DBM = 9 , # [doc = "10: -4 dBm"]
_4_DBM = 10 , # [doc = "11: -5 dBm"]
_5_DBM = 11 , # [doc = "12: -7 dBm"]
_7_DBM = 12 , # [doc = "13: -9 dBm"]
_9_DBM = 13 , # [doc = "14: -12 dBm"]
_12_DBM = 14 , # [doc = "15: -17 dBm"]
_17_DBM = 15 , } impl From < TX_PWR_A > for u8 { # [inline (always)]
fn from (variant : TX_PWR_A) -> Self { variant as _ } } impl TX_PWR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TX_PWR_A { match self . bits { 0 => TX_PWR_A :: _3_0_DBM , 1 => TX_PWR_A :: _2_8_DBM , 2 => TX_PWR_A :: _2_3_DBM , 3 => TX_PWR_A :: _1_8_DBM , 4 => TX_PWR_A :: _1_3_DBM , 5 => TX_PWR_A :: _0_7_DBM , 6 => TX_PWR_A :: _0_0_DBM , 7 => TX_PWR_A :: _1_DBM , 8 => TX_PWR_A :: _2_DBM , 9 => TX_PWR_A :: _3_DBM , 10 => TX_PWR_A :: _4_DBM , 11 => TX_PWR_A :: _5_DBM , 12 => TX_PWR_A :: _7_DBM , 13 => TX_PWR_A :: _9_DBM , 14 => TX_PWR_A :: _12_DBM , 15 => TX_PWR_A :: _17_DBM , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_3_0_DBM`"]
# [inline (always)]
pub fn is_3_0_dbm (& self) -> bool { * self == TX_PWR_A :: _3_0_DBM } # [doc = "Checks if the value of the field is `_2_8_DBM`"]
# [inline (always)]
pub fn is_2_8_dbm (& self) -> bool { * self == TX_PWR_A :: _2_8_DBM } # [doc = "Checks if the value of the field is `_2_3_DBM`"]
# [inline (always)]
pub fn is_2_3_dbm (& self) -> bool { * self == TX_PWR_A :: _2_3_DBM } # [doc = "Checks if the value of the field is `_1_8_DBM`"]
# [inline (always)]
pub fn is_1_8_dbm (& self) -> bool { * self == TX_PWR_A :: _1_8_DBM } # [doc = "Checks if the value of the field is `_1_3_DBM`"]
# [inline (always)]
pub fn is_1_3_dbm (& self) -> bool { * self == TX_PWR_A :: _1_3_DBM } # [doc = "Checks if the value of the field is `_0_7_DBM`"]
# [inline (always)]
pub fn is_0_7_dbm (& self) -> bool { * self == TX_PWR_A :: _0_7_DBM } # [doc = "Checks if the value of the field is `_0_0_DBM`"]
# [inline (always)]
pub fn is_0_0_dbm (& self) -> bool { * self == TX_PWR_A :: _0_0_DBM } # [doc = "Checks if the value of the field is `_1_DBM`"]
# [inline (always)]
pub fn is_1_dbm (& self) -> bool { * self == TX_PWR_A :: _1_DBM } # [doc = "Checks if the value of the field is `_2_DBM`"]
# [inline (always)]
pub fn is_2_dbm (& self) -> bool { * self == TX_PWR_A :: _2_DBM } # [doc = "Checks if the value of the field is `_3_DBM`"]
# [inline (always)]
pub fn is_3_dbm (& self) -> bool { * self == TX_PWR_A :: _3_DBM } # [doc = "Checks if the value of the field is `_4_DBM`"]
# [inline (always)]
pub fn is_4_dbm (& self) -> bool { * self == TX_PWR_A :: _4_DBM } # [doc = "Checks if the value of the field is `_5_DBM`"]
# [inline (always)]
pub fn is_5_dbm (& self) -> bool { * self == TX_PWR_A :: _5_DBM } # [doc = "Checks if the value of the field is `_7_DBM`"]
# [inline (always)]
pub fn is_7_dbm (& self) -> bool { * self == TX_PWR_A :: _7_DBM } # [doc = "Checks if the value of the field is `_9_DBM`"]
# [inline (always)]
pub fn is_9_dbm (& self) -> bool { * self == TX_PWR_A :: _9_DBM } # [doc = "Checks if the value of the field is `_12_DBM`"]
# [inline (always)]
pub fn is_12_dbm (& self) -> bool { * self == TX_PWR_A :: _12_DBM } # [doc = "Checks if the value of the field is `_17_DBM`"]
# [inline (always)]
pub fn is_17_dbm (& self) -> bool { * self == TX_PWR_A :: _17_DBM } } # [doc = "Field `TX_PWR` writer - Transmit Power Setting"]
pub type TX_PWR_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PHY_TX_PWR_SPEC , u8 , TX_PWR_A , 4 , O > ; impl < 'a , const O : u8 > TX_PWR_W < 'a , O > { # [doc = "3.0 dBm"]
# [inline (always)]
pub fn _3_0_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _3_0_DBM) } # [doc = "2.8 dBm"]
# [inline (always)]
pub fn _2_8_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _2_8_DBM) } # [doc = "2.3 dBm"]
# [inline (always)]
pub fn _2_3_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _2_3_DBM) } # [doc = "1.8 dBm"]
# [inline (always)]
pub fn _1_8_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _1_8_DBM) } # [doc = "1.3 dBm"]
# [inline (always)]
pub fn _1_3_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _1_3_DBM) } # [doc = "0.7 dBm"]
# [inline (always)]
pub fn _0_7_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _0_7_DBM) } # [doc = "0.0 dBm"]
# [inline (always)]
pub fn _0_0_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _0_0_DBM) } # [doc = "-1 dBm"]
# [inline (always)]
pub fn _1_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _1_DBM) } # [doc = "-2 dBm"]
# [inline (always)]
pub fn _2_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _2_DBM) } # [doc = "-3 dBm"]
# [inline (always)]
pub fn _3_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _3_DBM) } # [doc = "-4 dBm"]
# [inline (always)]
pub fn _4_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _4_DBM) } # [doc = "-5 dBm"]
# [inline (always)]
pub fn _5_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _5_DBM) } # [doc = "-7 dBm"]
# [inline (always)]
pub fn _7_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _7_DBM) } # [doc = "-9 dBm"]
# [inline (always)]
pub fn _9_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _9_DBM) } # [doc = "-12 dBm"]
# [inline (always)]
pub fn _12_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _12_DBM) } # [doc = "-17 dBm"]
# [inline (always)]
pub fn _17_dbm (self) -> & 'a mut W { self . variant (TX_PWR_A :: _17_DBM) } } # [doc = "Field `PA_LT` reader - Power Amplifier Lead Time"]
pub type PA_LT_R = crate :: FieldReader < u8 , PA_LT_A > ; # [doc = "Power Amplifier Lead Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PA_LT_A { # [doc = "0: 2 us"]
PA_LT_2US = 0 , # [doc = "1: 4 us"]
PA_LT_4US = 1 , # [doc = "2: 6 us"]
PA_LT_6US = 2 , # [doc = "3: 8 us"]
PA_LT_8US = 3 , } impl From < PA_LT_A > for u8 { # [inline (always)]
fn from (variant : PA_LT_A) -> Self { variant as _ } } impl PA_LT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PA_LT_A { match self . bits { 0 => PA_LT_A :: PA_LT_2US , 1 => PA_LT_A :: PA_LT_4US , 2 => PA_LT_A :: PA_LT_6US , 3 => PA_LT_A :: PA_LT_8US , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PA_LT_2US`"]
# [inline (always)]
pub fn is_pa_lt_2us (& self) -> bool { * self == PA_LT_A :: PA_LT_2US } # [doc = "Checks if the value of the field is `PA_LT_4US`"]
# [inline (always)]
pub fn is_pa_lt_4us (& self) -> bool { * self == PA_LT_A :: PA_LT_4US } # [doc = "Checks if the value of the field is `PA_LT_6US`"]
# [inline (always)]
pub fn is_pa_lt_6us (& self) -> bool { * self == PA_LT_A :: PA_LT_6US } # [doc = "Checks if the value of the field is `PA_LT_8US`"]
# [inline (always)]
pub fn is_pa_lt_8us (& self) -> bool { * self == PA_LT_A :: PA_LT_8US } } # [doc = "Field `PA_LT` writer - Power Amplifier Lead Time"]
pub type PA_LT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PHY_TX_PWR_SPEC , u8 , PA_LT_A , 2 , O > ; impl < 'a , const O : u8 > PA_LT_W < 'a , O > { # [doc = "2 us"]
# [inline (always)]
pub fn pa_lt_2us (self) -> & 'a mut W { self . variant (PA_LT_A :: PA_LT_2US) } # [doc = "4 us"]
# [inline (always)]
pub fn pa_lt_4us (self) -> & 'a mut W { self . variant (PA_LT_A :: PA_LT_4US) } # [doc = "6 us"]
# [inline (always)]
pub fn pa_lt_6us (self) -> & 'a mut W { self . variant (PA_LT_A :: PA_LT_6US) } # [doc = "8 us"]
# [inline (always)]
pub fn pa_lt_8us (self) -> & 'a mut W { self . variant (PA_LT_A :: PA_LT_8US) } } # [doc = "Field `PA_BUF_LT` reader - Power Amplifier Buffer Lead Time"]
pub type PA_BUF_LT_R = crate :: FieldReader < u8 , PA_BUF_LT_A > ; # [doc = "Power Amplifier Buffer Lead Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PA_BUF_LT_A { # [doc = "0: 0 us"]
PA_BUF_LT_0US = 0 , # [doc = "1: 2 us"]
PA_BUF_LT_2US = 1 , # [doc = "2: 4 us"]
PA_BUF_LT_4US = 2 , # [doc = "3: 6 us"]
PA_BUF_LT_6US = 3 , } impl From < PA_BUF_LT_A > for u8 { # [inline (always)]
fn from (variant : PA_BUF_LT_A) -> Self { variant as _ } } impl PA_BUF_LT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PA_BUF_LT_A { match self . bits { 0 => PA_BUF_LT_A :: PA_BUF_LT_0US , 1 => PA_BUF_LT_A :: PA_BUF_LT_2US , 2 => PA_BUF_LT_A :: PA_BUF_LT_4US , 3 => PA_BUF_LT_A :: PA_BUF_LT_6US , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PA_BUF_LT_0US`"]
# [inline (always)]
pub fn is_pa_buf_lt_0us (& self) -> bool { * self == PA_BUF_LT_A :: PA_BUF_LT_0US } # [doc = "Checks if the value of the field is `PA_BUF_LT_2US`"]
# [inline (always)]
pub fn is_pa_buf_lt_2us (& self) -> bool { * self == PA_BUF_LT_A :: PA_BUF_LT_2US } # [doc = "Checks if the value of the field is `PA_BUF_LT_4US`"]
# [inline (always)]
pub fn is_pa_buf_lt_4us (& self) -> bool { * self == PA_BUF_LT_A :: PA_BUF_LT_4US } # [doc = "Checks if the value of the field is `PA_BUF_LT_6US`"]
# [inline (always)]
pub fn is_pa_buf_lt_6us (& self) -> bool { * self == PA_BUF_LT_A :: PA_BUF_LT_6US } } # [doc = "Field `PA_BUF_LT` writer - Power Amplifier Buffer Lead Time"]
pub type PA_BUF_LT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PHY_TX_PWR_SPEC , u8 , PA_BUF_LT_A , 2 , O > ; impl < 'a , const O : u8 > PA_BUF_LT_W < 'a , O > { # [doc = "0 us"]
# [inline (always)]
pub fn pa_buf_lt_0us (self) -> & 'a mut W { self . variant (PA_BUF_LT_A :: PA_BUF_LT_0US) } # [doc = "2 us"]
# [inline (always)]
pub fn pa_buf_lt_2us (self) -> & 'a mut W { self . variant (PA_BUF_LT_A :: PA_BUF_LT_2US) } # [doc = "4 us"]
# [inline (always)]
pub fn pa_buf_lt_4us (self) -> & 'a mut W { self . variant (PA_BUF_LT_A :: PA_BUF_LT_4US) } # [doc = "6 us"]
# [inline (always)]
pub fn pa_buf_lt_6us (self) -> & 'a mut W { self . variant (PA_BUF_LT_A :: PA_BUF_LT_6US) } } impl R { # [doc = "Bits 0:3 - Transmit Power Setting"]
# [inline (always)]
pub fn tx_pwr (& self) -> TX_PWR_R { TX_PWR_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:5 - Power Amplifier Lead Time"]
# [inline (always)]
pub fn pa_lt (& self) -> PA_LT_R { PA_LT_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Power Amplifier Buffer Lead Time"]
# [inline (always)]
pub fn pa_buf_lt (& self) -> PA_BUF_LT_R { PA_BUF_LT_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:3 - Transmit Power Setting"]
# [inline (always)]
# [must_use]
pub fn tx_pwr (& mut self) -> TX_PWR_W < 0 > { TX_PWR_W :: new (self) } # [doc = "Bits 4:5 - Power Amplifier Lead Time"]
# [inline (always)]
# [must_use]
pub fn pa_lt (& mut self) -> PA_LT_W < 4 > { PA_LT_W :: new (self) } # [doc = "Bits 6:7 - Power Amplifier Buffer Lead Time"]
# [inline (always)]
# [must_use]
pub fn pa_buf_lt (& mut self) -> PA_BUF_LT_W < 6 > { PA_BUF_LT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Transmit Power Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [phy_tx_pwr](index.html) module"]
pub struct PHY_TX_PWR_SPEC ; impl crate :: RegisterSpec for PHY_TX_PWR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [phy_tx_pwr::R](R) reader structure"]
impl crate :: Readable for PHY_TX_PWR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [phy_tx_pwr::W](W) writer structure"]
impl crate :: Writable for PHY_TX_PWR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PHY_TX_PWR to value 0"]
impl crate :: Resettable for PHY_TX_PWR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PLL_CF (rw) register accessor: an alias for `Reg<PLL_CF_SPEC>`"]
pub type PLL_CF = crate :: Reg < pll_cf :: PLL_CF_SPEC > ; # [doc = "Transceiver Center Frequency Calibration Control Register"]
pub mod pll_cf { # [doc = "Register `PLL_CF` reader"]
pub struct R (crate :: R < PLL_CF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PLL_CF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PLL_CF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PLL_CF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PLL_CF` writer"]
pub struct W (crate :: W < PLL_CF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PLL_CF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PLL_CF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PLL_CF_SPEC >) -> Self { W (writer) } } # [doc = "Field `PLL_CF_START` reader - Start Center Frequency Calibration"]
pub type PLL_CF_START_R = crate :: BitReader < bool > ; # [doc = "Field `PLL_CF_START` writer - Start Center Frequency Calibration"]
pub type PLL_CF_START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PLL_CF_SPEC , bool , O > ; impl R { # [doc = "Bit 7 - Start Center Frequency Calibration"]
# [inline (always)]
pub fn pll_cf_start (& self) -> PLL_CF_START_R { PLL_CF_START_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 7 - Start Center Frequency Calibration"]
# [inline (always)]
# [must_use]
pub fn pll_cf_start (& mut self) -> PLL_CF_START_W < 7 > { PLL_CF_START_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Center Frequency Calibration Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pll_cf](index.html) module"]
pub struct PLL_CF_SPEC ; impl crate :: RegisterSpec for PLL_CF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pll_cf::R](R) reader structure"]
impl crate :: Readable for PLL_CF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pll_cf::W](W) writer structure"]
impl crate :: Writable for PLL_CF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PLL_CF to value 0"]
impl crate :: Resettable for PLL_CF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PLL_DCU (rw) register accessor: an alias for `Reg<PLL_DCU_SPEC>`"]
pub type PLL_DCU = crate :: Reg < pll_dcu :: PLL_DCU_SPEC > ; # [doc = "Transceiver Delay Cell Calibration Control Register"]
pub mod pll_dcu { # [doc = "Register `PLL_DCU` reader"]
pub struct R (crate :: R < PLL_DCU_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PLL_DCU_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PLL_DCU_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PLL_DCU_SPEC >) -> Self { R (reader) } } # [doc = "Register `PLL_DCU` writer"]
pub struct W (crate :: W < PLL_DCU_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PLL_DCU_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PLL_DCU_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PLL_DCU_SPEC >) -> Self { W (writer) } } # [doc = "Field `PLL_DCU_START` reader - Start Delay Cell Calibration"]
pub type PLL_DCU_START_R = crate :: BitReader < bool > ; # [doc = "Field `PLL_DCU_START` writer - Start Delay Cell Calibration"]
pub type PLL_DCU_START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PLL_DCU_SPEC , bool , O > ; impl R { # [doc = "Bit 7 - Start Delay Cell Calibration"]
# [inline (always)]
pub fn pll_dcu_start (& self) -> PLL_DCU_START_R { PLL_DCU_START_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 7 - Start Delay Cell Calibration"]
# [inline (always)]
# [must_use]
pub fn pll_dcu_start (& mut self) -> PLL_DCU_START_W < 7 > { PLL_DCU_START_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Delay Cell Calibration Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pll_dcu](index.html) module"]
pub struct PLL_DCU_SPEC ; impl crate :: RegisterSpec for PLL_DCU_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pll_dcu::R](R) reader structure"]
impl crate :: Readable for PLL_DCU_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pll_dcu::W](W) writer structure"]
impl crate :: Writable for PLL_DCU_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PLL_DCU to value 0"]
impl crate :: Resettable for PLL_DCU_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RX_CTRL (rw) register accessor: an alias for `Reg<RX_CTRL_SPEC>`"]
pub type RX_CTRL = crate :: Reg < rx_ctrl :: RX_CTRL_SPEC > ; # [doc = "Transceiver Receive Control Register"]
pub mod rx_ctrl { # [doc = "Register `RX_CTRL` reader"]
pub struct R (crate :: R < RX_CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RX_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RX_CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RX_CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RX_CTRL` writer"]
pub struct W (crate :: W < RX_CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RX_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RX_CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RX_CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PDT_THRES` reader - Receiver Sensitivity Control"]
pub type PDT_THRES_R = crate :: FieldReader < u8 , PDT_THRES_A > ; # [doc = "Receiver Sensitivity Control\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PDT_THRES_A { # [doc = "3: Recommended correlator threshold for Antenna Diversity operation"]
PDT_THRES_ANT_DIV_ON = 3 , # [doc = "7: Reset value, to be used if Antenna Diversity algorithm is disabled"]
PDT_THRES_ANT_DIV_OFF = 7 , } impl From < PDT_THRES_A > for u8 { # [inline (always)]
fn from (variant : PDT_THRES_A) -> Self { variant as _ } } impl PDT_THRES_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PDT_THRES_A > { match self . bits { 3 => Some (PDT_THRES_A :: PDT_THRES_ANT_DIV_ON) , 7 => Some (PDT_THRES_A :: PDT_THRES_ANT_DIV_OFF) , _ => None , } } # [doc = "Checks if the value of the field is `PDT_THRES_ANT_DIV_ON`"]
# [inline (always)]
pub fn is_pdt_thres_ant_div_on (& self) -> bool { * self == PDT_THRES_A :: PDT_THRES_ANT_DIV_ON } # [doc = "Checks if the value of the field is `PDT_THRES_ANT_DIV_OFF`"]
# [inline (always)]
pub fn is_pdt_thres_ant_div_off (& self) -> bool { * self == PDT_THRES_A :: PDT_THRES_ANT_DIV_OFF } } # [doc = "Field `PDT_THRES` writer - Receiver Sensitivity Control"]
pub type PDT_THRES_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , RX_CTRL_SPEC , u8 , PDT_THRES_A , 4 , O > ; impl < 'a , const O : u8 > PDT_THRES_W < 'a , O > { # [doc = "Recommended correlator threshold for Antenna Diversity operation"]
# [inline (always)]
pub fn pdt_thres_ant_div_on (self) -> & 'a mut W { self . variant (PDT_THRES_A :: PDT_THRES_ANT_DIV_ON) } # [doc = "Reset value, to be used if Antenna Diversity algorithm is disabled"]
# [inline (always)]
pub fn pdt_thres_ant_div_off (self) -> & 'a mut W { self . variant (PDT_THRES_A :: PDT_THRES_ANT_DIV_OFF) } } impl R { # [doc = "Bits 0:3 - Receiver Sensitivity Control"]
# [inline (always)]
pub fn pdt_thres (& self) -> PDT_THRES_R { PDT_THRES_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Receiver Sensitivity Control"]
# [inline (always)]
# [must_use]
pub fn pdt_thres (& mut self) -> PDT_THRES_W < 0 > { PDT_THRES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Receive Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rx_ctrl](index.html) module"]
pub struct RX_CTRL_SPEC ; impl crate :: RegisterSpec for RX_CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rx_ctrl::R](R) reader structure"]
impl crate :: Readable for RX_CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rx_ctrl::W](W) writer structure"]
impl crate :: Writable for RX_CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RX_CTRL to value 0"]
impl crate :: Resettable for RX_CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RX_SYN (rw) register accessor: an alias for `Reg<RX_SYN_SPEC>`"]
pub type RX_SYN = crate :: Reg < rx_syn :: RX_SYN_SPEC > ; # [doc = "Transceiver Receiver Sensitivity Control Register"]
pub mod rx_syn { # [doc = "Register `RX_SYN` reader"]
pub struct R (crate :: R < RX_SYN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RX_SYN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RX_SYN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RX_SYN_SPEC >) -> Self { R (reader) } } # [doc = "Register `RX_SYN` writer"]
pub struct W (crate :: W < RX_SYN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RX_SYN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RX_SYN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RX_SYN_SPEC >) -> Self { W (writer) } } # [doc = "Field `RX_PDT_LEVEL` reader - Reduce Receiver Sensitivity"]
pub type RX_PDT_LEVEL_R = crate :: FieldReader < u8 , RX_PDT_LEVEL_A > ; # [doc = "Reduce Receiver Sensitivity\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RX_PDT_LEVEL_A { # [doc = "0: RX_THRES ≤ RSSI_BASE_VAL (Reset value); RSSI value not considered"]
RX_PDT_LEVEL_MIN = 0 , # [doc = "1: RX_THRES > RSSI_BASE_VAL + 0 · 3; RSSI > -90 dBm"]
VAL_0X1 = 1 , # [doc = "2: ..."]
VAL_0X2 = 2 , # [doc = "14: RX_THRES > RSSI_BASE_VAL + 13 · 3; RSSI > -51 dBm"]
VAL_0X_E = 14 , # [doc = "15: RX_THRES > RSSI_BASE_VAL + 14 · 3; RSSI > -48 dBm"]
RX_PDT_LEVEL_MAX = 15 , } impl From < RX_PDT_LEVEL_A > for u8 { # [inline (always)]
fn from (variant : RX_PDT_LEVEL_A) -> Self { variant as _ } } impl RX_PDT_LEVEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RX_PDT_LEVEL_A > { match self . bits { 0 => Some (RX_PDT_LEVEL_A :: RX_PDT_LEVEL_MIN) , 1 => Some (RX_PDT_LEVEL_A :: VAL_0X1) , 2 => Some (RX_PDT_LEVEL_A :: VAL_0X2) , 14 => Some (RX_PDT_LEVEL_A :: VAL_0X_E) , 15 => Some (RX_PDT_LEVEL_A :: RX_PDT_LEVEL_MAX) , _ => None , } } # [doc = "Checks if the value of the field is `RX_PDT_LEVEL_MIN`"]
# [inline (always)]
pub fn is_rx_pdt_level_min (& self) -> bool { * self == RX_PDT_LEVEL_A :: RX_PDT_LEVEL_MIN } # [doc = "Checks if the value of the field is `VAL_0X1`"]
# [inline (always)]
pub fn is_val_0x1 (& self) -> bool { * self == RX_PDT_LEVEL_A :: VAL_0X1 } # [doc = "Checks if the value of the field is `VAL_0X2`"]
# [inline (always)]
pub fn is_val_0x2 (& self) -> bool { * self == RX_PDT_LEVEL_A :: VAL_0X2 } # [doc = "Checks if the value of the field is `VAL_0X_E`"]
# [inline (always)]
pub fn is_val_0x_e (& self) -> bool { * self == RX_PDT_LEVEL_A :: VAL_0X_E } # [doc = "Checks if the value of the field is `RX_PDT_LEVEL_MAX`"]
# [inline (always)]
pub fn is_rx_pdt_level_max (& self) -> bool { * self == RX_PDT_LEVEL_A :: RX_PDT_LEVEL_MAX } } # [doc = "Field `RX_PDT_LEVEL` writer - Reduce Receiver Sensitivity"]
pub type RX_PDT_LEVEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , RX_SYN_SPEC , u8 , RX_PDT_LEVEL_A , 4 , O > ; impl < 'a , const O : u8 > RX_PDT_LEVEL_W < 'a , O > { # [doc = "RX_THRES ≤ RSSI_BASE_VAL (Reset value); RSSI value not considered"]
# [inline (always)]
pub fn rx_pdt_level_min (self) -> & 'a mut W { self . variant (RX_PDT_LEVEL_A :: RX_PDT_LEVEL_MIN) } # [doc = "RX_THRES > RSSI_BASE_VAL + 0 · 3; RSSI > -90 dBm"]
# [inline (always)]
pub fn val_0x1 (self) -> & 'a mut W { self . variant (RX_PDT_LEVEL_A :: VAL_0X1) } # [doc = "..."]
# [inline (always)]
pub fn val_0x2 (self) -> & 'a mut W { self . variant (RX_PDT_LEVEL_A :: VAL_0X2) } # [doc = "RX_THRES > RSSI_BASE_VAL + 13 · 3; RSSI > -51 dBm"]
# [inline (always)]
pub fn val_0x_e (self) -> & 'a mut W { self . variant (RX_PDT_LEVEL_A :: VAL_0X_E) } # [doc = "RX_THRES > RSSI_BASE_VAL + 14 · 3; RSSI > -48 dBm"]
# [inline (always)]
pub fn rx_pdt_level_max (self) -> & 'a mut W { self . variant (RX_PDT_LEVEL_A :: RX_PDT_LEVEL_MAX) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , RX_SYN_SPEC , u8 , u8 , 3 , O > ; # [doc = "Field `RX_PDT_DIS` reader - Prevent Frame Reception"]
pub type RX_PDT_DIS_R = crate :: BitReader < bool > ; # [doc = "Field `RX_PDT_DIS` writer - Prevent Frame Reception"]
pub type RX_PDT_DIS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RX_SYN_SPEC , bool , O > ; impl R { # [doc = "Bits 0:3 - Reduce Receiver Sensitivity"]
# [inline (always)]
pub fn rx_pdt_level (& self) -> RX_PDT_LEVEL_R { RX_PDT_LEVEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:6 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 4) & 7) } # [doc = "Bit 7 - Prevent Frame Reception"]
# [inline (always)]
pub fn rx_pdt_dis (& self) -> RX_PDT_DIS_R { RX_PDT_DIS_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Reduce Receiver Sensitivity"]
# [inline (always)]
# [must_use]
pub fn rx_pdt_level (& mut self) -> RX_PDT_LEVEL_W < 0 > { RX_PDT_LEVEL_W :: new (self) } # [doc = "Bits 4:6 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 4 > { RES_W :: new (self) } # [doc = "Bit 7 - Prevent Frame Reception"]
# [inline (always)]
# [must_use]
pub fn rx_pdt_dis (& mut self) -> RX_PDT_DIS_W < 7 > { RX_PDT_DIS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Receiver Sensitivity Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rx_syn](index.html) module"]
pub struct RX_SYN_SPEC ; impl crate :: RegisterSpec for RX_SYN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rx_syn::R](R) reader structure"]
impl crate :: Readable for RX_SYN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rx_syn::W](W) writer structure"]
impl crate :: Writable for RX_SYN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RX_SYN to value 0"]
impl crate :: Resettable for RX_SYN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SFD_VALUE (rw) register accessor: an alias for `Reg<SFD_VALUE_SPEC>`"]
pub type SFD_VALUE = crate :: Reg < sfd_value :: SFD_VALUE_SPEC > ; # [doc = "Start of Frame Delimiter Value Register"]
pub mod sfd_value { # [doc = "Register `SFD_VALUE` reader"]
pub struct R (crate :: R < SFD_VALUE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SFD_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SFD_VALUE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SFD_VALUE_SPEC >) -> Self { R (reader) } } # [doc = "Register `SFD_VALUE` writer"]
pub struct W (crate :: W < SFD_VALUE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SFD_VALUE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SFD_VALUE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SFD_VALUE_SPEC >) -> Self { W (writer) } } # [doc = "Field `SFD_VALUE` reader - Start of Frame Delimiter Value"]
pub type SFD_VALUE_R = crate :: FieldReader < u8 , SFD_VALUE_A > ; # [doc = "Start of Frame Delimiter Value\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SFD_VALUE_A { # [doc = "167: IEEE 802.15.4 compliant value of the SFD"]
IEEE_SFD = 167 , } impl From < SFD_VALUE_A > for u8 { # [inline (always)]
fn from (variant : SFD_VALUE_A) -> Self { variant as _ } } impl SFD_VALUE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SFD_VALUE_A > { match self . bits { 167 => Some (SFD_VALUE_A :: IEEE_SFD) , _ => None , } } # [doc = "Checks if the value of the field is `IEEE_SFD`"]
# [inline (always)]
pub fn is_ieee_sfd (& self) -> bool { * self == SFD_VALUE_A :: IEEE_SFD } } # [doc = "Field `SFD_VALUE` writer - Start of Frame Delimiter Value"]
pub type SFD_VALUE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SFD_VALUE_SPEC , u8 , SFD_VALUE_A , 8 , O > ; impl < 'a , const O : u8 > SFD_VALUE_W < 'a , O > { # [doc = "IEEE 802.15.4 compliant value of the SFD"]
# [inline (always)]
pub fn ieee_sfd (self) -> & 'a mut W { self . variant (SFD_VALUE_A :: IEEE_SFD) } } impl R { # [doc = "Bits 0:7 - Start of Frame Delimiter Value"]
# [inline (always)]
pub fn sfd_value (& self) -> SFD_VALUE_R { SFD_VALUE_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Start of Frame Delimiter Value"]
# [inline (always)]
# [must_use]
pub fn sfd_value (& mut self) -> SFD_VALUE_W < 0 > { SFD_VALUE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Start of Frame Delimiter Value Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfd_value](index.html) module"]
pub struct SFD_VALUE_SPEC ; impl crate :: RegisterSpec for SFD_VALUE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sfd_value::R](R) reader structure"]
impl crate :: Readable for SFD_VALUE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sfd_value::W](W) writer structure"]
impl crate :: Writable for SFD_VALUE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SFD_VALUE to value 0"]
impl crate :: Resettable for SFD_VALUE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SHORT_ADDR_0 (rw) register accessor: an alias for `Reg<SHORT_ADDR_0_SPEC>`"]
pub type SHORT_ADDR_0 = crate :: Reg < short_addr_0 :: SHORT_ADDR_0_SPEC > ; # [doc = "Transceiver MAC Short Address Register (Low Byte)"]
pub mod short_addr_0 { # [doc = "Register `SHORT_ADDR_0` reader"]
pub struct R (crate :: R < SHORT_ADDR_0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SHORT_ADDR_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SHORT_ADDR_0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SHORT_ADDR_0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SHORT_ADDR_0` writer"]
pub struct W (crate :: W < SHORT_ADDR_0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SHORT_ADDR_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SHORT_ADDR_0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SHORT_ADDR_0_SPEC >) -> Self { W (writer) } } # [doc = "Field `SHORT_ADDR_00` reader - MAC Short Address"]
pub type SHORT_ADDR_00_R = crate :: BitReader < bool > ; # [doc = "Field `SHORT_ADDR_00` writer - MAC Short Address"]
pub type SHORT_ADDR_00_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SHORT_ADDR_0_SPEC , bool , O > ; # [doc = "Field `SHORT_ADDR_01` reader - MAC Short Address"]
pub type SHORT_ADDR_01_R = crate :: BitReader < bool > ; # [doc = "Field `SHORT_ADDR_01` writer - MAC Short Address"]
pub type SHORT_ADDR_01_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SHORT_ADDR_0_SPEC , bool , O > ; # [doc = "Field `SHORT_ADDR_02` reader - MAC Short Address"]
pub type SHORT_ADDR_02_R = crate :: BitReader < bool > ; # [doc = "Field `SHORT_ADDR_02` writer - MAC Short Address"]
pub type SHORT_ADDR_02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SHORT_ADDR_0_SPEC , bool , O > ; # [doc = "Field `SHORT_ADDR_03` reader - MAC Short Address"]
pub type SHORT_ADDR_03_R = crate :: BitReader < bool > ; # [doc = "Field `SHORT_ADDR_03` writer - MAC Short Address"]
pub type SHORT_ADDR_03_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SHORT_ADDR_0_SPEC , bool , O > ; # [doc = "Field `SHORT_ADDR_04` reader - MAC Short Address"]
pub type SHORT_ADDR_04_R = crate :: BitReader < bool > ; # [doc = "Field `SHORT_ADDR_04` writer - MAC Short Address"]
pub type SHORT_ADDR_04_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SHORT_ADDR_0_SPEC , bool , O > ; # [doc = "Field `SHORT_ADDR_05` reader - MAC Short Address"]
pub type SHORT_ADDR_05_R = crate :: BitReader < bool > ; # [doc = "Field `SHORT_ADDR_05` writer - MAC Short Address"]
pub type SHORT_ADDR_05_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SHORT_ADDR_0_SPEC , bool , O > ; # [doc = "Field `SHORT_ADDR_06` reader - MAC Short Address"]
pub type SHORT_ADDR_06_R = crate :: BitReader < bool > ; # [doc = "Field `SHORT_ADDR_06` writer - MAC Short Address"]
pub type SHORT_ADDR_06_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SHORT_ADDR_0_SPEC , bool , O > ; # [doc = "Field `SHORT_ADDR_07` reader - MAC Short Address"]
pub type SHORT_ADDR_07_R = crate :: BitReader < bool > ; # [doc = "Field `SHORT_ADDR_07` writer - MAC Short Address"]
pub type SHORT_ADDR_07_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SHORT_ADDR_0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_00 (& self) -> SHORT_ADDR_00_R { SHORT_ADDR_00_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_01 (& self) -> SHORT_ADDR_01_R { SHORT_ADDR_01_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_02 (& self) -> SHORT_ADDR_02_R { SHORT_ADDR_02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_03 (& self) -> SHORT_ADDR_03_R { SHORT_ADDR_03_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_04 (& self) -> SHORT_ADDR_04_R { SHORT_ADDR_04_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_05 (& self) -> SHORT_ADDR_05_R { SHORT_ADDR_05_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_06 (& self) -> SHORT_ADDR_06_R { SHORT_ADDR_06_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_07 (& self) -> SHORT_ADDR_07_R { SHORT_ADDR_07_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_00 (& mut self) -> SHORT_ADDR_00_W < 0 > { SHORT_ADDR_00_W :: new (self) } # [doc = "Bit 1 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_01 (& mut self) -> SHORT_ADDR_01_W < 1 > { SHORT_ADDR_01_W :: new (self) } # [doc = "Bit 2 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_02 (& mut self) -> SHORT_ADDR_02_W < 2 > { SHORT_ADDR_02_W :: new (self) } # [doc = "Bit 3 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_03 (& mut self) -> SHORT_ADDR_03_W < 3 > { SHORT_ADDR_03_W :: new (self) } # [doc = "Bit 4 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_04 (& mut self) -> SHORT_ADDR_04_W < 4 > { SHORT_ADDR_04_W :: new (self) } # [doc = "Bit 5 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_05 (& mut self) -> SHORT_ADDR_05_W < 5 > { SHORT_ADDR_05_W :: new (self) } # [doc = "Bit 6 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_06 (& mut self) -> SHORT_ADDR_06_W < 6 > { SHORT_ADDR_06_W :: new (self) } # [doc = "Bit 7 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_07 (& mut self) -> SHORT_ADDR_07_W < 7 > { SHORT_ADDR_07_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver MAC Short Address Register (Low Byte)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [short_addr_0](index.html) module"]
pub struct SHORT_ADDR_0_SPEC ; impl crate :: RegisterSpec for SHORT_ADDR_0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [short_addr_0::R](R) reader structure"]
impl crate :: Readable for SHORT_ADDR_0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [short_addr_0::W](W) writer structure"]
impl crate :: Writable for SHORT_ADDR_0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SHORT_ADDR_0 to value 0"]
impl crate :: Resettable for SHORT_ADDR_0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SHORT_ADDR_1 (rw) register accessor: an alias for `Reg<SHORT_ADDR_1_SPEC>`"]
pub type SHORT_ADDR_1 = crate :: Reg < short_addr_1 :: SHORT_ADDR_1_SPEC > ; # [doc = "Transceiver MAC Short Address Register (High Byte)"]
pub mod short_addr_1 { # [doc = "Register `SHORT_ADDR_1` reader"]
pub struct R (crate :: R < SHORT_ADDR_1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SHORT_ADDR_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SHORT_ADDR_1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SHORT_ADDR_1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SHORT_ADDR_1` writer"]
pub struct W (crate :: W < SHORT_ADDR_1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SHORT_ADDR_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SHORT_ADDR_1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SHORT_ADDR_1_SPEC >) -> Self { W (writer) } } # [doc = "Field `SHORT_ADDR_` reader - MAC Short Address"]
pub type SHORT_ADDR__R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SHORT_ADDR_` writer - MAC Short Address"]
pub type SHORT_ADDR__W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SHORT_ADDR_1_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - MAC Short Address"]
# [inline (always)]
pub fn short_addr_ (& self) -> SHORT_ADDR__R { SHORT_ADDR__R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - MAC Short Address"]
# [inline (always)]
# [must_use]
pub fn short_addr_ (& mut self) -> SHORT_ADDR__W < 0 > { SHORT_ADDR__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver MAC Short Address Register (High Byte)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [short_addr_1](index.html) module"]
pub struct SHORT_ADDR_1_SPEC ; impl crate :: RegisterSpec for SHORT_ADDR_1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [short_addr_1::R](R) reader structure"]
impl crate :: Readable for SHORT_ADDR_1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [short_addr_1::W](W) writer structure"]
impl crate :: Writable for SHORT_ADDR_1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SHORT_ADDR_1 to value 0"]
impl crate :: Resettable for SHORT_ADDR_1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRXFBEND (rw) register accessor: an alias for `Reg<TRXFBEND_SPEC>`"]
pub type TRXFBEND = crate :: Reg < trxfbend :: TRXFBEND_SPEC > ; # [doc = "End of frame buffer"]
pub mod trxfbend { # [doc = "Register `TRXFBEND` reader"]
pub struct R (crate :: R < TRXFBEND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRXFBEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRXFBEND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRXFBEND_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRXFBEND` writer"]
pub struct W (crate :: W < TRXFBEND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRXFBEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRXFBEND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRXFBEND_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "End of frame buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trxfbend](index.html) module"]
pub struct TRXFBEND_SPEC ; impl crate :: RegisterSpec for TRXFBEND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [trxfbend::R](R) reader structure"]
impl crate :: Readable for TRXFBEND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [trxfbend::W](W) writer structure"]
impl crate :: Writable for TRXFBEND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRXFBEND to value 0"]
impl crate :: Resettable for TRXFBEND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRXFBST (rw) register accessor: an alias for `Reg<TRXFBST_SPEC>`"]
pub type TRXFBST = crate :: Reg < trxfbst :: TRXFBST_SPEC > ; # [doc = "Start of frame buffer"]
pub mod trxfbst { # [doc = "Register `TRXFBST` reader"]
pub struct R (crate :: R < TRXFBST_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRXFBST_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRXFBST_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRXFBST_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRXFBST` writer"]
pub struct W (crate :: W < TRXFBST_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRXFBST_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRXFBST_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRXFBST_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Start of frame buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trxfbst](index.html) module"]
pub struct TRXFBST_SPEC ; impl crate :: RegisterSpec for TRXFBST_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [trxfbst::R](R) reader structure"]
impl crate :: Readable for TRXFBST_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [trxfbst::W](W) writer structure"]
impl crate :: Writable for TRXFBST_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRXFBST to value 0"]
impl crate :: Resettable for TRXFBST_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRX_CTRL_0 (rw) register accessor: an alias for `Reg<TRX_CTRL_0_SPEC>`"]
pub type TRX_CTRL_0 = crate :: Reg < trx_ctrl_0 :: TRX_CTRL_0_SPEC > ; # [doc = "Reserved"]
pub mod trx_ctrl_0 { # [doc = "Register `TRX_CTRL_0` reader"]
pub struct R (crate :: R < TRX_CTRL_0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRX_CTRL_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRX_CTRL_0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRX_CTRL_0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRX_CTRL_0` writer"]
pub struct W (crate :: W < TRX_CTRL_0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRX_CTRL_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRX_CTRL_0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRX_CTRL_0_SPEC >) -> Self { W (writer) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TRX_CTRL_0_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 0 > { RES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Reserved\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trx_ctrl_0](index.html) module"]
pub struct TRX_CTRL_0_SPEC ; impl crate :: RegisterSpec for TRX_CTRL_0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [trx_ctrl_0::R](R) reader structure"]
impl crate :: Readable for TRX_CTRL_0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [trx_ctrl_0::W](W) writer structure"]
impl crate :: Writable for TRX_CTRL_0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRX_CTRL_0 to value 0"]
impl crate :: Resettable for TRX_CTRL_0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRX_CTRL_1 (rw) register accessor: an alias for `Reg<TRX_CTRL_1_SPEC>`"]
pub type TRX_CTRL_1 = crate :: Reg < trx_ctrl_1 :: TRX_CTRL_1_SPEC > ; # [doc = "Transceiver Control Register 1"]
pub mod trx_ctrl_1 { # [doc = "Register `TRX_CTRL_1` reader"]
pub struct R (crate :: R < TRX_CTRL_1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRX_CTRL_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRX_CTRL_1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRX_CTRL_1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRX_CTRL_1` writer"]
pub struct W (crate :: W < TRX_CTRL_1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRX_CTRL_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRX_CTRL_1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRX_CTRL_1_SPEC >) -> Self { W (writer) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TRX_CTRL_1_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `TX_AUTO_CRC_ON` reader - Enable Automatic CRC Calculation"]
pub type TX_AUTO_CRC_ON_R = crate :: BitReader < bool > ; # [doc = "Field `TX_AUTO_CRC_ON` writer - Enable Automatic CRC Calculation"]
pub type TX_AUTO_CRC_ON_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRX_CTRL_1_SPEC , bool , O > ; # [doc = "Field `IRQ_2_EXT_EN` reader - Connect Frame Start IRQ to TC1"]
pub type IRQ_2_EXT_EN_R = crate :: BitReader < bool > ; # [doc = "Field `IRQ_2_EXT_EN` writer - Connect Frame Start IRQ to TC1"]
pub type IRQ_2_EXT_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRX_CTRL_1_SPEC , bool , O > ; # [doc = "Field `PA_EXT_EN` reader - External PA support enable"]
pub type PA_EXT_EN_R = crate :: BitReader < bool > ; # [doc = "Field `PA_EXT_EN` writer - External PA support enable"]
pub type PA_EXT_EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRX_CTRL_1_SPEC , bool , O > ; impl R { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (self . bits & 0x1f) } # [doc = "Bit 5 - Enable Automatic CRC Calculation"]
# [inline (always)]
pub fn tx_auto_crc_on (& self) -> TX_AUTO_CRC_ON_R { TX_AUTO_CRC_ON_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Connect Frame Start IRQ to TC1"]
# [inline (always)]
pub fn irq_2_ext_en (& self) -> IRQ_2_EXT_EN_R { IRQ_2_EXT_EN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - External PA support enable"]
# [inline (always)]
pub fn pa_ext_en (& self) -> PA_EXT_EN_R { PA_EXT_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 0 > { RES_W :: new (self) } # [doc = "Bit 5 - Enable Automatic CRC Calculation"]
# [inline (always)]
# [must_use]
pub fn tx_auto_crc_on (& mut self) -> TX_AUTO_CRC_ON_W < 5 > { TX_AUTO_CRC_ON_W :: new (self) } # [doc = "Bit 6 - Connect Frame Start IRQ to TC1"]
# [inline (always)]
# [must_use]
pub fn irq_2_ext_en (& mut self) -> IRQ_2_EXT_EN_W < 6 > { IRQ_2_EXT_EN_W :: new (self) } # [doc = "Bit 7 - External PA support enable"]
# [inline (always)]
# [must_use]
pub fn pa_ext_en (& mut self) -> PA_EXT_EN_W < 7 > { PA_EXT_EN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trx_ctrl_1](index.html) module"]
pub struct TRX_CTRL_1_SPEC ; impl crate :: RegisterSpec for TRX_CTRL_1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [trx_ctrl_1::R](R) reader structure"]
impl crate :: Readable for TRX_CTRL_1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [trx_ctrl_1::W](W) writer structure"]
impl crate :: Writable for TRX_CTRL_1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRX_CTRL_1 to value 0"]
impl crate :: Resettable for TRX_CTRL_1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRX_CTRL_2 (rw) register accessor: an alias for `Reg<TRX_CTRL_2_SPEC>`"]
pub type TRX_CTRL_2 = crate :: Reg < trx_ctrl_2 :: TRX_CTRL_2_SPEC > ; # [doc = "Transceiver Control Register 2"]
pub mod trx_ctrl_2 { # [doc = "Register `TRX_CTRL_2` reader"]
pub struct R (crate :: R < TRX_CTRL_2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRX_CTRL_2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRX_CTRL_2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRX_CTRL_2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRX_CTRL_2` writer"]
pub struct W (crate :: W < TRX_CTRL_2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRX_CTRL_2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRX_CTRL_2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRX_CTRL_2_SPEC >) -> Self { W (writer) } } # [doc = "Field `OQPSK_DATA_RATE` reader - Data Rate Selection"]
pub type OQPSK_DATA_RATE_R = crate :: FieldReader < u8 , OQPSK_DATA_RATE_A > ; # [doc = "Data Rate Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OQPSK_DATA_RATE_A { # [doc = "0: 250 kb/s (IEEE 802.15.4 compliant)"]
RATE_250KB = 0 , # [doc = "1: 500 kb/s"]
RATE_500KB = 1 , # [doc = "2: 1000 kb/s"]
RATE_1000KB = 2 , # [doc = "3: 2000 kb/s"]
RATE_2000KB = 3 , } impl From < OQPSK_DATA_RATE_A > for u8 { # [inline (always)]
fn from (variant : OQPSK_DATA_RATE_A) -> Self { variant as _ } } impl OQPSK_DATA_RATE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OQPSK_DATA_RATE_A { match self . bits { 0 => OQPSK_DATA_RATE_A :: RATE_250KB , 1 => OQPSK_DATA_RATE_A :: RATE_500KB , 2 => OQPSK_DATA_RATE_A :: RATE_1000KB , 3 => OQPSK_DATA_RATE_A :: RATE_2000KB , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RATE_250KB`"]
# [inline (always)]
pub fn is_rate_250kb (& self) -> bool { * self == OQPSK_DATA_RATE_A :: RATE_250KB } # [doc = "Checks if the value of the field is `RATE_500KB`"]
# [inline (always)]
pub fn is_rate_500kb (& self) -> bool { * self == OQPSK_DATA_RATE_A :: RATE_500KB } # [doc = "Checks if the value of the field is `RATE_1000KB`"]
# [inline (always)]
pub fn is_rate_1000kb (& self) -> bool { * self == OQPSK_DATA_RATE_A :: RATE_1000KB } # [doc = "Checks if the value of the field is `RATE_2000KB`"]
# [inline (always)]
pub fn is_rate_2000kb (& self) -> bool { * self == OQPSK_DATA_RATE_A :: RATE_2000KB } } # [doc = "Field `OQPSK_DATA_RATE` writer - Data Rate Selection"]
pub type OQPSK_DATA_RATE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TRX_CTRL_2_SPEC , u8 , OQPSK_DATA_RATE_A , 2 , O > ; impl < 'a , const O : u8 > OQPSK_DATA_RATE_W < 'a , O > { # [doc = "250 kb/s (IEEE 802.15.4 compliant)"]
# [inline (always)]
pub fn rate_250kb (self) -> & 'a mut W { self . variant (OQPSK_DATA_RATE_A :: RATE_250KB) } # [doc = "500 kb/s"]
# [inline (always)]
pub fn rate_500kb (self) -> & 'a mut W { self . variant (OQPSK_DATA_RATE_A :: RATE_500KB) } # [doc = "1000 kb/s"]
# [inline (always)]
pub fn rate_1000kb (self) -> & 'a mut W { self . variant (OQPSK_DATA_RATE_A :: RATE_1000KB) } # [doc = "2000 kb/s"]
# [inline (always)]
pub fn rate_2000kb (self) -> & 'a mut W { self . variant (OQPSK_DATA_RATE_A :: RATE_2000KB) } } # [doc = "Field `Res` reader - Reserved"]
pub type RES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `Res` writer - Reserved"]
pub type RES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TRX_CTRL_2_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `RX_SAFE_MODE` reader - RX Safe Mode"]
pub type RX_SAFE_MODE_R = crate :: BitReader < bool > ; # [doc = "Field `RX_SAFE_MODE` writer - RX Safe Mode"]
pub type RX_SAFE_MODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRX_CTRL_2_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Data Rate Selection"]
# [inline (always)]
pub fn oqpsk_data_rate (& self) -> OQPSK_DATA_RATE_R { OQPSK_DATA_RATE_R :: new (self . bits & 3) } # [doc = "Bits 2:6 - Reserved"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits >> 2) & 0x1f) } # [doc = "Bit 7 - RX Safe Mode"]
# [inline (always)]
pub fn rx_safe_mode (& self) -> RX_SAFE_MODE_R { RX_SAFE_MODE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Data Rate Selection"]
# [inline (always)]
# [must_use]
pub fn oqpsk_data_rate (& mut self) -> OQPSK_DATA_RATE_W < 0 > { OQPSK_DATA_RATE_W :: new (self) } # [doc = "Bits 2:6 - Reserved"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 2 > { RES_W :: new (self) } # [doc = "Bit 7 - RX Safe Mode"]
# [inline (always)]
# [must_use]
pub fn rx_safe_mode (& mut self) -> RX_SAFE_MODE_W < 7 > { RX_SAFE_MODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Control Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trx_ctrl_2](index.html) module"]
pub struct TRX_CTRL_2_SPEC ; impl crate :: RegisterSpec for TRX_CTRL_2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [trx_ctrl_2::R](R) reader structure"]
impl crate :: Readable for TRX_CTRL_2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [trx_ctrl_2::W](W) writer structure"]
impl crate :: Writable for TRX_CTRL_2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRX_CTRL_2 to value 0"]
impl crate :: Resettable for TRX_CTRL_2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRX_STATE (rw) register accessor: an alias for `Reg<TRX_STATE_SPEC>`"]
pub type TRX_STATE = crate :: Reg < trx_state :: TRX_STATE_SPEC > ; # [doc = "Transceiver State Control Register"]
pub mod trx_state { # [doc = "Register `TRX_STATE` reader"]
pub struct R (crate :: R < TRX_STATE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRX_STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRX_STATE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRX_STATE_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRX_STATE` writer"]
pub struct W (crate :: W < TRX_STATE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRX_STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRX_STATE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRX_STATE_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRX_CMD` reader - State Control Command"]
pub type TRX_CMD_R = crate :: FieldReader < u8 , TRX_CMD_A > ; # [doc = "State Control Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TRX_CMD_A { # [doc = "0: NOP"]
CMD_NOP = 0 , # [doc = "2: TX_START"]
CMD_TX_START = 2 , # [doc = "3: FORCE_TRX_OFF"]
CMD_FORCE_TRX_OFF = 3 , # [doc = "4: FORCE_PLL_ON"]
CMD_FORCE_PLL_ON = 4 , # [doc = "6: RX_ON"]
CMD_RX_ON = 6 , # [doc = "8: TRX_OFF"]
CMD_TRX_OFF = 8 , # [doc = "9: PLL_ON (TX_ON)"]
CMD_PLL_ON = 9 , # [doc = "22: RX_AACK_ON"]
CMD_RX_AACK_ON = 22 , # [doc = "25: TX_ARET_ON"]
CMD_TX_ARET_ON = 25 , } impl From < TRX_CMD_A > for u8 { # [inline (always)]
fn from (variant : TRX_CMD_A) -> Self { variant as _ } } impl TRX_CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TRX_CMD_A > { match self . bits { 0 => Some (TRX_CMD_A :: CMD_NOP) , 2 => Some (TRX_CMD_A :: CMD_TX_START) , 3 => Some (TRX_CMD_A :: CMD_FORCE_TRX_OFF) , 4 => Some (TRX_CMD_A :: CMD_FORCE_PLL_ON) , 6 => Some (TRX_CMD_A :: CMD_RX_ON) , 8 => Some (TRX_CMD_A :: CMD_TRX_OFF) , 9 => Some (TRX_CMD_A :: CMD_PLL_ON) , 22 => Some (TRX_CMD_A :: CMD_RX_AACK_ON) , 25 => Some (TRX_CMD_A :: CMD_TX_ARET_ON) , _ => None , } } # [doc = "Checks if the value of the field is `CMD_NOP`"]
# [inline (always)]
pub fn is_cmd_nop (& self) -> bool { * self == TRX_CMD_A :: CMD_NOP } # [doc = "Checks if the value of the field is `CMD_TX_START`"]
# [inline (always)]
pub fn is_cmd_tx_start (& self) -> bool { * self == TRX_CMD_A :: CMD_TX_START } # [doc = "Checks if the value of the field is `CMD_FORCE_TRX_OFF`"]
# [inline (always)]
pub fn is_cmd_force_trx_off (& self) -> bool { * self == TRX_CMD_A :: CMD_FORCE_TRX_OFF } # [doc = "Checks if the value of the field is `CMD_FORCE_PLL_ON`"]
# [inline (always)]
pub fn is_cmd_force_pll_on (& self) -> bool { * self == TRX_CMD_A :: CMD_FORCE_PLL_ON } # [doc = "Checks if the value of the field is `CMD_RX_ON`"]
# [inline (always)]
pub fn is_cmd_rx_on (& self) -> bool { * self == TRX_CMD_A :: CMD_RX_ON } # [doc = "Checks if the value of the field is `CMD_TRX_OFF`"]
# [inline (always)]
pub fn is_cmd_trx_off (& self) -> bool { * self == TRX_CMD_A :: CMD_TRX_OFF } # [doc = "Checks if the value of the field is `CMD_PLL_ON`"]
# [inline (always)]
pub fn is_cmd_pll_on (& self) -> bool { * self == TRX_CMD_A :: CMD_PLL_ON } # [doc = "Checks if the value of the field is `CMD_RX_AACK_ON`"]
# [inline (always)]
pub fn is_cmd_rx_aack_on (& self) -> bool { * self == TRX_CMD_A :: CMD_RX_AACK_ON } # [doc = "Checks if the value of the field is `CMD_TX_ARET_ON`"]
# [inline (always)]
pub fn is_cmd_tx_aret_on (& self) -> bool { * self == TRX_CMD_A :: CMD_TX_ARET_ON } } # [doc = "Field `TRX_CMD` writer - State Control Command"]
pub type TRX_CMD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TRX_STATE_SPEC , u8 , TRX_CMD_A , 5 , O > ; impl < 'a , const O : u8 > TRX_CMD_W < 'a , O > { # [doc = "NOP"]
# [inline (always)]
pub fn cmd_nop (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_NOP) } # [doc = "TX_START"]
# [inline (always)]
pub fn cmd_tx_start (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_TX_START) } # [doc = "FORCE_TRX_OFF"]
# [inline (always)]
pub fn cmd_force_trx_off (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_FORCE_TRX_OFF) } # [doc = "FORCE_PLL_ON"]
# [inline (always)]
pub fn cmd_force_pll_on (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_FORCE_PLL_ON) } # [doc = "RX_ON"]
# [inline (always)]
pub fn cmd_rx_on (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_RX_ON) } # [doc = "TRX_OFF"]
# [inline (always)]
pub fn cmd_trx_off (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_TRX_OFF) } # [doc = "PLL_ON (TX_ON)"]
# [inline (always)]
pub fn cmd_pll_on (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_PLL_ON) } # [doc = "RX_AACK_ON"]
# [inline (always)]
pub fn cmd_rx_aack_on (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_RX_AACK_ON) } # [doc = "TX_ARET_ON"]
# [inline (always)]
pub fn cmd_tx_aret_on (self) -> & 'a mut W { self . variant (TRX_CMD_A :: CMD_TX_ARET_ON) } } # [doc = "Field `TRAC_STATUS` reader - Transaction Status"]
pub type TRAC_STATUS_R = crate :: FieldReader < u8 , TRAC_STATUS_A > ; # [doc = "Transaction Status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TRAC_STATUS_A { # [doc = "0: SUCCESS (RX_AACK, TX_ARET)"]
TRAC_SUCCESS = 0 , # [doc = "1: SUCCESS_DATA_PENDING (TX_ARET)"]
TRAC_SUCCESS_DATA_PENDING = 1 , # [doc = "2: SUCCESS_WAIT_FOR_ACK (RX_AACK)"]
TRAC_SUCCESS_WAIT_FOR_ACK = 2 , # [doc = "3: CHANNEL_ACCESS_FAILURE (TX_ARET)"]
TRAC_CHANNEL_ACCESS_FAILURE = 3 , # [doc = "5: NO_ACK (TX_ARET)"]
TRAC_NO_ACK = 5 , # [doc = "7: INVALID (RX_AACK, TX_ARET)"]
TRAC_INVALID = 7 , } impl From < TRAC_STATUS_A > for u8 { # [inline (always)]
fn from (variant : TRAC_STATUS_A) -> Self { variant as _ } } impl TRAC_STATUS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TRAC_STATUS_A > { match self . bits { 0 => Some (TRAC_STATUS_A :: TRAC_SUCCESS) , 1 => Some (TRAC_STATUS_A :: TRAC_SUCCESS_DATA_PENDING) , 2 => Some (TRAC_STATUS_A :: TRAC_SUCCESS_WAIT_FOR_ACK) , 3 => Some (TRAC_STATUS_A :: TRAC_CHANNEL_ACCESS_FAILURE) , 5 => Some (TRAC_STATUS_A :: TRAC_NO_ACK) , 7 => Some (TRAC_STATUS_A :: TRAC_INVALID) , _ => None , } } # [doc = "Checks if the value of the field is `TRAC_SUCCESS`"]
# [inline (always)]
pub fn is_trac_success (& self) -> bool { * self == TRAC_STATUS_A :: TRAC_SUCCESS } # [doc = "Checks if the value of the field is `TRAC_SUCCESS_DATA_PENDING`"]
# [inline (always)]
pub fn is_trac_success_data_pending (& self) -> bool { * self == TRAC_STATUS_A :: TRAC_SUCCESS_DATA_PENDING } # [doc = "Checks if the value of the field is `TRAC_SUCCESS_WAIT_FOR_ACK`"]
# [inline (always)]
pub fn is_trac_success_wait_for_ack (& self) -> bool { * self == TRAC_STATUS_A :: TRAC_SUCCESS_WAIT_FOR_ACK } # [doc = "Checks if the value of the field is `TRAC_CHANNEL_ACCESS_FAILURE`"]
# [inline (always)]
pub fn is_trac_channel_access_failure (& self) -> bool { * self == TRAC_STATUS_A :: TRAC_CHANNEL_ACCESS_FAILURE } # [doc = "Checks if the value of the field is `TRAC_NO_ACK`"]
# [inline (always)]
pub fn is_trac_no_ack (& self) -> bool { * self == TRAC_STATUS_A :: TRAC_NO_ACK } # [doc = "Checks if the value of the field is `TRAC_INVALID`"]
# [inline (always)]
pub fn is_trac_invalid (& self) -> bool { * self == TRAC_STATUS_A :: TRAC_INVALID } } # [doc = "Field `TRAC_STATUS` writer - Transaction Status"]
pub type TRAC_STATUS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TRX_STATE_SPEC , u8 , TRAC_STATUS_A , 3 , O > ; impl < 'a , const O : u8 > TRAC_STATUS_W < 'a , O > { # [doc = "SUCCESS (RX_AACK, TX_ARET)"]
# [inline (always)]
pub fn trac_success (self) -> & 'a mut W { self . variant (TRAC_STATUS_A :: TRAC_SUCCESS) } # [doc = "SUCCESS_DATA_PENDING (TX_ARET)"]
# [inline (always)]
pub fn trac_success_data_pending (self) -> & 'a mut W { self . variant (TRAC_STATUS_A :: TRAC_SUCCESS_DATA_PENDING) } # [doc = "SUCCESS_WAIT_FOR_ACK (RX_AACK)"]
# [inline (always)]
pub fn trac_success_wait_for_ack (self) -> & 'a mut W { self . variant (TRAC_STATUS_A :: TRAC_SUCCESS_WAIT_FOR_ACK) } # [doc = "CHANNEL_ACCESS_FAILURE (TX_ARET)"]
# [inline (always)]
pub fn trac_channel_access_failure (self) -> & 'a mut W { self . variant (TRAC_STATUS_A :: TRAC_CHANNEL_ACCESS_FAILURE) } # [doc = "NO_ACK (TX_ARET)"]
# [inline (always)]
pub fn trac_no_ack (self) -> & 'a mut W { self . variant (TRAC_STATUS_A :: TRAC_NO_ACK) } # [doc = "INVALID (RX_AACK, TX_ARET)"]
# [inline (always)]
pub fn trac_invalid (self) -> & 'a mut W { self . variant (TRAC_STATUS_A :: TRAC_INVALID) } } impl R { # [doc = "Bits 0:4 - State Control Command"]
# [inline (always)]
pub fn trx_cmd (& self) -> TRX_CMD_R { TRX_CMD_R :: new (self . bits & 0x1f) } # [doc = "Bits 5:7 - Transaction Status"]
# [inline (always)]
pub fn trac_status (& self) -> TRAC_STATUS_R { TRAC_STATUS_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:4 - State Control Command"]
# [inline (always)]
# [must_use]
pub fn trx_cmd (& mut self) -> TRX_CMD_W < 0 > { TRX_CMD_W :: new (self) } # [doc = "Bits 5:7 - Transaction Status"]
# [inline (always)]
# [must_use]
pub fn trac_status (& mut self) -> TRAC_STATUS_W < 5 > { TRAC_STATUS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver State Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trx_state](index.html) module"]
pub struct TRX_STATE_SPEC ; impl crate :: RegisterSpec for TRX_STATE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [trx_state::R](R) reader structure"]
impl crate :: Readable for TRX_STATE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [trx_state::W](W) writer structure"]
impl crate :: Writable for TRX_STATE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRX_STATE to value 0"]
impl crate :: Resettable for TRX_STATE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRX_STATUS (rw) register accessor: an alias for `Reg<TRX_STATUS_SPEC>`"]
pub type TRX_STATUS = crate :: Reg < trx_status :: TRX_STATUS_SPEC > ; # [doc = "Transceiver Status Register"]
pub mod trx_status { # [doc = "Register `TRX_STATUS` reader"]
pub struct R (crate :: R < TRX_STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRX_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRX_STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRX_STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRX_STATUS` writer"]
pub struct W (crate :: W < TRX_STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRX_STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRX_STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRX_STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRX_STATUS` reader - Transceiver Main Status"]
pub type TRX_STATUS_R = crate :: FieldReader < u8 , TRX_STATUS_A > ; # [doc = "Transceiver Main Status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TRX_STATUS_A { # [doc = "0: P_ON"]
P_ON = 0 , # [doc = "1: BUSY_RX"]
BUSY_RX = 1 , # [doc = "2: BUSY_TX"]
BUSY_TX = 2 , # [doc = "6: RX_ON"]
RX_ON = 6 , # [doc = "8: TRX_OFF"]
TRX_OFF = 8 , # [doc = "9: PLL_ON"]
PLL_ON = 9 , # [doc = "15: SLEEP"]
SLEEP = 15 , # [doc = "17: BUSY_RX_AACK"]
BUSY_RX_AACK = 17 , # [doc = "18: BUSY_TX_ARET"]
BUSY_TX_ARET = 18 , # [doc = "22: RX_AACK_ON"]
RX_AACK_ON = 22 , # [doc = "25: TX_ARET_ON"]
TX_ARET_ON = 25 , # [doc = "31: STATE_TRANSITION_IN_PROGRESS"]
STATE_TRANSITION_IN_PROGRESS = 31 , } impl From < TRX_STATUS_A > for u8 { # [inline (always)]
fn from (variant : TRX_STATUS_A) -> Self { variant as _ } } impl TRX_STATUS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TRX_STATUS_A > { match self . bits { 0 => Some (TRX_STATUS_A :: P_ON) , 1 => Some (TRX_STATUS_A :: BUSY_RX) , 2 => Some (TRX_STATUS_A :: BUSY_TX) , 6 => Some (TRX_STATUS_A :: RX_ON) , 8 => Some (TRX_STATUS_A :: TRX_OFF) , 9 => Some (TRX_STATUS_A :: PLL_ON) , 15 => Some (TRX_STATUS_A :: SLEEP) , 17 => Some (TRX_STATUS_A :: BUSY_RX_AACK) , 18 => Some (TRX_STATUS_A :: BUSY_TX_ARET) , 22 => Some (TRX_STATUS_A :: RX_AACK_ON) , 25 => Some (TRX_STATUS_A :: TX_ARET_ON) , 31 => Some (TRX_STATUS_A :: STATE_TRANSITION_IN_PROGRESS) , _ => None , } } # [doc = "Checks if the value of the field is `P_ON`"]
# [inline (always)]
pub fn is_p_on (& self) -> bool { * self == TRX_STATUS_A :: P_ON } # [doc = "Checks if the value of the field is `BUSY_RX`"]
# [inline (always)]
pub fn is_busy_rx (& self) -> bool { * self == TRX_STATUS_A :: BUSY_RX } # [doc = "Checks if the value of the field is `BUSY_TX`"]
# [inline (always)]
pub fn is_busy_tx (& self) -> bool { * self == TRX_STATUS_A :: BUSY_TX } # [doc = "Checks if the value of the field is `RX_ON`"]
# [inline (always)]
pub fn is_rx_on (& self) -> bool { * self == TRX_STATUS_A :: RX_ON } # [doc = "Checks if the value of the field is `TRX_OFF`"]
# [inline (always)]
pub fn is_trx_off (& self) -> bool { * self == TRX_STATUS_A :: TRX_OFF } # [doc = "Checks if the value of the field is `PLL_ON`"]
# [inline (always)]
pub fn is_pll_on (& self) -> bool { * self == TRX_STATUS_A :: PLL_ON } # [doc = "Checks if the value of the field is `SLEEP`"]
# [inline (always)]
pub fn is_sleep (& self) -> bool { * self == TRX_STATUS_A :: SLEEP } # [doc = "Checks if the value of the field is `BUSY_RX_AACK`"]
# [inline (always)]
pub fn is_busy_rx_aack (& self) -> bool { * self == TRX_STATUS_A :: BUSY_RX_AACK } # [doc = "Checks if the value of the field is `BUSY_TX_ARET`"]
# [inline (always)]
pub fn is_busy_tx_aret (& self) -> bool { * self == TRX_STATUS_A :: BUSY_TX_ARET } # [doc = "Checks if the value of the field is `RX_AACK_ON`"]
# [inline (always)]
pub fn is_rx_aack_on (& self) -> bool { * self == TRX_STATUS_A :: RX_AACK_ON } # [doc = "Checks if the value of the field is `TX_ARET_ON`"]
# [inline (always)]
pub fn is_tx_aret_on (& self) -> bool { * self == TRX_STATUS_A :: TX_ARET_ON } # [doc = "Checks if the value of the field is `STATE_TRANSITION_IN_PROGRESS`"]
# [inline (always)]
pub fn is_state_transition_in_progress (& self) -> bool { * self == TRX_STATUS_A :: STATE_TRANSITION_IN_PROGRESS } } # [doc = "Field `TRX_STATUS` writer - Transceiver Main Status"]
pub type TRX_STATUS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TRX_STATUS_SPEC , u8 , TRX_STATUS_A , 5 , O > ; impl < 'a , const O : u8 > TRX_STATUS_W < 'a , O > { # [doc = "P_ON"]
# [inline (always)]
pub fn p_on (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: P_ON) } # [doc = "BUSY_RX"]
# [inline (always)]
pub fn busy_rx (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: BUSY_RX) } # [doc = "BUSY_TX"]
# [inline (always)]
pub fn busy_tx (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: BUSY_TX) } # [doc = "RX_ON"]
# [inline (always)]
pub fn rx_on (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: RX_ON) } # [doc = "TRX_OFF"]
# [inline (always)]
pub fn trx_off (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: TRX_OFF) } # [doc = "PLL_ON"]
# [inline (always)]
pub fn pll_on (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: PLL_ON) } # [doc = "SLEEP"]
# [inline (always)]
pub fn sleep (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: SLEEP) } # [doc = "BUSY_RX_AACK"]
# [inline (always)]
pub fn busy_rx_aack (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: BUSY_RX_AACK) } # [doc = "BUSY_TX_ARET"]
# [inline (always)]
pub fn busy_tx_aret (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: BUSY_TX_ARET) } # [doc = "RX_AACK_ON"]
# [inline (always)]
pub fn rx_aack_on (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: RX_AACK_ON) } # [doc = "TX_ARET_ON"]
# [inline (always)]
pub fn tx_aret_on (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: TX_ARET_ON) } # [doc = "STATE_TRANSITION_IN_PROGRESS"]
# [inline (always)]
pub fn state_transition_in_progress (self) -> & 'a mut W { self . variant (TRX_STATUS_A :: STATE_TRANSITION_IN_PROGRESS) } } # [doc = "Field `TST_STATUS` reader - Test mode status"]
pub type TST_STATUS_R = crate :: BitReader < TST_STATUS_A > ; # [doc = "Test mode status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TST_STATUS_A { # [doc = "0: Test mode is disabled."]
TST_DISABLED = 0 , # [doc = "1: Test mode is active."]
TST_ENABLED = 1 , } impl From < TST_STATUS_A > for bool { # [inline (always)]
fn from (variant : TST_STATUS_A) -> Self { variant as u8 != 0 } } impl TST_STATUS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TST_STATUS_A { match self . bits { false => TST_STATUS_A :: TST_DISABLED , true => TST_STATUS_A :: TST_ENABLED , } } # [doc = "Checks if the value of the field is `TST_DISABLED`"]
# [inline (always)]
pub fn is_tst_disabled (& self) -> bool { * self == TST_STATUS_A :: TST_DISABLED } # [doc = "Checks if the value of the field is `TST_ENABLED`"]
# [inline (always)]
pub fn is_tst_enabled (& self) -> bool { * self == TST_STATUS_A :: TST_ENABLED } } # [doc = "Field `TST_STATUS` writer - Test mode status"]
pub type TST_STATUS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRX_STATUS_SPEC , TST_STATUS_A , O > ; impl < 'a , const O : u8 > TST_STATUS_W < 'a , O > { # [doc = "Test mode is disabled."]
# [inline (always)]
pub fn tst_disabled (self) -> & 'a mut W { self . variant (TST_STATUS_A :: TST_DISABLED) } # [doc = "Test mode is active."]
# [inline (always)]
pub fn tst_enabled (self) -> & 'a mut W { self . variant (TST_STATUS_A :: TST_ENABLED) } } # [doc = "Field `CCA_STATUS` reader - CCA Status Result"]
pub type CCA_STATUS_R = crate :: BitReader < CCA_STATUS_A > ; # [doc = "CCA Status Result\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CCA_STATUS_A { # [doc = "0: Channel indicated as busy."]
CCA_BUSY = 0 , # [doc = "1: Channel indicated as idle."]
CCA_IDLE = 1 , } impl From < CCA_STATUS_A > for bool { # [inline (always)]
fn from (variant : CCA_STATUS_A) -> Self { variant as u8 != 0 } } impl CCA_STATUS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCA_STATUS_A { match self . bits { false => CCA_STATUS_A :: CCA_BUSY , true => CCA_STATUS_A :: CCA_IDLE , } } # [doc = "Checks if the value of the field is `CCA_BUSY`"]
# [inline (always)]
pub fn is_cca_busy (& self) -> bool { * self == CCA_STATUS_A :: CCA_BUSY } # [doc = "Checks if the value of the field is `CCA_IDLE`"]
# [inline (always)]
pub fn is_cca_idle (& self) -> bool { * self == CCA_STATUS_A :: CCA_IDLE } } # [doc = "Field `CCA_STATUS` writer - CCA Status Result"]
pub type CCA_STATUS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRX_STATUS_SPEC , CCA_STATUS_A , O > ; impl < 'a , const O : u8 > CCA_STATUS_W < 'a , O > { # [doc = "Channel indicated as busy."]
# [inline (always)]
pub fn cca_busy (self) -> & 'a mut W { self . variant (CCA_STATUS_A :: CCA_BUSY) } # [doc = "Channel indicated as idle."]
# [inline (always)]
pub fn cca_idle (self) -> & 'a mut W { self . variant (CCA_STATUS_A :: CCA_IDLE) } } # [doc = "Field `CCA_DONE` reader - CCA Algorithm Status"]
pub type CCA_DONE_R = crate :: BitReader < CCA_DONE_A > ; # [doc = "CCA Algorithm Status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CCA_DONE_A { # [doc = "0: CCA calculation not finished"]
CCA_NOT_FIN = 0 , # [doc = "1: CCA calculation finished"]
CCA_FIN = 1 , } impl From < CCA_DONE_A > for bool { # [inline (always)]
fn from (variant : CCA_DONE_A) -> Self { variant as u8 != 0 } } impl CCA_DONE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCA_DONE_A { match self . bits { false => CCA_DONE_A :: CCA_NOT_FIN , true => CCA_DONE_A :: CCA_FIN , } } # [doc = "Checks if the value of the field is `CCA_NOT_FIN`"]
# [inline (always)]
pub fn is_cca_not_fin (& self) -> bool { * self == CCA_DONE_A :: CCA_NOT_FIN } # [doc = "Checks if the value of the field is `CCA_FIN`"]
# [inline (always)]
pub fn is_cca_fin (& self) -> bool { * self == CCA_DONE_A :: CCA_FIN } } # [doc = "Field `CCA_DONE` writer - CCA Algorithm Status"]
pub type CCA_DONE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TRX_STATUS_SPEC , CCA_DONE_A , O > ; impl < 'a , const O : u8 > CCA_DONE_W < 'a , O > { # [doc = "CCA calculation not finished"]
# [inline (always)]
pub fn cca_not_fin (self) -> & 'a mut W { self . variant (CCA_DONE_A :: CCA_NOT_FIN) } # [doc = "CCA calculation finished"]
# [inline (always)]
pub fn cca_fin (self) -> & 'a mut W { self . variant (CCA_DONE_A :: CCA_FIN) } } impl R { # [doc = "Bits 0:4 - Transceiver Main Status"]
# [inline (always)]
pub fn trx_status (& self) -> TRX_STATUS_R { TRX_STATUS_R :: new (self . bits & 0x1f) } # [doc = "Bit 5 - Test mode status"]
# [inline (always)]
pub fn tst_status (& self) -> TST_STATUS_R { TST_STATUS_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - CCA Status Result"]
# [inline (always)]
pub fn cca_status (& self) -> CCA_STATUS_R { CCA_STATUS_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - CCA Algorithm Status"]
# [inline (always)]
pub fn cca_done (& self) -> CCA_DONE_R { CCA_DONE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Transceiver Main Status"]
# [inline (always)]
# [must_use]
pub fn trx_status (& mut self) -> TRX_STATUS_W < 0 > { TRX_STATUS_W :: new (self) } # [doc = "Bit 5 - Test mode status"]
# [inline (always)]
# [must_use]
pub fn tst_status (& mut self) -> TST_STATUS_W < 5 > { TST_STATUS_W :: new (self) } # [doc = "Bit 6 - CCA Status Result"]
# [inline (always)]
# [must_use]
pub fn cca_status (& mut self) -> CCA_STATUS_W < 6 > { CCA_STATUS_W :: new (self) } # [doc = "Bit 7 - CCA Algorithm Status"]
# [inline (always)]
# [must_use]
pub fn cca_done (& mut self) -> CCA_DONE_W < 7 > { CCA_DONE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [trx_status](index.html) module"]
pub struct TRX_STATUS_SPEC ; impl crate :: RegisterSpec for TRX_STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [trx_status::R](R) reader structure"]
impl crate :: Readable for TRX_STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [trx_status::W](W) writer structure"]
impl crate :: Writable for TRX_STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRX_STATUS to value 0"]
impl crate :: Resettable for TRX_STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TST_CTRL_DIGI (rw) register accessor: an alias for `Reg<TST_CTRL_DIGI_SPEC>`"]
pub type TST_CTRL_DIGI = crate :: Reg < tst_ctrl_digi :: TST_CTRL_DIGI_SPEC > ; # [doc = "Transceiver Digital Test Control Register"]
pub mod tst_ctrl_digi { # [doc = "Register `TST_CTRL_DIGI` reader"]
pub struct R (crate :: R < TST_CTRL_DIGI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TST_CTRL_DIGI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TST_CTRL_DIGI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TST_CTRL_DIGI_SPEC >) -> Self { R (reader) } } # [doc = "Register `TST_CTRL_DIGI` writer"]
pub struct W (crate :: W < TST_CTRL_DIGI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TST_CTRL_DIGI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TST_CTRL_DIGI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TST_CTRL_DIGI_SPEC >) -> Self { W (writer) } } # [doc = "Field `TST_CTRL_DIG` reader - Digital Test Controller Register"]
pub type TST_CTRL_DIG_R = crate :: FieldReader < u8 , TST_CTRL_DIG_A > ; # [doc = "Digital Test Controller Register\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TST_CTRL_DIG_A { # [doc = "0: NORMAL (no test is active)"]
NORMAL_NO_TEST_IS_ACTIVE = 0 , # [doc = "15: TST_CONT_TX (continuous transmit)"]
TST_CONT_TX_CONTINUOUS_TRANSMIT = 15 , } impl From < TST_CTRL_DIG_A > for u8 { # [inline (always)]
fn from (variant : TST_CTRL_DIG_A) -> Self { variant as _ } } impl TST_CTRL_DIG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TST_CTRL_DIG_A > { match self . bits { 0 => Some (TST_CTRL_DIG_A :: NORMAL_NO_TEST_IS_ACTIVE) , 15 => Some (TST_CTRL_DIG_A :: TST_CONT_TX_CONTINUOUS_TRANSMIT) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL_NO_TEST_IS_ACTIVE`"]
# [inline (always)]
pub fn is_normal_no_test_is_active (& self) -> bool { * self == TST_CTRL_DIG_A :: NORMAL_NO_TEST_IS_ACTIVE } # [doc = "Checks if the value of the field is `TST_CONT_TX_CONTINUOUS_TRANSMIT`"]
# [inline (always)]
pub fn is_tst_cont_tx_continuous_transmit (& self) -> bool { * self == TST_CTRL_DIG_A :: TST_CONT_TX_CONTINUOUS_TRANSMIT } } # [doc = "Field `TST_CTRL_DIG` writer - Digital Test Controller Register"]
pub type TST_CTRL_DIG_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TST_CTRL_DIGI_SPEC , u8 , TST_CTRL_DIG_A , 4 , O > ; impl < 'a , const O : u8 > TST_CTRL_DIG_W < 'a , O > { # [doc = "NORMAL (no test is active)"]
# [inline (always)]
pub fn normal_no_test_is_active (self) -> & 'a mut W { self . variant (TST_CTRL_DIG_A :: NORMAL_NO_TEST_IS_ACTIVE) } # [doc = "TST_CONT_TX (continuous transmit)"]
# [inline (always)]
pub fn tst_cont_tx_continuous_transmit (self) -> & 'a mut W { self . variant (TST_CTRL_DIG_A :: TST_CONT_TX_CONTINUOUS_TRANSMIT) } } impl R { # [doc = "Bits 0:3 - Digital Test Controller Register"]
# [inline (always)]
pub fn tst_ctrl_dig (& self) -> TST_CTRL_DIG_R { TST_CTRL_DIG_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Digital Test Controller Register"]
# [inline (always)]
# [must_use]
pub fn tst_ctrl_dig (& mut self) -> TST_CTRL_DIG_W < 0 > { TST_CTRL_DIG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Digital Test Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tst_ctrl_digi](index.html) module"]
pub struct TST_CTRL_DIGI_SPEC ; impl crate :: RegisterSpec for TST_CTRL_DIGI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tst_ctrl_digi::R](R) reader structure"]
impl crate :: Readable for TST_CTRL_DIGI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tst_ctrl_digi::W](W) writer structure"]
impl crate :: Writable for TST_CTRL_DIGI_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TST_CTRL_DIGI to value 0"]
impl crate :: Resettable for TST_CTRL_DIGI_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TST_RX_LENGTH (rw) register accessor: an alias for `Reg<TST_RX_LENGTH_SPEC>`"]
pub type TST_RX_LENGTH = crate :: Reg < tst_rx_length :: TST_RX_LENGTH_SPEC > ; # [doc = "Transceiver Received Frame Length Register"]
pub mod tst_rx_length { # [doc = "Register `TST_RX_LENGTH` reader"]
pub struct R (crate :: R < TST_RX_LENGTH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TST_RX_LENGTH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TST_RX_LENGTH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TST_RX_LENGTH_SPEC >) -> Self { R (reader) } } # [doc = "Register `TST_RX_LENGTH` writer"]
pub struct W (crate :: W < TST_RX_LENGTH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TST_RX_LENGTH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TST_RX_LENGTH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TST_RX_LENGTH_SPEC >) -> Self { W (writer) } } # [doc = "Field `RX_LENGTH` reader - Received Frame Length"]
pub type RX_LENGTH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RX_LENGTH` writer - Received Frame Length"]
pub type RX_LENGTH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TST_RX_LENGTH_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Received Frame Length"]
# [inline (always)]
pub fn rx_length (& self) -> RX_LENGTH_R { RX_LENGTH_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Received Frame Length"]
# [inline (always)]
# [must_use]
pub fn rx_length (& mut self) -> RX_LENGTH_W < 0 > { RX_LENGTH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transceiver Received Frame Length Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tst_rx_length](index.html) module"]
pub struct TST_RX_LENGTH_SPEC ; impl crate :: RegisterSpec for TST_RX_LENGTH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tst_rx_length::R](R) reader structure"]
impl crate :: Readable for TST_RX_LENGTH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tst_rx_length::W](W) writer structure"]
impl crate :: Writable for TST_RX_LENGTH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TST_RX_LENGTH to value 0"]
impl crate :: Resettable for TST_RX_LENGTH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VERSION_NUM (rw) register accessor: an alias for `Reg<VERSION_NUM_SPEC>`"]
pub type VERSION_NUM = crate :: Reg < version_num :: VERSION_NUM_SPEC > ; # [doc = "Device Identification Register (Version Number)"]
pub mod version_num { # [doc = "Register `VERSION_NUM` reader"]
pub struct R (crate :: R < VERSION_NUM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VERSION_NUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VERSION_NUM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VERSION_NUM_SPEC >) -> Self { R (reader) } } # [doc = "Register `VERSION_NUM` writer"]
pub struct W (crate :: W < VERSION_NUM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < VERSION_NUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < VERSION_NUM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < VERSION_NUM_SPEC >) -> Self { W (writer) } } # [doc = "Field `VERSION_NUM` reader - Version Number"]
pub type VERSION_NUM_R = crate :: FieldReader < u8 , VERSION_NUM_A > ; # [doc = "Version Number\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VERSION_NUM_A { # [doc = "2: Revision A"]
REV_A = 2 , # [doc = "3: Revision B"]
REV_B = 3 , } impl From < VERSION_NUM_A > for u8 { # [inline (always)]
fn from (variant : VERSION_NUM_A) -> Self { variant as _ } } impl VERSION_NUM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < VERSION_NUM_A > { match self . bits { 2 => Some (VERSION_NUM_A :: REV_A) , 3 => Some (VERSION_NUM_A :: REV_B) , _ => None , } } # [doc = "Checks if the value of the field is `REV_A`"]
# [inline (always)]
pub fn is_rev_a (& self) -> bool { * self == VERSION_NUM_A :: REV_A } # [doc = "Checks if the value of the field is `REV_B`"]
# [inline (always)]
pub fn is_rev_b (& self) -> bool { * self == VERSION_NUM_A :: REV_B } } # [doc = "Field `VERSION_NUM` writer - Version Number"]
pub type VERSION_NUM_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , VERSION_NUM_SPEC , u8 , VERSION_NUM_A , 8 , O > ; impl < 'a , const O : u8 > VERSION_NUM_W < 'a , O > { # [doc = "Revision A"]
# [inline (always)]
pub fn rev_a (self) -> & 'a mut W { self . variant (VERSION_NUM_A :: REV_A) } # [doc = "Revision B"]
# [inline (always)]
pub fn rev_b (self) -> & 'a mut W { self . variant (VERSION_NUM_A :: REV_B) } } impl R { # [doc = "Bits 0:7 - Version Number"]
# [inline (always)]
pub fn version_num (& self) -> VERSION_NUM_R { VERSION_NUM_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Version Number"]
# [inline (always)]
# [must_use]
pub fn version_num (& mut self) -> VERSION_NUM_W < 0 > { VERSION_NUM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Device Identification Register (Version Number)\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [version_num](index.html) module"]
pub struct VERSION_NUM_SPEC ; impl crate :: RegisterSpec for VERSION_NUM_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [version_num::R](R) reader structure"]
impl crate :: Readable for VERSION_NUM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [version_num::W](W) writer structure"]
impl crate :: Writable for VERSION_NUM_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VERSION_NUM to value 0"]
impl crate :: Resettable for VERSION_NUM_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VREG_CTRL (rw) register accessor: an alias for `Reg<VREG_CTRL_SPEC>`"]
pub type VREG_CTRL = crate :: Reg < vreg_ctrl :: VREG_CTRL_SPEC > ; # [doc = "Voltage Regulator Control and Status Register"]
pub mod vreg_ctrl { # [doc = "Register `VREG_CTRL` reader"]
pub struct R (crate :: R < VREG_CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VREG_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VREG_CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VREG_CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `VREG_CTRL` writer"]
pub struct W (crate :: W < VREG_CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < VREG_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < VREG_CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < VREG_CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DVDD_OK` reader - DVDD Supply Voltage Valid"]
pub type DVDD_OK_R = crate :: BitReader < DVDD_OK_A > ; # [doc = "DVDD Supply Voltage Valid\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DVDD_OK_A { # [doc = "0: Digital voltage regulator disabled or supply voltage not stable"]
DIGITAL_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE = 0 , # [doc = "1: Digital supply voltage has settled"]
DIGITAL_SUPPLY_VOLTAGE_HAS_SETTLED = 1 , } impl From < DVDD_OK_A > for bool { # [inline (always)]
fn from (variant : DVDD_OK_A) -> Self { variant as u8 != 0 } } impl DVDD_OK_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DVDD_OK_A { match self . bits { false => DVDD_OK_A :: DIGITAL_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE , true => DVDD_OK_A :: DIGITAL_SUPPLY_VOLTAGE_HAS_SETTLED , } } # [doc = "Checks if the value of the field is `DIGITAL_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE`"]
# [inline (always)]
pub fn is_digital_voltage_regulator_disabled_or_supply_voltage_not_stable (& self) -> bool { * self == DVDD_OK_A :: DIGITAL_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE } # [doc = "Checks if the value of the field is `DIGITAL_SUPPLY_VOLTAGE_HAS_SETTLED`"]
# [inline (always)]
pub fn is_digital_supply_voltage_has_settled (& self) -> bool { * self == DVDD_OK_A :: DIGITAL_SUPPLY_VOLTAGE_HAS_SETTLED } } # [doc = "Field `DVDD_OK` writer - DVDD Supply Voltage Valid"]
pub type DVDD_OK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , VREG_CTRL_SPEC , DVDD_OK_A , O > ; impl < 'a , const O : u8 > DVDD_OK_W < 'a , O > { # [doc = "Digital voltage regulator disabled or supply voltage not stable"]
# [inline (always)]
pub fn digital_voltage_regulator_disabled_or_supply_voltage_not_stable (self) -> & 'a mut W { self . variant (DVDD_OK_A :: DIGITAL_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE) } # [doc = "Digital supply voltage has settled"]
# [inline (always)]
pub fn digital_supply_voltage_has_settled (self) -> & 'a mut W { self . variant (DVDD_OK_A :: DIGITAL_SUPPLY_VOLTAGE_HAS_SETTLED) } } # [doc = "Field `DVREG_EXT` reader - Use External DVDD Regulator"]
pub type DVREG_EXT_R = crate :: BitReader < DVREG_EXT_A > ; # [doc = "Use External DVDD Regulator\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DVREG_EXT_A { # [doc = "0: Internal DVDD voltage regulator for the digital section is enabled."]
DVDD_INT = 0 , # [doc = "1: Internal DVDD voltage regulator is disabled; use external regulated 1.8V supply voltage for the digital section."]
DVDD_EXT = 1 , } impl From < DVREG_EXT_A > for bool { # [inline (always)]
fn from (variant : DVREG_EXT_A) -> Self { variant as u8 != 0 } } impl DVREG_EXT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DVREG_EXT_A { match self . bits { false => DVREG_EXT_A :: DVDD_INT , true => DVREG_EXT_A :: DVDD_EXT , } } # [doc = "Checks if the value of the field is `DVDD_INT`"]
# [inline (always)]
pub fn is_dvdd_int (& self) -> bool { * self == DVREG_EXT_A :: DVDD_INT } # [doc = "Checks if the value of the field is `DVDD_EXT`"]
# [inline (always)]
pub fn is_dvdd_ext (& self) -> bool { * self == DVREG_EXT_A :: DVDD_EXT } } # [doc = "Field `DVREG_EXT` writer - Use External DVDD Regulator"]
pub type DVREG_EXT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , VREG_CTRL_SPEC , DVREG_EXT_A , O > ; impl < 'a , const O : u8 > DVREG_EXT_W < 'a , O > { # [doc = "Internal DVDD voltage regulator for the digital section is enabled."]
# [inline (always)]
pub fn dvdd_int (self) -> & 'a mut W { self . variant (DVREG_EXT_A :: DVDD_INT) } # [doc = "Internal DVDD voltage regulator is disabled; use external regulated 1.8V supply voltage for the digital section."]
# [inline (always)]
pub fn dvdd_ext (self) -> & 'a mut W { self . variant (DVREG_EXT_A :: DVDD_EXT) } } # [doc = "Field `AVDD_OK` reader - AVDD Supply Voltage Valid"]
pub type AVDD_OK_R = crate :: BitReader < AVDD_OK_A > ; # [doc = "AVDD Supply Voltage Valid\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AVDD_OK_A { # [doc = "0: Analog voltage regulator disabled or supply voltage not stable"]
ANALOG_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE = 0 , # [doc = "1: Analog supply voltage has settled"]
ANALOG_SUPPLY_VOLTAGE_HAS_SETTLED = 1 , } impl From < AVDD_OK_A > for bool { # [inline (always)]
fn from (variant : AVDD_OK_A) -> Self { variant as u8 != 0 } } impl AVDD_OK_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AVDD_OK_A { match self . bits { false => AVDD_OK_A :: ANALOG_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE , true => AVDD_OK_A :: ANALOG_SUPPLY_VOLTAGE_HAS_SETTLED , } } # [doc = "Checks if the value of the field is `ANALOG_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE`"]
# [inline (always)]
pub fn is_analog_voltage_regulator_disabled_or_supply_voltage_not_stable (& self) -> bool { * self == AVDD_OK_A :: ANALOG_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE } # [doc = "Checks if the value of the field is `ANALOG_SUPPLY_VOLTAGE_HAS_SETTLED`"]
# [inline (always)]
pub fn is_analog_supply_voltage_has_settled (& self) -> bool { * self == AVDD_OK_A :: ANALOG_SUPPLY_VOLTAGE_HAS_SETTLED } } # [doc = "Field `AVDD_OK` writer - AVDD Supply Voltage Valid"]
pub type AVDD_OK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , VREG_CTRL_SPEC , AVDD_OK_A , O > ; impl < 'a , const O : u8 > AVDD_OK_W < 'a , O > { # [doc = "Analog voltage regulator disabled or supply voltage not stable"]
# [inline (always)]
pub fn analog_voltage_regulator_disabled_or_supply_voltage_not_stable (self) -> & 'a mut W { self . variant (AVDD_OK_A :: ANALOG_VOLTAGE_REGULATOR_DISABLED_OR_SUPPLY_VOLTAGE_NOT_STABLE) } # [doc = "Analog supply voltage has settled"]
# [inline (always)]
pub fn analog_supply_voltage_has_settled (self) -> & 'a mut W { self . variant (AVDD_OK_A :: ANALOG_SUPPLY_VOLTAGE_HAS_SETTLED) } } # [doc = "Field `AVREG_EXT` reader - Use External AVDD Regulator"]
pub type AVREG_EXT_R = crate :: BitReader < AVREG_EXT_A > ; # [doc = "Use External AVDD Regulator\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AVREG_EXT_A { # [doc = "0: Internal AVDD voltage regulator for the analog section is enabled."]
AVDD_INT = 0 , # [doc = "1: Internal AVDD voltage regulator is disabled; use external regulated 1.8V supply voltage for the analog section."]
AVDD_EXT = 1 , } impl From < AVREG_EXT_A > for bool { # [inline (always)]
fn from (variant : AVREG_EXT_A) -> Self { variant as u8 != 0 } } impl AVREG_EXT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AVREG_EXT_A { match self . bits { false => AVREG_EXT_A :: AVDD_INT , true => AVREG_EXT_A :: AVDD_EXT , } } # [doc = "Checks if the value of the field is `AVDD_INT`"]
# [inline (always)]
pub fn is_avdd_int (& self) -> bool { * self == AVREG_EXT_A :: AVDD_INT } # [doc = "Checks if the value of the field is `AVDD_EXT`"]
# [inline (always)]
pub fn is_avdd_ext (& self) -> bool { * self == AVREG_EXT_A :: AVDD_EXT } } # [doc = "Field `AVREG_EXT` writer - Use External AVDD Regulator"]
pub type AVREG_EXT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , VREG_CTRL_SPEC , AVREG_EXT_A , O > ; impl < 'a , const O : u8 > AVREG_EXT_W < 'a , O > { # [doc = "Internal AVDD voltage regulator for the analog section is enabled."]
# [inline (always)]
pub fn avdd_int (self) -> & 'a mut W { self . variant (AVREG_EXT_A :: AVDD_INT) } # [doc = "Internal AVDD voltage regulator is disabled; use external regulated 1.8V supply voltage for the analog section."]
# [inline (always)]
pub fn avdd_ext (self) -> & 'a mut W { self . variant (AVREG_EXT_A :: AVDD_EXT) } } impl R { # [doc = "Bit 2 - DVDD Supply Voltage Valid"]
# [inline (always)]
pub fn dvdd_ok (& self) -> DVDD_OK_R { DVDD_OK_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Use External DVDD Regulator"]
# [inline (always)]
pub fn dvreg_ext (& self) -> DVREG_EXT_R { DVREG_EXT_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 6 - AVDD Supply Voltage Valid"]
# [inline (always)]
pub fn avdd_ok (& self) -> AVDD_OK_R { AVDD_OK_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Use External AVDD Regulator"]
# [inline (always)]
pub fn avreg_ext (& self) -> AVREG_EXT_R { AVREG_EXT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 2 - DVDD Supply Voltage Valid"]
# [inline (always)]
# [must_use]
pub fn dvdd_ok (& mut self) -> DVDD_OK_W < 2 > { DVDD_OK_W :: new (self) } # [doc = "Bit 3 - Use External DVDD Regulator"]
# [inline (always)]
# [must_use]
pub fn dvreg_ext (& mut self) -> DVREG_EXT_W < 3 > { DVREG_EXT_W :: new (self) } # [doc = "Bit 6 - AVDD Supply Voltage Valid"]
# [inline (always)]
# [must_use]
pub fn avdd_ok (& mut self) -> AVDD_OK_W < 6 > { AVDD_OK_W :: new (self) } # [doc = "Bit 7 - Use External AVDD Regulator"]
# [inline (always)]
# [must_use]
pub fn avreg_ext (& mut self) -> AVREG_EXT_W < 7 > { AVREG_EXT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage Regulator Control and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vreg_ctrl](index.html) module"]
pub struct VREG_CTRL_SPEC ; impl crate :: RegisterSpec for VREG_CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [vreg_ctrl::R](R) reader structure"]
impl crate :: Readable for VREG_CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [vreg_ctrl::W](W) writer structure"]
impl crate :: Writable for VREG_CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VREG_CTRL to value 0"]
impl crate :: Resettable for VREG_CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "XAH_CTRL_0 (rw) register accessor: an alias for `Reg<XAH_CTRL_0_SPEC>`"]
pub type XAH_CTRL_0 = crate :: Reg < xah_ctrl_0 :: XAH_CTRL_0_SPEC > ; # [doc = "Transceiver Extended Operating Mode Control Register"]
pub mod xah_ctrl_0 { # [doc = "Register `XAH_CTRL_0` reader"]
pub struct R (crate :: R < XAH_CTRL_0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XAH_CTRL_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XAH_CTRL_0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XAH_CTRL_0_SPEC >) -> Self { R (reader) } } # [doc = "Register `XAH_CTRL_0` writer"]
pub struct W (crate :: W < XAH_CTRL_0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XAH_CTRL_0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XAH_CTRL_0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XAH_CTRL_0_SPEC >) -> Self { W (writer) } } # [doc = "Field `SLOTTED_OPERATION` reader - Set Slotted Acknowledgment"]
pub type SLOTTED_OPERATION_R = crate :: BitReader < SLOTTED_OPERATION_A > ; # [doc = "Set Slotted Acknowledgment\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SLOTTED_OPERATION_A { # [doc = "0: The radio transceiver operates in unslotted mode. An acknowledgment frame is automatically sent if requested."]
SLOTTED_OP_DIS = 0 , # [doc = "1: The transmission of an acknowledgment frame has to be controlled by the microcontroller."]
SLOTTED_OP_EN = 1 , } impl From < SLOTTED_OPERATION_A > for bool { # [inline (always)]
fn from (variant : SLOTTED_OPERATION_A) -> Self { variant as u8 != 0 } } impl SLOTTED_OPERATION_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SLOTTED_OPERATION_A { match self . bits { false => SLOTTED_OPERATION_A :: SLOTTED_OP_DIS , true => SLOTTED_OPERATION_A :: SLOTTED_OP_EN , } } # [doc = "Checks if the value of the field is `SLOTTED_OP_DIS`"]
# [inline (always)]
pub fn is_slotted_op_dis (& self) -> bool { * self == SLOTTED_OPERATION_A :: SLOTTED_OP_DIS } # [doc = "Checks if the value of the field is `SLOTTED_OP_EN`"]
# [inline (always)]
pub fn is_slotted_op_en (& self) -> bool { * self == SLOTTED_OPERATION_A :: SLOTTED_OP_EN } } # [doc = "Field `SLOTTED_OPERATION` writer - Set Slotted Acknowledgment"]
pub type SLOTTED_OPERATION_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XAH_CTRL_0_SPEC , SLOTTED_OPERATION_A , O > ; impl < 'a , const O : u8 > SLOTTED_OPERATION_W < 'a , O > { # [doc = "The radio transceiver operates in unslotted mode. An acknowledgment frame is automatically sent if requested."]
# [inline (always)]
pub fn slotted_op_dis (self) -> & 'a mut W { self . variant (SLOTTED_OPERATION_A :: SLOTTED_OP_DIS) } # [doc = "The transmission of an acknowledgment frame has to be controlled by the microcontroller."]
# [inline (always)]
pub fn slotted_op_en (self) -> & 'a mut W { self . variant (SLOTTED_OPERATION_A :: SLOTTED_OP_EN) } } # [doc = "Field `MAX_CSMA_RETRIES` reader - Maximum Number of CSMA-CA Procedure Repetition Attempts"]
pub type MAX_CSMA_RETRIES_R = crate :: FieldReader < u8 , MAX_CSMA_RETRIES_A > ; # [doc = "Maximum Number of CSMA-CA Procedure Repetition Attempts\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MAX_CSMA_RETRIES_A { # [doc = "0: No repetition of CSMA-CA procedure"]
NO_REPETITION_OF_CSMA_CA_PROCEDURE = 0 , # [doc = "1: One repetition of CSMA-CA procedure"]
ONE_REPETITION_OF_CSMA_CA_PROCEDURE = 1 , # [doc = "5: Five repetitions (highest IEEE 802.15.4 compliant value)"]
FIVE_REPETITIONS_HIGHEST_IEEE_802_15_4_COMPLIANT_VALUE = 5 , # [doc = "7: Immediate frame re-transmission without performing CSMA-CA"]
IMMEDIATE_FRAME_RE_TRANSMISSION_WITHOUT_PERFORMING_CSMA_CA = 7 , } impl From < MAX_CSMA_RETRIES_A > for u8 { # [inline (always)]
fn from (variant : MAX_CSMA_RETRIES_A) -> Self { variant as _ } } impl MAX_CSMA_RETRIES_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MAX_CSMA_RETRIES_A > { match self . bits { 0 => Some (MAX_CSMA_RETRIES_A :: NO_REPETITION_OF_CSMA_CA_PROCEDURE) , 1 => Some (MAX_CSMA_RETRIES_A :: ONE_REPETITION_OF_CSMA_CA_PROCEDURE) , 5 => Some (MAX_CSMA_RETRIES_A :: FIVE_REPETITIONS_HIGHEST_IEEE_802_15_4_COMPLIANT_VALUE) , 7 => Some (MAX_CSMA_RETRIES_A :: IMMEDIATE_FRAME_RE_TRANSMISSION_WITHOUT_PERFORMING_CSMA_CA) , _ => None , } } # [doc = "Checks if the value of the field is `NO_REPETITION_OF_CSMA_CA_PROCEDURE`"]
# [inline (always)]
pub fn is_no_repetition_of_csma_ca_procedure (& self) -> bool { * self == MAX_CSMA_RETRIES_A :: NO_REPETITION_OF_CSMA_CA_PROCEDURE } # [doc = "Checks if the value of the field is `ONE_REPETITION_OF_CSMA_CA_PROCEDURE`"]
# [inline (always)]
pub fn is_one_repetition_of_csma_ca_procedure (& self) -> bool { * self == MAX_CSMA_RETRIES_A :: ONE_REPETITION_OF_CSMA_CA_PROCEDURE } # [doc = "Checks if the value of the field is `FIVE_REPETITIONS_HIGHEST_IEEE_802_15_4_COMPLIANT_VALUE`"]
# [inline (always)]
pub fn is_five_repetitions_highest_ieee_802_15_4_compliant_value (& self) -> bool { * self == MAX_CSMA_RETRIES_A :: FIVE_REPETITIONS_HIGHEST_IEEE_802_15_4_COMPLIANT_VALUE } # [doc = "Checks if the value of the field is `IMMEDIATE_FRAME_RE_TRANSMISSION_WITHOUT_PERFORMING_CSMA_CA`"]
# [inline (always)]
pub fn is_immediate_frame_re_transmission_without_performing_csma_ca (& self) -> bool { * self == MAX_CSMA_RETRIES_A :: IMMEDIATE_FRAME_RE_TRANSMISSION_WITHOUT_PERFORMING_CSMA_CA } } # [doc = "Field `MAX_CSMA_RETRIES` writer - Maximum Number of CSMA-CA Procedure Repetition Attempts"]
pub type MAX_CSMA_RETRIES_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , XAH_CTRL_0_SPEC , u8 , MAX_CSMA_RETRIES_A , 3 , O > ; impl < 'a , const O : u8 > MAX_CSMA_RETRIES_W < 'a , O > { # [doc = "No repetition of CSMA-CA procedure"]
# [inline (always)]
pub fn no_repetition_of_csma_ca_procedure (self) -> & 'a mut W { self . variant (MAX_CSMA_RETRIES_A :: NO_REPETITION_OF_CSMA_CA_PROCEDURE) } # [doc = "One repetition of CSMA-CA procedure"]
# [inline (always)]
pub fn one_repetition_of_csma_ca_procedure (self) -> & 'a mut W { self . variant (MAX_CSMA_RETRIES_A :: ONE_REPETITION_OF_CSMA_CA_PROCEDURE) } # [doc = "Five repetitions (highest IEEE 802.15.4 compliant value)"]
# [inline (always)]
pub fn five_repetitions_highest_ieee_802_15_4_compliant_value (self) -> & 'a mut W { self . variant (MAX_CSMA_RETRIES_A :: FIVE_REPETITIONS_HIGHEST_IEEE_802_15_4_COMPLIANT_VALUE) } # [doc = "Immediate frame re-transmission without performing CSMA-CA"]
# [inline (always)]
pub fn immediate_frame_re_transmission_without_performing_csma_ca (self) -> & 'a mut W { self . variant (MAX_CSMA_RETRIES_A :: IMMEDIATE_FRAME_RE_TRANSMISSION_WITHOUT_PERFORMING_CSMA_CA) } } # [doc = "Field `MAX_FRAME_RETRIES` reader - Maximum Number of Frame Re-transmission Attempts"]
pub type MAX_FRAME_RETRIES_R = crate :: FieldReader < u8 , MAX_FRAME_RETRIES_A > ; # [doc = "Maximum Number of Frame Re-transmission Attempts\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MAX_FRAME_RETRIES_A { # [doc = "0: Retransmission of frame is not attempted."]
RETRANSMISSION_OF_FRAME_IS_NOT_ATTEMPTED = 0 , # [doc = "1: Retransmission of frame is attempted once."]
RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_ONCE = 1 , # [doc = "15: Retransmission of frame is attempted 15 times."]
RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_15_TIMES = 15 , } impl From < MAX_FRAME_RETRIES_A > for u8 { # [inline (always)]
fn from (variant : MAX_FRAME_RETRIES_A) -> Self { variant as _ } } impl MAX_FRAME_RETRIES_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MAX_FRAME_RETRIES_A > { match self . bits { 0 => Some (MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_NOT_ATTEMPTED) , 1 => Some (MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_ONCE) , 15 => Some (MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_15_TIMES) , _ => None , } } # [doc = "Checks if the value of the field is `RETRANSMISSION_OF_FRAME_IS_NOT_ATTEMPTED`"]
# [inline (always)]
pub fn is_retransmission_of_frame_is_not_attempted (& self) -> bool { * self == MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_NOT_ATTEMPTED } # [doc = "Checks if the value of the field is `RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_ONCE`"]
# [inline (always)]
pub fn is_retransmission_of_frame_is_attempted_once (& self) -> bool { * self == MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_ONCE } # [doc = "Checks if the value of the field is `RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_15_TIMES`"]
# [inline (always)]
pub fn is_retransmission_of_frame_is_attempted_15_times (& self) -> bool { * self == MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_15_TIMES } } # [doc = "Field `MAX_FRAME_RETRIES` writer - Maximum Number of Frame Re-transmission Attempts"]
pub type MAX_FRAME_RETRIES_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , XAH_CTRL_0_SPEC , u8 , MAX_FRAME_RETRIES_A , 4 , O > ; impl < 'a , const O : u8 > MAX_FRAME_RETRIES_W < 'a , O > { # [doc = "Retransmission of frame is not attempted."]
# [inline (always)]
pub fn retransmission_of_frame_is_not_attempted (self) -> & 'a mut W { self . variant (MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_NOT_ATTEMPTED) } # [doc = "Retransmission of frame is attempted once."]
# [inline (always)]
pub fn retransmission_of_frame_is_attempted_once (self) -> & 'a mut W { self . variant (MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_ONCE) } # [doc = "Retransmission of frame is attempted 15 times."]
# [inline (always)]
pub fn retransmission_of_frame_is_attempted_15_times (self) -> & 'a mut W { self . variant (MAX_FRAME_RETRIES_A :: RETRANSMISSION_OF_FRAME_IS_ATTEMPTED_15_TIMES) } } impl R { # [doc = "Bit 0 - Set Slotted Acknowledgment"]
# [inline (always)]
pub fn slotted_operation (& self) -> SLOTTED_OPERATION_R { SLOTTED_OPERATION_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Maximum Number of CSMA-CA Procedure Repetition Attempts"]
# [inline (always)]
pub fn max_csma_retries (& self) -> MAX_CSMA_RETRIES_R { MAX_CSMA_RETRIES_R :: new ((self . bits >> 1) & 7) } # [doc = "Bits 4:7 - Maximum Number of Frame Re-transmission Attempts"]
# [inline (always)]
pub fn max_frame_retries (& self) -> MAX_FRAME_RETRIES_R { MAX_FRAME_RETRIES_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bit 0 - Set Slotted Acknowledgment"]
# [inline (always)]
# [must_use]
pub fn slotted_operation (& mut self) -> SLOTTED_OPERATION_W < 0 > { SLOTTED_OPERATION_W :: new (self) } # [doc = "Bits 1:3 - Maximum Number of CSMA-CA Procedure Repetition Attempts"]
# [inline (always)]
# [must_use]
pub fn max_csma_retries (& mut self) -> MAX_CSMA_RETRIES_W < 1 > { MAX_CSMA_RETRIES_W :: new (self) } # [doc = "Bits 4:7 - Maximum Number of Frame Re-transmission Attempts"]
# [inline (always)]
# [must_use]
pub fn max_frame_retries (& mut self) -> MAX_FRAME_RETRIES_W < 4 > { MAX_FRAME_RETRIES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Extended Operating Mode Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xah_ctrl_0](index.html) module"]
pub struct XAH_CTRL_0_SPEC ; impl crate :: RegisterSpec for XAH_CTRL_0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [xah_ctrl_0::R](R) reader structure"]
impl crate :: Readable for XAH_CTRL_0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xah_ctrl_0::W](W) writer structure"]
impl crate :: Writable for XAH_CTRL_0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets XAH_CTRL_0 to value 0"]
impl crate :: Resettable for XAH_CTRL_0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "XAH_CTRL_1 (rw) register accessor: an alias for `Reg<XAH_CTRL_1_SPEC>`"]
pub type XAH_CTRL_1 = crate :: Reg < xah_ctrl_1 :: XAH_CTRL_1_SPEC > ; # [doc = "Transceiver Acknowledgment Frame Control Register 1"]
pub mod xah_ctrl_1 { # [doc = "Register `XAH_CTRL_1` reader"]
pub struct R (crate :: R < XAH_CTRL_1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XAH_CTRL_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XAH_CTRL_1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XAH_CTRL_1_SPEC >) -> Self { R (reader) } } # [doc = "Register `XAH_CTRL_1` writer"]
pub struct W (crate :: W < XAH_CTRL_1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XAH_CTRL_1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XAH_CTRL_1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XAH_CTRL_1_SPEC >) -> Self { W (writer) } } # [doc = "Field `AACK_PROM_MODE` reader - Enable Promiscuous Mode"]
pub type AACK_PROM_MODE_R = crate :: BitReader < bool > ; # [doc = "Field `AACK_PROM_MODE` writer - Enable Promiscuous Mode"]
pub type AACK_PROM_MODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XAH_CTRL_1_SPEC , bool , O > ; # [doc = "Field `AACK_ACK_TIME` reader - Reduce Acknowledgment Time"]
pub type AACK_ACK_TIME_R = crate :: BitReader < AACK_ACK_TIME_A > ; # [doc = "Reduce Acknowledgment Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AACK_ACK_TIME_A { # [doc = "0: 12 symbols acknowledgment time"]
AACK_ACK_TIME_12_SYM = 0 , # [doc = "1: 2 symbols acknowledgment time"]
AACK_ACK_TIME_2_SYM = 1 , } impl From < AACK_ACK_TIME_A > for bool { # [inline (always)]
fn from (variant : AACK_ACK_TIME_A) -> Self { variant as u8 != 0 } } impl AACK_ACK_TIME_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AACK_ACK_TIME_A { match self . bits { false => AACK_ACK_TIME_A :: AACK_ACK_TIME_12_SYM , true => AACK_ACK_TIME_A :: AACK_ACK_TIME_2_SYM , } } # [doc = "Checks if the value of the field is `AACK_ACK_TIME_12_SYM`"]
# [inline (always)]
pub fn is_aack_ack_time_12_sym (& self) -> bool { * self == AACK_ACK_TIME_A :: AACK_ACK_TIME_12_SYM } # [doc = "Checks if the value of the field is `AACK_ACK_TIME_2_SYM`"]
# [inline (always)]
pub fn is_aack_ack_time_2_sym (& self) -> bool { * self == AACK_ACK_TIME_A :: AACK_ACK_TIME_2_SYM } } # [doc = "Field `AACK_ACK_TIME` writer - Reduce Acknowledgment Time"]
pub type AACK_ACK_TIME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XAH_CTRL_1_SPEC , AACK_ACK_TIME_A , O > ; impl < 'a , const O : u8 > AACK_ACK_TIME_W < 'a , O > { # [doc = "12 symbols acknowledgment time"]
# [inline (always)]
pub fn aack_ack_time_12_sym (self) -> & 'a mut W { self . variant (AACK_ACK_TIME_A :: AACK_ACK_TIME_12_SYM) } # [doc = "2 symbols acknowledgment time"]
# [inline (always)]
pub fn aack_ack_time_2_sym (self) -> & 'a mut W { self . variant (AACK_ACK_TIME_A :: AACK_ACK_TIME_2_SYM) } } # [doc = "Field `AACK_UPLD_RES_FT` reader - Process Reserved Frames"]
pub type AACK_UPLD_RES_FT_R = crate :: BitReader < bool > ; # [doc = "Field `AACK_UPLD_RES_FT` writer - Process Reserved Frames"]
pub type AACK_UPLD_RES_FT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XAH_CTRL_1_SPEC , bool , O > ; # [doc = "Field `AACK_FLTR_RES_FT` reader - Filter Reserved Frames"]
pub type AACK_FLTR_RES_FT_R = crate :: BitReader < bool > ; # [doc = "Field `AACK_FLTR_RES_FT` writer - Filter Reserved Frames"]
pub type AACK_FLTR_RES_FT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XAH_CTRL_1_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - Enable Promiscuous Mode"]
# [inline (always)]
pub fn aack_prom_mode (& self) -> AACK_PROM_MODE_R { AACK_PROM_MODE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Reduce Acknowledgment Time"]
# [inline (always)]
pub fn aack_ack_time (& self) -> AACK_ACK_TIME_R { AACK_ACK_TIME_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Process Reserved Frames"]
# [inline (always)]
pub fn aack_upld_res_ft (& self) -> AACK_UPLD_RES_FT_R { AACK_UPLD_RES_FT_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Filter Reserved Frames"]
# [inline (always)]
pub fn aack_fltr_res_ft (& self) -> AACK_FLTR_RES_FT_R { AACK_FLTR_RES_FT_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 1 - Enable Promiscuous Mode"]
# [inline (always)]
# [must_use]
pub fn aack_prom_mode (& mut self) -> AACK_PROM_MODE_W < 1 > { AACK_PROM_MODE_W :: new (self) } # [doc = "Bit 2 - Reduce Acknowledgment Time"]
# [inline (always)]
# [must_use]
pub fn aack_ack_time (& mut self) -> AACK_ACK_TIME_W < 2 > { AACK_ACK_TIME_W :: new (self) } # [doc = "Bit 4 - Process Reserved Frames"]
# [inline (always)]
# [must_use]
pub fn aack_upld_res_ft (& mut self) -> AACK_UPLD_RES_FT_W < 4 > { AACK_UPLD_RES_FT_W :: new (self) } # [doc = "Bit 5 - Filter Reserved Frames"]
# [inline (always)]
# [must_use]
pub fn aack_fltr_res_ft (& mut self) -> AACK_FLTR_RES_FT_W < 5 > { AACK_FLTR_RES_FT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transceiver Acknowledgment Frame Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xah_ctrl_1](index.html) module"]
pub struct XAH_CTRL_1_SPEC ; impl crate :: RegisterSpec for XAH_CTRL_1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [xah_ctrl_1::R](R) reader structure"]
impl crate :: Readable for XAH_CTRL_1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xah_ctrl_1::W](W) writer structure"]
impl crate :: Writable for XAH_CTRL_1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets XAH_CTRL_1 to value 0"]
impl crate :: Resettable for XAH_CTRL_1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "XOSC_CTRL (rw) register accessor: an alias for `Reg<XOSC_CTRL_SPEC>`"]
pub type XOSC_CTRL = crate :: Reg < xosc_ctrl :: XOSC_CTRL_SPEC > ; # [doc = "Crystal Oscillator Control Register"]
pub mod xosc_ctrl { # [doc = "Register `XOSC_CTRL` reader"]
pub struct R (crate :: R < XOSC_CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XOSC_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XOSC_CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XOSC_CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `XOSC_CTRL` writer"]
pub struct W (crate :: W < XOSC_CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XOSC_CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XOSC_CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XOSC_CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `XTAL_TRIM` reader - Crystal Oscillator Load Capacitance Trimming"]
pub type XTAL_TRIM_R = crate :: FieldReader < u8 , XTAL_TRIM_A > ; # [doc = "Crystal Oscillator Load Capacitance Trimming\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum XTAL_TRIM_A { # [doc = "0: 0.0 pF, trimming capacitors disconnected"]
XTAL_TRIM_MIN = 0 , # [doc = "1: 0.3 pF, trimming capacitor switched on"]
VAL_0X1 = 1 , # [doc = "2: ..."]
VAL_0X2 = 2 , # [doc = "15: 4.5 pF, trimming capacitor switched on"]
XTAL_TRIM_MAX = 15 , } impl From < XTAL_TRIM_A > for u8 { # [inline (always)]
fn from (variant : XTAL_TRIM_A) -> Self { variant as _ } } impl XTAL_TRIM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < XTAL_TRIM_A > { match self . bits { 0 => Some (XTAL_TRIM_A :: XTAL_TRIM_MIN) , 1 => Some (XTAL_TRIM_A :: VAL_0X1) , 2 => Some (XTAL_TRIM_A :: VAL_0X2) , 15 => Some (XTAL_TRIM_A :: XTAL_TRIM_MAX) , _ => None , } } # [doc = "Checks if the value of the field is `XTAL_TRIM_MIN`"]
# [inline (always)]
pub fn is_xtal_trim_min (& self) -> bool { * self == XTAL_TRIM_A :: XTAL_TRIM_MIN } # [doc = "Checks if the value of the field is `VAL_0X1`"]
# [inline (always)]
pub fn is_val_0x1 (& self) -> bool { * self == XTAL_TRIM_A :: VAL_0X1 } # [doc = "Checks if the value of the field is `VAL_0X2`"]
# [inline (always)]
pub fn is_val_0x2 (& self) -> bool { * self == XTAL_TRIM_A :: VAL_0X2 } # [doc = "Checks if the value of the field is `XTAL_TRIM_MAX`"]
# [inline (always)]
pub fn is_xtal_trim_max (& self) -> bool { * self == XTAL_TRIM_A :: XTAL_TRIM_MAX } } # [doc = "Field `XTAL_TRIM` writer - Crystal Oscillator Load Capacitance Trimming"]
pub type XTAL_TRIM_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , XOSC_CTRL_SPEC , u8 , XTAL_TRIM_A , 4 , O > ; impl < 'a , const O : u8 > XTAL_TRIM_W < 'a , O > { # [doc = "0.0 pF, trimming capacitors disconnected"]
# [inline (always)]
pub fn xtal_trim_min (self) -> & 'a mut W { self . variant (XTAL_TRIM_A :: XTAL_TRIM_MIN) } # [doc = "0.3 pF, trimming capacitor switched on"]
# [inline (always)]
pub fn val_0x1 (self) -> & 'a mut W { self . variant (XTAL_TRIM_A :: VAL_0X1) } # [doc = "..."]
# [inline (always)]
pub fn val_0x2 (self) -> & 'a mut W { self . variant (XTAL_TRIM_A :: VAL_0X2) } # [doc = "4.5 pF, trimming capacitor switched on"]
# [inline (always)]
pub fn xtal_trim_max (self) -> & 'a mut W { self . variant (XTAL_TRIM_A :: XTAL_TRIM_MAX) } } # [doc = "Field `XTAL_MODE` reader - Crystal Oscillator Operating Mode"]
pub type XTAL_MODE_R = crate :: FieldReader < u8 , XTAL_MODE_A > ; # [doc = "Crystal Oscillator Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum XTAL_MODE_A { # [doc = "4: Internal crystal oscillator disabled; use external reference frequency."]
INTERNAL_CRYSTAL_OSCILLATOR_DISABLED_USE_EXTERNAL_REFERENCE_FREQUENCY = 4 , # [doc = "15: Internal crystal oscillator enabled; amplitude regulation of oscillation enabled."]
INTERNAL_CRYSTAL_OSCILLATOR_ENABLED_AMPLITUDE_REGULATION_OF_OSCILLATION_ENABLED = 15 , } impl From < XTAL_MODE_A > for u8 { # [inline (always)]
fn from (variant : XTAL_MODE_A) -> Self { variant as _ } } impl XTAL_MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < XTAL_MODE_A > { match self . bits { 4 => Some (XTAL_MODE_A :: INTERNAL_CRYSTAL_OSCILLATOR_DISABLED_USE_EXTERNAL_REFERENCE_FREQUENCY) , 15 => Some (XTAL_MODE_A :: INTERNAL_CRYSTAL_OSCILLATOR_ENABLED_AMPLITUDE_REGULATION_OF_OSCILLATION_ENABLED) , _ => None , } } # [doc = "Checks if the value of the field is `INTERNAL_CRYSTAL_OSCILLATOR_DISABLED_USE_EXTERNAL_REFERENCE_FREQUENCY`"]
# [inline (always)]
pub fn is_internal_crystal_oscillator_disabled_use_external_reference_frequency (& self) -> bool { * self == XTAL_MODE_A :: INTERNAL_CRYSTAL_OSCILLATOR_DISABLED_USE_EXTERNAL_REFERENCE_FREQUENCY } # [doc = "Checks if the value of the field is `INTERNAL_CRYSTAL_OSCILLATOR_ENABLED_AMPLITUDE_REGULATION_OF_OSCILLATION_ENABLED`"]
# [inline (always)]
pub fn is_internal_crystal_oscillator_enabled_amplitude_regulation_of_oscillation_enabled (& self) -> bool { * self == XTAL_MODE_A :: INTERNAL_CRYSTAL_OSCILLATOR_ENABLED_AMPLITUDE_REGULATION_OF_OSCILLATION_ENABLED } } # [doc = "Field `XTAL_MODE` writer - Crystal Oscillator Operating Mode"]
pub type XTAL_MODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , XOSC_CTRL_SPEC , u8 , XTAL_MODE_A , 4 , O > ; impl < 'a , const O : u8 > XTAL_MODE_W < 'a , O > { # [doc = "Internal crystal oscillator disabled; use external reference frequency."]
# [inline (always)]
pub fn internal_crystal_oscillator_disabled_use_external_reference_frequency (self) -> & 'a mut W { self . variant (XTAL_MODE_A :: INTERNAL_CRYSTAL_OSCILLATOR_DISABLED_USE_EXTERNAL_REFERENCE_FREQUENCY) } # [doc = "Internal crystal oscillator enabled; amplitude regulation of oscillation enabled."]
# [inline (always)]
pub fn internal_crystal_oscillator_enabled_amplitude_regulation_of_oscillation_enabled (self) -> & 'a mut W { self . variant (XTAL_MODE_A :: INTERNAL_CRYSTAL_OSCILLATOR_ENABLED_AMPLITUDE_REGULATION_OF_OSCILLATION_ENABLED) } } impl R { # [doc = "Bits 0:3 - Crystal Oscillator Load Capacitance Trimming"]
# [inline (always)]
pub fn xtal_trim (& self) -> XTAL_TRIM_R { XTAL_TRIM_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Crystal Oscillator Operating Mode"]
# [inline (always)]
pub fn xtal_mode (& self) -> XTAL_MODE_R { XTAL_MODE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Crystal Oscillator Load Capacitance Trimming"]
# [inline (always)]
# [must_use]
pub fn xtal_trim (& mut self) -> XTAL_TRIM_W < 0 > { XTAL_TRIM_W :: new (self) } # [doc = "Bits 4:7 - Crystal Oscillator Operating Mode"]
# [inline (always)]
# [must_use]
pub fn xtal_mode (& mut self) -> XTAL_MODE_W < 4 > { XTAL_MODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Crystal Oscillator Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xosc_ctrl](index.html) module"]
pub struct XOSC_CTRL_SPEC ; impl crate :: RegisterSpec for XOSC_CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [xosc_ctrl::R](R) reader structure"]
impl crate :: Readable for XOSC_CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xosc_ctrl::W](W) writer structure"]
impl crate :: Writable for XOSC_CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets XOSC_CTRL to value 0"]
impl crate :: Resettable for XOSC_CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Two Wire Serial Interface"]
pub struct TWI { _marker : PhantomData < * const () > } unsafe impl Send for TWI { } impl TWI { # [doc = r"Pointer to the register block"]
pub const PTR : * const twi :: RegisterBlock = 0xb8 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const twi :: RegisterBlock { Self :: PTR } } impl Deref for TWI { type Target = twi :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TWI { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TWI") . finish () } } # [doc = "Two Wire Serial Interface"]
pub mod twi { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - TWI Bit Rate Register"]
pub twbr : TWBR , # [doc = "0x01 - TWI Status Register"]
pub twsr : TWSR , # [doc = "0x02 - TWI (Slave) Address Register"]
pub twar : TWAR , # [doc = "0x03 - TWI Data Register"]
pub twdr : TWDR , # [doc = "0x04 - TWI Control Register"]
pub twcr : TWCR , # [doc = "0x05 - TWI (Slave) Address Mask Register"]
pub twamr : TWAMR , } # [doc = "TWAMR (rw) register accessor: an alias for `Reg<TWAMR_SPEC>`"]
pub type TWAMR = crate :: Reg < twamr :: TWAMR_SPEC > ; # [doc = "TWI (Slave) Address Mask Register"]
pub mod twamr { # [doc = "Register `TWAMR` reader"]
pub struct R (crate :: R < TWAMR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWAMR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWAMR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWAMR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWAMR` writer"]
pub struct W (crate :: W < TWAMR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWAMR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWAMR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWAMR_SPEC >) -> Self { W (writer) } } # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWAMR_SPEC , bool , O > ; # [doc = "Field `TWAM` reader - TWI Address Mask"]
pub type TWAM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TWAM` writer - TWI Address Mask"]
pub type TWAM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWAMR_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bit 0 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:7 - TWI Address Mask"]
# [inline (always)]
pub fn twam (& self) -> TWAM_R { TWAM_R :: new ((self . bits >> 1) & 0x7f) } } impl W { # [doc = "Bit 0 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 0 > { RES_W :: new (self) } # [doc = "Bits 1:7 - TWI Address Mask"]
# [inline (always)]
# [must_use]
pub fn twam (& mut self) -> TWAM_W < 1 > { TWAM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI (Slave) Address Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twamr](index.html) module"]
pub struct TWAMR_SPEC ; impl crate :: RegisterSpec for TWAMR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twamr::R](R) reader structure"]
impl crate :: Readable for TWAMR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twamr::W](W) writer structure"]
impl crate :: Writable for TWAMR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWAMR to value 0"]
impl crate :: Resettable for TWAMR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWAR (rw) register accessor: an alias for `Reg<TWAR_SPEC>`"]
pub type TWAR = crate :: Reg < twar :: TWAR_SPEC > ; # [doc = "TWI (Slave) Address Register"]
pub mod twar { # [doc = "Register `TWAR` reader"]
pub struct R (crate :: R < TWAR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWAR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWAR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWAR` writer"]
pub struct W (crate :: W < TWAR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWAR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWAR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TWGCE` reader - TWI General Call Recognition Enable Bit"]
pub type TWGCE_R = crate :: BitReader < bool > ; # [doc = "Field `TWGCE` writer - TWI General Call Recognition Enable Bit"]
pub type TWGCE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWAR_SPEC , bool , O > ; # [doc = "Field `TWA` reader - TWI (Slave) Address"]
pub type TWA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TWA` writer - TWI (Slave) Address"]
pub type TWA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWAR_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bit 0 - TWI General Call Recognition Enable Bit"]
# [inline (always)]
pub fn twgce (& self) -> TWGCE_R { TWGCE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:7 - TWI (Slave) Address"]
# [inline (always)]
pub fn twa (& self) -> TWA_R { TWA_R :: new ((self . bits >> 1) & 0x7f) } } impl W { # [doc = "Bit 0 - TWI General Call Recognition Enable Bit"]
# [inline (always)]
# [must_use]
pub fn twgce (& mut self) -> TWGCE_W < 0 > { TWGCE_W :: new (self) } # [doc = "Bits 1:7 - TWI (Slave) Address"]
# [inline (always)]
# [must_use]
pub fn twa (& mut self) -> TWA_W < 1 > { TWA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI (Slave) Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twar](index.html) module"]
pub struct TWAR_SPEC ; impl crate :: RegisterSpec for TWAR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twar::R](R) reader structure"]
impl crate :: Readable for TWAR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twar::W](W) writer structure"]
impl crate :: Writable for TWAR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWAR to value 0"]
impl crate :: Resettable for TWAR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWBR (rw) register accessor: an alias for `Reg<TWBR_SPEC>`"]
pub type TWBR = crate :: Reg < twbr :: TWBR_SPEC > ; # [doc = "TWI Bit Rate Register"]
pub mod twbr { # [doc = "Register `TWBR` reader"]
pub struct R (crate :: R < TWBR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWBR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWBR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWBR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWBR` writer"]
pub struct W (crate :: W < TWBR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWBR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWBR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWBR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "TWI Bit Rate Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twbr](index.html) module"]
pub struct TWBR_SPEC ; impl crate :: RegisterSpec for TWBR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twbr::R](R) reader structure"]
impl crate :: Readable for TWBR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twbr::W](W) writer structure"]
impl crate :: Writable for TWBR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWBR to value 0"]
impl crate :: Resettable for TWBR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWCR (rw) register accessor: an alias for `Reg<TWCR_SPEC>`"]
pub type TWCR = crate :: Reg < twcr :: TWCR_SPEC > ; # [doc = "TWI Control Register"]
pub mod twcr { # [doc = "Register `TWCR` reader"]
pub struct R (crate :: R < TWCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWCR` writer"]
pub struct W (crate :: W < TWCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TWIE` reader - TWI Interrupt Enable"]
pub type TWIE_R = crate :: BitReader < bool > ; # [doc = "Field `TWIE` writer - TWI Interrupt Enable"]
pub type TWIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWEN` reader - TWI Enable Bit"]
pub type TWEN_R = crate :: BitReader < bool > ; # [doc = "Field `TWEN` writer - TWI Enable Bit"]
pub type TWEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWWC` reader - TWI Write Collision Flag"]
pub type TWWC_R = crate :: BitReader < bool > ; # [doc = "Field `TWWC` writer - TWI Write Collision Flag"]
pub type TWWC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWSTO` reader - TWI STOP Condition Bit"]
pub type TWSTO_R = crate :: BitReader < bool > ; # [doc = "Field `TWSTO` writer - TWI STOP Condition Bit"]
pub type TWSTO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWSTA` reader - TWI START Condition Bit"]
pub type TWSTA_R = crate :: BitReader < bool > ; # [doc = "Field `TWSTA` writer - TWI START Condition Bit"]
pub type TWSTA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWEA` reader - TWI Enable Acknowledge Bit"]
pub type TWEA_R = crate :: BitReader < bool > ; # [doc = "Field `TWEA` writer - TWI Enable Acknowledge Bit"]
pub type TWEA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWINT` reader - TWI Interrupt Flag"]
pub type TWINT_R = crate :: BitReader < bool > ; # [doc = "Field `TWINT` writer - TWI Interrupt Flag"]
pub type TWINT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - TWI Interrupt Enable"]
# [inline (always)]
pub fn twie (& self) -> TWIE_R { TWIE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - TWI Enable Bit"]
# [inline (always)]
pub fn twen (& self) -> TWEN_R { TWEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - TWI Write Collision Flag"]
# [inline (always)]
pub fn twwc (& self) -> TWWC_R { TWWC_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - TWI STOP Condition Bit"]
# [inline (always)]
pub fn twsto (& self) -> TWSTO_R { TWSTO_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - TWI START Condition Bit"]
# [inline (always)]
pub fn twsta (& self) -> TWSTA_R { TWSTA_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TWI Enable Acknowledge Bit"]
# [inline (always)]
pub fn twea (& self) -> TWEA_R { TWEA_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - TWI Interrupt Flag"]
# [inline (always)]
pub fn twint (& self) -> TWINT_R { TWINT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - TWI Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn twie (& mut self) -> TWIE_W < 0 > { TWIE_W :: new (self) } # [doc = "Bit 1 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 1 > { RES_W :: new (self) } # [doc = "Bit 2 - TWI Enable Bit"]
# [inline (always)]
# [must_use]
pub fn twen (& mut self) -> TWEN_W < 2 > { TWEN_W :: new (self) } # [doc = "Bit 3 - TWI Write Collision Flag"]
# [inline (always)]
# [must_use]
pub fn twwc (& mut self) -> TWWC_W < 3 > { TWWC_W :: new (self) } # [doc = "Bit 4 - TWI STOP Condition Bit"]
# [inline (always)]
# [must_use]
pub fn twsto (& mut self) -> TWSTO_W < 4 > { TWSTO_W :: new (self) } # [doc = "Bit 5 - TWI START Condition Bit"]
# [inline (always)]
# [must_use]
pub fn twsta (& mut self) -> TWSTA_W < 5 > { TWSTA_W :: new (self) } # [doc = "Bit 6 - TWI Enable Acknowledge Bit"]
# [inline (always)]
# [must_use]
pub fn twea (& mut self) -> TWEA_W < 6 > { TWEA_W :: new (self) } # [doc = "Bit 7 - TWI Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn twint (& mut self) -> TWINT_W < 7 > { TWINT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twcr](index.html) module"]
pub struct TWCR_SPEC ; impl crate :: RegisterSpec for TWCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twcr::R](R) reader structure"]
impl crate :: Readable for TWCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twcr::W](W) writer structure"]
impl crate :: Writable for TWCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWCR to value 0"]
impl crate :: Resettable for TWCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWDR (rw) register accessor: an alias for `Reg<TWDR_SPEC>`"]
pub type TWDR = crate :: Reg < twdr :: TWDR_SPEC > ; # [doc = "TWI Data Register"]
pub mod twdr { # [doc = "Register `TWDR` reader"]
pub struct R (crate :: R < TWDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWDR` writer"]
pub struct W (crate :: W < TWDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "TWI Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twdr](index.html) module"]
pub struct TWDR_SPEC ; impl crate :: RegisterSpec for TWDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twdr::R](R) reader structure"]
impl crate :: Readable for TWDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twdr::W](W) writer structure"]
impl crate :: Writable for TWDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWDR to value 0"]
impl crate :: Resettable for TWDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWSR (rw) register accessor: an alias for `Reg<TWSR_SPEC>`"]
pub type TWSR = crate :: Reg < twsr :: TWSR_SPEC > ; # [doc = "TWI Status Register"]
pub mod twsr { # [doc = "Register `TWSR` reader"]
pub struct R (crate :: R < TWSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWSR` writer"]
pub struct W (crate :: W < TWSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TWPS` reader - TWI Prescaler Bits"]
pub type TWPS_R = crate :: FieldReader < u8 , TWPS_A > ; # [doc = "TWI Prescaler Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TWPS_A { # [doc = "0: 1"]
_1 = 0 , # [doc = "1: 4"]
_4 = 1 , # [doc = "2: 16"]
_16 = 2 , # [doc = "3: 64"]
_64 = 3 , } impl From < TWPS_A > for u8 { # [inline (always)]
fn from (variant : TWPS_A) -> Self { variant as _ } } impl TWPS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TWPS_A { match self . bits { 0 => TWPS_A :: _1 , 1 => TWPS_A :: _4 , 2 => TWPS_A :: _16 , 3 => TWPS_A :: _64 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == TWPS_A :: _1 } # [doc = "Checks if the value of the field is `_4`"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == TWPS_A :: _4 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == TWPS_A :: _16 } # [doc = "Checks if the value of the field is `_64`"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == TWPS_A :: _64 } } # [doc = "Field `TWPS` writer - TWI Prescaler Bits"]
pub type TWPS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWSR_SPEC , u8 , TWPS_A , 2 , O > ; impl < 'a , const O : u8 > TWPS_W < 'a , O > { # [doc = "1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (TWPS_A :: _1) } # [doc = "4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut W { self . variant (TWPS_A :: _4) } # [doc = "16"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (TWPS_A :: _16) } # [doc = "64"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut W { self . variant (TWPS_A :: _64) } } # [doc = "Field `Res` reader - Reserved Bit"]
pub type RES_R = crate :: BitReader < bool > ; # [doc = "Field `Res` writer - Reserved Bit"]
pub type RES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWSR_SPEC , bool , O > ; # [doc = "Field `TWS` reader - TWI Status"]
pub type TWS_R = crate :: FieldReader < u8 , TWS_A > ; # [doc = "TWI Status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TWS_A { # [doc = "0: Bus error due to illegal START or STOP condition."]
BUS_ERROR_DUE_TO_ILLEGAL_START_OR_STOP_CONDITION = 0 , # [doc = "8: A START condition has been transmitted."]
A_START_CONDITION_HAS_BEEN_TRANSMITTED = 8 , # [doc = "16: A repeated START condition has been transmitted."]
A_REPEATED_START_CONDITION_HAS_BEEN_TRANSMITTED = 16 , # [doc = "24: SLA+W has been transmitted; ACK has been received."]
SLA_W_HAS_BEEN_TRANSMITTED_ACK_HAS_BEEN_RECEIVED = 24 , } impl From < TWS_A > for u8 { # [inline (always)]
fn from (variant : TWS_A) -> Self { variant as _ } } impl TWS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TWS_A > { match self . bits { 0 => Some (TWS_A :: BUS_ERROR_DUE_TO_ILLEGAL_START_OR_STOP_CONDITION) , 8 => Some (TWS_A :: A_START_CONDITION_HAS_BEEN_TRANSMITTED) , 16 => Some (TWS_A :: A_REPEATED_START_CONDITION_HAS_BEEN_TRANSMITTED) , 24 => Some (TWS_A :: SLA_W_HAS_BEEN_TRANSMITTED_ACK_HAS_BEEN_RECEIVED) , _ => None , } } # [doc = "Checks if the value of the field is `BUS_ERROR_DUE_TO_ILLEGAL_START_OR_STOP_CONDITION`"]
# [inline (always)]
pub fn is_bus_error_due_to_illegal_start_or_stop_condition (& self) -> bool { * self == TWS_A :: BUS_ERROR_DUE_TO_ILLEGAL_START_OR_STOP_CONDITION } # [doc = "Checks if the value of the field is `A_START_CONDITION_HAS_BEEN_TRANSMITTED`"]
# [inline (always)]
pub fn is_a_start_condition_has_been_transmitted (& self) -> bool { * self == TWS_A :: A_START_CONDITION_HAS_BEEN_TRANSMITTED } # [doc = "Checks if the value of the field is `A_REPEATED_START_CONDITION_HAS_BEEN_TRANSMITTED`"]
# [inline (always)]
pub fn is_a_repeated_start_condition_has_been_transmitted (& self) -> bool { * self == TWS_A :: A_REPEATED_START_CONDITION_HAS_BEEN_TRANSMITTED } # [doc = "Checks if the value of the field is `SLA_W_HAS_BEEN_TRANSMITTED_ACK_HAS_BEEN_RECEIVED`"]
# [inline (always)]
pub fn is_sla_w_has_been_transmitted_ack_has_been_received (& self) -> bool { * self == TWS_A :: SLA_W_HAS_BEEN_TRANSMITTED_ACK_HAS_BEEN_RECEIVED } } # [doc = "Field `TWS` writer - TWI Status"]
pub type TWS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TWSR_SPEC , u8 , TWS_A , 5 , O > ; impl < 'a , const O : u8 > TWS_W < 'a , O > { # [doc = "Bus error due to illegal START or STOP condition."]
# [inline (always)]
pub fn bus_error_due_to_illegal_start_or_stop_condition (self) -> & 'a mut W { self . variant (TWS_A :: BUS_ERROR_DUE_TO_ILLEGAL_START_OR_STOP_CONDITION) } # [doc = "A START condition has been transmitted."]
# [inline (always)]
pub fn a_start_condition_has_been_transmitted (self) -> & 'a mut W { self . variant (TWS_A :: A_START_CONDITION_HAS_BEEN_TRANSMITTED) } # [doc = "A repeated START condition has been transmitted."]
# [inline (always)]
pub fn a_repeated_start_condition_has_been_transmitted (self) -> & 'a mut W { self . variant (TWS_A :: A_REPEATED_START_CONDITION_HAS_BEEN_TRANSMITTED) } # [doc = "SLA+W has been transmitted; ACK has been received."]
# [inline (always)]
pub fn sla_w_has_been_transmitted_ack_has_been_received (self) -> & 'a mut W { self . variant (TWS_A :: SLA_W_HAS_BEEN_TRANSMITTED_ACK_HAS_BEEN_RECEIVED) } } impl R { # [doc = "Bits 0:1 - TWI Prescaler Bits"]
# [inline (always)]
pub fn twps (& self) -> TWPS_R { TWPS_R :: new (self . bits & 3) } # [doc = "Bit 2 - Reserved Bit"]
# [inline (always)]
pub fn res (& self) -> RES_R { RES_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:7 - TWI Status"]
# [inline (always)]
pub fn tws (& self) -> TWS_R { TWS_R :: new ((self . bits >> 3) & 0x1f) } } impl W { # [doc = "Bits 0:1 - TWI Prescaler Bits"]
# [inline (always)]
# [must_use]
pub fn twps (& mut self) -> TWPS_W < 0 > { TWPS_W :: new (self) } # [doc = "Bit 2 - Reserved Bit"]
# [inline (always)]
# [must_use]
pub fn res (& mut self) -> RES_W < 2 > { RES_W :: new (self) } # [doc = "Bits 3:7 - TWI Status"]
# [inline (always)]
# [must_use]
pub fn tws (& mut self) -> TWS_W < 3 > { TWS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twsr](index.html) module"]
pub struct TWSR_SPEC ; impl crate :: RegisterSpec for TWSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twsr::R](R) reader structure"]
impl crate :: Readable for TWSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twsr::W](W) writer structure"]
impl crate :: Writable for TWSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWSR to value 0"]
impl crate :: Resettable for TWSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "USART"]
pub struct USART0 { _marker : PhantomData < * const () > } unsafe impl Send for USART0 { } impl USART0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart0 :: RegisterBlock = 0xc0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart0 :: RegisterBlock { Self :: PTR } } impl Deref for USART0 { type Target = usart0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART0") . finish () } } # [doc = "USART"]
pub mod usart0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USART0 Control and Status Register A"]
pub ucsr0a : UCSR0A , # [doc = "0x01 - USART0 Control and Status Register B"]
pub ucsr0b : UCSR0B , # [doc = "0x02 - USART0 Control and Status Register C"]
pub ucsr0c : UCSR0C , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - USART0 Baud Rate Register Bytes"]
pub ubrr0 : UBRR0 , # [doc = "0x06 - USART0 I/O Data Register"]
pub udr0 : UDR0 , } # [doc = "UBRR0 (rw) register accessor: an alias for `Reg<UBRR0_SPEC>`"]
pub type UBRR0 = crate :: Reg < ubrr0 :: UBRR0_SPEC > ; # [doc = "USART0 Baud Rate Register Bytes"]
pub mod ubrr0 { # [doc = "Register `UBRR0` reader"]
pub struct R (crate :: R < UBRR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UBRR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UBRR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UBRR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UBRR0` writer"]
pub struct W (crate :: W < UBRR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UBRR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UBRR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UBRR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "USART0 Baud Rate Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ubrr0](index.html) module"]
pub struct UBRR0_SPEC ; impl crate :: RegisterSpec for UBRR0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ubrr0::R](R) reader structure"]
impl crate :: Readable for UBRR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ubrr0::W](W) writer structure"]
impl crate :: Writable for UBRR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UBRR0 to value 0"]
impl crate :: Resettable for UBRR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR0A (rw) register accessor: an alias for `Reg<UCSR0A_SPEC>`"]
pub type UCSR0A = crate :: Reg < ucsr0a :: UCSR0A_SPEC > ; # [doc = "USART0 Control and Status Register A"]
pub mod ucsr0a { # [doc = "Register `UCSR0A` reader"]
pub struct R (crate :: R < UCSR0A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0A_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0A` writer"]
pub struct W (crate :: W < UCSR0A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0A_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPCM0` reader - Multi-processor Communication Mode"]
pub type MPCM0_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM0` writer - Multi-processor Communication Mode"]
pub type MPCM0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `U2X0` reader - Double the USART Transmission Speed"]
pub type U2X0_R = crate :: BitReader < bool > ; # [doc = "Field `U2X0` writer - Double the USART Transmission Speed"]
pub type U2X0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `UPE0` reader - USART Parity Error"]
pub type UPE0_R = crate :: BitReader < bool > ; # [doc = "Field `UPE0` writer - USART Parity Error"]
pub type UPE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `DOR0` reader - Data OverRun"]
pub type DOR0_R = crate :: BitReader < bool > ; # [doc = "Field `DOR0` writer - Data OverRun"]
pub type DOR0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `FE0` reader - Frame Error"]
pub type FE0_R = crate :: BitReader < bool > ; # [doc = "Field `FE0` writer - Frame Error"]
pub type FE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `UDRE0` reader - USART Data Register Empty"]
pub type UDRE0_R = crate :: BitReader < bool > ; # [doc = "Field `UDRE0` writer - USART Data Register Empty"]
pub type UDRE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `TXC0` reader - USART Transmit Complete"]
pub type TXC0_R = crate :: BitReader < bool > ; # [doc = "Field `TXC0` writer - USART Transmit Complete"]
pub type TXC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `RXC0` reader - USART Receive Complete"]
pub type RXC0_R = crate :: BitReader < bool > ; # [doc = "Field `RXC0` writer - USART Receive Complete"]
pub type RXC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm0 (& self) -> MPCM0_R { MPCM0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Double the USART Transmission Speed"]
# [inline (always)]
pub fn u2x0 (& self) -> U2X0_R { U2X0_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - USART Parity Error"]
# [inline (always)]
pub fn upe0 (& self) -> UPE0_R { UPE0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Data OverRun"]
# [inline (always)]
pub fn dor0 (& self) -> DOR0_R { DOR0_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn fe0 (& self) -> FE0_R { FE0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
pub fn udre0 (& self) -> UDRE0_R { UDRE0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USART Transmit Complete"]
# [inline (always)]
pub fn txc0 (& self) -> TXC0_R { TXC0_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
pub fn rxc0 (& self) -> RXC0_R { RXC0_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm0 (& mut self) -> MPCM0_W < 0 > { MPCM0_W :: new (self) } # [doc = "Bit 1 - Double the USART Transmission Speed"]
# [inline (always)]
# [must_use]
pub fn u2x0 (& mut self) -> U2X0_W < 1 > { U2X0_W :: new (self) } # [doc = "Bit 2 - USART Parity Error"]
# [inline (always)]
# [must_use]
pub fn upe0 (& mut self) -> UPE0_W < 2 > { UPE0_W :: new (self) } # [doc = "Bit 3 - Data OverRun"]
# [inline (always)]
# [must_use]
pub fn dor0 (& mut self) -> DOR0_W < 3 > { DOR0_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn fe0 (& mut self) -> FE0_W < 4 > { FE0_W :: new (self) } # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn udre0 (& mut self) -> UDRE0_W < 5 > { UDRE0_W :: new (self) } # [doc = "Bit 6 - USART Transmit Complete"]
# [inline (always)]
# [must_use]
pub fn txc0 (& mut self) -> TXC0_W < 6 > { TXC0_W :: new (self) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
# [must_use]
pub fn rxc0 (& mut self) -> RXC0_W < 7 > { RXC0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART0 Control and Status Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0a](index.html) module"]
pub struct UCSR0A_SPEC ; impl crate :: RegisterSpec for UCSR0A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0a::R](R) reader structure"]
impl crate :: Readable for UCSR0A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0a::W](W) writer structure"]
impl crate :: Writable for UCSR0A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0A to value 0"]
impl crate :: Resettable for UCSR0A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR0B (rw) register accessor: an alias for `Reg<UCSR0B_SPEC>`"]
pub type UCSR0B = crate :: Reg < ucsr0b :: UCSR0B_SPEC > ; # [doc = "USART0 Control and Status Register B"]
pub mod ucsr0b { # [doc = "Register `UCSR0B` reader"]
pub struct R (crate :: R < UCSR0B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0B_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0B` writer"]
pub struct W (crate :: W < UCSR0B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0B_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB80` reader - Transmit Data Bit 8"]
pub type TXB80_R = crate :: BitReader < bool > ; # [doc = "Field `TXB80` writer - Transmit Data Bit 8"]
pub type TXB80_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `RXB80` reader - Receive Data Bit 8"]
pub type RXB80_R = crate :: BitReader < bool > ; # [doc = "Field `RXB80` writer - Receive Data Bit 8"]
pub type RXB80_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `UCSZ02` reader - Character Size"]
pub type UCSZ02_R = crate :: BitReader < bool > ; # [doc = "Field `UCSZ02` writer - Character Size"]
pub type UCSZ02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `TXEN0` reader - Transmitter Enable"]
pub type TXEN0_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN0` writer - Transmitter Enable"]
pub type TXEN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `RXEN0` reader - Receiver Enable"]
pub type RXEN0_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN0` writer - Receiver Enable"]
pub type RXEN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `UDRIE0` reader - USART Data Register Empty Interrupt Enable"]
pub type UDRIE0_R = crate :: BitReader < bool > ; # [doc = "Field `UDRIE0` writer - USART Data Register Empty Interrupt Enable"]
pub type UDRIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `TXCIE0` reader - TX Complete Interrupt Enable"]
pub type TXCIE0_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE0` writer - TX Complete Interrupt Enable"]
pub type TXCIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `RXCIE0` reader - RX Complete Interrupt Enable"]
pub type RXCIE0_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE0` writer - RX Complete Interrupt Enable"]
pub type RXCIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit Data Bit 8"]
# [inline (always)]
pub fn txb80 (& self) -> TXB80_R { TXB80_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Receive Data Bit 8"]
# [inline (always)]
pub fn rxb80 (& self) -> RXB80_R { RXB80_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Character Size"]
# [inline (always)]
pub fn ucsz02 (& self) -> UCSZ02_R { UCSZ02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen0 (& self) -> TXEN0_R { TXEN0_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen0 (& self) -> RXEN0_R { RXEN0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USART Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn udrie0 (& self) -> UDRIE0_R { UDRIE0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie0 (& self) -> TXCIE0_R { TXCIE0_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie0 (& self) -> RXCIE0_R { RXCIE0_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit Data Bit 8"]
# [inline (always)]
# [must_use]
pub fn txb80 (& mut self) -> TXB80_W < 0 > { TXB80_W :: new (self) } # [doc = "Bit 1 - Receive Data Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb80 (& mut self) -> RXB80_W < 1 > { RXB80_W :: new (self) } # [doc = "Bit 2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn ucsz02 (& mut self) -> UCSZ02_W < 2 > { UCSZ02_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen0 (& mut self) -> TXEN0_W < 3 > { TXEN0_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen0 (& mut self) -> RXEN0_W < 4 > { RXEN0_W :: new (self) } # [doc = "Bit 5 - USART Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn udrie0 (& mut self) -> UDRIE0_W < 5 > { UDRIE0_W :: new (self) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie0 (& mut self) -> TXCIE0_W < 6 > { TXCIE0_W :: new (self) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie0 (& mut self) -> RXCIE0_W < 7 > { RXCIE0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART0 Control and Status Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0b](index.html) module"]
pub struct UCSR0B_SPEC ; impl crate :: RegisterSpec for UCSR0B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0b::R](R) reader structure"]
impl crate :: Readable for UCSR0B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0b::W](W) writer structure"]
impl crate :: Writable for UCSR0B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0B to value 0"]
impl crate :: Resettable for UCSR0B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR0C (rw) register accessor: an alias for `Reg<UCSR0C_SPEC>`"]
pub type UCSR0C = crate :: Reg < ucsr0c :: UCSR0C_SPEC > ; # [doc = "USART0 Control and Status Register C"]
pub mod ucsr0c { # [doc = "Register `UCSR0C` reader"]
pub struct R (crate :: R < UCSR0C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0C` writer"]
pub struct W (crate :: W < UCSR0C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCPOL0` reader - Clock Polarity"]
pub type UCPOL0_R = crate :: BitReader < UCPOL0_A > ; # [doc = "Clock Polarity\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum UCPOL0_A { # [doc = "0: Rising XCKn Edge (Transmitted Data Changed), Falling XCKn Edge (Received Data Sampled)"]
RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED = 0 , # [doc = "1: Falling XCKn Edge (Transmitted Data Changed), Rising XCKn Edge (Received Data Sampled)"]
FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED = 1 , } impl From < UCPOL0_A > for bool { # [inline (always)]
fn from (variant : UCPOL0_A) -> Self { variant as u8 != 0 } } impl UCPOL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCPOL0_A { match self . bits { false => UCPOL0_A :: RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED , true => UCPOL0_A :: FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED , } } # [doc = "Checks if the value of the field is `RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED`"]
# [inline (always)]
pub fn is_rising_xckn_edge_transmitted_data_changed_falling_xckn_edge_received_data_sampled (& self) -> bool { * self == UCPOL0_A :: RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED } # [doc = "Checks if the value of the field is `FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED`"]
# [inline (always)]
pub fn is_falling_xckn_edge_transmitted_data_changed_rising_xckn_edge_received_data_sampled (& self) -> bool { * self == UCPOL0_A :: FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED } } # [doc = "Field `UCPOL0` writer - Clock Polarity"]
pub type UCPOL0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0C_SPEC , UCPOL0_A , O > ; impl < 'a , const O : u8 > UCPOL0_W < 'a , O > { # [doc = "Rising XCKn Edge (Transmitted Data Changed), Falling XCKn Edge (Received Data Sampled)"]
# [inline (always)]
pub fn rising_xckn_edge_transmitted_data_changed_falling_xckn_edge_received_data_sampled (self) -> & 'a mut W { self . variant (UCPOL0_A :: RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED) } # [doc = "Falling XCKn Edge (Transmitted Data Changed), Rising XCKn Edge (Received Data Sampled)"]
# [inline (always)]
pub fn falling_xckn_edge_transmitted_data_changed_rising_xckn_edge_received_data_sampled (self) -> & 'a mut W { self . variant (UCPOL0_A :: FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED) } } # [doc = "Field `UCSZ0` reader - Character Size"]
pub type UCSZ0_R = crate :: FieldReader < u8 , UCSZ0_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum UCSZ0_A { # [doc = "0: 5-bit"]
_5_BIT = 0 , # [doc = "1: 6-bit"]
_6_BIT = 1 , # [doc = "2: 7-bit"]
_7_BIT = 2 , # [doc = "3: 8-bit"]
_8_BIT = 3 , } impl From < UCSZ0_A > for u8 { # [inline (always)]
fn from (variant : UCSZ0_A) -> Self { variant as _ } } impl UCSZ0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCSZ0_A { match self . bits { 0 => UCSZ0_A :: _5_BIT , 1 => UCSZ0_A :: _6_BIT , 2 => UCSZ0_A :: _7_BIT , 3 => UCSZ0_A :: _8_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_5_BIT`"]
# [inline (always)]
pub fn is_5_bit (& self) -> bool { * self == UCSZ0_A :: _5_BIT } # [doc = "Checks if the value of the field is `_6_BIT`"]
# [inline (always)]
pub fn is_6_bit (& self) -> bool { * self == UCSZ0_A :: _6_BIT } # [doc = "Checks if the value of the field is `_7_BIT`"]
# [inline (always)]
pub fn is_7_bit (& self) -> bool { * self == UCSZ0_A :: _7_BIT } # [doc = "Checks if the value of the field is `_8_BIT`"]
# [inline (always)]
pub fn is_8_bit (& self) -> bool { * self == UCSZ0_A :: _8_BIT } } # [doc = "Field `UCSZ0` writer - Character Size"]
pub type UCSZ0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , UCSR0C_SPEC , u8 , UCSZ0_A , 2 , O > ; impl < 'a , const O : u8 > UCSZ0_W < 'a , O > { # [doc = "5-bit"]
# [inline (always)]
pub fn _5_bit (self) -> & 'a mut W { self . variant (UCSZ0_A :: _5_BIT) } # [doc = "6-bit"]
# [inline (always)]
pub fn _6_bit (self) -> & 'a mut W { self . variant (UCSZ0_A :: _6_BIT) } # [doc = "7-bit"]
# [inline (always)]
pub fn _7_bit (self) -> & 'a mut W { self . variant (UCSZ0_A :: _7_BIT) } # [doc = "8-bit"]
# [inline (always)]
pub fn _8_bit (self) -> & 'a mut W { self . variant (UCSZ0_A :: _8_BIT) } } # [doc = "Field `USBS0` reader - Stop Bit Select"]
pub type USBS0_R = crate :: BitReader < USBS0_A > ; # [doc = "Stop Bit Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum USBS0_A { # [doc = "0: 1-bit"]
_1_BIT = 0 , # [doc = "1: 2-bit"]
_2_BIT = 1 , } impl From < USBS0_A > for bool { # [inline (always)]
fn from (variant : USBS0_A) -> Self { variant as u8 != 0 } } impl USBS0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> USBS0_A { match self . bits { false => USBS0_A :: _1_BIT , true => USBS0_A :: _2_BIT , } } # [doc = "Checks if the value of the field is `_1_BIT`"]
# [inline (always)]
pub fn is_1_bit (& self) -> bool { * self == USBS0_A :: _1_BIT } # [doc = "Checks if the value of the field is `_2_BIT`"]
# [inline (always)]
pub fn is_2_bit (& self) -> bool { * self == USBS0_A :: _2_BIT } } # [doc = "Field `USBS0` writer - Stop Bit Select"]
pub type USBS0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0C_SPEC , USBS0_A , O > ; impl < 'a , const O : u8 > USBS0_W < 'a , O > { # [doc = "1-bit"]
# [inline (always)]
pub fn _1_bit (self) -> & 'a mut W { self . variant (USBS0_A :: _1_BIT) } # [doc = "2-bit"]
# [inline (always)]
pub fn _2_bit (self) -> & 'a mut W { self . variant (USBS0_A :: _2_BIT) } } # [doc = "Field `UPM0` reader - Parity Mode"]
pub type UPM0_R = crate :: FieldReader < u8 , UPM0_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum UPM0_A { # [doc = "0: Disabled"]
DISABLED = 0 , # [doc = "2: Enabled, Even Parity"]
ENABLED_EVEN_PARITY = 2 , # [doc = "3: Enabled, Odd Parity"]
ENABLED_ODD_PARITY = 3 , } impl From < UPM0_A > for u8 { # [inline (always)]
fn from (variant : UPM0_A) -> Self { variant as _ } } impl UPM0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UPM0_A { match self . bits { 0 => UPM0_A :: DISABLED , 2 => UPM0_A :: ENABLED_EVEN_PARITY , 3 => UPM0_A :: ENABLED_ODD_PARITY , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == UPM0_A :: DISABLED } # [doc = "Checks if the value of the field is `ENABLED_EVEN_PARITY`"]
# [inline (always)]
pub fn is_enabled_even_parity (& self) -> bool { * self == UPM0_A :: ENABLED_EVEN_PARITY } # [doc = "Checks if the value of the field is `ENABLED_ODD_PARITY`"]
# [inline (always)]
pub fn is_enabled_odd_parity (& self) -> bool { * self == UPM0_A :: ENABLED_ODD_PARITY } } # [doc = "Field `UPM0` writer - Parity Mode"]
pub type UPM0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , UCSR0C_SPEC , u8 , UPM0_A , 2 , O > ; impl < 'a , const O : u8 > UPM0_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (UPM0_A :: DISABLED) } # [doc = "Enabled, Even Parity"]
# [inline (always)]
pub fn enabled_even_parity (self) -> & 'a mut W { self . variant (UPM0_A :: ENABLED_EVEN_PARITY) } # [doc = "Enabled, Odd Parity"]
# [inline (always)]
pub fn enabled_odd_parity (self) -> & 'a mut W { self . variant (UPM0_A :: ENABLED_ODD_PARITY) } } # [doc = "Field `UMSEL0` reader - USART Mode Select"]
pub type UMSEL0_R = crate :: FieldReader < u8 , UMSEL0_A > ; # [doc = "USART Mode Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum UMSEL0_A { # [doc = "0: Asynchronous USART"]
ASYNCHRONOUS_USART = 0 , # [doc = "1: Synchronous USART"]
SYNCHRONOUS_USART = 1 , # [doc = "3: Master SPI (MSPIM)"]
MASTER_SPI_MSPIM = 3 , } impl From < UMSEL0_A > for u8 { # [inline (always)]
fn from (variant : UMSEL0_A) -> Self { variant as _ } } impl UMSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UMSEL0_A { match self . bits { 0 => UMSEL0_A :: ASYNCHRONOUS_USART , 1 => UMSEL0_A :: SYNCHRONOUS_USART , 3 => UMSEL0_A :: MASTER_SPI_MSPIM , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS_USART`"]
# [inline (always)]
pub fn is_asynchronous_usart (& self) -> bool { * self == UMSEL0_A :: ASYNCHRONOUS_USART } # [doc = "Checks if the value of the field is `SYNCHRONOUS_USART`"]
# [inline (always)]
pub fn is_synchronous_usart (& self) -> bool { * self == UMSEL0_A :: SYNCHRONOUS_USART } # [doc = "Checks if the value of the field is `MASTER_SPI_MSPIM`"]
# [inline (always)]
pub fn is_master_spi_mspim (& self) -> bool { * self == UMSEL0_A :: MASTER_SPI_MSPIM } } # [doc = "Field `UMSEL0` writer - USART Mode Select"]
pub type UMSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , UCSR0C_SPEC , u8 , UMSEL0_A , 2 , O > ; impl < 'a , const O : u8 > UMSEL0_W < 'a , O > { # [doc = "Asynchronous USART"]
# [inline (always)]
pub fn asynchronous_usart (self) -> & 'a mut W { self . variant (UMSEL0_A :: ASYNCHRONOUS_USART) } # [doc = "Synchronous USART"]
# [inline (always)]
pub fn synchronous_usart (self) -> & 'a mut W { self . variant (UMSEL0_A :: SYNCHRONOUS_USART) } # [doc = "Master SPI (MSPIM)"]
# [inline (always)]
pub fn master_spi_mspim (self) -> & 'a mut W { self . variant (UMSEL0_A :: MASTER_SPI_MSPIM) } } impl R { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
pub fn ucpol0 (& self) -> UCPOL0_R { UCPOL0_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Character Size"]
# [inline (always)]
pub fn ucsz0 (& self) -> UCSZ0_R { UCSZ0_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Stop Bit Select"]
# [inline (always)]
pub fn usbs0 (& self) -> USBS0_R { USBS0_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn upm0 (& self) -> UPM0_R { UPM0_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - USART Mode Select"]
# [inline (always)]
pub fn umsel0 (& self) -> UMSEL0_R { UMSEL0_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
# [must_use]
pub fn ucpol0 (& mut self) -> UCPOL0_W < 0 > { UCPOL0_W :: new (self) } # [doc = "Bits 1:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn ucsz0 (& mut self) -> UCSZ0_W < 1 > { UCSZ0_W :: new (self) } # [doc = "Bit 3 - Stop Bit Select"]
# [inline (always)]
# [must_use]
pub fn usbs0 (& mut self) -> USBS0_W < 3 > { USBS0_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn upm0 (& mut self) -> UPM0_W < 4 > { UPM0_W :: new (self) } # [doc = "Bits 6:7 - USART Mode Select"]
# [inline (always)]
# [must_use]
pub fn umsel0 (& mut self) -> UMSEL0_W < 6 > { UMSEL0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART0 Control and Status Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0c](index.html) module"]
pub struct UCSR0C_SPEC ; impl crate :: RegisterSpec for UCSR0C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0c::R](R) reader structure"]
impl crate :: Readable for UCSR0C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0c::W](W) writer structure"]
impl crate :: Writable for UCSR0C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0C to value 0"]
impl crate :: Resettable for UCSR0C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UDR0 (rw) register accessor: an alias for `Reg<UDR0_SPEC>`"]
pub type UDR0 = crate :: Reg < udr0 :: UDR0_SPEC > ; # [doc = "USART0 I/O Data Register"]
pub mod udr0 { # [doc = "Register `UDR0` reader"]
pub struct R (crate :: R < UDR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UDR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UDR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UDR0` writer"]
pub struct W (crate :: W < UDR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UDR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UDR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "USART0 I/O Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [udr0](index.html) module"]
pub struct UDR0_SPEC ; impl crate :: RegisterSpec for UDR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [udr0::R](R) reader structure"]
impl crate :: Readable for UDR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [udr0::W](W) writer structure"]
impl crate :: Writable for UDR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UDR0 to value 0"]
impl crate :: Resettable for UDR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct USART0_SPI { _marker : PhantomData < * const () > } unsafe impl Send for USART0_SPI { } impl USART0_SPI { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart0_spi :: RegisterBlock = 0xc0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart0_spi :: RegisterBlock { Self :: PTR } } impl Deref for USART0_SPI { type Target = usart0_spi :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART0_SPI { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART0_SPI") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod usart0_spi { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USART0 MSPIM Control and Status Register A"]
pub ucsr0a : UCSR0A , # [doc = "0x01 - USART0 MSPIM Control and Status Register B"]
pub ucsr0b : UCSR0B , # [doc = "0x02 - USART0 MSPIM Control and Status Register C"]
pub ucsr0c : UCSR0C , } # [doc = "UCSR0A (rw) register accessor: an alias for `Reg<UCSR0A_SPEC>`"]
pub type UCSR0A = crate :: Reg < ucsr0a :: UCSR0A_SPEC > ; # [doc = "USART0 MSPIM Control and Status Register A"]
pub mod ucsr0a { # [doc = "Register `UCSR0A` reader"]
pub struct R (crate :: R < UCSR0A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0A_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0A` writer"]
pub struct W (crate :: W < UCSR0A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0A_SPEC >) -> Self { W (writer) } } # [doc = "Field `UDRE0` reader - USART Data Register Empty"]
pub type UDRE0_R = crate :: BitReader < bool > ; # [doc = "Field `UDRE0` writer - USART Data Register Empty"]
pub type UDRE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `TXC0` reader - USART Transmit Complete"]
pub type TXC0_R = crate :: BitReader < bool > ; # [doc = "Field `TXC0` writer - USART Transmit Complete"]
pub type TXC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `RXC0` reader - USART Receive Complete"]
pub type RXC0_R = crate :: BitReader < bool > ; # [doc = "Field `RXC0` writer - USART Receive Complete"]
pub type RXC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; impl R { # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
pub fn udre0 (& self) -> UDRE0_R { UDRE0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USART Transmit Complete"]
# [inline (always)]
pub fn txc0 (& self) -> TXC0_R { TXC0_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
pub fn rxc0 (& self) -> RXC0_R { RXC0_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn udre0 (& mut self) -> UDRE0_W < 5 > { UDRE0_W :: new (self) } # [doc = "Bit 6 - USART Transmit Complete"]
# [inline (always)]
# [must_use]
pub fn txc0 (& mut self) -> TXC0_W < 6 > { TXC0_W :: new (self) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
# [must_use]
pub fn rxc0 (& mut self) -> RXC0_W < 7 > { RXC0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART0 MSPIM Control and Status Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0a](index.html) module"]
pub struct UCSR0A_SPEC ; impl crate :: RegisterSpec for UCSR0A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0a::R](R) reader structure"]
impl crate :: Readable for UCSR0A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0a::W](W) writer structure"]
impl crate :: Writable for UCSR0A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0A to value 0"]
impl crate :: Resettable for UCSR0A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR0B (rw) register accessor: an alias for `Reg<UCSR0B_SPEC>`"]
pub type UCSR0B = crate :: Reg < ucsr0b :: UCSR0B_SPEC > ; # [doc = "USART0 MSPIM Control and Status Register B"]
pub mod ucsr0b { # [doc = "Register `UCSR0B` reader"]
pub struct R (crate :: R < UCSR0B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0B_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0B` writer"]
pub struct W (crate :: W < UCSR0B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0B_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXEN0` reader - Transmitter Enable"]
pub type TXEN0_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN0` writer - Transmitter Enable"]
pub type TXEN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `RXEN0` reader - Receiver Enable"]
pub type RXEN0_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN0` writer - Receiver Enable"]
pub type RXEN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `UDRIE0` reader - USART Data Register Empty Interrupt Enable"]
pub type UDRIE0_R = crate :: BitReader < bool > ; # [doc = "Field `UDRIE0` writer - USART Data Register Empty Interrupt Enable"]
pub type UDRIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `TXCIE0` reader - TX Complete Interrupt Enable"]
pub type TXCIE0_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE0` writer - TX Complete Interrupt Enable"]
pub type TXCIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `RXCIE0` reader - RX Complete Interrupt Enable"]
pub type RXCIE0_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE0` writer - RX Complete Interrupt Enable"]
pub type RXCIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; impl R { # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen0 (& self) -> TXEN0_R { TXEN0_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen0 (& self) -> RXEN0_R { RXEN0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USART Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn udrie0 (& self) -> UDRIE0_R { UDRIE0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie0 (& self) -> TXCIE0_R { TXCIE0_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie0 (& self) -> RXCIE0_R { RXCIE0_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen0 (& mut self) -> TXEN0_W < 3 > { TXEN0_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen0 (& mut self) -> RXEN0_W < 4 > { RXEN0_W :: new (self) } # [doc = "Bit 5 - USART Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn udrie0 (& mut self) -> UDRIE0_W < 5 > { UDRIE0_W :: new (self) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie0 (& mut self) -> TXCIE0_W < 6 > { TXCIE0_W :: new (self) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie0 (& mut self) -> RXCIE0_W < 7 > { RXCIE0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART0 MSPIM Control and Status Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0b](index.html) module"]
pub struct UCSR0B_SPEC ; impl crate :: RegisterSpec for UCSR0B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0b::R](R) reader structure"]
impl crate :: Readable for UCSR0B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0b::W](W) writer structure"]
impl crate :: Writable for UCSR0B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0B to value 0"]
impl crate :: Resettable for UCSR0B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR0C (rw) register accessor: an alias for `Reg<UCSR0C_SPEC>`"]
pub type UCSR0C = crate :: Reg < ucsr0c :: UCSR0C_SPEC > ; # [doc = "USART0 MSPIM Control and Status Register C"]
pub mod ucsr0c { # [doc = "Register `UCSR0C` reader"]
pub struct R (crate :: R < UCSR0C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0C` writer"]
pub struct W (crate :: W < UCSR0C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCPOL0` reader - Clock Polarity"]
pub type UCPOL0_R = crate :: BitReader < bool > ; # [doc = "Field `UCPOL0` writer - Clock Polarity"]
pub type UCPOL0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0C_SPEC , bool , O > ; # [doc = "Field `UCPHA0` reader - Clock Phase"]
pub type UCPHA0_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA0` writer - Clock Phase"]
pub type UCPHA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0C_SPEC , bool , O > ; # [doc = "Field `UDORD0` reader - Data Order"]
pub type UDORD0_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD0` writer - Data Order"]
pub type UDORD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0C_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
pub fn ucpol0 (& self) -> UCPOL0_R { UCPOL0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Clock Phase"]
# [inline (always)]
pub fn ucpha0 (& self) -> UCPHA0_R { UCPHA0_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Data Order"]
# [inline (always)]
pub fn udord0 (& self) -> UDORD0_R { UDORD0_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
# [must_use]
pub fn ucpol0 (& mut self) -> UCPOL0_W < 0 > { UCPOL0_W :: new (self) } # [doc = "Bit 1 - Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha0 (& mut self) -> UCPHA0_W < 1 > { UCPHA0_W :: new (self) } # [doc = "Bit 2 - Data Order"]
# [inline (always)]
# [must_use]
pub fn udord0 (& mut self) -> UDORD0_W < 2 > { UDORD0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART0 MSPIM Control and Status Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0c](index.html) module"]
pub struct UCSR0C_SPEC ; impl crate :: RegisterSpec for UCSR0C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0c::R](R) reader structure"]
impl crate :: Readable for UCSR0C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0c::W](W) writer structure"]
impl crate :: Writable for UCSR0C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0C to value 0"]
impl crate :: Resettable for UCSR0C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "USART"]
pub struct USART1 { _marker : PhantomData < * const () > } unsafe impl Send for USART1 { } impl USART1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart1 :: RegisterBlock = 0xc8 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart1 :: RegisterBlock { Self :: PTR } } impl Deref for USART1 { type Target = usart1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART1") . finish () } } # [doc = "USART"]
pub mod usart1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USART1 Control and Status Register A"]
pub ucsr1a : UCSR1A , # [doc = "0x01 - USART1 Control and Status Register B"]
pub ucsr1b : UCSR1B , # [doc = "0x02 - USART1 Control and Status Register C"]
pub ucsr1c : UCSR1C , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - USART1 Baud Rate Register Bytes"]
pub ubrr1 : UBRR1 , # [doc = "0x06 - USART1 I/O Data Register"]
pub udr1 : UDR1 , } # [doc = "UBRR1 (rw) register accessor: an alias for `Reg<UBRR1_SPEC>`"]
pub type UBRR1 = crate :: Reg < ubrr1 :: UBRR1_SPEC > ; # [doc = "USART1 Baud Rate Register Bytes"]
pub mod ubrr1 { # [doc = "Register `UBRR1` reader"]
pub struct R (crate :: R < UBRR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UBRR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UBRR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UBRR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UBRR1` writer"]
pub struct W (crate :: W < UBRR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UBRR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UBRR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UBRR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "USART1 Baud Rate Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ubrr1](index.html) module"]
pub struct UBRR1_SPEC ; impl crate :: RegisterSpec for UBRR1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ubrr1::R](R) reader structure"]
impl crate :: Readable for UBRR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ubrr1::W](W) writer structure"]
impl crate :: Writable for UBRR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UBRR1 to value 0"]
impl crate :: Resettable for UBRR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR1A (rw) register accessor: an alias for `Reg<UCSR1A_SPEC>`"]
pub type UCSR1A = crate :: Reg < ucsr1a :: UCSR1A_SPEC > ; # [doc = "USART1 Control and Status Register A"]
pub mod ucsr1a { # [doc = "Register `UCSR1A` reader"]
pub struct R (crate :: R < UCSR1A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR1A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR1A_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR1A` writer"]
pub struct W (crate :: W < UCSR1A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR1A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR1A_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPCM1` reader - Multi-processor Communication Mode"]
pub type MPCM1_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM1` writer - Multi-processor Communication Mode"]
pub type MPCM1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `U2X1` reader - Double the USART Transmission Speed"]
pub type U2X1_R = crate :: BitReader < bool > ; # [doc = "Field `U2X1` writer - Double the USART Transmission Speed"]
pub type U2X1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `UPE1` reader - USART Parity Error"]
pub type UPE1_R = crate :: BitReader < bool > ; # [doc = "Field `UPE1` writer - USART Parity Error"]
pub type UPE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `DOR1` reader - Data OverRun"]
pub type DOR1_R = crate :: BitReader < bool > ; # [doc = "Field `DOR1` writer - Data OverRun"]
pub type DOR1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `FE1` reader - Frame Error"]
pub type FE1_R = crate :: BitReader < bool > ; # [doc = "Field `FE1` writer - Frame Error"]
pub type FE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `UDRE1` reader - USART Data Register Empty"]
pub type UDRE1_R = crate :: BitReader < bool > ; # [doc = "Field `UDRE1` writer - USART Data Register Empty"]
pub type UDRE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `TXC1` reader - USART Transmit Complete"]
pub type TXC1_R = crate :: BitReader < bool > ; # [doc = "Field `TXC1` writer - USART Transmit Complete"]
pub type TXC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `RXC1` reader - USART Receive Complete"]
pub type RXC1_R = crate :: BitReader < bool > ; # [doc = "Field `RXC1` writer - USART Receive Complete"]
pub type RXC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm1 (& self) -> MPCM1_R { MPCM1_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Double the USART Transmission Speed"]
# [inline (always)]
pub fn u2x1 (& self) -> U2X1_R { U2X1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - USART Parity Error"]
# [inline (always)]
pub fn upe1 (& self) -> UPE1_R { UPE1_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Data OverRun"]
# [inline (always)]
pub fn dor1 (& self) -> DOR1_R { DOR1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn fe1 (& self) -> FE1_R { FE1_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
pub fn udre1 (& self) -> UDRE1_R { UDRE1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USART Transmit Complete"]
# [inline (always)]
pub fn txc1 (& self) -> TXC1_R { TXC1_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
pub fn rxc1 (& self) -> RXC1_R { RXC1_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm1 (& mut self) -> MPCM1_W < 0 > { MPCM1_W :: new (self) } # [doc = "Bit 1 - Double the USART Transmission Speed"]
# [inline (always)]
# [must_use]
pub fn u2x1 (& mut self) -> U2X1_W < 1 > { U2X1_W :: new (self) } # [doc = "Bit 2 - USART Parity Error"]
# [inline (always)]
# [must_use]
pub fn upe1 (& mut self) -> UPE1_W < 2 > { UPE1_W :: new (self) } # [doc = "Bit 3 - Data OverRun"]
# [inline (always)]
# [must_use]
pub fn dor1 (& mut self) -> DOR1_W < 3 > { DOR1_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn fe1 (& mut self) -> FE1_W < 4 > { FE1_W :: new (self) } # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn udre1 (& mut self) -> UDRE1_W < 5 > { UDRE1_W :: new (self) } # [doc = "Bit 6 - USART Transmit Complete"]
# [inline (always)]
# [must_use]
pub fn txc1 (& mut self) -> TXC1_W < 6 > { TXC1_W :: new (self) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
# [must_use]
pub fn rxc1 (& mut self) -> RXC1_W < 7 > { RXC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART1 Control and Status Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr1a](index.html) module"]
pub struct UCSR1A_SPEC ; impl crate :: RegisterSpec for UCSR1A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr1a::R](R) reader structure"]
impl crate :: Readable for UCSR1A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr1a::W](W) writer structure"]
impl crate :: Writable for UCSR1A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR1A to value 0"]
impl crate :: Resettable for UCSR1A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR1B (rw) register accessor: an alias for `Reg<UCSR1B_SPEC>`"]
pub type UCSR1B = crate :: Reg < ucsr1b :: UCSR1B_SPEC > ; # [doc = "USART1 Control and Status Register B"]
pub mod ucsr1b { # [doc = "Register `UCSR1B` reader"]
pub struct R (crate :: R < UCSR1B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR1B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR1B_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR1B` writer"]
pub struct W (crate :: W < UCSR1B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR1B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR1B_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB81` reader - Transmit Data Bit 8"]
pub type TXB81_R = crate :: BitReader < bool > ; # [doc = "Field `TXB81` writer - Transmit Data Bit 8"]
pub type TXB81_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `RXB81` reader - Receive Data Bit 8"]
pub type RXB81_R = crate :: BitReader < bool > ; # [doc = "Field `RXB81` writer - Receive Data Bit 8"]
pub type RXB81_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `UCSZ12` reader - Character Size"]
pub type UCSZ12_R = crate :: BitReader < bool > ; # [doc = "Field `UCSZ12` writer - Character Size"]
pub type UCSZ12_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `TXEN1` reader - Transmitter Enable"]
pub type TXEN1_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN1` writer - Transmitter Enable"]
pub type TXEN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `RXEN1` reader - Receiver Enable"]
pub type RXEN1_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN1` writer - Receiver Enable"]
pub type RXEN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `UDRIE1` reader - USART Data Register Empty Interrupt Enable"]
pub type UDRIE1_R = crate :: BitReader < bool > ; # [doc = "Field `UDRIE1` writer - USART Data Register Empty Interrupt Enable"]
pub type UDRIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `TXCIE1` reader - TX Complete Interrupt Enable"]
pub type TXCIE1_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE1` writer - TX Complete Interrupt Enable"]
pub type TXCIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `RXCIE1` reader - RX Complete Interrupt Enable"]
pub type RXCIE1_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE1` writer - RX Complete Interrupt Enable"]
pub type RXCIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit Data Bit 8"]
# [inline (always)]
pub fn txb81 (& self) -> TXB81_R { TXB81_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Receive Data Bit 8"]
# [inline (always)]
pub fn rxb81 (& self) -> RXB81_R { RXB81_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Character Size"]
# [inline (always)]
pub fn ucsz12 (& self) -> UCSZ12_R { UCSZ12_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen1 (& self) -> TXEN1_R { TXEN1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen1 (& self) -> RXEN1_R { RXEN1_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USART Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn udrie1 (& self) -> UDRIE1_R { UDRIE1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie1 (& self) -> TXCIE1_R { TXCIE1_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie1 (& self) -> RXCIE1_R { RXCIE1_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit Data Bit 8"]
# [inline (always)]
# [must_use]
pub fn txb81 (& mut self) -> TXB81_W < 0 > { TXB81_W :: new (self) } # [doc = "Bit 1 - Receive Data Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb81 (& mut self) -> RXB81_W < 1 > { RXB81_W :: new (self) } # [doc = "Bit 2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn ucsz12 (& mut self) -> UCSZ12_W < 2 > { UCSZ12_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen1 (& mut self) -> TXEN1_W < 3 > { TXEN1_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen1 (& mut self) -> RXEN1_W < 4 > { RXEN1_W :: new (self) } # [doc = "Bit 5 - USART Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn udrie1 (& mut self) -> UDRIE1_W < 5 > { UDRIE1_W :: new (self) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie1 (& mut self) -> TXCIE1_W < 6 > { TXCIE1_W :: new (self) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie1 (& mut self) -> RXCIE1_W < 7 > { RXCIE1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART1 Control and Status Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr1b](index.html) module"]
pub struct UCSR1B_SPEC ; impl crate :: RegisterSpec for UCSR1B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr1b::R](R) reader structure"]
impl crate :: Readable for UCSR1B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr1b::W](W) writer structure"]
impl crate :: Writable for UCSR1B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR1B to value 0"]
impl crate :: Resettable for UCSR1B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR1C (rw) register accessor: an alias for `Reg<UCSR1C_SPEC>`"]
pub type UCSR1C = crate :: Reg < ucsr1c :: UCSR1C_SPEC > ; # [doc = "USART1 Control and Status Register C"]
pub mod ucsr1c { # [doc = "Register `UCSR1C` reader"]
pub struct R (crate :: R < UCSR1C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR1C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR1C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR1C` writer"]
pub struct W (crate :: W < UCSR1C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR1C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR1C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCPOL1` reader - Clock Polarity"]
pub type UCPOL1_R = crate :: BitReader < UCPOL1_A > ; # [doc = "Clock Polarity\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum UCPOL1_A { # [doc = "0: Rising XCKn Edge (Transmitted Data Changed), Falling XCKn Edge (Received Data Sampled)"]
RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED = 0 , # [doc = "1: Falling XCKn Edge (Transmitted Data Changed), Rising XCKn Edge (Received Data Sampled)"]
FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED = 1 , } impl From < UCPOL1_A > for bool { # [inline (always)]
fn from (variant : UCPOL1_A) -> Self { variant as u8 != 0 } } impl UCPOL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCPOL1_A { match self . bits { false => UCPOL1_A :: RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED , true => UCPOL1_A :: FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED , } } # [doc = "Checks if the value of the field is `RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED`"]
# [inline (always)]
pub fn is_rising_xckn_edge_transmitted_data_changed_falling_xckn_edge_received_data_sampled (& self) -> bool { * self == UCPOL1_A :: RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED } # [doc = "Checks if the value of the field is `FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED`"]
# [inline (always)]
pub fn is_falling_xckn_edge_transmitted_data_changed_rising_xckn_edge_received_data_sampled (& self) -> bool { * self == UCPOL1_A :: FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED } } # [doc = "Field `UCPOL1` writer - Clock Polarity"]
pub type UCPOL1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1C_SPEC , UCPOL1_A , O > ; impl < 'a , const O : u8 > UCPOL1_W < 'a , O > { # [doc = "Rising XCKn Edge (Transmitted Data Changed), Falling XCKn Edge (Received Data Sampled)"]
# [inline (always)]
pub fn rising_xckn_edge_transmitted_data_changed_falling_xckn_edge_received_data_sampled (self) -> & 'a mut W { self . variant (UCPOL1_A :: RISING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_FALLING_XCKN_EDGE_RECEIVED_DATA_SAMPLED) } # [doc = "Falling XCKn Edge (Transmitted Data Changed), Rising XCKn Edge (Received Data Sampled)"]
# [inline (always)]
pub fn falling_xckn_edge_transmitted_data_changed_rising_xckn_edge_received_data_sampled (self) -> & 'a mut W { self . variant (UCPOL1_A :: FALLING_XCKN_EDGE_TRANSMITTED_DATA_CHANGED_RISING_XCKN_EDGE_RECEIVED_DATA_SAMPLED) } } # [doc = "Field `UCSZ1` reader - Character Size"]
pub type UCSZ1_R = crate :: FieldReader < u8 , UCSZ1_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum UCSZ1_A { # [doc = "0: 5-bit"]
_5_BIT = 0 , # [doc = "1: 6-bit"]
_6_BIT = 1 , # [doc = "2: 7-bit"]
_7_BIT = 2 , # [doc = "3: 8-bit"]
_8_BIT = 3 , } impl From < UCSZ1_A > for u8 { # [inline (always)]
fn from (variant : UCSZ1_A) -> Self { variant as _ } } impl UCSZ1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UCSZ1_A { match self . bits { 0 => UCSZ1_A :: _5_BIT , 1 => UCSZ1_A :: _6_BIT , 2 => UCSZ1_A :: _7_BIT , 3 => UCSZ1_A :: _8_BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_5_BIT`"]
# [inline (always)]
pub fn is_5_bit (& self) -> bool { * self == UCSZ1_A :: _5_BIT } # [doc = "Checks if the value of the field is `_6_BIT`"]
# [inline (always)]
pub fn is_6_bit (& self) -> bool { * self == UCSZ1_A :: _6_BIT } # [doc = "Checks if the value of the field is `_7_BIT`"]
# [inline (always)]
pub fn is_7_bit (& self) -> bool { * self == UCSZ1_A :: _7_BIT } # [doc = "Checks if the value of the field is `_8_BIT`"]
# [inline (always)]
pub fn is_8_bit (& self) -> bool { * self == UCSZ1_A :: _8_BIT } } # [doc = "Field `UCSZ1` writer - Character Size"]
pub type UCSZ1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , UCSR1C_SPEC , u8 , UCSZ1_A , 2 , O > ; impl < 'a , const O : u8 > UCSZ1_W < 'a , O > { # [doc = "5-bit"]
# [inline (always)]
pub fn _5_bit (self) -> & 'a mut W { self . variant (UCSZ1_A :: _5_BIT) } # [doc = "6-bit"]
# [inline (always)]
pub fn _6_bit (self) -> & 'a mut W { self . variant (UCSZ1_A :: _6_BIT) } # [doc = "7-bit"]
# [inline (always)]
pub fn _7_bit (self) -> & 'a mut W { self . variant (UCSZ1_A :: _7_BIT) } # [doc = "8-bit"]
# [inline (always)]
pub fn _8_bit (self) -> & 'a mut W { self . variant (UCSZ1_A :: _8_BIT) } } # [doc = "Field `USBS1` reader - Stop Bit Select"]
pub type USBS1_R = crate :: BitReader < USBS1_A > ; # [doc = "Stop Bit Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum USBS1_A { # [doc = "0: 1-bit"]
_1_BIT = 0 , # [doc = "1: 2-bit"]
_2_BIT = 1 , } impl From < USBS1_A > for bool { # [inline (always)]
fn from (variant : USBS1_A) -> Self { variant as u8 != 0 } } impl USBS1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> USBS1_A { match self . bits { false => USBS1_A :: _1_BIT , true => USBS1_A :: _2_BIT , } } # [doc = "Checks if the value of the field is `_1_BIT`"]
# [inline (always)]
pub fn is_1_bit (& self) -> bool { * self == USBS1_A :: _1_BIT } # [doc = "Checks if the value of the field is `_2_BIT`"]
# [inline (always)]
pub fn is_2_bit (& self) -> bool { * self == USBS1_A :: _2_BIT } } # [doc = "Field `USBS1` writer - Stop Bit Select"]
pub type USBS1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1C_SPEC , USBS1_A , O > ; impl < 'a , const O : u8 > USBS1_W < 'a , O > { # [doc = "1-bit"]
# [inline (always)]
pub fn _1_bit (self) -> & 'a mut W { self . variant (USBS1_A :: _1_BIT) } # [doc = "2-bit"]
# [inline (always)]
pub fn _2_bit (self) -> & 'a mut W { self . variant (USBS1_A :: _2_BIT) } } # [doc = "Field `UPM1` reader - Parity Mode"]
pub type UPM1_R = crate :: FieldReader < u8 , UPM1_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum UPM1_A { # [doc = "0: Disabled"]
DISABLED = 0 , # [doc = "2: Enabled, Even Parity"]
ENABLED_EVEN_PARITY = 2 , # [doc = "3: Enabled, Odd Parity"]
ENABLED_ODD_PARITY = 3 , } impl From < UPM1_A > for u8 { # [inline (always)]
fn from (variant : UPM1_A) -> Self { variant as _ } } impl UPM1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UPM1_A { match self . bits { 0 => UPM1_A :: DISABLED , 2 => UPM1_A :: ENABLED_EVEN_PARITY , 3 => UPM1_A :: ENABLED_ODD_PARITY , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == UPM1_A :: DISABLED } # [doc = "Checks if the value of the field is `ENABLED_EVEN_PARITY`"]
# [inline (always)]
pub fn is_enabled_even_parity (& self) -> bool { * self == UPM1_A :: ENABLED_EVEN_PARITY } # [doc = "Checks if the value of the field is `ENABLED_ODD_PARITY`"]
# [inline (always)]
pub fn is_enabled_odd_parity (& self) -> bool { * self == UPM1_A :: ENABLED_ODD_PARITY } } # [doc = "Field `UPM1` writer - Parity Mode"]
pub type UPM1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , UCSR1C_SPEC , u8 , UPM1_A , 2 , O > ; impl < 'a , const O : u8 > UPM1_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (UPM1_A :: DISABLED) } # [doc = "Enabled, Even Parity"]
# [inline (always)]
pub fn enabled_even_parity (self) -> & 'a mut W { self . variant (UPM1_A :: ENABLED_EVEN_PARITY) } # [doc = "Enabled, Odd Parity"]
# [inline (always)]
pub fn enabled_odd_parity (self) -> & 'a mut W { self . variant (UPM1_A :: ENABLED_ODD_PARITY) } } # [doc = "Field `UMSEL1` reader - USART Mode Select"]
pub type UMSEL1_R = crate :: FieldReader < u8 , UMSEL1_A > ; # [doc = "USART Mode Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum UMSEL1_A { # [doc = "0: Asynchronous USART"]
ASYNCHRONOUS_USART = 0 , # [doc = "1: Synchronous USART"]
SYNCHRONOUS_USART = 1 , # [doc = "3: Master SPI (MSPIM)"]
MASTER_SPI_MSPIM = 3 , } impl From < UMSEL1_A > for u8 { # [inline (always)]
fn from (variant : UMSEL1_A) -> Self { variant as _ } } impl UMSEL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UMSEL1_A { match self . bits { 0 => UMSEL1_A :: ASYNCHRONOUS_USART , 1 => UMSEL1_A :: SYNCHRONOUS_USART , 3 => UMSEL1_A :: MASTER_SPI_MSPIM , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS_USART`"]
# [inline (always)]
pub fn is_asynchronous_usart (& self) -> bool { * self == UMSEL1_A :: ASYNCHRONOUS_USART } # [doc = "Checks if the value of the field is `SYNCHRONOUS_USART`"]
# [inline (always)]
pub fn is_synchronous_usart (& self) -> bool { * self == UMSEL1_A :: SYNCHRONOUS_USART } # [doc = "Checks if the value of the field is `MASTER_SPI_MSPIM`"]
# [inline (always)]
pub fn is_master_spi_mspim (& self) -> bool { * self == UMSEL1_A :: MASTER_SPI_MSPIM } } # [doc = "Field `UMSEL1` writer - USART Mode Select"]
pub type UMSEL1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , UCSR1C_SPEC , u8 , UMSEL1_A , 2 , O > ; impl < 'a , const O : u8 > UMSEL1_W < 'a , O > { # [doc = "Asynchronous USART"]
# [inline (always)]
pub fn asynchronous_usart (self) -> & 'a mut W { self . variant (UMSEL1_A :: ASYNCHRONOUS_USART) } # [doc = "Synchronous USART"]
# [inline (always)]
pub fn synchronous_usart (self) -> & 'a mut W { self . variant (UMSEL1_A :: SYNCHRONOUS_USART) } # [doc = "Master SPI (MSPIM)"]
# [inline (always)]
pub fn master_spi_mspim (self) -> & 'a mut W { self . variant (UMSEL1_A :: MASTER_SPI_MSPIM) } } impl R { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
pub fn ucpol1 (& self) -> UCPOL1_R { UCPOL1_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Character Size"]
# [inline (always)]
pub fn ucsz1 (& self) -> UCSZ1_R { UCSZ1_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Stop Bit Select"]
# [inline (always)]
pub fn usbs1 (& self) -> USBS1_R { USBS1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn upm1 (& self) -> UPM1_R { UPM1_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - USART Mode Select"]
# [inline (always)]
pub fn umsel1 (& self) -> UMSEL1_R { UMSEL1_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
# [must_use]
pub fn ucpol1 (& mut self) -> UCPOL1_W < 0 > { UCPOL1_W :: new (self) } # [doc = "Bits 1:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn ucsz1 (& mut self) -> UCSZ1_W < 1 > { UCSZ1_W :: new (self) } # [doc = "Bit 3 - Stop Bit Select"]
# [inline (always)]
# [must_use]
pub fn usbs1 (& mut self) -> USBS1_W < 3 > { USBS1_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn upm1 (& mut self) -> UPM1_W < 4 > { UPM1_W :: new (self) } # [doc = "Bits 6:7 - USART Mode Select"]
# [inline (always)]
# [must_use]
pub fn umsel1 (& mut self) -> UMSEL1_W < 6 > { UMSEL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART1 Control and Status Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr1c](index.html) module"]
pub struct UCSR1C_SPEC ; impl crate :: RegisterSpec for UCSR1C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr1c::R](R) reader structure"]
impl crate :: Readable for UCSR1C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr1c::W](W) writer structure"]
impl crate :: Writable for UCSR1C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR1C to value 0"]
impl crate :: Resettable for UCSR1C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UDR1 (rw) register accessor: an alias for `Reg<UDR1_SPEC>`"]
pub type UDR1 = crate :: Reg < udr1 :: UDR1_SPEC > ; # [doc = "USART1 I/O Data Register"]
pub mod udr1 { # [doc = "Register `UDR1` reader"]
pub struct R (crate :: R < UDR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UDR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UDR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `UDR1` writer"]
pub struct W (crate :: W < UDR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UDR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UDR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "USART1 I/O Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [udr1](index.html) module"]
pub struct UDR1_SPEC ; impl crate :: RegisterSpec for UDR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [udr1::R](R) reader structure"]
impl crate :: Readable for UDR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [udr1::W](W) writer structure"]
impl crate :: Writable for UDR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UDR1 to value 0"]
impl crate :: Resettable for UDR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct USART1_SPI { _marker : PhantomData < * const () > } unsafe impl Send for USART1_SPI { } impl USART1_SPI { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart1_spi :: RegisterBlock = 0xc8 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart1_spi :: RegisterBlock { Self :: PTR } } impl Deref for USART1_SPI { type Target = usart1_spi :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART1_SPI { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART1_SPI") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod usart1_spi { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USART1 MSPIM Control and Status Register A"]
pub ucsr1a : UCSR1A , # [doc = "0x01 - USART1 MSPIM Control and Status Register B"]
pub ucsr1b : UCSR1B , # [doc = "0x02 - USART1 MSPIM Control and Status Register C"]
pub ucsr1c : UCSR1C , } # [doc = "UCSR1A (rw) register accessor: an alias for `Reg<UCSR1A_SPEC>`"]
pub type UCSR1A = crate :: Reg < ucsr1a :: UCSR1A_SPEC > ; # [doc = "USART1 MSPIM Control and Status Register A"]
pub mod ucsr1a { # [doc = "Register `UCSR1A` reader"]
pub struct R (crate :: R < UCSR1A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR1A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR1A_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR1A` writer"]
pub struct W (crate :: W < UCSR1A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR1A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR1A_SPEC >) -> Self { W (writer) } } # [doc = "Field `UDRE1` reader - USART Data Register Empty"]
pub type UDRE1_R = crate :: BitReader < bool > ; # [doc = "Field `UDRE1` writer - USART Data Register Empty"]
pub type UDRE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `TXC1` reader - USART Transmit Complete"]
pub type TXC1_R = crate :: BitReader < bool > ; # [doc = "Field `TXC1` writer - USART Transmit Complete"]
pub type TXC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; # [doc = "Field `RXC1` reader - USART Receive Complete"]
pub type RXC1_R = crate :: BitReader < bool > ; # [doc = "Field `RXC1` writer - USART Receive Complete"]
pub type RXC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1A_SPEC , bool , O > ; impl R { # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
pub fn udre1 (& self) -> UDRE1_R { UDRE1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USART Transmit Complete"]
# [inline (always)]
pub fn txc1 (& self) -> TXC1_R { TXC1_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
pub fn rxc1 (& self) -> RXC1_R { RXC1_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn udre1 (& mut self) -> UDRE1_W < 5 > { UDRE1_W :: new (self) } # [doc = "Bit 6 - USART Transmit Complete"]
# [inline (always)]
# [must_use]
pub fn txc1 (& mut self) -> TXC1_W < 6 > { TXC1_W :: new (self) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
# [must_use]
pub fn rxc1 (& mut self) -> RXC1_W < 7 > { RXC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART1 MSPIM Control and Status Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr1a](index.html) module"]
pub struct UCSR1A_SPEC ; impl crate :: RegisterSpec for UCSR1A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr1a::R](R) reader structure"]
impl crate :: Readable for UCSR1A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr1a::W](W) writer structure"]
impl crate :: Writable for UCSR1A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR1A to value 0"]
impl crate :: Resettable for UCSR1A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR1B (rw) register accessor: an alias for `Reg<UCSR1B_SPEC>`"]
pub type UCSR1B = crate :: Reg < ucsr1b :: UCSR1B_SPEC > ; # [doc = "USART1 MSPIM Control and Status Register B"]
pub mod ucsr1b { # [doc = "Register `UCSR1B` reader"]
pub struct R (crate :: R < UCSR1B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR1B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR1B_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR1B` writer"]
pub struct W (crate :: W < UCSR1B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR1B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR1B_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXEN1` reader - Transmitter Enable"]
pub type TXEN1_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN1` writer - Transmitter Enable"]
pub type TXEN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `RXEN1` reader - Receiver Enable"]
pub type RXEN1_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN1` writer - Receiver Enable"]
pub type RXEN1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `UDRIE1` reader - USART Data Register Empty Interrupt Enable"]
pub type UDRIE1_R = crate :: BitReader < bool > ; # [doc = "Field `UDRIE1` writer - USART Data Register Empty Interrupt Enable"]
pub type UDRIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `TXCIE1` reader - TX Complete Interrupt Enable"]
pub type TXCIE1_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE1` writer - TX Complete Interrupt Enable"]
pub type TXCIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; # [doc = "Field `RXCIE1` reader - RX Complete Interrupt Enable"]
pub type RXCIE1_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE1` writer - RX Complete Interrupt Enable"]
pub type RXCIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1B_SPEC , bool , O > ; impl R { # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen1 (& self) -> TXEN1_R { TXEN1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen1 (& self) -> RXEN1_R { RXEN1_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USART Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn udrie1 (& self) -> UDRIE1_R { UDRIE1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie1 (& self) -> TXCIE1_R { TXCIE1_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie1 (& self) -> RXCIE1_R { RXCIE1_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen1 (& mut self) -> TXEN1_W < 3 > { TXEN1_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen1 (& mut self) -> RXEN1_W < 4 > { RXEN1_W :: new (self) } # [doc = "Bit 5 - USART Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn udrie1 (& mut self) -> UDRIE1_W < 5 > { UDRIE1_W :: new (self) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie1 (& mut self) -> TXCIE1_W < 6 > { TXCIE1_W :: new (self) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie1 (& mut self) -> RXCIE1_W < 7 > { RXCIE1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART1 MSPIM Control and Status Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr1b](index.html) module"]
pub struct UCSR1B_SPEC ; impl crate :: RegisterSpec for UCSR1B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr1b::R](R) reader structure"]
impl crate :: Readable for UCSR1B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr1b::W](W) writer structure"]
impl crate :: Writable for UCSR1B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR1B to value 0"]
impl crate :: Resettable for UCSR1B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR1C (rw) register accessor: an alias for `Reg<UCSR1C_SPEC>`"]
pub type UCSR1C = crate :: Reg < ucsr1c :: UCSR1C_SPEC > ; # [doc = "USART1 MSPIM Control and Status Register C"]
pub mod ucsr1c { # [doc = "Register `UCSR1C` reader"]
pub struct R (crate :: R < UCSR1C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR1C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR1C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR1C` writer"]
pub struct W (crate :: W < UCSR1C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR1C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR1C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCPOL1` reader - Clock Polarity"]
pub type UCPOL1_R = crate :: BitReader < bool > ; # [doc = "Field `UCPOL1` writer - Clock Polarity"]
pub type UCPOL1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1C_SPEC , bool , O > ; # [doc = "Field `UCPHA1` reader - Clock Phase"]
pub type UCPHA1_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA1` writer - Clock Phase"]
pub type UCPHA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1C_SPEC , bool , O > ; # [doc = "Field `UDORD1` reader - Data Order"]
pub type UDORD1_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD1` writer - Data Order"]
pub type UDORD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR1C_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
pub fn ucpol1 (& self) -> UCPOL1_R { UCPOL1_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Clock Phase"]
# [inline (always)]
pub fn ucpha1 (& self) -> UCPHA1_R { UCPHA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Data Order"]
# [inline (always)]
pub fn udord1 (& self) -> UDORD1_R { UDORD1_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
# [must_use]
pub fn ucpol1 (& mut self) -> UCPOL1_W < 0 > { UCPOL1_W :: new (self) } # [doc = "Bit 1 - Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha1 (& mut self) -> UCPHA1_W < 1 > { UCPHA1_W :: new (self) } # [doc = "Bit 2 - Data Order"]
# [inline (always)]
# [must_use]
pub fn udord1 (& mut self) -> UDORD1_W < 2 > { UDORD1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART1 MSPIM Control and Status Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr1c](index.html) module"]
pub struct UCSR1C_SPEC ; impl crate :: RegisterSpec for UCSR1C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr1c::R](R) reader structure"]
impl crate :: Readable for UCSR1C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr1c::W](W) writer structure"]
impl crate :: Writable for UCSR1C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR1C to value 0"]
impl crate :: Resettable for UCSR1C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Watchdog Timer"]
pub struct WDT { _marker : PhantomData < * const () > } unsafe impl Send for WDT { } impl WDT { # [doc = r"Pointer to the register block"]
pub const PTR : * const wdt :: RegisterBlock = 0x60 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wdt :: RegisterBlock { Self :: PTR } } impl Deref for WDT { type Target = wdt :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WDT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WDT") . finish () } } # [doc = "Watchdog Timer"]
pub mod wdt { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Watchdog Timer Control Register"]
pub wdtcsr : WDTCSR , } # [doc = "WDTCSR (rw) register accessor: an alias for `Reg<WDTCSR_SPEC>`"]
pub type WDTCSR = crate :: Reg < wdtcsr :: WDTCSR_SPEC > ; # [doc = "Watchdog Timer Control Register"]
pub mod wdtcsr { # [doc = "Register `WDTCSR` reader"]
pub struct R (crate :: R < WDTCSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WDTCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WDTCSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WDTCSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `WDTCSR` writer"]
pub struct W (crate :: W < WDTCSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WDTCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WDTCSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WDTCSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `WDP` reader - Watchdog Timer Prescaler Bits"]
pub type WDP_R = crate :: FieldReader < u8 , WDP_A > ; # [doc = "Watchdog Timer Prescaler Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WDP_A { # [doc = "0: Oscillator Cycles 2K"]
OSCILLATOR_CYCLES_2K = 0 , # [doc = "1: Oscillator Cycles 4K"]
OSCILLATOR_CYCLES_4K = 1 , # [doc = "2: Oscillator Cycles 8K"]
OSCILLATOR_CYCLES_8K = 2 , # [doc = "3: Oscillator Cycles 16K"]
OSCILLATOR_CYCLES_16K = 3 , # [doc = "4: Oscillator Cycles 32K"]
OSCILLATOR_CYCLES_32K = 4 , # [doc = "5: Oscillator Cycles 64K"]
OSCILLATOR_CYCLES_64K = 5 , # [doc = "6: Oscillator Cycles 128K"]
OSCILLATOR_CYCLES_128K = 6 , # [doc = "7: Oscillator Cycles 256K"]
OSCILLATOR_CYCLES_256K = 7 , } impl From < WDP_A > for u8 { # [inline (always)]
fn from (variant : WDP_A) -> Self { variant as _ } } impl WDP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WDP_A > { match self . bits { 0 => Some (WDP_A :: OSCILLATOR_CYCLES_2K) , 1 => Some (WDP_A :: OSCILLATOR_CYCLES_4K) , 2 => Some (WDP_A :: OSCILLATOR_CYCLES_8K) , 3 => Some (WDP_A :: OSCILLATOR_CYCLES_16K) , 4 => Some (WDP_A :: OSCILLATOR_CYCLES_32K) , 5 => Some (WDP_A :: OSCILLATOR_CYCLES_64K) , 6 => Some (WDP_A :: OSCILLATOR_CYCLES_128K) , 7 => Some (WDP_A :: OSCILLATOR_CYCLES_256K) , _ => None , } } # [doc = "Checks if the value of the field is `OSCILLATOR_CYCLES_2K`"]
# [inline (always)]
pub fn is_oscillator_cycles_2k (& self) -> bool { * self == WDP_A :: OSCILLATOR_CYCLES_2K } # [doc = "Checks if the value of the field is `OSCILLATOR_CYCLES_4K`"]
# [inline (always)]
pub fn is_oscillator_cycles_4k (& self) -> bool { * self == WDP_A :: OSCILLATOR_CYCLES_4K } # [doc = "Checks if the value of the field is `OSCILLATOR_CYCLES_8K`"]
# [inline (always)]
pub fn is_oscillator_cycles_8k (& self) -> bool { * self == WDP_A :: OSCILLATOR_CYCLES_8K } # [doc = "Checks if the value of the field is `OSCILLATOR_CYCLES_16K`"]
# [inline (always)]
pub fn is_oscillator_cycles_16k (& self) -> bool { * self == WDP_A :: OSCILLATOR_CYCLES_16K } # [doc = "Checks if the value of the field is `OSCILLATOR_CYCLES_32K`"]
# [inline (always)]
pub fn is_oscillator_cycles_32k (& self) -> bool { * self == WDP_A :: OSCILLATOR_CYCLES_32K } # [doc = "Checks if the value of the field is `OSCILLATOR_CYCLES_64K`"]
# [inline (always)]
pub fn is_oscillator_cycles_64k (& self) -> bool { * self == WDP_A :: OSCILLATOR_CYCLES_64K } # [doc = "Checks if the value of the field is `OSCILLATOR_CYCLES_128K`"]
# [inline (always)]
pub fn is_oscillator_cycles_128k (& self) -> bool { * self == WDP_A :: OSCILLATOR_CYCLES_128K } # [doc = "Checks if the value of the field is `OSCILLATOR_CYCLES_256K`"]
# [inline (always)]
pub fn is_oscillator_cycles_256k (& self) -> bool { * self == WDP_A :: OSCILLATOR_CYCLES_256K } } # [doc = "Field `WDP` writer - Watchdog Timer Prescaler Bits"]
pub type WDP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , WDTCSR_SPEC , u8 , WDP_A , 6 , O > ; impl < 'a , const O : u8 > WDP_W < 'a , O > { # [doc = "Oscillator Cycles 2K"]
# [inline (always)]
pub fn oscillator_cycles_2k (self) -> & 'a mut W { self . variant (WDP_A :: OSCILLATOR_CYCLES_2K) } # [doc = "Oscillator Cycles 4K"]
# [inline (always)]
pub fn oscillator_cycles_4k (self) -> & 'a mut W { self . variant (WDP_A :: OSCILLATOR_CYCLES_4K) } # [doc = "Oscillator Cycles 8K"]
# [inline (always)]
pub fn oscillator_cycles_8k (self) -> & 'a mut W { self . variant (WDP_A :: OSCILLATOR_CYCLES_8K) } # [doc = "Oscillator Cycles 16K"]
# [inline (always)]
pub fn oscillator_cycles_16k (self) -> & 'a mut W { self . variant (WDP_A :: OSCILLATOR_CYCLES_16K) } # [doc = "Oscillator Cycles 32K"]
# [inline (always)]
pub fn oscillator_cycles_32k (self) -> & 'a mut W { self . variant (WDP_A :: OSCILLATOR_CYCLES_32K) } # [doc = "Oscillator Cycles 64K"]
# [inline (always)]
pub fn oscillator_cycles_64k (self) -> & 'a mut W { self . variant (WDP_A :: OSCILLATOR_CYCLES_64K) } # [doc = "Oscillator Cycles 128K"]
# [inline (always)]
pub fn oscillator_cycles_128k (self) -> & 'a mut W { self . variant (WDP_A :: OSCILLATOR_CYCLES_128K) } # [doc = "Oscillator Cycles 256K"]
# [inline (always)]
pub fn oscillator_cycles_256k (self) -> & 'a mut W { self . variant (WDP_A :: OSCILLATOR_CYCLES_256K) } } # [doc = "Field `WDE` reader - Watch Dog Enable"]
pub type WDE_R = crate :: BitReader < bool > ; # [doc = "Field `WDE` writer - Watch Dog Enable"]
pub type WDE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WDTCSR_SPEC , bool , O > ; # [doc = "Field `WDCE` reader - Watchdog Change Enable"]
pub type WDCE_R = crate :: BitReader < bool > ; # [doc = "Field `WDCE` writer - Watchdog Change Enable"]
pub type WDCE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WDTCSR_SPEC , bool , O > ; # [doc = "Field `WDIE` reader - Watchdog Timeout Interrupt Enable"]
pub type WDIE_R = crate :: BitReader < bool > ; # [doc = "Field `WDIE` writer - Watchdog Timeout Interrupt Enable"]
pub type WDIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WDTCSR_SPEC , bool , O > ; # [doc = "Field `WDIF` reader - Watchdog Timeout Interrupt Flag"]
pub type WDIF_R = crate :: BitReader < bool > ; # [doc = "Field `WDIF` writer - Watchdog Timeout Interrupt Flag"]
pub type WDIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WDTCSR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:5 - Watchdog Timer Prescaler Bits"]
# [inline (always)]
pub fn wdp (& self) -> WDP_R { WDP_R :: new (self . bits & 0x3f) } # [doc = "Bit 3 - Watch Dog Enable"]
# [inline (always)]
pub fn wde (& self) -> WDE_R { WDE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Watchdog Change Enable"]
# [inline (always)]
pub fn wdce (& self) -> WDCE_R { WDCE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Watchdog Timeout Interrupt Enable"]
# [inline (always)]
pub fn wdie (& self) -> WDIE_R { WDIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Watchdog Timeout Interrupt Flag"]
# [inline (always)]
pub fn wdif (& self) -> WDIF_R { WDIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - Watchdog Timer Prescaler Bits"]
# [inline (always)]
# [must_use]
pub fn wdp (& mut self) -> WDP_W < 0 > { WDP_W :: new (self) } # [doc = "Bit 3 - Watch Dog Enable"]
# [inline (always)]
# [must_use]
pub fn wde (& mut self) -> WDE_W < 3 > { WDE_W :: new (self) } # [doc = "Bit 4 - Watchdog Change Enable"]
# [inline (always)]
# [must_use]
pub fn wdce (& mut self) -> WDCE_W < 4 > { WDCE_W :: new (self) } # [doc = "Bit 6 - Watchdog Timeout Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn wdie (& mut self) -> WDIE_W < 6 > { WDIE_W :: new (self) } # [doc = "Bit 7 - Watchdog Timeout Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn wdif (& mut self) -> WDIF_W < 7 > { WDIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Watchdog Timer Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wdtcsr](index.html) module"]
pub struct WDTCSR_SPEC ; impl crate :: RegisterSpec for WDTCSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [wdtcsr::R](R) reader structure"]
impl crate :: Readable for WDTCSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wdtcsr::W](W) writer structure"]
impl crate :: Writable for WDTCSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WDTCSR to value 0"]
impl crate :: Resettable for WDTCSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "AC"]
pub AC : AC , # [doc = "ADC"]
pub ADC : ADC , # [doc = "BOOT_LOAD"]
pub BOOT_LOAD : BOOT_LOAD , # [doc = "CPU"]
pub CPU : CPU , # [doc = "EEPROM"]
pub EEPROM : EEPROM , # [doc = "EXINT"]
pub EXINT : EXINT , # [doc = "FLASH"]
pub FLASH : FLASH , # [doc = "FUSE"]
pub FUSE : FUSE , # [doc = "JTAG"]
pub JTAG : JTAG , # [doc = "LOCKBIT"]
pub LOCKBIT : LOCKBIT , # [doc = "PORTA"]
pub PORTA : PORTA , # [doc = "PORTB"]
pub PORTB : PORTB , # [doc = "PORTC"]
pub PORTC : PORTC , # [doc = "PORTD"]
pub PORTD : PORTD , # [doc = "PORTE"]
pub PORTE : PORTE , # [doc = "PORTF"]
pub PORTF : PORTF , # [doc = "PORTG"]
pub PORTG : PORTG , # [doc = "PWRCTRL"]
pub PWRCTRL : PWRCTRL , # [doc = "SPI"]
pub SPI : SPI , # [doc = "SYMCNT"]
pub SYMCNT : SYMCNT , # [doc = "TC0"]
pub TC0 : TC0 , # [doc = "TC1"]
pub TC1 : TC1 , # [doc = "TC2"]
pub TC2 : TC2 , # [doc = "TC3"]
pub TC3 : TC3 , # [doc = "TC4"]
pub TC4 : TC4 , # [doc = "TC5"]
pub TC5 : TC5 , # [doc = "TRX24"]
pub TRX24 : TRX24 , # [doc = "TWI"]
pub TWI : TWI , # [doc = "USART0"]
pub USART0 : USART0 , # [doc = "USART0_SPI"]
pub USART0_SPI : USART0_SPI , # [doc = "USART1"]
pub USART1 : USART1 , # [doc = "USART1_SPI"]
pub USART1_SPI : USART1_SPI , # [doc = "WDT"]
pub WDT : WDT , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { AC : AC { _marker : PhantomData } , ADC : ADC { _marker : PhantomData } , BOOT_LOAD : BOOT_LOAD { _marker : PhantomData } , CPU : CPU { _marker : PhantomData } , EEPROM : EEPROM { _marker : PhantomData } , EXINT : EXINT { _marker : PhantomData } , FLASH : FLASH { _marker : PhantomData } , FUSE : FUSE { _marker : PhantomData } , JTAG : JTAG { _marker : PhantomData } , LOCKBIT : LOCKBIT { _marker : PhantomData } , PORTA : PORTA { _marker : PhantomData } , PORTB : PORTB { _marker : PhantomData } , PORTC : PORTC { _marker : PhantomData } , PORTD : PORTD { _marker : PhantomData } , PORTE : PORTE { _marker : PhantomData } , PORTF : PORTF { _marker : PhantomData } , PORTG : PORTG { _marker : PhantomData } , PWRCTRL : PWRCTRL { _marker : PhantomData } , SPI : SPI { _marker : PhantomData } , SYMCNT : SYMCNT { _marker : PhantomData } , TC0 : TC0 { _marker : PhantomData } , TC1 : TC1 { _marker : PhantomData } , TC2 : TC2 { _marker : PhantomData } , TC3 : TC3 { _marker : PhantomData } , TC4 : TC4 { _marker : PhantomData } , TC5 : TC5 { _marker : PhantomData } , TRX24 : TRX24 { _marker : PhantomData } , TWI : TWI { _marker : PhantomData } , USART0 : USART0 { _marker : PhantomData } , USART0_SPI : USART0_SPI { _marker : PhantomData } , USART1 : USART1 { _marker : PhantomData } , USART1_SPI : USART1_SPI { _marker : PhantomData } , WDT : WDT { _marker : PhantomData } , } } }