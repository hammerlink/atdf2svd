# ! [doc = "Peripheral access API for ATTINY817 microcontrollers (generated using svd2rust v0.28.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS : u8 = 4 ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."]
type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."]
type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Read datasheet or reference manual to find what values are allowed to pass."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc (hidden)]
pub struct FieldReaderRaw < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , FI > FieldReaderRaw < U , FI > where U : Copy , { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitReaderRaw < T > { pub (crate) bits : bool , _reg : marker :: PhantomData < T > , } impl < FI > BitReaderRaw < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < U , FI > = FieldReaderRaw < U , FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI > = BitReaderRaw < FI > ; impl < U , FI > FieldReader < U , FI > where U : Copy , { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , FI > PartialEq < FI > for FieldReader < U , FI > where U : PartialEq , FI : Copy , U : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& U :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc (hidden)]
pub struct FieldWriterRaw < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (N , FI , Safety) > , } impl < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > FieldWriterRaw < 'a , U , REG , N , FI , Safety , WI , O > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitWriterRaw < 'a , U , REG , FI , M , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , U , REG , FI , M , const O : u8 > BitWriterRaw < 'a , U , REG , FI , M , O > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Unsafe , WI , O > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Safe , WI , O > ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , U , REG , FI , const O : u8 > = BitWriterRaw <'a , U , REG , FI , $ mwv , O >; impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; } } ; } macro_rules ! impl_bit_proxy { ($ writer : ident) => { impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, U : RawReg , bool : From < FI >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w . bits |= (U :: from (value) & U :: one ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { unsafe { self . bits (N :: from (variant)) } } } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { self . bits (N :: from (variant)) } } impl_bit_proxy ! (BitWriter) ; impl_bit_proxy ! (BitWriter1S) ; impl_bit_proxy ! (BitWriter0C) ; impl_bit_proxy ! (BitWriter1C) ; impl_bit_proxy ! (BitWriter0S) ; impl_bit_proxy ! (BitWriter1T) ; impl_bit_proxy ! (BitWriter0T) ; impl < 'a , U , REG , FI , const OF : u8 > BitWriter < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } } # [doc (hidden)]
pub mod interrupt { # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "1 - No Description."]
CRCSCAN_NMI = 1 , # [doc = "2 - No Description."]
BOD_VLM = 2 , # [doc = "3 - No Description."]
PORTA_PORT = 3 , # [doc = "4 - No Description."]
PORTB_PORT = 4 , # [doc = "5 - No Description."]
PORTC_PORT = 5 , # [doc = "6 - No Description."]
RTC_CNT = 6 , # [doc = "7 - No Description."]
RTC_PIT = 7 , # [doc = "8 - No Description."]
TCA0_LUNF_OVF = 8 , # [doc = "9 - No Description."]
TCA0_HUNF = 9 , # [doc = "10 - No Description."]
TCA0_CMP0_LCMP0 = 10 , # [doc = "11 - No Description."]
TCA0_CMP1_LCMP1 = 11 , # [doc = "12 - No Description."]
TCA0_CMP2_LCMP2 = 12 , # [doc = "13 - No Description."]
TCB0_INT = 13 , # [doc = "14 - No Description."]
TCD0_OVF = 14 , # [doc = "15 - No Description."]
TCD0_TRIG = 15 , # [doc = "16 - No Description."]
AC0_AC = 16 , # [doc = "17 - No Description."]
ADC0_RESRDY = 17 , # [doc = "18 - No Description."]
ADC0_WCOMP = 18 , # [doc = "19 - No Description."]
TWI0_TWIS = 19 , # [doc = "20 - No Description."]
TWI0_TWIM = 20 , # [doc = "21 - No Description."]
SPI0_INT = 21 , # [doc = "22 - No Description."]
USART0_RXC = 22 , # [doc = "23 - No Description."]
USART0_DRE = 23 , # [doc = "24 - No Description."]
USART0_TXC = 24 , # [doc = "25 - No Description."]
NVMCTRL_EE = 25 , } # [doc = r" TryFromInterruptError"]
# [derive (Debug , Copy , Clone)]
pub struct TryFromInterruptError (()) ; impl Interrupt { # [doc = r" Attempt to convert a given value into an `Interrupt`"]
# [inline]
pub fn try_from (value : u8) -> Result < Self , TryFromInterruptError > { match value { 1 => Ok (Interrupt :: CRCSCAN_NMI) , 2 => Ok (Interrupt :: BOD_VLM) , 3 => Ok (Interrupt :: PORTA_PORT) , 4 => Ok (Interrupt :: PORTB_PORT) , 5 => Ok (Interrupt :: PORTC_PORT) , 6 => Ok (Interrupt :: RTC_CNT) , 7 => Ok (Interrupt :: RTC_PIT) , 8 => Ok (Interrupt :: TCA0_LUNF_OVF) , 9 => Ok (Interrupt :: TCA0_HUNF) , 10 => Ok (Interrupt :: TCA0_CMP0_LCMP0) , 11 => Ok (Interrupt :: TCA0_CMP1_LCMP1) , 12 => Ok (Interrupt :: TCA0_CMP2_LCMP2) , 13 => Ok (Interrupt :: TCB0_INT) , 14 => Ok (Interrupt :: TCD0_OVF) , 15 => Ok (Interrupt :: TCD0_TRIG) , 16 => Ok (Interrupt :: AC0_AC) , 17 => Ok (Interrupt :: ADC0_RESRDY) , 18 => Ok (Interrupt :: ADC0_WCOMP) , 19 => Ok (Interrupt :: TWI0_TWIS) , 20 => Ok (Interrupt :: TWI0_TWIM) , 21 => Ok (Interrupt :: SPI0_INT) , 22 => Ok (Interrupt :: USART0_RXC) , 23 => Ok (Interrupt :: USART0_DRE) , 24 => Ok (Interrupt :: USART0_TXC) , 25 => Ok (Interrupt :: NVMCTRL_EE) , _ => Err (TryFromInterruptError (())) , } } } } pub use self :: interrupt :: Interrupt ; # [doc = "Analog Comparator"]
pub struct AC0 { _marker : PhantomData < * const () > } unsafe impl Send for AC0 { } impl AC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const ac0 :: RegisterBlock = 0x0670 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ac0 :: RegisterBlock { Self :: PTR } } impl Deref for AC0 { type Target = ac0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for AC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AC0") . finish () } } # [doc = "Analog Comparator"]
pub mod ac0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Mux Control A"]
pub muxctrla : MUXCTRLA , _reserved2 : [u8 ; 0x03]
, # [doc = "0x06 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x07 - Status"]
pub status : STATUS , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `HYSMODE` reader - Hysteresis Mode"]
pub type HYSMODE_R = crate :: FieldReader < u8 , HYSMODE_A > ; # [doc = "Hysteresis Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HYSMODE_A { # [doc = "0: No hysteresis"]
OFF = 0 , # [doc = "1: 10mV hysteresis"]
_10M_V = 1 , # [doc = "2: 25mV hysteresis"]
_25M_V = 2 , # [doc = "3: 50mV hysteresis"]
_50M_V = 3 , } impl From < HYSMODE_A > for u8 { # [inline (always)]
fn from (variant : HYSMODE_A) -> Self { variant as _ } } impl HYSMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> HYSMODE_A { match self . bits { 0 => HYSMODE_A :: OFF , 1 => HYSMODE_A :: _10M_V , 2 => HYSMODE_A :: _25M_V , 3 => HYSMODE_A :: _50M_V , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == HYSMODE_A :: OFF } # [doc = "Checks if the value of the field is `_10M_V`"]
# [inline (always)]
pub fn is_10m_v (& self) -> bool { * self == HYSMODE_A :: _10M_V } # [doc = "Checks if the value of the field is `_25M_V`"]
# [inline (always)]
pub fn is_25m_v (& self) -> bool { * self == HYSMODE_A :: _25M_V } # [doc = "Checks if the value of the field is `_50M_V`"]
# [inline (always)]
pub fn is_50m_v (& self) -> bool { * self == HYSMODE_A :: _50M_V } } # [doc = "Field `HYSMODE` writer - Hysteresis Mode"]
pub type HYSMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , HYSMODE_A , 2 , O > ; impl < 'a , const O : u8 > HYSMODE_W < 'a , O > { # [doc = "No hysteresis"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (HYSMODE_A :: OFF) } # [doc = "10mV hysteresis"]
# [inline (always)]
pub fn _10m_v (self) -> & 'a mut W { self . variant (HYSMODE_A :: _10M_V) } # [doc = "25mV hysteresis"]
# [inline (always)]
pub fn _25m_v (self) -> & 'a mut W { self . variant (HYSMODE_A :: _25M_V) } # [doc = "50mV hysteresis"]
# [inline (always)]
pub fn _50m_v (self) -> & 'a mut W { self . variant (HYSMODE_A :: _50M_V) } } # [doc = "Field `LPMODE` reader - Low Power Mode"]
pub type LPMODE_R = crate :: BitReader < LPMODE_A > ; # [doc = "Low Power Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum LPMODE_A { # [doc = "0: Low power mode disabled"]
DIS = 0 , # [doc = "1: Low power mode enabled"]
EN = 1 , } impl From < LPMODE_A > for bool { # [inline (always)]
fn from (variant : LPMODE_A) -> Self { variant as u8 != 0 } } impl LPMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> LPMODE_A { match self . bits { false => LPMODE_A :: DIS , true => LPMODE_A :: EN , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == LPMODE_A :: DIS } # [doc = "Checks if the value of the field is `EN`"]
# [inline (always)]
pub fn is_en (& self) -> bool { * self == LPMODE_A :: EN } } # [doc = "Field `LPMODE` writer - Low Power Mode"]
pub type LPMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , LPMODE_A , O > ; impl < 'a , const O : u8 > LPMODE_W < 'a , O > { # [doc = "Low power mode disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (LPMODE_A :: DIS) } # [doc = "Low power mode enabled"]
# [inline (always)]
pub fn en (self) -> & 'a mut W { self . variant (LPMODE_A :: EN) } } # [doc = "Field `INTMODE` reader - Interrupt Mode"]
pub type INTMODE_R = crate :: FieldReader < u8 , INTMODE_A > ; # [doc = "Interrupt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE_A { # [doc = "0: Any Edge"]
BOTHEDGE = 0 , # [doc = "2: Negative Edge"]
NEGEDGE = 2 , # [doc = "3: Positive Edge"]
POSEDGE = 3 , } impl From < INTMODE_A > for u8 { # [inline (always)]
fn from (variant : INTMODE_A) -> Self { variant as _ } } impl INTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INTMODE_A > { match self . bits { 0 => Some (INTMODE_A :: BOTHEDGE) , 2 => Some (INTMODE_A :: NEGEDGE) , 3 => Some (INTMODE_A :: POSEDGE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGE`"]
# [inline (always)]
pub fn is_bothedge (& self) -> bool { * self == INTMODE_A :: BOTHEDGE } # [doc = "Checks if the value of the field is `NEGEDGE`"]
# [inline (always)]
pub fn is_negedge (& self) -> bool { * self == INTMODE_A :: NEGEDGE } # [doc = "Checks if the value of the field is `POSEDGE`"]
# [inline (always)]
pub fn is_posedge (& self) -> bool { * self == INTMODE_A :: POSEDGE } } # [doc = "Field `INTMODE` writer - Interrupt Mode"]
pub type INTMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , INTMODE_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE_W < 'a , O > { # [doc = "Any Edge"]
# [inline (always)]
pub fn bothedge (self) -> & 'a mut W { self . variant (INTMODE_A :: BOTHEDGE) } # [doc = "Negative Edge"]
# [inline (always)]
pub fn negedge (self) -> & 'a mut W { self . variant (INTMODE_A :: NEGEDGE) } # [doc = "Positive Edge"]
# [inline (always)]
pub fn posedge (self) -> & 'a mut W { self . variant (INTMODE_A :: POSEDGE) } } # [doc = "Field `OUTEN` reader - Output Buffer Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Buffer Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby Mode"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby Mode"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
pub fn hysmode (& self) -> HYSMODE_R { HYSMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Low Power Mode"]
# [inline (always)]
pub fn lpmode (& self) -> LPMODE_R { LPMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Interrupt Mode"]
# [inline (always)]
pub fn intmode (& self) -> INTMODE_R { INTMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Output Buffer Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Run in Standby Mode"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
# [must_use]
pub fn hysmode (& mut self) -> HYSMODE_W < 1 > { HYSMODE_W :: new (self) } # [doc = "Bit 3 - Low Power Mode"]
# [inline (always)]
# [must_use]
pub fn lpmode (& mut self) -> LPMODE_W < 3 > { LPMODE_W :: new (self) } # [doc = "Bits 4:5 - Interrupt Mode"]
# [inline (always)]
# [must_use]
pub fn intmode (& mut self) -> INTMODE_W < 4 > { INTMODE_W :: new (self) } # [doc = "Bit 6 - Output Buffer Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 6 > { OUTEN_W :: new (self) } # [doc = "Bit 7 - Run in Standby Mode"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 7 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP` reader - Analog Comparator 0 Interrupt Enable"]
pub type CMP_R = crate :: BitReader < bool > ; # [doc = "Field `CMP` writer - Analog Comparator 0 Interrupt Enable"]
pub type CMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Analog Comparator 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp (& self) -> CMP_R { CMP_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Analog Comparator 0 Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn cmp (& mut self) -> CMP_W < 0 > { CMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MUXCTRLA (rw) register accessor: an alias for `Reg<MUXCTRLA_SPEC>`"]
pub type MUXCTRLA = crate :: Reg < muxctrla :: MUXCTRLA_SPEC > ; # [doc = "Mux Control A"]
pub mod muxctrla { # [doc = "Register `MUXCTRLA` reader"]
pub struct R (crate :: R < MUXCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MUXCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MUXCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MUXCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `MUXCTRLA` writer"]
pub struct W (crate :: W < MUXCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MUXCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MUXCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MUXCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUXNEG` reader - Negative Input MUX Selection"]
pub type MUXNEG_R = crate :: FieldReader < u8 , MUXNEG_A > ; # [doc = "Negative Input MUX Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXNEG_A { # [doc = "0: Negative Pin 0"]
PIN0 = 0 , # [doc = "1: Negative Pin 1"]
PIN1 = 1 , # [doc = "2: Voltage Reference"]
VREF = 2 , # [doc = "3: DAC output"]
DAC = 3 , } impl From < MUXNEG_A > for u8 { # [inline (always)]
fn from (variant : MUXNEG_A) -> Self { variant as _ } } impl MUXNEG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXNEG_A { match self . bits { 0 => MUXNEG_A :: PIN0 , 1 => MUXNEG_A :: PIN1 , 2 => MUXNEG_A :: VREF , 3 => MUXNEG_A :: DAC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXNEG_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXNEG_A :: PIN1 } # [doc = "Checks if the value of the field is `VREF`"]
# [inline (always)]
pub fn is_vref (& self) -> bool { * self == MUXNEG_A :: VREF } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXNEG_A :: DAC } } # [doc = "Field `MUXNEG` writer - Negative Input MUX Selection"]
pub type MUXNEG_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MUXCTRLA_SPEC , u8 , MUXNEG_A , 2 , O > ; impl < 'a , const O : u8 > MUXNEG_W < 'a , O > { # [doc = "Negative Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN0) } # [doc = "Negative Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN1) } # [doc = "Voltage Reference"]
# [inline (always)]
pub fn vref (self) -> & 'a mut W { self . variant (MUXNEG_A :: VREF) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXNEG_A :: DAC) } } # [doc = "Field `MUXPOS` reader - Positive Input MUX Selection"]
pub type MUXPOS_R = crate :: BitReader < MUXPOS_A > ; # [doc = "Positive Input MUX Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MUXPOS_A { # [doc = "0: Positive Pin 0"]
PIN0 = 0 , # [doc = "1: Positive Pin 1"]
PIN1 = 1 , } impl From < MUXPOS_A > for bool { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as u8 != 0 } } impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXPOS_A { match self . bits { false => MUXPOS_A :: PIN0 , true => MUXPOS_A :: PIN1 , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXPOS_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXPOS_A :: PIN1 } } # [doc = "Field `MUXPOS` writer - Positive Input MUX Selection"]
pub type MUXPOS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MUXCTRLA_SPEC , MUXPOS_A , O > ; impl < 'a , const O : u8 > MUXPOS_W < 'a , O > { # [doc = "Positive Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN0) } # [doc = "Positive Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN1) } } # [doc = "Field `INVERT` reader - Invert AC Output"]
pub type INVERT_R = crate :: BitReader < bool > ; # [doc = "Field `INVERT` writer - Invert AC Output"]
pub type INVERT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MUXCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Negative Input MUX Selection"]
# [inline (always)]
pub fn muxneg (& self) -> MUXNEG_R { MUXNEG_R :: new (self . bits & 3) } # [doc = "Bit 3 - Positive Input MUX Selection"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Invert AC Output"]
# [inline (always)]
pub fn invert (& self) -> INVERT_R { INVERT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Negative Input MUX Selection"]
# [inline (always)]
# [must_use]
pub fn muxneg (& mut self) -> MUXNEG_W < 0 > { MUXNEG_W :: new (self) } # [doc = "Bit 3 - Positive Input MUX Selection"]
# [inline (always)]
# [must_use]
pub fn muxpos (& mut self) -> MUXPOS_W < 3 > { MUXPOS_W :: new (self) } # [doc = "Bit 7 - Invert AC Output"]
# [inline (always)]
# [must_use]
pub fn invert (& mut self) -> INVERT_W < 7 > { INVERT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Mux Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [muxctrla](index.html) module"]
pub struct MUXCTRLA_SPEC ; impl crate :: RegisterSpec for MUXCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [muxctrla::R](R) reader structure"]
impl crate :: Readable for MUXCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [muxctrla::W](W) writer structure"]
impl crate :: Writable for MUXCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MUXCTRLA to value 0"]
impl crate :: Resettable for MUXCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP` reader - Analog Comparator Interrupt Flag"]
pub type CMP_R = crate :: BitReader < bool > ; # [doc = "Field `CMP` writer - Analog Comparator Interrupt Flag"]
pub type CMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `STATE` reader - Analog Comparator State"]
pub type STATE_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Analog Comparator Interrupt Flag"]
# [inline (always)]
pub fn cmp (& self) -> CMP_R { CMP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Analog Comparator State"]
# [inline (always)]
pub fn state (& self) -> STATE_R { STATE_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Analog Comparator Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn cmp (& mut self) -> CMP_W < 0 > { CMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Analog to Digital Converter"]
pub struct ADC0 { _marker : PhantomData < * const () > } unsafe impl Send for ADC0 { } impl ADC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const adc0 :: RegisterBlock = 0x0600 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adc0 :: RegisterBlock { Self :: PTR } } impl Deref for ADC0 { type Target = adc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC0") . finish () } } # [doc = "Analog to Digital Converter"]
pub mod adc0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control E"]
pub ctrle : CTRLE , # [doc = "0x05 - Sample Control"]
pub sampctrl : SAMPCTRL , # [doc = "0x06 - Positive mux input"]
pub muxpos : MUXPOS , _reserved7 : [u8 ; 0x01]
, # [doc = "0x08 - Command"]
pub command : COMMAND , # [doc = "0x09 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x0a - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x0b - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0c - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x0d - Temporary Data"]
pub temp : TEMP , _reserved13 : [u8 ; 0x02]
, # [doc = "0x10 - ADC Accumulator Result"]
pub res : RES , # [doc = "0x12 - Window comparator low threshold"]
pub winlt : WINLT , # [doc = "0x14 - Window comparator high threshold"]
pub winht : WINHT , # [doc = "0x16 - Calibration"]
pub calib : CALIB , } # [doc = "CALIB (rw) register accessor: an alias for `Reg<CALIB_SPEC>`"]
pub type CALIB = crate :: Reg < calib :: CALIB_SPEC > ; # [doc = "Calibration"]
pub mod calib { # [doc = "Register `CALIB` reader"]
pub struct R (crate :: R < CALIB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CALIB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CALIB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CALIB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CALIB` writer"]
pub struct W (crate :: W < CALIB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CALIB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CALIB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CALIB_SPEC >) -> Self { W (writer) } } # [doc = "Field `DUTYCYC` reader - Duty Cycle"]
pub type DUTYCYC_R = crate :: BitReader < DUTYCYC_A > ; # [doc = "Duty Cycle\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DUTYCYC_A { # [doc = "0: 50% Duty cycle"]
DUTY50 = 0 , # [doc = "1: 25% Duty cycle"]
DUTY25 = 1 , } impl From < DUTYCYC_A > for bool { # [inline (always)]
fn from (variant : DUTYCYC_A) -> Self { variant as u8 != 0 } } impl DUTYCYC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DUTYCYC_A { match self . bits { false => DUTYCYC_A :: DUTY50 , true => DUTYCYC_A :: DUTY25 , } } # [doc = "Checks if the value of the field is `DUTY50`"]
# [inline (always)]
pub fn is_duty50 (& self) -> bool { * self == DUTYCYC_A :: DUTY50 } # [doc = "Checks if the value of the field is `DUTY25`"]
# [inline (always)]
pub fn is_duty25 (& self) -> bool { * self == DUTYCYC_A :: DUTY25 } } # [doc = "Field `DUTYCYC` writer - Duty Cycle"]
pub type DUTYCYC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CALIB_SPEC , DUTYCYC_A , O > ; impl < 'a , const O : u8 > DUTYCYC_W < 'a , O > { # [doc = "50% Duty cycle"]
# [inline (always)]
pub fn duty50 (self) -> & 'a mut W { self . variant (DUTYCYC_A :: DUTY50) } # [doc = "25% Duty cycle"]
# [inline (always)]
pub fn duty25 (self) -> & 'a mut W { self . variant (DUTYCYC_A :: DUTY25) } } impl R { # [doc = "Bit 0 - Duty Cycle"]
# [inline (always)]
pub fn dutycyc (& self) -> DUTYCYC_R { DUTYCYC_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Duty Cycle"]
# [inline (always)]
# [must_use]
pub fn dutycyc (& mut self) -> DUTYCYC_W < 0 > { DUTYCYC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calib](index.html) module"]
pub struct CALIB_SPEC ; impl crate :: RegisterSpec for CALIB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [calib::R](R) reader structure"]
impl crate :: Readable for CALIB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [calib::W](W) writer structure"]
impl crate :: Writable for CALIB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CALIB to value 0"]
impl crate :: Resettable for CALIB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMMAND (rw) register accessor: an alias for `Reg<COMMAND_SPEC>`"]
pub type COMMAND = crate :: Reg < command :: COMMAND_SPEC > ; # [doc = "Command"]
pub mod command { # [doc = "Register `COMMAND` reader"]
pub struct R (crate :: R < COMMAND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMMAND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMMAND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMMAND_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMMAND` writer"]
pub struct W (crate :: W < COMMAND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMMAND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMMAND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMMAND_SPEC >) -> Self { W (writer) } } # [doc = "Field `STCONV` reader - Start Conversion Operation"]
pub type STCONV_R = crate :: BitReader < bool > ; # [doc = "Field `STCONV` writer - Start Conversion Operation"]
pub type STCONV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , COMMAND_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Start Conversion Operation"]
# [inline (always)]
pub fn stconv (& self) -> STCONV_R { STCONV_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Start Conversion Operation"]
# [inline (always)]
# [must_use]
pub fn stconv (& mut self) -> STCONV_W < 0 > { STCONV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Command\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [command](index.html) module"]
pub struct COMMAND_SPEC ; impl crate :: RegisterSpec for COMMAND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [command::R](R) reader structure"]
impl crate :: Readable for COMMAND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [command::W](W) writer structure"]
impl crate :: Writable for COMMAND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMMAND to value 0"]
impl crate :: Resettable for COMMAND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - ADC Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - ADC Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `FREERUN` reader - ADC Freerun mode"]
pub type FREERUN_R = crate :: BitReader < bool > ; # [doc = "Field `FREERUN` writer - ADC Freerun mode"]
pub type FREERUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RESSEL` reader - ADC Resolution"]
pub type RESSEL_R = crate :: BitReader < RESSEL_A > ; # [doc = "ADC Resolution\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RESSEL_A { # [doc = "0: 10-bit mode"]
_10BIT = 0 , # [doc = "1: 8-bit mode"]
_8BIT = 1 , } impl From < RESSEL_A > for bool { # [inline (always)]
fn from (variant : RESSEL_A) -> Self { variant as u8 != 0 } } impl RESSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RESSEL_A { match self . bits { false => RESSEL_A :: _10BIT , true => RESSEL_A :: _8BIT , } } # [doc = "Checks if the value of the field is `_10BIT`"]
# [inline (always)]
pub fn is_10bit (& self) -> bool { * self == RESSEL_A :: _10BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == RESSEL_A :: _8BIT } } # [doc = "Field `RESSEL` writer - ADC Resolution"]
pub type RESSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , RESSEL_A , O > ; impl < 'a , const O : u8 > RESSEL_W < 'a , O > { # [doc = "10-bit mode"]
# [inline (always)]
pub fn _10bit (self) -> & 'a mut W { self . variant (RESSEL_A :: _10BIT) } # [doc = "8-bit mode"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (RESSEL_A :: _8BIT) } } # [doc = "Field `RUNSTBY` reader - Run standby mode"]
pub type RUNSTBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTBY` writer - Run standby mode"]
pub type RUNSTBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - ADC Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC Freerun mode"]
# [inline (always)]
pub fn freerun (& self) -> FREERUN_R { FREERUN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - ADC Resolution"]
# [inline (always)]
pub fn ressel (& self) -> RESSEL_R { RESSEL_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Run standby mode"]
# [inline (always)]
pub fn runstby (& self) -> RUNSTBY_R { RUNSTBY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - ADC Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - ADC Freerun mode"]
# [inline (always)]
# [must_use]
pub fn freerun (& mut self) -> FREERUN_W < 1 > { FREERUN_W :: new (self) } # [doc = "Bit 2 - ADC Resolution"]
# [inline (always)]
# [must_use]
pub fn ressel (& mut self) -> RESSEL_W < 2 > { RESSEL_W :: new (self) } # [doc = "Bit 7 - Run standby mode"]
# [inline (always)]
# [must_use]
pub fn runstby (& mut self) -> RUNSTBY_W < 7 > { RUNSTBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SAMPNUM` reader - Accumulation Samples"]
pub type SAMPNUM_R = crate :: FieldReader < u8 , SAMPNUM_A > ; # [doc = "Accumulation Samples\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SAMPNUM_A { # [doc = "0: 1 ADC sample"]
ACC1 = 0 , # [doc = "1: Accumulate 2 samples"]
ACC2 = 1 , # [doc = "2: Accumulate 4 samples"]
ACC4 = 2 , # [doc = "3: Accumulate 8 samples"]
ACC8 = 3 , # [doc = "4: Accumulate 16 samples"]
ACC16 = 4 , # [doc = "5: Accumulate 32 samples"]
ACC32 = 5 , # [doc = "6: Accumulate 64 samples"]
ACC64 = 6 , } impl From < SAMPNUM_A > for u8 { # [inline (always)]
fn from (variant : SAMPNUM_A) -> Self { variant as _ } } impl SAMPNUM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SAMPNUM_A > { match self . bits { 0 => Some (SAMPNUM_A :: ACC1) , 1 => Some (SAMPNUM_A :: ACC2) , 2 => Some (SAMPNUM_A :: ACC4) , 3 => Some (SAMPNUM_A :: ACC8) , 4 => Some (SAMPNUM_A :: ACC16) , 5 => Some (SAMPNUM_A :: ACC32) , 6 => Some (SAMPNUM_A :: ACC64) , _ => None , } } # [doc = "Checks if the value of the field is `ACC1`"]
# [inline (always)]
pub fn is_acc1 (& self) -> bool { * self == SAMPNUM_A :: ACC1 } # [doc = "Checks if the value of the field is `ACC2`"]
# [inline (always)]
pub fn is_acc2 (& self) -> bool { * self == SAMPNUM_A :: ACC2 } # [doc = "Checks if the value of the field is `ACC4`"]
# [inline (always)]
pub fn is_acc4 (& self) -> bool { * self == SAMPNUM_A :: ACC4 } # [doc = "Checks if the value of the field is `ACC8`"]
# [inline (always)]
pub fn is_acc8 (& self) -> bool { * self == SAMPNUM_A :: ACC8 } # [doc = "Checks if the value of the field is `ACC16`"]
# [inline (always)]
pub fn is_acc16 (& self) -> bool { * self == SAMPNUM_A :: ACC16 } # [doc = "Checks if the value of the field is `ACC32`"]
# [inline (always)]
pub fn is_acc32 (& self) -> bool { * self == SAMPNUM_A :: ACC32 } # [doc = "Checks if the value of the field is `ACC64`"]
# [inline (always)]
pub fn is_acc64 (& self) -> bool { * self == SAMPNUM_A :: ACC64 } } # [doc = "Field `SAMPNUM` writer - Accumulation Samples"]
pub type SAMPNUM_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , SAMPNUM_A , 3 , O > ; impl < 'a , const O : u8 > SAMPNUM_W < 'a , O > { # [doc = "1 ADC sample"]
# [inline (always)]
pub fn acc1 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC1) } # [doc = "Accumulate 2 samples"]
# [inline (always)]
pub fn acc2 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC2) } # [doc = "Accumulate 4 samples"]
# [inline (always)]
pub fn acc4 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC4) } # [doc = "Accumulate 8 samples"]
# [inline (always)]
pub fn acc8 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC8) } # [doc = "Accumulate 16 samples"]
# [inline (always)]
pub fn acc16 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC16) } # [doc = "Accumulate 32 samples"]
# [inline (always)]
pub fn acc32 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC32) } # [doc = "Accumulate 64 samples"]
# [inline (always)]
pub fn acc64 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC64) } } impl R { # [doc = "Bits 0:2 - Accumulation Samples"]
# [inline (always)]
pub fn sampnum (& self) -> SAMPNUM_R { SAMPNUM_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Accumulation Samples"]
# [inline (always)]
# [must_use]
pub fn sampnum (& mut self) -> SAMPNUM_W < 0 > { SAMPNUM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESC` reader - Clock Pre-scaler"]
pub type PRESC_R = crate :: FieldReader < u8 , PRESC_A > ; # [doc = "Clock Pre-scaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESC_A { # [doc = "0: CLK_PER divided by 2"]
DIV2 = 0 , # [doc = "1: CLK_PER divided by 4"]
DIV4 = 1 , # [doc = "2: CLK_PER divided by 8"]
DIV8 = 2 , # [doc = "3: CLK_PER divided by 16"]
DIV16 = 3 , # [doc = "4: CLK_PER divided by 32"]
DIV32 = 4 , # [doc = "5: CLK_PER divided by 64"]
DIV64 = 5 , # [doc = "6: CLK_PER divided by 128"]
DIV128 = 6 , # [doc = "7: CLK_PER divided by 256"]
DIV256 = 7 , } impl From < PRESC_A > for u8 { # [inline (always)]
fn from (variant : PRESC_A) -> Self { variant as _ } } impl PRESC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESC_A { match self . bits { 0 => PRESC_A :: DIV2 , 1 => PRESC_A :: DIV4 , 2 => PRESC_A :: DIV8 , 3 => PRESC_A :: DIV16 , 4 => PRESC_A :: DIV32 , 5 => PRESC_A :: DIV64 , 6 => PRESC_A :: DIV128 , 7 => PRESC_A :: DIV256 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESC_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESC_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESC_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESC_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESC_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESC_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESC_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESC_A :: DIV256 } } # [doc = "Field `PRESC` writer - Clock Pre-scaler"]
pub type PRESC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , PRESC_A , 3 , O > ; impl < 'a , const O : u8 > PRESC_W < 'a , O > { # [doc = "CLK_PER divided by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV2) } # [doc = "CLK_PER divided by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV4) } # [doc = "CLK_PER divided by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV8) } # [doc = "CLK_PER divided by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV16) } # [doc = "CLK_PER divided by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV32) } # [doc = "CLK_PER divided by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV64) } # [doc = "CLK_PER divided by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV128) } # [doc = "CLK_PER divided by 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV256) } } # [doc = "Field `REFSEL` reader - Reference Selection"]
pub type REFSEL_R = crate :: FieldReader < u8 , REFSEL_A > ; # [doc = "Reference Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFSEL_A { # [doc = "0: Internal reference"]
INTREF = 0 , # [doc = "1: VDD"]
VDDREF = 1 , } impl From < REFSEL_A > for u8 { # [inline (always)]
fn from (variant : REFSEL_A) -> Self { variant as _ } } impl REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < REFSEL_A > { match self . bits { 0 => Some (REFSEL_A :: INTREF) , 1 => Some (REFSEL_A :: VDDREF) , _ => None , } } # [doc = "Checks if the value of the field is `INTREF`"]
# [inline (always)]
pub fn is_intref (& self) -> bool { * self == REFSEL_A :: INTREF } # [doc = "Checks if the value of the field is `VDDREF`"]
# [inline (always)]
pub fn is_vddref (& self) -> bool { * self == REFSEL_A :: VDDREF } } # [doc = "Field `REFSEL` writer - Reference Selection"]
pub type REFSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , REFSEL_A , 2 , O > ; impl < 'a , const O : u8 > REFSEL_W < 'a , O > { # [doc = "Internal reference"]
# [inline (always)]
pub fn intref (self) -> & 'a mut W { self . variant (REFSEL_A :: INTREF) } # [doc = "VDD"]
# [inline (always)]
pub fn vddref (self) -> & 'a mut W { self . variant (REFSEL_A :: VDDREF) } } # [doc = "Field `SAMPCAP` reader - Sample Capacitance Selection"]
pub type SAMPCAP_R = crate :: BitReader < bool > ; # [doc = "Field `SAMPCAP` writer - Sample Capacitance Selection"]
pub type SAMPCAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Pre-scaler"]
# [inline (always)]
pub fn presc (& self) -> PRESC_R { PRESC_R :: new (self . bits & 7) } # [doc = "Bits 4:5 - Reference Selection"]
# [inline (always)]
pub fn refsel (& self) -> REFSEL_R { REFSEL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Sample Capacitance Selection"]
# [inline (always)]
pub fn sampcap (& self) -> SAMPCAP_R { SAMPCAP_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Pre-scaler"]
# [inline (always)]
# [must_use]
pub fn presc (& mut self) -> PRESC_W < 0 > { PRESC_W :: new (self) } # [doc = "Bits 4:5 - Reference Selection"]
# [inline (always)]
# [must_use]
pub fn refsel (& mut self) -> REFSEL_W < 4 > { REFSEL_W :: new (self) } # [doc = "Bit 6 - Sample Capacitance Selection"]
# [inline (always)]
# [must_use]
pub fn sampcap (& mut self) -> SAMPCAP_W < 6 > { SAMPCAP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `SAMPDLY` reader - Sampling Delay Selection"]
pub type SAMPDLY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SAMPDLY` writer - Sampling Delay Selection"]
pub type SAMPDLY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLD_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `ASDV` reader - Automatic Sampling Delay Variation"]
pub type ASDV_R = crate :: BitReader < ASDV_A > ; # [doc = "Automatic Sampling Delay Variation\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ASDV_A { # [doc = "0: The Automatic Sampling Delay Variation is disabled"]
ASVOFF = 0 , # [doc = "1: The Automatic Sampling Delay Variation is enabled"]
ASVON = 1 , } impl From < ASDV_A > for bool { # [inline (always)]
fn from (variant : ASDV_A) -> Self { variant as u8 != 0 } } impl ASDV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ASDV_A { match self . bits { false => ASDV_A :: ASVOFF , true => ASDV_A :: ASVON , } } # [doc = "Checks if the value of the field is `ASVOFF`"]
# [inline (always)]
pub fn is_asvoff (& self) -> bool { * self == ASDV_A :: ASVOFF } # [doc = "Checks if the value of the field is `ASVON`"]
# [inline (always)]
pub fn is_asvon (& self) -> bool { * self == ASDV_A :: ASVON } } # [doc = "Field `ASDV` writer - Automatic Sampling Delay Variation"]
pub type ASDV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , ASDV_A , O > ; impl < 'a , const O : u8 > ASDV_W < 'a , O > { # [doc = "The Automatic Sampling Delay Variation is disabled"]
# [inline (always)]
pub fn asvoff (self) -> & 'a mut W { self . variant (ASDV_A :: ASVOFF) } # [doc = "The Automatic Sampling Delay Variation is enabled"]
# [inline (always)]
pub fn asvon (self) -> & 'a mut W { self . variant (ASDV_A :: ASVON) } } # [doc = "Field `INITDLY` reader - Initial Delay Selection"]
pub type INITDLY_R = crate :: FieldReader < u8 , INITDLY_A > ; # [doc = "Initial Delay Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INITDLY_A { # [doc = "0: Delay 0 CLK_ADC cycles"]
DLY0 = 0 , # [doc = "1: Delay 16 CLK_ADC cycles"]
DLY16 = 1 , # [doc = "2: Delay 32 CLK_ADC cycles"]
DLY32 = 2 , # [doc = "3: Delay 64 CLK_ADC cycles"]
DLY64 = 3 , # [doc = "4: Delay 128 CLK_ADC cycles"]
DLY128 = 4 , # [doc = "5: Delay 256 CLK_ADC cycles"]
DLY256 = 5 , } impl From < INITDLY_A > for u8 { # [inline (always)]
fn from (variant : INITDLY_A) -> Self { variant as _ } } impl INITDLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INITDLY_A > { match self . bits { 0 => Some (INITDLY_A :: DLY0) , 1 => Some (INITDLY_A :: DLY16) , 2 => Some (INITDLY_A :: DLY32) , 3 => Some (INITDLY_A :: DLY64) , 4 => Some (INITDLY_A :: DLY128) , 5 => Some (INITDLY_A :: DLY256) , _ => None , } } # [doc = "Checks if the value of the field is `DLY0`"]
# [inline (always)]
pub fn is_dly0 (& self) -> bool { * self == INITDLY_A :: DLY0 } # [doc = "Checks if the value of the field is `DLY16`"]
# [inline (always)]
pub fn is_dly16 (& self) -> bool { * self == INITDLY_A :: DLY16 } # [doc = "Checks if the value of the field is `DLY32`"]
# [inline (always)]
pub fn is_dly32 (& self) -> bool { * self == INITDLY_A :: DLY32 } # [doc = "Checks if the value of the field is `DLY64`"]
# [inline (always)]
pub fn is_dly64 (& self) -> bool { * self == INITDLY_A :: DLY64 } # [doc = "Checks if the value of the field is `DLY128`"]
# [inline (always)]
pub fn is_dly128 (& self) -> bool { * self == INITDLY_A :: DLY128 } # [doc = "Checks if the value of the field is `DLY256`"]
# [inline (always)]
pub fn is_dly256 (& self) -> bool { * self == INITDLY_A :: DLY256 } } # [doc = "Field `INITDLY` writer - Initial Delay Selection"]
pub type INITDLY_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , INITDLY_A , 3 , O > ; impl < 'a , const O : u8 > INITDLY_W < 'a , O > { # [doc = "Delay 0 CLK_ADC cycles"]
# [inline (always)]
pub fn dly0 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY0) } # [doc = "Delay 16 CLK_ADC cycles"]
# [inline (always)]
pub fn dly16 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY16) } # [doc = "Delay 32 CLK_ADC cycles"]
# [inline (always)]
pub fn dly32 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY32) } # [doc = "Delay 64 CLK_ADC cycles"]
# [inline (always)]
pub fn dly64 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY64) } # [doc = "Delay 128 CLK_ADC cycles"]
# [inline (always)]
pub fn dly128 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY128) } # [doc = "Delay 256 CLK_ADC cycles"]
# [inline (always)]
pub fn dly256 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY256) } } impl R { # [doc = "Bits 0:3 - Sampling Delay Selection"]
# [inline (always)]
pub fn sampdly (& self) -> SAMPDLY_R { SAMPDLY_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Automatic Sampling Delay Variation"]
# [inline (always)]
pub fn asdv (& self) -> ASDV_R { ASDV_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Initial Delay Selection"]
# [inline (always)]
pub fn initdly (& self) -> INITDLY_R { INITDLY_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Sampling Delay Selection"]
# [inline (always)]
# [must_use]
pub fn sampdly (& mut self) -> SAMPDLY_W < 0 > { SAMPDLY_W :: new (self) } # [doc = "Bit 4 - Automatic Sampling Delay Variation"]
# [inline (always)]
# [must_use]
pub fn asdv (& mut self) -> ASDV_W < 4 > { ASDV_W :: new (self) } # [doc = "Bits 5:7 - Initial Delay Selection"]
# [inline (always)]
# [must_use]
pub fn initdly (& mut self) -> INITDLY_W < 5 > { INITDLY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `WINCM` reader - Window Comparator Mode"]
pub type WINCM_R = crate :: FieldReader < u8 , WINCM_A > ; # [doc = "Window Comparator Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINCM_A { # [doc = "0: No Window Comparison"]
NONE = 0 , # [doc = "1: Below Window"]
BELOW = 1 , # [doc = "2: Above Window"]
ABOVE = 2 , # [doc = "3: Inside Window"]
INSIDE = 3 , # [doc = "4: Outside Window"]
OUTSIDE = 4 , } impl From < WINCM_A > for u8 { # [inline (always)]
fn from (variant : WINCM_A) -> Self { variant as _ } } impl WINCM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WINCM_A > { match self . bits { 0 => Some (WINCM_A :: NONE) , 1 => Some (WINCM_A :: BELOW) , 2 => Some (WINCM_A :: ABOVE) , 3 => Some (WINCM_A :: INSIDE) , 4 => Some (WINCM_A :: OUTSIDE) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == WINCM_A :: NONE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WINCM_A :: BELOW } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WINCM_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WINCM_A :: INSIDE } # [doc = "Checks if the value of the field is `OUTSIDE`"]
# [inline (always)]
pub fn is_outside (& self) -> bool { * self == WINCM_A :: OUTSIDE } } # [doc = "Field `WINCM` writer - Window Comparator Mode"]
pub type WINCM_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLE_SPEC , u8 , WINCM_A , 3 , O > ; impl < 'a , const O : u8 > WINCM_W < 'a , O > { # [doc = "No Window Comparison"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (WINCM_A :: NONE) } # [doc = "Below Window"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (WINCM_A :: BELOW) } # [doc = "Above Window"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (WINCM_A :: ABOVE) } # [doc = "Inside Window"]
# [inline (always)]
pub fn inside (self) -> & 'a mut W { self . variant (WINCM_A :: INSIDE) } # [doc = "Outside Window"]
# [inline (always)]
pub fn outside (self) -> & 'a mut W { self . variant (WINCM_A :: OUTSIDE) } } impl R { # [doc = "Bits 0:2 - Window Comparator Mode"]
# [inline (always)]
pub fn wincm (& self) -> WINCM_R { WINCM_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Window Comparator Mode"]
# [inline (always)]
# [must_use]
pub fn wincm (& mut self) -> WINCM_W < 0 > { WINCM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `STARTEI` reader - Start Event Input Enable"]
pub type STARTEI_R = crate :: BitReader < bool > ; # [doc = "Field `STARTEI` writer - Start Event Input Enable"]
pub type STARTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Start Event Input Enable"]
# [inline (always)]
pub fn startei (& self) -> STARTEI_R { STARTEI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Start Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn startei (& mut self) -> STARTEI_W < 0 > { STARTEI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESRDY` reader - Result Ready Interrupt Enable"]
pub type RESRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RESRDY` writer - Result Ready Interrupt Enable"]
pub type RESRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `WCMP` reader - Window Comparator Interrupt Enable"]
pub type WCMP_R = crate :: BitReader < bool > ; # [doc = "Field `WCMP` writer - Window Comparator Interrupt Enable"]
pub type WCMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Result Ready Interrupt Enable"]
# [inline (always)]
pub fn resrdy (& self) -> RESRDY_R { RESRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Window Comparator Interrupt Enable"]
# [inline (always)]
pub fn wcmp (& self) -> WCMP_R { WCMP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Result Ready Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn resrdy (& mut self) -> RESRDY_W < 0 > { RESRDY_W :: new (self) } # [doc = "Bit 1 - Window Comparator Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn wcmp (& mut self) -> WCMP_W < 1 > { WCMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESRDY` reader - Result Ready Flag"]
pub type RESRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RESRDY` writer - Result Ready Flag"]
pub type RESRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `WCMP` reader - Window Comparator Flag"]
pub type WCMP_R = crate :: BitReader < bool > ; # [doc = "Field `WCMP` writer - Window Comparator Flag"]
pub type WCMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Result Ready Flag"]
# [inline (always)]
pub fn resrdy (& self) -> RESRDY_R { RESRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Window Comparator Flag"]
# [inline (always)]
pub fn wcmp (& self) -> WCMP_R { WCMP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Result Ready Flag"]
# [inline (always)]
# [must_use]
pub fn resrdy (& mut self) -> RESRDY_W < 0 > { RESRDY_W :: new (self) } # [doc = "Bit 1 - Window Comparator Flag"]
# [inline (always)]
# [must_use]
pub fn wcmp (& mut self) -> WCMP_W < 1 > { WCMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MUXPOS (rw) register accessor: an alias for `Reg<MUXPOS_SPEC>`"]
pub type MUXPOS = crate :: Reg < muxpos :: MUXPOS_SPEC > ; # [doc = "Positive mux input"]
pub mod muxpos { # [doc = "Register `MUXPOS` reader"]
pub struct R (crate :: R < MUXPOS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MUXPOS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MUXPOS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MUXPOS_SPEC >) -> Self { R (reader) } } # [doc = "Register `MUXPOS` writer"]
pub struct W (crate :: W < MUXPOS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MUXPOS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MUXPOS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MUXPOS_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUXPOS` reader - Analog Channel Selection Bits"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; # [doc = "Analog Channel Selection Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: ADC input pin 0"]
AIN0 = 0 , # [doc = "1: ADC input pin 1"]
AIN1 = 1 , # [doc = "2: ADC input pin 2"]
AIN2 = 2 , # [doc = "3: ADC input pin 3"]
AIN3 = 3 , # [doc = "4: ADC input pin 4"]
AIN4 = 4 , # [doc = "5: ADC input pin 5"]
AIN5 = 5 , # [doc = "6: ADC input pin 6"]
AIN6 = 6 , # [doc = "7: ADC input pin 7"]
AIN7 = 7 , # [doc = "8: ADC input pin 8"]
AIN8 = 8 , # [doc = "9: ADC input pin 9"]
AIN9 = 9 , # [doc = "10: ADC input pin 10"]
AIN10 = 10 , # [doc = "11: ADC input pin 11"]
AIN11 = 11 , # [doc = "28: DAC0"]
DAC0 = 28 , # [doc = "29: Internal Ref"]
INTREF = 29 , # [doc = "30: Temp sensor"]
TEMPSENSE = 30 , # [doc = "31: GND"]
GND = 31 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MUXPOS_A > { match self . bits { 0 => Some (MUXPOS_A :: AIN0) , 1 => Some (MUXPOS_A :: AIN1) , 2 => Some (MUXPOS_A :: AIN2) , 3 => Some (MUXPOS_A :: AIN3) , 4 => Some (MUXPOS_A :: AIN4) , 5 => Some (MUXPOS_A :: AIN5) , 6 => Some (MUXPOS_A :: AIN6) , 7 => Some (MUXPOS_A :: AIN7) , 8 => Some (MUXPOS_A :: AIN8) , 9 => Some (MUXPOS_A :: AIN9) , 10 => Some (MUXPOS_A :: AIN10) , 11 => Some (MUXPOS_A :: AIN11) , 28 => Some (MUXPOS_A :: DAC0) , 29 => Some (MUXPOS_A :: INTREF) , 30 => Some (MUXPOS_A :: TEMPSENSE) , 31 => Some (MUXPOS_A :: GND) , _ => None , } } # [doc = "Checks if the value of the field is `AIN0`"]
# [inline (always)]
pub fn is_ain0 (& self) -> bool { * self == MUXPOS_A :: AIN0 } # [doc = "Checks if the value of the field is `AIN1`"]
# [inline (always)]
pub fn is_ain1 (& self) -> bool { * self == MUXPOS_A :: AIN1 } # [doc = "Checks if the value of the field is `AIN2`"]
# [inline (always)]
pub fn is_ain2 (& self) -> bool { * self == MUXPOS_A :: AIN2 } # [doc = "Checks if the value of the field is `AIN3`"]
# [inline (always)]
pub fn is_ain3 (& self) -> bool { * self == MUXPOS_A :: AIN3 } # [doc = "Checks if the value of the field is `AIN4`"]
# [inline (always)]
pub fn is_ain4 (& self) -> bool { * self == MUXPOS_A :: AIN4 } # [doc = "Checks if the value of the field is `AIN5`"]
# [inline (always)]
pub fn is_ain5 (& self) -> bool { * self == MUXPOS_A :: AIN5 } # [doc = "Checks if the value of the field is `AIN6`"]
# [inline (always)]
pub fn is_ain6 (& self) -> bool { * self == MUXPOS_A :: AIN6 } # [doc = "Checks if the value of the field is `AIN7`"]
# [inline (always)]
pub fn is_ain7 (& self) -> bool { * self == MUXPOS_A :: AIN7 } # [doc = "Checks if the value of the field is `AIN8`"]
# [inline (always)]
pub fn is_ain8 (& self) -> bool { * self == MUXPOS_A :: AIN8 } # [doc = "Checks if the value of the field is `AIN9`"]
# [inline (always)]
pub fn is_ain9 (& self) -> bool { * self == MUXPOS_A :: AIN9 } # [doc = "Checks if the value of the field is `AIN10`"]
# [inline (always)]
pub fn is_ain10 (& self) -> bool { * self == MUXPOS_A :: AIN10 } # [doc = "Checks if the value of the field is `AIN11`"]
# [inline (always)]
pub fn is_ain11 (& self) -> bool { * self == MUXPOS_A :: AIN11 } # [doc = "Checks if the value of the field is `DAC0`"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == MUXPOS_A :: DAC0 } # [doc = "Checks if the value of the field is `INTREF`"]
# [inline (always)]
pub fn is_intref (& self) -> bool { * self == MUXPOS_A :: INTREF } # [doc = "Checks if the value of the field is `TEMPSENSE`"]
# [inline (always)]
pub fn is_tempsense (& self) -> bool { * self == MUXPOS_A :: TEMPSENSE } # [doc = "Checks if the value of the field is `GND`"]
# [inline (always)]
pub fn is_gnd (& self) -> bool { * self == MUXPOS_A :: GND } } # [doc = "Field `MUXPOS` writer - Analog Channel Selection Bits"]
pub type MUXPOS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , MUXPOS_SPEC , u8 , MUXPOS_A , 5 , O > ; impl < 'a , const O : u8 > MUXPOS_W < 'a , O > { # [doc = "ADC input pin 0"]
# [inline (always)]
pub fn ain0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN0) } # [doc = "ADC input pin 1"]
# [inline (always)]
pub fn ain1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN1) } # [doc = "ADC input pin 2"]
# [inline (always)]
pub fn ain2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN2) } # [doc = "ADC input pin 3"]
# [inline (always)]
pub fn ain3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN3) } # [doc = "ADC input pin 4"]
# [inline (always)]
pub fn ain4 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN4) } # [doc = "ADC input pin 5"]
# [inline (always)]
pub fn ain5 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN5) } # [doc = "ADC input pin 6"]
# [inline (always)]
pub fn ain6 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN6) } # [doc = "ADC input pin 7"]
# [inline (always)]
pub fn ain7 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN7) } # [doc = "ADC input pin 8"]
# [inline (always)]
pub fn ain8 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN8) } # [doc = "ADC input pin 9"]
# [inline (always)]
pub fn ain9 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN9) } # [doc = "ADC input pin 10"]
# [inline (always)]
pub fn ain10 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN10) } # [doc = "ADC input pin 11"]
# [inline (always)]
pub fn ain11 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN11) } # [doc = "DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: DAC0) } # [doc = "Internal Ref"]
# [inline (always)]
pub fn intref (self) -> & 'a mut W { self . variant (MUXPOS_A :: INTREF) } # [doc = "Temp sensor"]
# [inline (always)]
pub fn tempsense (self) -> & 'a mut W { self . variant (MUXPOS_A :: TEMPSENSE) } # [doc = "GND"]
# [inline (always)]
pub fn gnd (self) -> & 'a mut W { self . variant (MUXPOS_A :: GND) } } impl R { # [doc = "Bits 0:4 - Analog Channel Selection Bits"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new (self . bits & 0x1f) } } impl W { # [doc = "Bits 0:4 - Analog Channel Selection Bits"]
# [inline (always)]
# [must_use]
pub fn muxpos (& mut self) -> MUXPOS_W < 0 > { MUXPOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Positive mux input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [muxpos](index.html) module"]
pub struct MUXPOS_SPEC ; impl crate :: RegisterSpec for MUXPOS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [muxpos::R](R) reader structure"]
impl crate :: Readable for MUXPOS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [muxpos::W](W) writer structure"]
impl crate :: Writable for MUXPOS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MUXPOS to value 0"]
impl crate :: Resettable for MUXPOS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RES (r) register accessor: an alias for `Reg<RES_SPEC>`"]
pub type RES = crate :: Reg < res :: RES_SPEC > ; # [doc = "ADC Accumulator Result"]
pub mod res { # [doc = "Register `RES` reader"]
pub struct R (crate :: R < RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RES_SPEC >) -> Self { R (reader) } } # [doc = "ADC Accumulator Result\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res](index.html) module"]
pub struct RES_SPEC ; impl crate :: RegisterSpec for RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [res::R](R) reader structure"]
impl crate :: Readable for RES_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RES to value 0"]
impl crate :: Resettable for RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SAMPCTRL (rw) register accessor: an alias for `Reg<SAMPCTRL_SPEC>`"]
pub type SAMPCTRL = crate :: Reg < sampctrl :: SAMPCTRL_SPEC > ; # [doc = "Sample Control"]
pub mod sampctrl { # [doc = "Register `SAMPCTRL` reader"]
pub struct R (crate :: R < SAMPCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SAMPCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SAMPCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SAMPCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SAMPCTRL` writer"]
pub struct W (crate :: W < SAMPCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SAMPCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SAMPCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SAMPCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SAMPLEN` reader - Sample lenght"]
pub type SAMPLEN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SAMPLEN` writer - Sample lenght"]
pub type SAMPLEN_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SAMPCTRL_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bits 0:4 - Sample lenght"]
# [inline (always)]
pub fn samplen (& self) -> SAMPLEN_R { SAMPLEN_R :: new (self . bits & 0x1f) } } impl W { # [doc = "Bits 0:4 - Sample lenght"]
# [inline (always)]
# [must_use]
pub fn samplen (& mut self) -> SAMPLEN_W < 0 > { SAMPLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sample Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sampctrl](index.html) module"]
pub struct SAMPCTRL_SPEC ; impl crate :: RegisterSpec for SAMPCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sampctrl::R](R) reader structure"]
impl crate :: Readable for SAMPCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sampctrl::W](W) writer structure"]
impl crate :: Writable for SAMPCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SAMPCTRL to value 0"]
impl crate :: Resettable for SAMPCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Data"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } # [doc = "Field `TEMP` reader - Temporary"]
pub type TEMP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TEMP` writer - Temporary"]
pub type TEMP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TEMP_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Temporary"]
# [inline (always)]
pub fn temp (& self) -> TEMP_R { TEMP_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Temporary"]
# [inline (always)]
# [must_use]
pub fn temp (& mut self) -> TEMP_W < 0 > { TEMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WINHT (rw) register accessor: an alias for `Reg<WINHT_SPEC>`"]
pub type WINHT = crate :: Reg < winht :: WINHT_SPEC > ; # [doc = "Window comparator high threshold"]
pub mod winht { # [doc = "Register `WINHT` reader"]
pub struct R (crate :: R < WINHT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINHT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINHT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINHT_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINHT` writer"]
pub struct W (crate :: W < WINHT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINHT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINHT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINHT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Window comparator high threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winht](index.html) module"]
pub struct WINHT_SPEC ; impl crate :: RegisterSpec for WINHT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [winht::R](R) reader structure"]
impl crate :: Readable for WINHT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winht::W](W) writer structure"]
impl crate :: Writable for WINHT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WINHT to value 0"]
impl crate :: Resettable for WINHT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WINLT (rw) register accessor: an alias for `Reg<WINLT_SPEC>`"]
pub type WINLT = crate :: Reg < winlt :: WINLT_SPEC > ; # [doc = "Window comparator low threshold"]
pub mod winlt { # [doc = "Register `WINLT` reader"]
pub struct R (crate :: R < WINLT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINLT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINLT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINLT_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINLT` writer"]
pub struct W (crate :: W < WINLT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINLT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINLT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINLT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Window comparator low threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winlt](index.html) module"]
pub struct WINLT_SPEC ; impl crate :: RegisterSpec for WINLT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [winlt::R](R) reader structure"]
impl crate :: Readable for WINLT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winlt::W](W) writer structure"]
impl crate :: Writable for WINLT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WINLT to value 0"]
impl crate :: Resettable for WINLT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Bod interface"]
pub struct BOD { _marker : PhantomData < * const () > } unsafe impl Send for BOD { } impl BOD { # [doc = r"Pointer to the register block"]
pub const PTR : * const bod :: RegisterBlock = 0x80 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const bod :: RegisterBlock { Self :: PTR } } impl Deref for BOD { type Target = bod :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for BOD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("BOD") . finish () } } # [doc = "Bod interface"]
pub mod bod { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , _reserved2 : [u8 ; 0x06]
, # [doc = "0x08 - Voltage level monitor Control"]
pub vlmctrla : VLMCTRLA , # [doc = "0x09 - Voltage level monitor interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x0a - Voltage level monitor interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0b - Voltage level monitor status"]
pub status : STATUS , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SLEEP` reader - Operation in sleep mode"]
pub type SLEEP_R = crate :: FieldReader < u8 , SLEEP_A > ; # [doc = "Operation in sleep mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SLEEP_A { # [doc = "0: Disabled"]
DIS = 0 , # [doc = "1: Enabled"]
ENABLED = 1 , # [doc = "2: Sampled"]
SAMPLED = 2 , } impl From < SLEEP_A > for u8 { # [inline (always)]
fn from (variant : SLEEP_A) -> Self { variant as _ } } impl SLEEP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SLEEP_A > { match self . bits { 0 => Some (SLEEP_A :: DIS) , 1 => Some (SLEEP_A :: ENABLED) , 2 => Some (SLEEP_A :: SAMPLED) , _ => None , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == SLEEP_A :: DIS } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * self == SLEEP_A :: ENABLED } # [doc = "Checks if the value of the field is `SAMPLED`"]
# [inline (always)]
pub fn is_sampled (& self) -> bool { * self == SLEEP_A :: SAMPLED } } # [doc = "Field `SLEEP` writer - Operation in sleep mode"]
pub type SLEEP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , SLEEP_A , 2 , O > ; impl < 'a , const O : u8 > SLEEP_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (SLEEP_A :: DIS) } # [doc = "Enabled"]
# [inline (always)]
pub fn enabled (self) -> & 'a mut W { self . variant (SLEEP_A :: ENABLED) } # [doc = "Sampled"]
# [inline (always)]
pub fn sampled (self) -> & 'a mut W { self . variant (SLEEP_A :: SAMPLED) } } # [doc = "Field `ACTIVE` reader - Operation in active mode"]
pub type ACTIVE_R = crate :: FieldReader < u8 , ACTIVE_A > ; # [doc = "Operation in active mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ACTIVE_A { # [doc = "0: Disabled"]
DIS = 0 , # [doc = "1: Enabled"]
ENABLED = 1 , # [doc = "2: Sampled"]
SAMPLED = 2 , # [doc = "3: Enabled with wakeup halt"]
ENWAKE = 3 , } impl From < ACTIVE_A > for u8 { # [inline (always)]
fn from (variant : ACTIVE_A) -> Self { variant as _ } } impl ACTIVE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACTIVE_A { match self . bits { 0 => ACTIVE_A :: DIS , 1 => ACTIVE_A :: ENABLED , 2 => ACTIVE_A :: SAMPLED , 3 => ACTIVE_A :: ENWAKE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == ACTIVE_A :: DIS } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * self == ACTIVE_A :: ENABLED } # [doc = "Checks if the value of the field is `SAMPLED`"]
# [inline (always)]
pub fn is_sampled (& self) -> bool { * self == ACTIVE_A :: SAMPLED } # [doc = "Checks if the value of the field is `ENWAKE`"]
# [inline (always)]
pub fn is_enwake (& self) -> bool { * self == ACTIVE_A :: ENWAKE } } # [doc = "Field `SAMPFREQ` reader - Sample frequency"]
pub type SAMPFREQ_R = crate :: BitReader < SAMPFREQ_A > ; # [doc = "Sample frequency\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SAMPFREQ_A { # [doc = "0: 1kHz sampling"]
_1KHZ = 0 , # [doc = "1: 125Hz sampling"]
_125HZ = 1 , } impl From < SAMPFREQ_A > for bool { # [inline (always)]
fn from (variant : SAMPFREQ_A) -> Self { variant as u8 != 0 } } impl SAMPFREQ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SAMPFREQ_A { match self . bits { false => SAMPFREQ_A :: _1KHZ , true => SAMPFREQ_A :: _125HZ , } } # [doc = "Checks if the value of the field is `_1KHZ`"]
# [inline (always)]
pub fn is_1khz (& self) -> bool { * self == SAMPFREQ_A :: _1KHZ } # [doc = "Checks if the value of the field is `_125HZ`"]
# [inline (always)]
pub fn is_125hz (& self) -> bool { * self == SAMPFREQ_A :: _125HZ } } impl R { # [doc = "Bits 0:1 - Operation in sleep mode"]
# [inline (always)]
pub fn sleep (& self) -> SLEEP_R { SLEEP_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Operation in active mode"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Sample frequency"]
# [inline (always)]
pub fn sampfreq (& self) -> SAMPFREQ_R { SAMPFREQ_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Operation in sleep mode"]
# [inline (always)]
# [must_use]
pub fn sleep (& mut self) -> SLEEP_W < 0 > { SLEEP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL` reader - Bod level"]
pub type LVL_R = crate :: FieldReader < u8 , LVL_A > ; # [doc = "Bod level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LVL_A { # [doc = "0: 1.8 V"]
BODLEVEL0 = 0 , # [doc = "1: 2.1 V"]
BODLEVEL1 = 1 , # [doc = "2: 2.6 V"]
BODLEVEL2 = 2 , # [doc = "3: 2.9 V"]
BODLEVEL3 = 3 , # [doc = "4: 3.3 V"]
BODLEVEL4 = 4 , # [doc = "5: 3.7 V"]
BODLEVEL5 = 5 , # [doc = "6: 4.0 V"]
BODLEVEL6 = 6 , # [doc = "7: 4.2 V"]
BODLEVEL7 = 7 , } impl From < LVL_A > for u8 { # [inline (always)]
fn from (variant : LVL_A) -> Self { variant as _ } } impl LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> LVL_A { match self . bits { 0 => LVL_A :: BODLEVEL0 , 1 => LVL_A :: BODLEVEL1 , 2 => LVL_A :: BODLEVEL2 , 3 => LVL_A :: BODLEVEL3 , 4 => LVL_A :: BODLEVEL4 , 5 => LVL_A :: BODLEVEL5 , 6 => LVL_A :: BODLEVEL6 , 7 => LVL_A :: BODLEVEL7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `BODLEVEL0`"]
# [inline (always)]
pub fn is_bodlevel0 (& self) -> bool { * self == LVL_A :: BODLEVEL0 } # [doc = "Checks if the value of the field is `BODLEVEL1`"]
# [inline (always)]
pub fn is_bodlevel1 (& self) -> bool { * self == LVL_A :: BODLEVEL1 } # [doc = "Checks if the value of the field is `BODLEVEL2`"]
# [inline (always)]
pub fn is_bodlevel2 (& self) -> bool { * self == LVL_A :: BODLEVEL2 } # [doc = "Checks if the value of the field is `BODLEVEL3`"]
# [inline (always)]
pub fn is_bodlevel3 (& self) -> bool { * self == LVL_A :: BODLEVEL3 } # [doc = "Checks if the value of the field is `BODLEVEL4`"]
# [inline (always)]
pub fn is_bodlevel4 (& self) -> bool { * self == LVL_A :: BODLEVEL4 } # [doc = "Checks if the value of the field is `BODLEVEL5`"]
# [inline (always)]
pub fn is_bodlevel5 (& self) -> bool { * self == LVL_A :: BODLEVEL5 } # [doc = "Checks if the value of the field is `BODLEVEL6`"]
# [inline (always)]
pub fn is_bodlevel6 (& self) -> bool { * self == LVL_A :: BODLEVEL6 } # [doc = "Checks if the value of the field is `BODLEVEL7`"]
# [inline (always)]
pub fn is_bodlevel7 (& self) -> bool { * self == LVL_A :: BODLEVEL7 } } impl R { # [doc = "Bits 0:2 - Bod level"]
# [inline (always)]
pub fn lvl (& self) -> LVL_R { LVL_R :: new (self . bits & 7) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Voltage level monitor interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `VLMIE` reader - voltage level monitor interrrupt enable"]
pub type VLMIE_R = crate :: BitReader < bool > ; # [doc = "Field `VLMIE` writer - voltage level monitor interrrupt enable"]
pub type VLMIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `VLMCFG` reader - Configuration"]
pub type VLMCFG_R = crate :: FieldReader < u8 , VLMCFG_A > ; # [doc = "Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VLMCFG_A { # [doc = "0: Interrupt when supply goes below VLM level"]
BELOW = 0 , # [doc = "1: Interrupt when supply goes above VLM level"]
ABOVE = 1 , # [doc = "2: Interrupt when supply crosses VLM level"]
CROSS = 2 , } impl From < VLMCFG_A > for u8 { # [inline (always)]
fn from (variant : VLMCFG_A) -> Self { variant as _ } } impl VLMCFG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < VLMCFG_A > { match self . bits { 0 => Some (VLMCFG_A :: BELOW) , 1 => Some (VLMCFG_A :: ABOVE) , 2 => Some (VLMCFG_A :: CROSS) , _ => None , } } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == VLMCFG_A :: BELOW } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == VLMCFG_A :: ABOVE } # [doc = "Checks if the value of the field is `CROSS`"]
# [inline (always)]
pub fn is_cross (& self) -> bool { * self == VLMCFG_A :: CROSS } } # [doc = "Field `VLMCFG` writer - Configuration"]
pub type VLMCFG_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , INTCTRL_SPEC , u8 , VLMCFG_A , 2 , O > ; impl < 'a , const O : u8 > VLMCFG_W < 'a , O > { # [doc = "Interrupt when supply goes below VLM level"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (VLMCFG_A :: BELOW) } # [doc = "Interrupt when supply goes above VLM level"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (VLMCFG_A :: ABOVE) } # [doc = "Interrupt when supply crosses VLM level"]
# [inline (always)]
pub fn cross (self) -> & 'a mut W { self . variant (VLMCFG_A :: CROSS) } } impl R { # [doc = "Bit 0 - voltage level monitor interrrupt enable"]
# [inline (always)]
pub fn vlmie (& self) -> VLMIE_R { VLMIE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Configuration"]
# [inline (always)]
pub fn vlmcfg (& self) -> VLMCFG_R { VLMCFG_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - voltage level monitor interrrupt enable"]
# [inline (always)]
# [must_use]
pub fn vlmie (& mut self) -> VLMIE_W < 0 > { VLMIE_W :: new (self) } # [doc = "Bits 1:2 - Configuration"]
# [inline (always)]
# [must_use]
pub fn vlmcfg (& mut self) -> VLMCFG_W < 1 > { VLMCFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage level monitor interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Voltage level monitor interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `VLMIF` reader - Voltage level monitor interrupt flag"]
pub type VLMIF_R = crate :: BitReader < bool > ; # [doc = "Field `VLMIF` writer - Voltage level monitor interrupt flag"]
pub type VLMIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Voltage level monitor interrupt flag"]
# [inline (always)]
pub fn vlmif (& self) -> VLMIF_R { VLMIF_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Voltage level monitor interrupt flag"]
# [inline (always)]
# [must_use]
pub fn vlmif (& mut self) -> VLMIF_W < 0 > { VLMIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage level monitor interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Voltage level monitor status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `VLMS` reader - Voltage level monitor status"]
pub type VLMS_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Voltage level monitor status"]
# [inline (always)]
pub fn vlms (& self) -> VLMS_R { VLMS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage level monitor status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VLMCTRLA (rw) register accessor: an alias for `Reg<VLMCTRLA_SPEC>`"]
pub type VLMCTRLA = crate :: Reg < vlmctrla :: VLMCTRLA_SPEC > ; # [doc = "Voltage level monitor Control"]
pub mod vlmctrla { # [doc = "Register `VLMCTRLA` reader"]
pub struct R (crate :: R < VLMCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VLMCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VLMCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VLMCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `VLMCTRLA` writer"]
pub struct W (crate :: W < VLMCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < VLMCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < VLMCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < VLMCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `VLMLVL` reader - voltage level monitor level"]
pub type VLMLVL_R = crate :: FieldReader < u8 , VLMLVL_A > ; # [doc = "voltage level monitor level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VLMLVL_A { # [doc = "0: VLM threshold 5% above BOD level"]
_5ABOVE = 0 , # [doc = "1: VLM threshold 15% above BOD level"]
_15ABOVE = 1 , # [doc = "2: VLM threshold 25% above BOD level"]
_25ABOVE = 2 , } impl From < VLMLVL_A > for u8 { # [inline (always)]
fn from (variant : VLMLVL_A) -> Self { variant as _ } } impl VLMLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < VLMLVL_A > { match self . bits { 0 => Some (VLMLVL_A :: _5ABOVE) , 1 => Some (VLMLVL_A :: _15ABOVE) , 2 => Some (VLMLVL_A :: _25ABOVE) , _ => None , } } # [doc = "Checks if the value of the field is `_5ABOVE`"]
# [inline (always)]
pub fn is_5above (& self) -> bool { * self == VLMLVL_A :: _5ABOVE } # [doc = "Checks if the value of the field is `_15ABOVE`"]
# [inline (always)]
pub fn is_15above (& self) -> bool { * self == VLMLVL_A :: _15ABOVE } # [doc = "Checks if the value of the field is `_25ABOVE`"]
# [inline (always)]
pub fn is_25above (& self) -> bool { * self == VLMLVL_A :: _25ABOVE } } # [doc = "Field `VLMLVL` writer - voltage level monitor level"]
pub type VLMLVL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , VLMCTRLA_SPEC , u8 , VLMLVL_A , 2 , O > ; impl < 'a , const O : u8 > VLMLVL_W < 'a , O > { # [doc = "VLM threshold 5% above BOD level"]
# [inline (always)]
pub fn _5above (self) -> & 'a mut W { self . variant (VLMLVL_A :: _5ABOVE) } # [doc = "VLM threshold 15% above BOD level"]
# [inline (always)]
pub fn _15above (self) -> & 'a mut W { self . variant (VLMLVL_A :: _15ABOVE) } # [doc = "VLM threshold 25% above BOD level"]
# [inline (always)]
pub fn _25above (self) -> & 'a mut W { self . variant (VLMLVL_A :: _25ABOVE) } } impl R { # [doc = "Bits 0:1 - voltage level monitor level"]
# [inline (always)]
pub fn vlmlvl (& self) -> VLMLVL_R { VLMLVL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - voltage level monitor level"]
# [inline (always)]
# [must_use]
pub fn vlmlvl (& mut self) -> VLMLVL_W < 0 > { VLMLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage level monitor Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vlmctrla](index.html) module"]
pub struct VLMCTRLA_SPEC ; impl crate :: RegisterSpec for VLMCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [vlmctrla::R](R) reader structure"]
impl crate :: Readable for VLMCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [vlmctrla::W](W) writer structure"]
impl crate :: Writable for VLMCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VLMCTRLA to value 0"]
impl crate :: Resettable for VLMCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Configurable Custom Logic"]
pub struct CCL { _marker : PhantomData < * const () > } unsafe impl Send for CCL { } impl CCL { # [doc = r"Pointer to the register block"]
pub const PTR : * const ccl :: RegisterBlock = 0x01c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ccl :: RegisterBlock { Self :: PTR } } impl Deref for CCL { type Target = ccl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CCL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CCL") . finish () } } # [doc = "Configurable Custom Logic"]
pub mod ccl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Sequential Control 0"]
pub seqctrl0 : SEQCTRL0 , _reserved2 : [u8 ; 0x03]
, # [doc = "0x05 - LUT Control 0 A"]
pub lut0ctrla : LUT0CTRLA , # [doc = "0x06 - LUT Control 0 B"]
pub lut0ctrlb : LUT0CTRLB , # [doc = "0x07 - LUT Control 0 C"]
pub lut0ctrlc : LUT0CTRLC , # [doc = "0x08 - Truth 0"]
pub truth0 : TRUTH0 , # [doc = "0x09 - LUT Control 1 A"]
pub lut1ctrla : LUT1CTRLA , # [doc = "0x0a - LUT Control 1 B"]
pub lut1ctrlb : LUT1CTRLB , # [doc = "0x0b - LUT Control 1 C"]
pub lut1ctrlc : LUT1CTRLC , # [doc = "0x0c - Truth 1"]
pub truth1 : TRUTH1 , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 6 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT0CTRLA (rw) register accessor: an alias for `Reg<LUT0CTRLA_SPEC>`"]
pub type LUT0CTRLA = crate :: Reg < lut0ctrla :: LUT0CTRLA_SPEC > ; # [doc = "LUT Control 0 A"]
pub mod lut0ctrla { # [doc = "Register `LUT0CTRLA` reader"]
pub struct R (crate :: R < LUT0CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT0CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT0CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT0CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT0CTRLA` writer"]
pub struct W (crate :: W < LUT0CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT0CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT0CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT0CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - LUT Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - LUT Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT0CTRLA_SPEC , bool , O > ; # [doc = "Field `OUTEN` reader - Output Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT0CTRLA_SPEC , bool , O > ; # [doc = "Field `FILTSEL` reader - Filter Selection"]
pub type FILTSEL_R = crate :: FieldReader < u8 , FILTSEL_A > ; # [doc = "Filter Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FILTSEL_A { # [doc = "0: Filter disabled"]
DISABLE = 0 , # [doc = "1: Synchronizer enabled"]
SYNCH = 1 , # [doc = "2: Filter enabled"]
FILTER = 2 , } impl From < FILTSEL_A > for u8 { # [inline (always)]
fn from (variant : FILTSEL_A) -> Self { variant as _ } } impl FILTSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FILTSEL_A > { match self . bits { 0 => Some (FILTSEL_A :: DISABLE) , 1 => Some (FILTSEL_A :: SYNCH) , 2 => Some (FILTSEL_A :: FILTER) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FILTSEL_A :: DISABLE } # [doc = "Checks if the value of the field is `SYNCH`"]
# [inline (always)]
pub fn is_synch (& self) -> bool { * self == FILTSEL_A :: SYNCH } # [doc = "Checks if the value of the field is `FILTER`"]
# [inline (always)]
pub fn is_filter (& self) -> bool { * self == FILTSEL_A :: FILTER } } # [doc = "Field `FILTSEL` writer - Filter Selection"]
pub type FILTSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLA_SPEC , u8 , FILTSEL_A , 2 , O > ; impl < 'a , const O : u8 > FILTSEL_W < 'a , O > { # [doc = "Filter disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (FILTSEL_A :: DISABLE) } # [doc = "Synchronizer enabled"]
# [inline (always)]
pub fn synch (self) -> & 'a mut W { self . variant (FILTSEL_A :: SYNCH) } # [doc = "Filter enabled"]
# [inline (always)]
pub fn filter (self) -> & 'a mut W { self . variant (FILTSEL_A :: FILTER) } } # [doc = "Field `CLKSRC` reader - Clock Source Selection"]
pub type CLKSRC_R = crate :: BitReader < bool > ; # [doc = "Field `CLKSRC` writer - Clock Source Selection"]
pub type CLKSRC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT0CTRLA_SPEC , bool , O > ; # [doc = "Field `EDGEDET` reader - Edge Detection Enable"]
pub type EDGEDET_R = crate :: BitReader < EDGEDET_A > ; # [doc = "Edge Detection Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EDGEDET_A { # [doc = "0: Edge detector is disabled"]
DIS = 0 , # [doc = "1: Edge detector is enabled"]
EN = 1 , } impl From < EDGEDET_A > for bool { # [inline (always)]
fn from (variant : EDGEDET_A) -> Self { variant as u8 != 0 } } impl EDGEDET_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGEDET_A { match self . bits { false => EDGEDET_A :: DIS , true => EDGEDET_A :: EN , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == EDGEDET_A :: DIS } # [doc = "Checks if the value of the field is `EN`"]
# [inline (always)]
pub fn is_en (& self) -> bool { * self == EDGEDET_A :: EN } } # [doc = "Field `EDGEDET` writer - Edge Detection Enable"]
pub type EDGEDET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT0CTRLA_SPEC , EDGEDET_A , O > ; impl < 'a , const O : u8 > EDGEDET_W < 'a , O > { # [doc = "Edge detector is disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (EDGEDET_A :: DIS) } # [doc = "Edge detector is enabled"]
# [inline (always)]
pub fn en (self) -> & 'a mut W { self . variant (EDGEDET_A :: EN) } } impl R { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 3 - Output Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
pub fn filtsel (& self) -> FILTSEL_R { FILTSEL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Clock Source Selection"]
# [inline (always)]
pub fn clksrc (& self) -> CLKSRC_R { CLKSRC_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
pub fn edgedet (& self) -> EDGEDET_R { EDGEDET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 3 - Output Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 3 > { OUTEN_W :: new (self) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
# [must_use]
pub fn filtsel (& mut self) -> FILTSEL_W < 4 > { FILTSEL_W :: new (self) } # [doc = "Bit 6 - Clock Source Selection"]
# [inline (always)]
# [must_use]
pub fn clksrc (& mut self) -> CLKSRC_W < 6 > { CLKSRC_W :: new (self) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
# [must_use]
pub fn edgedet (& mut self) -> EDGEDET_W < 7 > { EDGEDET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 0 A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut0ctrla](index.html) module"]
pub struct LUT0CTRLA_SPEC ; impl crate :: RegisterSpec for LUT0CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut0ctrla::R](R) reader structure"]
impl crate :: Readable for LUT0CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut0ctrla::W](W) writer structure"]
impl crate :: Writable for LUT0CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT0CTRLA to value 0"]
impl crate :: Resettable for LUT0CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT0CTRLB (rw) register accessor: an alias for `Reg<LUT0CTRLB_SPEC>`"]
pub type LUT0CTRLB = crate :: Reg < lut0ctrlb :: LUT0CTRLB_SPEC > ; # [doc = "LUT Control 0 B"]
pub mod lut0ctrlb { # [doc = "Register `LUT0CTRLB` reader"]
pub struct R (crate :: R < LUT0CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT0CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT0CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT0CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT0CTRLB` writer"]
pub struct W (crate :: W < LUT0CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT0CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT0CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT0CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL0` reader - LUT Input 0 Source Selection"]
pub type INSEL0_R = crate :: FieldReader < u8 , INSEL0_A > ; # [doc = "LUT Input 0 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL0_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source 0"]
EVENT0 = 3 , # [doc = "4: Event input source 1"]
EVENT1 = 4 , # [doc = "5: IO pin LUTn-IN0 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "7: TCB0 WO input source"]
TCB0 = 7 , # [doc = "8: TCA0 WO0 input source"]
TCA0 = 8 , # [doc = "9: TCD0 WOA input source"]
TCD0 = 9 , # [doc = "10: USART0 XCK input source"]
USART0 = 10 , # [doc = "11: SPI0 SCK source"]
SPI0 = 11 , } impl From < INSEL0_A > for u8 { # [inline (always)]
fn from (variant : INSEL0_A) -> Self { variant as _ } } impl INSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL0_A > { match self . bits { 0 => Some (INSEL0_A :: MASK) , 1 => Some (INSEL0_A :: FEEDBACK) , 2 => Some (INSEL0_A :: LINK) , 3 => Some (INSEL0_A :: EVENT0) , 4 => Some (INSEL0_A :: EVENT1) , 5 => Some (INSEL0_A :: IO) , 6 => Some (INSEL0_A :: AC0) , 7 => Some (INSEL0_A :: TCB0) , 8 => Some (INSEL0_A :: TCA0) , 9 => Some (INSEL0_A :: TCD0) , 10 => Some (INSEL0_A :: USART0) , 11 => Some (INSEL0_A :: SPI0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL0_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL0_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL0_A :: LINK } # [doc = "Checks if the value of the field is `EVENT0`"]
# [inline (always)]
pub fn is_event0 (& self) -> bool { * self == INSEL0_A :: EVENT0 } # [doc = "Checks if the value of the field is `EVENT1`"]
# [inline (always)]
pub fn is_event1 (& self) -> bool { * self == INSEL0_A :: EVENT1 } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL0_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL0_A :: AC0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL0_A :: TCB0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL0_A :: TCA0 } # [doc = "Checks if the value of the field is `TCD0`"]
# [inline (always)]
pub fn is_tcd0 (& self) -> bool { * self == INSEL0_A :: TCD0 } # [doc = "Checks if the value of the field is `USART0`"]
# [inline (always)]
pub fn is_usart0 (& self) -> bool { * self == INSEL0_A :: USART0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL0_A :: SPI0 } } # [doc = "Field `INSEL0` writer - LUT Input 0 Source Selection"]
pub type INSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLB_SPEC , u8 , INSEL0_A , 4 , O > ; impl < 'a , const O : u8 > INSEL0_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL0_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL0_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL0_A :: LINK) } # [doc = "Event input source 0"]
# [inline (always)]
pub fn event0 (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENT0) } # [doc = "Event input source 1"]
# [inline (always)]
pub fn event1 (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENT1) } # [doc = "IO pin LUTn-IN0 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL0_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL0_A :: AC0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCB0) } # [doc = "TCA0 WO0 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCA0) } # [doc = "TCD0 WOA input source"]
# [inline (always)]
pub fn tcd0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCD0) } # [doc = "USART0 XCK input source"]
# [inline (always)]
pub fn usart0 (self) -> & 'a mut W { self . variant (INSEL0_A :: USART0) } # [doc = "SPI0 SCK source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL0_A :: SPI0) } } # [doc = "Field `INSEL1` reader - LUT Input 1 Source Selection"]
pub type INSEL1_R = crate :: FieldReader < u8 , INSEL1_A > ; # [doc = "LUT Input 1 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL1_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source 0"]
EVENT0 = 3 , # [doc = "4: Event input source 1"]
EVENT1 = 4 , # [doc = "5: IO pin LUTn-N1 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "7: TCB0 WO input source"]
TCB0 = 7 , # [doc = "8: TCA0 WO1 input source"]
TCA0 = 8 , # [doc = "9: TCD0 WOB input source"]
TCD0 = 9 , # [doc = "10: USART0 TXD input source"]
USART0 = 10 , # [doc = "11: SPI0 MOSI input source"]
SPI0 = 11 , } impl From < INSEL1_A > for u8 { # [inline (always)]
fn from (variant : INSEL1_A) -> Self { variant as _ } } impl INSEL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL1_A > { match self . bits { 0 => Some (INSEL1_A :: MASK) , 1 => Some (INSEL1_A :: FEEDBACK) , 2 => Some (INSEL1_A :: LINK) , 3 => Some (INSEL1_A :: EVENT0) , 4 => Some (INSEL1_A :: EVENT1) , 5 => Some (INSEL1_A :: IO) , 6 => Some (INSEL1_A :: AC0) , 7 => Some (INSEL1_A :: TCB0) , 8 => Some (INSEL1_A :: TCA0) , 9 => Some (INSEL1_A :: TCD0) , 10 => Some (INSEL1_A :: USART0) , 11 => Some (INSEL1_A :: SPI0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL1_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL1_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL1_A :: LINK } # [doc = "Checks if the value of the field is `EVENT0`"]
# [inline (always)]
pub fn is_event0 (& self) -> bool { * self == INSEL1_A :: EVENT0 } # [doc = "Checks if the value of the field is `EVENT1`"]
# [inline (always)]
pub fn is_event1 (& self) -> bool { * self == INSEL1_A :: EVENT1 } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL1_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL1_A :: AC0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL1_A :: TCB0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL1_A :: TCA0 } # [doc = "Checks if the value of the field is `TCD0`"]
# [inline (always)]
pub fn is_tcd0 (& self) -> bool { * self == INSEL1_A :: TCD0 } # [doc = "Checks if the value of the field is `USART0`"]
# [inline (always)]
pub fn is_usart0 (& self) -> bool { * self == INSEL1_A :: USART0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL1_A :: SPI0 } } # [doc = "Field `INSEL1` writer - LUT Input 1 Source Selection"]
pub type INSEL1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLB_SPEC , u8 , INSEL1_A , 4 , O > ; impl < 'a , const O : u8 > INSEL1_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL1_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL1_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL1_A :: LINK) } # [doc = "Event input source 0"]
# [inline (always)]
pub fn event0 (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENT0) } # [doc = "Event input source 1"]
# [inline (always)]
pub fn event1 (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENT1) } # [doc = "IO pin LUTn-N1 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL1_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL1_A :: AC0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCB0) } # [doc = "TCA0 WO1 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCA0) } # [doc = "TCD0 WOB input source"]
# [inline (always)]
pub fn tcd0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCD0) } # [doc = "USART0 TXD input source"]
# [inline (always)]
pub fn usart0 (self) -> & 'a mut W { self . variant (INSEL1_A :: USART0) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL1_A :: SPI0) } } impl R { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
pub fn insel0 (& self) -> INSEL0_R { INSEL0_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
pub fn insel1 (& self) -> INSEL1_R { INSEL1_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel0 (& mut self) -> INSEL0_W < 0 > { INSEL0_W :: new (self) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel1 (& mut self) -> INSEL1_W < 4 > { INSEL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 0 B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut0ctrlb](index.html) module"]
pub struct LUT0CTRLB_SPEC ; impl crate :: RegisterSpec for LUT0CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut0ctrlb::R](R) reader structure"]
impl crate :: Readable for LUT0CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut0ctrlb::W](W) writer structure"]
impl crate :: Writable for LUT0CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT0CTRLB to value 0"]
impl crate :: Resettable for LUT0CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT0CTRLC (rw) register accessor: an alias for `Reg<LUT0CTRLC_SPEC>`"]
pub type LUT0CTRLC = crate :: Reg < lut0ctrlc :: LUT0CTRLC_SPEC > ; # [doc = "LUT Control 0 C"]
pub mod lut0ctrlc { # [doc = "Register `LUT0CTRLC` reader"]
pub struct R (crate :: R < LUT0CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT0CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT0CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT0CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT0CTRLC` writer"]
pub struct W (crate :: W < LUT0CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT0CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT0CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT0CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL2` reader - LUT Input 2 Source Selection"]
pub type INSEL2_R = crate :: FieldReader < u8 , INSEL2_A > ; # [doc = "LUT Input 2 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL2_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source 0"]
EVENT0 = 3 , # [doc = "4: Event input source 1"]
EVENT1 = 4 , # [doc = "5: IO pin LUTn-IN2 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "7: TCB0 WO input source"]
TCB0 = 7 , # [doc = "8: TCA0 WO2 input source"]
TCA0 = 8 , # [doc = "9: TCD0 WOA input source"]
TCD0 = 9 , # [doc = "11: SPI0 MISO source"]
SPI0 = 11 , } impl From < INSEL2_A > for u8 { # [inline (always)]
fn from (variant : INSEL2_A) -> Self { variant as _ } } impl INSEL2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL2_A > { match self . bits { 0 => Some (INSEL2_A :: MASK) , 1 => Some (INSEL2_A :: FEEDBACK) , 2 => Some (INSEL2_A :: LINK) , 3 => Some (INSEL2_A :: EVENT0) , 4 => Some (INSEL2_A :: EVENT1) , 5 => Some (INSEL2_A :: IO) , 6 => Some (INSEL2_A :: AC0) , 7 => Some (INSEL2_A :: TCB0) , 8 => Some (INSEL2_A :: TCA0) , 9 => Some (INSEL2_A :: TCD0) , 11 => Some (INSEL2_A :: SPI0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL2_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL2_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL2_A :: LINK } # [doc = "Checks if the value of the field is `EVENT0`"]
# [inline (always)]
pub fn is_event0 (& self) -> bool { * self == INSEL2_A :: EVENT0 } # [doc = "Checks if the value of the field is `EVENT1`"]
# [inline (always)]
pub fn is_event1 (& self) -> bool { * self == INSEL2_A :: EVENT1 } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL2_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL2_A :: AC0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL2_A :: TCB0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL2_A :: TCA0 } # [doc = "Checks if the value of the field is `TCD0`"]
# [inline (always)]
pub fn is_tcd0 (& self) -> bool { * self == INSEL2_A :: TCD0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL2_A :: SPI0 } } # [doc = "Field `INSEL2` writer - LUT Input 2 Source Selection"]
pub type INSEL2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLC_SPEC , u8 , INSEL2_A , 4 , O > ; impl < 'a , const O : u8 > INSEL2_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL2_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL2_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL2_A :: LINK) } # [doc = "Event input source 0"]
# [inline (always)]
pub fn event0 (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENT0) } # [doc = "Event input source 1"]
# [inline (always)]
pub fn event1 (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENT1) } # [doc = "IO pin LUTn-IN2 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL2_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL2_A :: AC0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCB0) } # [doc = "TCA0 WO2 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCA0) } # [doc = "TCD0 WOA input source"]
# [inline (always)]
pub fn tcd0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCD0) } # [doc = "SPI0 MISO source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL2_A :: SPI0) } } impl R { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
pub fn insel2 (& self) -> INSEL2_R { INSEL2_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel2 (& mut self) -> INSEL2_W < 0 > { INSEL2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 0 C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut0ctrlc](index.html) module"]
pub struct LUT0CTRLC_SPEC ; impl crate :: RegisterSpec for LUT0CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut0ctrlc::R](R) reader structure"]
impl crate :: Readable for LUT0CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut0ctrlc::W](W) writer structure"]
impl crate :: Writable for LUT0CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT0CTRLC to value 0"]
impl crate :: Resettable for LUT0CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT1CTRLA (rw) register accessor: an alias for `Reg<LUT1CTRLA_SPEC>`"]
pub type LUT1CTRLA = crate :: Reg < lut1ctrla :: LUT1CTRLA_SPEC > ; # [doc = "LUT Control 1 A"]
pub mod lut1ctrla { # [doc = "Register `LUT1CTRLA` reader"]
pub struct R (crate :: R < LUT1CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT1CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT1CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT1CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT1CTRLA` writer"]
pub struct W (crate :: W < LUT1CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT1CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT1CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT1CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - LUT Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - LUT Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT1CTRLA_SPEC , bool , O > ; # [doc = "Field `OUTEN` reader - Output Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT1CTRLA_SPEC , bool , O > ; # [doc = "Field `FILTSEL` reader - Filter Selection"]
pub type FILTSEL_R = crate :: FieldReader < u8 , FILTSEL_A > ; # [doc = "Filter Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FILTSEL_A { # [doc = "0: Filter disabled"]
DISABLE = 0 , # [doc = "1: Synchronizer enabled"]
SYNCH = 1 , # [doc = "2: Filter enabled"]
FILTER = 2 , } impl From < FILTSEL_A > for u8 { # [inline (always)]
fn from (variant : FILTSEL_A) -> Self { variant as _ } } impl FILTSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FILTSEL_A > { match self . bits { 0 => Some (FILTSEL_A :: DISABLE) , 1 => Some (FILTSEL_A :: SYNCH) , 2 => Some (FILTSEL_A :: FILTER) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FILTSEL_A :: DISABLE } # [doc = "Checks if the value of the field is `SYNCH`"]
# [inline (always)]
pub fn is_synch (& self) -> bool { * self == FILTSEL_A :: SYNCH } # [doc = "Checks if the value of the field is `FILTER`"]
# [inline (always)]
pub fn is_filter (& self) -> bool { * self == FILTSEL_A :: FILTER } } # [doc = "Field `FILTSEL` writer - Filter Selection"]
pub type FILTSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLA_SPEC , u8 , FILTSEL_A , 2 , O > ; impl < 'a , const O : u8 > FILTSEL_W < 'a , O > { # [doc = "Filter disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (FILTSEL_A :: DISABLE) } # [doc = "Synchronizer enabled"]
# [inline (always)]
pub fn synch (self) -> & 'a mut W { self . variant (FILTSEL_A :: SYNCH) } # [doc = "Filter enabled"]
# [inline (always)]
pub fn filter (self) -> & 'a mut W { self . variant (FILTSEL_A :: FILTER) } } # [doc = "Field `CLKSRC` reader - Clock Source Selection"]
pub type CLKSRC_R = crate :: BitReader < bool > ; # [doc = "Field `CLKSRC` writer - Clock Source Selection"]
pub type CLKSRC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT1CTRLA_SPEC , bool , O > ; # [doc = "Field `EDGEDET` reader - Edge Detection Enable"]
pub type EDGEDET_R = crate :: BitReader < EDGEDET_A > ; # [doc = "Edge Detection Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EDGEDET_A { # [doc = "0: Edge detector is disabled"]
DIS = 0 , # [doc = "1: Edge detector is enabled"]
EN = 1 , } impl From < EDGEDET_A > for bool { # [inline (always)]
fn from (variant : EDGEDET_A) -> Self { variant as u8 != 0 } } impl EDGEDET_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGEDET_A { match self . bits { false => EDGEDET_A :: DIS , true => EDGEDET_A :: EN , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == EDGEDET_A :: DIS } # [doc = "Checks if the value of the field is `EN`"]
# [inline (always)]
pub fn is_en (& self) -> bool { * self == EDGEDET_A :: EN } } # [doc = "Field `EDGEDET` writer - Edge Detection Enable"]
pub type EDGEDET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT1CTRLA_SPEC , EDGEDET_A , O > ; impl < 'a , const O : u8 > EDGEDET_W < 'a , O > { # [doc = "Edge detector is disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (EDGEDET_A :: DIS) } # [doc = "Edge detector is enabled"]
# [inline (always)]
pub fn en (self) -> & 'a mut W { self . variant (EDGEDET_A :: EN) } } impl R { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 3 - Output Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
pub fn filtsel (& self) -> FILTSEL_R { FILTSEL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Clock Source Selection"]
# [inline (always)]
pub fn clksrc (& self) -> CLKSRC_R { CLKSRC_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
pub fn edgedet (& self) -> EDGEDET_R { EDGEDET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 3 - Output Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 3 > { OUTEN_W :: new (self) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
# [must_use]
pub fn filtsel (& mut self) -> FILTSEL_W < 4 > { FILTSEL_W :: new (self) } # [doc = "Bit 6 - Clock Source Selection"]
# [inline (always)]
# [must_use]
pub fn clksrc (& mut self) -> CLKSRC_W < 6 > { CLKSRC_W :: new (self) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
# [must_use]
pub fn edgedet (& mut self) -> EDGEDET_W < 7 > { EDGEDET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 1 A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut1ctrla](index.html) module"]
pub struct LUT1CTRLA_SPEC ; impl crate :: RegisterSpec for LUT1CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut1ctrla::R](R) reader structure"]
impl crate :: Readable for LUT1CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut1ctrla::W](W) writer structure"]
impl crate :: Writable for LUT1CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT1CTRLA to value 0"]
impl crate :: Resettable for LUT1CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT1CTRLB (rw) register accessor: an alias for `Reg<LUT1CTRLB_SPEC>`"]
pub type LUT1CTRLB = crate :: Reg < lut1ctrlb :: LUT1CTRLB_SPEC > ; # [doc = "LUT Control 1 B"]
pub mod lut1ctrlb { # [doc = "Register `LUT1CTRLB` reader"]
pub struct R (crate :: R < LUT1CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT1CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT1CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT1CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT1CTRLB` writer"]
pub struct W (crate :: W < LUT1CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT1CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT1CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT1CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL0` reader - LUT Input 0 Source Selection"]
pub type INSEL0_R = crate :: FieldReader < u8 , INSEL0_A > ; # [doc = "LUT Input 0 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL0_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source 0"]
EVENT0 = 3 , # [doc = "4: Event input source 1"]
EVENT1 = 4 , # [doc = "5: IO pin LUTn-IN0 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "7: TCB0 WO input source"]
TCB0 = 7 , # [doc = "8: TCA0 WO0 input source"]
TCA0 = 8 , # [doc = "9: TCD0 WOA input source"]
TCD0 = 9 , # [doc = "10: USART0 XCK input source"]
USART0 = 10 , # [doc = "11: SPI0 SCK source"]
SPI0 = 11 , } impl From < INSEL0_A > for u8 { # [inline (always)]
fn from (variant : INSEL0_A) -> Self { variant as _ } } impl INSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL0_A > { match self . bits { 0 => Some (INSEL0_A :: MASK) , 1 => Some (INSEL0_A :: FEEDBACK) , 2 => Some (INSEL0_A :: LINK) , 3 => Some (INSEL0_A :: EVENT0) , 4 => Some (INSEL0_A :: EVENT1) , 5 => Some (INSEL0_A :: IO) , 6 => Some (INSEL0_A :: AC0) , 7 => Some (INSEL0_A :: TCB0) , 8 => Some (INSEL0_A :: TCA0) , 9 => Some (INSEL0_A :: TCD0) , 10 => Some (INSEL0_A :: USART0) , 11 => Some (INSEL0_A :: SPI0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL0_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL0_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL0_A :: LINK } # [doc = "Checks if the value of the field is `EVENT0`"]
# [inline (always)]
pub fn is_event0 (& self) -> bool { * self == INSEL0_A :: EVENT0 } # [doc = "Checks if the value of the field is `EVENT1`"]
# [inline (always)]
pub fn is_event1 (& self) -> bool { * self == INSEL0_A :: EVENT1 } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL0_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL0_A :: AC0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL0_A :: TCB0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL0_A :: TCA0 } # [doc = "Checks if the value of the field is `TCD0`"]
# [inline (always)]
pub fn is_tcd0 (& self) -> bool { * self == INSEL0_A :: TCD0 } # [doc = "Checks if the value of the field is `USART0`"]
# [inline (always)]
pub fn is_usart0 (& self) -> bool { * self == INSEL0_A :: USART0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL0_A :: SPI0 } } # [doc = "Field `INSEL0` writer - LUT Input 0 Source Selection"]
pub type INSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLB_SPEC , u8 , INSEL0_A , 4 , O > ; impl < 'a , const O : u8 > INSEL0_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL0_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL0_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL0_A :: LINK) } # [doc = "Event input source 0"]
# [inline (always)]
pub fn event0 (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENT0) } # [doc = "Event input source 1"]
# [inline (always)]
pub fn event1 (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENT1) } # [doc = "IO pin LUTn-IN0 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL0_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL0_A :: AC0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCB0) } # [doc = "TCA0 WO0 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCA0) } # [doc = "TCD0 WOA input source"]
# [inline (always)]
pub fn tcd0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCD0) } # [doc = "USART0 XCK input source"]
# [inline (always)]
pub fn usart0 (self) -> & 'a mut W { self . variant (INSEL0_A :: USART0) } # [doc = "SPI0 SCK source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL0_A :: SPI0) } } # [doc = "Field `INSEL1` reader - LUT Input 1 Source Selection"]
pub type INSEL1_R = crate :: FieldReader < u8 , INSEL1_A > ; # [doc = "LUT Input 1 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL1_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source 0"]
EVENT0 = 3 , # [doc = "4: Event input source 1"]
EVENT1 = 4 , # [doc = "5: IO pin LUTn-N1 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "7: TCB0 WO input source"]
TCB0 = 7 , # [doc = "8: TCA0 WO1 input source"]
TCA0 = 8 , # [doc = "9: TCD0 WOB input source"]
TCD0 = 9 , # [doc = "10: USART0 TXD input source"]
USART0 = 10 , # [doc = "11: SPI0 MOSI input source"]
SPI0 = 11 , } impl From < INSEL1_A > for u8 { # [inline (always)]
fn from (variant : INSEL1_A) -> Self { variant as _ } } impl INSEL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL1_A > { match self . bits { 0 => Some (INSEL1_A :: MASK) , 1 => Some (INSEL1_A :: FEEDBACK) , 2 => Some (INSEL1_A :: LINK) , 3 => Some (INSEL1_A :: EVENT0) , 4 => Some (INSEL1_A :: EVENT1) , 5 => Some (INSEL1_A :: IO) , 6 => Some (INSEL1_A :: AC0) , 7 => Some (INSEL1_A :: TCB0) , 8 => Some (INSEL1_A :: TCA0) , 9 => Some (INSEL1_A :: TCD0) , 10 => Some (INSEL1_A :: USART0) , 11 => Some (INSEL1_A :: SPI0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL1_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL1_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL1_A :: LINK } # [doc = "Checks if the value of the field is `EVENT0`"]
# [inline (always)]
pub fn is_event0 (& self) -> bool { * self == INSEL1_A :: EVENT0 } # [doc = "Checks if the value of the field is `EVENT1`"]
# [inline (always)]
pub fn is_event1 (& self) -> bool { * self == INSEL1_A :: EVENT1 } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL1_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL1_A :: AC0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL1_A :: TCB0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL1_A :: TCA0 } # [doc = "Checks if the value of the field is `TCD0`"]
# [inline (always)]
pub fn is_tcd0 (& self) -> bool { * self == INSEL1_A :: TCD0 } # [doc = "Checks if the value of the field is `USART0`"]
# [inline (always)]
pub fn is_usart0 (& self) -> bool { * self == INSEL1_A :: USART0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL1_A :: SPI0 } } # [doc = "Field `INSEL1` writer - LUT Input 1 Source Selection"]
pub type INSEL1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLB_SPEC , u8 , INSEL1_A , 4 , O > ; impl < 'a , const O : u8 > INSEL1_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL1_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL1_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL1_A :: LINK) } # [doc = "Event input source 0"]
# [inline (always)]
pub fn event0 (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENT0) } # [doc = "Event input source 1"]
# [inline (always)]
pub fn event1 (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENT1) } # [doc = "IO pin LUTn-N1 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL1_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL1_A :: AC0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCB0) } # [doc = "TCA0 WO1 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCA0) } # [doc = "TCD0 WOB input source"]
# [inline (always)]
pub fn tcd0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCD0) } # [doc = "USART0 TXD input source"]
# [inline (always)]
pub fn usart0 (self) -> & 'a mut W { self . variant (INSEL1_A :: USART0) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL1_A :: SPI0) } } impl R { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
pub fn insel0 (& self) -> INSEL0_R { INSEL0_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
pub fn insel1 (& self) -> INSEL1_R { INSEL1_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel0 (& mut self) -> INSEL0_W < 0 > { INSEL0_W :: new (self) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel1 (& mut self) -> INSEL1_W < 4 > { INSEL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 1 B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut1ctrlb](index.html) module"]
pub struct LUT1CTRLB_SPEC ; impl crate :: RegisterSpec for LUT1CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut1ctrlb::R](R) reader structure"]
impl crate :: Readable for LUT1CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut1ctrlb::W](W) writer structure"]
impl crate :: Writable for LUT1CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT1CTRLB to value 0"]
impl crate :: Resettable for LUT1CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT1CTRLC (rw) register accessor: an alias for `Reg<LUT1CTRLC_SPEC>`"]
pub type LUT1CTRLC = crate :: Reg < lut1ctrlc :: LUT1CTRLC_SPEC > ; # [doc = "LUT Control 1 C"]
pub mod lut1ctrlc { # [doc = "Register `LUT1CTRLC` reader"]
pub struct R (crate :: R < LUT1CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT1CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT1CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT1CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT1CTRLC` writer"]
pub struct W (crate :: W < LUT1CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT1CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT1CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT1CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL2` reader - LUT Input 2 Source Selection"]
pub type INSEL2_R = crate :: FieldReader < u8 , INSEL2_A > ; # [doc = "LUT Input 2 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL2_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source 0"]
EVENT0 = 3 , # [doc = "4: Event input source 1"]
EVENT1 = 4 , # [doc = "5: IO pin LUTn-IN2 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "7: TCB0 WO input source"]
TCB0 = 7 , # [doc = "8: TCA0 WO2 input source"]
TCA0 = 8 , # [doc = "9: TCD0 WOA input source"]
TCD0 = 9 , # [doc = "11: SPI0 MISO source"]
SPI0 = 11 , } impl From < INSEL2_A > for u8 { # [inline (always)]
fn from (variant : INSEL2_A) -> Self { variant as _ } } impl INSEL2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL2_A > { match self . bits { 0 => Some (INSEL2_A :: MASK) , 1 => Some (INSEL2_A :: FEEDBACK) , 2 => Some (INSEL2_A :: LINK) , 3 => Some (INSEL2_A :: EVENT0) , 4 => Some (INSEL2_A :: EVENT1) , 5 => Some (INSEL2_A :: IO) , 6 => Some (INSEL2_A :: AC0) , 7 => Some (INSEL2_A :: TCB0) , 8 => Some (INSEL2_A :: TCA0) , 9 => Some (INSEL2_A :: TCD0) , 11 => Some (INSEL2_A :: SPI0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL2_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL2_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL2_A :: LINK } # [doc = "Checks if the value of the field is `EVENT0`"]
# [inline (always)]
pub fn is_event0 (& self) -> bool { * self == INSEL2_A :: EVENT0 } # [doc = "Checks if the value of the field is `EVENT1`"]
# [inline (always)]
pub fn is_event1 (& self) -> bool { * self == INSEL2_A :: EVENT1 } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL2_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL2_A :: AC0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL2_A :: TCB0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL2_A :: TCA0 } # [doc = "Checks if the value of the field is `TCD0`"]
# [inline (always)]
pub fn is_tcd0 (& self) -> bool { * self == INSEL2_A :: TCD0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL2_A :: SPI0 } } # [doc = "Field `INSEL2` writer - LUT Input 2 Source Selection"]
pub type INSEL2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLC_SPEC , u8 , INSEL2_A , 4 , O > ; impl < 'a , const O : u8 > INSEL2_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL2_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL2_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL2_A :: LINK) } # [doc = "Event input source 0"]
# [inline (always)]
pub fn event0 (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENT0) } # [doc = "Event input source 1"]
# [inline (always)]
pub fn event1 (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENT1) } # [doc = "IO pin LUTn-IN2 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL2_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL2_A :: AC0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCB0) } # [doc = "TCA0 WO2 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCA0) } # [doc = "TCD0 WOA input source"]
# [inline (always)]
pub fn tcd0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCD0) } # [doc = "SPI0 MISO source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL2_A :: SPI0) } } impl R { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
pub fn insel2 (& self) -> INSEL2_R { INSEL2_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel2 (& mut self) -> INSEL2_W < 0 > { INSEL2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 1 C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut1ctrlc](index.html) module"]
pub struct LUT1CTRLC_SPEC ; impl crate :: RegisterSpec for LUT1CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut1ctrlc::R](R) reader structure"]
impl crate :: Readable for LUT1CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut1ctrlc::W](W) writer structure"]
impl crate :: Writable for LUT1CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT1CTRLC to value 0"]
impl crate :: Resettable for LUT1CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SEQCTRL0 (rw) register accessor: an alias for `Reg<SEQCTRL0_SPEC>`"]
pub type SEQCTRL0 = crate :: Reg < seqctrl0 :: SEQCTRL0_SPEC > ; # [doc = "Sequential Control 0"]
pub mod seqctrl0 { # [doc = "Register `SEQCTRL0` reader"]
pub struct R (crate :: R < SEQCTRL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SEQCTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SEQCTRL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SEQCTRL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SEQCTRL0` writer"]
pub struct W (crate :: W < SEQCTRL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SEQCTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SEQCTRL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SEQCTRL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `SEQSEL` reader - Sequential Selection"]
pub type SEQSEL_R = crate :: FieldReader < u8 , SEQSEL_A > ; # [doc = "Sequential Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SEQSEL_A { # [doc = "0: Sequential logic disabled"]
DISABLE = 0 , # [doc = "1: D FlipFlop"]
DFF = 1 , # [doc = "2: JK FlipFlop"]
JK = 2 , # [doc = "3: D Latch"]
LATCH = 3 , # [doc = "4: RS Latch"]
RS = 4 , } impl From < SEQSEL_A > for u8 { # [inline (always)]
fn from (variant : SEQSEL_A) -> Self { variant as _ } } impl SEQSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SEQSEL_A > { match self . bits { 0 => Some (SEQSEL_A :: DISABLE) , 1 => Some (SEQSEL_A :: DFF) , 2 => Some (SEQSEL_A :: JK) , 3 => Some (SEQSEL_A :: LATCH) , 4 => Some (SEQSEL_A :: RS) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SEQSEL_A :: DISABLE } # [doc = "Checks if the value of the field is `DFF`"]
# [inline (always)]
pub fn is_dff (& self) -> bool { * self == SEQSEL_A :: DFF } # [doc = "Checks if the value of the field is `JK`"]
# [inline (always)]
pub fn is_jk (& self) -> bool { * self == SEQSEL_A :: JK } # [doc = "Checks if the value of the field is `LATCH`"]
# [inline (always)]
pub fn is_latch (& self) -> bool { * self == SEQSEL_A :: LATCH } # [doc = "Checks if the value of the field is `RS`"]
# [inline (always)]
pub fn is_rs (& self) -> bool { * self == SEQSEL_A :: RS } } # [doc = "Field `SEQSEL` writer - Sequential Selection"]
pub type SEQSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SEQCTRL0_SPEC , u8 , SEQSEL_A , 3 , O > ; impl < 'a , const O : u8 > SEQSEL_W < 'a , O > { # [doc = "Sequential logic disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (SEQSEL_A :: DISABLE) } # [doc = "D FlipFlop"]
# [inline (always)]
pub fn dff (self) -> & 'a mut W { self . variant (SEQSEL_A :: DFF) } # [doc = "JK FlipFlop"]
# [inline (always)]
pub fn jk (self) -> & 'a mut W { self . variant (SEQSEL_A :: JK) } # [doc = "D Latch"]
# [inline (always)]
pub fn latch (self) -> & 'a mut W { self . variant (SEQSEL_A :: LATCH) } # [doc = "RS Latch"]
# [inline (always)]
pub fn rs (self) -> & 'a mut W { self . variant (SEQSEL_A :: RS) } } impl R { # [doc = "Bits 0:2 - Sequential Selection"]
# [inline (always)]
pub fn seqsel (& self) -> SEQSEL_R { SEQSEL_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Sequential Selection"]
# [inline (always)]
# [must_use]
pub fn seqsel (& mut self) -> SEQSEL_W < 0 > { SEQSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sequential Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [seqctrl0](index.html) module"]
pub struct SEQCTRL0_SPEC ; impl crate :: RegisterSpec for SEQCTRL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [seqctrl0::R](R) reader structure"]
impl crate :: Readable for SEQCTRL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [seqctrl0::W](W) writer structure"]
impl crate :: Writable for SEQCTRL0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SEQCTRL0 to value 0"]
impl crate :: Resettable for SEQCTRL0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRUTH0 (rw) register accessor: an alias for `Reg<TRUTH0_SPEC>`"]
pub type TRUTH0 = crate :: Reg < truth0 :: TRUTH0_SPEC > ; # [doc = "Truth 0"]
pub mod truth0 { # [doc = "Register `TRUTH0` reader"]
pub struct R (crate :: R < TRUTH0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRUTH0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRUTH0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRUTH0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRUTH0` writer"]
pub struct W (crate :: W < TRUTH0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRUTH0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRUTH0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRUTH0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Truth 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [truth0](index.html) module"]
pub struct TRUTH0_SPEC ; impl crate :: RegisterSpec for TRUTH0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [truth0::R](R) reader structure"]
impl crate :: Readable for TRUTH0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [truth0::W](W) writer structure"]
impl crate :: Writable for TRUTH0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRUTH0 to value 0"]
impl crate :: Resettable for TRUTH0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRUTH1 (rw) register accessor: an alias for `Reg<TRUTH1_SPEC>`"]
pub type TRUTH1 = crate :: Reg < truth1 :: TRUTH1_SPEC > ; # [doc = "Truth 1"]
pub mod truth1 { # [doc = "Register `TRUTH1` reader"]
pub struct R (crate :: R < TRUTH1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRUTH1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRUTH1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRUTH1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRUTH1` writer"]
pub struct W (crate :: W < TRUTH1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRUTH1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRUTH1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRUTH1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Truth 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [truth1](index.html) module"]
pub struct TRUTH1_SPEC ; impl crate :: RegisterSpec for TRUTH1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [truth1::R](R) reader structure"]
impl crate :: Readable for TRUTH1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [truth1::W](W) writer structure"]
impl crate :: Writable for TRUTH1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRUTH1 to value 0"]
impl crate :: Resettable for TRUTH1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Clock controller"]
pub struct CLKCTRL { _marker : PhantomData < * const () > } unsafe impl Send for CLKCTRL { } impl CLKCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const clkctrl :: RegisterBlock = 0x60 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const clkctrl :: RegisterBlock { Self :: PTR } } impl Deref for CLKCTRL { type Target = clkctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CLKCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CLKCTRL") . finish () } } # [doc = "Clock controller"]
pub mod clkctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - MCLK Control A"]
pub mclkctrla : MCLKCTRLA , # [doc = "0x01 - MCLK Control B"]
pub mclkctrlb : MCLKCTRLB , # [doc = "0x02 - MCLK Lock"]
pub mclklock : MCLKLOCK , # [doc = "0x03 - MCLK Status"]
pub mclkstatus : MCLKSTATUS , _reserved4 : [u8 ; 0x0c]
, # [doc = "0x10 - OSC20M Control A"]
pub osc20mctrla : OSC20MCTRLA , # [doc = "0x11 - OSC20M Calibration A"]
pub osc20mcaliba : OSC20MCALIBA , # [doc = "0x12 - OSC20M Calibration B"]
pub osc20mcalibb : OSC20MCALIBB , _reserved7 : [u8 ; 0x05]
, # [doc = "0x18 - OSC32K Control A"]
pub osc32kctrla : OSC32KCTRLA , _reserved8 : [u8 ; 0x03]
, # [doc = "0x1c - XOSC32K Control A"]
pub xosc32kctrla : XOSC32KCTRLA , } # [doc = "MCLKCTRLA (rw) register accessor: an alias for `Reg<MCLKCTRLA_SPEC>`"]
pub type MCLKCTRLA = crate :: Reg < mclkctrla :: MCLKCTRLA_SPEC > ; # [doc = "MCLK Control A"]
pub mod mclkctrla { # [doc = "Register `MCLKCTRLA` reader"]
pub struct R (crate :: R < MCLKCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCLKCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCLKCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCLKCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCLKCTRLA` writer"]
pub struct W (crate :: W < MCLKCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCLKCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCLKCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCLKCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: 20MHz internal oscillator"]
OSC20M = 0 , # [doc = "1: 32KHz internal Ultra Low Power oscillator"]
OSCULP32K = 1 , # [doc = "2: 32.768kHz external crystal oscillator"]
XOSC32K = 2 , # [doc = "3: External clock"]
EXTCLK = 3 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OSC20M , 1 => CLKSEL_A :: OSCULP32K , 2 => CLKSEL_A :: XOSC32K , 3 => CLKSEL_A :: EXTCLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OSC20M`"]
# [inline (always)]
pub fn is_osc20m (& self) -> bool { * self == CLKSEL_A :: OSC20M } # [doc = "Checks if the value of the field is `OSCULP32K`"]
# [inline (always)]
pub fn is_osculp32k (& self) -> bool { * self == CLKSEL_A :: OSCULP32K } # [doc = "Checks if the value of the field is `XOSC32K`"]
# [inline (always)]
pub fn is_xosc32k (& self) -> bool { * self == CLKSEL_A :: XOSC32K } # [doc = "Checks if the value of the field is `EXTCLK`"]
# [inline (always)]
pub fn is_extclk (& self) -> bool { * self == CLKSEL_A :: EXTCLK } } # [doc = "Field `CLKSEL` writer - Clock select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MCLKCTRLA_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "20MHz internal oscillator"]
# [inline (always)]
pub fn osc20m (self) -> & 'a mut W { self . variant (CLKSEL_A :: OSC20M) } # [doc = "32KHz internal Ultra Low Power oscillator"]
# [inline (always)]
pub fn osculp32k (self) -> & 'a mut W { self . variant (CLKSEL_A :: OSCULP32K) } # [doc = "32.768kHz external crystal oscillator"]
# [inline (always)]
pub fn xosc32k (self) -> & 'a mut W { self . variant (CLKSEL_A :: XOSC32K) } # [doc = "External clock"]
# [inline (always)]
pub fn extclk (self) -> & 'a mut W { self . variant (CLKSEL_A :: EXTCLK) } } # [doc = "Field `CLKOUT` reader - System clock out"]
pub type CLKOUT_R = crate :: BitReader < bool > ; # [doc = "Field `CLKOUT` writer - System clock out"]
pub type CLKOUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCLKCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Clock select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 3) } # [doc = "Bit 7 - System clock out"]
# [inline (always)]
pub fn clkout (& self) -> CLKOUT_R { CLKOUT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Clock select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Bit 7 - System clock out"]
# [inline (always)]
# [must_use]
pub fn clkout (& mut self) -> CLKOUT_W < 7 > { CLKOUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCLK Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mclkctrla](index.html) module"]
pub struct MCLKCTRLA_SPEC ; impl crate :: RegisterSpec for MCLKCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mclkctrla::R](R) reader structure"]
impl crate :: Readable for MCLKCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mclkctrla::W](W) writer structure"]
impl crate :: Writable for MCLKCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCLKCTRLA to value 0"]
impl crate :: Resettable for MCLKCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCLKCTRLB (rw) register accessor: an alias for `Reg<MCLKCTRLB_SPEC>`"]
pub type MCLKCTRLB = crate :: Reg < mclkctrlb :: MCLKCTRLB_SPEC > ; # [doc = "MCLK Control B"]
pub mod mclkctrlb { # [doc = "Register `MCLKCTRLB` reader"]
pub struct R (crate :: R < MCLKCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCLKCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCLKCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCLKCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCLKCTRLB` writer"]
pub struct W (crate :: W < MCLKCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCLKCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCLKCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCLKCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `PEN` reader - Prescaler enable"]
pub type PEN_R = crate :: BitReader < bool > ; # [doc = "Field `PEN` writer - Prescaler enable"]
pub type PEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCLKCTRLB_SPEC , bool , O > ; # [doc = "Field `PDIV` reader - Prescaler division"]
pub type PDIV_R = crate :: FieldReader < u8 , PDIV_A > ; # [doc = "Prescaler division\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PDIV_A { # [doc = "0: 2X"]
_2X = 0 , # [doc = "1: 4X"]
_4X = 1 , # [doc = "2: 8X"]
_8X = 2 , # [doc = "3: 16X"]
_16X = 3 , # [doc = "4: 32X"]
_32X = 4 , # [doc = "5: 64X"]
_64X = 5 , # [doc = "8: 6X"]
_6X = 8 , # [doc = "9: 10X"]
_10X = 9 , # [doc = "10: 12X"]
_12X = 10 , # [doc = "11: 24X"]
_24X = 11 , # [doc = "12: 48X"]
_48X = 12 , } impl From < PDIV_A > for u8 { # [inline (always)]
fn from (variant : PDIV_A) -> Self { variant as _ } } impl PDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PDIV_A > { match self . bits { 0 => Some (PDIV_A :: _2X) , 1 => Some (PDIV_A :: _4X) , 2 => Some (PDIV_A :: _8X) , 3 => Some (PDIV_A :: _16X) , 4 => Some (PDIV_A :: _32X) , 5 => Some (PDIV_A :: _64X) , 8 => Some (PDIV_A :: _6X) , 9 => Some (PDIV_A :: _10X) , 10 => Some (PDIV_A :: _12X) , 11 => Some (PDIV_A :: _24X) , 12 => Some (PDIV_A :: _48X) , _ => None , } } # [doc = "Checks if the value of the field is `_2X`"]
# [inline (always)]
pub fn is_2x (& self) -> bool { * self == PDIV_A :: _2X } # [doc = "Checks if the value of the field is `_4X`"]
# [inline (always)]
pub fn is_4x (& self) -> bool { * self == PDIV_A :: _4X } # [doc = "Checks if the value of the field is `_8X`"]
# [inline (always)]
pub fn is_8x (& self) -> bool { * self == PDIV_A :: _8X } # [doc = "Checks if the value of the field is `_16X`"]
# [inline (always)]
pub fn is_16x (& self) -> bool { * self == PDIV_A :: _16X } # [doc = "Checks if the value of the field is `_32X`"]
# [inline (always)]
pub fn is_32x (& self) -> bool { * self == PDIV_A :: _32X } # [doc = "Checks if the value of the field is `_64X`"]
# [inline (always)]
pub fn is_64x (& self) -> bool { * self == PDIV_A :: _64X } # [doc = "Checks if the value of the field is `_6X`"]
# [inline (always)]
pub fn is_6x (& self) -> bool { * self == PDIV_A :: _6X } # [doc = "Checks if the value of the field is `_10X`"]
# [inline (always)]
pub fn is_10x (& self) -> bool { * self == PDIV_A :: _10X } # [doc = "Checks if the value of the field is `_12X`"]
# [inline (always)]
pub fn is_12x (& self) -> bool { * self == PDIV_A :: _12X } # [doc = "Checks if the value of the field is `_24X`"]
# [inline (always)]
pub fn is_24x (& self) -> bool { * self == PDIV_A :: _24X } # [doc = "Checks if the value of the field is `_48X`"]
# [inline (always)]
pub fn is_48x (& self) -> bool { * self == PDIV_A :: _48X } } # [doc = "Field `PDIV` writer - Prescaler division"]
pub type PDIV_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , MCLKCTRLB_SPEC , u8 , PDIV_A , 4 , O > ; impl < 'a , const O : u8 > PDIV_W < 'a , O > { # [doc = "2X"]
# [inline (always)]
pub fn _2x (self) -> & 'a mut W { self . variant (PDIV_A :: _2X) } # [doc = "4X"]
# [inline (always)]
pub fn _4x (self) -> & 'a mut W { self . variant (PDIV_A :: _4X) } # [doc = "8X"]
# [inline (always)]
pub fn _8x (self) -> & 'a mut W { self . variant (PDIV_A :: _8X) } # [doc = "16X"]
# [inline (always)]
pub fn _16x (self) -> & 'a mut W { self . variant (PDIV_A :: _16X) } # [doc = "32X"]
# [inline (always)]
pub fn _32x (self) -> & 'a mut W { self . variant (PDIV_A :: _32X) } # [doc = "64X"]
# [inline (always)]
pub fn _64x (self) -> & 'a mut W { self . variant (PDIV_A :: _64X) } # [doc = "6X"]
# [inline (always)]
pub fn _6x (self) -> & 'a mut W { self . variant (PDIV_A :: _6X) } # [doc = "10X"]
# [inline (always)]
pub fn _10x (self) -> & 'a mut W { self . variant (PDIV_A :: _10X) } # [doc = "12X"]
# [inline (always)]
pub fn _12x (self) -> & 'a mut W { self . variant (PDIV_A :: _12X) } # [doc = "24X"]
# [inline (always)]
pub fn _24x (self) -> & 'a mut W { self . variant (PDIV_A :: _24X) } # [doc = "48X"]
# [inline (always)]
pub fn _48x (self) -> & 'a mut W { self . variant (PDIV_A :: _48X) } } impl R { # [doc = "Bit 0 - Prescaler enable"]
# [inline (always)]
pub fn pen (& self) -> PEN_R { PEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:4 - Prescaler division"]
# [inline (always)]
pub fn pdiv (& self) -> PDIV_R { PDIV_R :: new ((self . bits >> 1) & 0x0f) } } impl W { # [doc = "Bit 0 - Prescaler enable"]
# [inline (always)]
# [must_use]
pub fn pen (& mut self) -> PEN_W < 0 > { PEN_W :: new (self) } # [doc = "Bits 1:4 - Prescaler division"]
# [inline (always)]
# [must_use]
pub fn pdiv (& mut self) -> PDIV_W < 1 > { PDIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCLK Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mclkctrlb](index.html) module"]
pub struct MCLKCTRLB_SPEC ; impl crate :: RegisterSpec for MCLKCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mclkctrlb::R](R) reader structure"]
impl crate :: Readable for MCLKCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mclkctrlb::W](W) writer structure"]
impl crate :: Writable for MCLKCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCLKCTRLB to value 0"]
impl crate :: Resettable for MCLKCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCLKLOCK (rw) register accessor: an alias for `Reg<MCLKLOCK_SPEC>`"]
pub type MCLKLOCK = crate :: Reg < mclklock :: MCLKLOCK_SPEC > ; # [doc = "MCLK Lock"]
pub mod mclklock { # [doc = "Register `MCLKLOCK` reader"]
pub struct R (crate :: R < MCLKLOCK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCLKLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCLKLOCK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCLKLOCK_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCLKLOCK` writer"]
pub struct W (crate :: W < MCLKLOCK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCLKLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCLKLOCK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCLKLOCK_SPEC >) -> Self { W (writer) } } # [doc = "Field `LOCKEN` reader - lock ebable"]
pub type LOCKEN_R = crate :: BitReader < bool > ; # [doc = "Field `LOCKEN` writer - lock ebable"]
pub type LOCKEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCLKLOCK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - lock ebable"]
# [inline (always)]
pub fn locken (& self) -> LOCKEN_R { LOCKEN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - lock ebable"]
# [inline (always)]
# [must_use]
pub fn locken (& mut self) -> LOCKEN_W < 0 > { LOCKEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCLK Lock\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mclklock](index.html) module"]
pub struct MCLKLOCK_SPEC ; impl crate :: RegisterSpec for MCLKLOCK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mclklock::R](R) reader structure"]
impl crate :: Readable for MCLKLOCK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mclklock::W](W) writer structure"]
impl crate :: Writable for MCLKLOCK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCLKLOCK to value 0"]
impl crate :: Resettable for MCLKLOCK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCLKSTATUS (r) register accessor: an alias for `Reg<MCLKSTATUS_SPEC>`"]
pub type MCLKSTATUS = crate :: Reg < mclkstatus :: MCLKSTATUS_SPEC > ; # [doc = "MCLK Status"]
pub mod mclkstatus { # [doc = "Register `MCLKSTATUS` reader"]
pub struct R (crate :: R < MCLKSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCLKSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCLKSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCLKSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `SOSC` reader - System Oscillator changing"]
pub type SOSC_R = crate :: BitReader < bool > ; # [doc = "Field `OSC20MS` reader - 20MHz oscillator status"]
pub type OSC20MS_R = crate :: BitReader < bool > ; # [doc = "Field `OSC32KS` reader - 32KHz oscillator status"]
pub type OSC32KS_R = crate :: BitReader < bool > ; # [doc = "Field `XOSC32KS` reader - 32.768 kHz Crystal Oscillator status"]
pub type XOSC32KS_R = crate :: BitReader < bool > ; # [doc = "Field `EXTS` reader - External Clock status"]
pub type EXTS_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - System Oscillator changing"]
# [inline (always)]
pub fn sosc (& self) -> SOSC_R { SOSC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - 20MHz oscillator status"]
# [inline (always)]
pub fn osc20ms (& self) -> OSC20MS_R { OSC20MS_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - 32KHz oscillator status"]
# [inline (always)]
pub fn osc32ks (& self) -> OSC32KS_R { OSC32KS_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - 32.768 kHz Crystal Oscillator status"]
# [inline (always)]
pub fn xosc32ks (& self) -> XOSC32KS_R { XOSC32KS_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - External Clock status"]
# [inline (always)]
pub fn exts (& self) -> EXTS_R { EXTS_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "MCLK Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mclkstatus](index.html) module"]
pub struct MCLKSTATUS_SPEC ; impl crate :: RegisterSpec for MCLKSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mclkstatus::R](R) reader structure"]
impl crate :: Readable for MCLKSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets MCLKSTATUS to value 0"]
impl crate :: Resettable for MCLKSTATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20MCALIBA (rw) register accessor: an alias for `Reg<OSC20MCALIBA_SPEC>`"]
pub type OSC20MCALIBA = crate :: Reg < osc20mcaliba :: OSC20MCALIBA_SPEC > ; # [doc = "OSC20M Calibration A"]
pub mod osc20mcaliba { # [doc = "Register `OSC20MCALIBA` reader"]
pub struct R (crate :: R < OSC20MCALIBA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20MCALIBA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20MCALIBA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20MCALIBA_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC20MCALIBA` writer"]
pub struct W (crate :: W < OSC20MCALIBA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC20MCALIBA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC20MCALIBA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC20MCALIBA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAL20M` reader - Calibration"]
pub type CAL20M_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CAL20M` writer - Calibration"]
pub type CAL20M_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OSC20MCALIBA_SPEC , u8 , u8 , 6 , O > ; impl R { # [doc = "Bits 0:5 - Calibration"]
# [inline (always)]
pub fn cal20m (& self) -> CAL20M_R { CAL20M_R :: new (self . bits & 0x3f) } } impl W { # [doc = "Bits 0:5 - Calibration"]
# [inline (always)]
# [must_use]
pub fn cal20m (& mut self) -> CAL20M_W < 0 > { CAL20M_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OSC20M Calibration A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20mcaliba](index.html) module"]
pub struct OSC20MCALIBA_SPEC ; impl crate :: RegisterSpec for OSC20MCALIBA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20mcaliba::R](R) reader structure"]
impl crate :: Readable for OSC20MCALIBA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc20mcaliba::W](W) writer structure"]
impl crate :: Writable for OSC20MCALIBA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSC20MCALIBA to value 0"]
impl crate :: Resettable for OSC20MCALIBA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20MCALIBB (rw) register accessor: an alias for `Reg<OSC20MCALIBB_SPEC>`"]
pub type OSC20MCALIBB = crate :: Reg < osc20mcalibb :: OSC20MCALIBB_SPEC > ; # [doc = "OSC20M Calibration B"]
pub mod osc20mcalibb { # [doc = "Register `OSC20MCALIBB` reader"]
pub struct R (crate :: R < OSC20MCALIBB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20MCALIBB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20MCALIBB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20MCALIBB_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC20MCALIBB` writer"]
pub struct W (crate :: W < OSC20MCALIBB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC20MCALIBB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC20MCALIBB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC20MCALIBB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TEMPCAL20M` reader - Oscillator temperature coefficient"]
pub type TEMPCAL20M_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TEMPCAL20M` writer - Oscillator temperature coefficient"]
pub type TEMPCAL20M_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OSC20MCALIBB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `LOCK` reader - Lock"]
pub type LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `LOCK` writer - Lock"]
pub type LOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OSC20MCALIBB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:3 - Oscillator temperature coefficient"]
# [inline (always)]
pub fn tempcal20m (& self) -> TEMPCAL20M_R { TEMPCAL20M_R :: new (self . bits & 0x0f) } # [doc = "Bit 7 - Lock"]
# [inline (always)]
pub fn lock (& self) -> LOCK_R { LOCK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Oscillator temperature coefficient"]
# [inline (always)]
# [must_use]
pub fn tempcal20m (& mut self) -> TEMPCAL20M_W < 0 > { TEMPCAL20M_W :: new (self) } # [doc = "Bit 7 - Lock"]
# [inline (always)]
# [must_use]
pub fn lock (& mut self) -> LOCK_W < 7 > { LOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OSC20M Calibration B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20mcalibb](index.html) module"]
pub struct OSC20MCALIBB_SPEC ; impl crate :: RegisterSpec for OSC20MCALIBB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20mcalibb::R](R) reader structure"]
impl crate :: Readable for OSC20MCALIBB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc20mcalibb::W](W) writer structure"]
impl crate :: Writable for OSC20MCALIBB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSC20MCALIBB to value 0"]
impl crate :: Resettable for OSC20MCALIBB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20MCTRLA (rw) register accessor: an alias for `Reg<OSC20MCTRLA_SPEC>`"]
pub type OSC20MCTRLA = crate :: Reg < osc20mctrla :: OSC20MCTRLA_SPEC > ; # [doc = "OSC20M Control A"]
pub mod osc20mctrla { # [doc = "Register `OSC20MCTRLA` reader"]
pub struct R (crate :: R < OSC20MCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20MCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20MCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20MCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC20MCTRLA` writer"]
pub struct W (crate :: W < OSC20MCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC20MCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC20MCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC20MCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RUNSTDBY` reader - Run standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OSC20MCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - Run standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 1 - Run standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 1 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OSC20M Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20mctrla](index.html) module"]
pub struct OSC20MCTRLA_SPEC ; impl crate :: RegisterSpec for OSC20MCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20mctrla::R](R) reader structure"]
impl crate :: Readable for OSC20MCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc20mctrla::W](W) writer structure"]
impl crate :: Writable for OSC20MCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSC20MCTRLA to value 0"]
impl crate :: Resettable for OSC20MCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC32KCTRLA (rw) register accessor: an alias for `Reg<OSC32KCTRLA_SPEC>`"]
pub type OSC32KCTRLA = crate :: Reg < osc32kctrla :: OSC32KCTRLA_SPEC > ; # [doc = "OSC32K Control A"]
pub mod osc32kctrla { # [doc = "Register `OSC32KCTRLA` reader"]
pub struct R (crate :: R < OSC32KCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC32KCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC32KCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC32KCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC32KCTRLA` writer"]
pub struct W (crate :: W < OSC32KCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC32KCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC32KCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC32KCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RUNSTDBY` reader - Run standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OSC32KCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - Run standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 1 - Run standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 1 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OSC32K Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc32kctrla](index.html) module"]
pub struct OSC32KCTRLA_SPEC ; impl crate :: RegisterSpec for OSC32KCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc32kctrla::R](R) reader structure"]
impl crate :: Readable for OSC32KCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc32kctrla::W](W) writer structure"]
impl crate :: Writable for OSC32KCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSC32KCTRLA to value 0"]
impl crate :: Resettable for OSC32KCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "XOSC32KCTRLA (rw) register accessor: an alias for `Reg<XOSC32KCTRLA_SPEC>`"]
pub type XOSC32KCTRLA = crate :: Reg < xosc32kctrla :: XOSC32KCTRLA_SPEC > ; # [doc = "XOSC32K Control A"]
pub mod xosc32kctrla { # [doc = "Register `XOSC32KCTRLA` reader"]
pub struct R (crate :: R < XOSC32KCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XOSC32KCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XOSC32KCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XOSC32KCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `XOSC32KCTRLA` writer"]
pub struct W (crate :: W < XOSC32KCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XOSC32KCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XOSC32KCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XOSC32KCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSC32KCTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSC32KCTRLA_SPEC , bool , O > ; # [doc = "Field `SEL` reader - Select"]
pub type SEL_R = crate :: BitReader < bool > ; # [doc = "Field `SEL` writer - Select"]
pub type SEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSC32KCTRLA_SPEC , bool , O > ; # [doc = "Field `CSUT` reader - Crystal startup time"]
pub type CSUT_R = crate :: FieldReader < u8 , CSUT_A > ; # [doc = "Crystal startup time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CSUT_A { # [doc = "0: 1K cycles"]
_1K = 0 , # [doc = "1: 16K cycles"]
_16K = 1 , # [doc = "2: 32K cycles"]
_32K = 2 , # [doc = "3: 64K cycles"]
_64K = 3 , } impl From < CSUT_A > for u8 { # [inline (always)]
fn from (variant : CSUT_A) -> Self { variant as _ } } impl CSUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CSUT_A { match self . bits { 0 => CSUT_A :: _1K , 1 => CSUT_A :: _16K , 2 => CSUT_A :: _32K , 3 => CSUT_A :: _64K , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1K`"]
# [inline (always)]
pub fn is_1k (& self) -> bool { * self == CSUT_A :: _1K } # [doc = "Checks if the value of the field is `_16K`"]
# [inline (always)]
pub fn is_16k (& self) -> bool { * self == CSUT_A :: _16K } # [doc = "Checks if the value of the field is `_32K`"]
# [inline (always)]
pub fn is_32k (& self) -> bool { * self == CSUT_A :: _32K } # [doc = "Checks if the value of the field is `_64K`"]
# [inline (always)]
pub fn is_64k (& self) -> bool { * self == CSUT_A :: _64K } } # [doc = "Field `CSUT` writer - Crystal startup time"]
pub type CSUT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , XOSC32KCTRLA_SPEC , u8 , CSUT_A , 2 , O > ; impl < 'a , const O : u8 > CSUT_W < 'a , O > { # [doc = "1K cycles"]
# [inline (always)]
pub fn _1k (self) -> & 'a mut W { self . variant (CSUT_A :: _1K) } # [doc = "16K cycles"]
# [inline (always)]
pub fn _16k (self) -> & 'a mut W { self . variant (CSUT_A :: _16K) } # [doc = "32K cycles"]
# [inline (always)]
pub fn _32k (self) -> & 'a mut W { self . variant (CSUT_A :: _32K) } # [doc = "64K cycles"]
# [inline (always)]
pub fn _64k (self) -> & 'a mut W { self . variant (CSUT_A :: _64K) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Run standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Select"]
# [inline (always)]
pub fn sel (& self) -> SEL_R { SEL_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 4:5 - Crystal startup time"]
# [inline (always)]
pub fn csut (& self) -> CSUT_R { CSUT_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Run standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 1 > { RUNSTDBY_W :: new (self) } # [doc = "Bit 2 - Select"]
# [inline (always)]
# [must_use]
pub fn sel (& mut self) -> SEL_W < 2 > { SEL_W :: new (self) } # [doc = "Bits 4:5 - Crystal startup time"]
# [inline (always)]
# [must_use]
pub fn csut (& mut self) -> CSUT_W < 4 > { CSUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "XOSC32K Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xosc32kctrla](index.html) module"]
pub struct XOSC32KCTRLA_SPEC ; impl crate :: RegisterSpec for XOSC32KCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [xosc32kctrla::R](R) reader structure"]
impl crate :: Readable for XOSC32KCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xosc32kctrla::W](W) writer structure"]
impl crate :: Writable for XOSC32KCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets XOSC32KCTRLA to value 0"]
impl crate :: Resettable for XOSC32KCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "CPU"]
pub struct CPU { _marker : PhantomData < * const () > } unsafe impl Send for CPU { } impl CPU { # [doc = r"Pointer to the register block"]
pub const PTR : * const cpu :: RegisterBlock = 0x34 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const cpu :: RegisterBlock { Self :: PTR } } impl Deref for CPU { type Target = cpu :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CPU { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CPU") . finish () } } # [doc = "CPU"]
pub mod cpu { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Configuration Change Protection"]
pub ccp : CCP , _reserved1 : [u8 ; 0x08]
, # [doc = "0x09 - Stack Pointer Low"]
pub spl : SPL , # [doc = "0x0a - Stack Pointer High"]
pub sph : SPH , } # [doc = "CCP (rw) register accessor: an alias for `Reg<CCP_SPEC>`"]
pub type CCP = crate :: Reg < ccp :: CCP_SPEC > ; # [doc = "Configuration Change Protection"]
pub mod ccp { # [doc = "Register `CCP` reader"]
pub struct R (crate :: R < CCP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCP` writer"]
pub struct W (crate :: W < CCP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCP_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCP` reader - CCP signature"]
pub type CCP_R = crate :: FieldReader < u8 , CCP_A > ; # [doc = "CCP signature\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCP_A { # [doc = "157: SPM Instruction Protection"]
SPM = 157 , # [doc = "216: IO Register Protection"]
IOREG = 216 , } impl From < CCP_A > for u8 { # [inline (always)]
fn from (variant : CCP_A) -> Self { variant as _ } } impl CCP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CCP_A > { match self . bits { 157 => Some (CCP_A :: SPM) , 216 => Some (CCP_A :: IOREG) , _ => None , } } # [doc = "Checks if the value of the field is `SPM`"]
# [inline (always)]
pub fn is_spm (& self) -> bool { * self == CCP_A :: SPM } # [doc = "Checks if the value of the field is `IOREG`"]
# [inline (always)]
pub fn is_ioreg (& self) -> bool { * self == CCP_A :: IOREG } } # [doc = "Field `CCP` writer - CCP signature"]
pub type CCP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CCP_SPEC , u8 , CCP_A , 8 , O > ; impl < 'a , const O : u8 > CCP_W < 'a , O > { # [doc = "SPM Instruction Protection"]
# [inline (always)]
pub fn spm (self) -> & 'a mut W { self . variant (CCP_A :: SPM) } # [doc = "IO Register Protection"]
# [inline (always)]
pub fn ioreg (self) -> & 'a mut W { self . variant (CCP_A :: IOREG) } } impl R { # [doc = "Bits 0:7 - CCP signature"]
# [inline (always)]
pub fn ccp (& self) -> CCP_R { CCP_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - CCP signature"]
# [inline (always)]
# [must_use]
pub fn ccp (& mut self) -> CCP_W < 0 > { CCP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Configuration Change Protection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccp](index.html) module"]
pub struct CCP_SPEC ; impl crate :: RegisterSpec for CCP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ccp::R](R) reader structure"]
impl crate :: Readable for CCP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccp::W](W) writer structure"]
impl crate :: Writable for CCP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCP to value 0"]
impl crate :: Resettable for CCP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPH (rw) register accessor: an alias for `Reg<SPH_SPEC>`"]
pub type SPH = crate :: Reg < sph :: SPH_SPEC > ; # [doc = "Stack Pointer High"]
pub mod sph { # [doc = "Register `SPH` reader"]
pub struct R (crate :: R < SPH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPH` writer"]
pub struct W (crate :: W < SPH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPH_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Stack Pointer High\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sph](index.html) module"]
pub struct SPH_SPEC ; impl crate :: RegisterSpec for SPH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sph::R](R) reader structure"]
impl crate :: Readable for SPH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sph::W](W) writer structure"]
impl crate :: Writable for SPH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPH to value 0"]
impl crate :: Resettable for SPH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPL (rw) register accessor: an alias for `Reg<SPL_SPEC>`"]
pub type SPL = crate :: Reg < spl :: SPL_SPEC > ; # [doc = "Stack Pointer Low"]
pub mod spl { # [doc = "Register `SPL` reader"]
pub struct R (crate :: R < SPL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPL` writer"]
pub struct W (crate :: W < SPL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Stack Pointer Low\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spl](index.html) module"]
pub struct SPL_SPEC ; impl crate :: RegisterSpec for SPL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spl::R](R) reader structure"]
impl crate :: Readable for SPL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spl::W](W) writer structure"]
impl crate :: Writable for SPL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPL to value 0"]
impl crate :: Resettable for SPL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Interrupt Controller"]
pub struct CPUINT { _marker : PhantomData < * const () > } unsafe impl Send for CPUINT { } impl CPUINT { # [doc = r"Pointer to the register block"]
pub const PTR : * const cpuint :: RegisterBlock = 0x0110 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const cpuint :: RegisterBlock { Self :: PTR } } impl Deref for CPUINT { type Target = cpuint :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CPUINT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CPUINT") . finish () } } # [doc = "Interrupt Controller"]
pub mod cpuint { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Status"]
pub status : STATUS , # [doc = "0x02 - Interrupt Level 0 Priority"]
pub lvl0pri : LVL0PRI , # [doc = "0x03 - Interrupt Level 1 Priority Vector"]
pub lvl1vec : LVL1VEC , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL0RR` reader - Round-robin Scheduling Enable"]
pub type LVL0RR_R = crate :: BitReader < bool > ; # [doc = "Field `LVL0RR` writer - Round-robin Scheduling Enable"]
pub type LVL0RR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CVT` reader - Compact Vector Table"]
pub type CVT_R = crate :: BitReader < bool > ; # [doc = "Field `CVT` writer - Compact Vector Table"]
pub type CVT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `IVSEL` reader - Interrupt Vector Select"]
pub type IVSEL_R = crate :: BitReader < bool > ; # [doc = "Field `IVSEL` writer - Interrupt Vector Select"]
pub type IVSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Round-robin Scheduling Enable"]
# [inline (always)]
pub fn lvl0rr (& self) -> LVL0RR_R { LVL0RR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 5 - Compact Vector Table"]
# [inline (always)]
pub fn cvt (& self) -> CVT_R { CVT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Interrupt Vector Select"]
# [inline (always)]
pub fn ivsel (& self) -> IVSEL_R { IVSEL_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Round-robin Scheduling Enable"]
# [inline (always)]
# [must_use]
pub fn lvl0rr (& mut self) -> LVL0RR_W < 0 > { LVL0RR_W :: new (self) } # [doc = "Bit 5 - Compact Vector Table"]
# [inline (always)]
# [must_use]
pub fn cvt (& mut self) -> CVT_W < 5 > { CVT_W :: new (self) } # [doc = "Bit 6 - Interrupt Vector Select"]
# [inline (always)]
# [must_use]
pub fn ivsel (& mut self) -> IVSEL_W < 6 > { IVSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LVL0PRI (rw) register accessor: an alias for `Reg<LVL0PRI_SPEC>`"]
pub type LVL0PRI = crate :: Reg < lvl0pri :: LVL0PRI_SPEC > ; # [doc = "Interrupt Level 0 Priority"]
pub mod lvl0pri { # [doc = "Register `LVL0PRI` reader"]
pub struct R (crate :: R < LVL0PRI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LVL0PRI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LVL0PRI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LVL0PRI_SPEC >) -> Self { R (reader) } } # [doc = "Register `LVL0PRI` writer"]
pub struct W (crate :: W < LVL0PRI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LVL0PRI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LVL0PRI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LVL0PRI_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL0PRI` reader - Interrupt Level Priority"]
pub type LVL0PRI_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LVL0PRI` writer - Interrupt Level Priority"]
pub type LVL0PRI_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LVL0PRI_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Interrupt Level Priority"]
# [inline (always)]
pub fn lvl0pri (& self) -> LVL0PRI_R { LVL0PRI_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Interrupt Level Priority"]
# [inline (always)]
# [must_use]
pub fn lvl0pri (& mut self) -> LVL0PRI_W < 0 > { LVL0PRI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Level 0 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lvl0pri](index.html) module"]
pub struct LVL0PRI_SPEC ; impl crate :: RegisterSpec for LVL0PRI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lvl0pri::R](R) reader structure"]
impl crate :: Readable for LVL0PRI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lvl0pri::W](W) writer structure"]
impl crate :: Writable for LVL0PRI_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LVL0PRI to value 0"]
impl crate :: Resettable for LVL0PRI_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LVL1VEC (rw) register accessor: an alias for `Reg<LVL1VEC_SPEC>`"]
pub type LVL1VEC = crate :: Reg < lvl1vec :: LVL1VEC_SPEC > ; # [doc = "Interrupt Level 1 Priority Vector"]
pub mod lvl1vec { # [doc = "Register `LVL1VEC` reader"]
pub struct R (crate :: R < LVL1VEC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LVL1VEC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LVL1VEC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LVL1VEC_SPEC >) -> Self { R (reader) } } # [doc = "Register `LVL1VEC` writer"]
pub struct W (crate :: W < LVL1VEC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LVL1VEC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LVL1VEC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LVL1VEC_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL1VEC` reader - Interrupt Vector with High Priority"]
pub type LVL1VEC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LVL1VEC` writer - Interrupt Vector with High Priority"]
pub type LVL1VEC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LVL1VEC_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Interrupt Vector with High Priority"]
# [inline (always)]
pub fn lvl1vec (& self) -> LVL1VEC_R { LVL1VEC_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Interrupt Vector with High Priority"]
# [inline (always)]
# [must_use]
pub fn lvl1vec (& mut self) -> LVL1VEC_W < 0 > { LVL1VEC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Level 1 Priority Vector\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lvl1vec](index.html) module"]
pub struct LVL1VEC_SPEC ; impl crate :: RegisterSpec for LVL1VEC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lvl1vec::R](R) reader structure"]
impl crate :: Readable for LVL1VEC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lvl1vec::W](W) writer structure"]
impl crate :: Writable for LVL1VEC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LVL1VEC to value 0"]
impl crate :: Resettable for LVL1VEC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL0EX` reader - Level 0 Interrupt Executing"]
pub type LVL0EX_R = crate :: BitReader < bool > ; # [doc = "Field `LVL1EX` reader - Level 1 Interrupt Executing"]
pub type LVL1EX_R = crate :: BitReader < bool > ; # [doc = "Field `NMIEX` reader - Non-maskable Interrupt Executing"]
pub type NMIEX_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Level 0 Interrupt Executing"]
# [inline (always)]
pub fn lvl0ex (& self) -> LVL0EX_R { LVL0EX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Level 1 Interrupt Executing"]
# [inline (always)]
pub fn lvl1ex (& self) -> LVL1EX_R { LVL1EX_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Non-maskable Interrupt Executing"]
# [inline (always)]
pub fn nmiex (& self) -> NMIEX_R { NMIEX_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "CRCSCAN"]
pub struct CRCSCAN { _marker : PhantomData < * const () > } unsafe impl Send for CRCSCAN { } impl CRCSCAN { # [doc = r"Pointer to the register block"]
pub const PTR : * const crcscan :: RegisterBlock = 0x0120 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const crcscan :: RegisterBlock { Self :: PTR } } impl Deref for CRCSCAN { type Target = crcscan :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CRCSCAN { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CRCSCAN") . finish () } } # [doc = "CRCSCAN"]
pub mod crcscan { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Status"]
pub status : STATUS , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable CRC scan"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable CRC scan"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `NMIEN` reader - Enable NMI Trigger"]
pub type NMIEN_R = crate :: BitReader < bool > ; # [doc = "Field `NMIEN` writer - Enable NMI Trigger"]
pub type NMIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RESET` reader - Reset CRC scan"]
pub type RESET_R = crate :: BitReader < bool > ; # [doc = "Field `RESET` writer - Reset CRC scan"]
pub type RESET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable CRC scan"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable NMI Trigger"]
# [inline (always)]
pub fn nmien (& self) -> NMIEN_R { NMIEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Reset CRC scan"]
# [inline (always)]
pub fn reset (& self) -> RESET_R { RESET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable CRC scan"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Enable NMI Trigger"]
# [inline (always)]
# [must_use]
pub fn nmien (& mut self) -> NMIEN_W < 1 > { NMIEN_W :: new (self) } # [doc = "Bit 7 - Reset CRC scan"]
# [inline (always)]
# [must_use]
pub fn reset (& mut self) -> RESET_W < 7 > { RESET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRC` reader - CRC Source"]
pub type SRC_R = crate :: FieldReader < u8 , SRC_A > ; # [doc = "CRC Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SRC_A { # [doc = "0: CRC on entire flash"]
FLASH = 0 , # [doc = "1: CRC on boot and appl section of flash"]
APPLICATION = 1 , # [doc = "2: CRC on boot section of flash"]
BOOT = 2 , } impl From < SRC_A > for u8 { # [inline (always)]
fn from (variant : SRC_A) -> Self { variant as _ } } impl SRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SRC_A > { match self . bits { 0 => Some (SRC_A :: FLASH) , 1 => Some (SRC_A :: APPLICATION) , 2 => Some (SRC_A :: BOOT) , _ => None , } } # [doc = "Checks if the value of the field is `FLASH`"]
# [inline (always)]
pub fn is_flash (& self) -> bool { * self == SRC_A :: FLASH } # [doc = "Checks if the value of the field is `APPLICATION`"]
# [inline (always)]
pub fn is_application (& self) -> bool { * self == SRC_A :: APPLICATION } # [doc = "Checks if the value of the field is `BOOT`"]
# [inline (always)]
pub fn is_boot (& self) -> bool { * self == SRC_A :: BOOT } } # [doc = "Field `SRC` writer - CRC Source"]
pub type SRC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , SRC_A , 2 , O > ; impl < 'a , const O : u8 > SRC_W < 'a , O > { # [doc = "CRC on entire flash"]
# [inline (always)]
pub fn flash (self) -> & 'a mut W { self . variant (SRC_A :: FLASH) } # [doc = "CRC on boot and appl section of flash"]
# [inline (always)]
pub fn application (self) -> & 'a mut W { self . variant (SRC_A :: APPLICATION) } # [doc = "CRC on boot section of flash"]
# [inline (always)]
pub fn boot (self) -> & 'a mut W { self . variant (SRC_A :: BOOT) } } # [doc = "Field `MODE` reader - CRC Flash Access Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; # [doc = "CRC Flash Access Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: Priority to flash"]
PRIORITY = 0 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: PRIORITY) , _ => None , } } # [doc = "Checks if the value of the field is `PRIORITY`"]
# [inline (always)]
pub fn is_priority (& self) -> bool { * self == MODE_A :: PRIORITY } } # [doc = "Field `MODE` writer - CRC Flash Access Mode"]
pub type MODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , MODE_A , 2 , O > ; impl < 'a , const O : u8 > MODE_W < 'a , O > { # [doc = "Priority to flash"]
# [inline (always)]
pub fn priority (self) -> & 'a mut W { self . variant (MODE_A :: PRIORITY) } } impl R { # [doc = "Bits 0:1 - CRC Source"]
# [inline (always)]
pub fn src (& self) -> SRC_R { SRC_R :: new (self . bits & 3) } # [doc = "Bits 4:5 - CRC Flash Access Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - CRC Source"]
# [inline (always)]
# [must_use]
pub fn src (& mut self) -> SRC_W < 0 > { SRC_W :: new (self) } # [doc = "Bits 4:5 - CRC Flash Access Mode"]
# [inline (always)]
# [must_use]
pub fn mode (& mut self) -> MODE_W < 4 > { MODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `BUSY` reader - CRC Busy"]
pub type BUSY_R = crate :: BitReader < bool > ; # [doc = "Field `OK` reader - CRC Ok"]
pub type OK_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - CRC Busy"]
# [inline (always)]
pub fn busy (& self) -> BUSY_R { BUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - CRC Ok"]
# [inline (always)]
pub fn ok (& self) -> OK_R { OK_R :: new (((self . bits >> 1) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Digital to Analog Converter"]
pub struct DAC0 { _marker : PhantomData < * const () > } unsafe impl Send for DAC0 { } impl DAC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const dac0 :: RegisterBlock = 0x0680 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dac0 :: RegisterBlock { Self :: PTR } } impl Deref for DAC0 { type Target = dac0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DAC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DAC0") . finish () } } # [doc = "Digital to Analog Converter"]
pub mod dac0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - DATA Register"]
pub data : DATA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - DAC Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - DAC Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `OUTEN` reader - Output Buffer Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Buffer Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby Mode"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby Mode"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - DAC Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Output Buffer Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Run in Standby Mode"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - DAC Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 6 - Output Buffer Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 6 > { OUTEN_W :: new (self) } # [doc = "Bit 7 - Run in Standby Mode"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 7 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "DATA Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "DATA Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Event System"]
pub struct EVSYS { _marker : PhantomData < * const () > } unsafe impl Send for EVSYS { } impl EVSYS { # [doc = r"Pointer to the register block"]
pub const PTR : * const evsys :: RegisterBlock = 0x0180 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const evsys :: RegisterBlock { Self :: PTR } } impl Deref for EVSYS { type Target = evsys :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EVSYS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EVSYS") . finish () } } # [doc = "Event System"]
pub mod evsys { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Asynchronous Channel Strobe"]
pub asyncstrobe : ASYNCSTROBE , # [doc = "0x01 - Synchronous Channel Strobe"]
pub syncstrobe : SYNCSTROBE , # [doc = "0x02 - Asynchronous Channel 0 Generator Selection"]
pub asyncch0 : ASYNCCH0 , # [doc = "0x03 - Asynchronous Channel 1 Generator Selection"]
pub asyncch1 : ASYNCCH1 , # [doc = "0x04 - Asynchronous Channel 2 Generator Selection"]
pub asyncch2 : ASYNCCH2 , # [doc = "0x05 - Asynchronous Channel 3 Generator Selection"]
pub asyncch3 : ASYNCCH3 , _reserved6 : [u8 ; 0x04]
, # [doc = "0x0a - Synchronous Channel 0 Generator Selection"]
pub syncch0 : SYNCCH0 , # [doc = "0x0b - Synchronous Channel 1 Generator Selection"]
pub syncch1 : SYNCCH1 , _reserved8 : [u8 ; 0x06]
, # [doc = "0x12 - Asynchronous User Ch 0 Input Selection - TCB0"]
pub asyncuser0 : ASYNCUSER0 , # [doc = "0x13 - Asynchronous User Ch 1 Input Selection - ADC0"]
pub asyncuser1 : ASYNCUSER1 , # [doc = "0x14 - Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0"]
pub asyncuser2 : ASYNCUSER2 , # [doc = "0x15 - Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0"]
pub asyncuser3 : ASYNCUSER3 , # [doc = "0x16 - Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1"]
pub asyncuser4 : ASYNCUSER4 , # [doc = "0x17 - Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1"]
pub asyncuser5 : ASYNCUSER5 , # [doc = "0x18 - Asynchronous User Ch 6 Input Selection - TCD0 Event 0"]
pub asyncuser6 : ASYNCUSER6 , # [doc = "0x19 - Asynchronous User Ch 7 Input Selection - TCD0 Event 1"]
pub asyncuser7 : ASYNCUSER7 , # [doc = "0x1a - Asynchronous User Ch 8 Input Selection - Event Out 0"]
pub asyncuser8 : ASYNCUSER8 , # [doc = "0x1b - Asynchronous User Ch 9 Input Selection - Event Out 1"]
pub asyncuser9 : ASYNCUSER9 , # [doc = "0x1c - Asynchronous User Ch 10 Input Selection - Event Out 2"]
pub asyncuser10 : ASYNCUSER10 , _reserved19 : [u8 ; 0x05]
, # [doc = "0x22 - Synchronous User Ch 0 Input Selection - TCA0"]
pub syncuser0 : SYNCUSER0 , # [doc = "0x23 - Synchronous User Ch 1 Input Selection - USART0"]
pub syncuser1 : SYNCUSER1 , } # [doc = "ASYNCCH0 (rw) register accessor: an alias for `Reg<ASYNCCH0_SPEC>`"]
pub type ASYNCCH0 = crate :: Reg < asyncch0 :: ASYNCCH0_SPEC > ; # [doc = "Asynchronous Channel 0 Generator Selection"]
pub mod asyncch0 { # [doc = "Register `ASYNCCH0` reader"]
pub struct R (crate :: R < ASYNCCH0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCCH0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCCH0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCCH0_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCCH0` writer"]
pub struct W (crate :: W < ASYNCCH0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCCH0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCCH0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCCH0_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCCH0` reader - Asynchronous Channel 0 Generator Selection"]
pub type ASYNCCH0_R = crate :: FieldReader < u8 , ASYNCCH0_A > ; # [doc = "Asynchronous Channel 0 Generator Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCCH0_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Configurable Custom Logic LUT0"]
CCL_LUT0 = 1 , # [doc = "2: Configurable Custom Logic LUT1"]
CCL_LUT1 = 2 , # [doc = "3: Analog Comparator 0 out"]
AC0_OUT = 3 , # [doc = "4: Timer/Counter D0 compare B clear"]
TCD0_CMPBCLR = 4 , # [doc = "5: Timer/Counter D0 compare A set"]
TCD0_CMPASET = 5 , # [doc = "6: Timer/Counter D0 compare B set"]
TCD0_CMPBSET = 6 , # [doc = "7: Timer/Counter D0 program event"]
TCD0_PROGEV = 7 , # [doc = "8: Real Time Counter overflow"]
RTC_OVF = 8 , # [doc = "9: Real Time Counter compare"]
RTC_CMP = 9 , # [doc = "10: Asynchronous Event from Pin PA0"]
PORTA_PIN0 = 10 , # [doc = "11: Asynchronous Event from Pin PA1"]
PORTA_PIN1 = 11 , # [doc = "12: Asynchronous Event from Pin PA2"]
PORTA_PIN2 = 12 , # [doc = "13: Asynchronous Event from Pin PA3"]
PORTA_PIN3 = 13 , # [doc = "14: Asynchronous Event from Pin PA4"]
PORTA_PIN4 = 14 , # [doc = "15: Asynchronous Event from Pin PA5"]
PORTA_PIN5 = 15 , # [doc = "16: Asynchronous Event from Pin PA6"]
PORTA_PIN6 = 16 , # [doc = "17: Asynchronous Event from Pin PA7"]
PORTA_PIN7 = 17 , # [doc = "18: Unified Program and debug interface"]
UPDI = 18 , } impl From < ASYNCCH0_A > for u8 { # [inline (always)]
fn from (variant : ASYNCCH0_A) -> Self { variant as _ } } impl ASYNCCH0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCCH0_A > { match self . bits { 0 => Some (ASYNCCH0_A :: OFF) , 1 => Some (ASYNCCH0_A :: CCL_LUT0) , 2 => Some (ASYNCCH0_A :: CCL_LUT1) , 3 => Some (ASYNCCH0_A :: AC0_OUT) , 4 => Some (ASYNCCH0_A :: TCD0_CMPBCLR) , 5 => Some (ASYNCCH0_A :: TCD0_CMPASET) , 6 => Some (ASYNCCH0_A :: TCD0_CMPBSET) , 7 => Some (ASYNCCH0_A :: TCD0_PROGEV) , 8 => Some (ASYNCCH0_A :: RTC_OVF) , 9 => Some (ASYNCCH0_A :: RTC_CMP) , 10 => Some (ASYNCCH0_A :: PORTA_PIN0) , 11 => Some (ASYNCCH0_A :: PORTA_PIN1) , 12 => Some (ASYNCCH0_A :: PORTA_PIN2) , 13 => Some (ASYNCCH0_A :: PORTA_PIN3) , 14 => Some (ASYNCCH0_A :: PORTA_PIN4) , 15 => Some (ASYNCCH0_A :: PORTA_PIN5) , 16 => Some (ASYNCCH0_A :: PORTA_PIN6) , 17 => Some (ASYNCCH0_A :: PORTA_PIN7) , 18 => Some (ASYNCCH0_A :: UPDI) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCCH0_A :: OFF } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == ASYNCCH0_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == ASYNCCH0_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == ASYNCCH0_A :: AC0_OUT } # [doc = "Checks if the value of the field is `TCD0_CMPBCLR`"]
# [inline (always)]
pub fn is_tcd0_cmpbclr (& self) -> bool { * self == ASYNCCH0_A :: TCD0_CMPBCLR } # [doc = "Checks if the value of the field is `TCD0_CMPASET`"]
# [inline (always)]
pub fn is_tcd0_cmpaset (& self) -> bool { * self == ASYNCCH0_A :: TCD0_CMPASET } # [doc = "Checks if the value of the field is `TCD0_CMPBSET`"]
# [inline (always)]
pub fn is_tcd0_cmpbset (& self) -> bool { * self == ASYNCCH0_A :: TCD0_CMPBSET } # [doc = "Checks if the value of the field is `TCD0_PROGEV`"]
# [inline (always)]
pub fn is_tcd0_progev (& self) -> bool { * self == ASYNCCH0_A :: TCD0_PROGEV } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == ASYNCCH0_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == ASYNCCH0_A :: RTC_CMP } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == ASYNCCH0_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == ASYNCCH0_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == ASYNCCH0_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == ASYNCCH0_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == ASYNCCH0_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == ASYNCCH0_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == ASYNCCH0_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == ASYNCCH0_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == ASYNCCH0_A :: UPDI } } # [doc = "Field `ASYNCCH0` writer - Asynchronous Channel 0 Generator Selection"]
pub type ASYNCCH0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCCH0_SPEC , u8 , ASYNCCH0_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCCH0_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: OFF) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: CCL_LUT1) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: AC0_OUT) } # [doc = "Timer/Counter D0 compare B clear"]
# [inline (always)]
pub fn tcd0_cmpbclr (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: TCD0_CMPBCLR) } # [doc = "Timer/Counter D0 compare A set"]
# [inline (always)]
pub fn tcd0_cmpaset (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: TCD0_CMPASET) } # [doc = "Timer/Counter D0 compare B set"]
# [inline (always)]
pub fn tcd0_cmpbset (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: TCD0_CMPBSET) } # [doc = "Timer/Counter D0 program event"]
# [inline (always)]
pub fn tcd0_progev (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: TCD0_PROGEV) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: RTC_CMP) } # [doc = "Asynchronous Event from Pin PA0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: PORTA_PIN0) } # [doc = "Asynchronous Event from Pin PA1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: PORTA_PIN1) } # [doc = "Asynchronous Event from Pin PA2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: PORTA_PIN2) } # [doc = "Asynchronous Event from Pin PA3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: PORTA_PIN3) } # [doc = "Asynchronous Event from Pin PA4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: PORTA_PIN4) } # [doc = "Asynchronous Event from Pin PA5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: PORTA_PIN5) } # [doc = "Asynchronous Event from Pin PA6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: PORTA_PIN6) } # [doc = "Asynchronous Event from Pin PA7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: PORTA_PIN7) } # [doc = "Unified Program and debug interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (ASYNCCH0_A :: UPDI) } } impl R { # [doc = "Bits 0:7 - Asynchronous Channel 0 Generator Selection"]
# [inline (always)]
pub fn asyncch0 (& self) -> ASYNCCH0_R { ASYNCCH0_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous Channel 0 Generator Selection"]
# [inline (always)]
# [must_use]
pub fn asyncch0 (& mut self) -> ASYNCCH0_W < 0 > { ASYNCCH0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous Channel 0 Generator Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncch0](index.html) module"]
pub struct ASYNCCH0_SPEC ; impl crate :: RegisterSpec for ASYNCCH0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncch0::R](R) reader structure"]
impl crate :: Readable for ASYNCCH0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncch0::W](W) writer structure"]
impl crate :: Writable for ASYNCCH0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCCH0 to value 0"]
impl crate :: Resettable for ASYNCCH0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCCH1 (rw) register accessor: an alias for `Reg<ASYNCCH1_SPEC>`"]
pub type ASYNCCH1 = crate :: Reg < asyncch1 :: ASYNCCH1_SPEC > ; # [doc = "Asynchronous Channel 1 Generator Selection"]
pub mod asyncch1 { # [doc = "Register `ASYNCCH1` reader"]
pub struct R (crate :: R < ASYNCCH1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCCH1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCCH1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCCH1_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCCH1` writer"]
pub struct W (crate :: W < ASYNCCH1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCCH1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCCH1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCCH1_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCCH1` reader - Asynchronous Channel 1 Generator Selection"]
pub type ASYNCCH1_R = crate :: FieldReader < u8 , ASYNCCH1_A > ; # [doc = "Asynchronous Channel 1 Generator Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCCH1_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Configurable custom logic LUT0"]
CCL_LUT0 = 1 , # [doc = "2: Configurable custom logic LUT1"]
CCL_LUT1 = 2 , # [doc = "3: Analog Comparator 0 out"]
AC0_OUT = 3 , # [doc = "4: Timer/Counter D0 compare B clear"]
TCD0_CMPBCLR = 4 , # [doc = "5: Timer/Counter D0 compare A set"]
TCD0_CMPASET = 5 , # [doc = "6: Timer/Counter D0 compare B set"]
TCD0_CMPBSET = 6 , # [doc = "7: Timer/Counter D0 program event"]
TCD0_PROGEV = 7 , # [doc = "8: Real Time Counter overflow"]
RTC_OVF = 8 , # [doc = "9: Real Time Counter compare"]
RTC_CMP = 9 , # [doc = "10: Asynchronous Event from Pin PB0"]
PORTB_PIN0 = 10 , # [doc = "11: Asynchronous Event from Pin PB1"]
PORTB_PIN1 = 11 , # [doc = "12: Asynchronous Event from Pin PB2"]
PORTB_PIN2 = 12 , # [doc = "13: Asynchronous Event from Pin PB3"]
PORTB_PIN3 = 13 , # [doc = "14: Asynchronous Event from Pin PB4"]
PORTB_PIN4 = 14 , # [doc = "15: Asynchronous Event from Pin PB5"]
PORTB_PIN5 = 15 , # [doc = "16: Asynchronous Event from Pin PB6"]
PORTB_PIN6 = 16 , # [doc = "17: Asynchronous Event from Pin PB7"]
PORTB_PIN7 = 17 , } impl From < ASYNCCH1_A > for u8 { # [inline (always)]
fn from (variant : ASYNCCH1_A) -> Self { variant as _ } } impl ASYNCCH1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCCH1_A > { match self . bits { 0 => Some (ASYNCCH1_A :: OFF) , 1 => Some (ASYNCCH1_A :: CCL_LUT0) , 2 => Some (ASYNCCH1_A :: CCL_LUT1) , 3 => Some (ASYNCCH1_A :: AC0_OUT) , 4 => Some (ASYNCCH1_A :: TCD0_CMPBCLR) , 5 => Some (ASYNCCH1_A :: TCD0_CMPASET) , 6 => Some (ASYNCCH1_A :: TCD0_CMPBSET) , 7 => Some (ASYNCCH1_A :: TCD0_PROGEV) , 8 => Some (ASYNCCH1_A :: RTC_OVF) , 9 => Some (ASYNCCH1_A :: RTC_CMP) , 10 => Some (ASYNCCH1_A :: PORTB_PIN0) , 11 => Some (ASYNCCH1_A :: PORTB_PIN1) , 12 => Some (ASYNCCH1_A :: PORTB_PIN2) , 13 => Some (ASYNCCH1_A :: PORTB_PIN3) , 14 => Some (ASYNCCH1_A :: PORTB_PIN4) , 15 => Some (ASYNCCH1_A :: PORTB_PIN5) , 16 => Some (ASYNCCH1_A :: PORTB_PIN6) , 17 => Some (ASYNCCH1_A :: PORTB_PIN7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCCH1_A :: OFF } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == ASYNCCH1_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == ASYNCCH1_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == ASYNCCH1_A :: AC0_OUT } # [doc = "Checks if the value of the field is `TCD0_CMPBCLR`"]
# [inline (always)]
pub fn is_tcd0_cmpbclr (& self) -> bool { * self == ASYNCCH1_A :: TCD0_CMPBCLR } # [doc = "Checks if the value of the field is `TCD0_CMPASET`"]
# [inline (always)]
pub fn is_tcd0_cmpaset (& self) -> bool { * self == ASYNCCH1_A :: TCD0_CMPASET } # [doc = "Checks if the value of the field is `TCD0_CMPBSET`"]
# [inline (always)]
pub fn is_tcd0_cmpbset (& self) -> bool { * self == ASYNCCH1_A :: TCD0_CMPBSET } # [doc = "Checks if the value of the field is `TCD0_PROGEV`"]
# [inline (always)]
pub fn is_tcd0_progev (& self) -> bool { * self == ASYNCCH1_A :: TCD0_PROGEV } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == ASYNCCH1_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == ASYNCCH1_A :: RTC_CMP } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == ASYNCCH1_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == ASYNCCH1_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == ASYNCCH1_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == ASYNCCH1_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == ASYNCCH1_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == ASYNCCH1_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == ASYNCCH1_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == ASYNCCH1_A :: PORTB_PIN7 } } # [doc = "Field `ASYNCCH1` writer - Asynchronous Channel 1 Generator Selection"]
pub type ASYNCCH1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCCH1_SPEC , u8 , ASYNCCH1_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCCH1_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: OFF) } # [doc = "Configurable custom logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: CCL_LUT0) } # [doc = "Configurable custom logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: CCL_LUT1) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: AC0_OUT) } # [doc = "Timer/Counter D0 compare B clear"]
# [inline (always)]
pub fn tcd0_cmpbclr (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: TCD0_CMPBCLR) } # [doc = "Timer/Counter D0 compare A set"]
# [inline (always)]
pub fn tcd0_cmpaset (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: TCD0_CMPASET) } # [doc = "Timer/Counter D0 compare B set"]
# [inline (always)]
pub fn tcd0_cmpbset (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: TCD0_CMPBSET) } # [doc = "Timer/Counter D0 program event"]
# [inline (always)]
pub fn tcd0_progev (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: TCD0_PROGEV) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: RTC_CMP) } # [doc = "Asynchronous Event from Pin PB0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: PORTB_PIN0) } # [doc = "Asynchronous Event from Pin PB1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: PORTB_PIN1) } # [doc = "Asynchronous Event from Pin PB2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: PORTB_PIN2) } # [doc = "Asynchronous Event from Pin PB3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: PORTB_PIN3) } # [doc = "Asynchronous Event from Pin PB4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: PORTB_PIN4) } # [doc = "Asynchronous Event from Pin PB5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: PORTB_PIN5) } # [doc = "Asynchronous Event from Pin PB6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: PORTB_PIN6) } # [doc = "Asynchronous Event from Pin PB7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (ASYNCCH1_A :: PORTB_PIN7) } } impl R { # [doc = "Bits 0:7 - Asynchronous Channel 1 Generator Selection"]
# [inline (always)]
pub fn asyncch1 (& self) -> ASYNCCH1_R { ASYNCCH1_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous Channel 1 Generator Selection"]
# [inline (always)]
# [must_use]
pub fn asyncch1 (& mut self) -> ASYNCCH1_W < 0 > { ASYNCCH1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous Channel 1 Generator Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncch1](index.html) module"]
pub struct ASYNCCH1_SPEC ; impl crate :: RegisterSpec for ASYNCCH1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncch1::R](R) reader structure"]
impl crate :: Readable for ASYNCCH1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncch1::W](W) writer structure"]
impl crate :: Writable for ASYNCCH1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCCH1 to value 0"]
impl crate :: Resettable for ASYNCCH1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCCH2 (rw) register accessor: an alias for `Reg<ASYNCCH2_SPEC>`"]
pub type ASYNCCH2 = crate :: Reg < asyncch2 :: ASYNCCH2_SPEC > ; # [doc = "Asynchronous Channel 2 Generator Selection"]
pub mod asyncch2 { # [doc = "Register `ASYNCCH2` reader"]
pub struct R (crate :: R < ASYNCCH2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCCH2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCCH2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCCH2_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCCH2` writer"]
pub struct W (crate :: W < ASYNCCH2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCCH2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCCH2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCCH2_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCCH2` reader - Asynchronous Channel 2 Generator Selection"]
pub type ASYNCCH2_R = crate :: FieldReader < u8 , ASYNCCH2_A > ; # [doc = "Asynchronous Channel 2 Generator Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCCH2_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Configurable Custom Logic LUT0"]
CCL_LUT0 = 1 , # [doc = "2: Configurable Custom Logic LUT1"]
CCL_LUT1 = 2 , # [doc = "3: Analog Comparator 0 out"]
AC0_OUT = 3 , # [doc = "4: Timer/Counter D0 compare B clear"]
TCD0_CMPBCLR = 4 , # [doc = "5: Timer/Counter D0 compare A set"]
TCD0_CMPASET = 5 , # [doc = "6: Timer/Counter D0 compare B set"]
TCD0_CMPBSET = 6 , # [doc = "7: Timer/Counter D0 program event"]
TCD0_PROGEV = 7 , # [doc = "8: Real Time Counter overflow"]
RTC_OVF = 8 , # [doc = "9: Real Time Counter compare"]
RTC_CMP = 9 , # [doc = "10: Asynchronous Event from Pin PC0"]
PORTC_PIN0 = 10 , # [doc = "11: Asynchronous Event from Pin PC1"]
PORTC_PIN1 = 11 , # [doc = "12: Asynchronous Event from Pin PC2"]
PORTC_PIN2 = 12 , # [doc = "13: Asynchronous Event from Pin PC3"]
PORTC_PIN3 = 13 , # [doc = "14: Asynchronous Event from Pin PC4"]
PORTC_PIN4 = 14 , # [doc = "15: Asynchronous Event from Pin PC5"]
PORTC_PIN5 = 15 , } impl From < ASYNCCH2_A > for u8 { # [inline (always)]
fn from (variant : ASYNCCH2_A) -> Self { variant as _ } } impl ASYNCCH2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCCH2_A > { match self . bits { 0 => Some (ASYNCCH2_A :: OFF) , 1 => Some (ASYNCCH2_A :: CCL_LUT0) , 2 => Some (ASYNCCH2_A :: CCL_LUT1) , 3 => Some (ASYNCCH2_A :: AC0_OUT) , 4 => Some (ASYNCCH2_A :: TCD0_CMPBCLR) , 5 => Some (ASYNCCH2_A :: TCD0_CMPASET) , 6 => Some (ASYNCCH2_A :: TCD0_CMPBSET) , 7 => Some (ASYNCCH2_A :: TCD0_PROGEV) , 8 => Some (ASYNCCH2_A :: RTC_OVF) , 9 => Some (ASYNCCH2_A :: RTC_CMP) , 10 => Some (ASYNCCH2_A :: PORTC_PIN0) , 11 => Some (ASYNCCH2_A :: PORTC_PIN1) , 12 => Some (ASYNCCH2_A :: PORTC_PIN2) , 13 => Some (ASYNCCH2_A :: PORTC_PIN3) , 14 => Some (ASYNCCH2_A :: PORTC_PIN4) , 15 => Some (ASYNCCH2_A :: PORTC_PIN5) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCCH2_A :: OFF } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == ASYNCCH2_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == ASYNCCH2_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == ASYNCCH2_A :: AC0_OUT } # [doc = "Checks if the value of the field is `TCD0_CMPBCLR`"]
# [inline (always)]
pub fn is_tcd0_cmpbclr (& self) -> bool { * self == ASYNCCH2_A :: TCD0_CMPBCLR } # [doc = "Checks if the value of the field is `TCD0_CMPASET`"]
# [inline (always)]
pub fn is_tcd0_cmpaset (& self) -> bool { * self == ASYNCCH2_A :: TCD0_CMPASET } # [doc = "Checks if the value of the field is `TCD0_CMPBSET`"]
# [inline (always)]
pub fn is_tcd0_cmpbset (& self) -> bool { * self == ASYNCCH2_A :: TCD0_CMPBSET } # [doc = "Checks if the value of the field is `TCD0_PROGEV`"]
# [inline (always)]
pub fn is_tcd0_progev (& self) -> bool { * self == ASYNCCH2_A :: TCD0_PROGEV } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == ASYNCCH2_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == ASYNCCH2_A :: RTC_CMP } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == ASYNCCH2_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == ASYNCCH2_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == ASYNCCH2_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == ASYNCCH2_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == ASYNCCH2_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == ASYNCCH2_A :: PORTC_PIN5 } } # [doc = "Field `ASYNCCH2` writer - Asynchronous Channel 2 Generator Selection"]
pub type ASYNCCH2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCCH2_SPEC , u8 , ASYNCCH2_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCCH2_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: OFF) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: CCL_LUT1) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: AC0_OUT) } # [doc = "Timer/Counter D0 compare B clear"]
# [inline (always)]
pub fn tcd0_cmpbclr (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: TCD0_CMPBCLR) } # [doc = "Timer/Counter D0 compare A set"]
# [inline (always)]
pub fn tcd0_cmpaset (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: TCD0_CMPASET) } # [doc = "Timer/Counter D0 compare B set"]
# [inline (always)]
pub fn tcd0_cmpbset (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: TCD0_CMPBSET) } # [doc = "Timer/Counter D0 program event"]
# [inline (always)]
pub fn tcd0_progev (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: TCD0_PROGEV) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: RTC_CMP) } # [doc = "Asynchronous Event from Pin PC0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: PORTC_PIN0) } # [doc = "Asynchronous Event from Pin PC1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: PORTC_PIN1) } # [doc = "Asynchronous Event from Pin PC2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: PORTC_PIN2) } # [doc = "Asynchronous Event from Pin PC3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: PORTC_PIN3) } # [doc = "Asynchronous Event from Pin PC4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: PORTC_PIN4) } # [doc = "Asynchronous Event from Pin PC5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (ASYNCCH2_A :: PORTC_PIN5) } } impl R { # [doc = "Bits 0:7 - Asynchronous Channel 2 Generator Selection"]
# [inline (always)]
pub fn asyncch2 (& self) -> ASYNCCH2_R { ASYNCCH2_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous Channel 2 Generator Selection"]
# [inline (always)]
# [must_use]
pub fn asyncch2 (& mut self) -> ASYNCCH2_W < 0 > { ASYNCCH2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous Channel 2 Generator Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncch2](index.html) module"]
pub struct ASYNCCH2_SPEC ; impl crate :: RegisterSpec for ASYNCCH2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncch2::R](R) reader structure"]
impl crate :: Readable for ASYNCCH2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncch2::W](W) writer structure"]
impl crate :: Writable for ASYNCCH2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCCH2 to value 0"]
impl crate :: Resettable for ASYNCCH2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCCH3 (rw) register accessor: an alias for `Reg<ASYNCCH3_SPEC>`"]
pub type ASYNCCH3 = crate :: Reg < asyncch3 :: ASYNCCH3_SPEC > ; # [doc = "Asynchronous Channel 3 Generator Selection"]
pub mod asyncch3 { # [doc = "Register `ASYNCCH3` reader"]
pub struct R (crate :: R < ASYNCCH3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCCH3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCCH3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCCH3_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCCH3` writer"]
pub struct W (crate :: W < ASYNCCH3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCCH3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCCH3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCCH3_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCCH3` reader - Asynchronous Channel 3 Generator Selection"]
pub type ASYNCCH3_R = crate :: FieldReader < u8 , ASYNCCH3_A > ; # [doc = "Asynchronous Channel 3 Generator Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCCH3_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Configurable custom logic LUT0"]
CCL_LUT0 = 1 , # [doc = "2: Configurable custom logic LUT1"]
CCL_LUT1 = 2 , # [doc = "3: Analog Comparator 0 out"]
AC0_OUT = 3 , # [doc = "4: Timer/Counter type D compare B clear"]
TCD0_CMPBCLR = 4 , # [doc = "5: Timer/Counter type D compare A set"]
TCD0_CMPASET = 5 , # [doc = "6: Timer/Counter type D compare B set"]
TCD0_CMPBSET = 6 , # [doc = "7: Timer/Counter type D program event"]
TCD0_PROGEV = 7 , # [doc = "8: Real Time Counter overflow"]
RTC_OVF = 8 , # [doc = "9: Real Time Counter compare"]
RTC_CMP = 9 , # [doc = "10: Periodic Interrupt CLK_RTC div 8192"]
PIT_DIV8192 = 10 , # [doc = "11: Periodic Interrupt CLK_RTC div 4096"]
PIT_DIV4096 = 11 , # [doc = "12: Periodic Interrupt CLK_RTC div 2048"]
PIT_DIV2048 = 12 , # [doc = "13: Periodic Interrupt CLK_RTC div 1024"]
PIT_DIV1024 = 13 , # [doc = "14: Periodic Interrupt CLK_RTC div 512"]
PIT_DIV512 = 14 , # [doc = "15: Periodic Interrupt CLK_RTC div 256"]
PIT_DIV256 = 15 , # [doc = "16: Periodic Interrupt CLK_RTC div 128"]
PIT_DIV128 = 16 , # [doc = "17: Periodic Interrupt CLK_RTC div 64"]
PIT_DIV64 = 17 , } impl From < ASYNCCH3_A > for u8 { # [inline (always)]
fn from (variant : ASYNCCH3_A) -> Self { variant as _ } } impl ASYNCCH3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCCH3_A > { match self . bits { 0 => Some (ASYNCCH3_A :: OFF) , 1 => Some (ASYNCCH3_A :: CCL_LUT0) , 2 => Some (ASYNCCH3_A :: CCL_LUT1) , 3 => Some (ASYNCCH3_A :: AC0_OUT) , 4 => Some (ASYNCCH3_A :: TCD0_CMPBCLR) , 5 => Some (ASYNCCH3_A :: TCD0_CMPASET) , 6 => Some (ASYNCCH3_A :: TCD0_CMPBSET) , 7 => Some (ASYNCCH3_A :: TCD0_PROGEV) , 8 => Some (ASYNCCH3_A :: RTC_OVF) , 9 => Some (ASYNCCH3_A :: RTC_CMP) , 10 => Some (ASYNCCH3_A :: PIT_DIV8192) , 11 => Some (ASYNCCH3_A :: PIT_DIV4096) , 12 => Some (ASYNCCH3_A :: PIT_DIV2048) , 13 => Some (ASYNCCH3_A :: PIT_DIV1024) , 14 => Some (ASYNCCH3_A :: PIT_DIV512) , 15 => Some (ASYNCCH3_A :: PIT_DIV256) , 16 => Some (ASYNCCH3_A :: PIT_DIV128) , 17 => Some (ASYNCCH3_A :: PIT_DIV64) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCCH3_A :: OFF } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == ASYNCCH3_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == ASYNCCH3_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == ASYNCCH3_A :: AC0_OUT } # [doc = "Checks if the value of the field is `TCD0_CMPBCLR`"]
# [inline (always)]
pub fn is_tcd0_cmpbclr (& self) -> bool { * self == ASYNCCH3_A :: TCD0_CMPBCLR } # [doc = "Checks if the value of the field is `TCD0_CMPASET`"]
# [inline (always)]
pub fn is_tcd0_cmpaset (& self) -> bool { * self == ASYNCCH3_A :: TCD0_CMPASET } # [doc = "Checks if the value of the field is `TCD0_CMPBSET`"]
# [inline (always)]
pub fn is_tcd0_cmpbset (& self) -> bool { * self == ASYNCCH3_A :: TCD0_CMPBSET } # [doc = "Checks if the value of the field is `TCD0_PROGEV`"]
# [inline (always)]
pub fn is_tcd0_progev (& self) -> bool { * self == ASYNCCH3_A :: TCD0_PROGEV } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == ASYNCCH3_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == ASYNCCH3_A :: RTC_CMP } # [doc = "Checks if the value of the field is `PIT_DIV8192`"]
# [inline (always)]
pub fn is_pit_div8192 (& self) -> bool { * self == ASYNCCH3_A :: PIT_DIV8192 } # [doc = "Checks if the value of the field is `PIT_DIV4096`"]
# [inline (always)]
pub fn is_pit_div4096 (& self) -> bool { * self == ASYNCCH3_A :: PIT_DIV4096 } # [doc = "Checks if the value of the field is `PIT_DIV2048`"]
# [inline (always)]
pub fn is_pit_div2048 (& self) -> bool { * self == ASYNCCH3_A :: PIT_DIV2048 } # [doc = "Checks if the value of the field is `PIT_DIV1024`"]
# [inline (always)]
pub fn is_pit_div1024 (& self) -> bool { * self == ASYNCCH3_A :: PIT_DIV1024 } # [doc = "Checks if the value of the field is `PIT_DIV512`"]
# [inline (always)]
pub fn is_pit_div512 (& self) -> bool { * self == ASYNCCH3_A :: PIT_DIV512 } # [doc = "Checks if the value of the field is `PIT_DIV256`"]
# [inline (always)]
pub fn is_pit_div256 (& self) -> bool { * self == ASYNCCH3_A :: PIT_DIV256 } # [doc = "Checks if the value of the field is `PIT_DIV128`"]
# [inline (always)]
pub fn is_pit_div128 (& self) -> bool { * self == ASYNCCH3_A :: PIT_DIV128 } # [doc = "Checks if the value of the field is `PIT_DIV64`"]
# [inline (always)]
pub fn is_pit_div64 (& self) -> bool { * self == ASYNCCH3_A :: PIT_DIV64 } } # [doc = "Field `ASYNCCH3` writer - Asynchronous Channel 3 Generator Selection"]
pub type ASYNCCH3_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCCH3_SPEC , u8 , ASYNCCH3_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCCH3_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: OFF) } # [doc = "Configurable custom logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: CCL_LUT0) } # [doc = "Configurable custom logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: CCL_LUT1) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: AC0_OUT) } # [doc = "Timer/Counter type D compare B clear"]
# [inline (always)]
pub fn tcd0_cmpbclr (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: TCD0_CMPBCLR) } # [doc = "Timer/Counter type D compare A set"]
# [inline (always)]
pub fn tcd0_cmpaset (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: TCD0_CMPASET) } # [doc = "Timer/Counter type D compare B set"]
# [inline (always)]
pub fn tcd0_cmpbset (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: TCD0_CMPBSET) } # [doc = "Timer/Counter type D program event"]
# [inline (always)]
pub fn tcd0_progev (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: TCD0_PROGEV) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: RTC_CMP) } # [doc = "Periodic Interrupt CLK_RTC div 8192"]
# [inline (always)]
pub fn pit_div8192 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: PIT_DIV8192) } # [doc = "Periodic Interrupt CLK_RTC div 4096"]
# [inline (always)]
pub fn pit_div4096 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: PIT_DIV4096) } # [doc = "Periodic Interrupt CLK_RTC div 2048"]
# [inline (always)]
pub fn pit_div2048 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: PIT_DIV2048) } # [doc = "Periodic Interrupt CLK_RTC div 1024"]
# [inline (always)]
pub fn pit_div1024 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: PIT_DIV1024) } # [doc = "Periodic Interrupt CLK_RTC div 512"]
# [inline (always)]
pub fn pit_div512 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: PIT_DIV512) } # [doc = "Periodic Interrupt CLK_RTC div 256"]
# [inline (always)]
pub fn pit_div256 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: PIT_DIV256) } # [doc = "Periodic Interrupt CLK_RTC div 128"]
# [inline (always)]
pub fn pit_div128 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: PIT_DIV128) } # [doc = "Periodic Interrupt CLK_RTC div 64"]
# [inline (always)]
pub fn pit_div64 (self) -> & 'a mut W { self . variant (ASYNCCH3_A :: PIT_DIV64) } } impl R { # [doc = "Bits 0:7 - Asynchronous Channel 3 Generator Selection"]
# [inline (always)]
pub fn asyncch3 (& self) -> ASYNCCH3_R { ASYNCCH3_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous Channel 3 Generator Selection"]
# [inline (always)]
# [must_use]
pub fn asyncch3 (& mut self) -> ASYNCCH3_W < 0 > { ASYNCCH3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous Channel 3 Generator Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncch3](index.html) module"]
pub struct ASYNCCH3_SPEC ; impl crate :: RegisterSpec for ASYNCCH3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncch3::R](R) reader structure"]
impl crate :: Readable for ASYNCCH3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncch3::W](W) writer structure"]
impl crate :: Writable for ASYNCCH3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCCH3 to value 0"]
impl crate :: Resettable for ASYNCCH3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCSTROBE (w) register accessor: an alias for `Reg<ASYNCSTROBE_SPEC>`"]
pub type ASYNCSTROBE = crate :: Reg < asyncstrobe :: ASYNCSTROBE_SPEC > ; # [doc = "Asynchronous Channel Strobe"]
pub mod asyncstrobe { # [doc = "Register `ASYNCSTROBE` writer"]
pub struct W (crate :: W < ASYNCSTROBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCSTROBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCSTROBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCSTROBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Asynchronous Channel Strobe\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncstrobe](index.html) module"]
pub struct ASYNCSTROBE_SPEC ; impl crate :: RegisterSpec for ASYNCSTROBE_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [asyncstrobe::W](W) writer structure"]
impl crate :: Writable for ASYNCSTROBE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCSTROBE to value 0"]
impl crate :: Resettable for ASYNCSTROBE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER0 (rw) register accessor: an alias for `Reg<ASYNCUSER0_SPEC>`"]
pub type ASYNCUSER0 = crate :: Reg < asyncuser0 :: ASYNCUSER0_SPEC > ; # [doc = "Asynchronous User Ch 0 Input Selection - TCB0"]
pub mod asyncuser0 { # [doc = "Register `ASYNCUSER0` reader"]
pub struct R (crate :: R < ASYNCUSER0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER0_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER0` writer"]
pub struct W (crate :: W < ASYNCUSER0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER0_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER0` reader - Asynchronous User Ch 0 Input Selection - TCB0"]
pub type ASYNCUSER0_R = crate :: FieldReader < u8 , ASYNCUSER0_A > ; # [doc = "Asynchronous User Ch 0 Input Selection - TCB0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER0_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER0_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER0_A) -> Self { variant as _ } } impl ASYNCUSER0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER0_A > { match self . bits { 0 => Some (ASYNCUSER0_A :: OFF) , 1 => Some (ASYNCUSER0_A :: SYNCCH0) , 2 => Some (ASYNCUSER0_A :: SYNCCH1) , 3 => Some (ASYNCUSER0_A :: ASYNCCH0) , 4 => Some (ASYNCUSER0_A :: ASYNCCH1) , 5 => Some (ASYNCUSER0_A :: ASYNCCH2) , 6 => Some (ASYNCUSER0_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER0_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER0_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER0_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER0_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER0_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER0_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER0_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER0` writer - Asynchronous User Ch 0 Input Selection - TCB0"]
pub type ASYNCUSER0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER0_SPEC , u8 , ASYNCUSER0_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER0_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER0_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER0_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER0_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER0_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER0_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER0_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER0_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 0 Input Selection - TCB0"]
# [inline (always)]
pub fn asyncuser0 (& self) -> ASYNCUSER0_R { ASYNCUSER0_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 0 Input Selection - TCB0"]
# [inline (always)]
# [must_use]
pub fn asyncuser0 (& mut self) -> ASYNCUSER0_W < 0 > { ASYNCUSER0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 0 Input Selection - TCB0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser0](index.html) module"]
pub struct ASYNCUSER0_SPEC ; impl crate :: RegisterSpec for ASYNCUSER0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser0::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser0::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER0 to value 0"]
impl crate :: Resettable for ASYNCUSER0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER1 (rw) register accessor: an alias for `Reg<ASYNCUSER1_SPEC>`"]
pub type ASYNCUSER1 = crate :: Reg < asyncuser1 :: ASYNCUSER1_SPEC > ; # [doc = "Asynchronous User Ch 1 Input Selection - ADC0"]
pub mod asyncuser1 { # [doc = "Register `ASYNCUSER1` reader"]
pub struct R (crate :: R < ASYNCUSER1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER1_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER1` writer"]
pub struct W (crate :: W < ASYNCUSER1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER1_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER1` reader - Asynchronous User Ch 1 Input Selection - ADC0"]
pub type ASYNCUSER1_R = crate :: FieldReader < u8 , ASYNCUSER1_A > ; # [doc = "Asynchronous User Ch 1 Input Selection - ADC0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER1_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER1_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER1_A) -> Self { variant as _ } } impl ASYNCUSER1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER1_A > { match self . bits { 0 => Some (ASYNCUSER1_A :: OFF) , 1 => Some (ASYNCUSER1_A :: SYNCCH0) , 2 => Some (ASYNCUSER1_A :: SYNCCH1) , 3 => Some (ASYNCUSER1_A :: ASYNCCH0) , 4 => Some (ASYNCUSER1_A :: ASYNCCH1) , 5 => Some (ASYNCUSER1_A :: ASYNCCH2) , 6 => Some (ASYNCUSER1_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER1_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER1_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER1_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER1_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER1_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER1_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER1_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER1` writer - Asynchronous User Ch 1 Input Selection - ADC0"]
pub type ASYNCUSER1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER1_SPEC , u8 , ASYNCUSER1_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER1_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER1_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER1_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER1_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER1_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER1_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER1_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER1_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 1 Input Selection - ADC0"]
# [inline (always)]
pub fn asyncuser1 (& self) -> ASYNCUSER1_R { ASYNCUSER1_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 1 Input Selection - ADC0"]
# [inline (always)]
# [must_use]
pub fn asyncuser1 (& mut self) -> ASYNCUSER1_W < 0 > { ASYNCUSER1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 1 Input Selection - ADC0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser1](index.html) module"]
pub struct ASYNCUSER1_SPEC ; impl crate :: RegisterSpec for ASYNCUSER1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser1::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser1::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER1 to value 0"]
impl crate :: Resettable for ASYNCUSER1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER10 (rw) register accessor: an alias for `Reg<ASYNCUSER10_SPEC>`"]
pub type ASYNCUSER10 = crate :: Reg < asyncuser10 :: ASYNCUSER10_SPEC > ; # [doc = "Asynchronous User Ch 10 Input Selection - Event Out 2"]
pub mod asyncuser10 { # [doc = "Register `ASYNCUSER10` reader"]
pub struct R (crate :: R < ASYNCUSER10_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER10_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER10_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER10_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER10` writer"]
pub struct W (crate :: W < ASYNCUSER10_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER10_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER10_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER10_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER10` reader - Asynchronous User Ch 10 Input Selection - Event Out 2"]
pub type ASYNCUSER10_R = crate :: FieldReader < u8 , ASYNCUSER10_A > ; # [doc = "Asynchronous User Ch 10 Input Selection - Event Out 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER10_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER10_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER10_A) -> Self { variant as _ } } impl ASYNCUSER10_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER10_A > { match self . bits { 0 => Some (ASYNCUSER10_A :: OFF) , 1 => Some (ASYNCUSER10_A :: SYNCCH0) , 2 => Some (ASYNCUSER10_A :: SYNCCH1) , 3 => Some (ASYNCUSER10_A :: ASYNCCH0) , 4 => Some (ASYNCUSER10_A :: ASYNCCH1) , 5 => Some (ASYNCUSER10_A :: ASYNCCH2) , 6 => Some (ASYNCUSER10_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER10_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER10_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER10_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER10_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER10_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER10_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER10_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER10` writer - Asynchronous User Ch 10 Input Selection - Event Out 2"]
pub type ASYNCUSER10_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER10_SPEC , u8 , ASYNCUSER10_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER10_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER10_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER10_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER10_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER10_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER10_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER10_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER10_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 10 Input Selection - Event Out 2"]
# [inline (always)]
pub fn asyncuser10 (& self) -> ASYNCUSER10_R { ASYNCUSER10_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 10 Input Selection - Event Out 2"]
# [inline (always)]
# [must_use]
pub fn asyncuser10 (& mut self) -> ASYNCUSER10_W < 0 > { ASYNCUSER10_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 10 Input Selection - Event Out 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser10](index.html) module"]
pub struct ASYNCUSER10_SPEC ; impl crate :: RegisterSpec for ASYNCUSER10_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser10::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER10_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser10::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER10_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER10 to value 0"]
impl crate :: Resettable for ASYNCUSER10_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER2 (rw) register accessor: an alias for `Reg<ASYNCUSER2_SPEC>`"]
pub type ASYNCUSER2 = crate :: Reg < asyncuser2 :: ASYNCUSER2_SPEC > ; # [doc = "Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0"]
pub mod asyncuser2 { # [doc = "Register `ASYNCUSER2` reader"]
pub struct R (crate :: R < ASYNCUSER2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER2_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER2` writer"]
pub struct W (crate :: W < ASYNCUSER2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER2_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER2` reader - Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0"]
pub type ASYNCUSER2_R = crate :: FieldReader < u8 , ASYNCUSER2_A > ; # [doc = "Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER2_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER2_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER2_A) -> Self { variant as _ } } impl ASYNCUSER2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER2_A > { match self . bits { 0 => Some (ASYNCUSER2_A :: OFF) , 1 => Some (ASYNCUSER2_A :: SYNCCH0) , 2 => Some (ASYNCUSER2_A :: SYNCCH1) , 3 => Some (ASYNCUSER2_A :: ASYNCCH0) , 4 => Some (ASYNCUSER2_A :: ASYNCCH1) , 5 => Some (ASYNCUSER2_A :: ASYNCCH2) , 6 => Some (ASYNCUSER2_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER2_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER2_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER2_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER2_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER2_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER2_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER2_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER2` writer - Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0"]
pub type ASYNCUSER2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER2_SPEC , u8 , ASYNCUSER2_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER2_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER2_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER2_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER2_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER2_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER2_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER2_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER2_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0"]
# [inline (always)]
pub fn asyncuser2 (& self) -> ASYNCUSER2_R { ASYNCUSER2_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0"]
# [inline (always)]
# [must_use]
pub fn asyncuser2 (& mut self) -> ASYNCUSER2_W < 0 > { ASYNCUSER2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser2](index.html) module"]
pub struct ASYNCUSER2_SPEC ; impl crate :: RegisterSpec for ASYNCUSER2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser2::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser2::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER2 to value 0"]
impl crate :: Resettable for ASYNCUSER2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER3 (rw) register accessor: an alias for `Reg<ASYNCUSER3_SPEC>`"]
pub type ASYNCUSER3 = crate :: Reg < asyncuser3 :: ASYNCUSER3_SPEC > ; # [doc = "Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0"]
pub mod asyncuser3 { # [doc = "Register `ASYNCUSER3` reader"]
pub struct R (crate :: R < ASYNCUSER3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER3_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER3` writer"]
pub struct W (crate :: W < ASYNCUSER3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER3_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER3` reader - Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0"]
pub type ASYNCUSER3_R = crate :: FieldReader < u8 , ASYNCUSER3_A > ; # [doc = "Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER3_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER3_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER3_A) -> Self { variant as _ } } impl ASYNCUSER3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER3_A > { match self . bits { 0 => Some (ASYNCUSER3_A :: OFF) , 1 => Some (ASYNCUSER3_A :: SYNCCH0) , 2 => Some (ASYNCUSER3_A :: SYNCCH1) , 3 => Some (ASYNCUSER3_A :: ASYNCCH0) , 4 => Some (ASYNCUSER3_A :: ASYNCCH1) , 5 => Some (ASYNCUSER3_A :: ASYNCCH2) , 6 => Some (ASYNCUSER3_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER3_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER3_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER3_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER3_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER3_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER3_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER3_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER3` writer - Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0"]
pub type ASYNCUSER3_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER3_SPEC , u8 , ASYNCUSER3_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER3_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER3_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER3_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER3_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER3_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER3_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER3_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER3_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0"]
# [inline (always)]
pub fn asyncuser3 (& self) -> ASYNCUSER3_R { ASYNCUSER3_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0"]
# [inline (always)]
# [must_use]
pub fn asyncuser3 (& mut self) -> ASYNCUSER3_W < 0 > { ASYNCUSER3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser3](index.html) module"]
pub struct ASYNCUSER3_SPEC ; impl crate :: RegisterSpec for ASYNCUSER3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser3::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser3::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER3 to value 0"]
impl crate :: Resettable for ASYNCUSER3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER4 (rw) register accessor: an alias for `Reg<ASYNCUSER4_SPEC>`"]
pub type ASYNCUSER4 = crate :: Reg < asyncuser4 :: ASYNCUSER4_SPEC > ; # [doc = "Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1"]
pub mod asyncuser4 { # [doc = "Register `ASYNCUSER4` reader"]
pub struct R (crate :: R < ASYNCUSER4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER4_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER4` writer"]
pub struct W (crate :: W < ASYNCUSER4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER4_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER4` reader - Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1"]
pub type ASYNCUSER4_R = crate :: FieldReader < u8 , ASYNCUSER4_A > ; # [doc = "Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER4_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER4_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER4_A) -> Self { variant as _ } } impl ASYNCUSER4_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER4_A > { match self . bits { 0 => Some (ASYNCUSER4_A :: OFF) , 1 => Some (ASYNCUSER4_A :: SYNCCH0) , 2 => Some (ASYNCUSER4_A :: SYNCCH1) , 3 => Some (ASYNCUSER4_A :: ASYNCCH0) , 4 => Some (ASYNCUSER4_A :: ASYNCCH1) , 5 => Some (ASYNCUSER4_A :: ASYNCCH2) , 6 => Some (ASYNCUSER4_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER4_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER4_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER4_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER4_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER4_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER4_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER4_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER4` writer - Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1"]
pub type ASYNCUSER4_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER4_SPEC , u8 , ASYNCUSER4_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER4_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER4_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER4_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER4_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER4_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER4_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER4_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER4_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1"]
# [inline (always)]
pub fn asyncuser4 (& self) -> ASYNCUSER4_R { ASYNCUSER4_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1"]
# [inline (always)]
# [must_use]
pub fn asyncuser4 (& mut self) -> ASYNCUSER4_W < 0 > { ASYNCUSER4_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser4](index.html) module"]
pub struct ASYNCUSER4_SPEC ; impl crate :: RegisterSpec for ASYNCUSER4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser4::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser4::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER4 to value 0"]
impl crate :: Resettable for ASYNCUSER4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER5 (rw) register accessor: an alias for `Reg<ASYNCUSER5_SPEC>`"]
pub type ASYNCUSER5 = crate :: Reg < asyncuser5 :: ASYNCUSER5_SPEC > ; # [doc = "Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1"]
pub mod asyncuser5 { # [doc = "Register `ASYNCUSER5` reader"]
pub struct R (crate :: R < ASYNCUSER5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER5_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER5` writer"]
pub struct W (crate :: W < ASYNCUSER5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER5_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER5` reader - Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1"]
pub type ASYNCUSER5_R = crate :: FieldReader < u8 , ASYNCUSER5_A > ; # [doc = "Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER5_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER5_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER5_A) -> Self { variant as _ } } impl ASYNCUSER5_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER5_A > { match self . bits { 0 => Some (ASYNCUSER5_A :: OFF) , 1 => Some (ASYNCUSER5_A :: SYNCCH0) , 2 => Some (ASYNCUSER5_A :: SYNCCH1) , 3 => Some (ASYNCUSER5_A :: ASYNCCH0) , 4 => Some (ASYNCUSER5_A :: ASYNCCH1) , 5 => Some (ASYNCUSER5_A :: ASYNCCH2) , 6 => Some (ASYNCUSER5_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER5_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER5_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER5_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER5_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER5_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER5_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER5_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER5` writer - Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1"]
pub type ASYNCUSER5_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER5_SPEC , u8 , ASYNCUSER5_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER5_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER5_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER5_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER5_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER5_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER5_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER5_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER5_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1"]
# [inline (always)]
pub fn asyncuser5 (& self) -> ASYNCUSER5_R { ASYNCUSER5_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1"]
# [inline (always)]
# [must_use]
pub fn asyncuser5 (& mut self) -> ASYNCUSER5_W < 0 > { ASYNCUSER5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser5](index.html) module"]
pub struct ASYNCUSER5_SPEC ; impl crate :: RegisterSpec for ASYNCUSER5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser5::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser5::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER5 to value 0"]
impl crate :: Resettable for ASYNCUSER5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER6 (rw) register accessor: an alias for `Reg<ASYNCUSER6_SPEC>`"]
pub type ASYNCUSER6 = crate :: Reg < asyncuser6 :: ASYNCUSER6_SPEC > ; # [doc = "Asynchronous User Ch 6 Input Selection - TCD0 Event 0"]
pub mod asyncuser6 { # [doc = "Register `ASYNCUSER6` reader"]
pub struct R (crate :: R < ASYNCUSER6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER6_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER6` writer"]
pub struct W (crate :: W < ASYNCUSER6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER6_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER6` reader - Asynchronous User Ch 6 Input Selection - TCD0 Event 0"]
pub type ASYNCUSER6_R = crate :: FieldReader < u8 , ASYNCUSER6_A > ; # [doc = "Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER6_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER6_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER6_A) -> Self { variant as _ } } impl ASYNCUSER6_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER6_A > { match self . bits { 0 => Some (ASYNCUSER6_A :: OFF) , 1 => Some (ASYNCUSER6_A :: SYNCCH0) , 2 => Some (ASYNCUSER6_A :: SYNCCH1) , 3 => Some (ASYNCUSER6_A :: ASYNCCH0) , 4 => Some (ASYNCUSER6_A :: ASYNCCH1) , 5 => Some (ASYNCUSER6_A :: ASYNCCH2) , 6 => Some (ASYNCUSER6_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER6_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER6_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER6_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER6_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER6_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER6_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER6_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER6` writer - Asynchronous User Ch 6 Input Selection - TCD0 Event 0"]
pub type ASYNCUSER6_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER6_SPEC , u8 , ASYNCUSER6_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER6_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER6_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER6_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER6_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER6_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER6_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER6_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER6_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 6 Input Selection - TCD0 Event 0"]
# [inline (always)]
pub fn asyncuser6 (& self) -> ASYNCUSER6_R { ASYNCUSER6_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 6 Input Selection - TCD0 Event 0"]
# [inline (always)]
# [must_use]
pub fn asyncuser6 (& mut self) -> ASYNCUSER6_W < 0 > { ASYNCUSER6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser6](index.html) module"]
pub struct ASYNCUSER6_SPEC ; impl crate :: RegisterSpec for ASYNCUSER6_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser6::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser6::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER6_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER6 to value 0"]
impl crate :: Resettable for ASYNCUSER6_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER7 (rw) register accessor: an alias for `Reg<ASYNCUSER7_SPEC>`"]
pub type ASYNCUSER7 = crate :: Reg < asyncuser7 :: ASYNCUSER7_SPEC > ; # [doc = "Asynchronous User Ch 7 Input Selection - TCD0 Event 1"]
pub mod asyncuser7 { # [doc = "Register `ASYNCUSER7` reader"]
pub struct R (crate :: R < ASYNCUSER7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER7_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER7` writer"]
pub struct W (crate :: W < ASYNCUSER7_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER7_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER7_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER7` reader - Asynchronous User Ch 7 Input Selection - TCD0 Event 1"]
pub type ASYNCUSER7_R = crate :: FieldReader < u8 , ASYNCUSER7_A > ; # [doc = "Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER7_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER7_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER7_A) -> Self { variant as _ } } impl ASYNCUSER7_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER7_A > { match self . bits { 0 => Some (ASYNCUSER7_A :: OFF) , 1 => Some (ASYNCUSER7_A :: SYNCCH0) , 2 => Some (ASYNCUSER7_A :: SYNCCH1) , 3 => Some (ASYNCUSER7_A :: ASYNCCH0) , 4 => Some (ASYNCUSER7_A :: ASYNCCH1) , 5 => Some (ASYNCUSER7_A :: ASYNCCH2) , 6 => Some (ASYNCUSER7_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER7_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER7_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER7_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER7_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER7_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER7_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER7_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER7` writer - Asynchronous User Ch 7 Input Selection - TCD0 Event 1"]
pub type ASYNCUSER7_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER7_SPEC , u8 , ASYNCUSER7_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER7_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER7_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER7_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER7_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER7_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER7_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER7_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER7_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 7 Input Selection - TCD0 Event 1"]
# [inline (always)]
pub fn asyncuser7 (& self) -> ASYNCUSER7_R { ASYNCUSER7_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 7 Input Selection - TCD0 Event 1"]
# [inline (always)]
# [must_use]
pub fn asyncuser7 (& mut self) -> ASYNCUSER7_W < 0 > { ASYNCUSER7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser7](index.html) module"]
pub struct ASYNCUSER7_SPEC ; impl crate :: RegisterSpec for ASYNCUSER7_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser7::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER7_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser7::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER7_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER7 to value 0"]
impl crate :: Resettable for ASYNCUSER7_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER8 (rw) register accessor: an alias for `Reg<ASYNCUSER8_SPEC>`"]
pub type ASYNCUSER8 = crate :: Reg < asyncuser8 :: ASYNCUSER8_SPEC > ; # [doc = "Asynchronous User Ch 8 Input Selection - Event Out 0"]
pub mod asyncuser8 { # [doc = "Register `ASYNCUSER8` reader"]
pub struct R (crate :: R < ASYNCUSER8_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER8_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER8_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER8` writer"]
pub struct W (crate :: W < ASYNCUSER8_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER8_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER8_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER8` reader - Asynchronous User Ch 8 Input Selection - Event Out 0"]
pub type ASYNCUSER8_R = crate :: FieldReader < u8 , ASYNCUSER8_A > ; # [doc = "Asynchronous User Ch 8 Input Selection - Event Out 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER8_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER8_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER8_A) -> Self { variant as _ } } impl ASYNCUSER8_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER8_A > { match self . bits { 0 => Some (ASYNCUSER8_A :: OFF) , 1 => Some (ASYNCUSER8_A :: SYNCCH0) , 2 => Some (ASYNCUSER8_A :: SYNCCH1) , 3 => Some (ASYNCUSER8_A :: ASYNCCH0) , 4 => Some (ASYNCUSER8_A :: ASYNCCH1) , 5 => Some (ASYNCUSER8_A :: ASYNCCH2) , 6 => Some (ASYNCUSER8_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER8_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER8_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER8_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER8_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER8_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER8_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER8_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER8` writer - Asynchronous User Ch 8 Input Selection - Event Out 0"]
pub type ASYNCUSER8_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER8_SPEC , u8 , ASYNCUSER8_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER8_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER8_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER8_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER8_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER8_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER8_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER8_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER8_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 8 Input Selection - Event Out 0"]
# [inline (always)]
pub fn asyncuser8 (& self) -> ASYNCUSER8_R { ASYNCUSER8_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 8 Input Selection - Event Out 0"]
# [inline (always)]
# [must_use]
pub fn asyncuser8 (& mut self) -> ASYNCUSER8_W < 0 > { ASYNCUSER8_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 8 Input Selection - Event Out 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser8](index.html) module"]
pub struct ASYNCUSER8_SPEC ; impl crate :: RegisterSpec for ASYNCUSER8_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser8::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER8_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser8::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER8_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER8 to value 0"]
impl crate :: Resettable for ASYNCUSER8_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ASYNCUSER9 (rw) register accessor: an alias for `Reg<ASYNCUSER9_SPEC>`"]
pub type ASYNCUSER9 = crate :: Reg < asyncuser9 :: ASYNCUSER9_SPEC > ; # [doc = "Asynchronous User Ch 9 Input Selection - Event Out 1"]
pub mod asyncuser9 { # [doc = "Register `ASYNCUSER9` reader"]
pub struct R (crate :: R < ASYNCUSER9_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASYNCUSER9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASYNCUSER9_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASYNCUSER9_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASYNCUSER9` writer"]
pub struct W (crate :: W < ASYNCUSER9_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASYNCUSER9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASYNCUSER9_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASYNCUSER9_SPEC >) -> Self { W (writer) } } # [doc = "Field `ASYNCUSER9` reader - Asynchronous User Ch 9 Input Selection - Event Out 1"]
pub type ASYNCUSER9_R = crate :: FieldReader < u8 , ASYNCUSER9_A > ; # [doc = "Asynchronous User Ch 9 Input Selection - Event Out 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ASYNCUSER9_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , # [doc = "3: Asynchronous Event Channel 0"]
ASYNCCH0 = 3 , # [doc = "4: Asynchronous Event Channel 1"]
ASYNCCH1 = 4 , # [doc = "5: Asynchronous Event Channel 2"]
ASYNCCH2 = 5 , # [doc = "6: Asynchronous Event Channel 3"]
ASYNCCH3 = 6 , } impl From < ASYNCUSER9_A > for u8 { # [inline (always)]
fn from (variant : ASYNCUSER9_A) -> Self { variant as _ } } impl ASYNCUSER9_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ASYNCUSER9_A > { match self . bits { 0 => Some (ASYNCUSER9_A :: OFF) , 1 => Some (ASYNCUSER9_A :: SYNCCH0) , 2 => Some (ASYNCUSER9_A :: SYNCCH1) , 3 => Some (ASYNCUSER9_A :: ASYNCCH0) , 4 => Some (ASYNCUSER9_A :: ASYNCCH1) , 5 => Some (ASYNCUSER9_A :: ASYNCCH2) , 6 => Some (ASYNCUSER9_A :: ASYNCCH3) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ASYNCUSER9_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == ASYNCUSER9_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == ASYNCUSER9_A :: SYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH0`"]
# [inline (always)]
pub fn is_asyncch0 (& self) -> bool { * self == ASYNCUSER9_A :: ASYNCCH0 } # [doc = "Checks if the value of the field is `ASYNCCH1`"]
# [inline (always)]
pub fn is_asyncch1 (& self) -> bool { * self == ASYNCUSER9_A :: ASYNCCH1 } # [doc = "Checks if the value of the field is `ASYNCCH2`"]
# [inline (always)]
pub fn is_asyncch2 (& self) -> bool { * self == ASYNCUSER9_A :: ASYNCCH2 } # [doc = "Checks if the value of the field is `ASYNCCH3`"]
# [inline (always)]
pub fn is_asyncch3 (& self) -> bool { * self == ASYNCUSER9_A :: ASYNCCH3 } } # [doc = "Field `ASYNCUSER9` writer - Asynchronous User Ch 9 Input Selection - Event Out 1"]
pub type ASYNCUSER9_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ASYNCUSER9_SPEC , u8 , ASYNCUSER9_A , 8 , O > ; impl < 'a , const O : u8 > ASYNCUSER9_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ASYNCUSER9_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER9_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER9_A :: SYNCCH1) } # [doc = "Asynchronous Event Channel 0"]
# [inline (always)]
pub fn asyncch0 (self) -> & 'a mut W { self . variant (ASYNCUSER9_A :: ASYNCCH0) } # [doc = "Asynchronous Event Channel 1"]
# [inline (always)]
pub fn asyncch1 (self) -> & 'a mut W { self . variant (ASYNCUSER9_A :: ASYNCCH1) } # [doc = "Asynchronous Event Channel 2"]
# [inline (always)]
pub fn asyncch2 (self) -> & 'a mut W { self . variant (ASYNCUSER9_A :: ASYNCCH2) } # [doc = "Asynchronous Event Channel 3"]
# [inline (always)]
pub fn asyncch3 (self) -> & 'a mut W { self . variant (ASYNCUSER9_A :: ASYNCCH3) } } impl R { # [doc = "Bits 0:7 - Asynchronous User Ch 9 Input Selection - Event Out 1"]
# [inline (always)]
pub fn asyncuser9 (& self) -> ASYNCUSER9_R { ASYNCUSER9_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Asynchronous User Ch 9 Input Selection - Event Out 1"]
# [inline (always)]
# [must_use]
pub fn asyncuser9 (& mut self) -> ASYNCUSER9_W < 0 > { ASYNCUSER9_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous User Ch 9 Input Selection - Event Out 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [asyncuser9](index.html) module"]
pub struct ASYNCUSER9_SPEC ; impl crate :: RegisterSpec for ASYNCUSER9_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [asyncuser9::R](R) reader structure"]
impl crate :: Readable for ASYNCUSER9_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [asyncuser9::W](W) writer structure"]
impl crate :: Writable for ASYNCUSER9_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASYNCUSER9 to value 0"]
impl crate :: Resettable for ASYNCUSER9_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYNCCH0 (rw) register accessor: an alias for `Reg<SYNCCH0_SPEC>`"]
pub type SYNCCH0 = crate :: Reg < syncch0 :: SYNCCH0_SPEC > ; # [doc = "Synchronous Channel 0 Generator Selection"]
pub mod syncch0 { # [doc = "Register `SYNCCH0` reader"]
pub struct R (crate :: R < SYNCCH0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCCH0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCCH0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCCH0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYNCCH0` writer"]
pub struct W (crate :: W < SYNCCH0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYNCCH0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYNCCH0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYNCCH0_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCCH0` reader - Synchronous Channel 0 Generator Selection"]
pub type SYNCCH0_R = crate :: FieldReader < u8 , SYNCCH0_A > ; # [doc = "Synchronous Channel 0 Generator Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SYNCCH0_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Timer/Counter B0"]
TCB0 = 1 , # [doc = "2: Timer/Counter A0 overflow"]
TCA0_OVF_LUNF = 2 , # [doc = "3: Timer/Counter A0 underflow high byte (split mode)"]
TCA0_HUNF = 3 , # [doc = "4: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 4 , # [doc = "5: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 5 , # [doc = "6: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 6 , # [doc = "7: Synchronous Event from Pin PC0"]
PORTC_PIN0 = 7 , # [doc = "8: Synchronous Event from Pin PC1"]
PORTC_PIN1 = 8 , # [doc = "9: Synchronous Event from Pin PC2"]
PORTC_PIN2 = 9 , # [doc = "10: Synchronous Event from Pin PC3"]
PORTC_PIN3 = 10 , # [doc = "11: Synchronous Event from Pin PC4"]
PORTC_PIN4 = 11 , # [doc = "12: Synchronous Event from Pin PC5"]
PORTC_PIN5 = 12 , # [doc = "13: Synchronous Event from Pin PA0"]
PORTA_PIN0 = 13 , # [doc = "14: Synchronous Event from Pin PA1"]
PORTA_PIN1 = 14 , # [doc = "15: Synchronous Event from Pin PA2"]
PORTA_PIN2 = 15 , # [doc = "16: Synchronous Event from Pin PA3"]
PORTA_PIN3 = 16 , # [doc = "17: Synchronous Event from Pin PA4"]
PORTA_PIN4 = 17 , # [doc = "18: Synchronous Event from Pin PA5"]
PORTA_PIN5 = 18 , # [doc = "19: Synchronous Event from Pin PA6"]
PORTA_PIN6 = 19 , # [doc = "20: Synchronous Event from Pin PA7"]
PORTA_PIN7 = 20 , } impl From < SYNCCH0_A > for u8 { # [inline (always)]
fn from (variant : SYNCCH0_A) -> Self { variant as _ } } impl SYNCCH0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SYNCCH0_A > { match self . bits { 0 => Some (SYNCCH0_A :: OFF) , 1 => Some (SYNCCH0_A :: TCB0) , 2 => Some (SYNCCH0_A :: TCA0_OVF_LUNF) , 3 => Some (SYNCCH0_A :: TCA0_HUNF) , 4 => Some (SYNCCH0_A :: TCA0_CMP0) , 5 => Some (SYNCCH0_A :: TCA0_CMP1) , 6 => Some (SYNCCH0_A :: TCA0_CMP2) , 7 => Some (SYNCCH0_A :: PORTC_PIN0) , 8 => Some (SYNCCH0_A :: PORTC_PIN1) , 9 => Some (SYNCCH0_A :: PORTC_PIN2) , 10 => Some (SYNCCH0_A :: PORTC_PIN3) , 11 => Some (SYNCCH0_A :: PORTC_PIN4) , 12 => Some (SYNCCH0_A :: PORTC_PIN5) , 13 => Some (SYNCCH0_A :: PORTA_PIN0) , 14 => Some (SYNCCH0_A :: PORTA_PIN1) , 15 => Some (SYNCCH0_A :: PORTA_PIN2) , 16 => Some (SYNCCH0_A :: PORTA_PIN3) , 17 => Some (SYNCCH0_A :: PORTA_PIN4) , 18 => Some (SYNCCH0_A :: PORTA_PIN5) , 19 => Some (SYNCCH0_A :: PORTA_PIN6) , 20 => Some (SYNCCH0_A :: PORTA_PIN7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SYNCCH0_A :: OFF } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == SYNCCH0_A :: TCB0 } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == SYNCCH0_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == SYNCCH0_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == SYNCCH0_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == SYNCCH0_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == SYNCCH0_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == SYNCCH0_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == SYNCCH0_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == SYNCCH0_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == SYNCCH0_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == SYNCCH0_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == SYNCCH0_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == SYNCCH0_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == SYNCCH0_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == SYNCCH0_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == SYNCCH0_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == SYNCCH0_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == SYNCCH0_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == SYNCCH0_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == SYNCCH0_A :: PORTA_PIN7 } } # [doc = "Field `SYNCCH0` writer - Synchronous Channel 0 Generator Selection"]
pub type SYNCCH0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SYNCCH0_SPEC , u8 , SYNCCH0_A , 8 , O > ; impl < 'a , const O : u8 > SYNCCH0_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SYNCCH0_A :: OFF) } # [doc = "Timer/Counter B0"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: TCB0) } # [doc = "Timer/Counter A0 overflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (SYNCCH0_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 underflow high byte (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (SYNCCH0_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: TCA0_CMP2) } # [doc = "Synchronous Event from Pin PC0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTC_PIN0) } # [doc = "Synchronous Event from Pin PC1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTC_PIN1) } # [doc = "Synchronous Event from Pin PC2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTC_PIN2) } # [doc = "Synchronous Event from Pin PC3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTC_PIN3) } # [doc = "Synchronous Event from Pin PC4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTC_PIN4) } # [doc = "Synchronous Event from Pin PC5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTC_PIN5) } # [doc = "Synchronous Event from Pin PA0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTA_PIN0) } # [doc = "Synchronous Event from Pin PA1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTA_PIN1) } # [doc = "Synchronous Event from Pin PA2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTA_PIN2) } # [doc = "Synchronous Event from Pin PA3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTA_PIN3) } # [doc = "Synchronous Event from Pin PA4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTA_PIN4) } # [doc = "Synchronous Event from Pin PA5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTA_PIN5) } # [doc = "Synchronous Event from Pin PA6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTA_PIN6) } # [doc = "Synchronous Event from Pin PA7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (SYNCCH0_A :: PORTA_PIN7) } } impl R { # [doc = "Bits 0:7 - Synchronous Channel 0 Generator Selection"]
# [inline (always)]
pub fn syncch0 (& self) -> SYNCCH0_R { SYNCCH0_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Synchronous Channel 0 Generator Selection"]
# [inline (always)]
# [must_use]
pub fn syncch0 (& mut self) -> SYNCCH0_W < 0 > { SYNCCH0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Synchronous Channel 0 Generator Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncch0](index.html) module"]
pub struct SYNCCH0_SPEC ; impl crate :: RegisterSpec for SYNCCH0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syncch0::R](R) reader structure"]
impl crate :: Readable for SYNCCH0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syncch0::W](W) writer structure"]
impl crate :: Writable for SYNCCH0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYNCCH0 to value 0"]
impl crate :: Resettable for SYNCCH0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYNCCH1 (rw) register accessor: an alias for `Reg<SYNCCH1_SPEC>`"]
pub type SYNCCH1 = crate :: Reg < syncch1 :: SYNCCH1_SPEC > ; # [doc = "Synchronous Channel 1 Generator Selection"]
pub mod syncch1 { # [doc = "Register `SYNCCH1` reader"]
pub struct R (crate :: R < SYNCCH1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCCH1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCCH1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCCH1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYNCCH1` writer"]
pub struct W (crate :: W < SYNCCH1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYNCCH1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYNCCH1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYNCCH1_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCCH1` reader - Synchronous Channel 1 Generator Selection"]
pub type SYNCCH1_R = crate :: FieldReader < u8 , SYNCCH1_A > ; # [doc = "Synchronous Channel 1 Generator Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SYNCCH1_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Timer/Counter B0"]
TCB0 = 1 , # [doc = "2: Timer/Counter A0 overflow"]
TCA0_OVF_LUNF = 2 , # [doc = "3: Timer/Counter A0 underflow high byte (split mode)"]
TCA0_HUNF = 3 , # [doc = "4: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 4 , # [doc = "5: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 5 , # [doc = "6: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 6 , # [doc = "8: Synchronous Event from Pin PB0"]
PORTB_PIN0 = 8 , # [doc = "9: Synchronous Event from Pin PB1"]
PORTB_PIN1 = 9 , # [doc = "10: Synchronous Event from Pin PB2"]
PORTB_PIN2 = 10 , # [doc = "11: Synchronous Event from Pin PB3"]
PORTB_PIN3 = 11 , # [doc = "12: Synchronous Event from Pin PB4"]
PORTB_PIN4 = 12 , # [doc = "13: Synchronous Event from Pin PB5"]
PORTB_PIN5 = 13 , # [doc = "14: Synchronous Event from Pin PB6"]
PORTB_PIN6 = 14 , # [doc = "15: Synchronous Event from Pin PB7"]
PORTB_PIN7 = 15 , } impl From < SYNCCH1_A > for u8 { # [inline (always)]
fn from (variant : SYNCCH1_A) -> Self { variant as _ } } impl SYNCCH1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SYNCCH1_A > { match self . bits { 0 => Some (SYNCCH1_A :: OFF) , 1 => Some (SYNCCH1_A :: TCB0) , 2 => Some (SYNCCH1_A :: TCA0_OVF_LUNF) , 3 => Some (SYNCCH1_A :: TCA0_HUNF) , 4 => Some (SYNCCH1_A :: TCA0_CMP0) , 5 => Some (SYNCCH1_A :: TCA0_CMP1) , 6 => Some (SYNCCH1_A :: TCA0_CMP2) , 8 => Some (SYNCCH1_A :: PORTB_PIN0) , 9 => Some (SYNCCH1_A :: PORTB_PIN1) , 10 => Some (SYNCCH1_A :: PORTB_PIN2) , 11 => Some (SYNCCH1_A :: PORTB_PIN3) , 12 => Some (SYNCCH1_A :: PORTB_PIN4) , 13 => Some (SYNCCH1_A :: PORTB_PIN5) , 14 => Some (SYNCCH1_A :: PORTB_PIN6) , 15 => Some (SYNCCH1_A :: PORTB_PIN7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SYNCCH1_A :: OFF } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == SYNCCH1_A :: TCB0 } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == SYNCCH1_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == SYNCCH1_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == SYNCCH1_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == SYNCCH1_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == SYNCCH1_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == SYNCCH1_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == SYNCCH1_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == SYNCCH1_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == SYNCCH1_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == SYNCCH1_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == SYNCCH1_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == SYNCCH1_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == SYNCCH1_A :: PORTB_PIN7 } } # [doc = "Field `SYNCCH1` writer - Synchronous Channel 1 Generator Selection"]
pub type SYNCCH1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SYNCCH1_SPEC , u8 , SYNCCH1_A , 8 , O > ; impl < 'a , const O : u8 > SYNCCH1_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SYNCCH1_A :: OFF) } # [doc = "Timer/Counter B0"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: TCB0) } # [doc = "Timer/Counter A0 overflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (SYNCCH1_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 underflow high byte (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (SYNCCH1_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: TCA0_CMP2) } # [doc = "Synchronous Event from Pin PB0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: PORTB_PIN0) } # [doc = "Synchronous Event from Pin PB1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: PORTB_PIN1) } # [doc = "Synchronous Event from Pin PB2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: PORTB_PIN2) } # [doc = "Synchronous Event from Pin PB3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: PORTB_PIN3) } # [doc = "Synchronous Event from Pin PB4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: PORTB_PIN4) } # [doc = "Synchronous Event from Pin PB5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: PORTB_PIN5) } # [doc = "Synchronous Event from Pin PB6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: PORTB_PIN6) } # [doc = "Synchronous Event from Pin PB7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (SYNCCH1_A :: PORTB_PIN7) } } impl R { # [doc = "Bits 0:7 - Synchronous Channel 1 Generator Selection"]
# [inline (always)]
pub fn syncch1 (& self) -> SYNCCH1_R { SYNCCH1_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Synchronous Channel 1 Generator Selection"]
# [inline (always)]
# [must_use]
pub fn syncch1 (& mut self) -> SYNCCH1_W < 0 > { SYNCCH1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Synchronous Channel 1 Generator Selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncch1](index.html) module"]
pub struct SYNCCH1_SPEC ; impl crate :: RegisterSpec for SYNCCH1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syncch1::R](R) reader structure"]
impl crate :: Readable for SYNCCH1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syncch1::W](W) writer structure"]
impl crate :: Writable for SYNCCH1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYNCCH1 to value 0"]
impl crate :: Resettable for SYNCCH1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYNCSTROBE (w) register accessor: an alias for `Reg<SYNCSTROBE_SPEC>`"]
pub type SYNCSTROBE = crate :: Reg < syncstrobe :: SYNCSTROBE_SPEC > ; # [doc = "Synchronous Channel Strobe"]
pub mod syncstrobe { # [doc = "Register `SYNCSTROBE` writer"]
pub struct W (crate :: W < SYNCSTROBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYNCSTROBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYNCSTROBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYNCSTROBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Synchronous Channel Strobe\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncstrobe](index.html) module"]
pub struct SYNCSTROBE_SPEC ; impl crate :: RegisterSpec for SYNCSTROBE_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [syncstrobe::W](W) writer structure"]
impl crate :: Writable for SYNCSTROBE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYNCSTROBE to value 0"]
impl crate :: Resettable for SYNCSTROBE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYNCUSER0 (rw) register accessor: an alias for `Reg<SYNCUSER0_SPEC>`"]
pub type SYNCUSER0 = crate :: Reg < syncuser0 :: SYNCUSER0_SPEC > ; # [doc = "Synchronous User Ch 0 Input Selection - TCA0"]
pub mod syncuser0 { # [doc = "Register `SYNCUSER0` reader"]
pub struct R (crate :: R < SYNCUSER0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCUSER0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCUSER0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCUSER0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYNCUSER0` writer"]
pub struct W (crate :: W < SYNCUSER0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYNCUSER0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYNCUSER0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYNCUSER0_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCUSER0` reader - Synchronous User Ch 0 Input Selection - TCA0"]
pub type SYNCUSER0_R = crate :: FieldReader < u8 , SYNCUSER0_A > ; # [doc = "Synchronous User Ch 0 Input Selection - TCA0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SYNCUSER0_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , } impl From < SYNCUSER0_A > for u8 { # [inline (always)]
fn from (variant : SYNCUSER0_A) -> Self { variant as _ } } impl SYNCUSER0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SYNCUSER0_A > { match self . bits { 0 => Some (SYNCUSER0_A :: OFF) , 1 => Some (SYNCUSER0_A :: SYNCCH0) , 2 => Some (SYNCUSER0_A :: SYNCCH1) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SYNCUSER0_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == SYNCUSER0_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == SYNCUSER0_A :: SYNCCH1 } } # [doc = "Field `SYNCUSER0` writer - Synchronous User Ch 0 Input Selection - TCA0"]
pub type SYNCUSER0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SYNCUSER0_SPEC , u8 , SYNCUSER0_A , 8 , O > ; impl < 'a , const O : u8 > SYNCUSER0_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SYNCUSER0_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (SYNCUSER0_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (SYNCUSER0_A :: SYNCCH1) } } impl R { # [doc = "Bits 0:7 - Synchronous User Ch 0 Input Selection - TCA0"]
# [inline (always)]
pub fn syncuser0 (& self) -> SYNCUSER0_R { SYNCUSER0_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Synchronous User Ch 0 Input Selection - TCA0"]
# [inline (always)]
# [must_use]
pub fn syncuser0 (& mut self) -> SYNCUSER0_W < 0 > { SYNCUSER0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Synchronous User Ch 0 Input Selection - TCA0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncuser0](index.html) module"]
pub struct SYNCUSER0_SPEC ; impl crate :: RegisterSpec for SYNCUSER0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syncuser0::R](R) reader structure"]
impl crate :: Readable for SYNCUSER0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syncuser0::W](W) writer structure"]
impl crate :: Writable for SYNCUSER0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYNCUSER0 to value 0"]
impl crate :: Resettable for SYNCUSER0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYNCUSER1 (rw) register accessor: an alias for `Reg<SYNCUSER1_SPEC>`"]
pub type SYNCUSER1 = crate :: Reg < syncuser1 :: SYNCUSER1_SPEC > ; # [doc = "Synchronous User Ch 1 Input Selection - USART0"]
pub mod syncuser1 { # [doc = "Register `SYNCUSER1` reader"]
pub struct R (crate :: R < SYNCUSER1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCUSER1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCUSER1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCUSER1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYNCUSER1` writer"]
pub struct W (crate :: W < SYNCUSER1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYNCUSER1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYNCUSER1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYNCUSER1_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCUSER1` reader - Synchronous User Ch 1 Input Selection - USART0"]
pub type SYNCUSER1_R = crate :: FieldReader < u8 , SYNCUSER1_A > ; # [doc = "Synchronous User Ch 1 Input Selection - USART0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SYNCUSER1_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Synchronous Event Channel 0"]
SYNCCH0 = 1 , # [doc = "2: Synchronous Event Channel 1"]
SYNCCH1 = 2 , } impl From < SYNCUSER1_A > for u8 { # [inline (always)]
fn from (variant : SYNCUSER1_A) -> Self { variant as _ } } impl SYNCUSER1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SYNCUSER1_A > { match self . bits { 0 => Some (SYNCUSER1_A :: OFF) , 1 => Some (SYNCUSER1_A :: SYNCCH0) , 2 => Some (SYNCUSER1_A :: SYNCCH1) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SYNCUSER1_A :: OFF } # [doc = "Checks if the value of the field is `SYNCCH0`"]
# [inline (always)]
pub fn is_syncch0 (& self) -> bool { * self == SYNCUSER1_A :: SYNCCH0 } # [doc = "Checks if the value of the field is `SYNCCH1`"]
# [inline (always)]
pub fn is_syncch1 (& self) -> bool { * self == SYNCUSER1_A :: SYNCCH1 } } # [doc = "Field `SYNCUSER1` writer - Synchronous User Ch 1 Input Selection - USART0"]
pub type SYNCUSER1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SYNCUSER1_SPEC , u8 , SYNCUSER1_A , 8 , O > ; impl < 'a , const O : u8 > SYNCUSER1_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SYNCUSER1_A :: OFF) } # [doc = "Synchronous Event Channel 0"]
# [inline (always)]
pub fn syncch0 (self) -> & 'a mut W { self . variant (SYNCUSER1_A :: SYNCCH0) } # [doc = "Synchronous Event Channel 1"]
# [inline (always)]
pub fn syncch1 (self) -> & 'a mut W { self . variant (SYNCUSER1_A :: SYNCCH1) } } impl R { # [doc = "Bits 0:7 - Synchronous User Ch 1 Input Selection - USART0"]
# [inline (always)]
pub fn syncuser1 (& self) -> SYNCUSER1_R { SYNCUSER1_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Synchronous User Ch 1 Input Selection - USART0"]
# [inline (always)]
# [must_use]
pub fn syncuser1 (& mut self) -> SYNCUSER1_W < 0 > { SYNCUSER1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Synchronous User Ch 1 Input Selection - USART0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncuser1](index.html) module"]
pub struct SYNCUSER1_SPEC ; impl crate :: RegisterSpec for SYNCUSER1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syncuser1::R](R) reader structure"]
impl crate :: Readable for SYNCUSER1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syncuser1::W](W) writer structure"]
impl crate :: Writable for SYNCUSER1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYNCUSER1 to value 0"]
impl crate :: Resettable for SYNCUSER1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Fuses"]
pub struct FUSE { _marker : PhantomData < * const () > } unsafe impl Send for FUSE { } impl FUSE { # [doc = r"Pointer to the register block"]
pub const PTR : * const fuse :: RegisterBlock = 0x1280 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const fuse :: RegisterBlock { Self :: PTR } } impl Deref for FUSE { type Target = fuse :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FUSE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FUSE") . finish () } } # [doc = "Fuses"]
pub mod fuse { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Watchdog Configuration"]
pub wdtcfg : WDTCFG , # [doc = "0x01 - BOD Configuration"]
pub bodcfg : BODCFG , # [doc = "0x02 - Oscillator Configuration"]
pub osccfg : OSCCFG , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - TCD0 Configuration"]
pub tcd0cfg : TCD0CFG , # [doc = "0x05 - System Configuration 0"]
pub syscfg0 : SYSCFG0 , # [doc = "0x06 - System Configuration 1"]
pub syscfg1 : SYSCFG1 , # [doc = "0x07 - Application Code Section End"]
pub append : APPEND , # [doc = "0x08 - Boot Section End"]
pub bootend : BOOTEND , } # [doc = "APPEND (rw) register accessor: an alias for `Reg<APPEND_SPEC>`"]
pub type APPEND = crate :: Reg < append :: APPEND_SPEC > ; # [doc = "Application Code Section End"]
pub mod append { # [doc = "Register `APPEND` reader"]
pub struct R (crate :: R < APPEND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < APPEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < APPEND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < APPEND_SPEC >) -> Self { R (reader) } } # [doc = "Register `APPEND` writer"]
pub struct W (crate :: W < APPEND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < APPEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < APPEND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < APPEND_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Application Code Section End\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [append](index.html) module"]
pub struct APPEND_SPEC ; impl crate :: RegisterSpec for APPEND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [append::R](R) reader structure"]
impl crate :: Readable for APPEND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [append::W](W) writer structure"]
impl crate :: Writable for APPEND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets APPEND to value 0"]
impl crate :: Resettable for APPEND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BODCFG (rw) register accessor: an alias for `Reg<BODCFG_SPEC>`"]
pub type BODCFG = crate :: Reg < bodcfg :: BODCFG_SPEC > ; # [doc = "BOD Configuration"]
pub mod bodcfg { # [doc = "Register `BODCFG` reader"]
pub struct R (crate :: R < BODCFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BODCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BODCFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BODCFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `BODCFG` writer"]
pub struct W (crate :: W < BODCFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BODCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BODCFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BODCFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `SLEEP` reader - BOD Operation in Sleep Mode"]
pub type SLEEP_R = crate :: FieldReader < u8 , SLEEP_A > ; # [doc = "BOD Operation in Sleep Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SLEEP_A { # [doc = "0: Disabled"]
DIS = 0 , # [doc = "1: Enabled"]
ENABLED = 1 , # [doc = "2: Sampled"]
SAMPLED = 2 , } impl From < SLEEP_A > for u8 { # [inline (always)]
fn from (variant : SLEEP_A) -> Self { variant as _ } } impl SLEEP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SLEEP_A > { match self . bits { 0 => Some (SLEEP_A :: DIS) , 1 => Some (SLEEP_A :: ENABLED) , 2 => Some (SLEEP_A :: SAMPLED) , _ => None , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == SLEEP_A :: DIS } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * self == SLEEP_A :: ENABLED } # [doc = "Checks if the value of the field is `SAMPLED`"]
# [inline (always)]
pub fn is_sampled (& self) -> bool { * self == SLEEP_A :: SAMPLED } } # [doc = "Field `SLEEP` writer - BOD Operation in Sleep Mode"]
pub type SLEEP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , BODCFG_SPEC , u8 , SLEEP_A , 2 , O > ; impl < 'a , const O : u8 > SLEEP_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (SLEEP_A :: DIS) } # [doc = "Enabled"]
# [inline (always)]
pub fn enabled (self) -> & 'a mut W { self . variant (SLEEP_A :: ENABLED) } # [doc = "Sampled"]
# [inline (always)]
pub fn sampled (self) -> & 'a mut W { self . variant (SLEEP_A :: SAMPLED) } } # [doc = "Field `ACTIVE` reader - BOD Operation in Active Mode"]
pub type ACTIVE_R = crate :: FieldReader < u8 , ACTIVE_A > ; # [doc = "BOD Operation in Active Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ACTIVE_A { # [doc = "0: Disabled"]
DIS = 0 , # [doc = "1: Enabled"]
ENABLED = 1 , # [doc = "2: Sampled"]
SAMPLED = 2 , # [doc = "3: Enabled with wake-up halted until BOD is ready"]
ENWAKE = 3 , } impl From < ACTIVE_A > for u8 { # [inline (always)]
fn from (variant : ACTIVE_A) -> Self { variant as _ } } impl ACTIVE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACTIVE_A { match self . bits { 0 => ACTIVE_A :: DIS , 1 => ACTIVE_A :: ENABLED , 2 => ACTIVE_A :: SAMPLED , 3 => ACTIVE_A :: ENWAKE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == ACTIVE_A :: DIS } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * self == ACTIVE_A :: ENABLED } # [doc = "Checks if the value of the field is `SAMPLED`"]
# [inline (always)]
pub fn is_sampled (& self) -> bool { * self == ACTIVE_A :: SAMPLED } # [doc = "Checks if the value of the field is `ENWAKE`"]
# [inline (always)]
pub fn is_enwake (& self) -> bool { * self == ACTIVE_A :: ENWAKE } } # [doc = "Field `ACTIVE` writer - BOD Operation in Active Mode"]
pub type ACTIVE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BODCFG_SPEC , u8 , ACTIVE_A , 2 , O > ; impl < 'a , const O : u8 > ACTIVE_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (ACTIVE_A :: DIS) } # [doc = "Enabled"]
# [inline (always)]
pub fn enabled (self) -> & 'a mut W { self . variant (ACTIVE_A :: ENABLED) } # [doc = "Sampled"]
# [inline (always)]
pub fn sampled (self) -> & 'a mut W { self . variant (ACTIVE_A :: SAMPLED) } # [doc = "Enabled with wake-up halted until BOD is ready"]
# [inline (always)]
pub fn enwake (self) -> & 'a mut W { self . variant (ACTIVE_A :: ENWAKE) } } # [doc = "Field `SAMPFREQ` reader - BOD Sample Frequency"]
pub type SAMPFREQ_R = crate :: BitReader < SAMPFREQ_A > ; # [doc = "BOD Sample Frequency\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SAMPFREQ_A { # [doc = "0: 1kHz sampling frequency"]
_1KHZ = 0 , # [doc = "1: 125Hz sampling frequency"]
_125HZ = 1 , } impl From < SAMPFREQ_A > for bool { # [inline (always)]
fn from (variant : SAMPFREQ_A) -> Self { variant as u8 != 0 } } impl SAMPFREQ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SAMPFREQ_A { match self . bits { false => SAMPFREQ_A :: _1KHZ , true => SAMPFREQ_A :: _125HZ , } } # [doc = "Checks if the value of the field is `_1KHZ`"]
# [inline (always)]
pub fn is_1khz (& self) -> bool { * self == SAMPFREQ_A :: _1KHZ } # [doc = "Checks if the value of the field is `_125HZ`"]
# [inline (always)]
pub fn is_125hz (& self) -> bool { * self == SAMPFREQ_A :: _125HZ } } # [doc = "Field `SAMPFREQ` writer - BOD Sample Frequency"]
pub type SAMPFREQ_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , BODCFG_SPEC , SAMPFREQ_A , O > ; impl < 'a , const O : u8 > SAMPFREQ_W < 'a , O > { # [doc = "1kHz sampling frequency"]
# [inline (always)]
pub fn _1khz (self) -> & 'a mut W { self . variant (SAMPFREQ_A :: _1KHZ) } # [doc = "125Hz sampling frequency"]
# [inline (always)]
pub fn _125hz (self) -> & 'a mut W { self . variant (SAMPFREQ_A :: _125HZ) } } # [doc = "Field `LVL` reader - BOD Level"]
pub type LVL_R = crate :: FieldReader < u8 , LVL_A > ; # [doc = "BOD Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LVL_A { # [doc = "0: 1.8 V"]
BODLEVEL0 = 0 , # [doc = "2: 2.6 V"]
BODLEVEL2 = 2 , # [doc = "7: 4.2 V"]
BODLEVEL7 = 7 , } impl From < LVL_A > for u8 { # [inline (always)]
fn from (variant : LVL_A) -> Self { variant as _ } } impl LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LVL_A > { match self . bits { 0 => Some (LVL_A :: BODLEVEL0) , 2 => Some (LVL_A :: BODLEVEL2) , 7 => Some (LVL_A :: BODLEVEL7) , _ => None , } } # [doc = "Checks if the value of the field is `BODLEVEL0`"]
# [inline (always)]
pub fn is_bodlevel0 (& self) -> bool { * self == LVL_A :: BODLEVEL0 } # [doc = "Checks if the value of the field is `BODLEVEL2`"]
# [inline (always)]
pub fn is_bodlevel2 (& self) -> bool { * self == LVL_A :: BODLEVEL2 } # [doc = "Checks if the value of the field is `BODLEVEL7`"]
# [inline (always)]
pub fn is_bodlevel7 (& self) -> bool { * self == LVL_A :: BODLEVEL7 } } # [doc = "Field `LVL` writer - BOD Level"]
pub type LVL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , BODCFG_SPEC , u8 , LVL_A , 3 , O > ; impl < 'a , const O : u8 > LVL_W < 'a , O > { # [doc = "1.8 V"]
# [inline (always)]
pub fn bodlevel0 (self) -> & 'a mut W { self . variant (LVL_A :: BODLEVEL0) } # [doc = "2.6 V"]
# [inline (always)]
pub fn bodlevel2 (self) -> & 'a mut W { self . variant (LVL_A :: BODLEVEL2) } # [doc = "4.2 V"]
# [inline (always)]
pub fn bodlevel7 (self) -> & 'a mut W { self . variant (LVL_A :: BODLEVEL7) } } impl R { # [doc = "Bits 0:1 - BOD Operation in Sleep Mode"]
# [inline (always)]
pub fn sleep (& self) -> SLEEP_R { SLEEP_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - BOD Operation in Active Mode"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - BOD Sample Frequency"]
# [inline (always)]
pub fn sampfreq (& self) -> SAMPFREQ_R { SAMPFREQ_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - BOD Level"]
# [inline (always)]
pub fn lvl (& self) -> LVL_R { LVL_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:1 - BOD Operation in Sleep Mode"]
# [inline (always)]
# [must_use]
pub fn sleep (& mut self) -> SLEEP_W < 0 > { SLEEP_W :: new (self) } # [doc = "Bits 2:3 - BOD Operation in Active Mode"]
# [inline (always)]
# [must_use]
pub fn active (& mut self) -> ACTIVE_W < 2 > { ACTIVE_W :: new (self) } # [doc = "Bit 4 - BOD Sample Frequency"]
# [inline (always)]
# [must_use]
pub fn sampfreq (& mut self) -> SAMPFREQ_W < 4 > { SAMPFREQ_W :: new (self) } # [doc = "Bits 5:7 - BOD Level"]
# [inline (always)]
# [must_use]
pub fn lvl (& mut self) -> LVL_W < 5 > { LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "BOD Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bodcfg](index.html) module"]
pub struct BODCFG_SPEC ; impl crate :: RegisterSpec for BODCFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [bodcfg::R](R) reader structure"]
impl crate :: Readable for BODCFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bodcfg::W](W) writer structure"]
impl crate :: Writable for BODCFG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BODCFG to value 0"]
impl crate :: Resettable for BODCFG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BOOTEND (rw) register accessor: an alias for `Reg<BOOTEND_SPEC>`"]
pub type BOOTEND = crate :: Reg < bootend :: BOOTEND_SPEC > ; # [doc = "Boot Section End"]
pub mod bootend { # [doc = "Register `BOOTEND` reader"]
pub struct R (crate :: R < BOOTEND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BOOTEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BOOTEND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BOOTEND_SPEC >) -> Self { R (reader) } } # [doc = "Register `BOOTEND` writer"]
pub struct W (crate :: W < BOOTEND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BOOTEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BOOTEND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BOOTEND_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Boot Section End\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bootend](index.html) module"]
pub struct BOOTEND_SPEC ; impl crate :: RegisterSpec for BOOTEND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [bootend::R](R) reader structure"]
impl crate :: Readable for BOOTEND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bootend::W](W) writer structure"]
impl crate :: Writable for BOOTEND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BOOTEND to value 0"]
impl crate :: Resettable for BOOTEND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCFG (rw) register accessor: an alias for `Reg<OSCCFG_SPEC>`"]
pub type OSCCFG = crate :: Reg < osccfg :: OSCCFG_SPEC > ; # [doc = "Oscillator Configuration"]
pub mod osccfg { # [doc = "Register `OSCCFG` reader"]
pub struct R (crate :: R < OSCCFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSCCFG` writer"]
pub struct W (crate :: W < OSCCFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSCCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSCCFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSCCFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `FREQSEL` reader - Frequency Select"]
pub type FREQSEL_R = crate :: FieldReader < u8 , FREQSEL_A > ; # [doc = "Frequency Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FREQSEL_A { # [doc = "1: 16 MHz"]
_16MHZ = 1 , # [doc = "2: 20 MHz"]
_20MHZ = 2 , } impl From < FREQSEL_A > for u8 { # [inline (always)]
fn from (variant : FREQSEL_A) -> Self { variant as _ } } impl FREQSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FREQSEL_A > { match self . bits { 1 => Some (FREQSEL_A :: _16MHZ) , 2 => Some (FREQSEL_A :: _20MHZ) , _ => None , } } # [doc = "Checks if the value of the field is `_16MHZ`"]
# [inline (always)]
pub fn is_16mhz (& self) -> bool { * self == FREQSEL_A :: _16MHZ } # [doc = "Checks if the value of the field is `_20MHZ`"]
# [inline (always)]
pub fn is_20mhz (& self) -> bool { * self == FREQSEL_A :: _20MHZ } } # [doc = "Field `FREQSEL` writer - Frequency Select"]
pub type FREQSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , OSCCFG_SPEC , u8 , FREQSEL_A , 2 , O > ; impl < 'a , const O : u8 > FREQSEL_W < 'a , O > { # [doc = "16 MHz"]
# [inline (always)]
pub fn _16mhz (self) -> & 'a mut W { self . variant (FREQSEL_A :: _16MHZ) } # [doc = "20 MHz"]
# [inline (always)]
pub fn _20mhz (self) -> & 'a mut W { self . variant (FREQSEL_A :: _20MHZ) } } # [doc = "Field `OSCLOCK` reader - Oscillator Lock"]
pub type OSCLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `OSCLOCK` writer - Oscillator Lock"]
pub type OSCLOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OSCCFG_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Frequency Select"]
# [inline (always)]
pub fn freqsel (& self) -> FREQSEL_R { FREQSEL_R :: new (self . bits & 3) } # [doc = "Bit 7 - Oscillator Lock"]
# [inline (always)]
pub fn osclock (& self) -> OSCLOCK_R { OSCLOCK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Frequency Select"]
# [inline (always)]
# [must_use]
pub fn freqsel (& mut self) -> FREQSEL_W < 0 > { FREQSEL_W :: new (self) } # [doc = "Bit 7 - Oscillator Lock"]
# [inline (always)]
# [must_use]
pub fn osclock (& mut self) -> OSCLOCK_W < 7 > { OSCLOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Oscillator Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccfg](index.html) module"]
pub struct OSCCFG_SPEC ; impl crate :: RegisterSpec for OSCCFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccfg::R](R) reader structure"]
impl crate :: Readable for OSCCFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osccfg::W](W) writer structure"]
impl crate :: Writable for OSCCFG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSCCFG to value 0"]
impl crate :: Resettable for OSCCFG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYSCFG0 (rw) register accessor: an alias for `Reg<SYSCFG0_SPEC>`"]
pub type SYSCFG0 = crate :: Reg < syscfg0 :: SYSCFG0_SPEC > ; # [doc = "System Configuration 0"]
pub mod syscfg0 { # [doc = "Register `SYSCFG0` reader"]
pub struct R (crate :: R < SYSCFG0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSCFG0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSCFG0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSCFG0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSCFG0` writer"]
pub struct W (crate :: W < SYSCFG0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSCFG0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSCFG0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSCFG0_SPEC >) -> Self { W (writer) } } # [doc = "Field `EESAVE` reader - EEPROM Save"]
pub type EESAVE_R = crate :: BitReader < bool > ; # [doc = "Field `EESAVE` writer - EEPROM Save"]
pub type EESAVE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SYSCFG0_SPEC , bool , O > ; # [doc = "Field `RSTPINCFG` reader - Reset Pin Configuration"]
pub type RSTPINCFG_R = crate :: FieldReader < u8 , RSTPINCFG_A > ; # [doc = "Reset Pin Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RSTPINCFG_A { # [doc = "0: GPIO mode"]
GPIO = 0 , # [doc = "1: UPDI mode"]
UPDI = 1 , # [doc = "2: Reset mode"]
RST = 2 , } impl From < RSTPINCFG_A > for u8 { # [inline (always)]
fn from (variant : RSTPINCFG_A) -> Self { variant as _ } } impl RSTPINCFG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RSTPINCFG_A > { match self . bits { 0 => Some (RSTPINCFG_A :: GPIO) , 1 => Some (RSTPINCFG_A :: UPDI) , 2 => Some (RSTPINCFG_A :: RST) , _ => None , } } # [doc = "Checks if the value of the field is `GPIO`"]
# [inline (always)]
pub fn is_gpio (& self) -> bool { * self == RSTPINCFG_A :: GPIO } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == RSTPINCFG_A :: UPDI } # [doc = "Checks if the value of the field is `RST`"]
# [inline (always)]
pub fn is_rst (& self) -> bool { * self == RSTPINCFG_A :: RST } } # [doc = "Field `RSTPINCFG` writer - Reset Pin Configuration"]
pub type RSTPINCFG_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SYSCFG0_SPEC , u8 , RSTPINCFG_A , 2 , O > ; impl < 'a , const O : u8 > RSTPINCFG_W < 'a , O > { # [doc = "GPIO mode"]
# [inline (always)]
pub fn gpio (self) -> & 'a mut W { self . variant (RSTPINCFG_A :: GPIO) } # [doc = "UPDI mode"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (RSTPINCFG_A :: UPDI) } # [doc = "Reset mode"]
# [inline (always)]
pub fn rst (self) -> & 'a mut W { self . variant (RSTPINCFG_A :: RST) } } # [doc = "Field `CRCSRC` reader - CRC Source"]
pub type CRCSRC_R = crate :: FieldReader < u8 , CRCSRC_A > ; # [doc = "CRC Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CRCSRC_A { # [doc = "0: The CRC is performed on the entire Flash (boot, application code and application data section)."]
FLASH = 0 , # [doc = "1: The CRC is performed on the boot section of Flash"]
BOOT = 1 , # [doc = "2: The CRC is performed on the boot and application code section of Flash"]
BOOTAPP = 2 , # [doc = "3: Disable CRC."]
NOCRC = 3 , } impl From < CRCSRC_A > for u8 { # [inline (always)]
fn from (variant : CRCSRC_A) -> Self { variant as _ } } impl CRCSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CRCSRC_A { match self . bits { 0 => CRCSRC_A :: FLASH , 1 => CRCSRC_A :: BOOT , 2 => CRCSRC_A :: BOOTAPP , 3 => CRCSRC_A :: NOCRC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FLASH`"]
# [inline (always)]
pub fn is_flash (& self) -> bool { * self == CRCSRC_A :: FLASH } # [doc = "Checks if the value of the field is `BOOT`"]
# [inline (always)]
pub fn is_boot (& self) -> bool { * self == CRCSRC_A :: BOOT } # [doc = "Checks if the value of the field is `BOOTAPP`"]
# [inline (always)]
pub fn is_bootapp (& self) -> bool { * self == CRCSRC_A :: BOOTAPP } # [doc = "Checks if the value of the field is `NOCRC`"]
# [inline (always)]
pub fn is_nocrc (& self) -> bool { * self == CRCSRC_A :: NOCRC } } # [doc = "Field `CRCSRC` writer - CRC Source"]
pub type CRCSRC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SYSCFG0_SPEC , u8 , CRCSRC_A , 2 , O > ; impl < 'a , const O : u8 > CRCSRC_W < 'a , O > { # [doc = "The CRC is performed on the entire Flash (boot, application code and application data section)."]
# [inline (always)]
pub fn flash (self) -> & 'a mut W { self . variant (CRCSRC_A :: FLASH) } # [doc = "The CRC is performed on the boot section of Flash"]
# [inline (always)]
pub fn boot (self) -> & 'a mut W { self . variant (CRCSRC_A :: BOOT) } # [doc = "The CRC is performed on the boot and application code section of Flash"]
# [inline (always)]
pub fn bootapp (self) -> & 'a mut W { self . variant (CRCSRC_A :: BOOTAPP) } # [doc = "Disable CRC."]
# [inline (always)]
pub fn nocrc (self) -> & 'a mut W { self . variant (CRCSRC_A :: NOCRC) } } impl R { # [doc = "Bit 0 - EEPROM Save"]
# [inline (always)]
pub fn eesave (& self) -> EESAVE_R { EESAVE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 2:3 - Reset Pin Configuration"]
# [inline (always)]
pub fn rstpincfg (& self) -> RSTPINCFG_R { RSTPINCFG_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 6:7 - CRC Source"]
# [inline (always)]
pub fn crcsrc (& self) -> CRCSRC_R { CRCSRC_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - EEPROM Save"]
# [inline (always)]
# [must_use]
pub fn eesave (& mut self) -> EESAVE_W < 0 > { EESAVE_W :: new (self) } # [doc = "Bits 2:3 - Reset Pin Configuration"]
# [inline (always)]
# [must_use]
pub fn rstpincfg (& mut self) -> RSTPINCFG_W < 2 > { RSTPINCFG_W :: new (self) } # [doc = "Bits 6:7 - CRC Source"]
# [inline (always)]
# [must_use]
pub fn crcsrc (& mut self) -> CRCSRC_W < 6 > { CRCSRC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System Configuration 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg0](index.html) module"]
pub struct SYSCFG0_SPEC ; impl crate :: RegisterSpec for SYSCFG0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syscfg0::R](R) reader structure"]
impl crate :: Readable for SYSCFG0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syscfg0::W](W) writer structure"]
impl crate :: Writable for SYSCFG0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYSCFG0 to value 0"]
impl crate :: Resettable for SYSCFG0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYSCFG1 (rw) register accessor: an alias for `Reg<SYSCFG1_SPEC>`"]
pub type SYSCFG1 = crate :: Reg < syscfg1 :: SYSCFG1_SPEC > ; # [doc = "System Configuration 1"]
pub mod syscfg1 { # [doc = "Register `SYSCFG1` reader"]
pub struct R (crate :: R < SYSCFG1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSCFG1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSCFG1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSCFG1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSCFG1` writer"]
pub struct W (crate :: W < SYSCFG1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSCFG1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSCFG1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSCFG1_SPEC >) -> Self { W (writer) } } # [doc = "Field `SUT` reader - Startup Time"]
pub type SUT_R = crate :: FieldReader < u8 , SUT_A > ; # [doc = "Startup Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SUT_A { # [doc = "0: 0 ms"]
_0MS = 0 , # [doc = "1: 1 ms"]
_1MS = 1 , # [doc = "2: 2 ms"]
_2MS = 2 , # [doc = "3: 4 ms"]
_4MS = 3 , # [doc = "4: 8 ms"]
_8MS = 4 , # [doc = "5: 16 ms"]
_16MS = 5 , # [doc = "6: 32 ms"]
_32MS = 6 , # [doc = "7: 64 ms"]
_64MS = 7 , } impl From < SUT_A > for u8 { # [inline (always)]
fn from (variant : SUT_A) -> Self { variant as _ } } impl SUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SUT_A { match self . bits { 0 => SUT_A :: _0MS , 1 => SUT_A :: _1MS , 2 => SUT_A :: _2MS , 3 => SUT_A :: _4MS , 4 => SUT_A :: _8MS , 5 => SUT_A :: _16MS , 6 => SUT_A :: _32MS , 7 => SUT_A :: _64MS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0MS`"]
# [inline (always)]
pub fn is_0ms (& self) -> bool { * self == SUT_A :: _0MS } # [doc = "Checks if the value of the field is `_1MS`"]
# [inline (always)]
pub fn is_1ms (& self) -> bool { * self == SUT_A :: _1MS } # [doc = "Checks if the value of the field is `_2MS`"]
# [inline (always)]
pub fn is_2ms (& self) -> bool { * self == SUT_A :: _2MS } # [doc = "Checks if the value of the field is `_4MS`"]
# [inline (always)]
pub fn is_4ms (& self) -> bool { * self == SUT_A :: _4MS } # [doc = "Checks if the value of the field is `_8MS`"]
# [inline (always)]
pub fn is_8ms (& self) -> bool { * self == SUT_A :: _8MS } # [doc = "Checks if the value of the field is `_16MS`"]
# [inline (always)]
pub fn is_16ms (& self) -> bool { * self == SUT_A :: _16MS } # [doc = "Checks if the value of the field is `_32MS`"]
# [inline (always)]
pub fn is_32ms (& self) -> bool { * self == SUT_A :: _32MS } # [doc = "Checks if the value of the field is `_64MS`"]
# [inline (always)]
pub fn is_64ms (& self) -> bool { * self == SUT_A :: _64MS } } # [doc = "Field `SUT` writer - Startup Time"]
pub type SUT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SYSCFG1_SPEC , u8 , SUT_A , 3 , O > ; impl < 'a , const O : u8 > SUT_W < 'a , O > { # [doc = "0 ms"]
# [inline (always)]
pub fn _0ms (self) -> & 'a mut W { self . variant (SUT_A :: _0MS) } # [doc = "1 ms"]
# [inline (always)]
pub fn _1ms (self) -> & 'a mut W { self . variant (SUT_A :: _1MS) } # [doc = "2 ms"]
# [inline (always)]
pub fn _2ms (self) -> & 'a mut W { self . variant (SUT_A :: _2MS) } # [doc = "4 ms"]
# [inline (always)]
pub fn _4ms (self) -> & 'a mut W { self . variant (SUT_A :: _4MS) } # [doc = "8 ms"]
# [inline (always)]
pub fn _8ms (self) -> & 'a mut W { self . variant (SUT_A :: _8MS) } # [doc = "16 ms"]
# [inline (always)]
pub fn _16ms (self) -> & 'a mut W { self . variant (SUT_A :: _16MS) } # [doc = "32 ms"]
# [inline (always)]
pub fn _32ms (self) -> & 'a mut W { self . variant (SUT_A :: _32MS) } # [doc = "64 ms"]
# [inline (always)]
pub fn _64ms (self) -> & 'a mut W { self . variant (SUT_A :: _64MS) } } impl R { # [doc = "Bits 0:2 - Startup Time"]
# [inline (always)]
pub fn sut (& self) -> SUT_R { SUT_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Startup Time"]
# [inline (always)]
# [must_use]
pub fn sut (& mut self) -> SUT_W < 0 > { SUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System Configuration 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg1](index.html) module"]
pub struct SYSCFG1_SPEC ; impl crate :: RegisterSpec for SYSCFG1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syscfg1::R](R) reader structure"]
impl crate :: Readable for SYSCFG1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syscfg1::W](W) writer structure"]
impl crate :: Writable for SYSCFG1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYSCFG1 to value 0"]
impl crate :: Resettable for SYSCFG1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCD0CFG (rw) register accessor: an alias for `Reg<TCD0CFG_SPEC>`"]
pub type TCD0CFG = crate :: Reg < tcd0cfg :: TCD0CFG_SPEC > ; # [doc = "TCD0 Configuration"]
pub mod tcd0cfg { # [doc = "Register `TCD0CFG` reader"]
pub struct R (crate :: R < TCD0CFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCD0CFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCD0CFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCD0CFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCD0CFG` writer"]
pub struct W (crate :: W < TCD0CFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCD0CFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCD0CFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCD0CFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Default Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Default Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCD0CFG_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Default Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Default Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCD0CFG_SPEC , bool , O > ; # [doc = "Field `CMPC` reader - Compare C Default Output Value"]
pub type CMPC_R = crate :: BitReader < bool > ; # [doc = "Field `CMPC` writer - Compare C Default Output Value"]
pub type CMPC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCD0CFG_SPEC , bool , O > ; # [doc = "Field `CMPD` reader - Compare D Default Output Value"]
pub type CMPD_R = crate :: BitReader < bool > ; # [doc = "Field `CMPD` writer - Compare D Default Output Value"]
pub type CMPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCD0CFG_SPEC , bool , O > ; # [doc = "Field `CMPAEN` reader - Compare A Output Enable"]
pub type CMPAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CMPAEN` writer - Compare A Output Enable"]
pub type CMPAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCD0CFG_SPEC , bool , O > ; # [doc = "Field `CMPBEN` reader - Compare B Output Enable"]
pub type CMPBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CMPBEN` writer - Compare B Output Enable"]
pub type CMPBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCD0CFG_SPEC , bool , O > ; # [doc = "Field `CMPCEN` reader - Compare C Output Enable"]
pub type CMPCEN_R = crate :: BitReader < bool > ; # [doc = "Field `CMPCEN` writer - Compare C Output Enable"]
pub type CMPCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCD0CFG_SPEC , bool , O > ; # [doc = "Field `CMPDEN` reader - Compare D Output Enable"]
pub type CMPDEN_R = crate :: BitReader < bool > ; # [doc = "Field `CMPDEN` writer - Compare D Output Enable"]
pub type CMPDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCD0CFG_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Default Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Default Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare C Default Output Value"]
# [inline (always)]
pub fn cmpc (& self) -> CMPC_R { CMPC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare D Default Output Value"]
# [inline (always)]
pub fn cmpd (& self) -> CMPD_R { CMPD_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare A Output Enable"]
# [inline (always)]
pub fn cmpaen (& self) -> CMPAEN_R { CMPAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare B Output Enable"]
# [inline (always)]
pub fn cmpben (& self) -> CMPBEN_R { CMPBEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare C Output Enable"]
# [inline (always)]
pub fn cmpcen (& self) -> CMPCEN_R { CMPCEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare D Output Enable"]
# [inline (always)]
pub fn cmpden (& self) -> CMPDEN_R { CMPDEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Default Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Default Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Bit 2 - Compare C Default Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpc (& mut self) -> CMPC_W < 2 > { CMPC_W :: new (self) } # [doc = "Bit 3 - Compare D Default Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpd (& mut self) -> CMPD_W < 3 > { CMPD_W :: new (self) } # [doc = "Bit 4 - Compare A Output Enable"]
# [inline (always)]
# [must_use]
pub fn cmpaen (& mut self) -> CMPAEN_W < 4 > { CMPAEN_W :: new (self) } # [doc = "Bit 5 - Compare B Output Enable"]
# [inline (always)]
# [must_use]
pub fn cmpben (& mut self) -> CMPBEN_W < 5 > { CMPBEN_W :: new (self) } # [doc = "Bit 6 - Compare C Output Enable"]
# [inline (always)]
# [must_use]
pub fn cmpcen (& mut self) -> CMPCEN_W < 6 > { CMPCEN_W :: new (self) } # [doc = "Bit 7 - Compare D Output Enable"]
# [inline (always)]
# [must_use]
pub fn cmpden (& mut self) -> CMPDEN_W < 7 > { CMPDEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TCD0 Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcd0cfg](index.html) module"]
pub struct TCD0CFG_SPEC ; impl crate :: RegisterSpec for TCD0CFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tcd0cfg::R](R) reader structure"]
impl crate :: Readable for TCD0CFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcd0cfg::W](W) writer structure"]
impl crate :: Writable for TCD0CFG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCD0CFG to value 0"]
impl crate :: Resettable for TCD0CFG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WDTCFG (rw) register accessor: an alias for `Reg<WDTCFG_SPEC>`"]
pub type WDTCFG = crate :: Reg < wdtcfg :: WDTCFG_SPEC > ; # [doc = "Watchdog Configuration"]
pub mod wdtcfg { # [doc = "Register `WDTCFG` reader"]
pub struct R (crate :: R < WDTCFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WDTCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WDTCFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WDTCFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `WDTCFG` writer"]
pub struct W (crate :: W < WDTCFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WDTCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WDTCFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WDTCFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERIOD` reader - Watchdog Timeout Period"]
pub type PERIOD_R = crate :: FieldReader < u8 , PERIOD_A > ; # [doc = "Watchdog Timeout Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PERIOD_A { # [doc = "0: Watch-Dog timer Off"]
OFF = 0 , # [doc = "1: 8 cycles (8ms)"]
_8CLK = 1 , # [doc = "2: 16 cycles (16ms)"]
_16CLK = 2 , # [doc = "3: 32 cycles (32ms)"]
_32CLK = 3 , # [doc = "4: 64 cycles (64ms)"]
_64CLK = 4 , # [doc = "5: 128 cycles (0.128s)"]
_128CLK = 5 , # [doc = "6: 256 cycles (0.256s)"]
_256CLK = 6 , # [doc = "7: 512 cycles (0.512s)"]
_512CLK = 7 , # [doc = "8: 1K cycles (1.0s)"]
_1KCLK = 8 , # [doc = "9: 2K cycles (2.0s)"]
_2KCLK = 9 , # [doc = "10: 4K cycles (4.1s)"]
_4KCLK = 10 , # [doc = "11: 8K cycles (8.2s)"]
_8KCLK = 11 , } impl From < PERIOD_A > for u8 { # [inline (always)]
fn from (variant : PERIOD_A) -> Self { variant as _ } } impl PERIOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PERIOD_A > { match self . bits { 0 => Some (PERIOD_A :: OFF) , 1 => Some (PERIOD_A :: _8CLK) , 2 => Some (PERIOD_A :: _16CLK) , 3 => Some (PERIOD_A :: _32CLK) , 4 => Some (PERIOD_A :: _64CLK) , 5 => Some (PERIOD_A :: _128CLK) , 6 => Some (PERIOD_A :: _256CLK) , 7 => Some (PERIOD_A :: _512CLK) , 8 => Some (PERIOD_A :: _1KCLK) , 9 => Some (PERIOD_A :: _2KCLK) , 10 => Some (PERIOD_A :: _4KCLK) , 11 => Some (PERIOD_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == PERIOD_A :: OFF } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == PERIOD_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == PERIOD_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == PERIOD_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == PERIOD_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == PERIOD_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == PERIOD_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == PERIOD_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == PERIOD_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == PERIOD_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == PERIOD_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == PERIOD_A :: _8KCLK } } # [doc = "Field `PERIOD` writer - Watchdog Timeout Period"]
pub type PERIOD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , WDTCFG_SPEC , u8 , PERIOD_A , 4 , O > ; impl < 'a , const O : u8 > PERIOD_W < 'a , O > { # [doc = "Watch-Dog timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (PERIOD_A :: OFF) } # [doc = "8 cycles (8ms)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _8CLK) } # [doc = "16 cycles (16ms)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _16CLK) } # [doc = "32 cycles (32ms)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _32CLK) } # [doc = "64 cycles (64ms)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _64CLK) } # [doc = "128 cycles (0.128s)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _128CLK) } # [doc = "256 cycles (0.256s)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _256CLK) } # [doc = "512 cycles (0.512s)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _512CLK) } # [doc = "1K cycles (1.0s)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _1KCLK) } # [doc = "2K cycles (2.0s)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _2KCLK) } # [doc = "4K cycles (4.1s)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _4KCLK) } # [doc = "8K cycles (8.2s)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _8KCLK) } } # [doc = "Field `WINDOW` reader - Watchdog Window Timeout Period"]
pub type WINDOW_R = crate :: FieldReader < u8 , WINDOW_A > ; # [doc = "Watchdog Window Timeout Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINDOW_A { # [doc = "0: Window mode off"]
OFF = 0 , # [doc = "1: 8 cycles (8ms)"]
_8CLK = 1 , # [doc = "2: 16 cycles (16ms)"]
_16CLK = 2 , # [doc = "3: 32 cycles (32ms)"]
_32CLK = 3 , # [doc = "4: 64 cycles (64ms)"]
_64CLK = 4 , # [doc = "5: 128 cycles (0.128s)"]
_128CLK = 5 , # [doc = "6: 256 cycles (0.256s)"]
_256CLK = 6 , # [doc = "7: 512 cycles (0.512s)"]
_512CLK = 7 , # [doc = "8: 1K cycles (1.0s)"]
_1KCLK = 8 , # [doc = "9: 2K cycles (2.0s)"]
_2KCLK = 9 , # [doc = "10: 4K cycles (4.1s)"]
_4KCLK = 10 , # [doc = "11: 8K cycles (8.2s)"]
_8KCLK = 11 , } impl From < WINDOW_A > for u8 { # [inline (always)]
fn from (variant : WINDOW_A) -> Self { variant as _ } } impl WINDOW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WINDOW_A > { match self . bits { 0 => Some (WINDOW_A :: OFF) , 1 => Some (WINDOW_A :: _8CLK) , 2 => Some (WINDOW_A :: _16CLK) , 3 => Some (WINDOW_A :: _32CLK) , 4 => Some (WINDOW_A :: _64CLK) , 5 => Some (WINDOW_A :: _128CLK) , 6 => Some (WINDOW_A :: _256CLK) , 7 => Some (WINDOW_A :: _512CLK) , 8 => Some (WINDOW_A :: _1KCLK) , 9 => Some (WINDOW_A :: _2KCLK) , 10 => Some (WINDOW_A :: _4KCLK) , 11 => Some (WINDOW_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == WINDOW_A :: OFF } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == WINDOW_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == WINDOW_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == WINDOW_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == WINDOW_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == WINDOW_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == WINDOW_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == WINDOW_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == WINDOW_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == WINDOW_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == WINDOW_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == WINDOW_A :: _8KCLK } } # [doc = "Field `WINDOW` writer - Watchdog Window Timeout Period"]
pub type WINDOW_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , WDTCFG_SPEC , u8 , WINDOW_A , 4 , O > ; impl < 'a , const O : u8 > WINDOW_W < 'a , O > { # [doc = "Window mode off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (WINDOW_A :: OFF) } # [doc = "8 cycles (8ms)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _8CLK) } # [doc = "16 cycles (16ms)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _16CLK) } # [doc = "32 cycles (32ms)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _32CLK) } # [doc = "64 cycles (64ms)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _64CLK) } # [doc = "128 cycles (0.128s)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _128CLK) } # [doc = "256 cycles (0.256s)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _256CLK) } # [doc = "512 cycles (0.512s)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _512CLK) } # [doc = "1K cycles (1.0s)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _1KCLK) } # [doc = "2K cycles (2.0s)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _2KCLK) } # [doc = "4K cycles (4.1s)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _4KCLK) } # [doc = "8K cycles (8.2s)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _8KCLK) } } impl R { # [doc = "Bits 0:3 - Watchdog Timeout Period"]
# [inline (always)]
pub fn period (& self) -> PERIOD_R { PERIOD_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Watchdog Window Timeout Period"]
# [inline (always)]
pub fn window (& self) -> WINDOW_R { WINDOW_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Watchdog Timeout Period"]
# [inline (always)]
# [must_use]
pub fn period (& mut self) -> PERIOD_W < 0 > { PERIOD_W :: new (self) } # [doc = "Bits 4:7 - Watchdog Window Timeout Period"]
# [inline (always)]
# [must_use]
pub fn window (& mut self) -> WINDOW_W < 4 > { WINDOW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Watchdog Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wdtcfg](index.html) module"]
pub struct WDTCFG_SPEC ; impl crate :: RegisterSpec for WDTCFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [wdtcfg::R](R) reader structure"]
impl crate :: Readable for WDTCFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wdtcfg::W](W) writer structure"]
impl crate :: Writable for WDTCFG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WDTCFG to value 0"]
impl crate :: Resettable for WDTCFG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "General Purpose IO"]
pub struct GPIO { _marker : PhantomData < * const () > } unsafe impl Send for GPIO { } impl GPIO { # [doc = r"Pointer to the register block"]
pub const PTR : * const gpio :: RegisterBlock = 0x1c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const gpio :: RegisterBlock { Self :: PTR } } impl Deref for GPIO { type Target = gpio :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for GPIO { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("GPIO") . finish () } } # [doc = "General Purpose IO"]
pub mod gpio { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - General Purpose IO Register 0"]
pub gpior0 : GPIOR0 , # [doc = "0x01 - General Purpose IO Register 1"]
pub gpior1 : GPIOR1 , # [doc = "0x02 - General Purpose IO Register 2"]
pub gpior2 : GPIOR2 , # [doc = "0x03 - General Purpose IO Register 3"]
pub gpior3 : GPIOR3 , } # [doc = "GPIOR0 (rw) register accessor: an alias for `Reg<GPIOR0_SPEC>`"]
pub type GPIOR0 = crate :: Reg < gpior0 :: GPIOR0_SPEC > ; # [doc = "General Purpose IO Register 0"]
pub mod gpior0 { # [doc = "Register `GPIOR0` reader"]
pub struct R (crate :: R < GPIOR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR0` writer"]
pub struct W (crate :: W < GPIOR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior0](index.html) module"]
pub struct GPIOR0_SPEC ; impl crate :: RegisterSpec for GPIOR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior0::R](R) reader structure"]
impl crate :: Readable for GPIOR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior0::W](W) writer structure"]
impl crate :: Writable for GPIOR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR0 to value 0"]
impl crate :: Resettable for GPIOR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR1 (rw) register accessor: an alias for `Reg<GPIOR1_SPEC>`"]
pub type GPIOR1 = crate :: Reg < gpior1 :: GPIOR1_SPEC > ; # [doc = "General Purpose IO Register 1"]
pub mod gpior1 { # [doc = "Register `GPIOR1` reader"]
pub struct R (crate :: R < GPIOR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR1` writer"]
pub struct W (crate :: W < GPIOR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior1](index.html) module"]
pub struct GPIOR1_SPEC ; impl crate :: RegisterSpec for GPIOR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior1::R](R) reader structure"]
impl crate :: Readable for GPIOR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior1::W](W) writer structure"]
impl crate :: Writable for GPIOR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR1 to value 0"]
impl crate :: Resettable for GPIOR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR2 (rw) register accessor: an alias for `Reg<GPIOR2_SPEC>`"]
pub type GPIOR2 = crate :: Reg < gpior2 :: GPIOR2_SPEC > ; # [doc = "General Purpose IO Register 2"]
pub mod gpior2 { # [doc = "Register `GPIOR2` reader"]
pub struct R (crate :: R < GPIOR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR2` writer"]
pub struct W (crate :: W < GPIOR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior2](index.html) module"]
pub struct GPIOR2_SPEC ; impl crate :: RegisterSpec for GPIOR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior2::R](R) reader structure"]
impl crate :: Readable for GPIOR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior2::W](W) writer structure"]
impl crate :: Writable for GPIOR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR2 to value 0"]
impl crate :: Resettable for GPIOR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR3 (rw) register accessor: an alias for `Reg<GPIOR3_SPEC>`"]
pub type GPIOR3 = crate :: Reg < gpior3 :: GPIOR3_SPEC > ; # [doc = "General Purpose IO Register 3"]
pub mod gpior3 { # [doc = "Register `GPIOR3` reader"]
pub struct R (crate :: R < GPIOR3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR3_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR3` writer"]
pub struct W (crate :: W < GPIOR3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior3](index.html) module"]
pub struct GPIOR3_SPEC ; impl crate :: RegisterSpec for GPIOR3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior3::R](R) reader structure"]
impl crate :: Readable for GPIOR3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior3::W](W) writer structure"]
impl crate :: Writable for GPIOR3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR3 to value 0"]
impl crate :: Resettable for GPIOR3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Lockbit"]
pub struct LOCKBIT { _marker : PhantomData < * const () > } unsafe impl Send for LOCKBIT { } impl LOCKBIT { # [doc = r"Pointer to the register block"]
pub const PTR : * const lockbit :: RegisterBlock = 0x128a as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const lockbit :: RegisterBlock { Self :: PTR } } impl Deref for LOCKBIT { type Target = lockbit :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for LOCKBIT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("LOCKBIT") . finish () } } # [doc = "Lockbit"]
pub mod lockbit { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Lock bits"]
pub lockbit : LOCKBIT , } # [doc = "LOCKBIT (rw) register accessor: an alias for `Reg<LOCKBIT_SPEC>`"]
pub type LOCKBIT = crate :: Reg < lockbit :: LOCKBIT_SPEC > ; # [doc = "Lock bits"]
pub mod lockbit { # [doc = "Register `LOCKBIT` reader"]
pub struct R (crate :: R < LOCKBIT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKBIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKBIT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKBIT_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCKBIT` writer"]
pub struct W (crate :: W < LOCKBIT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCKBIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCKBIT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCKBIT_SPEC >) -> Self { W (writer) } } # [doc = "Field `LB` reader - Lock Bits"]
pub type LB_R = crate :: FieldReader < u8 , LB_A > ; # [doc = "Lock Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LB_A { # [doc = "58: Read and write lock"]
RWLOCK = 58 , # [doc = "197: No locks"]
NOLOCK = 197 , } impl From < LB_A > for u8 { # [inline (always)]
fn from (variant : LB_A) -> Self { variant as _ } } impl LB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LB_A > { match self . bits { 58 => Some (LB_A :: RWLOCK) , 197 => Some (LB_A :: NOLOCK) , _ => None , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == LB_A :: RWLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == LB_A :: NOLOCK } } # [doc = "Field `LB` writer - Lock Bits"]
pub type LB_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LOCKBIT_SPEC , u8 , LB_A , 8 , O > ; impl < 'a , const O : u8 > LB_W < 'a , O > { # [doc = "Read and write lock"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (LB_A :: RWLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (LB_A :: NOLOCK) } } impl R { # [doc = "Bits 0:7 - Lock Bits"]
# [inline (always)]
pub fn lb (& self) -> LB_R { LB_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Lock Bits"]
# [inline (always)]
# [must_use]
pub fn lb (& mut self) -> LB_W < 0 > { LB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Lock bits\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockbit](index.html) module"]
pub struct LOCKBIT_SPEC ; impl crate :: RegisterSpec for LOCKBIT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lockbit::R](R) reader structure"]
impl crate :: Readable for LOCKBIT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lockbit::W](W) writer structure"]
impl crate :: Writable for LOCKBIT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOCKBIT to value 0"]
impl crate :: Resettable for LOCKBIT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Non-volatile Memory Controller"]
pub struct NVMCTRL { _marker : PhantomData < * const () > } unsafe impl Send for NVMCTRL { } impl NVMCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const nvmctrl :: RegisterBlock = 0x1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const nvmctrl :: RegisterBlock { Self :: PTR } } impl Deref for NVMCTRL { type Target = nvmctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for NVMCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("NVMCTRL") . finish () } } # [doc = "Non-volatile Memory Controller"]
pub mod nvmctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Status"]
pub status : STATUS , # [doc = "0x03 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x04 - Interrupt Flags"]
pub intflags : INTFLAGS , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Data"]
pub data : DATA , # [doc = "0x08 - Address"]
pub addr : ADDR , } # [doc = "ADDR (rw) register accessor: an alias for `Reg<ADDR_SPEC>`"]
pub type ADDR = crate :: Reg < addr :: ADDR_SPEC > ; # [doc = "Address"]
pub mod addr { # [doc = "Register `ADDR` reader"]
pub struct R (crate :: R < ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR` writer"]
pub struct W (crate :: W < ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr](index.html) module"]
pub struct ADDR_SPEC ; impl crate :: RegisterSpec for ADDR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [addr::R](R) reader structure"]
impl crate :: Readable for ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr::W](W) writer structure"]
impl crate :: Writable for ADDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADDR to value 0"]
impl crate :: Resettable for ADDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Write page"]
PAGEWRITE = 1 , # [doc = "2: Erase page"]
PAGEERASE = 2 , # [doc = "3: Erase and write page"]
PAGEERASEWRITE = 3 , # [doc = "4: Page buffer clear"]
PAGEBUFCLR = 4 , # [doc = "5: Chip erase"]
CHIPERASE = 5 , # [doc = "6: EEPROM erase"]
EEERASE = 6 , # [doc = "7: Write fuse (PDI only)"]
FUSEWRITE = 7 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: PAGEWRITE , 2 => CMD_A :: PAGEERASE , 3 => CMD_A :: PAGEERASEWRITE , 4 => CMD_A :: PAGEBUFCLR , 5 => CMD_A :: CHIPERASE , 6 => CMD_A :: EEERASE , 7 => CMD_A :: FUSEWRITE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `PAGEWRITE`"]
# [inline (always)]
pub fn is_pagewrite (& self) -> bool { * self == CMD_A :: PAGEWRITE } # [doc = "Checks if the value of the field is `PAGEERASE`"]
# [inline (always)]
pub fn is_pageerase (& self) -> bool { * self == CMD_A :: PAGEERASE } # [doc = "Checks if the value of the field is `PAGEERASEWRITE`"]
# [inline (always)]
pub fn is_pageerasewrite (& self) -> bool { * self == CMD_A :: PAGEERASEWRITE } # [doc = "Checks if the value of the field is `PAGEBUFCLR`"]
# [inline (always)]
pub fn is_pagebufclr (& self) -> bool { * self == CMD_A :: PAGEBUFCLR } # [doc = "Checks if the value of the field is `CHIPERASE`"]
# [inline (always)]
pub fn is_chiperase (& self) -> bool { * self == CMD_A :: CHIPERASE } # [doc = "Checks if the value of the field is `EEERASE`"]
# [inline (always)]
pub fn is_eeerase (& self) -> bool { * self == CMD_A :: EEERASE } # [doc = "Checks if the value of the field is `FUSEWRITE`"]
# [inline (always)]
pub fn is_fusewrite (& self) -> bool { * self == CMD_A :: FUSEWRITE } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CMD_A , 3 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Write page"]
# [inline (always)]
pub fn pagewrite (self) -> & 'a mut W { self . variant (CMD_A :: PAGEWRITE) } # [doc = "Erase page"]
# [inline (always)]
pub fn pageerase (self) -> & 'a mut W { self . variant (CMD_A :: PAGEERASE) } # [doc = "Erase and write page"]
# [inline (always)]
pub fn pageerasewrite (self) -> & 'a mut W { self . variant (CMD_A :: PAGEERASEWRITE) } # [doc = "Page buffer clear"]
# [inline (always)]
pub fn pagebufclr (self) -> & 'a mut W { self . variant (CMD_A :: PAGEBUFCLR) } # [doc = "Chip erase"]
# [inline (always)]
pub fn chiperase (self) -> & 'a mut W { self . variant (CMD_A :: CHIPERASE) } # [doc = "EEPROM erase"]
# [inline (always)]
pub fn eeerase (self) -> & 'a mut W { self . variant (CMD_A :: EEERASE) } # [doc = "Write fuse (PDI only)"]
# [inline (always)]
pub fn fusewrite (self) -> & 'a mut W { self . variant (CMD_A :: FUSEWRITE) } } impl R { # [doc = "Bits 0:2 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 0 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `APCWP` reader - Application code write protect"]
pub type APCWP_R = crate :: BitReader < bool > ; # [doc = "Field `APCWP` writer - Application code write protect"]
pub type APCWP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `BOOTLOCK` reader - Boot Lock"]
pub type BOOTLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `BOOTLOCK` writer - Boot Lock"]
pub type BOOTLOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Application code write protect"]
# [inline (always)]
pub fn apcwp (& self) -> APCWP_R { APCWP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Boot Lock"]
# [inline (always)]
pub fn bootlock (& self) -> BOOTLOCK_R { BOOTLOCK_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Application code write protect"]
# [inline (always)]
# [must_use]
pub fn apcwp (& mut self) -> APCWP_W < 0 > { APCWP_W :: new (self) } # [doc = "Bit 1 - Boot Lock"]
# [inline (always)]
# [must_use]
pub fn bootlock (& mut self) -> BOOTLOCK_W < 1 > { BOOTLOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EEREADY` reader - EEPROM Ready"]
pub type EEREADY_R = crate :: BitReader < bool > ; # [doc = "Field `EEREADY` writer - EEPROM Ready"]
pub type EEREADY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - EEPROM Ready"]
# [inline (always)]
pub fn eeready (& self) -> EEREADY_R { EEREADY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - EEPROM Ready"]
# [inline (always)]
# [must_use]
pub fn eeready (& mut self) -> EEREADY_W < 0 > { EEREADY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `EEREADY` reader - EEPROM Ready"]
pub type EEREADY_R = crate :: BitReader < bool > ; # [doc = "Field `EEREADY` writer - EEPROM Ready"]
pub type EEREADY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - EEPROM Ready"]
# [inline (always)]
pub fn eeready (& self) -> EEREADY_R { EEREADY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - EEPROM Ready"]
# [inline (always)]
# [must_use]
pub fn eeready (& mut self) -> EEREADY_W < 0 > { EEREADY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `FBUSY` reader - Flash busy"]
pub type FBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `EEBUSY` reader - EEPROM busy"]
pub type EEBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `WRERROR` reader - Write error"]
pub type WRERROR_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Flash busy"]
# [inline (always)]
pub fn fbusy (& self) -> FBUSY_R { FBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EEPROM busy"]
# [inline (always)]
pub fn eebusy (& self) -> EEBUSY_R { EEBUSY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Write error"]
# [inline (always)]
pub fn wrerror (& self) -> WRERROR_R { WRERROR_R :: new (((self . bits >> 2) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTA { _marker : PhantomData < * const () > } unsafe impl Send for PORTA { } impl PORTA { # [doc = r"Pointer to the register block"]
pub const PTR : * const porta :: RegisterBlock = 0x0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porta :: RegisterBlock { Self :: PTR } } impl Deref for PORTA { type Target = porta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTA") . finish () } } # [doc = "I/O Ports"]
pub mod porta { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , _reserved10 : [u8 ; 0x06]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTB { _marker : PhantomData < * const () > } unsafe impl Send for PORTB { } impl PORTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const portb :: RegisterBlock = 0x0420 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portb :: RegisterBlock { Self :: PTR } } impl Deref for PORTB { type Target = portb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTB") . finish () } } # [doc = "I/O Ports"]
pub mod portb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , _reserved10 : [u8 ; 0x06]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTC { _marker : PhantomData < * const () > } unsafe impl Send for PORTC { } impl PORTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const portc :: RegisterBlock = 0x0440 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portc :: RegisterBlock { Self :: PTR } } impl Deref for PORTC { type Target = portc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTC") . finish () } } # [doc = "I/O Ports"]
pub mod portc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , _reserved10 : [u8 ; 0x06]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Multiplexer"]
pub struct PORTMUX { _marker : PhantomData < * const () > } unsafe impl Send for PORTMUX { } impl PORTMUX { # [doc = r"Pointer to the register block"]
pub const PTR : * const portmux :: RegisterBlock = 0x0200 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portmux :: RegisterBlock { Self :: PTR } } impl Deref for PORTMUX { type Target = portmux :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTMUX { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTMUX") . finish () } } # [doc = "Port Multiplexer"]
pub mod portmux { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port Multiplexer Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Port Multiplexer Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Port Multiplexer Control C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Port Multiplexer Control D"]
pub ctrld : CTRLD , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Port Multiplexer Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVOUT0` reader - Event Output 0"]
pub type EVOUT0_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT0` writer - Event Output 0"]
pub type EVOUT0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `EVOUT1` reader - Event Output 1"]
pub type EVOUT1_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT1` writer - Event Output 1"]
pub type EVOUT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `EVOUT2` reader - Event Output 2"]
pub type EVOUT2_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT2` writer - Event Output 2"]
pub type EVOUT2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `LUT0` reader - Configurable Custom Logic LUT0"]
pub type LUT0_R = crate :: BitReader < LUT0_A > ; # [doc = "Configurable Custom Logic LUT0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum LUT0_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < LUT0_A > for bool { # [inline (always)]
fn from (variant : LUT0_A) -> Self { variant as u8 != 0 } } impl LUT0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> LUT0_A { match self . bits { false => LUT0_A :: DEFAULT , true => LUT0_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == LUT0_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == LUT0_A :: ALTERNATE } } # [doc = "Field `LUT0` writer - Configurable Custom Logic LUT0"]
pub type LUT0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , LUT0_A , O > ; impl < 'a , const O : u8 > LUT0_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (LUT0_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (LUT0_A :: ALTERNATE) } } # [doc = "Field `LUT1` reader - Configurable Custom Logic LUT1"]
pub type LUT1_R = crate :: BitReader < LUT1_A > ; # [doc = "Configurable Custom Logic LUT1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum LUT1_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < LUT1_A > for bool { # [inline (always)]
fn from (variant : LUT1_A) -> Self { variant as u8 != 0 } } impl LUT1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> LUT1_A { match self . bits { false => LUT1_A :: DEFAULT , true => LUT1_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == LUT1_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == LUT1_A :: ALTERNATE } } # [doc = "Field `LUT1` writer - Configurable Custom Logic LUT1"]
pub type LUT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , LUT1_A , O > ; impl < 'a , const O : u8 > LUT1_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (LUT1_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (LUT1_A :: ALTERNATE) } } impl R { # [doc = "Bit 0 - Event Output 0"]
# [inline (always)]
pub fn evout0 (& self) -> EVOUT0_R { EVOUT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Event Output 1"]
# [inline (always)]
pub fn evout1 (& self) -> EVOUT1_R { EVOUT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Event Output 2"]
# [inline (always)]
pub fn evout2 (& self) -> EVOUT2_R { EVOUT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn lut0 (& self) -> LUT0_R { LUT0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn lut1 (& self) -> LUT1_R { LUT1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Event Output 0"]
# [inline (always)]
# [must_use]
pub fn evout0 (& mut self) -> EVOUT0_W < 0 > { EVOUT0_W :: new (self) } # [doc = "Bit 1 - Event Output 1"]
# [inline (always)]
# [must_use]
pub fn evout1 (& mut self) -> EVOUT1_W < 1 > { EVOUT1_W :: new (self) } # [doc = "Bit 2 - Event Output 2"]
# [inline (always)]
# [must_use]
pub fn evout2 (& mut self) -> EVOUT2_W < 2 > { EVOUT2_W :: new (self) } # [doc = "Bit 4 - Configurable Custom Logic LUT0"]
# [inline (always)]
# [must_use]
pub fn lut0 (& mut self) -> LUT0_W < 4 > { LUT0_W :: new (self) } # [doc = "Bit 5 - Configurable Custom Logic LUT1"]
# [inline (always)]
# [must_use]
pub fn lut1 (& mut self) -> LUT1_W < 5 > { LUT1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Port Multiplexer Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `USART0` reader - Port Multiplexer USART0"]
pub type USART0_R = crate :: BitReader < USART0_A > ; # [doc = "Port Multiplexer USART0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum USART0_A { # [doc = "0: Default pins"]
DEFAULT = 0 , # [doc = "1: Alternate pins"]
ALTERNATE = 1 , } impl From < USART0_A > for bool { # [inline (always)]
fn from (variant : USART0_A) -> Self { variant as u8 != 0 } } impl USART0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> USART0_A { match self . bits { false => USART0_A :: DEFAULT , true => USART0_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == USART0_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == USART0_A :: ALTERNATE } } # [doc = "Field `USART0` writer - Port Multiplexer USART0"]
pub type USART0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , USART0_A , O > ; impl < 'a , const O : u8 > USART0_W < 'a , O > { # [doc = "Default pins"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (USART0_A :: DEFAULT) } # [doc = "Alternate pins"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (USART0_A :: ALTERNATE) } } # [doc = "Field `SPI0` reader - Port Multiplexer SPI0"]
pub type SPI0_R = crate :: BitReader < SPI0_A > ; # [doc = "Port Multiplexer SPI0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SPI0_A { # [doc = "0: Default pins"]
DEFAULT = 0 , # [doc = "1: Alternate pins"]
ALTERNATE = 1 , } impl From < SPI0_A > for bool { # [inline (always)]
fn from (variant : SPI0_A) -> Self { variant as u8 != 0 } } impl SPI0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SPI0_A { match self . bits { false => SPI0_A :: DEFAULT , true => SPI0_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == SPI0_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == SPI0_A :: ALTERNATE } } # [doc = "Field `SPI0` writer - Port Multiplexer SPI0"]
pub type SPI0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , SPI0_A , O > ; impl < 'a , const O : u8 > SPI0_W < 'a , O > { # [doc = "Default pins"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (SPI0_A :: DEFAULT) } # [doc = "Alternate pins"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (SPI0_A :: ALTERNATE) } } # [doc = "Field `TWI0` reader - Port Multiplexer TWI0"]
pub type TWI0_R = crate :: BitReader < TWI0_A > ; # [doc = "Port Multiplexer TWI0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TWI0_A { # [doc = "0: Default pins"]
DEFAULT = 0 , # [doc = "1: Alternate pins"]
ALTERNATE = 1 , } impl From < TWI0_A > for bool { # [inline (always)]
fn from (variant : TWI0_A) -> Self { variant as u8 != 0 } } impl TWI0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TWI0_A { match self . bits { false => TWI0_A :: DEFAULT , true => TWI0_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TWI0_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == TWI0_A :: ALTERNATE } } # [doc = "Field `TWI0` writer - Port Multiplexer TWI0"]
pub type TWI0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , TWI0_A , O > ; impl < 'a , const O : u8 > TWI0_W < 'a , O > { # [doc = "Default pins"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TWI0_A :: DEFAULT) } # [doc = "Alternate pins"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (TWI0_A :: ALTERNATE) } } impl R { # [doc = "Bit 0 - Port Multiplexer USART0"]
# [inline (always)]
pub fn usart0 (& self) -> USART0_R { USART0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Port Multiplexer SPI0"]
# [inline (always)]
pub fn spi0 (& self) -> SPI0_R { SPI0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Port Multiplexer TWI0"]
# [inline (always)]
pub fn twi0 (& self) -> TWI0_R { TWI0_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Multiplexer USART0"]
# [inline (always)]
# [must_use]
pub fn usart0 (& mut self) -> USART0_W < 0 > { USART0_W :: new (self) } # [doc = "Bit 2 - Port Multiplexer SPI0"]
# [inline (always)]
# [must_use]
pub fn spi0 (& mut self) -> SPI0_W < 2 > { SPI0_W :: new (self) } # [doc = "Bit 4 - Port Multiplexer TWI0"]
# [inline (always)]
# [must_use]
pub fn twi0 (& mut self) -> TWI0_W < 4 > { TWI0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Port Multiplexer Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `TCA00` reader - Port Multiplexer TCA0 Output 0"]
pub type TCA00_R = crate :: BitReader < TCA00_A > ; # [doc = "Port Multiplexer TCA0 Output 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TCA00_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < TCA00_A > for bool { # [inline (always)]
fn from (variant : TCA00_A) -> Self { variant as u8 != 0 } } impl TCA00_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TCA00_A { match self . bits { false => TCA00_A :: DEFAULT , true => TCA00_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TCA00_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == TCA00_A :: ALTERNATE } } # [doc = "Field `TCA00` writer - Port Multiplexer TCA0 Output 0"]
pub type TCA00_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , TCA00_A , O > ; impl < 'a , const O : u8 > TCA00_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TCA00_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (TCA00_A :: ALTERNATE) } } # [doc = "Field `TCA01` reader - Port Multiplexer TCA0 Output 1"]
pub type TCA01_R = crate :: BitReader < TCA01_A > ; # [doc = "Port Multiplexer TCA0 Output 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TCA01_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < TCA01_A > for bool { # [inline (always)]
fn from (variant : TCA01_A) -> Self { variant as u8 != 0 } } impl TCA01_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TCA01_A { match self . bits { false => TCA01_A :: DEFAULT , true => TCA01_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TCA01_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == TCA01_A :: ALTERNATE } } # [doc = "Field `TCA01` writer - Port Multiplexer TCA0 Output 1"]
pub type TCA01_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , TCA01_A , O > ; impl < 'a , const O : u8 > TCA01_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TCA01_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (TCA01_A :: ALTERNATE) } } # [doc = "Field `TCA02` reader - Port Multiplexer TCA0 Output 2"]
pub type TCA02_R = crate :: BitReader < TCA02_A > ; # [doc = "Port Multiplexer TCA0 Output 2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TCA02_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < TCA02_A > for bool { # [inline (always)]
fn from (variant : TCA02_A) -> Self { variant as u8 != 0 } } impl TCA02_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TCA02_A { match self . bits { false => TCA02_A :: DEFAULT , true => TCA02_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TCA02_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == TCA02_A :: ALTERNATE } } # [doc = "Field `TCA02` writer - Port Multiplexer TCA0 Output 2"]
pub type TCA02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , TCA02_A , O > ; impl < 'a , const O : u8 > TCA02_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TCA02_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (TCA02_A :: ALTERNATE) } } # [doc = "Field `TCA03` reader - Port Multiplexer TCA0 Output 3"]
pub type TCA03_R = crate :: BitReader < TCA03_A > ; # [doc = "Port Multiplexer TCA0 Output 3\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TCA03_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < TCA03_A > for bool { # [inline (always)]
fn from (variant : TCA03_A) -> Self { variant as u8 != 0 } } impl TCA03_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TCA03_A { match self . bits { false => TCA03_A :: DEFAULT , true => TCA03_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TCA03_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == TCA03_A :: ALTERNATE } } # [doc = "Field `TCA03` writer - Port Multiplexer TCA0 Output 3"]
pub type TCA03_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , TCA03_A , O > ; impl < 'a , const O : u8 > TCA03_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TCA03_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (TCA03_A :: ALTERNATE) } } # [doc = "Field `TCA04` reader - Port Multiplexer TCA0 Output 4"]
pub type TCA04_R = crate :: BitReader < TCA04_A > ; # [doc = "Port Multiplexer TCA0 Output 4\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TCA04_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < TCA04_A > for bool { # [inline (always)]
fn from (variant : TCA04_A) -> Self { variant as u8 != 0 } } impl TCA04_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TCA04_A { match self . bits { false => TCA04_A :: DEFAULT , true => TCA04_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TCA04_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == TCA04_A :: ALTERNATE } } # [doc = "Field `TCA04` writer - Port Multiplexer TCA0 Output 4"]
pub type TCA04_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , TCA04_A , O > ; impl < 'a , const O : u8 > TCA04_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TCA04_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (TCA04_A :: ALTERNATE) } } # [doc = "Field `TCA05` reader - Port Multiplexer TCA0 Output 5"]
pub type TCA05_R = crate :: BitReader < TCA05_A > ; # [doc = "Port Multiplexer TCA0 Output 5\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TCA05_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < TCA05_A > for bool { # [inline (always)]
fn from (variant : TCA05_A) -> Self { variant as u8 != 0 } } impl TCA05_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TCA05_A { match self . bits { false => TCA05_A :: DEFAULT , true => TCA05_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TCA05_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == TCA05_A :: ALTERNATE } } # [doc = "Field `TCA05` writer - Port Multiplexer TCA0 Output 5"]
pub type TCA05_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , TCA05_A , O > ; impl < 'a , const O : u8 > TCA05_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TCA05_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (TCA05_A :: ALTERNATE) } } impl R { # [doc = "Bit 0 - Port Multiplexer TCA0 Output 0"]
# [inline (always)]
pub fn tca00 (& self) -> TCA00_R { TCA00_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Multiplexer TCA0 Output 1"]
# [inline (always)]
pub fn tca01 (& self) -> TCA01_R { TCA01_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Port Multiplexer TCA0 Output 2"]
# [inline (always)]
pub fn tca02 (& self) -> TCA02_R { TCA02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Port Multiplexer TCA0 Output 3"]
# [inline (always)]
pub fn tca03 (& self) -> TCA03_R { TCA03_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Port Multiplexer TCA0 Output 4"]
# [inline (always)]
pub fn tca04 (& self) -> TCA04_R { TCA04_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Port Multiplexer TCA0 Output 5"]
# [inline (always)]
pub fn tca05 (& self) -> TCA05_R { TCA05_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Multiplexer TCA0 Output 0"]
# [inline (always)]
# [must_use]
pub fn tca00 (& mut self) -> TCA00_W < 0 > { TCA00_W :: new (self) } # [doc = "Bit 1 - Port Multiplexer TCA0 Output 1"]
# [inline (always)]
# [must_use]
pub fn tca01 (& mut self) -> TCA01_W < 1 > { TCA01_W :: new (self) } # [doc = "Bit 2 - Port Multiplexer TCA0 Output 2"]
# [inline (always)]
# [must_use]
pub fn tca02 (& mut self) -> TCA02_W < 2 > { TCA02_W :: new (self) } # [doc = "Bit 3 - Port Multiplexer TCA0 Output 3"]
# [inline (always)]
# [must_use]
pub fn tca03 (& mut self) -> TCA03_W < 3 > { TCA03_W :: new (self) } # [doc = "Bit 4 - Port Multiplexer TCA0 Output 4"]
# [inline (always)]
# [must_use]
pub fn tca04 (& mut self) -> TCA04_W < 4 > { TCA04_W :: new (self) } # [doc = "Bit 5 - Port Multiplexer TCA0 Output 5"]
# [inline (always)]
# [must_use]
pub fn tca05 (& mut self) -> TCA05_W < 5 > { TCA05_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Port Multiplexer Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `TCB0` reader - Port Multiplexer TCB"]
pub type TCB0_R = crate :: BitReader < TCB0_A > ; # [doc = "Port Multiplexer TCB\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TCB0_A { # [doc = "0: Default pin"]
DEFAULT = 0 , # [doc = "1: Alternate pin"]
ALTERNATE = 1 , } impl From < TCB0_A > for bool { # [inline (always)]
fn from (variant : TCB0_A) -> Self { variant as u8 != 0 } } impl TCB0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TCB0_A { match self . bits { false => TCB0_A :: DEFAULT , true => TCB0_A :: ALTERNATE , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TCB0_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALTERNATE`"]
# [inline (always)]
pub fn is_alternate (& self) -> bool { * self == TCB0_A :: ALTERNATE } } # [doc = "Field `TCB0` writer - Port Multiplexer TCB"]
pub type TCB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , TCB0_A , O > ; impl < 'a , const O : u8 > TCB0_W < 'a , O > { # [doc = "Default pin"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TCB0_A :: DEFAULT) } # [doc = "Alternate pin"]
# [inline (always)]
pub fn alternate (self) -> & 'a mut W { self . variant (TCB0_A :: ALTERNATE) } } impl R { # [doc = "Bit 0 - Port Multiplexer TCB"]
# [inline (always)]
pub fn tcb0 (& self) -> TCB0_R { TCB0_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Multiplexer TCB"]
# [inline (always)]
# [must_use]
pub fn tcb0 (& mut self) -> TCB0_W < 0 > { TCB0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Reset controller"]
pub struct RSTCTRL { _marker : PhantomData < * const () > } unsafe impl Send for RSTCTRL { } impl RSTCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const rstctrl :: RegisterBlock = 0x40 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rstctrl :: RegisterBlock { Self :: PTR } } impl Deref for RSTCTRL { type Target = rstctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RSTCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RSTCTRL") . finish () } } # [doc = "Reset controller"]
pub mod rstctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Reset Flags"]
pub rstfr : RSTFR , # [doc = "0x01 - Software Reset"]
pub swrr : SWRR , } # [doc = "RSTFR (rw) register accessor: an alias for `Reg<RSTFR_SPEC>`"]
pub type RSTFR = crate :: Reg < rstfr :: RSTFR_SPEC > ; # [doc = "Reset Flags"]
pub mod rstfr { # [doc = "Register `RSTFR` reader"]
pub struct R (crate :: R < RSTFR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RSTFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RSTFR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RSTFR_SPEC >) -> Self { R (reader) } } # [doc = "Register `RSTFR` writer"]
pub struct W (crate :: W < RSTFR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RSTFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RSTFR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RSTFR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PORF` reader - Power on Reset flag"]
pub type PORF_R = crate :: BitReader < bool > ; # [doc = "Field `PORF` writer - Power on Reset flag"]
pub type PORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `BORF` reader - Brown out detector Reset flag"]
pub type BORF_R = crate :: BitReader < bool > ; # [doc = "Field `BORF` writer - Brown out detector Reset flag"]
pub type BORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `EXTRF` reader - External Reset flag"]
pub type EXTRF_R = crate :: BitReader < bool > ; # [doc = "Field `EXTRF` writer - External Reset flag"]
pub type EXTRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `WDRF` reader - Watch dog Reset flag"]
pub type WDRF_R = crate :: BitReader < bool > ; # [doc = "Field `WDRF` writer - Watch dog Reset flag"]
pub type WDRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `SWRF` reader - Software Reset flag"]
pub type SWRF_R = crate :: BitReader < bool > ; # [doc = "Field `SWRF` writer - Software Reset flag"]
pub type SWRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `UPDIRF` reader - UPDI Reset flag"]
pub type UPDIRF_R = crate :: BitReader < bool > ; # [doc = "Field `UPDIRF` writer - UPDI Reset flag"]
pub type UPDIRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Power on Reset flag"]
# [inline (always)]
pub fn porf (& self) -> PORF_R { PORF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Brown out detector Reset flag"]
# [inline (always)]
pub fn borf (& self) -> BORF_R { BORF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - External Reset flag"]
# [inline (always)]
pub fn extrf (& self) -> EXTRF_R { EXTRF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Watch dog Reset flag"]
# [inline (always)]
pub fn wdrf (& self) -> WDRF_R { WDRF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Software Reset flag"]
# [inline (always)]
pub fn swrf (& self) -> SWRF_R { SWRF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - UPDI Reset flag"]
# [inline (always)]
pub fn updirf (& self) -> UPDIRF_R { UPDIRF_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Power on Reset flag"]
# [inline (always)]
# [must_use]
pub fn porf (& mut self) -> PORF_W < 0 > { PORF_W :: new (self) } # [doc = "Bit 1 - Brown out detector Reset flag"]
# [inline (always)]
# [must_use]
pub fn borf (& mut self) -> BORF_W < 1 > { BORF_W :: new (self) } # [doc = "Bit 2 - External Reset flag"]
# [inline (always)]
# [must_use]
pub fn extrf (& mut self) -> EXTRF_W < 2 > { EXTRF_W :: new (self) } # [doc = "Bit 3 - Watch dog Reset flag"]
# [inline (always)]
# [must_use]
pub fn wdrf (& mut self) -> WDRF_W < 3 > { WDRF_W :: new (self) } # [doc = "Bit 4 - Software Reset flag"]
# [inline (always)]
# [must_use]
pub fn swrf (& mut self) -> SWRF_W < 4 > { SWRF_W :: new (self) } # [doc = "Bit 5 - UPDI Reset flag"]
# [inline (always)]
# [must_use]
pub fn updirf (& mut self) -> UPDIRF_W < 5 > { UPDIRF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Reset Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rstfr](index.html) module"]
pub struct RSTFR_SPEC ; impl crate :: RegisterSpec for RSTFR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rstfr::R](R) reader structure"]
impl crate :: Readable for RSTFR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rstfr::W](W) writer structure"]
impl crate :: Writable for RSTFR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RSTFR to value 0"]
impl crate :: Resettable for RSTFR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SWRR (rw) register accessor: an alias for `Reg<SWRR_SPEC>`"]
pub type SWRR = crate :: Reg < swrr :: SWRR_SPEC > ; # [doc = "Software Reset"]
pub mod swrr { # [doc = "Register `SWRR` reader"]
pub struct R (crate :: R < SWRR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SWRR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SWRR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SWRR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SWRR` writer"]
pub struct W (crate :: W < SWRR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SWRR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SWRR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SWRR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRE` reader - Software reset enable"]
pub type SWRE_R = crate :: BitReader < bool > ; # [doc = "Field `SWRE` writer - Software reset enable"]
pub type SWRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SWRR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Software reset enable"]
# [inline (always)]
pub fn swre (& self) -> SWRE_R { SWRE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Software reset enable"]
# [inline (always)]
# [must_use]
pub fn swre (& mut self) -> SWRE_W < 0 > { SWRE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Software Reset\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swrr](index.html) module"]
pub struct SWRR_SPEC ; impl crate :: RegisterSpec for SWRR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [swrr::R](R) reader structure"]
impl crate :: Readable for SWRR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [swrr::W](W) writer structure"]
impl crate :: Writable for SWRR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SWRR to value 0"]
impl crate :: Resettable for SWRR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Real-Time Counter"]
pub struct RTC { _marker : PhantomData < * const () > } unsafe impl Send for RTC { } impl RTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const rtc :: RegisterBlock = 0x0140 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rtc :: RegisterBlock { Self :: PTR } } impl Deref for RTC { type Target = rtc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RTC") . finish () } } # [doc = "Real-Time Counter"]
pub mod rtc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Status"]
pub status : STATUS , # [doc = "0x02 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x04 - Temporary"]
pub temp : TEMP , # [doc = "0x05 - Debug control"]
pub dbgctrl : DBGCTRL , _reserved6 : [u8 ; 0x01]
, # [doc = "0x07 - Clock Select"]
pub clksel : CLKSEL , # [doc = "0x08 - Counter"]
pub cnt : CNT , # [doc = "0x0a - Period"]
pub per : PER , # [doc = "0x0c - Compare"]
pub cmp : CMP , _reserved10 : [u8 ; 0x02]
, # [doc = "0x10 - PIT Control A"]
pub pitctrla : PITCTRLA , # [doc = "0x11 - PIT Status"]
pub pitstatus : PITSTATUS , # [doc = "0x12 - PIT Interrupt Control"]
pub pitintctrl : PITINTCTRL , # [doc = "0x13 - PIT Interrupt Flags"]
pub pitintflags : PITINTFLAGS , _reserved14 : [u8 ; 0x01]
, # [doc = "0x15 - PIT Debug control"]
pub pitdbgctrl : PITDBGCTRL , } # [doc = "CLKSEL (rw) register accessor: an alias for `Reg<CLKSEL_SPEC>`"]
pub type CLKSEL = crate :: Reg < clksel :: CLKSEL_SPEC > ; # [doc = "Clock Select"]
pub mod clksel { # [doc = "Register `CLKSEL` reader"]
pub struct R (crate :: R < CLKSEL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKSEL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKSEL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKSEL` writer"]
pub struct W (crate :: W < CLKSEL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKSEL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKSEL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Internal 32kHz OSC"]
INT32K = 0 , # [doc = "1: Internal 1kHz OSC"]
INT1K = 1 , # [doc = "2: 32KHz Crystal OSC"]
TOSC32K = 2 , # [doc = "3: External Clock"]
EXTCLK = 3 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: INT32K , 1 => CLKSEL_A :: INT1K , 2 => CLKSEL_A :: TOSC32K , 3 => CLKSEL_A :: EXTCLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT32K`"]
# [inline (always)]
pub fn is_int32k (& self) -> bool { * self == CLKSEL_A :: INT32K } # [doc = "Checks if the value of the field is `INT1K`"]
# [inline (always)]
pub fn is_int1k (& self) -> bool { * self == CLKSEL_A :: INT1K } # [doc = "Checks if the value of the field is `TOSC32K`"]
# [inline (always)]
pub fn is_tosc32k (& self) -> bool { * self == CLKSEL_A :: TOSC32K } # [doc = "Checks if the value of the field is `EXTCLK`"]
# [inline (always)]
pub fn is_extclk (& self) -> bool { * self == CLKSEL_A :: EXTCLK } } # [doc = "Field `CLKSEL` writer - Clock Select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CLKSEL_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Internal 32kHz OSC"]
# [inline (always)]
pub fn int32k (self) -> & 'a mut W { self . variant (CLKSEL_A :: INT32K) } # [doc = "Internal 1kHz OSC"]
# [inline (always)]
pub fn int1k (self) -> & 'a mut W { self . variant (CLKSEL_A :: INT1K) } # [doc = "32KHz Crystal OSC"]
# [inline (always)]
pub fn tosc32k (self) -> & 'a mut W { self . variant (CLKSEL_A :: TOSC32K) } # [doc = "External Clock"]
# [inline (always)]
pub fn extclk (self) -> & 'a mut W { self . variant (CLKSEL_A :: EXTCLK) } } impl R { # [doc = "Bits 0:1 - Clock Select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clksel](index.html) module"]
pub struct CLKSEL_SPEC ; impl crate :: RegisterSpec for CLKSEL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [clksel::R](R) reader structure"]
impl crate :: Readable for CLKSEL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clksel::W](W) writer structure"]
impl crate :: Writable for CLKSEL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CLKSEL to value 0"]
impl crate :: Resettable for CLKSEL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP (rw) register accessor: an alias for `Reg<CMP_SPEC>`"]
pub type CMP = crate :: Reg < cmp :: CMP_SPEC > ; # [doc = "Compare"]
pub mod cmp { # [doc = "Register `CMP` reader"]
pub struct R (crate :: R < CMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP` writer"]
pub struct W (crate :: W < CMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp](index.html) module"]
pub struct CMP_SPEC ; impl crate :: RegisterSpec for CMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp::R](R) reader structure"]
impl crate :: Readable for CMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp::W](W) writer structure"]
impl crate :: Writable for CMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP to value 0"]
impl crate :: Resettable for CMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Counter"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RTCEN` reader - Enable"]
pub type RTCEN_R = crate :: BitReader < bool > ; # [doc = "Field `RTCEN` writer - Enable"]
pub type RTCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `PRESCALER` reader - Prescaling Factor"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Prescaling Factor\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: RTC Clock / 1"]
DIV1 = 0 , # [doc = "1: RTC Clock / 2"]
DIV2 = 1 , # [doc = "2: RTC Clock / 4"]
DIV4 = 2 , # [doc = "3: RTC Clock / 8"]
DIV8 = 3 , # [doc = "4: RTC Clock / 16"]
DIV16 = 4 , # [doc = "5: RTC Clock / 32"]
DIV32 = 5 , # [doc = "6: RTC Clock / 64"]
DIV64 = 6 , # [doc = "7: RTC Clock / 128"]
DIV128 = 7 , # [doc = "8: RTC Clock / 256"]
DIV256 = 8 , # [doc = "9: RTC Clock / 512"]
DIV512 = 9 , # [doc = "10: RTC Clock / 1024"]
DIV1024 = 10 , # [doc = "11: RTC Clock / 2048"]
DIV2048 = 11 , # [doc = "12: RTC Clock / 4096"]
DIV4096 = 12 , # [doc = "13: RTC Clock / 8192"]
DIV8192 = 13 , # [doc = "14: RTC Clock / 16384"]
DIV16384 = 14 , # [doc = "15: RTC Clock / 32768"]
DIV32768 = 15 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV32 , 6 => PRESCALER_A :: DIV64 , 7 => PRESCALER_A :: DIV128 , 8 => PRESCALER_A :: DIV256 , 9 => PRESCALER_A :: DIV512 , 10 => PRESCALER_A :: DIV1024 , 11 => PRESCALER_A :: DIV2048 , 12 => PRESCALER_A :: DIV4096 , 13 => PRESCALER_A :: DIV8192 , 14 => PRESCALER_A :: DIV16384 , 15 => PRESCALER_A :: DIV32768 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESCALER_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PRESCALER_A :: DIV512 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } # [doc = "Checks if the value of the field is `DIV2048`"]
# [inline (always)]
pub fn is_div2048 (& self) -> bool { * self == PRESCALER_A :: DIV2048 } # [doc = "Checks if the value of the field is `DIV4096`"]
# [inline (always)]
pub fn is_div4096 (& self) -> bool { * self == PRESCALER_A :: DIV4096 } # [doc = "Checks if the value of the field is `DIV8192`"]
# [inline (always)]
pub fn is_div8192 (& self) -> bool { * self == PRESCALER_A :: DIV8192 } # [doc = "Checks if the value of the field is `DIV16384`"]
# [inline (always)]
pub fn is_div16384 (& self) -> bool { * self == PRESCALER_A :: DIV16384 } # [doc = "Checks if the value of the field is `DIV32768`"]
# [inline (always)]
pub fn is_div32768 (& self) -> bool { * self == PRESCALER_A :: DIV32768 } } # [doc = "Field `PRESCALER` writer - Prescaling Factor"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , PRESCALER_A , 4 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "RTC Clock / 1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "RTC Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "RTC Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "RTC Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "RTC Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "RTC Clock / 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32) } # [doc = "RTC Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "RTC Clock / 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } # [doc = "RTC Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "RTC Clock / 512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV512) } # [doc = "RTC Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } # [doc = "RTC Clock / 2048"]
# [inline (always)]
pub fn div2048 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2048) } # [doc = "RTC Clock / 4096"]
# [inline (always)]
pub fn div4096 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4096) } # [doc = "RTC Clock / 8192"]
# [inline (always)]
pub fn div8192 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8192) } # [doc = "RTC Clock / 16384"]
# [inline (always)]
pub fn div16384 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16384) } # [doc = "RTC Clock / 32768"]
# [inline (always)]
pub fn div32768 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32768) } } # [doc = "Field `RUNSTDBY` reader - Run In Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run In Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn rtcen (& self) -> RTCEN_R { RTCEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 3:6 - Prescaling Factor"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new ((self . bits >> 3) & 0x0f) } # [doc = "Bit 7 - Run In Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn rtcen (& mut self) -> RTCEN_W < 0 > { RTCEN_W :: new (self) } # [doc = "Bits 3:6 - Prescaling Factor"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 3 > { PRESCALER_W :: new (self) } # [doc = "Bit 7 - Run In Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 7 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Run in debug"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Run in debug"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Run in debug"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Run in debug"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt enable"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `CMP` reader - Compare Match Interrupt enable"]
pub type CMP_R = crate :: BitReader < bool > ; # [doc = "Field `CMP` writer - Compare Match Interrupt enable"]
pub type CMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare Match Interrupt enable"]
# [inline (always)]
pub fn cmp (& self) -> CMP_R { CMP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt enable"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 1 - Compare Match Interrupt enable"]
# [inline (always)]
# [must_use]
pub fn cmp (& mut self) -> CMP_W < 1 > { CMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Flag"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Flag"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CMP` reader - Compare Match Interrupt"]
pub type CMP_R = crate :: BitReader < bool > ; # [doc = "Field `CMP` writer - Compare Match Interrupt"]
pub type CMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare Match Interrupt"]
# [inline (always)]
pub fn cmp (& self) -> CMP_R { CMP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 1 - Compare Match Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp (& mut self) -> CMP_W < 1 > { CMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITCTRLA (rw) register accessor: an alias for `Reg<PITCTRLA_SPEC>`"]
pub type PITCTRLA = crate :: Reg < pitctrla :: PITCTRLA_SPEC > ; # [doc = "PIT Control A"]
pub mod pitctrla { # [doc = "Register `PITCTRLA` reader"]
pub struct R (crate :: R < PITCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `PITCTRLA` writer"]
pub struct W (crate :: W < PITCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PITCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PITCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PITCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `PITEN` reader - Enable"]
pub type PITEN_R = crate :: BitReader < bool > ; # [doc = "Field `PITEN` writer - Enable"]
pub type PITEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PITCTRLA_SPEC , bool , O > ; # [doc = "Field `PERIOD` reader - Period"]
pub type PERIOD_R = crate :: FieldReader < u8 , PERIOD_A > ; # [doc = "Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PERIOD_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: RTC Clock Cycles 4"]
CYC4 = 1 , # [doc = "2: RTC Clock Cycles 8"]
CYC8 = 2 , # [doc = "3: RTC Clock Cycles 16"]
CYC16 = 3 , # [doc = "4: RTC Clock Cycles 32"]
CYC32 = 4 , # [doc = "5: RTC Clock Cycles 64"]
CYC64 = 5 , # [doc = "6: RTC Clock Cycles 128"]
CYC128 = 6 , # [doc = "7: RTC Clock Cycles 256"]
CYC256 = 7 , # [doc = "8: RTC Clock Cycles 512"]
CYC512 = 8 , # [doc = "9: RTC Clock Cycles 1024"]
CYC1024 = 9 , # [doc = "10: RTC Clock Cycles 2048"]
CYC2048 = 10 , # [doc = "11: RTC Clock Cycles 4096"]
CYC4096 = 11 , # [doc = "12: RTC Clock Cycles 8192"]
CYC8192 = 12 , # [doc = "13: RTC Clock Cycles 16384"]
CYC16384 = 13 , # [doc = "14: RTC Clock Cycles 32768"]
CYC32768 = 14 , } impl From < PERIOD_A > for u8 { # [inline (always)]
fn from (variant : PERIOD_A) -> Self { variant as _ } } impl PERIOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PERIOD_A > { match self . bits { 0 => Some (PERIOD_A :: OFF) , 1 => Some (PERIOD_A :: CYC4) , 2 => Some (PERIOD_A :: CYC8) , 3 => Some (PERIOD_A :: CYC16) , 4 => Some (PERIOD_A :: CYC32) , 5 => Some (PERIOD_A :: CYC64) , 6 => Some (PERIOD_A :: CYC128) , 7 => Some (PERIOD_A :: CYC256) , 8 => Some (PERIOD_A :: CYC512) , 9 => Some (PERIOD_A :: CYC1024) , 10 => Some (PERIOD_A :: CYC2048) , 11 => Some (PERIOD_A :: CYC4096) , 12 => Some (PERIOD_A :: CYC8192) , 13 => Some (PERIOD_A :: CYC16384) , 14 => Some (PERIOD_A :: CYC32768) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == PERIOD_A :: OFF } # [doc = "Checks if the value of the field is `CYC4`"]
# [inline (always)]
pub fn is_cyc4 (& self) -> bool { * self == PERIOD_A :: CYC4 } # [doc = "Checks if the value of the field is `CYC8`"]
# [inline (always)]
pub fn is_cyc8 (& self) -> bool { * self == PERIOD_A :: CYC8 } # [doc = "Checks if the value of the field is `CYC16`"]
# [inline (always)]
pub fn is_cyc16 (& self) -> bool { * self == PERIOD_A :: CYC16 } # [doc = "Checks if the value of the field is `CYC32`"]
# [inline (always)]
pub fn is_cyc32 (& self) -> bool { * self == PERIOD_A :: CYC32 } # [doc = "Checks if the value of the field is `CYC64`"]
# [inline (always)]
pub fn is_cyc64 (& self) -> bool { * self == PERIOD_A :: CYC64 } # [doc = "Checks if the value of the field is `CYC128`"]
# [inline (always)]
pub fn is_cyc128 (& self) -> bool { * self == PERIOD_A :: CYC128 } # [doc = "Checks if the value of the field is `CYC256`"]
# [inline (always)]
pub fn is_cyc256 (& self) -> bool { * self == PERIOD_A :: CYC256 } # [doc = "Checks if the value of the field is `CYC512`"]
# [inline (always)]
pub fn is_cyc512 (& self) -> bool { * self == PERIOD_A :: CYC512 } # [doc = "Checks if the value of the field is `CYC1024`"]
# [inline (always)]
pub fn is_cyc1024 (& self) -> bool { * self == PERIOD_A :: CYC1024 } # [doc = "Checks if the value of the field is `CYC2048`"]
# [inline (always)]
pub fn is_cyc2048 (& self) -> bool { * self == PERIOD_A :: CYC2048 } # [doc = "Checks if the value of the field is `CYC4096`"]
# [inline (always)]
pub fn is_cyc4096 (& self) -> bool { * self == PERIOD_A :: CYC4096 } # [doc = "Checks if the value of the field is `CYC8192`"]
# [inline (always)]
pub fn is_cyc8192 (& self) -> bool { * self == PERIOD_A :: CYC8192 } # [doc = "Checks if the value of the field is `CYC16384`"]
# [inline (always)]
pub fn is_cyc16384 (& self) -> bool { * self == PERIOD_A :: CYC16384 } # [doc = "Checks if the value of the field is `CYC32768`"]
# [inline (always)]
pub fn is_cyc32768 (& self) -> bool { * self == PERIOD_A :: CYC32768 } } # [doc = "Field `PERIOD` writer - Period"]
pub type PERIOD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PITCTRLA_SPEC , u8 , PERIOD_A , 4 , O > ; impl < 'a , const O : u8 > PERIOD_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (PERIOD_A :: OFF) } # [doc = "RTC Clock Cycles 4"]
# [inline (always)]
pub fn cyc4 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC4) } # [doc = "RTC Clock Cycles 8"]
# [inline (always)]
pub fn cyc8 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC8) } # [doc = "RTC Clock Cycles 16"]
# [inline (always)]
pub fn cyc16 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC16) } # [doc = "RTC Clock Cycles 32"]
# [inline (always)]
pub fn cyc32 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC32) } # [doc = "RTC Clock Cycles 64"]
# [inline (always)]
pub fn cyc64 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC64) } # [doc = "RTC Clock Cycles 128"]
# [inline (always)]
pub fn cyc128 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC128) } # [doc = "RTC Clock Cycles 256"]
# [inline (always)]
pub fn cyc256 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC256) } # [doc = "RTC Clock Cycles 512"]
# [inline (always)]
pub fn cyc512 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC512) } # [doc = "RTC Clock Cycles 1024"]
# [inline (always)]
pub fn cyc1024 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC1024) } # [doc = "RTC Clock Cycles 2048"]
# [inline (always)]
pub fn cyc2048 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC2048) } # [doc = "RTC Clock Cycles 4096"]
# [inline (always)]
pub fn cyc4096 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC4096) } # [doc = "RTC Clock Cycles 8192"]
# [inline (always)]
pub fn cyc8192 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC8192) } # [doc = "RTC Clock Cycles 16384"]
# [inline (always)]
pub fn cyc16384 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC16384) } # [doc = "RTC Clock Cycles 32768"]
# [inline (always)]
pub fn cyc32768 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC32768) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn piten (& self) -> PITEN_R { PITEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 3:6 - Period"]
# [inline (always)]
pub fn period (& self) -> PERIOD_R { PERIOD_R :: new ((self . bits >> 3) & 0x0f) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn piten (& mut self) -> PITEN_W < 0 > { PITEN_W :: new (self) } # [doc = "Bits 3:6 - Period"]
# [inline (always)]
# [must_use]
pub fn period (& mut self) -> PERIOD_W < 3 > { PERIOD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PIT Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitctrla](index.html) module"]
pub struct PITCTRLA_SPEC ; impl crate :: RegisterSpec for PITCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitctrla::R](R) reader structure"]
impl crate :: Readable for PITCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pitctrla::W](W) writer structure"]
impl crate :: Writable for PITCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PITCTRLA to value 0"]
impl crate :: Resettable for PITCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITDBGCTRL (rw) register accessor: an alias for `Reg<PITDBGCTRL_SPEC>`"]
pub type PITDBGCTRL = crate :: Reg < pitdbgctrl :: PITDBGCTRL_SPEC > ; # [doc = "PIT Debug control"]
pub mod pitdbgctrl { # [doc = "Register `PITDBGCTRL` reader"]
pub struct R (crate :: R < PITDBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITDBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITDBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITDBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PITDBGCTRL` writer"]
pub struct W (crate :: W < PITDBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PITDBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PITDBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PITDBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Run in debug"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Run in debug"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PITDBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Run in debug"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Run in debug"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PIT Debug control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitdbgctrl](index.html) module"]
pub struct PITDBGCTRL_SPEC ; impl crate :: RegisterSpec for PITDBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitdbgctrl::R](R) reader structure"]
impl crate :: Readable for PITDBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pitdbgctrl::W](W) writer structure"]
impl crate :: Writable for PITDBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PITDBGCTRL to value 0"]
impl crate :: Resettable for PITDBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITINTCTRL (rw) register accessor: an alias for `Reg<PITINTCTRL_SPEC>`"]
pub type PITINTCTRL = crate :: Reg < pitintctrl :: PITINTCTRL_SPEC > ; # [doc = "PIT Interrupt Control"]
pub mod pitintctrl { # [doc = "Register `PITINTCTRL` reader"]
pub struct R (crate :: R < PITINTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITINTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITINTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITINTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PITINTCTRL` writer"]
pub struct W (crate :: W < PITINTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PITINTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PITINTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PITINTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PI` reader - Periodic Interrupt"]
pub type PI_R = crate :: BitReader < bool > ; # [doc = "Field `PI` writer - Periodic Interrupt"]
pub type PI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PITINTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Periodic Interrupt"]
# [inline (always)]
pub fn pi (& self) -> PI_R { PI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Periodic Interrupt"]
# [inline (always)]
# [must_use]
pub fn pi (& mut self) -> PI_W < 0 > { PI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PIT Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitintctrl](index.html) module"]
pub struct PITINTCTRL_SPEC ; impl crate :: RegisterSpec for PITINTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitintctrl::R](R) reader structure"]
impl crate :: Readable for PITINTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pitintctrl::W](W) writer structure"]
impl crate :: Writable for PITINTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PITINTCTRL to value 0"]
impl crate :: Resettable for PITINTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITINTFLAGS (rw) register accessor: an alias for `Reg<PITINTFLAGS_SPEC>`"]
pub type PITINTFLAGS = crate :: Reg < pitintflags :: PITINTFLAGS_SPEC > ; # [doc = "PIT Interrupt Flags"]
pub mod pitintflags { # [doc = "Register `PITINTFLAGS` reader"]
pub struct R (crate :: R < PITINTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITINTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITINTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITINTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `PITINTFLAGS` writer"]
pub struct W (crate :: W < PITINTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PITINTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PITINTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PITINTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PI` reader - Periodic Interrupt"]
pub type PI_R = crate :: BitReader < bool > ; # [doc = "Field `PI` writer - Periodic Interrupt"]
pub type PI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PITINTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Periodic Interrupt"]
# [inline (always)]
pub fn pi (& self) -> PI_R { PI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Periodic Interrupt"]
# [inline (always)]
# [must_use]
pub fn pi (& mut self) -> PI_W < 0 > { PI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PIT Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitintflags](index.html) module"]
pub struct PITINTFLAGS_SPEC ; impl crate :: RegisterSpec for PITINTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitintflags::R](R) reader structure"]
impl crate :: Readable for PITINTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pitintflags::W](W) writer structure"]
impl crate :: Writable for PITINTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PITINTFLAGS to value 0"]
impl crate :: Resettable for PITINTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITSTATUS (r) register accessor: an alias for `Reg<PITSTATUS_SPEC>`"]
pub type PITSTATUS = crate :: Reg < pitstatus :: PITSTATUS_SPEC > ; # [doc = "PIT Status"]
pub mod pitstatus { # [doc = "Register `PITSTATUS` reader"]
pub struct R (crate :: R < PITSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `CTRLBUSY` reader - CTRLA Synchronization Busy Flag"]
pub type CTRLBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - CTRLA Synchronization Busy Flag"]
# [inline (always)]
pub fn ctrlbusy (& self) -> CTRLBUSY_R { CTRLBUSY_R :: new ((self . bits & 1) != 0) } } # [doc = "PIT Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitstatus](index.html) module"]
pub struct PITSTATUS_SPEC ; impl crate :: RegisterSpec for PITSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitstatus::R](R) reader structure"]
impl crate :: Readable for PITSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PITSTATUS to value 0"]
impl crate :: Resettable for PITSTATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `CTRLABUSY` reader - CTRLA Synchronization Busy Flag"]
pub type CTRLABUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CNTBUSY` reader - Count Synchronization Busy Flag"]
pub type CNTBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `PERBUSY` reader - Period Synchronization Busy Flag"]
pub type PERBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CMPBUSY` reader - Comparator Synchronization Busy Flag"]
pub type CMPBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - CTRLA Synchronization Busy Flag"]
# [inline (always)]
pub fn ctrlabusy (& self) -> CTRLABUSY_R { CTRLABUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Count Synchronization Busy Flag"]
# [inline (always)]
pub fn cntbusy (& self) -> CNTBUSY_R { CNTBUSY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Period Synchronization Busy Flag"]
# [inline (always)]
pub fn perbusy (& self) -> PERBUSY_R { PERBUSY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Comparator Synchronization Busy Flag"]
# [inline (always)]
pub fn cmpbusy (& self) -> CMPBUSY_R { CMPBUSY_R :: new (((self . bits >> 3) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Signature row"]
pub struct SIGROW { _marker : PhantomData < * const () > } unsafe impl Send for SIGROW { } impl SIGROW { # [doc = r"Pointer to the register block"]
pub const PTR : * const sigrow :: RegisterBlock = 0x1100 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sigrow :: RegisterBlock { Self :: PTR } } impl Deref for SIGROW { type Target = sigrow :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SIGROW { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SIGROW") . finish () } } # [doc = "Signature row"]
pub mod sigrow { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Device ID Byte 0"]
pub deviceid0 : DEVICEID0 , # [doc = "0x01 - Device ID Byte 1"]
pub deviceid1 : DEVICEID1 , # [doc = "0x02 - Device ID Byte 2"]
pub deviceid2 : DEVICEID2 , # [doc = "0x03 - Serial Number Byte 0"]
pub sernum0 : SERNUM0 , # [doc = "0x04 - Serial Number Byte 1"]
pub sernum1 : SERNUM1 , # [doc = "0x05 - Serial Number Byte 2"]
pub sernum2 : SERNUM2 , # [doc = "0x06 - Serial Number Byte 3"]
pub sernum3 : SERNUM3 , # [doc = "0x07 - Serial Number Byte 4"]
pub sernum4 : SERNUM4 , # [doc = "0x08 - Serial Number Byte 5"]
pub sernum5 : SERNUM5 , # [doc = "0x09 - Serial Number Byte 6"]
pub sernum6 : SERNUM6 , # [doc = "0x0a - Serial Number Byte 7"]
pub sernum7 : SERNUM7 , # [doc = "0x0b - Serial Number Byte 8"]
pub sernum8 : SERNUM8 , # [doc = "0x0c - Serial Number Byte 9"]
pub sernum9 : SERNUM9 , _reserved13 : [u8 ; 0x13]
, # [doc = "0x20 - Temperature Sensor Calibration Byte 0"]
pub tempsense0 : TEMPSENSE0 , # [doc = "0x21 - Temperature Sensor Calibration Byte 1"]
pub tempsense1 : TEMPSENSE1 , # [doc = "0x22 - OSC16 error at 3V"]
pub osc16err3v : OSC16ERR3V , # [doc = "0x23 - OSC16 error at 5V"]
pub osc16err5v : OSC16ERR5V , # [doc = "0x24 - OSC20 error at 3V"]
pub osc20err3v : OSC20ERR3V , # [doc = "0x25 - OSC20 error at 5V"]
pub osc20err5v : OSC20ERR5V , } # [doc = "DEVICEID0 (r) register accessor: an alias for `Reg<DEVICEID0_SPEC>`"]
pub type DEVICEID0 = crate :: Reg < deviceid0 :: DEVICEID0_SPEC > ; # [doc = "Device ID Byte 0"]
pub mod deviceid0 { # [doc = "Register `DEVICEID0` reader"]
pub struct R (crate :: R < DEVICEID0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVICEID0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVICEID0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVICEID0_SPEC >) -> Self { R (reader) } } # [doc = "Device ID Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [deviceid0](index.html) module"]
pub struct DEVICEID0_SPEC ; impl crate :: RegisterSpec for DEVICEID0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [deviceid0::R](R) reader structure"]
impl crate :: Readable for DEVICEID0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVICEID0 to value 0"]
impl crate :: Resettable for DEVICEID0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DEVICEID1 (r) register accessor: an alias for `Reg<DEVICEID1_SPEC>`"]
pub type DEVICEID1 = crate :: Reg < deviceid1 :: DEVICEID1_SPEC > ; # [doc = "Device ID Byte 1"]
pub mod deviceid1 { # [doc = "Register `DEVICEID1` reader"]
pub struct R (crate :: R < DEVICEID1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVICEID1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVICEID1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVICEID1_SPEC >) -> Self { R (reader) } } # [doc = "Device ID Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [deviceid1](index.html) module"]
pub struct DEVICEID1_SPEC ; impl crate :: RegisterSpec for DEVICEID1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [deviceid1::R](R) reader structure"]
impl crate :: Readable for DEVICEID1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVICEID1 to value 0"]
impl crate :: Resettable for DEVICEID1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DEVICEID2 (r) register accessor: an alias for `Reg<DEVICEID2_SPEC>`"]
pub type DEVICEID2 = crate :: Reg < deviceid2 :: DEVICEID2_SPEC > ; # [doc = "Device ID Byte 2"]
pub mod deviceid2 { # [doc = "Register `DEVICEID2` reader"]
pub struct R (crate :: R < DEVICEID2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVICEID2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVICEID2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVICEID2_SPEC >) -> Self { R (reader) } } # [doc = "Device ID Byte 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [deviceid2](index.html) module"]
pub struct DEVICEID2_SPEC ; impl crate :: RegisterSpec for DEVICEID2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [deviceid2::R](R) reader structure"]
impl crate :: Readable for DEVICEID2_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVICEID2 to value 0"]
impl crate :: Resettable for DEVICEID2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC16ERR3V (r) register accessor: an alias for `Reg<OSC16ERR3V_SPEC>`"]
pub type OSC16ERR3V = crate :: Reg < osc16err3v :: OSC16ERR3V_SPEC > ; # [doc = "OSC16 error at 3V"]
pub mod osc16err3v { # [doc = "Register `OSC16ERR3V` reader"]
pub struct R (crate :: R < OSC16ERR3V_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC16ERR3V_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC16ERR3V_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC16ERR3V_SPEC >) -> Self { R (reader) } } # [doc = "OSC16 error at 3V\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc16err3v](index.html) module"]
pub struct OSC16ERR3V_SPEC ; impl crate :: RegisterSpec for OSC16ERR3V_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc16err3v::R](R) reader structure"]
impl crate :: Readable for OSC16ERR3V_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSC16ERR3V to value 0"]
impl crate :: Resettable for OSC16ERR3V_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC16ERR5V (r) register accessor: an alias for `Reg<OSC16ERR5V_SPEC>`"]
pub type OSC16ERR5V = crate :: Reg < osc16err5v :: OSC16ERR5V_SPEC > ; # [doc = "OSC16 error at 5V"]
pub mod osc16err5v { # [doc = "Register `OSC16ERR5V` reader"]
pub struct R (crate :: R < OSC16ERR5V_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC16ERR5V_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC16ERR5V_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC16ERR5V_SPEC >) -> Self { R (reader) } } # [doc = "OSC16 error at 5V\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc16err5v](index.html) module"]
pub struct OSC16ERR5V_SPEC ; impl crate :: RegisterSpec for OSC16ERR5V_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc16err5v::R](R) reader structure"]
impl crate :: Readable for OSC16ERR5V_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSC16ERR5V to value 0"]
impl crate :: Resettable for OSC16ERR5V_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20ERR3V (r) register accessor: an alias for `Reg<OSC20ERR3V_SPEC>`"]
pub type OSC20ERR3V = crate :: Reg < osc20err3v :: OSC20ERR3V_SPEC > ; # [doc = "OSC20 error at 3V"]
pub mod osc20err3v { # [doc = "Register `OSC20ERR3V` reader"]
pub struct R (crate :: R < OSC20ERR3V_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20ERR3V_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20ERR3V_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20ERR3V_SPEC >) -> Self { R (reader) } } # [doc = "OSC20 error at 3V\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20err3v](index.html) module"]
pub struct OSC20ERR3V_SPEC ; impl crate :: RegisterSpec for OSC20ERR3V_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20err3v::R](R) reader structure"]
impl crate :: Readable for OSC20ERR3V_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSC20ERR3V to value 0"]
impl crate :: Resettable for OSC20ERR3V_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20ERR5V (r) register accessor: an alias for `Reg<OSC20ERR5V_SPEC>`"]
pub type OSC20ERR5V = crate :: Reg < osc20err5v :: OSC20ERR5V_SPEC > ; # [doc = "OSC20 error at 5V"]
pub mod osc20err5v { # [doc = "Register `OSC20ERR5V` reader"]
pub struct R (crate :: R < OSC20ERR5V_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20ERR5V_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20ERR5V_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20ERR5V_SPEC >) -> Self { R (reader) } } # [doc = "OSC20 error at 5V\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20err5v](index.html) module"]
pub struct OSC20ERR5V_SPEC ; impl crate :: RegisterSpec for OSC20ERR5V_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20err5v::R](R) reader structure"]
impl crate :: Readable for OSC20ERR5V_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSC20ERR5V to value 0"]
impl crate :: Resettable for OSC20ERR5V_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM0 (r) register accessor: an alias for `Reg<SERNUM0_SPEC>`"]
pub type SERNUM0 = crate :: Reg < sernum0 :: SERNUM0_SPEC > ; # [doc = "Serial Number Byte 0"]
pub mod sernum0 { # [doc = "Register `SERNUM0` reader"]
pub struct R (crate :: R < SERNUM0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM0_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum0](index.html) module"]
pub struct SERNUM0_SPEC ; impl crate :: RegisterSpec for SERNUM0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum0::R](R) reader structure"]
impl crate :: Readable for SERNUM0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM0 to value 0"]
impl crate :: Resettable for SERNUM0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM1 (r) register accessor: an alias for `Reg<SERNUM1_SPEC>`"]
pub type SERNUM1 = crate :: Reg < sernum1 :: SERNUM1_SPEC > ; # [doc = "Serial Number Byte 1"]
pub mod sernum1 { # [doc = "Register `SERNUM1` reader"]
pub struct R (crate :: R < SERNUM1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM1_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum1](index.html) module"]
pub struct SERNUM1_SPEC ; impl crate :: RegisterSpec for SERNUM1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum1::R](R) reader structure"]
impl crate :: Readable for SERNUM1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM1 to value 0"]
impl crate :: Resettable for SERNUM1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM2 (r) register accessor: an alias for `Reg<SERNUM2_SPEC>`"]
pub type SERNUM2 = crate :: Reg < sernum2 :: SERNUM2_SPEC > ; # [doc = "Serial Number Byte 2"]
pub mod sernum2 { # [doc = "Register `SERNUM2` reader"]
pub struct R (crate :: R < SERNUM2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM2_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum2](index.html) module"]
pub struct SERNUM2_SPEC ; impl crate :: RegisterSpec for SERNUM2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum2::R](R) reader structure"]
impl crate :: Readable for SERNUM2_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM2 to value 0"]
impl crate :: Resettable for SERNUM2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM3 (r) register accessor: an alias for `Reg<SERNUM3_SPEC>`"]
pub type SERNUM3 = crate :: Reg < sernum3 :: SERNUM3_SPEC > ; # [doc = "Serial Number Byte 3"]
pub mod sernum3 { # [doc = "Register `SERNUM3` reader"]
pub struct R (crate :: R < SERNUM3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM3_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 3\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum3](index.html) module"]
pub struct SERNUM3_SPEC ; impl crate :: RegisterSpec for SERNUM3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum3::R](R) reader structure"]
impl crate :: Readable for SERNUM3_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM3 to value 0"]
impl crate :: Resettable for SERNUM3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM4 (r) register accessor: an alias for `Reg<SERNUM4_SPEC>`"]
pub type SERNUM4 = crate :: Reg < sernum4 :: SERNUM4_SPEC > ; # [doc = "Serial Number Byte 4"]
pub mod sernum4 { # [doc = "Register `SERNUM4` reader"]
pub struct R (crate :: R < SERNUM4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM4_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 4\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum4](index.html) module"]
pub struct SERNUM4_SPEC ; impl crate :: RegisterSpec for SERNUM4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum4::R](R) reader structure"]
impl crate :: Readable for SERNUM4_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM4 to value 0"]
impl crate :: Resettable for SERNUM4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM5 (r) register accessor: an alias for `Reg<SERNUM5_SPEC>`"]
pub type SERNUM5 = crate :: Reg < sernum5 :: SERNUM5_SPEC > ; # [doc = "Serial Number Byte 5"]
pub mod sernum5 { # [doc = "Register `SERNUM5` reader"]
pub struct R (crate :: R < SERNUM5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM5_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 5\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum5](index.html) module"]
pub struct SERNUM5_SPEC ; impl crate :: RegisterSpec for SERNUM5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum5::R](R) reader structure"]
impl crate :: Readable for SERNUM5_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM5 to value 0"]
impl crate :: Resettable for SERNUM5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM6 (r) register accessor: an alias for `Reg<SERNUM6_SPEC>`"]
pub type SERNUM6 = crate :: Reg < sernum6 :: SERNUM6_SPEC > ; # [doc = "Serial Number Byte 6"]
pub mod sernum6 { # [doc = "Register `SERNUM6` reader"]
pub struct R (crate :: R < SERNUM6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM6_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 6\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum6](index.html) module"]
pub struct SERNUM6_SPEC ; impl crate :: RegisterSpec for SERNUM6_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum6::R](R) reader structure"]
impl crate :: Readable for SERNUM6_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM6 to value 0"]
impl crate :: Resettable for SERNUM6_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM7 (r) register accessor: an alias for `Reg<SERNUM7_SPEC>`"]
pub type SERNUM7 = crate :: Reg < sernum7 :: SERNUM7_SPEC > ; # [doc = "Serial Number Byte 7"]
pub mod sernum7 { # [doc = "Register `SERNUM7` reader"]
pub struct R (crate :: R < SERNUM7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM7_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 7\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum7](index.html) module"]
pub struct SERNUM7_SPEC ; impl crate :: RegisterSpec for SERNUM7_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum7::R](R) reader structure"]
impl crate :: Readable for SERNUM7_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM7 to value 0"]
impl crate :: Resettable for SERNUM7_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM8 (r) register accessor: an alias for `Reg<SERNUM8_SPEC>`"]
pub type SERNUM8 = crate :: Reg < sernum8 :: SERNUM8_SPEC > ; # [doc = "Serial Number Byte 8"]
pub mod sernum8 { # [doc = "Register `SERNUM8` reader"]
pub struct R (crate :: R < SERNUM8_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM8_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM8_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 8\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum8](index.html) module"]
pub struct SERNUM8_SPEC ; impl crate :: RegisterSpec for SERNUM8_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum8::R](R) reader structure"]
impl crate :: Readable for SERNUM8_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM8 to value 0"]
impl crate :: Resettable for SERNUM8_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM9 (r) register accessor: an alias for `Reg<SERNUM9_SPEC>`"]
pub type SERNUM9 = crate :: Reg < sernum9 :: SERNUM9_SPEC > ; # [doc = "Serial Number Byte 9"]
pub mod sernum9 { # [doc = "Register `SERNUM9` reader"]
pub struct R (crate :: R < SERNUM9_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM9_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM9_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 9\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum9](index.html) module"]
pub struct SERNUM9_SPEC ; impl crate :: RegisterSpec for SERNUM9_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum9::R](R) reader structure"]
impl crate :: Readable for SERNUM9_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM9 to value 0"]
impl crate :: Resettable for SERNUM9_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMPSENSE0 (r) register accessor: an alias for `Reg<TEMPSENSE0_SPEC>`"]
pub type TEMPSENSE0 = crate :: Reg < tempsense0 :: TEMPSENSE0_SPEC > ; # [doc = "Temperature Sensor Calibration Byte 0"]
pub mod tempsense0 { # [doc = "Register `TEMPSENSE0` reader"]
pub struct R (crate :: R < TEMPSENSE0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMPSENSE0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMPSENSE0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMPSENSE0_SPEC >) -> Self { R (reader) } } # [doc = "Temperature Sensor Calibration Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tempsense0](index.html) module"]
pub struct TEMPSENSE0_SPEC ; impl crate :: RegisterSpec for TEMPSENSE0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tempsense0::R](R) reader structure"]
impl crate :: Readable for TEMPSENSE0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets TEMPSENSE0 to value 0"]
impl crate :: Resettable for TEMPSENSE0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMPSENSE1 (r) register accessor: an alias for `Reg<TEMPSENSE1_SPEC>`"]
pub type TEMPSENSE1 = crate :: Reg < tempsense1 :: TEMPSENSE1_SPEC > ; # [doc = "Temperature Sensor Calibration Byte 1"]
pub mod tempsense1 { # [doc = "Register `TEMPSENSE1` reader"]
pub struct R (crate :: R < TEMPSENSE1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMPSENSE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMPSENSE1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMPSENSE1_SPEC >) -> Self { R (reader) } } # [doc = "Temperature Sensor Calibration Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tempsense1](index.html) module"]
pub struct TEMPSENSE1_SPEC ; impl crate :: RegisterSpec for TEMPSENSE1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tempsense1::R](R) reader structure"]
impl crate :: Readable for TEMPSENSE1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets TEMPSENSE1 to value 0"]
impl crate :: Resettable for TEMPSENSE1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Sleep Controller"]
pub struct SLPCTRL { _marker : PhantomData < * const () > } unsafe impl Send for SLPCTRL { } impl SLPCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const slpctrl :: RegisterBlock = 0x50 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const slpctrl :: RegisterBlock { Self :: PTR } } impl Deref for SLPCTRL { type Target = slpctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SLPCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SLPCTRL") . finish () } } # [doc = "Sleep Controller"]
pub mod slpctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrla : CTRLA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SEN` reader - Sleep enable"]
pub type SEN_R = crate :: BitReader < bool > ; # [doc = "Field `SEN` writer - Sleep enable"]
pub type SEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `SMODE` reader - Sleep mode"]
pub type SMODE_R = crate :: FieldReader < u8 , SMODE_A > ; # [doc = "Sleep mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SMODE_A { # [doc = "0: Idle mode"]
IDLE = 0 , # [doc = "1: Standby Mode"]
STDBY = 1 , # [doc = "2: Power-down Mode"]
PDOWN = 2 , } impl From < SMODE_A > for u8 { # [inline (always)]
fn from (variant : SMODE_A) -> Self { variant as _ } } impl SMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SMODE_A > { match self . bits { 0 => Some (SMODE_A :: IDLE) , 1 => Some (SMODE_A :: STDBY) , 2 => Some (SMODE_A :: PDOWN) , _ => None , } } # [doc = "Checks if the value of the field is `IDLE`"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == SMODE_A :: IDLE } # [doc = "Checks if the value of the field is `STDBY`"]
# [inline (always)]
pub fn is_stdby (& self) -> bool { * self == SMODE_A :: STDBY } # [doc = "Checks if the value of the field is `PDOWN`"]
# [inline (always)]
pub fn is_pdown (& self) -> bool { * self == SMODE_A :: PDOWN } } # [doc = "Field `SMODE` writer - Sleep mode"]
pub type SMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , SMODE_A , 2 , O > ; impl < 'a , const O : u8 > SMODE_W < 'a , O > { # [doc = "Idle mode"]
# [inline (always)]
pub fn idle (self) -> & 'a mut W { self . variant (SMODE_A :: IDLE) } # [doc = "Standby Mode"]
# [inline (always)]
pub fn stdby (self) -> & 'a mut W { self . variant (SMODE_A :: STDBY) } # [doc = "Power-down Mode"]
# [inline (always)]
pub fn pdown (self) -> & 'a mut W { self . variant (SMODE_A :: PDOWN) } } impl R { # [doc = "Bit 0 - Sleep enable"]
# [inline (always)]
pub fn sen (& self) -> SEN_R { SEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Sleep mode"]
# [inline (always)]
pub fn smode (& self) -> SMODE_R { SMODE_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - Sleep enable"]
# [inline (always)]
# [must_use]
pub fn sen (& mut self) -> SEN_W < 0 > { SEN_W :: new (self) } # [doc = "Bits 1:2 - Sleep mode"]
# [inline (always)]
# [must_use]
pub fn smode (& mut self) -> SMODE_W < 1 > { SMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct SPI0 { _marker : PhantomData < * const () > } unsafe impl Send for SPI0 { } impl SPI0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const spi0 :: RegisterBlock = 0x0820 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spi0 :: RegisterBlock { Self :: PTR } } impl Deref for SPI0 { type Target = spi0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPI0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPI0") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod spi0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x04 - Data"]
pub data : DATA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable Module"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable Module"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `PRESC` reader - Prescaler"]
pub type PRESC_R = crate :: FieldReader < u8 , PRESC_A > ; # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESC_A { # [doc = "0: System Clock / 4"]
DIV4 = 0 , # [doc = "1: System Clock / 16"]
DIV16 = 1 , # [doc = "2: System Clock / 64"]
DIV64 = 2 , # [doc = "3: System Clock / 128"]
DIV128 = 3 , } impl From < PRESC_A > for u8 { # [inline (always)]
fn from (variant : PRESC_A) -> Self { variant as _ } } impl PRESC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESC_A { match self . bits { 0 => PRESC_A :: DIV4 , 1 => PRESC_A :: DIV16 , 2 => PRESC_A :: DIV64 , 3 => PRESC_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESC_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESC_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESC_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESC_A :: DIV128 } } # [doc = "Field `PRESC` writer - Prescaler"]
pub type PRESC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , PRESC_A , 2 , O > ; impl < 'a , const O : u8 > PRESC_W < 'a , O > { # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV4) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV64) } # [doc = "System Clock / 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV128) } } # [doc = "Field `CLK2X` reader - Enable Double Speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Enable Double Speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `MASTER` reader - Host Operation Enable"]
pub type MASTER_R = crate :: BitReader < bool > ; # [doc = "Field `MASTER` writer - Host Operation Enable"]
pub type MASTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DORD` reader - Data Order Setting"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order Setting"]
pub type DORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable Module"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Prescaler"]
# [inline (always)]
pub fn presc (& self) -> PRESC_R { PRESC_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 4 - Enable Double Speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Host Operation Enable"]
# [inline (always)]
pub fn master (& self) -> MASTER_R { MASTER_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Data Order Setting"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable Module"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Prescaler"]
# [inline (always)]
# [must_use]
pub fn presc (& mut self) -> PRESC_W < 1 > { PRESC_W :: new (self) } # [doc = "Bit 4 - Enable Double Speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 4 > { CLK2X_W :: new (self) } # [doc = "Bit 5 - Host Operation Enable"]
# [inline (always)]
# [must_use]
pub fn master (& mut self) -> MASTER_W < 5 > { MASTER_W :: new (self) } # [doc = "Bit 6 - Data Order Setting"]
# [inline (always)]
# [must_use]
pub fn dord (& mut self) -> DORD_W < 6 > { DORD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MODE` reader - SPI Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; # [doc = "SPI Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: SPI Mode 0"]
_0 = 0 , # [doc = "1: SPI Mode 1"]
_1 = 1 , # [doc = "2: SPI Mode 2"]
_2 = 2 , # [doc = "3: SPI Mode 3"]
_3 = 3 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MODE_A { match self . bits { 0 => MODE_A :: _0 , 1 => MODE_A :: _1 , 2 => MODE_A :: _2 , 3 => MODE_A :: _3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == MODE_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == MODE_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == MODE_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == MODE_A :: _3 } } # [doc = "Field `MODE` writer - SPI Mode"]
pub type MODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , MODE_A , 2 , O > ; impl < 'a , const O : u8 > MODE_W < 'a , O > { # [doc = "SPI Mode 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (MODE_A :: _0) } # [doc = "SPI Mode 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (MODE_A :: _1) } # [doc = "SPI Mode 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (MODE_A :: _2) } # [doc = "SPI Mode 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (MODE_A :: _3) } } # [doc = "Field `SSD` reader - Client Select Disable"]
pub type SSD_R = crate :: BitReader < bool > ; # [doc = "Field `SSD` writer - Client Select Disable"]
pub type SSD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `BUFWR` reader - Buffer Write Mode"]
pub type BUFWR_R = crate :: BitReader < bool > ; # [doc = "Field `BUFWR` writer - Buffer Write Mode"]
pub type BUFWR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `BUFEN` reader - Buffer Mode Enable"]
pub type BUFEN_R = crate :: BitReader < bool > ; # [doc = "Field `BUFEN` writer - Buffer Mode Enable"]
pub type BUFEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - SPI Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (self . bits & 3) } # [doc = "Bit 2 - Client Select Disable"]
# [inline (always)]
pub fn ssd (& self) -> SSD_R { SSD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Buffer Write Mode"]
# [inline (always)]
pub fn bufwr (& self) -> BUFWR_R { BUFWR_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Buffer Mode Enable"]
# [inline (always)]
pub fn bufen (& self) -> BUFEN_R { BUFEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - SPI Mode"]
# [inline (always)]
# [must_use]
pub fn mode (& mut self) -> MODE_W < 0 > { MODE_W :: new (self) } # [doc = "Bit 2 - Client Select Disable"]
# [inline (always)]
# [must_use]
pub fn ssd (& mut self) -> SSD_W < 2 > { SSD_W :: new (self) } # [doc = "Bit 6 - Buffer Write Mode"]
# [inline (always)]
# [must_use]
pub fn bufwr (& mut self) -> BUFWR_W < 6 > { BUFWR_W :: new (self) } # [doc = "Bit 7 - Buffer Mode Enable"]
# [inline (always)]
# [must_use]
pub fn bufen (& mut self) -> BUFEN_W < 7 > { BUFEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `IE` reader - Interrupt Enable"]
pub type IE_R = crate :: BitReader < bool > ; # [doc = "Field `IE` writer - Interrupt Enable"]
pub type IE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `SSIE` reader - Client Select Trigger Interrupt Enable"]
pub type SSIE_R = crate :: BitReader < bool > ; # [doc = "Field `SSIE` writer - Client Select Trigger Interrupt Enable"]
pub type SSIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `DREIE` reader - Data Register Empty Interrupt Enable"]
pub type DREIE_R = crate :: BitReader < bool > ; # [doc = "Field `DREIE` writer - Data Register Empty Interrupt Enable"]
pub type DREIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `TXCIE` reader - Transfer Complete Interrupt Enable"]
pub type TXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE` writer - Transfer Complete Interrupt Enable"]
pub type TXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `RXCIE` reader - Receive Complete Interrupt Enable"]
pub type RXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE` writer - Receive Complete Interrupt Enable"]
pub type RXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Interrupt Enable"]
# [inline (always)]
pub fn ie (& self) -> IE_R { IE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Client Select Trigger Interrupt Enable"]
# [inline (always)]
pub fn ssie (& self) -> SSIE_R { SSIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dreie (& self) -> DREIE_R { DREIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transfer Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie (& self) -> TXCIE_R { TXCIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie (& self) -> RXCIE_R { RXCIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ie (& mut self) -> IE_W < 0 > { IE_W :: new (self) } # [doc = "Bit 4 - Client Select Trigger Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ssie (& mut self) -> SSIE_W < 4 > { SSIE_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dreie (& mut self) -> DREIE_W < 5 > { DREIE_W :: new (self) } # [doc = "Bit 6 - Transfer Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie (& mut self) -> TXCIE_W < 6 > { TXCIE_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie (& mut self) -> RXCIE_W < 7 > { RXCIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `SSIF` reader - Client Select Trigger Interrupt Flag"]
pub type SSIF_R = crate :: BitReader < bool > ; # [doc = "Field `SSIF` writer - Client Select Trigger Interrupt Flag"]
pub type SSIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Interrupt Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Interrupt Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transfer Complete Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transfer Complete Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `WRCOL` reader - Write Collision"]
pub type WRCOL_R = crate :: BitReader < bool > ; # [doc = "Field `WRCOL` writer - Write Collision"]
pub type WRCOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `IF` reader - Interrupt Flag"]
pub type IF_R = crate :: BitReader < bool > ; # [doc = "Field `IF` writer - Interrupt Flag"]
pub type IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Complete Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Client Select Trigger Interrupt Flag"]
# [inline (always)]
pub fn ssif (& self) -> SSIF_R { SSIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transfer Complete Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
pub fn wrcol (& self) -> WRCOL_R { WRCOL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
pub fn if_ (& self) -> IF_R { IF_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 0 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Client Select Trigger Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ssif (& mut self) -> SSIF_W < 4 > { SSIF_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transfer Complete Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
# [must_use]
pub fn wrcol (& mut self) -> WRCOL_W < 6 > { WRCOL_W :: new (self) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn if_ (& mut self) -> IF_W < 7 > { IF_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "System Configuration Registers"]
pub struct SYSCFG { _marker : PhantomData < * const () > } unsafe impl Send for SYSCFG { } impl SYSCFG { # [doc = r"Pointer to the register block"]
pub const PTR : * const syscfg :: RegisterBlock = 0x0f01 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const syscfg :: RegisterBlock { Self :: PTR } } impl Deref for SYSCFG { type Target = syscfg :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SYSCFG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYSCFG") . finish () } } # [doc = "System Configuration Registers"]
pub mod syscfg { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Revision ID"]
pub revid : REVID , # [doc = "0x01 - External Break"]
pub extbrk : EXTBRK , } # [doc = "EXTBRK (rw) register accessor: an alias for `Reg<EXTBRK_SPEC>`"]
pub type EXTBRK = crate :: Reg < extbrk :: EXTBRK_SPEC > ; # [doc = "External Break"]
pub mod extbrk { # [doc = "Register `EXTBRK` reader"]
pub struct R (crate :: R < EXTBRK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EXTBRK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EXTBRK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EXTBRK_SPEC >) -> Self { R (reader) } } # [doc = "Register `EXTBRK` writer"]
pub struct W (crate :: W < EXTBRK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EXTBRK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EXTBRK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EXTBRK_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENEXTBRK` reader - External break enable"]
pub type ENEXTBRK_R = crate :: BitReader < bool > ; # [doc = "Field `ENEXTBRK` writer - External break enable"]
pub type ENEXTBRK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EXTBRK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - External break enable"]
# [inline (always)]
pub fn enextbrk (& self) -> ENEXTBRK_R { ENEXTBRK_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - External break enable"]
# [inline (always)]
# [must_use]
pub fn enextbrk (& mut self) -> ENEXTBRK_W < 0 > { ENEXTBRK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Break\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [extbrk](index.html) module"]
pub struct EXTBRK_SPEC ; impl crate :: RegisterSpec for EXTBRK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [extbrk::R](R) reader structure"]
impl crate :: Readable for EXTBRK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [extbrk::W](W) writer structure"]
impl crate :: Writable for EXTBRK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EXTBRK to value 0"]
impl crate :: Resettable for EXTBRK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "REVID (rw) register accessor: an alias for `Reg<REVID_SPEC>`"]
pub type REVID = crate :: Reg < revid :: REVID_SPEC > ; # [doc = "Revision ID"]
pub mod revid { # [doc = "Register `REVID` reader"]
pub struct R (crate :: R < REVID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < REVID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < REVID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < REVID_SPEC >) -> Self { R (reader) } } # [doc = "Register `REVID` writer"]
pub struct W (crate :: W < REVID_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < REVID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < REVID_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < REVID_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Revision ID\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [revid](index.html) module"]
pub struct REVID_SPEC ; impl crate :: RegisterSpec for REVID_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [revid::R](R) reader structure"]
impl crate :: Readable for REVID_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [revid::W](W) writer structure"]
impl crate :: Writable for REVID_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets REVID to value 0"]
impl crate :: Resettable for REVID_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter Type A"]
pub struct TCA0 { _marker : PhantomData < * const () > } unsafe impl Send for TCA0 { } impl TCA0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tca0 :: RegisterBlock = 0x0a00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tca0 :: RegisterBlock { Self :: PTR } } impl Deref for TCA0 { type Target = tca0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCA0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCA0") . finish () } } # [doc = "16-bit Timer/Counter Type A"]
pub mod tca0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_split_ctrla : [u8 ; 0x01]
, _reserved_1_split_ctrlb : [u8 ; 0x01]
, _reserved_2_split_ctrlc : [u8 ; 0x01]
, _reserved_3_split_ctrld : [u8 ; 0x01]
, _reserved_4_split_ctrleclr : [u8 ; 0x01]
, _reserved_5_split_ctrleset : [u8 ; 0x01]
, # [doc = "0x06 - Control F Clear"]
pub single_ctrlfclr : SINGLE_CTRLFCLR , # [doc = "0x07 - Control F Set"]
pub single_ctrlfset : SINGLE_CTRLFSET , _reserved8 : [u8 ; 0x01]
, # [doc = "0x09 - Event Control"]
pub single_evctrl : SINGLE_EVCTRL , _reserved_9_split_intctrl : [u8 ; 0x01]
, _reserved_10_split_intflags : [u8 ; 0x01]
, _reserved11 : [u8 ; 0x02]
, _reserved_11_split_dbgctrl : [u8 ; 0x01]
, # [doc = "0x0f - Temporary data for 16-bit Access"]
pub single_temp : SINGLE_TEMP , _reserved13 : [u8 ; 0x10]
, _reserved_13_single_cnt : [u8 ; 0x02]
, _reserved14 : [u8 ; 0x04]
, _reserved_14_single_per : [u8 ; 0x02]
, _reserved_15_single_cmp0 : [u8 ; 0x02]
, _reserved_16_single_cmp1 : [u8 ; 0x02]
, _reserved_17_single_cmp2 : [u8 ; 0x02]
, _reserved18 : [u8 ; 0x08]
, # [doc = "0x36 - Period Buffer"]
pub single_perbuf : SINGLE_PERBUF , # [doc = "0x38 - Compare 0 Buffer"]
pub single_cmp0buf : SINGLE_CMP0BUF , # [doc = "0x3a - Compare 1 Buffer"]
pub single_cmp1buf : SINGLE_CMP1BUF , # [doc = "0x3c - Compare 2 Buffer"]
pub single_cmp2buf : SINGLE_CMP2BUF , } impl RegisterBlock { # [doc = "0x00 - Control A"]
# [inline (always)]
pub const fn split_ctrla (& self) -> & SPLIT_CTRLA { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (0usize) . cast () } } # [doc = "0x00 - Control A"]
# [inline (always)]
pub const fn single_ctrla (& self) -> & SINGLE_CTRLA { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (0usize) . cast () } } # [doc = "0x01 - Control B"]
# [inline (always)]
pub const fn split_ctrlb (& self) -> & SPLIT_CTRLB { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (1usize) . cast () } } # [doc = "0x01 - Control B"]
# [inline (always)]
pub const fn single_ctrlb (& self) -> & SINGLE_CTRLB { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (1usize) . cast () } } # [doc = "0x02 - Control C"]
# [inline (always)]
pub const fn split_ctrlc (& self) -> & SPLIT_CTRLC { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (2usize) . cast () } } # [doc = "0x02 - Control C"]
# [inline (always)]
pub const fn single_ctrlc (& self) -> & SINGLE_CTRLC { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (2usize) . cast () } } # [doc = "0x03 - Control D"]
# [inline (always)]
pub const fn split_ctrld (& self) -> & SPLIT_CTRLD { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (3usize) . cast () } } # [doc = "0x03 - Control D"]
# [inline (always)]
pub const fn single_ctrld (& self) -> & SINGLE_CTRLD { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (3usize) . cast () } } # [doc = "0x04 - Control E Clear"]
# [inline (always)]
pub const fn split_ctrleclr (& self) -> & SPLIT_CTRLECLR { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (4usize) . cast () } } # [doc = "0x04 - Control E Clear"]
# [inline (always)]
pub const fn single_ctrleclr (& self) -> & SINGLE_CTRLECLR { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (4usize) . cast () } } # [doc = "0x05 - Control E Set"]
# [inline (always)]
pub const fn split_ctrleset (& self) -> & SPLIT_CTRLESET { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (5usize) . cast () } } # [doc = "0x05 - Control E Set"]
# [inline (always)]
pub const fn single_ctrleset (& self) -> & SINGLE_CTRLESET { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (5usize) . cast () } } # [doc = "0x0a - Interrupt Control"]
# [inline (always)]
pub const fn split_intctrl (& self) -> & SPLIT_INTCTRL { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (10usize) . cast () } } # [doc = "0x0a - Interrupt Control"]
# [inline (always)]
pub const fn single_intctrl (& self) -> & SINGLE_INTCTRL { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (10usize) . cast () } } # [doc = "0x0b - Interrupt Flags"]
# [inline (always)]
pub const fn split_intflags (& self) -> & SPLIT_INTFLAGS { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (11usize) . cast () } } # [doc = "0x0b - Interrupt Flags"]
# [inline (always)]
pub const fn single_intflags (& self) -> & SINGLE_INTFLAGS { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (11usize) . cast () } } # [doc = "0x0e - Degbug Control"]
# [inline (always)]
pub const fn split_dbgctrl (& self) -> & SPLIT_DBGCTRL { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (14usize) . cast () } } # [doc = "0x0e - Degbug Control"]
# [inline (always)]
pub const fn single_dbgctrl (& self) -> & SINGLE_DBGCTRL { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (14usize) . cast () } } # [doc = "0x20 - Low Count"]
# [inline (always)]
pub const fn split_lcnt (& self) -> & SPLIT_LCNT { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (32usize) . cast () } } # [doc = "0x20 - Count"]
# [inline (always)]
pub const fn single_cnt (& self) -> & SINGLE_CNT { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (32usize) . cast () } } # [doc = "0x21 - High Count"]
# [inline (always)]
pub const fn split_hcnt (& self) -> & SPLIT_HCNT { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (33usize) . cast () } } # [doc = "0x26 - Low Period"]
# [inline (always)]
pub const fn split_lper (& self) -> & SPLIT_LPER { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (38usize) . cast () } } # [doc = "0x26 - Period"]
# [inline (always)]
pub const fn single_per (& self) -> & SINGLE_PER { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (38usize) . cast () } } # [doc = "0x27 - High Period"]
# [inline (always)]
pub const fn split_hper (& self) -> & SPLIT_HPER { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (39usize) . cast () } } # [doc = "0x28 - Low Compare"]
# [inline (always)]
pub const fn split_lcmp0 (& self) -> & SPLIT_LCMP0 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (40usize) . cast () } } # [doc = "0x28 - Compare 0"]
# [inline (always)]
pub const fn single_cmp0 (& self) -> & SINGLE_CMP0 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (40usize) . cast () } } # [doc = "0x29 - High Compare"]
# [inline (always)]
pub const fn split_hcmp0 (& self) -> & SPLIT_HCMP0 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (41usize) . cast () } } # [doc = "0x2a - Low Compare"]
# [inline (always)]
pub const fn split_lcmp1 (& self) -> & SPLIT_LCMP1 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (42usize) . cast () } } # [doc = "0x2a - Compare 1"]
# [inline (always)]
pub const fn single_cmp1 (& self) -> & SINGLE_CMP1 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (42usize) . cast () } } # [doc = "0x2b - High Compare"]
# [inline (always)]
pub const fn split_hcmp1 (& self) -> & SPLIT_HCMP1 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (43usize) . cast () } } # [doc = "0x2c - Low Compare"]
# [inline (always)]
pub const fn split_lcmp2 (& self) -> & SPLIT_LCMP2 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (44usize) . cast () } } # [doc = "0x2c - Compare 2"]
# [inline (always)]
pub const fn single_cmp2 (& self) -> & SINGLE_CMP2 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (44usize) . cast () } } # [doc = "0x2d - High Compare"]
# [inline (always)]
pub const fn split_hcmp2 (& self) -> & SPLIT_HCMP2 { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (45usize) . cast () } } } # [doc = "SINGLE_CMP0 (rw) register accessor: an alias for `Reg<SINGLE_CMP0_SPEC>`"]
pub type SINGLE_CMP0 = crate :: Reg < single_cmp0 :: SINGLE_CMP0_SPEC > ; # [doc = "Compare 0"]
pub mod single_cmp0 { # [doc = "Register `CMP0` reader"]
pub struct R (crate :: R < SINGLE_CMP0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CMP0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CMP0_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP0` writer"]
pub struct W (crate :: W < SINGLE_CMP0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CMP0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CMP0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_cmp0](index.html) module"]
pub struct SINGLE_CMP0_SPEC ; impl crate :: RegisterSpec for SINGLE_CMP0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_cmp0::R](R) reader structure"]
impl crate :: Readable for SINGLE_CMP0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_cmp0::W](W) writer structure"]
impl crate :: Writable for SINGLE_CMP0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP0 to value 0"]
impl crate :: Resettable for SINGLE_CMP0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CMP0BUF (rw) register accessor: an alias for `Reg<SINGLE_CMP0BUF_SPEC>`"]
pub type SINGLE_CMP0BUF = crate :: Reg < single_cmp0buf :: SINGLE_CMP0BUF_SPEC > ; # [doc = "Compare 0 Buffer"]
pub mod single_cmp0buf { # [doc = "Register `CMP0BUF` reader"]
pub struct R (crate :: R < SINGLE_CMP0BUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CMP0BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CMP0BUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CMP0BUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP0BUF` writer"]
pub struct W (crate :: W < SINGLE_CMP0BUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CMP0BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CMP0BUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CMP0BUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 0 Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_cmp0buf](index.html) module"]
pub struct SINGLE_CMP0BUF_SPEC ; impl crate :: RegisterSpec for SINGLE_CMP0BUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_cmp0buf::R](R) reader structure"]
impl crate :: Readable for SINGLE_CMP0BUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_cmp0buf::W](W) writer structure"]
impl crate :: Writable for SINGLE_CMP0BUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP0BUF to value 0"]
impl crate :: Resettable for SINGLE_CMP0BUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CMP1 (rw) register accessor: an alias for `Reg<SINGLE_CMP1_SPEC>`"]
pub type SINGLE_CMP1 = crate :: Reg < single_cmp1 :: SINGLE_CMP1_SPEC > ; # [doc = "Compare 1"]
pub mod single_cmp1 { # [doc = "Register `CMP1` reader"]
pub struct R (crate :: R < SINGLE_CMP1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CMP1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CMP1_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP1` writer"]
pub struct W (crate :: W < SINGLE_CMP1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CMP1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CMP1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_cmp1](index.html) module"]
pub struct SINGLE_CMP1_SPEC ; impl crate :: RegisterSpec for SINGLE_CMP1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_cmp1::R](R) reader structure"]
impl crate :: Readable for SINGLE_CMP1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_cmp1::W](W) writer structure"]
impl crate :: Writable for SINGLE_CMP1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP1 to value 0"]
impl crate :: Resettable for SINGLE_CMP1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CMP1BUF (rw) register accessor: an alias for `Reg<SINGLE_CMP1BUF_SPEC>`"]
pub type SINGLE_CMP1BUF = crate :: Reg < single_cmp1buf :: SINGLE_CMP1BUF_SPEC > ; # [doc = "Compare 1 Buffer"]
pub mod single_cmp1buf { # [doc = "Register `CMP1BUF` reader"]
pub struct R (crate :: R < SINGLE_CMP1BUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CMP1BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CMP1BUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CMP1BUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP1BUF` writer"]
pub struct W (crate :: W < SINGLE_CMP1BUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CMP1BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CMP1BUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CMP1BUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 1 Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_cmp1buf](index.html) module"]
pub struct SINGLE_CMP1BUF_SPEC ; impl crate :: RegisterSpec for SINGLE_CMP1BUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_cmp1buf::R](R) reader structure"]
impl crate :: Readable for SINGLE_CMP1BUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_cmp1buf::W](W) writer structure"]
impl crate :: Writable for SINGLE_CMP1BUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP1BUF to value 0"]
impl crate :: Resettable for SINGLE_CMP1BUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CMP2 (rw) register accessor: an alias for `Reg<SINGLE_CMP2_SPEC>`"]
pub type SINGLE_CMP2 = crate :: Reg < single_cmp2 :: SINGLE_CMP2_SPEC > ; # [doc = "Compare 2"]
pub mod single_cmp2 { # [doc = "Register `CMP2` reader"]
pub struct R (crate :: R < SINGLE_CMP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CMP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CMP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP2` writer"]
pub struct W (crate :: W < SINGLE_CMP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CMP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CMP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_cmp2](index.html) module"]
pub struct SINGLE_CMP2_SPEC ; impl crate :: RegisterSpec for SINGLE_CMP2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_cmp2::R](R) reader structure"]
impl crate :: Readable for SINGLE_CMP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_cmp2::W](W) writer structure"]
impl crate :: Writable for SINGLE_CMP2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP2 to value 0"]
impl crate :: Resettable for SINGLE_CMP2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CMP2BUF (rw) register accessor: an alias for `Reg<SINGLE_CMP2BUF_SPEC>`"]
pub type SINGLE_CMP2BUF = crate :: Reg < single_cmp2buf :: SINGLE_CMP2BUF_SPEC > ; # [doc = "Compare 2 Buffer"]
pub mod single_cmp2buf { # [doc = "Register `CMP2BUF` reader"]
pub struct R (crate :: R < SINGLE_CMP2BUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CMP2BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CMP2BUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CMP2BUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP2BUF` writer"]
pub struct W (crate :: W < SINGLE_CMP2BUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CMP2BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CMP2BUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CMP2BUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 2 Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_cmp2buf](index.html) module"]
pub struct SINGLE_CMP2BUF_SPEC ; impl crate :: RegisterSpec for SINGLE_CMP2BUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_cmp2buf::R](R) reader structure"]
impl crate :: Readable for SINGLE_CMP2BUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_cmp2buf::W](W) writer structure"]
impl crate :: Writable for SINGLE_CMP2BUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP2BUF to value 0"]
impl crate :: Resettable for SINGLE_CMP2BUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CNT (rw) register accessor: an alias for `Reg<SINGLE_CNT_SPEC>`"]
pub type SINGLE_CNT = crate :: Reg < single_cnt :: SINGLE_CNT_SPEC > ; # [doc = "Count"]
pub mod single_cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < SINGLE_CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < SINGLE_CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_cnt](index.html) module"]
pub struct SINGLE_CNT_SPEC ; impl crate :: RegisterSpec for SINGLE_CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_cnt::R](R) reader structure"]
impl crate :: Readable for SINGLE_CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_cnt::W](W) writer structure"]
impl crate :: Writable for SINGLE_CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for SINGLE_CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CTRLA (rw) register accessor: an alias for `Reg<SINGLE_CTRLA_SPEC>`"]
pub type SINGLE_CTRLA = crate :: Reg < single_ctrla :: SINGLE_CTRLA_SPEC > ; # [doc = "Control A"]
pub mod single_ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < SINGLE_CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < SINGLE_CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Module Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Module Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: System Clock"]
DIV1 = 0 , # [doc = "1: System Clock / 2"]
DIV2 = 1 , # [doc = "2: System Clock / 4"]
DIV4 = 2 , # [doc = "3: System Clock / 8"]
DIV8 = 3 , # [doc = "4: System Clock / 16"]
DIV16 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: DIV1 , 1 => CLKSEL_A :: DIV2 , 2 => CLKSEL_A :: DIV4 , 3 => CLKSEL_A :: DIV8 , 4 => CLKSEL_A :: DIV16 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == CLKSEL_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SINGLE_CTRLA_SPEC , u8 , CLKSEL_A , 3 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } } impl R { # [doc = "Bit 0 - Module Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 7) } } impl W { # [doc = "Bit 0 - Module Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_ctrla](index.html) module"]
pub struct SINGLE_CTRLA_SPEC ; impl crate :: RegisterSpec for SINGLE_CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_ctrla::R](R) reader structure"]
impl crate :: Readable for SINGLE_CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_ctrla::W](W) writer structure"]
impl crate :: Writable for SINGLE_CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for SINGLE_CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CTRLB (rw) register accessor: an alias for `Reg<SINGLE_CTRLB_SPEC>`"]
pub type SINGLE_CTRLB = crate :: Reg < single_ctrlb :: SINGLE_CTRLB_SPEC > ; # [doc = "Control B"]
pub mod single_ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < SINGLE_CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < SINGLE_CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope PWM"]
SINGLESLOPE = 3 , # [doc = "5: Dual Slope PWM, overflow on TOP"]
DSTOP = 5 , # [doc = "6: Dual Slope PWM, overflow on TOP and BOTTOM"]
DSBOTH = 6 , # [doc = "7: Dual Slope PWM, overflow on BOTTOM"]
DSBOTTOM = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SINGLESLOPE) , 5 => Some (WGMODE_A :: DSTOP) , 6 => Some (WGMODE_A :: DSBOTH) , 7 => Some (WGMODE_A :: DSBOTTOM) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SINGLESLOPE`"]
# [inline (always)]
pub fn is_singleslope (& self) -> bool { * self == WGMODE_A :: SINGLESLOPE } # [doc = "Checks if the value of the field is `DSTOP`"]
# [inline (always)]
pub fn is_dstop (& self) -> bool { * self == WGMODE_A :: DSTOP } # [doc = "Checks if the value of the field is `DSBOTH`"]
# [inline (always)]
pub fn is_dsboth (& self) -> bool { * self == WGMODE_A :: DSBOTH } # [doc = "Checks if the value of the field is `DSBOTTOM`"]
# [inline (always)]
pub fn is_dsbottom (& self) -> bool { * self == WGMODE_A :: DSBOTTOM } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SINGLE_CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope PWM"]
# [inline (always)]
pub fn singleslope (self) -> & 'a mut W { self . variant (WGMODE_A :: SINGLESLOPE) } # [doc = "Dual Slope PWM, overflow on TOP"]
# [inline (always)]
pub fn dstop (self) -> & 'a mut W { self . variant (WGMODE_A :: DSTOP) } # [doc = "Dual Slope PWM, overflow on TOP and BOTTOM"]
# [inline (always)]
pub fn dsboth (self) -> & 'a mut W { self . variant (WGMODE_A :: DSBOTH) } # [doc = "Dual Slope PWM, overflow on BOTTOM"]
# [inline (always)]
pub fn dsbottom (self) -> & 'a mut W { self . variant (WGMODE_A :: DSBOTTOM) } } # [doc = "Field `ALUPD` reader - Auto Lock Update"]
pub type ALUPD_R = crate :: BitReader < bool > ; # [doc = "Field `ALUPD` writer - Auto Lock Update"]
pub type ALUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLB_SPEC , bool , O > ; # [doc = "Field `CMP0EN` reader - Compare 0 Enable"]
pub type CMP0EN_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0EN` writer - Compare 0 Enable"]
pub type CMP0EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLB_SPEC , bool , O > ; # [doc = "Field `CMP1EN` reader - Compare 1 Enable"]
pub type CMP1EN_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1EN` writer - Compare 1 Enable"]
pub type CMP1EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLB_SPEC , bool , O > ; # [doc = "Field `CMP2EN` reader - Compare 2 Enable"]
pub type CMP2EN_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2EN` writer - Compare 2 Enable"]
pub type CMP2EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 3 - Auto Lock Update"]
# [inline (always)]
pub fn alupd (& self) -> ALUPD_R { ALUPD_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare 0 Enable"]
# [inline (always)]
pub fn cmp0en (& self) -> CMP0EN_R { CMP0EN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare 1 Enable"]
# [inline (always)]
pub fn cmp1en (& self) -> CMP1EN_R { CMP1EN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare 2 Enable"]
# [inline (always)]
pub fn cmp2en (& self) -> CMP2EN_R { CMP2EN_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 3 - Auto Lock Update"]
# [inline (always)]
# [must_use]
pub fn alupd (& mut self) -> ALUPD_W < 3 > { ALUPD_W :: new (self) } # [doc = "Bit 4 - Compare 0 Enable"]
# [inline (always)]
# [must_use]
pub fn cmp0en (& mut self) -> CMP0EN_W < 4 > { CMP0EN_W :: new (self) } # [doc = "Bit 5 - Compare 1 Enable"]
# [inline (always)]
# [must_use]
pub fn cmp1en (& mut self) -> CMP1EN_W < 5 > { CMP1EN_W :: new (self) } # [doc = "Bit 6 - Compare 2 Enable"]
# [inline (always)]
# [must_use]
pub fn cmp2en (& mut self) -> CMP2EN_W < 6 > { CMP2EN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_ctrlb](index.html) module"]
pub struct SINGLE_CTRLB_SPEC ; impl crate :: RegisterSpec for SINGLE_CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_ctrlb::R](R) reader structure"]
impl crate :: Readable for SINGLE_CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_ctrlb::W](W) writer structure"]
impl crate :: Writable for SINGLE_CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for SINGLE_CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CTRLC (rw) register accessor: an alias for `Reg<SINGLE_CTRLC_SPEC>`"]
pub type SINGLE_CTRLC = crate :: Reg < single_ctrlc :: SINGLE_CTRLC_SPEC > ; # [doc = "Control C"]
pub mod single_ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < SINGLE_CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < SINGLE_CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP0OV` reader - Compare 0 Waveform Output Value"]
pub type CMP0OV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0OV` writer - Compare 0 Waveform Output Value"]
pub type CMP0OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLC_SPEC , bool , O > ; # [doc = "Field `CMP1OV` reader - Compare 1 Waveform Output Value"]
pub type CMP1OV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1OV` writer - Compare 1 Waveform Output Value"]
pub type CMP1OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLC_SPEC , bool , O > ; # [doc = "Field `CMP2OV` reader - Compare 2 Waveform Output Value"]
pub type CMP2OV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2OV` writer - Compare 2 Waveform Output Value"]
pub type CMP2OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare 0 Waveform Output Value"]
# [inline (always)]
pub fn cmp0ov (& self) -> CMP0OV_R { CMP0OV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 1 Waveform Output Value"]
# [inline (always)]
pub fn cmp1ov (& self) -> CMP1OV_R { CMP1OV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare 2 Waveform Output Value"]
# [inline (always)]
pub fn cmp2ov (& self) -> CMP2OV_R { CMP2OV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare 0 Waveform Output Value"]
# [inline (always)]
# [must_use]
pub fn cmp0ov (& mut self) -> CMP0OV_W < 0 > { CMP0OV_W :: new (self) } # [doc = "Bit 1 - Compare 1 Waveform Output Value"]
# [inline (always)]
# [must_use]
pub fn cmp1ov (& mut self) -> CMP1OV_W < 1 > { CMP1OV_W :: new (self) } # [doc = "Bit 2 - Compare 2 Waveform Output Value"]
# [inline (always)]
# [must_use]
pub fn cmp2ov (& mut self) -> CMP2OV_W < 2 > { CMP2OV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_ctrlc](index.html) module"]
pub struct SINGLE_CTRLC_SPEC ; impl crate :: RegisterSpec for SINGLE_CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_ctrlc::R](R) reader structure"]
impl crate :: Readable for SINGLE_CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_ctrlc::W](W) writer structure"]
impl crate :: Writable for SINGLE_CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for SINGLE_CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CTRLD (rw) register accessor: an alias for `Reg<SINGLE_CTRLD_SPEC>`"]
pub type SINGLE_CTRLD = crate :: Reg < single_ctrld :: SINGLE_CTRLD_SPEC > ; # [doc = "Control D"]
pub mod single_ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < SINGLE_CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < SINGLE_CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPLITM` reader - Split Mode Enable"]
pub type SPLITM_R = crate :: BitReader < bool > ; # [doc = "Field `SPLITM` writer - Split Mode Enable"]
pub type SPLITM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLD_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Split Mode Enable"]
# [inline (always)]
pub fn splitm (& self) -> SPLITM_R { SPLITM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Split Mode Enable"]
# [inline (always)]
# [must_use]
pub fn splitm (& mut self) -> SPLITM_W < 0 > { SPLITM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_ctrld](index.html) module"]
pub struct SINGLE_CTRLD_SPEC ; impl crate :: RegisterSpec for SINGLE_CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_ctrld::R](R) reader structure"]
impl crate :: Readable for SINGLE_CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_ctrld::W](W) writer structure"]
impl crate :: Writable for SINGLE_CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for SINGLE_CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CTRLECLR (rw) register accessor: an alias for `Reg<SINGLE_CTRLECLR_SPEC>`"]
pub type SINGLE_CTRLECLR = crate :: Reg < single_ctrleclr :: SINGLE_CTRLECLR_SPEC > ; # [doc = "Control E Clear"]
pub mod single_ctrleclr { # [doc = "Register `CTRLECLR` reader"]
pub struct R (crate :: R < SINGLE_CTRLECLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CTRLECLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CTRLECLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CTRLECLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLECLR` writer"]
pub struct W (crate :: W < SINGLE_CTRLECLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CTRLECLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CTRLECLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CTRLECLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLECLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLECLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SINGLE_CTRLECLR_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_ctrleclr](index.html) module"]
pub struct SINGLE_CTRLECLR_SPEC ; impl crate :: RegisterSpec for SINGLE_CTRLECLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_ctrleclr::R](R) reader structure"]
impl crate :: Readable for SINGLE_CTRLECLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_ctrleclr::W](W) writer structure"]
impl crate :: Writable for SINGLE_CTRLECLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLECLR to value 0"]
impl crate :: Resettable for SINGLE_CTRLECLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CTRLESET (rw) register accessor: an alias for `Reg<SINGLE_CTRLESET_SPEC>`"]
pub type SINGLE_CTRLESET = crate :: Reg < single_ctrleset :: SINGLE_CTRLESET_SPEC > ; # [doc = "Control E Set"]
pub mod single_ctrleset { # [doc = "Register `CTRLESET` reader"]
pub struct R (crate :: R < SINGLE_CTRLESET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CTRLESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CTRLESET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CTRLESET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLESET` writer"]
pub struct W (crate :: W < SINGLE_CTRLESET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CTRLESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CTRLESET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CTRLESET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < DIR_A > ; # [doc = "Direction\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DIR_A { # [doc = "0: Count up"]
UP = 0 , # [doc = "1: Count down"]
DOWN = 1 , } impl From < DIR_A > for bool { # [inline (always)]
fn from (variant : DIR_A) -> Self { variant as u8 != 0 } } impl DIR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIR_A { match self . bits { false => DIR_A :: UP , true => DIR_A :: DOWN , } } # [doc = "Checks if the value of the field is `UP`"]
# [inline (always)]
pub fn is_up (& self) -> bool { * self == DIR_A :: UP } # [doc = "Checks if the value of the field is `DOWN`"]
# [inline (always)]
pub fn is_down (& self) -> bool { * self == DIR_A :: DOWN } } # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLESET_SPEC , DIR_A , O > ; impl < 'a , const O : u8 > DIR_W < 'a , O > { # [doc = "Count up"]
# [inline (always)]
pub fn up (self) -> & 'a mut W { self . variant (DIR_A :: UP) } # [doc = "Count down"]
# [inline (always)]
pub fn down (self) -> & 'a mut W { self . variant (DIR_A :: DOWN) } } # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLESET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SINGLE_CTRLESET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_ctrleset](index.html) module"]
pub struct SINGLE_CTRLESET_SPEC ; impl crate :: RegisterSpec for SINGLE_CTRLESET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_ctrleset::R](R) reader structure"]
impl crate :: Readable for SINGLE_CTRLESET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_ctrleset::W](W) writer structure"]
impl crate :: Writable for SINGLE_CTRLESET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLESET to value 0"]
impl crate :: Resettable for SINGLE_CTRLESET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CTRLFCLR (rw) register accessor: an alias for `Reg<SINGLE_CTRLFCLR_SPEC>`"]
pub type SINGLE_CTRLFCLR = crate :: Reg < single_ctrlfclr :: SINGLE_CTRLFCLR_SPEC > ; # [doc = "Control F Clear"]
pub mod single_ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < SINGLE_CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < SINGLE_CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMP0BV` reader - Compare 0 Buffer Valid"]
pub type CMP0BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0BV` writer - Compare 0 Buffer Valid"]
pub type CMP0BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMP1BV` reader - Compare 1 Buffer Valid"]
pub type CMP1BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1BV` writer - Compare 1 Buffer Valid"]
pub type CMP1BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMP2BV` reader - Compare 2 Buffer Valid"]
pub type CMP2BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2BV` writer - Compare 2 Buffer Valid"]
pub type CMP2BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLFCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 0 Buffer Valid"]
# [inline (always)]
pub fn cmp0bv (& self) -> CMP0BV_R { CMP0BV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare 1 Buffer Valid"]
# [inline (always)]
pub fn cmp1bv (& self) -> CMP1BV_R { CMP1BV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare 2 Buffer Valid"]
# [inline (always)]
pub fn cmp2bv (& self) -> CMP2BV_R { CMP2BV_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare 0 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp0bv (& mut self) -> CMP0BV_W < 1 > { CMP0BV_W :: new (self) } # [doc = "Bit 2 - Compare 1 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp1bv (& mut self) -> CMP1BV_W < 2 > { CMP1BV_W :: new (self) } # [doc = "Bit 3 - Compare 2 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp2bv (& mut self) -> CMP2BV_W < 3 > { CMP2BV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_ctrlfclr](index.html) module"]
pub struct SINGLE_CTRLFCLR_SPEC ; impl crate :: RegisterSpec for SINGLE_CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_ctrlfclr::R](R) reader structure"]
impl crate :: Readable for SINGLE_CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_ctrlfclr::W](W) writer structure"]
impl crate :: Writable for SINGLE_CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for SINGLE_CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_CTRLFSET (rw) register accessor: an alias for `Reg<SINGLE_CTRLFSET_SPEC>`"]
pub type SINGLE_CTRLFSET = crate :: Reg < single_ctrlfset :: SINGLE_CTRLFSET_SPEC > ; # [doc = "Control F Set"]
pub mod single_ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < SINGLE_CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < SINGLE_CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMP0BV` reader - Compare 0 Buffer Valid"]
pub type CMP0BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0BV` writer - Compare 0 Buffer Valid"]
pub type CMP0BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMP1BV` reader - Compare 1 Buffer Valid"]
pub type CMP1BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1BV` writer - Compare 1 Buffer Valid"]
pub type CMP1BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMP2BV` reader - Compare 2 Buffer Valid"]
pub type CMP2BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2BV` writer - Compare 2 Buffer Valid"]
pub type CMP2BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_CTRLFSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 0 Buffer Valid"]
# [inline (always)]
pub fn cmp0bv (& self) -> CMP0BV_R { CMP0BV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare 1 Buffer Valid"]
# [inline (always)]
pub fn cmp1bv (& self) -> CMP1BV_R { CMP1BV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare 2 Buffer Valid"]
# [inline (always)]
pub fn cmp2bv (& self) -> CMP2BV_R { CMP2BV_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare 0 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp0bv (& mut self) -> CMP0BV_W < 1 > { CMP0BV_W :: new (self) } # [doc = "Bit 2 - Compare 1 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp1bv (& mut self) -> CMP1BV_W < 2 > { CMP1BV_W :: new (self) } # [doc = "Bit 3 - Compare 2 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp2bv (& mut self) -> CMP2BV_W < 3 > { CMP2BV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_ctrlfset](index.html) module"]
pub struct SINGLE_CTRLFSET_SPEC ; impl crate :: RegisterSpec for SINGLE_CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_ctrlfset::R](R) reader structure"]
impl crate :: Readable for SINGLE_CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_ctrlfset::W](W) writer structure"]
impl crate :: Writable for SINGLE_CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for SINGLE_CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_DBGCTRL (rw) register accessor: an alias for `Reg<SINGLE_DBGCTRL_SPEC>`"]
pub type SINGLE_DBGCTRL = crate :: Reg < single_dbgctrl :: SINGLE_DBGCTRL_SPEC > ; # [doc = "Degbug Control"]
pub mod single_dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < SINGLE_DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < SINGLE_DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Degbug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_dbgctrl](index.html) module"]
pub struct SINGLE_DBGCTRL_SPEC ; impl crate :: RegisterSpec for SINGLE_DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_dbgctrl::R](R) reader structure"]
impl crate :: Readable for SINGLE_DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_dbgctrl::W](W) writer structure"]
impl crate :: Writable for SINGLE_DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for SINGLE_DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_EVCTRL (rw) register accessor: an alias for `Reg<SINGLE_EVCTRL_SPEC>`"]
pub type SINGLE_EVCTRL = crate :: Reg < single_evctrl :: SINGLE_EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod single_evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < SINGLE_EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < SINGLE_EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CNTEI` reader - Count on Event Input"]
pub type CNTEI_R = crate :: BitReader < bool > ; # [doc = "Field `CNTEI` writer - Count on Event Input"]
pub type CNTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_EVCTRL_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: Count on positive edge event"]
POSEDGE = 0 , # [doc = "1: Count on any edge event"]
ANYEDGE = 1 , # [doc = "2: Count on prescaled clock while event line is 1."]
HIGHLVL = 2 , # [doc = "3: Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1."]
UPDOWN = 3 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EVACT_A { match self . bits { 0 => EVACT_A :: POSEDGE , 1 => EVACT_A :: ANYEDGE , 2 => EVACT_A :: HIGHLVL , 3 => EVACT_A :: UPDOWN , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `POSEDGE`"]
# [inline (always)]
pub fn is_posedge (& self) -> bool { * self == EVACT_A :: POSEDGE } # [doc = "Checks if the value of the field is `ANYEDGE`"]
# [inline (always)]
pub fn is_anyedge (& self) -> bool { * self == EVACT_A :: ANYEDGE } # [doc = "Checks if the value of the field is `HIGHLVL`"]
# [inline (always)]
pub fn is_highlvl (& self) -> bool { * self == EVACT_A :: HIGHLVL } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SINGLE_EVCTRL_SPEC , u8 , EVACT_A , 2 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "Count on positive edge event"]
# [inline (always)]
pub fn posedge (self) -> & 'a mut W { self . variant (EVACT_A :: POSEDGE) } # [doc = "Count on any edge event"]
# [inline (always)]
pub fn anyedge (self) -> & 'a mut W { self . variant (EVACT_A :: ANYEDGE) } # [doc = "Count on prescaled clock while event line is 1."]
# [inline (always)]
pub fn highlvl (self) -> & 'a mut W { self . variant (EVACT_A :: HIGHLVL) } # [doc = "Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1."]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } } impl R { # [doc = "Bit 0 - Count on Event Input"]
# [inline (always)]
pub fn cntei (& self) -> CNTEI_R { CNTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - Count on Event Input"]
# [inline (always)]
# [must_use]
pub fn cntei (& mut self) -> CNTEI_W < 0 > { CNTEI_W :: new (self) } # [doc = "Bits 1:2 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 1 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_evctrl](index.html) module"]
pub struct SINGLE_EVCTRL_SPEC ; impl crate :: RegisterSpec for SINGLE_EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_evctrl::R](R) reader structure"]
impl crate :: Readable for SINGLE_EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_evctrl::W](W) writer structure"]
impl crate :: Writable for SINGLE_EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for SINGLE_EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_INTCTRL (rw) register accessor: an alias for `Reg<SINGLE_INTCTRL_SPEC>`"]
pub type SINGLE_INTCTRL = crate :: Reg < single_intctrl :: SINGLE_INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod single_intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < SINGLE_INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < SINGLE_INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_INTCTRL_SPEC , bool , O > ; # [doc = "Field `CMP0` reader - Compare 0 Interrupt"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0 Interrupt"]
pub type CMP0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_INTCTRL_SPEC , bool , O > ; # [doc = "Field `CMP1` reader - Compare 1 Interrupt"]
pub type CMP1_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1` writer - Compare 1 Interrupt"]
pub type CMP1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_INTCTRL_SPEC , bool , O > ; # [doc = "Field `CMP2` reader - Compare 2 Interrupt"]
pub type CMP2_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2` writer - Compare 2 Interrupt"]
pub type CMP2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Compare 0 Interrupt"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare 1 Interrupt"]
# [inline (always)]
pub fn cmp1 (& self) -> CMP1_R { CMP1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare 2 Interrupt"]
# [inline (always)]
pub fn cmp2 (& self) -> CMP2_R { CMP2_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 4 - Compare 0 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp0 (& mut self) -> CMP0_W < 4 > { CMP0_W :: new (self) } # [doc = "Bit 5 - Compare 1 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp1 (& mut self) -> CMP1_W < 5 > { CMP1_W :: new (self) } # [doc = "Bit 6 - Compare 2 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp2 (& mut self) -> CMP2_W < 6 > { CMP2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_intctrl](index.html) module"]
pub struct SINGLE_INTCTRL_SPEC ; impl crate :: RegisterSpec for SINGLE_INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_intctrl::R](R) reader structure"]
impl crate :: Readable for SINGLE_INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_intctrl::W](W) writer structure"]
impl crate :: Writable for SINGLE_INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for SINGLE_INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_INTFLAGS (rw) register accessor: an alias for `Reg<SINGLE_INTFLAGS_SPEC>`"]
pub type SINGLE_INTFLAGS = crate :: Reg < single_intflags :: SINGLE_INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod single_intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < SINGLE_INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < SINGLE_INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CMP0` reader - Compare 0 Interrupt"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0 Interrupt"]
pub type CMP0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CMP1` reader - Compare 1 Interrupt"]
pub type CMP1_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1` writer - Compare 1 Interrupt"]
pub type CMP1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CMP2` reader - Compare 2 Interrupt"]
pub type CMP2_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2` writer - Compare 2 Interrupt"]
pub type CMP2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SINGLE_INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Compare 0 Interrupt"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare 1 Interrupt"]
# [inline (always)]
pub fn cmp1 (& self) -> CMP1_R { CMP1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare 2 Interrupt"]
# [inline (always)]
pub fn cmp2 (& self) -> CMP2_R { CMP2_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 4 - Compare 0 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp0 (& mut self) -> CMP0_W < 4 > { CMP0_W :: new (self) } # [doc = "Bit 5 - Compare 1 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp1 (& mut self) -> CMP1_W < 5 > { CMP1_W :: new (self) } # [doc = "Bit 6 - Compare 2 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp2 (& mut self) -> CMP2_W < 6 > { CMP2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_intflags](index.html) module"]
pub struct SINGLE_INTFLAGS_SPEC ; impl crate :: RegisterSpec for SINGLE_INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_intflags::R](R) reader structure"]
impl crate :: Readable for SINGLE_INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_intflags::W](W) writer structure"]
impl crate :: Writable for SINGLE_INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for SINGLE_INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_PER (rw) register accessor: an alias for `Reg<SINGLE_PER_SPEC>`"]
pub type SINGLE_PER = crate :: Reg < single_per :: SINGLE_PER_SPEC > ; # [doc = "Period"]
pub mod single_per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < SINGLE_PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < SINGLE_PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_per](index.html) module"]
pub struct SINGLE_PER_SPEC ; impl crate :: RegisterSpec for SINGLE_PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_per::R](R) reader structure"]
impl crate :: Readable for SINGLE_PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_per::W](W) writer structure"]
impl crate :: Writable for SINGLE_PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for SINGLE_PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_PERBUF (rw) register accessor: an alias for `Reg<SINGLE_PERBUF_SPEC>`"]
pub type SINGLE_PERBUF = crate :: Reg < single_perbuf :: SINGLE_PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod single_perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < SINGLE_PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < SINGLE_PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_perbuf](index.html) module"]
pub struct SINGLE_PERBUF_SPEC ; impl crate :: RegisterSpec for SINGLE_PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [single_perbuf::R](R) reader structure"]
impl crate :: Readable for SINGLE_PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_perbuf::W](W) writer structure"]
impl crate :: Writable for SINGLE_PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for SINGLE_PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SINGLE_TEMP (rw) register accessor: an alias for `Reg<SINGLE_TEMP_SPEC>`"]
pub type SINGLE_TEMP = crate :: Reg < single_temp :: SINGLE_TEMP_SPEC > ; # [doc = "Temporary data for 16-bit Access"]
pub mod single_temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < SINGLE_TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SINGLE_TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SINGLE_TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SINGLE_TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < SINGLE_TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SINGLE_TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SINGLE_TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SINGLE_TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary data for 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [single_temp](index.html) module"]
pub struct SINGLE_TEMP_SPEC ; impl crate :: RegisterSpec for SINGLE_TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [single_temp::R](R) reader structure"]
impl crate :: Readable for SINGLE_TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [single_temp::W](W) writer structure"]
impl crate :: Writable for SINGLE_TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for SINGLE_TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_CTRLA (rw) register accessor: an alias for `Reg<SPLIT_CTRLA_SPEC>`"]
pub type SPLIT_CTRLA = crate :: Reg < split_ctrla :: SPLIT_CTRLA_SPEC > ; # [doc = "Control A"]
pub mod split_ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < SPLIT_CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < SPLIT_CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Module Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Module Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: System Clock"]
DIV1 = 0 , # [doc = "1: System Clock / 2"]
DIV2 = 1 , # [doc = "2: System Clock / 4"]
DIV4 = 2 , # [doc = "3: System Clock / 8"]
DIV8 = 3 , # [doc = "4: System Clock / 16"]
DIV16 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: DIV1 , 1 => CLKSEL_A :: DIV2 , 2 => CLKSEL_A :: DIV4 , 3 => CLKSEL_A :: DIV8 , 4 => CLKSEL_A :: DIV16 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == CLKSEL_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SPLIT_CTRLA_SPEC , u8 , CLKSEL_A , 3 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } } impl R { # [doc = "Bit 0 - Module Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 7) } } impl W { # [doc = "Bit 0 - Module Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_ctrla](index.html) module"]
pub struct SPLIT_CTRLA_SPEC ; impl crate :: RegisterSpec for SPLIT_CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_ctrla::R](R) reader structure"]
impl crate :: Readable for SPLIT_CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_ctrla::W](W) writer structure"]
impl crate :: Writable for SPLIT_CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for SPLIT_CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_CTRLB (rw) register accessor: an alias for `Reg<SPLIT_CTRLB_SPEC>`"]
pub type SPLIT_CTRLB = crate :: Reg < split_ctrlb :: SPLIT_CTRLB_SPEC > ; # [doc = "Control B"]
pub mod split_ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < SPLIT_CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < SPLIT_CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `LCMP0EN` reader - Low Compare 0 Enable"]
pub type LCMP0EN_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP0EN` writer - Low Compare 0 Enable"]
pub type LCMP0EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLB_SPEC , bool , O > ; # [doc = "Field `LCMP1EN` reader - Low Compare 1 Enable"]
pub type LCMP1EN_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP1EN` writer - Low Compare 1 Enable"]
pub type LCMP1EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLB_SPEC , bool , O > ; # [doc = "Field `LCMP2EN` reader - Low Compare 2 Enable"]
pub type LCMP2EN_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP2EN` writer - Low Compare 2 Enable"]
pub type LCMP2EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLB_SPEC , bool , O > ; # [doc = "Field `HCMP0EN` reader - High Compare 0 Enable"]
pub type HCMP0EN_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP0EN` writer - High Compare 0 Enable"]
pub type HCMP0EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLB_SPEC , bool , O > ; # [doc = "Field `HCMP1EN` reader - High Compare 1 Enable"]
pub type HCMP1EN_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP1EN` writer - High Compare 1 Enable"]
pub type HCMP1EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLB_SPEC , bool , O > ; # [doc = "Field `HCMP2EN` reader - High Compare 2 Enable"]
pub type HCMP2EN_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP2EN` writer - High Compare 2 Enable"]
pub type HCMP2EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Compare 0 Enable"]
# [inline (always)]
pub fn lcmp0en (& self) -> LCMP0EN_R { LCMP0EN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Low Compare 1 Enable"]
# [inline (always)]
pub fn lcmp1en (& self) -> LCMP1EN_R { LCMP1EN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Low Compare 2 Enable"]
# [inline (always)]
pub fn lcmp2en (& self) -> LCMP2EN_R { LCMP2EN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - High Compare 0 Enable"]
# [inline (always)]
pub fn hcmp0en (& self) -> HCMP0EN_R { HCMP0EN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - High Compare 1 Enable"]
# [inline (always)]
pub fn hcmp1en (& self) -> HCMP1EN_R { HCMP1EN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - High Compare 2 Enable"]
# [inline (always)]
pub fn hcmp2en (& self) -> HCMP2EN_R { HCMP2EN_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Compare 0 Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp0en (& mut self) -> LCMP0EN_W < 0 > { LCMP0EN_W :: new (self) } # [doc = "Bit 1 - Low Compare 1 Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp1en (& mut self) -> LCMP1EN_W < 1 > { LCMP1EN_W :: new (self) } # [doc = "Bit 2 - Low Compare 2 Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp2en (& mut self) -> LCMP2EN_W < 2 > { LCMP2EN_W :: new (self) } # [doc = "Bit 4 - High Compare 0 Enable"]
# [inline (always)]
# [must_use]
pub fn hcmp0en (& mut self) -> HCMP0EN_W < 4 > { HCMP0EN_W :: new (self) } # [doc = "Bit 5 - High Compare 1 Enable"]
# [inline (always)]
# [must_use]
pub fn hcmp1en (& mut self) -> HCMP1EN_W < 5 > { HCMP1EN_W :: new (self) } # [doc = "Bit 6 - High Compare 2 Enable"]
# [inline (always)]
# [must_use]
pub fn hcmp2en (& mut self) -> HCMP2EN_W < 6 > { HCMP2EN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_ctrlb](index.html) module"]
pub struct SPLIT_CTRLB_SPEC ; impl crate :: RegisterSpec for SPLIT_CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_ctrlb::R](R) reader structure"]
impl crate :: Readable for SPLIT_CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_ctrlb::W](W) writer structure"]
impl crate :: Writable for SPLIT_CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for SPLIT_CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_CTRLC (rw) register accessor: an alias for `Reg<SPLIT_CTRLC_SPEC>`"]
pub type SPLIT_CTRLC = crate :: Reg < split_ctrlc :: SPLIT_CTRLC_SPEC > ; # [doc = "Control C"]
pub mod split_ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < SPLIT_CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < SPLIT_CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `LCMP0OV` reader - Low Compare 0 Output Value"]
pub type LCMP0OV_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP0OV` writer - Low Compare 0 Output Value"]
pub type LCMP0OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLC_SPEC , bool , O > ; # [doc = "Field `LCMP1OV` reader - Low Compare 1 Output Value"]
pub type LCMP1OV_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP1OV` writer - Low Compare 1 Output Value"]
pub type LCMP1OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLC_SPEC , bool , O > ; # [doc = "Field `LCMP2OV` reader - Low Compare 2 Output Value"]
pub type LCMP2OV_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP2OV` writer - Low Compare 2 Output Value"]
pub type LCMP2OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLC_SPEC , bool , O > ; # [doc = "Field `HCMP0OV` reader - High Compare 0 Output Value"]
pub type HCMP0OV_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP0OV` writer - High Compare 0 Output Value"]
pub type HCMP0OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLC_SPEC , bool , O > ; # [doc = "Field `HCMP1OV` reader - High Compare 1 Output Value"]
pub type HCMP1OV_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP1OV` writer - High Compare 1 Output Value"]
pub type HCMP1OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLC_SPEC , bool , O > ; # [doc = "Field `HCMP2OV` reader - High Compare 2 Output Value"]
pub type HCMP2OV_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP2OV` writer - High Compare 2 Output Value"]
pub type HCMP2OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Compare 0 Output Value"]
# [inline (always)]
pub fn lcmp0ov (& self) -> LCMP0OV_R { LCMP0OV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Low Compare 1 Output Value"]
# [inline (always)]
pub fn lcmp1ov (& self) -> LCMP1OV_R { LCMP1OV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Low Compare 2 Output Value"]
# [inline (always)]
pub fn lcmp2ov (& self) -> LCMP2OV_R { LCMP2OV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - High Compare 0 Output Value"]
# [inline (always)]
pub fn hcmp0ov (& self) -> HCMP0OV_R { HCMP0OV_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - High Compare 1 Output Value"]
# [inline (always)]
pub fn hcmp1ov (& self) -> HCMP1OV_R { HCMP1OV_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - High Compare 2 Output Value"]
# [inline (always)]
pub fn hcmp2ov (& self) -> HCMP2OV_R { HCMP2OV_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Compare 0 Output Value"]
# [inline (always)]
# [must_use]
pub fn lcmp0ov (& mut self) -> LCMP0OV_W < 0 > { LCMP0OV_W :: new (self) } # [doc = "Bit 1 - Low Compare 1 Output Value"]
# [inline (always)]
# [must_use]
pub fn lcmp1ov (& mut self) -> LCMP1OV_W < 1 > { LCMP1OV_W :: new (self) } # [doc = "Bit 2 - Low Compare 2 Output Value"]
# [inline (always)]
# [must_use]
pub fn lcmp2ov (& mut self) -> LCMP2OV_W < 2 > { LCMP2OV_W :: new (self) } # [doc = "Bit 4 - High Compare 0 Output Value"]
# [inline (always)]
# [must_use]
pub fn hcmp0ov (& mut self) -> HCMP0OV_W < 4 > { HCMP0OV_W :: new (self) } # [doc = "Bit 5 - High Compare 1 Output Value"]
# [inline (always)]
# [must_use]
pub fn hcmp1ov (& mut self) -> HCMP1OV_W < 5 > { HCMP1OV_W :: new (self) } # [doc = "Bit 6 - High Compare 2 Output Value"]
# [inline (always)]
# [must_use]
pub fn hcmp2ov (& mut self) -> HCMP2OV_W < 6 > { HCMP2OV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_ctrlc](index.html) module"]
pub struct SPLIT_CTRLC_SPEC ; impl crate :: RegisterSpec for SPLIT_CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_ctrlc::R](R) reader structure"]
impl crate :: Readable for SPLIT_CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_ctrlc::W](W) writer structure"]
impl crate :: Writable for SPLIT_CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for SPLIT_CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_CTRLD (rw) register accessor: an alias for `Reg<SPLIT_CTRLD_SPEC>`"]
pub type SPLIT_CTRLD = crate :: Reg < split_ctrld :: SPLIT_CTRLD_SPEC > ; # [doc = "Control D"]
pub mod split_ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < SPLIT_CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < SPLIT_CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPLITM` reader - Split Mode Enable"]
pub type SPLITM_R = crate :: BitReader < bool > ; # [doc = "Field `SPLITM` writer - Split Mode Enable"]
pub type SPLITM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_CTRLD_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Split Mode Enable"]
# [inline (always)]
pub fn splitm (& self) -> SPLITM_R { SPLITM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Split Mode Enable"]
# [inline (always)]
# [must_use]
pub fn splitm (& mut self) -> SPLITM_W < 0 > { SPLITM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_ctrld](index.html) module"]
pub struct SPLIT_CTRLD_SPEC ; impl crate :: RegisterSpec for SPLIT_CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_ctrld::R](R) reader structure"]
impl crate :: Readable for SPLIT_CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_ctrld::W](W) writer structure"]
impl crate :: Writable for SPLIT_CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for SPLIT_CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_CTRLECLR (rw) register accessor: an alias for `Reg<SPLIT_CTRLECLR_SPEC>`"]
pub type SPLIT_CTRLECLR = crate :: Reg < split_ctrleclr :: SPLIT_CTRLECLR_SPEC > ; # [doc = "Control E Clear"]
pub mod split_ctrleclr { # [doc = "Register `CTRLECLR` reader"]
pub struct R (crate :: R < SPLIT_CTRLECLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_CTRLECLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_CTRLECLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_CTRLECLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLECLR` writer"]
pub struct W (crate :: W < SPLIT_CTRLECLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_CTRLECLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_CTRLECLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_CTRLECLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SPLIT_CTRLECLR_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_ctrleclr](index.html) module"]
pub struct SPLIT_CTRLECLR_SPEC ; impl crate :: RegisterSpec for SPLIT_CTRLECLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_ctrleclr::R](R) reader structure"]
impl crate :: Readable for SPLIT_CTRLECLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_ctrleclr::W](W) writer structure"]
impl crate :: Writable for SPLIT_CTRLECLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLECLR to value 0"]
impl crate :: Resettable for SPLIT_CTRLECLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_CTRLESET (rw) register accessor: an alias for `Reg<SPLIT_CTRLESET_SPEC>`"]
pub type SPLIT_CTRLESET = crate :: Reg < split_ctrleset :: SPLIT_CTRLESET_SPEC > ; # [doc = "Control E Set"]
pub mod split_ctrleset { # [doc = "Register `CTRLESET` reader"]
pub struct R (crate :: R < SPLIT_CTRLESET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_CTRLESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_CTRLESET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_CTRLESET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLESET` writer"]
pub struct W (crate :: W < SPLIT_CTRLESET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_CTRLESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_CTRLESET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_CTRLESET_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SPLIT_CTRLESET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_ctrleset](index.html) module"]
pub struct SPLIT_CTRLESET_SPEC ; impl crate :: RegisterSpec for SPLIT_CTRLESET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_ctrleset::R](R) reader structure"]
impl crate :: Readable for SPLIT_CTRLESET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_ctrleset::W](W) writer structure"]
impl crate :: Writable for SPLIT_CTRLESET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLESET to value 0"]
impl crate :: Resettable for SPLIT_CTRLESET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_DBGCTRL (rw) register accessor: an alias for `Reg<SPLIT_DBGCTRL_SPEC>`"]
pub type SPLIT_DBGCTRL = crate :: Reg < split_dbgctrl :: SPLIT_DBGCTRL_SPEC > ; # [doc = "Degbug Control"]
pub mod split_dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < SPLIT_DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < SPLIT_DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Degbug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_dbgctrl](index.html) module"]
pub struct SPLIT_DBGCTRL_SPEC ; impl crate :: RegisterSpec for SPLIT_DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_dbgctrl::R](R) reader structure"]
impl crate :: Readable for SPLIT_DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_dbgctrl::W](W) writer structure"]
impl crate :: Writable for SPLIT_DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for SPLIT_DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_HCMP0 (rw) register accessor: an alias for `Reg<SPLIT_HCMP0_SPEC>`"]
pub type SPLIT_HCMP0 = crate :: Reg < split_hcmp0 :: SPLIT_HCMP0_SPEC > ; # [doc = "High Compare"]
pub mod split_hcmp0 { # [doc = "Register `HCMP0` reader"]
pub struct R (crate :: R < SPLIT_HCMP0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_HCMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_HCMP0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_HCMP0_SPEC >) -> Self { R (reader) } } # [doc = "Register `HCMP0` writer"]
pub struct W (crate :: W < SPLIT_HCMP0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_HCMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_HCMP0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_HCMP0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_hcmp0](index.html) module"]
pub struct SPLIT_HCMP0_SPEC ; impl crate :: RegisterSpec for SPLIT_HCMP0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_hcmp0::R](R) reader structure"]
impl crate :: Readable for SPLIT_HCMP0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_hcmp0::W](W) writer structure"]
impl crate :: Writable for SPLIT_HCMP0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HCMP0 to value 0"]
impl crate :: Resettable for SPLIT_HCMP0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_HCMP1 (rw) register accessor: an alias for `Reg<SPLIT_HCMP1_SPEC>`"]
pub type SPLIT_HCMP1 = crate :: Reg < split_hcmp1 :: SPLIT_HCMP1_SPEC > ; # [doc = "High Compare"]
pub mod split_hcmp1 { # [doc = "Register `HCMP1` reader"]
pub struct R (crate :: R < SPLIT_HCMP1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_HCMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_HCMP1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_HCMP1_SPEC >) -> Self { R (reader) } } # [doc = "Register `HCMP1` writer"]
pub struct W (crate :: W < SPLIT_HCMP1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_HCMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_HCMP1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_HCMP1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_hcmp1](index.html) module"]
pub struct SPLIT_HCMP1_SPEC ; impl crate :: RegisterSpec for SPLIT_HCMP1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_hcmp1::R](R) reader structure"]
impl crate :: Readable for SPLIT_HCMP1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_hcmp1::W](W) writer structure"]
impl crate :: Writable for SPLIT_HCMP1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HCMP1 to value 0"]
impl crate :: Resettable for SPLIT_HCMP1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_HCMP2 (rw) register accessor: an alias for `Reg<SPLIT_HCMP2_SPEC>`"]
pub type SPLIT_HCMP2 = crate :: Reg < split_hcmp2 :: SPLIT_HCMP2_SPEC > ; # [doc = "High Compare"]
pub mod split_hcmp2 { # [doc = "Register `HCMP2` reader"]
pub struct R (crate :: R < SPLIT_HCMP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_HCMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_HCMP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_HCMP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `HCMP2` writer"]
pub struct W (crate :: W < SPLIT_HCMP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_HCMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_HCMP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_HCMP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_hcmp2](index.html) module"]
pub struct SPLIT_HCMP2_SPEC ; impl crate :: RegisterSpec for SPLIT_HCMP2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_hcmp2::R](R) reader structure"]
impl crate :: Readable for SPLIT_HCMP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_hcmp2::W](W) writer structure"]
impl crate :: Writable for SPLIT_HCMP2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HCMP2 to value 0"]
impl crate :: Resettable for SPLIT_HCMP2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_HCNT (rw) register accessor: an alias for `Reg<SPLIT_HCNT_SPEC>`"]
pub type SPLIT_HCNT = crate :: Reg < split_hcnt :: SPLIT_HCNT_SPEC > ; # [doc = "High Count"]
pub mod split_hcnt { # [doc = "Register `HCNT` reader"]
pub struct R (crate :: R < SPLIT_HCNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_HCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_HCNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_HCNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `HCNT` writer"]
pub struct W (crate :: W < SPLIT_HCNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_HCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_HCNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_HCNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_hcnt](index.html) module"]
pub struct SPLIT_HCNT_SPEC ; impl crate :: RegisterSpec for SPLIT_HCNT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_hcnt::R](R) reader structure"]
impl crate :: Readable for SPLIT_HCNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_hcnt::W](W) writer structure"]
impl crate :: Writable for SPLIT_HCNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HCNT to value 0"]
impl crate :: Resettable for SPLIT_HCNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_HPER (rw) register accessor: an alias for `Reg<SPLIT_HPER_SPEC>`"]
pub type SPLIT_HPER = crate :: Reg < split_hper :: SPLIT_HPER_SPEC > ; # [doc = "High Period"]
pub mod split_hper { # [doc = "Register `HPER` reader"]
pub struct R (crate :: R < SPLIT_HPER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_HPER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_HPER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_HPER_SPEC >) -> Self { R (reader) } } # [doc = "Register `HPER` writer"]
pub struct W (crate :: W < SPLIT_HPER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_HPER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_HPER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_HPER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_hper](index.html) module"]
pub struct SPLIT_HPER_SPEC ; impl crate :: RegisterSpec for SPLIT_HPER_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_hper::R](R) reader structure"]
impl crate :: Readable for SPLIT_HPER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_hper::W](W) writer structure"]
impl crate :: Writable for SPLIT_HPER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HPER to value 0"]
impl crate :: Resettable for SPLIT_HPER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_INTCTRL (rw) register accessor: an alias for `Reg<SPLIT_INTCTRL_SPEC>`"]
pub type SPLIT_INTCTRL = crate :: Reg < split_intctrl :: SPLIT_INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod split_intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < SPLIT_INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < SPLIT_INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `LUNF` reader - Low Underflow Interrupt Enable"]
pub type LUNF_R = crate :: BitReader < bool > ; # [doc = "Field `LUNF` writer - Low Underflow Interrupt Enable"]
pub type LUNF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTCTRL_SPEC , bool , O > ; # [doc = "Field `HUNF` reader - High Underflow Interrupt Enable"]
pub type HUNF_R = crate :: BitReader < bool > ; # [doc = "Field `HUNF` writer - High Underflow Interrupt Enable"]
pub type HUNF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTCTRL_SPEC , bool , O > ; # [doc = "Field `LCMP0` reader - Low Compare 0 Interrupt Enable"]
pub type LCMP0_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP0` writer - Low Compare 0 Interrupt Enable"]
pub type LCMP0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTCTRL_SPEC , bool , O > ; # [doc = "Field `LCMP1` reader - Low Compare 1 Interrupt Enable"]
pub type LCMP1_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP1` writer - Low Compare 1 Interrupt Enable"]
pub type LCMP1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTCTRL_SPEC , bool , O > ; # [doc = "Field `LCMP2` reader - Low Compare 2 Interrupt Enable"]
pub type LCMP2_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP2` writer - Low Compare 2 Interrupt Enable"]
pub type LCMP2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Underflow Interrupt Enable"]
# [inline (always)]
pub fn lunf (& self) -> LUNF_R { LUNF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - High Underflow Interrupt Enable"]
# [inline (always)]
pub fn hunf (& self) -> HUNF_R { HUNF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Low Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn lcmp0 (& self) -> LCMP0_R { LCMP0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Low Compare 1 Interrupt Enable"]
# [inline (always)]
pub fn lcmp1 (& self) -> LCMP1_R { LCMP1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Low Compare 2 Interrupt Enable"]
# [inline (always)]
pub fn lcmp2 (& self) -> LCMP2_R { LCMP2_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Underflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn lunf (& mut self) -> LUNF_W < 0 > { LUNF_W :: new (self) } # [doc = "Bit 1 - High Underflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn hunf (& mut self) -> HUNF_W < 1 > { HUNF_W :: new (self) } # [doc = "Bit 4 - Low Compare 0 Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp0 (& mut self) -> LCMP0_W < 4 > { LCMP0_W :: new (self) } # [doc = "Bit 5 - Low Compare 1 Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp1 (& mut self) -> LCMP1_W < 5 > { LCMP1_W :: new (self) } # [doc = "Bit 6 - Low Compare 2 Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp2 (& mut self) -> LCMP2_W < 6 > { LCMP2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_intctrl](index.html) module"]
pub struct SPLIT_INTCTRL_SPEC ; impl crate :: RegisterSpec for SPLIT_INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_intctrl::R](R) reader structure"]
impl crate :: Readable for SPLIT_INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_intctrl::W](W) writer structure"]
impl crate :: Writable for SPLIT_INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for SPLIT_INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_INTFLAGS (rw) register accessor: an alias for `Reg<SPLIT_INTFLAGS_SPEC>`"]
pub type SPLIT_INTFLAGS = crate :: Reg < split_intflags :: SPLIT_INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod split_intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < SPLIT_INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < SPLIT_INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `LUNF` reader - Low Underflow Interrupt Flag"]
pub type LUNF_R = crate :: BitReader < bool > ; # [doc = "Field `LUNF` writer - Low Underflow Interrupt Flag"]
pub type LUNF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTFLAGS_SPEC , bool , O > ; # [doc = "Field `HUNF` reader - High Underflow Interrupt Flag"]
pub type HUNF_R = crate :: BitReader < bool > ; # [doc = "Field `HUNF` writer - High Underflow Interrupt Flag"]
pub type HUNF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTFLAGS_SPEC , bool , O > ; # [doc = "Field `LCMP0` reader - Low Compare 2 Interrupt Flag"]
pub type LCMP0_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP0` writer - Low Compare 2 Interrupt Flag"]
pub type LCMP0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTFLAGS_SPEC , bool , O > ; # [doc = "Field `LCMP1` reader - Low Compare 1 Interrupt Flag"]
pub type LCMP1_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP1` writer - Low Compare 1 Interrupt Flag"]
pub type LCMP1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTFLAGS_SPEC , bool , O > ; # [doc = "Field `LCMP2` reader - Low Compare 0 Interrupt Flag"]
pub type LCMP2_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP2` writer - Low Compare 0 Interrupt Flag"]
pub type LCMP2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPLIT_INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Underflow Interrupt Flag"]
# [inline (always)]
pub fn lunf (& self) -> LUNF_R { LUNF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - High Underflow Interrupt Flag"]
# [inline (always)]
pub fn hunf (& self) -> HUNF_R { HUNF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Low Compare 2 Interrupt Flag"]
# [inline (always)]
pub fn lcmp0 (& self) -> LCMP0_R { LCMP0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Low Compare 1 Interrupt Flag"]
# [inline (always)]
pub fn lcmp1 (& self) -> LCMP1_R { LCMP1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Low Compare 0 Interrupt Flag"]
# [inline (always)]
pub fn lcmp2 (& self) -> LCMP2_R { LCMP2_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Underflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn lunf (& mut self) -> LUNF_W < 0 > { LUNF_W :: new (self) } # [doc = "Bit 1 - High Underflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn hunf (& mut self) -> HUNF_W < 1 > { HUNF_W :: new (self) } # [doc = "Bit 4 - Low Compare 2 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn lcmp0 (& mut self) -> LCMP0_W < 4 > { LCMP0_W :: new (self) } # [doc = "Bit 5 - Low Compare 1 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn lcmp1 (& mut self) -> LCMP1_W < 5 > { LCMP1_W :: new (self) } # [doc = "Bit 6 - Low Compare 0 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn lcmp2 (& mut self) -> LCMP2_W < 6 > { LCMP2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_intflags](index.html) module"]
pub struct SPLIT_INTFLAGS_SPEC ; impl crate :: RegisterSpec for SPLIT_INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_intflags::R](R) reader structure"]
impl crate :: Readable for SPLIT_INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_intflags::W](W) writer structure"]
impl crate :: Writable for SPLIT_INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for SPLIT_INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_LCMP0 (rw) register accessor: an alias for `Reg<SPLIT_LCMP0_SPEC>`"]
pub type SPLIT_LCMP0 = crate :: Reg < split_lcmp0 :: SPLIT_LCMP0_SPEC > ; # [doc = "Low Compare"]
pub mod split_lcmp0 { # [doc = "Register `LCMP0` reader"]
pub struct R (crate :: R < SPLIT_LCMP0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_LCMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_LCMP0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_LCMP0_SPEC >) -> Self { R (reader) } } # [doc = "Register `LCMP0` writer"]
pub struct W (crate :: W < SPLIT_LCMP0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_LCMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_LCMP0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_LCMP0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_lcmp0](index.html) module"]
pub struct SPLIT_LCMP0_SPEC ; impl crate :: RegisterSpec for SPLIT_LCMP0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_lcmp0::R](R) reader structure"]
impl crate :: Readable for SPLIT_LCMP0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_lcmp0::W](W) writer structure"]
impl crate :: Writable for SPLIT_LCMP0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCMP0 to value 0"]
impl crate :: Resettable for SPLIT_LCMP0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_LCMP1 (rw) register accessor: an alias for `Reg<SPLIT_LCMP1_SPEC>`"]
pub type SPLIT_LCMP1 = crate :: Reg < split_lcmp1 :: SPLIT_LCMP1_SPEC > ; # [doc = "Low Compare"]
pub mod split_lcmp1 { # [doc = "Register `LCMP1` reader"]
pub struct R (crate :: R < SPLIT_LCMP1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_LCMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_LCMP1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_LCMP1_SPEC >) -> Self { R (reader) } } # [doc = "Register `LCMP1` writer"]
pub struct W (crate :: W < SPLIT_LCMP1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_LCMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_LCMP1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_LCMP1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_lcmp1](index.html) module"]
pub struct SPLIT_LCMP1_SPEC ; impl crate :: RegisterSpec for SPLIT_LCMP1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_lcmp1::R](R) reader structure"]
impl crate :: Readable for SPLIT_LCMP1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_lcmp1::W](W) writer structure"]
impl crate :: Writable for SPLIT_LCMP1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCMP1 to value 0"]
impl crate :: Resettable for SPLIT_LCMP1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_LCMP2 (rw) register accessor: an alias for `Reg<SPLIT_LCMP2_SPEC>`"]
pub type SPLIT_LCMP2 = crate :: Reg < split_lcmp2 :: SPLIT_LCMP2_SPEC > ; # [doc = "Low Compare"]
pub mod split_lcmp2 { # [doc = "Register `LCMP2` reader"]
pub struct R (crate :: R < SPLIT_LCMP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_LCMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_LCMP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_LCMP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `LCMP2` writer"]
pub struct W (crate :: W < SPLIT_LCMP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_LCMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_LCMP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_LCMP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_lcmp2](index.html) module"]
pub struct SPLIT_LCMP2_SPEC ; impl crate :: RegisterSpec for SPLIT_LCMP2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_lcmp2::R](R) reader structure"]
impl crate :: Readable for SPLIT_LCMP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_lcmp2::W](W) writer structure"]
impl crate :: Writable for SPLIT_LCMP2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCMP2 to value 0"]
impl crate :: Resettable for SPLIT_LCMP2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_LCNT (rw) register accessor: an alias for `Reg<SPLIT_LCNT_SPEC>`"]
pub type SPLIT_LCNT = crate :: Reg < split_lcnt :: SPLIT_LCNT_SPEC > ; # [doc = "Low Count"]
pub mod split_lcnt { # [doc = "Register `LCNT` reader"]
pub struct R (crate :: R < SPLIT_LCNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_LCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_LCNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_LCNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `LCNT` writer"]
pub struct W (crate :: W < SPLIT_LCNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_LCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_LCNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_LCNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_lcnt](index.html) module"]
pub struct SPLIT_LCNT_SPEC ; impl crate :: RegisterSpec for SPLIT_LCNT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_lcnt::R](R) reader structure"]
impl crate :: Readable for SPLIT_LCNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_lcnt::W](W) writer structure"]
impl crate :: Writable for SPLIT_LCNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCNT to value 0"]
impl crate :: Resettable for SPLIT_LCNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPLIT_LPER (rw) register accessor: an alias for `Reg<SPLIT_LPER_SPEC>`"]
pub type SPLIT_LPER = crate :: Reg < split_lper :: SPLIT_LPER_SPEC > ; # [doc = "Low Period"]
pub mod split_lper { # [doc = "Register `LPER` reader"]
pub struct R (crate :: R < SPLIT_LPER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPLIT_LPER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPLIT_LPER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPLIT_LPER_SPEC >) -> Self { R (reader) } } # [doc = "Register `LPER` writer"]
pub struct W (crate :: W < SPLIT_LPER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPLIT_LPER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPLIT_LPER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPLIT_LPER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [split_lper](index.html) module"]
pub struct SPLIT_LPER_SPEC ; impl crate :: RegisterSpec for SPLIT_LPER_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [split_lper::R](R) reader structure"]
impl crate :: Readable for SPLIT_LPER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [split_lper::W](W) writer structure"]
impl crate :: Writable for SPLIT_LPER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LPER to value 0"]
impl crate :: Resettable for SPLIT_LPER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer Type B"]
pub struct TCB0 { _marker : PhantomData < * const () > } unsafe impl Send for TCB0 { } impl TCB0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcb0 :: RegisterBlock = 0x0a40 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcb0 :: RegisterBlock { Self :: PTR } } impl Deref for TCB0 { type Target = tcb0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCB0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCB0") . finish () } } # [doc = "16-bit Timer Type B"]
pub mod tcb0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , _reserved2 : [u8 ; 0x02]
, # [doc = "0x04 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x05 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x06 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x07 - Status"]
pub status : STATUS , # [doc = "0x08 - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x09 - Temporary Value"]
pub temp : TEMP , # [doc = "0x0a - Count"]
pub cnt : CNT , # [doc = "0x0c - Compare or Capture"]
pub ccmp : CCMP , } # [doc = "CCMP (rw) register accessor: an alias for `Reg<CCMP_SPEC>`"]
pub type CCMP = crate :: Reg < ccmp :: CCMP_SPEC > ; # [doc = "Compare or Capture"]
pub mod ccmp { # [doc = "Register `CCMP` reader"]
pub struct R (crate :: R < CCMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCMP` writer"]
pub struct W (crate :: W < CCMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmp](index.html) module"]
pub struct CCMP_SPEC ; impl crate :: RegisterSpec for CCMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccmp::R](R) reader structure"]
impl crate :: Readable for CCMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccmp::W](W) writer structure"]
impl crate :: Writable for CCMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCMP to value 0"]
impl crate :: Resettable for CCMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: CLK_PER (No Prescaling)"]
CLKDIV1 = 0 , # [doc = "1: CLK_PER/2 (From Prescaler)"]
CLKDIV2 = 1 , # [doc = "2: Use Clock from TCA"]
CLKTCA = 2 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSEL_A > { match self . bits { 0 => Some (CLKSEL_A :: CLKDIV1) , 1 => Some (CLKSEL_A :: CLKDIV2) , 2 => Some (CLKSEL_A :: CLKTCA) , _ => None , } } # [doc = "Checks if the value of the field is `CLKDIV1`"]
# [inline (always)]
pub fn is_clkdiv1 (& self) -> bool { * self == CLKSEL_A :: CLKDIV1 } # [doc = "Checks if the value of the field is `CLKDIV2`"]
# [inline (always)]
pub fn is_clkdiv2 (& self) -> bool { * self == CLKSEL_A :: CLKDIV2 } # [doc = "Checks if the value of the field is `CLKTCA`"]
# [inline (always)]
pub fn is_clktca (& self) -> bool { * self == CLKSEL_A :: CLKTCA } } # [doc = "Field `CLKSEL` writer - Clock Select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "CLK_PER (No Prescaling)"]
# [inline (always)]
pub fn clkdiv1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV1) } # [doc = "CLK_PER/2 (From Prescaler)"]
# [inline (always)]
pub fn clkdiv2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV2) } # [doc = "Use Clock from TCA"]
# [inline (always)]
pub fn clktca (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKTCA) } } # [doc = "Field `SYNCUPD` reader - Synchronize Update"]
pub type SYNCUPD_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCUPD` writer - Synchronize Update"]
pub type SYNCUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
pub fn syncupd (& self) -> SYNCUPD_R { SYNCUPD_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
# [must_use]
pub fn syncupd (& mut self) -> SYNCUPD_W < 4 > { SYNCUPD_W :: new (self) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 6 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CNTMODE` reader - Timer Mode"]
pub type CNTMODE_R = crate :: FieldReader < u8 , CNTMODE_A > ; # [doc = "Timer Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CNTMODE_A { # [doc = "0: Periodic Interrupt"]
INT = 0 , # [doc = "1: Periodic Timeout"]
TIMEOUT = 1 , # [doc = "2: Input Capture Event"]
CAPT = 2 , # [doc = "3: Input Capture Frequency measurement"]
FRQ = 3 , # [doc = "4: Input Capture Pulse-Width measurement"]
PW = 4 , # [doc = "5: Input Capture Frequency and Pulse-Width measurement"]
FRQPW = 5 , # [doc = "6: Single Shot"]
SINGLE = 6 , # [doc = "7: 8-bit PWM"]
PWM8 = 7 , } impl From < CNTMODE_A > for u8 { # [inline (always)]
fn from (variant : CNTMODE_A) -> Self { variant as _ } } impl CNTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CNTMODE_A { match self . bits { 0 => CNTMODE_A :: INT , 1 => CNTMODE_A :: TIMEOUT , 2 => CNTMODE_A :: CAPT , 3 => CNTMODE_A :: FRQ , 4 => CNTMODE_A :: PW , 5 => CNTMODE_A :: FRQPW , 6 => CNTMODE_A :: SINGLE , 7 => CNTMODE_A :: PWM8 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == CNTMODE_A :: INT } # [doc = "Checks if the value of the field is `TIMEOUT`"]
# [inline (always)]
pub fn is_timeout (& self) -> bool { * self == CNTMODE_A :: TIMEOUT } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == CNTMODE_A :: CAPT } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == CNTMODE_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == CNTMODE_A :: PW } # [doc = "Checks if the value of the field is `FRQPW`"]
# [inline (always)]
pub fn is_frqpw (& self) -> bool { * self == CNTMODE_A :: FRQPW } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == CNTMODE_A :: SINGLE } # [doc = "Checks if the value of the field is `PWM8`"]
# [inline (always)]
pub fn is_pwm8 (& self) -> bool { * self == CNTMODE_A :: PWM8 } } # [doc = "Field `CNTMODE` writer - Timer Mode"]
pub type CNTMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , CNTMODE_A , 3 , O > ; impl < 'a , const O : u8 > CNTMODE_W < 'a , O > { # [doc = "Periodic Interrupt"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (CNTMODE_A :: INT) } # [doc = "Periodic Timeout"]
# [inline (always)]
pub fn timeout (self) -> & 'a mut W { self . variant (CNTMODE_A :: TIMEOUT) } # [doc = "Input Capture Event"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (CNTMODE_A :: CAPT) } # [doc = "Input Capture Frequency measurement"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQ) } # [doc = "Input Capture Pulse-Width measurement"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (CNTMODE_A :: PW) } # [doc = "Input Capture Frequency and Pulse-Width measurement"]
# [inline (always)]
pub fn frqpw (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQPW) } # [doc = "Single Shot"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (CNTMODE_A :: SINGLE) } # [doc = "8-bit PWM"]
# [inline (always)]
pub fn pwm8 (self) -> & 'a mut W { self . variant (CNTMODE_A :: PWM8) } } # [doc = "Field `CCMPEN` reader - Pin Output Enable"]
pub type CCMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPEN` writer - Pin Output Enable"]
pub type CCMPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCMPINIT` reader - Pin Initial State"]
pub type CCMPINIT_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPINIT` writer - Pin Initial State"]
pub type CCMPINIT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `ASYNC` reader - Asynchronous Enable"]
pub type ASYNC_R = crate :: BitReader < bool > ; # [doc = "Field `ASYNC` writer - Asynchronous Enable"]
pub type ASYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
pub fn cntmode (& self) -> CNTMODE_R { CNTMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
pub fn ccmpen (& self) -> CCMPEN_R { CCMPEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
pub fn ccmpinit (& self) -> CCMPINIT_R { CCMPINIT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
pub fn async_ (& self) -> ASYNC_R { ASYNC_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
# [must_use]
pub fn cntmode (& mut self) -> CNTMODE_W < 0 > { CNTMODE_W :: new (self) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
# [must_use]
pub fn ccmpen (& mut self) -> CCMPEN_W < 4 > { CCMPEN_W :: new (self) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
# [must_use]
pub fn ccmpinit (& mut self) -> CCMPINIT_W < 5 > { CCMPINIT_W :: new (self) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
# [must_use]
pub fn async_ (& mut self) -> ASYNC_W < 6 > { ASYNC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPTEI` reader - Event Input Enable"]
pub type CAPTEI_R = crate :: BitReader < bool > ; # [doc = "Field `CAPTEI` writer - Event Input Enable"]
pub type CAPTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `EDGE` reader - Event Edge"]
pub type EDGE_R = crate :: BitReader < bool > ; # [doc = "Field `EDGE` writer - Event Edge"]
pub type EDGE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `FILTER` reader - Input Capture Noise Cancellation Filter"]
pub type FILTER_R = crate :: BitReader < bool > ; # [doc = "Field `FILTER` writer - Input Capture Noise Cancellation Filter"]
pub type FILTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
pub fn captei (& self) -> CAPTEI_R { CAPTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
pub fn edge (& self) -> EDGE_R { EDGE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
pub fn filter (& self) -> FILTER_R { FILTER_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn captei (& mut self) -> CAPTEI_W < 0 > { CAPTEI_W :: new (self) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
# [must_use]
pub fn edge (& mut self) -> EDGE_W < 4 > { EDGE_W :: new (self) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
# [must_use]
pub fn filter (& mut self) -> FILTER_W < 6 > { FILTER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `RUN` reader - Run"]
pub type RUN_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Run"]
# [inline (always)]
pub fn run (& self) -> RUN_R { RUN_R :: new ((self . bits & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Value"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer Counter D"]
pub struct TCD0 { _marker : PhantomData < * const () > } unsafe impl Send for TCD0 { } impl TCD0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcd0 :: RegisterBlock = 0x0a80 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcd0 :: RegisterBlock { Self :: PTR } } impl Deref for TCD0 { type Target = tcd0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCD0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCD0") . finish () } } # [doc = "Timer Counter D"]
pub mod tcd0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x03]
, # [doc = "0x08 - EVCTRLA"]
pub evctrla : EVCTRLA , # [doc = "0x09 - EVCTRLB"]
pub evctrlb : EVCTRLB , _reserved7 : [u8 ; 0x02]
, # [doc = "0x0c - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x0d - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0e - Status"]
pub status : STATUS , _reserved10 : [u8 ; 0x01]
, # [doc = "0x10 - Input Control A"]
pub inputctrla : INPUTCTRLA , # [doc = "0x11 - Input Control B"]
pub inputctrlb : INPUTCTRLB , # [doc = "0x12 - Fault Control"]
pub faultctrl : FAULTCTRL , _reserved13 : [u8 ; 0x01]
, # [doc = "0x14 - Delay Control"]
pub dlyctrl : DLYCTRL , # [doc = "0x15 - Delay value"]
pub dlyval : DLYVAL , _reserved15 : [u8 ; 0x02]
, # [doc = "0x18 - Dither Control A"]
pub ditctrl : DITCTRL , # [doc = "0x19 - Dither value"]
pub ditval : DITVAL , _reserved17 : [u8 ; 0x04]
, # [doc = "0x1e - Debug Control"]
pub dbgctrl : DBGCTRL , _reserved18 : [u8 ; 0x03]
, # [doc = "0x22 - Capture A"]
pub capturea : CAPTUREA , # [doc = "0x24 - Capture B"]
pub captureb : CAPTUREB , _reserved20 : [u8 ; 0x02]
, # [doc = "0x28 - Compare A Set"]
pub cmpaset : CMPASET , # [doc = "0x2a - Compare A Clear"]
pub cmpaclr : CMPACLR , # [doc = "0x2c - Compare B Set"]
pub cmpbset : CMPBSET , # [doc = "0x2e - Compare B Clear"]
pub cmpbclr : CMPBCLR , } # [doc = "CAPTUREA (r) register accessor: an alias for `Reg<CAPTUREA_SPEC>`"]
pub type CAPTUREA = crate :: Reg < capturea :: CAPTUREA_SPEC > ; # [doc = "Capture A"]
pub mod capturea { # [doc = "Register `CAPTUREA` reader"]
pub struct R (crate :: R < CAPTUREA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CAPTUREA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CAPTUREA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CAPTUREA_SPEC >) -> Self { R (reader) } } # [doc = "Capture A\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [capturea](index.html) module"]
pub struct CAPTUREA_SPEC ; impl crate :: RegisterSpec for CAPTUREA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [capturea::R](R) reader structure"]
impl crate :: Readable for CAPTUREA_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CAPTUREA to value 0"]
impl crate :: Resettable for CAPTUREA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CAPTUREB (r) register accessor: an alias for `Reg<CAPTUREB_SPEC>`"]
pub type CAPTUREB = crate :: Reg < captureb :: CAPTUREB_SPEC > ; # [doc = "Capture B"]
pub mod captureb { # [doc = "Register `CAPTUREB` reader"]
pub struct R (crate :: R < CAPTUREB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CAPTUREB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CAPTUREB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CAPTUREB_SPEC >) -> Self { R (reader) } } # [doc = "Capture B\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [captureb](index.html) module"]
pub struct CAPTUREB_SPEC ; impl crate :: RegisterSpec for CAPTUREB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [captureb::R](R) reader structure"]
impl crate :: Readable for CAPTUREB_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CAPTUREB to value 0"]
impl crate :: Resettable for CAPTUREB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMPACLR (rw) register accessor: an alias for `Reg<CMPACLR_SPEC>`"]
pub type CMPACLR = crate :: Reg < cmpaclr :: CMPACLR_SPEC > ; # [doc = "Compare A Clear"]
pub mod cmpaclr { # [doc = "Register `CMPACLR` reader"]
pub struct R (crate :: R < CMPACLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMPACLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMPACLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMPACLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMPACLR` writer"]
pub struct W (crate :: W < CMPACLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMPACLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMPACLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMPACLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPACLR` reader - Compare A Clear"]
pub type CMPACLR_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `CMPACLR` writer - Compare A Clear"]
pub type CMPACLR_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CMPACLR_SPEC , u16 , u16 , 12 , O > ; impl R { # [doc = "Bits 0:11 - Compare A Clear"]
# [inline (always)]
pub fn cmpaclr (& self) -> CMPACLR_R { CMPACLR_R :: new (self . bits & 0x0fff) } } impl W { # [doc = "Bits 0:11 - Compare A Clear"]
# [inline (always)]
# [must_use]
pub fn cmpaclr (& mut self) -> CMPACLR_W < 0 > { CMPACLR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare A Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmpaclr](index.html) module"]
pub struct CMPACLR_SPEC ; impl crate :: RegisterSpec for CMPACLR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmpaclr::R](R) reader structure"]
impl crate :: Readable for CMPACLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmpaclr::W](W) writer structure"]
impl crate :: Writable for CMPACLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMPACLR to value 0"]
impl crate :: Resettable for CMPACLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMPASET (rw) register accessor: an alias for `Reg<CMPASET_SPEC>`"]
pub type CMPASET = crate :: Reg < cmpaset :: CMPASET_SPEC > ; # [doc = "Compare A Set"]
pub mod cmpaset { # [doc = "Register `CMPASET` reader"]
pub struct R (crate :: R < CMPASET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMPASET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMPASET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMPASET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMPASET` writer"]
pub struct W (crate :: W < CMPASET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMPASET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMPASET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMPASET_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPASET` reader - Compare A Set"]
pub type CMPASET_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `CMPASET` writer - Compare A Set"]
pub type CMPASET_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CMPASET_SPEC , u16 , u16 , 12 , O > ; impl R { # [doc = "Bits 0:11 - Compare A Set"]
# [inline (always)]
pub fn cmpaset (& self) -> CMPASET_R { CMPASET_R :: new (self . bits & 0x0fff) } } impl W { # [doc = "Bits 0:11 - Compare A Set"]
# [inline (always)]
# [must_use]
pub fn cmpaset (& mut self) -> CMPASET_W < 0 > { CMPASET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare A Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmpaset](index.html) module"]
pub struct CMPASET_SPEC ; impl crate :: RegisterSpec for CMPASET_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmpaset::R](R) reader structure"]
impl crate :: Readable for CMPASET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmpaset::W](W) writer structure"]
impl crate :: Writable for CMPASET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMPASET to value 0"]
impl crate :: Resettable for CMPASET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMPBCLR (rw) register accessor: an alias for `Reg<CMPBCLR_SPEC>`"]
pub type CMPBCLR = crate :: Reg < cmpbclr :: CMPBCLR_SPEC > ; # [doc = "Compare B Clear"]
pub mod cmpbclr { # [doc = "Register `CMPBCLR` reader"]
pub struct R (crate :: R < CMPBCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMPBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMPBCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMPBCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMPBCLR` writer"]
pub struct W (crate :: W < CMPBCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMPBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMPBCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMPBCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPBCLR` reader - Compare B Clear"]
pub type CMPBCLR_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `CMPBCLR` writer - Compare B Clear"]
pub type CMPBCLR_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CMPBCLR_SPEC , u16 , u16 , 12 , O > ; impl R { # [doc = "Bits 0:11 - Compare B Clear"]
# [inline (always)]
pub fn cmpbclr (& self) -> CMPBCLR_R { CMPBCLR_R :: new (self . bits & 0x0fff) } } impl W { # [doc = "Bits 0:11 - Compare B Clear"]
# [inline (always)]
# [must_use]
pub fn cmpbclr (& mut self) -> CMPBCLR_W < 0 > { CMPBCLR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmpbclr](index.html) module"]
pub struct CMPBCLR_SPEC ; impl crate :: RegisterSpec for CMPBCLR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmpbclr::R](R) reader structure"]
impl crate :: Readable for CMPBCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmpbclr::W](W) writer structure"]
impl crate :: Writable for CMPBCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMPBCLR to value 0"]
impl crate :: Resettable for CMPBCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMPBSET (rw) register accessor: an alias for `Reg<CMPBSET_SPEC>`"]
pub type CMPBSET = crate :: Reg < cmpbset :: CMPBSET_SPEC > ; # [doc = "Compare B Set"]
pub mod cmpbset { # [doc = "Register `CMPBSET` reader"]
pub struct R (crate :: R < CMPBSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMPBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMPBSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMPBSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMPBSET` writer"]
pub struct W (crate :: W < CMPBSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMPBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMPBSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMPBSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPBSET` reader - Compare B Set"]
pub type CMPBSET_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `CMPBSET` writer - Compare B Set"]
pub type CMPBSET_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u16 , CMPBSET_SPEC , u16 , u16 , 12 , O > ; impl R { # [doc = "Bits 0:11 - Compare B Set"]
# [inline (always)]
pub fn cmpbset (& self) -> CMPBSET_R { CMPBSET_R :: new (self . bits & 0x0fff) } } impl W { # [doc = "Bits 0:11 - Compare B Set"]
# [inline (always)]
# [must_use]
pub fn cmpbset (& mut self) -> CMPBSET_W < 0 > { CMPBSET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmpbset](index.html) module"]
pub struct CMPBSET_SPEC ; impl crate :: RegisterSpec for CMPBSET_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmpbset::R](R) reader structure"]
impl crate :: Readable for CMPBSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmpbset::W](W) writer structure"]
impl crate :: Writable for CMPBSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMPBSET to value 0"]
impl crate :: Resettable for CMPBSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `SYNCPRES` reader - Syncronization prescaler"]
pub type SYNCPRES_R = crate :: FieldReader < u8 , SYNCPRES_A > ; # [doc = "Syncronization prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SYNCPRES_A { # [doc = "0: Selevted clock source divided by 1"]
DIV1 = 0 , # [doc = "1: Selevted clock source divided by 2"]
DIV2 = 1 , # [doc = "2: Selevted clock source divided by 4"]
DIV4 = 2 , # [doc = "3: Selevted clock source divided by 8"]
DIV8 = 3 , } impl From < SYNCPRES_A > for u8 { # [inline (always)]
fn from (variant : SYNCPRES_A) -> Self { variant as _ } } impl SYNCPRES_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SYNCPRES_A { match self . bits { 0 => SYNCPRES_A :: DIV1 , 1 => SYNCPRES_A :: DIV2 , 2 => SYNCPRES_A :: DIV4 , 3 => SYNCPRES_A :: DIV8 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == SYNCPRES_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == SYNCPRES_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == SYNCPRES_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == SYNCPRES_A :: DIV8 } } # [doc = "Field `SYNCPRES` writer - Syncronization prescaler"]
pub type SYNCPRES_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , SYNCPRES_A , 2 , O > ; impl < 'a , const O : u8 > SYNCPRES_W < 'a , O > { # [doc = "Selevted clock source divided by 1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (SYNCPRES_A :: DIV1) } # [doc = "Selevted clock source divided by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (SYNCPRES_A :: DIV2) } # [doc = "Selevted clock source divided by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (SYNCPRES_A :: DIV4) } # [doc = "Selevted clock source divided by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (SYNCPRES_A :: DIV8) } } # [doc = "Field `CNTPRES` reader - counter prescaler"]
pub type CNTPRES_R = crate :: FieldReader < u8 , CNTPRES_A > ; # [doc = "counter prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CNTPRES_A { # [doc = "0: Sync clock divided by 1"]
DIV1 = 0 , # [doc = "1: Sync clock divided by 4"]
DIV4 = 1 , # [doc = "2: Sync clock divided by 32"]
DIV32 = 2 , } impl From < CNTPRES_A > for u8 { # [inline (always)]
fn from (variant : CNTPRES_A) -> Self { variant as _ } } impl CNTPRES_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CNTPRES_A > { match self . bits { 0 => Some (CNTPRES_A :: DIV1) , 1 => Some (CNTPRES_A :: DIV4) , 2 => Some (CNTPRES_A :: DIV32) , _ => None , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CNTPRES_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CNTPRES_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == CNTPRES_A :: DIV32 } } # [doc = "Field `CNTPRES` writer - counter prescaler"]
pub type CNTPRES_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , CNTPRES_A , 2 , O > ; impl < 'a , const O : u8 > CNTPRES_W < 'a , O > { # [doc = "Sync clock divided by 1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CNTPRES_A :: DIV1) } # [doc = "Sync clock divided by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CNTPRES_A :: DIV4) } # [doc = "Sync clock divided by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (CNTPRES_A :: DIV32) } } # [doc = "Field `CLKSEL` reader - clock select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "clock select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: 20 MHz oscillator"]
_20MHZ = 0 , # [doc = "2: External clock"]
EXTCLK = 2 , # [doc = "3: System clock"]
SYSCLK = 3 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSEL_A > { match self . bits { 0 => Some (CLKSEL_A :: _20MHZ) , 2 => Some (CLKSEL_A :: EXTCLK) , 3 => Some (CLKSEL_A :: SYSCLK) , _ => None , } } # [doc = "Checks if the value of the field is `_20MHZ`"]
# [inline (always)]
pub fn is_20mhz (& self) -> bool { * self == CLKSEL_A :: _20MHZ } # [doc = "Checks if the value of the field is `EXTCLK`"]
# [inline (always)]
pub fn is_extclk (& self) -> bool { * self == CLKSEL_A :: EXTCLK } # [doc = "Checks if the value of the field is `SYSCLK`"]
# [inline (always)]
pub fn is_sysclk (& self) -> bool { * self == CLKSEL_A :: SYSCLK } } # [doc = "Field `CLKSEL` writer - clock select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "20 MHz oscillator"]
# [inline (always)]
pub fn _20mhz (self) -> & 'a mut W { self . variant (CLKSEL_A :: _20MHZ) } # [doc = "External clock"]
# [inline (always)]
pub fn extclk (self) -> & 'a mut W { self . variant (CLKSEL_A :: EXTCLK) } # [doc = "System clock"]
# [inline (always)]
pub fn sysclk (self) -> & 'a mut W { self . variant (CLKSEL_A :: SYSCLK) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Syncronization prescaler"]
# [inline (always)]
pub fn syncpres (& self) -> SYNCPRES_R { SYNCPRES_R :: new ((self . bits >> 1) & 3) } # [doc = "Bits 3:4 - counter prescaler"]
# [inline (always)]
pub fn cntpres (& self) -> CNTPRES_R { CNTPRES_R :: new ((self . bits >> 3) & 3) } # [doc = "Bits 5:6 - clock select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 5) & 3) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Syncronization prescaler"]
# [inline (always)]
# [must_use]
pub fn syncpres (& mut self) -> SYNCPRES_W < 1 > { SYNCPRES_W :: new (self) } # [doc = "Bits 3:4 - counter prescaler"]
# [inline (always)]
# [must_use]
pub fn cntpres (& mut self) -> CNTPRES_W < 3 > { CNTPRES_W :: new (self) } # [doc = "Bits 5:6 - clock select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 5 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: One ramp mode"]
ONERAMP = 0 , # [doc = "1: Two ramp mode"]
TWORAMP = 1 , # [doc = "2: Four ramp mode"]
FOURRAMP = 2 , # [doc = "3: Dual slope mode"]
DS = 3 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WGMODE_A { match self . bits { 0 => WGMODE_A :: ONERAMP , 1 => WGMODE_A :: TWORAMP , 2 => WGMODE_A :: FOURRAMP , 3 => WGMODE_A :: DS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ONERAMP`"]
# [inline (always)]
pub fn is_oneramp (& self) -> bool { * self == WGMODE_A :: ONERAMP } # [doc = "Checks if the value of the field is `TWORAMP`"]
# [inline (always)]
pub fn is_tworamp (& self) -> bool { * self == WGMODE_A :: TWORAMP } # [doc = "Checks if the value of the field is `FOURRAMP`"]
# [inline (always)]
pub fn is_fourramp (& self) -> bool { * self == WGMODE_A :: FOURRAMP } # [doc = "Checks if the value of the field is `DS`"]
# [inline (always)]
pub fn is_ds (& self) -> bool { * self == WGMODE_A :: DS } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 2 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "One ramp mode"]
# [inline (always)]
pub fn oneramp (self) -> & 'a mut W { self . variant (WGMODE_A :: ONERAMP) } # [doc = "Two ramp mode"]
# [inline (always)]
pub fn tworamp (self) -> & 'a mut W { self . variant (WGMODE_A :: TWORAMP) } # [doc = "Four ramp mode"]
# [inline (always)]
pub fn fourramp (self) -> & 'a mut W { self . variant (WGMODE_A :: FOURRAMP) } # [doc = "Dual slope mode"]
# [inline (always)]
pub fn ds (self) -> & 'a mut W { self . variant (WGMODE_A :: DS) } } impl R { # [doc = "Bits 0:1 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPOVR` reader - Compare output value override"]
pub type CMPOVR_R = crate :: BitReader < bool > ; # [doc = "Field `CMPOVR` writer - Compare output value override"]
pub type CMPOVR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `AUPDATE` reader - Auto update"]
pub type AUPDATE_R = crate :: BitReader < bool > ; # [doc = "Field `AUPDATE` writer - Auto update"]
pub type AUPDATE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `FIFTY` reader - Fifty percent waveform"]
pub type FIFTY_R = crate :: BitReader < bool > ; # [doc = "Field `FIFTY` writer - Fifty percent waveform"]
pub type FIFTY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPCSEL` reader - Compare C output select"]
pub type CMPCSEL_R = crate :: BitReader < CMPCSEL_A > ; # [doc = "Compare C output select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CMPCSEL_A { # [doc = "0: PWM A output"]
PWMA = 0 , # [doc = "1: PWM B output"]
PWMB = 1 , } impl From < CMPCSEL_A > for bool { # [inline (always)]
fn from (variant : CMPCSEL_A) -> Self { variant as u8 != 0 } } impl CMPCSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMPCSEL_A { match self . bits { false => CMPCSEL_A :: PWMA , true => CMPCSEL_A :: PWMB , } } # [doc = "Checks if the value of the field is `PWMA`"]
# [inline (always)]
pub fn is_pwma (& self) -> bool { * self == CMPCSEL_A :: PWMA } # [doc = "Checks if the value of the field is `PWMB`"]
# [inline (always)]
pub fn is_pwmb (& self) -> bool { * self == CMPCSEL_A :: PWMB } } # [doc = "Field `CMPCSEL` writer - Compare C output select"]
pub type CMPCSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , CMPCSEL_A , O > ; impl < 'a , const O : u8 > CMPCSEL_W < 'a , O > { # [doc = "PWM A output"]
# [inline (always)]
pub fn pwma (self) -> & 'a mut W { self . variant (CMPCSEL_A :: PWMA) } # [doc = "PWM B output"]
# [inline (always)]
pub fn pwmb (self) -> & 'a mut W { self . variant (CMPCSEL_A :: PWMB) } } # [doc = "Field `CMPDSEL` reader - Compare D output select"]
pub type CMPDSEL_R = crate :: BitReader < CMPDSEL_A > ; # [doc = "Compare D output select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CMPDSEL_A { # [doc = "0: PWM A output"]
PWMA = 0 , # [doc = "1: PWM B output"]
PWMB = 1 , } impl From < CMPDSEL_A > for bool { # [inline (always)]
fn from (variant : CMPDSEL_A) -> Self { variant as u8 != 0 } } impl CMPDSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMPDSEL_A { match self . bits { false => CMPDSEL_A :: PWMA , true => CMPDSEL_A :: PWMB , } } # [doc = "Checks if the value of the field is `PWMA`"]
# [inline (always)]
pub fn is_pwma (& self) -> bool { * self == CMPDSEL_A :: PWMA } # [doc = "Checks if the value of the field is `PWMB`"]
# [inline (always)]
pub fn is_pwmb (& self) -> bool { * self == CMPDSEL_A :: PWMB } } # [doc = "Field `CMPDSEL` writer - Compare D output select"]
pub type CMPDSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , CMPDSEL_A , O > ; impl < 'a , const O : u8 > CMPDSEL_W < 'a , O > { # [doc = "PWM A output"]
# [inline (always)]
pub fn pwma (self) -> & 'a mut W { self . variant (CMPDSEL_A :: PWMA) } # [doc = "PWM B output"]
# [inline (always)]
pub fn pwmb (self) -> & 'a mut W { self . variant (CMPDSEL_A :: PWMB) } } impl R { # [doc = "Bit 0 - Compare output value override"]
# [inline (always)]
pub fn cmpovr (& self) -> CMPOVR_R { CMPOVR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Auto update"]
# [inline (always)]
pub fn aupdate (& self) -> AUPDATE_R { AUPDATE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Fifty percent waveform"]
# [inline (always)]
pub fn fifty (& self) -> FIFTY_R { FIFTY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 6 - Compare C output select"]
# [inline (always)]
pub fn cmpcsel (& self) -> CMPCSEL_R { CMPCSEL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare D output select"]
# [inline (always)]
pub fn cmpdsel (& self) -> CMPDSEL_R { CMPDSEL_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare output value override"]
# [inline (always)]
# [must_use]
pub fn cmpovr (& mut self) -> CMPOVR_W < 0 > { CMPOVR_W :: new (self) } # [doc = "Bit 1 - Auto update"]
# [inline (always)]
# [must_use]
pub fn aupdate (& mut self) -> AUPDATE_W < 1 > { AUPDATE_W :: new (self) } # [doc = "Bit 3 - Fifty percent waveform"]
# [inline (always)]
# [must_use]
pub fn fifty (& mut self) -> FIFTY_W < 3 > { FIFTY_W :: new (self) } # [doc = "Bit 6 - Compare C output select"]
# [inline (always)]
# [must_use]
pub fn cmpcsel (& mut self) -> CMPCSEL_W < 6 > { CMPCSEL_W :: new (self) } # [doc = "Bit 7 - Compare D output select"]
# [inline (always)]
# [must_use]
pub fn cmpdsel (& mut self) -> CMPDSEL_W < 7 > { CMPDSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPAVAL` reader - Compare A value"]
pub type CMPAVAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMPAVAL` writer - Compare A value"]
pub type CMPAVAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLD_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `CMPBVAL` reader - Compare B value"]
pub type CMPBVAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMPBVAL` writer - Compare B value"]
pub type CMPBVAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLD_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Compare A value"]
# [inline (always)]
pub fn cmpaval (& self) -> CMPAVAL_R { CMPAVAL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Compare B value"]
# [inline (always)]
pub fn cmpbval (& self) -> CMPBVAL_R { CMPBVAL_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Compare A value"]
# [inline (always)]
# [must_use]
pub fn cmpaval (& mut self) -> CMPAVAL_W < 0 > { CMPAVAL_W :: new (self) } # [doc = "Bits 4:7 - Compare B value"]
# [inline (always)]
# [must_use]
pub fn cmpbval (& mut self) -> CMPBVAL_W < 4 > { CMPBVAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCEOC` reader - synchronize end of cycle strobe"]
pub type SYNCEOC_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCEOC` writer - synchronize end of cycle strobe"]
pub type SYNCEOC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; # [doc = "Field `SYNC` reader - synchronize strobe"]
pub type SYNC_R = crate :: BitReader < bool > ; # [doc = "Field `SYNC` writer - synchronize strobe"]
pub type SYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; # [doc = "Field `RESTART` reader - Restart strobe"]
pub type RESTART_R = crate :: BitReader < bool > ; # [doc = "Field `RESTART` writer - Restart strobe"]
pub type RESTART_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; # [doc = "Field `SCAPTUREA` reader - Software Capture A Strobe"]
pub type SCAPTUREA_R = crate :: BitReader < bool > ; # [doc = "Field `SCAPTUREA` writer - Software Capture A Strobe"]
pub type SCAPTUREA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; # [doc = "Field `SCAPTUREB` reader - Software Capture B Strobe"]
pub type SCAPTUREB_R = crate :: BitReader < bool > ; # [doc = "Field `SCAPTUREB` writer - Software Capture B Strobe"]
pub type SCAPTUREB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; # [doc = "Field `DISEOC` reader - Disable at end of cycle"]
pub type DISEOC_R = crate :: BitReader < bool > ; # [doc = "Field `DISEOC` writer - Disable at end of cycle"]
pub type DISEOC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - synchronize end of cycle strobe"]
# [inline (always)]
pub fn synceoc (& self) -> SYNCEOC_R { SYNCEOC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - synchronize strobe"]
# [inline (always)]
pub fn sync (& self) -> SYNC_R { SYNC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Restart strobe"]
# [inline (always)]
pub fn restart (& self) -> RESTART_R { RESTART_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Software Capture A Strobe"]
# [inline (always)]
pub fn scapturea (& self) -> SCAPTUREA_R { SCAPTUREA_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Software Capture B Strobe"]
# [inline (always)]
pub fn scaptureb (& self) -> SCAPTUREB_R { SCAPTUREB_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 7 - Disable at end of cycle"]
# [inline (always)]
pub fn diseoc (& self) -> DISEOC_R { DISEOC_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - synchronize end of cycle strobe"]
# [inline (always)]
# [must_use]
pub fn synceoc (& mut self) -> SYNCEOC_W < 0 > { SYNCEOC_W :: new (self) } # [doc = "Bit 1 - synchronize strobe"]
# [inline (always)]
# [must_use]
pub fn sync (& mut self) -> SYNC_W < 1 > { SYNC_W :: new (self) } # [doc = "Bit 2 - Restart strobe"]
# [inline (always)]
# [must_use]
pub fn restart (& mut self) -> RESTART_W < 2 > { RESTART_W :: new (self) } # [doc = "Bit 3 - Software Capture A Strobe"]
# [inline (always)]
# [must_use]
pub fn scapturea (& mut self) -> SCAPTUREA_W < 3 > { SCAPTUREA_W :: new (self) } # [doc = "Bit 4 - Software Capture B Strobe"]
# [inline (always)]
# [must_use]
pub fn scaptureb (& mut self) -> SCAPTUREB_W < 4 > { SCAPTUREB_W :: new (self) } # [doc = "Bit 7 - Disable at end of cycle"]
# [inline (always)]
# [must_use]
pub fn diseoc (& mut self) -> DISEOC_W < 7 > { DISEOC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; # [doc = "Field `FAULTDET` reader - Fault detection"]
pub type FAULTDET_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTDET` writer - Fault detection"]
pub type FAULTDET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Fault detection"]
# [inline (always)]
pub fn faultdet (& self) -> FAULTDET_R { FAULTDET_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Bit 2 - Fault detection"]
# [inline (always)]
# [must_use]
pub fn faultdet (& mut self) -> FAULTDET_W < 2 > { FAULTDET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DITCTRL (rw) register accessor: an alias for `Reg<DITCTRL_SPEC>`"]
pub type DITCTRL = crate :: Reg < ditctrl :: DITCTRL_SPEC > ; # [doc = "Dither Control A"]
pub mod ditctrl { # [doc = "Register `DITCTRL` reader"]
pub struct R (crate :: R < DITCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DITCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DITCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DITCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DITCTRL` writer"]
pub struct W (crate :: W < DITCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DITCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DITCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DITCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERSEL` reader - dither select"]
pub type DITHERSEL_R = crate :: FieldReader < u8 , DITHERSEL_A > ; # [doc = "dither select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DITHERSEL_A { # [doc = "0: On-time ramp B"]
ONTIMEB = 0 , # [doc = "1: On-time ramp A and B"]
ONTIMEAB = 1 , # [doc = "2: Dead-time rampB"]
DEADTIMEB = 2 , # [doc = "3: Dead-time ramp A and B"]
DEADTIMEAB = 3 , } impl From < DITHERSEL_A > for u8 { # [inline (always)]
fn from (variant : DITHERSEL_A) -> Self { variant as _ } } impl DITHERSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DITHERSEL_A { match self . bits { 0 => DITHERSEL_A :: ONTIMEB , 1 => DITHERSEL_A :: ONTIMEAB , 2 => DITHERSEL_A :: DEADTIMEB , 3 => DITHERSEL_A :: DEADTIMEAB , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ONTIMEB`"]
# [inline (always)]
pub fn is_ontimeb (& self) -> bool { * self == DITHERSEL_A :: ONTIMEB } # [doc = "Checks if the value of the field is `ONTIMEAB`"]
# [inline (always)]
pub fn is_ontimeab (& self) -> bool { * self == DITHERSEL_A :: ONTIMEAB } # [doc = "Checks if the value of the field is `DEADTIMEB`"]
# [inline (always)]
pub fn is_deadtimeb (& self) -> bool { * self == DITHERSEL_A :: DEADTIMEB } # [doc = "Checks if the value of the field is `DEADTIMEAB`"]
# [inline (always)]
pub fn is_deadtimeab (& self) -> bool { * self == DITHERSEL_A :: DEADTIMEAB } } # [doc = "Field `DITHERSEL` writer - dither select"]
pub type DITHERSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DITCTRL_SPEC , u8 , DITHERSEL_A , 2 , O > ; impl < 'a , const O : u8 > DITHERSEL_W < 'a , O > { # [doc = "On-time ramp B"]
# [inline (always)]
pub fn ontimeb (self) -> & 'a mut W { self . variant (DITHERSEL_A :: ONTIMEB) } # [doc = "On-time ramp A and B"]
# [inline (always)]
pub fn ontimeab (self) -> & 'a mut W { self . variant (DITHERSEL_A :: ONTIMEAB) } # [doc = "Dead-time rampB"]
# [inline (always)]
pub fn deadtimeb (self) -> & 'a mut W { self . variant (DITHERSEL_A :: DEADTIMEB) } # [doc = "Dead-time ramp A and B"]
# [inline (always)]
pub fn deadtimeab (self) -> & 'a mut W { self . variant (DITHERSEL_A :: DEADTIMEAB) } } impl R { # [doc = "Bits 0:1 - dither select"]
# [inline (always)]
pub fn dithersel (& self) -> DITHERSEL_R { DITHERSEL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - dither select"]
# [inline (always)]
# [must_use]
pub fn dithersel (& mut self) -> DITHERSEL_W < 0 > { DITHERSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Dither Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ditctrl](index.html) module"]
pub struct DITCTRL_SPEC ; impl crate :: RegisterSpec for DITCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ditctrl::R](R) reader structure"]
impl crate :: Readable for DITCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ditctrl::W](W) writer structure"]
impl crate :: Writable for DITCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DITCTRL to value 0"]
impl crate :: Resettable for DITCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DITVAL (rw) register accessor: an alias for `Reg<DITVAL_SPEC>`"]
pub type DITVAL = crate :: Reg < ditval :: DITVAL_SPEC > ; # [doc = "Dither value"]
pub mod ditval { # [doc = "Register `DITVAL` reader"]
pub struct R (crate :: R < DITVAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DITVAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DITVAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DITVAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DITVAL` writer"]
pub struct W (crate :: W < DITVAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DITVAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DITVAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DITVAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHER` reader - Dither value"]
pub type DITHER_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHER` writer - Dither value"]
pub type DITHER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DITVAL_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Dither value"]
# [inline (always)]
pub fn dither (& self) -> DITHER_R { DITHER_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Dither value"]
# [inline (always)]
# [must_use]
pub fn dither (& mut self) -> DITHER_W < 0 > { DITHER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Dither value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ditval](index.html) module"]
pub struct DITVAL_SPEC ; impl crate :: RegisterSpec for DITVAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ditval::R](R) reader structure"]
impl crate :: Readable for DITVAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ditval::W](W) writer structure"]
impl crate :: Writable for DITVAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DITVAL to value 0"]
impl crate :: Resettable for DITVAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DLYCTRL (rw) register accessor: an alias for `Reg<DLYCTRL_SPEC>`"]
pub type DLYCTRL = crate :: Reg < dlyctrl :: DLYCTRL_SPEC > ; # [doc = "Delay Control"]
pub mod dlyctrl { # [doc = "Register `DLYCTRL` reader"]
pub struct R (crate :: R < DLYCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DLYCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DLYCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DLYCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DLYCTRL` writer"]
pub struct W (crate :: W < DLYCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DLYCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DLYCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DLYCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DLYSEL` reader - Delay select"]
pub type DLYSEL_R = crate :: FieldReader < u8 , DLYSEL_A > ; # [doc = "Delay select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DLYSEL_A { # [doc = "0: No delay"]
OFF = 0 , # [doc = "1: Input blanking enabled"]
INBLANK = 1 , # [doc = "2: Event delay enabled"]
EVENT = 2 , } impl From < DLYSEL_A > for u8 { # [inline (always)]
fn from (variant : DLYSEL_A) -> Self { variant as _ } } impl DLYSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < DLYSEL_A > { match self . bits { 0 => Some (DLYSEL_A :: OFF) , 1 => Some (DLYSEL_A :: INBLANK) , 2 => Some (DLYSEL_A :: EVENT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DLYSEL_A :: OFF } # [doc = "Checks if the value of the field is `INBLANK`"]
# [inline (always)]
pub fn is_inblank (& self) -> bool { * self == DLYSEL_A :: INBLANK } # [doc = "Checks if the value of the field is `EVENT`"]
# [inline (always)]
pub fn is_event (& self) -> bool { * self == DLYSEL_A :: EVENT } } # [doc = "Field `DLYSEL` writer - Delay select"]
pub type DLYSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , DLYCTRL_SPEC , u8 , DLYSEL_A , 2 , O > ; impl < 'a , const O : u8 > DLYSEL_W < 'a , O > { # [doc = "No delay"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DLYSEL_A :: OFF) } # [doc = "Input blanking enabled"]
# [inline (always)]
pub fn inblank (self) -> & 'a mut W { self . variant (DLYSEL_A :: INBLANK) } # [doc = "Event delay enabled"]
# [inline (always)]
pub fn event (self) -> & 'a mut W { self . variant (DLYSEL_A :: EVENT) } } # [doc = "Field `DLYTRIG` reader - Delay trigger"]
pub type DLYTRIG_R = crate :: FieldReader < u8 , DLYTRIG_A > ; # [doc = "Delay trigger\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DLYTRIG_A { # [doc = "0: Compare A set"]
CMPASET = 0 , # [doc = "1: Compare A clear"]
CMPACLR = 1 , # [doc = "2: Compare B set"]
CMPBSET = 2 , # [doc = "3: Compare B clear"]
CMPBCLR = 3 , } impl From < DLYTRIG_A > for u8 { # [inline (always)]
fn from (variant : DLYTRIG_A) -> Self { variant as _ } } impl DLYTRIG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DLYTRIG_A { match self . bits { 0 => DLYTRIG_A :: CMPASET , 1 => DLYTRIG_A :: CMPACLR , 2 => DLYTRIG_A :: CMPBSET , 3 => DLYTRIG_A :: CMPBCLR , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CMPASET`"]
# [inline (always)]
pub fn is_cmpaset (& self) -> bool { * self == DLYTRIG_A :: CMPASET } # [doc = "Checks if the value of the field is `CMPACLR`"]
# [inline (always)]
pub fn is_cmpaclr (& self) -> bool { * self == DLYTRIG_A :: CMPACLR } # [doc = "Checks if the value of the field is `CMPBSET`"]
# [inline (always)]
pub fn is_cmpbset (& self) -> bool { * self == DLYTRIG_A :: CMPBSET } # [doc = "Checks if the value of the field is `CMPBCLR`"]
# [inline (always)]
pub fn is_cmpbclr (& self) -> bool { * self == DLYTRIG_A :: CMPBCLR } } # [doc = "Field `DLYTRIG` writer - Delay trigger"]
pub type DLYTRIG_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DLYCTRL_SPEC , u8 , DLYTRIG_A , 2 , O > ; impl < 'a , const O : u8 > DLYTRIG_W < 'a , O > { # [doc = "Compare A set"]
# [inline (always)]
pub fn cmpaset (self) -> & 'a mut W { self . variant (DLYTRIG_A :: CMPASET) } # [doc = "Compare A clear"]
# [inline (always)]
pub fn cmpaclr (self) -> & 'a mut W { self . variant (DLYTRIG_A :: CMPACLR) } # [doc = "Compare B set"]
# [inline (always)]
pub fn cmpbset (self) -> & 'a mut W { self . variant (DLYTRIG_A :: CMPBSET) } # [doc = "Compare B clear"]
# [inline (always)]
pub fn cmpbclr (self) -> & 'a mut W { self . variant (DLYTRIG_A :: CMPBCLR) } } # [doc = "Field `DLYPRESC` reader - Delay prescaler"]
pub type DLYPRESC_R = crate :: FieldReader < u8 , DLYPRESC_A > ; # [doc = "Delay prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DLYPRESC_A { # [doc = "0: No prescaling"]
DIV1 = 0 , # [doc = "1: Prescale with 2"]
DIV2 = 1 , # [doc = "2: Prescale with 4"]
DIV4 = 2 , # [doc = "3: Prescale with 8"]
DIV8 = 3 , } impl From < DLYPRESC_A > for u8 { # [inline (always)]
fn from (variant : DLYPRESC_A) -> Self { variant as _ } } impl DLYPRESC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DLYPRESC_A { match self . bits { 0 => DLYPRESC_A :: DIV1 , 1 => DLYPRESC_A :: DIV2 , 2 => DLYPRESC_A :: DIV4 , 3 => DLYPRESC_A :: DIV8 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == DLYPRESC_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == DLYPRESC_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == DLYPRESC_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == DLYPRESC_A :: DIV8 } } # [doc = "Field `DLYPRESC` writer - Delay prescaler"]
pub type DLYPRESC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DLYCTRL_SPEC , u8 , DLYPRESC_A , 2 , O > ; impl < 'a , const O : u8 > DLYPRESC_W < 'a , O > { # [doc = "No prescaling"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (DLYPRESC_A :: DIV1) } # [doc = "Prescale with 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (DLYPRESC_A :: DIV2) } # [doc = "Prescale with 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (DLYPRESC_A :: DIV4) } # [doc = "Prescale with 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (DLYPRESC_A :: DIV8) } } impl R { # [doc = "Bits 0:1 - Delay select"]
# [inline (always)]
pub fn dlysel (& self) -> DLYSEL_R { DLYSEL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Delay trigger"]
# [inline (always)]
pub fn dlytrig (& self) -> DLYTRIG_R { DLYTRIG_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Delay prescaler"]
# [inline (always)]
pub fn dlypresc (& self) -> DLYPRESC_R { DLYPRESC_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Delay select"]
# [inline (always)]
# [must_use]
pub fn dlysel (& mut self) -> DLYSEL_W < 0 > { DLYSEL_W :: new (self) } # [doc = "Bits 2:3 - Delay trigger"]
# [inline (always)]
# [must_use]
pub fn dlytrig (& mut self) -> DLYTRIG_W < 2 > { DLYTRIG_W :: new (self) } # [doc = "Bits 4:5 - Delay prescaler"]
# [inline (always)]
# [must_use]
pub fn dlypresc (& mut self) -> DLYPRESC_W < 4 > { DLYPRESC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Delay Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dlyctrl](index.html) module"]
pub struct DLYCTRL_SPEC ; impl crate :: RegisterSpec for DLYCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dlyctrl::R](R) reader structure"]
impl crate :: Readable for DLYCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dlyctrl::W](W) writer structure"]
impl crate :: Writable for DLYCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DLYCTRL to value 0"]
impl crate :: Resettable for DLYCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DLYVAL (rw) register accessor: an alias for `Reg<DLYVAL_SPEC>`"]
pub type DLYVAL = crate :: Reg < dlyval :: DLYVAL_SPEC > ; # [doc = "Delay value"]
pub mod dlyval { # [doc = "Register `DLYVAL` reader"]
pub struct R (crate :: R < DLYVAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DLYVAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DLYVAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DLYVAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DLYVAL` writer"]
pub struct W (crate :: W < DLYVAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DLYVAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DLYVAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DLYVAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DLYVAL` reader - Delay value"]
pub type DLYVAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DLYVAL` writer - Delay value"]
pub type DLYVAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DLYVAL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Delay value"]
# [inline (always)]
pub fn dlyval (& self) -> DLYVAL_R { DLYVAL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Delay value"]
# [inline (always)]
# [must_use]
pub fn dlyval (& mut self) -> DLYVAL_W < 0 > { DLYVAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Delay value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dlyval](index.html) module"]
pub struct DLYVAL_SPEC ; impl crate :: RegisterSpec for DLYVAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dlyval::R](R) reader structure"]
impl crate :: Readable for DLYVAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dlyval::W](W) writer structure"]
impl crate :: Writable for DLYVAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DLYVAL to value 0"]
impl crate :: Resettable for DLYVAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRLA (rw) register accessor: an alias for `Reg<EVCTRLA_SPEC>`"]
pub type EVCTRLA = crate :: Reg < evctrla :: EVCTRLA_SPEC > ; # [doc = "EVCTRLA"]
pub mod evctrla { # [doc = "Register `EVCTRLA` reader"]
pub struct R (crate :: R < EVCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRLA` writer"]
pub struct W (crate :: W < EVCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRIGEI` reader - Trigger event enable"]
pub type TRIGEI_R = crate :: BitReader < bool > ; # [doc = "Field `TRIGEI` writer - Trigger event enable"]
pub type TRIGEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRLA_SPEC , bool , O > ; # [doc = "Field `ACTION` reader - event action"]
pub type ACTION_R = crate :: BitReader < ACTION_A > ; # [doc = "event action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ACTION_A { # [doc = "0: Event trigger a fault"]
FAULT = 0 , # [doc = "1: Event trigger a fault and capture"]
CAPTURE = 1 , } impl From < ACTION_A > for bool { # [inline (always)]
fn from (variant : ACTION_A) -> Self { variant as u8 != 0 } } impl ACTION_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACTION_A { match self . bits { false => ACTION_A :: FAULT , true => ACTION_A :: CAPTURE , } } # [doc = "Checks if the value of the field is `FAULT`"]
# [inline (always)]
pub fn is_fault (& self) -> bool { * self == ACTION_A :: FAULT } # [doc = "Checks if the value of the field is `CAPTURE`"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == ACTION_A :: CAPTURE } } # [doc = "Field `ACTION` writer - event action"]
pub type ACTION_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRLA_SPEC , ACTION_A , O > ; impl < 'a , const O : u8 > ACTION_W < 'a , O > { # [doc = "Event trigger a fault"]
# [inline (always)]
pub fn fault (self) -> & 'a mut W { self . variant (ACTION_A :: FAULT) } # [doc = "Event trigger a fault and capture"]
# [inline (always)]
pub fn capture (self) -> & 'a mut W { self . variant (ACTION_A :: CAPTURE) } } # [doc = "Field `EDGE` reader - edge select"]
pub type EDGE_R = crate :: BitReader < EDGE_A > ; # [doc = "edge select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EDGE_A { # [doc = "0: The falling edge or low level of event generates retrigger or fault action"]
FALL_LOW = 0 , # [doc = "1: The rising edge or high level of event generates retrigger or fault action"]
RISE_HIGH = 1 , } impl From < EDGE_A > for bool { # [inline (always)]
fn from (variant : EDGE_A) -> Self { variant as u8 != 0 } } impl EDGE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGE_A { match self . bits { false => EDGE_A :: FALL_LOW , true => EDGE_A :: RISE_HIGH , } } # [doc = "Checks if the value of the field is `FALL_LOW`"]
# [inline (always)]
pub fn is_fall_low (& self) -> bool { * self == EDGE_A :: FALL_LOW } # [doc = "Checks if the value of the field is `RISE_HIGH`"]
# [inline (always)]
pub fn is_rise_high (& self) -> bool { * self == EDGE_A :: RISE_HIGH } } # [doc = "Field `EDGE` writer - edge select"]
pub type EDGE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRLA_SPEC , EDGE_A , O > ; impl < 'a , const O : u8 > EDGE_W < 'a , O > { # [doc = "The falling edge or low level of event generates retrigger or fault action"]
# [inline (always)]
pub fn fall_low (self) -> & 'a mut W { self . variant (EDGE_A :: FALL_LOW) } # [doc = "The rising edge or high level of event generates retrigger or fault action"]
# [inline (always)]
pub fn rise_high (self) -> & 'a mut W { self . variant (EDGE_A :: RISE_HIGH) } } # [doc = "Field `CFG` reader - event config"]
pub type CFG_R = crate :: FieldReader < u8 , CFG_A > ; # [doc = "event config\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CFG_A { # [doc = "0: Neither Filter nor Asynchronous Event is enabled"]
NEITHER = 0 , # [doc = "1: Input Capture Noise Cancellation Filter enabled"]
FILTER = 1 , # [doc = "2: Asynchronous Event output qualification enabled"]
ASYNC = 2 , } impl From < CFG_A > for u8 { # [inline (always)]
fn from (variant : CFG_A) -> Self { variant as _ } } impl CFG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CFG_A > { match self . bits { 0 => Some (CFG_A :: NEITHER) , 1 => Some (CFG_A :: FILTER) , 2 => Some (CFG_A :: ASYNC) , _ => None , } } # [doc = "Checks if the value of the field is `NEITHER`"]
# [inline (always)]
pub fn is_neither (& self) -> bool { * self == CFG_A :: NEITHER } # [doc = "Checks if the value of the field is `FILTER`"]
# [inline (always)]
pub fn is_filter (& self) -> bool { * self == CFG_A :: FILTER } # [doc = "Checks if the value of the field is `ASYNC`"]
# [inline (always)]
pub fn is_async (& self) -> bool { * self == CFG_A :: ASYNC } } # [doc = "Field `CFG` writer - event config"]
pub type CFG_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , EVCTRLA_SPEC , u8 , CFG_A , 2 , O > ; impl < 'a , const O : u8 > CFG_W < 'a , O > { # [doc = "Neither Filter nor Asynchronous Event is enabled"]
# [inline (always)]
pub fn neither (self) -> & 'a mut W { self . variant (CFG_A :: NEITHER) } # [doc = "Input Capture Noise Cancellation Filter enabled"]
# [inline (always)]
pub fn filter (self) -> & 'a mut W { self . variant (CFG_A :: FILTER) } # [doc = "Asynchronous Event output qualification enabled"]
# [inline (always)]
pub fn async_ (self) -> & 'a mut W { self . variant (CFG_A :: ASYNC) } } impl R { # [doc = "Bit 0 - Trigger event enable"]
# [inline (always)]
pub fn trigei (& self) -> TRIGEI_R { TRIGEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - event action"]
# [inline (always)]
pub fn action (& self) -> ACTION_R { ACTION_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - edge select"]
# [inline (always)]
pub fn edge (& self) -> EDGE_R { EDGE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 6:7 - event config"]
# [inline (always)]
pub fn cfg (& self) -> CFG_R { CFG_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Trigger event enable"]
# [inline (always)]
# [must_use]
pub fn trigei (& mut self) -> TRIGEI_W < 0 > { TRIGEI_W :: new (self) } # [doc = "Bit 2 - event action"]
# [inline (always)]
# [must_use]
pub fn action (& mut self) -> ACTION_W < 2 > { ACTION_W :: new (self) } # [doc = "Bit 4 - edge select"]
# [inline (always)]
# [must_use]
pub fn edge (& mut self) -> EDGE_W < 4 > { EDGE_W :: new (self) } # [doc = "Bits 6:7 - event config"]
# [inline (always)]
# [must_use]
pub fn cfg (& mut self) -> CFG_W < 6 > { CFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "EVCTRLA\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrla](index.html) module"]
pub struct EVCTRLA_SPEC ; impl crate :: RegisterSpec for EVCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrla::R](R) reader structure"]
impl crate :: Readable for EVCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrla::W](W) writer structure"]
impl crate :: Writable for EVCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRLA to value 0"]
impl crate :: Resettable for EVCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRLB (rw) register accessor: an alias for `Reg<EVCTRLB_SPEC>`"]
pub type EVCTRLB = crate :: Reg < evctrlb :: EVCTRLB_SPEC > ; # [doc = "EVCTRLB"]
pub mod evctrlb { # [doc = "Register `EVCTRLB` reader"]
pub struct R (crate :: R < EVCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRLB` writer"]
pub struct W (crate :: W < EVCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRIGEI` reader - Trigger event enable"]
pub type TRIGEI_R = crate :: BitReader < bool > ; # [doc = "Field `TRIGEI` writer - Trigger event enable"]
pub type TRIGEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRLB_SPEC , bool , O > ; # [doc = "Field `ACTION` reader - event action"]
pub type ACTION_R = crate :: BitReader < ACTION_A > ; # [doc = "event action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ACTION_A { # [doc = "0: Event trigger a fault"]
FAULT = 0 , # [doc = "1: Event trigger a fault and capture"]
CAPTURE = 1 , } impl From < ACTION_A > for bool { # [inline (always)]
fn from (variant : ACTION_A) -> Self { variant as u8 != 0 } } impl ACTION_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACTION_A { match self . bits { false => ACTION_A :: FAULT , true => ACTION_A :: CAPTURE , } } # [doc = "Checks if the value of the field is `FAULT`"]
# [inline (always)]
pub fn is_fault (& self) -> bool { * self == ACTION_A :: FAULT } # [doc = "Checks if the value of the field is `CAPTURE`"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == ACTION_A :: CAPTURE } } # [doc = "Field `ACTION` writer - event action"]
pub type ACTION_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRLB_SPEC , ACTION_A , O > ; impl < 'a , const O : u8 > ACTION_W < 'a , O > { # [doc = "Event trigger a fault"]
# [inline (always)]
pub fn fault (self) -> & 'a mut W { self . variant (ACTION_A :: FAULT) } # [doc = "Event trigger a fault and capture"]
# [inline (always)]
pub fn capture (self) -> & 'a mut W { self . variant (ACTION_A :: CAPTURE) } } # [doc = "Field `EDGE` reader - edge select"]
pub type EDGE_R = crate :: BitReader < EDGE_A > ; # [doc = "edge select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EDGE_A { # [doc = "0: The falling edge or low level of event generates retrigger or fault action"]
FALL_LOW = 0 , # [doc = "1: The rising edge or high level of event generates retrigger or fault action"]
RISE_HIGH = 1 , } impl From < EDGE_A > for bool { # [inline (always)]
fn from (variant : EDGE_A) -> Self { variant as u8 != 0 } } impl EDGE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGE_A { match self . bits { false => EDGE_A :: FALL_LOW , true => EDGE_A :: RISE_HIGH , } } # [doc = "Checks if the value of the field is `FALL_LOW`"]
# [inline (always)]
pub fn is_fall_low (& self) -> bool { * self == EDGE_A :: FALL_LOW } # [doc = "Checks if the value of the field is `RISE_HIGH`"]
# [inline (always)]
pub fn is_rise_high (& self) -> bool { * self == EDGE_A :: RISE_HIGH } } # [doc = "Field `EDGE` writer - edge select"]
pub type EDGE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRLB_SPEC , EDGE_A , O > ; impl < 'a , const O : u8 > EDGE_W < 'a , O > { # [doc = "The falling edge or low level of event generates retrigger or fault action"]
# [inline (always)]
pub fn fall_low (self) -> & 'a mut W { self . variant (EDGE_A :: FALL_LOW) } # [doc = "The rising edge or high level of event generates retrigger or fault action"]
# [inline (always)]
pub fn rise_high (self) -> & 'a mut W { self . variant (EDGE_A :: RISE_HIGH) } } # [doc = "Field `CFG` reader - event config"]
pub type CFG_R = crate :: FieldReader < u8 , CFG_A > ; # [doc = "event config\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CFG_A { # [doc = "0: Neither Filter nor Asynchronous Event is enabled"]
NEITHER = 0 , # [doc = "1: Input Capture Noise Cancellation Filter enabled"]
FILTER = 1 , # [doc = "2: Asynchronous Event output qualification enabled"]
ASYNC = 2 , } impl From < CFG_A > for u8 { # [inline (always)]
fn from (variant : CFG_A) -> Self { variant as _ } } impl CFG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CFG_A > { match self . bits { 0 => Some (CFG_A :: NEITHER) , 1 => Some (CFG_A :: FILTER) , 2 => Some (CFG_A :: ASYNC) , _ => None , } } # [doc = "Checks if the value of the field is `NEITHER`"]
# [inline (always)]
pub fn is_neither (& self) -> bool { * self == CFG_A :: NEITHER } # [doc = "Checks if the value of the field is `FILTER`"]
# [inline (always)]
pub fn is_filter (& self) -> bool { * self == CFG_A :: FILTER } # [doc = "Checks if the value of the field is `ASYNC`"]
# [inline (always)]
pub fn is_async (& self) -> bool { * self == CFG_A :: ASYNC } } # [doc = "Field `CFG` writer - event config"]
pub type CFG_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , EVCTRLB_SPEC , u8 , CFG_A , 2 , O > ; impl < 'a , const O : u8 > CFG_W < 'a , O > { # [doc = "Neither Filter nor Asynchronous Event is enabled"]
# [inline (always)]
pub fn neither (self) -> & 'a mut W { self . variant (CFG_A :: NEITHER) } # [doc = "Input Capture Noise Cancellation Filter enabled"]
# [inline (always)]
pub fn filter (self) -> & 'a mut W { self . variant (CFG_A :: FILTER) } # [doc = "Asynchronous Event output qualification enabled"]
# [inline (always)]
pub fn async_ (self) -> & 'a mut W { self . variant (CFG_A :: ASYNC) } } impl R { # [doc = "Bit 0 - Trigger event enable"]
# [inline (always)]
pub fn trigei (& self) -> TRIGEI_R { TRIGEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - event action"]
# [inline (always)]
pub fn action (& self) -> ACTION_R { ACTION_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - edge select"]
# [inline (always)]
pub fn edge (& self) -> EDGE_R { EDGE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 6:7 - event config"]
# [inline (always)]
pub fn cfg (& self) -> CFG_R { CFG_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Trigger event enable"]
# [inline (always)]
# [must_use]
pub fn trigei (& mut self) -> TRIGEI_W < 0 > { TRIGEI_W :: new (self) } # [doc = "Bit 2 - event action"]
# [inline (always)]
# [must_use]
pub fn action (& mut self) -> ACTION_W < 2 > { ACTION_W :: new (self) } # [doc = "Bit 4 - edge select"]
# [inline (always)]
# [must_use]
pub fn edge (& mut self) -> EDGE_W < 4 > { EDGE_W :: new (self) } # [doc = "Bits 6:7 - event config"]
# [inline (always)]
# [must_use]
pub fn cfg (& mut self) -> CFG_W < 6 > { CFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "EVCTRLB\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrlb](index.html) module"]
pub struct EVCTRLB_SPEC ; impl crate :: RegisterSpec for EVCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrlb::R](R) reader structure"]
impl crate :: Readable for EVCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrlb::W](W) writer structure"]
impl crate :: Writable for EVCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRLB to value 0"]
impl crate :: Resettable for EVCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FAULTCTRL (rw) register accessor: an alias for `Reg<FAULTCTRL_SPEC>`"]
pub type FAULTCTRL = crate :: Reg < faultctrl :: FAULTCTRL_SPEC > ; # [doc = "Fault Control"]
pub mod faultctrl { # [doc = "Register `FAULTCTRL` reader"]
pub struct R (crate :: R < FAULTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FAULTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FAULTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FAULTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `FAULTCTRL` writer"]
pub struct W (crate :: W < FAULTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FAULTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FAULTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FAULTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FAULTCTRL_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FAULTCTRL_SPEC , bool , O > ; # [doc = "Field `CMPC` reader - Compare C value"]
pub type CMPC_R = crate :: BitReader < bool > ; # [doc = "Field `CMPC` writer - Compare C value"]
pub type CMPC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FAULTCTRL_SPEC , bool , O > ; # [doc = "Field `CMPD` reader - Compare D vaule"]
pub type CMPD_R = crate :: BitReader < bool > ; # [doc = "Field `CMPD` writer - Compare D vaule"]
pub type CMPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FAULTCTRL_SPEC , bool , O > ; # [doc = "Field `CMPAEN` reader - Compare A enable"]
pub type CMPAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CMPAEN` writer - Compare A enable"]
pub type CMPAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FAULTCTRL_SPEC , bool , O > ; # [doc = "Field `CMPBEN` reader - Compare B enable"]
pub type CMPBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CMPBEN` writer - Compare B enable"]
pub type CMPBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FAULTCTRL_SPEC , bool , O > ; # [doc = "Field `CMPCEN` reader - Compare C enable"]
pub type CMPCEN_R = crate :: BitReader < bool > ; # [doc = "Field `CMPCEN` writer - Compare C enable"]
pub type CMPCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FAULTCTRL_SPEC , bool , O > ; # [doc = "Field `CMPDEN` reader - Compare D enable"]
pub type CMPDEN_R = crate :: BitReader < bool > ; # [doc = "Field `CMPDEN` writer - Compare D enable"]
pub type CMPDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FAULTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare C value"]
# [inline (always)]
pub fn cmpc (& self) -> CMPC_R { CMPC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare D vaule"]
# [inline (always)]
pub fn cmpd (& self) -> CMPD_R { CMPD_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare A enable"]
# [inline (always)]
pub fn cmpaen (& self) -> CMPAEN_R { CMPAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare B enable"]
# [inline (always)]
pub fn cmpben (& self) -> CMPBEN_R { CMPBEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare C enable"]
# [inline (always)]
pub fn cmpcen (& self) -> CMPCEN_R { CMPCEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare D enable"]
# [inline (always)]
pub fn cmpden (& self) -> CMPDEN_R { CMPDEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Bit 2 - Compare C value"]
# [inline (always)]
# [must_use]
pub fn cmpc (& mut self) -> CMPC_W < 2 > { CMPC_W :: new (self) } # [doc = "Bit 3 - Compare D vaule"]
# [inline (always)]
# [must_use]
pub fn cmpd (& mut self) -> CMPD_W < 3 > { CMPD_W :: new (self) } # [doc = "Bit 4 - Compare A enable"]
# [inline (always)]
# [must_use]
pub fn cmpaen (& mut self) -> CMPAEN_W < 4 > { CMPAEN_W :: new (self) } # [doc = "Bit 5 - Compare B enable"]
# [inline (always)]
# [must_use]
pub fn cmpben (& mut self) -> CMPBEN_W < 5 > { CMPBEN_W :: new (self) } # [doc = "Bit 6 - Compare C enable"]
# [inline (always)]
# [must_use]
pub fn cmpcen (& mut self) -> CMPCEN_W < 6 > { CMPCEN_W :: new (self) } # [doc = "Bit 7 - Compare D enable"]
# [inline (always)]
# [must_use]
pub fn cmpden (& mut self) -> CMPDEN_W < 7 > { CMPDEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Fault Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [faultctrl](index.html) module"]
pub struct FAULTCTRL_SPEC ; impl crate :: RegisterSpec for FAULTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [faultctrl::R](R) reader structure"]
impl crate :: Readable for FAULTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [faultctrl::W](W) writer structure"]
impl crate :: Writable for FAULTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FAULTCTRL to value 0"]
impl crate :: Resettable for FAULTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INPUTCTRLA (rw) register accessor: an alias for `Reg<INPUTCTRLA_SPEC>`"]
pub type INPUTCTRLA = crate :: Reg < inputctrla :: INPUTCTRLA_SPEC > ; # [doc = "Input Control A"]
pub mod inputctrla { # [doc = "Register `INPUTCTRLA` reader"]
pub struct R (crate :: R < INPUTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INPUTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INPUTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INPUTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INPUTCTRLA` writer"]
pub struct W (crate :: W < INPUTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INPUTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INPUTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INPUTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `INPUTMODE` reader - Input mode"]
pub type INPUTMODE_R = crate :: FieldReader < u8 , INPUTMODE_A > ; # [doc = "Input mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INPUTMODE_A { # [doc = "0: Input has no actions"]
NONE = 0 , # [doc = "1: Stop output, jump to opposite compare cycle and wait"]
JMPWAIT = 1 , # [doc = "2: Stop output, execute opposite compare cycle and wait"]
EXECWAIT = 2 , # [doc = "3: stop output, execute opposite compare cycle while fault active"]
EXECFAULT = 3 , # [doc = "4: Stop all outputs, maintain frequency"]
FREQ = 4 , # [doc = "5: Stop all outputs, execute dead time while fault active"]
EXECDT = 5 , # [doc = "6: Stop all outputs, jump to next compare cycle and wait"]
WAIT = 6 , # [doc = "7: Stop all outputs, wait for software action"]
WAITSW = 7 , # [doc = "8: Stop output on edge, jump to next compare cycle"]
EDGETRIG = 8 , # [doc = "9: Stop output on edge, maintain frequency"]
EDGETRIGFREQ = 9 , # [doc = "10: Stop output at level, maintain frequency"]
LVLTRIGFREQ = 10 , } impl From < INPUTMODE_A > for u8 { # [inline (always)]
fn from (variant : INPUTMODE_A) -> Self { variant as _ } } impl INPUTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INPUTMODE_A > { match self . bits { 0 => Some (INPUTMODE_A :: NONE) , 1 => Some (INPUTMODE_A :: JMPWAIT) , 2 => Some (INPUTMODE_A :: EXECWAIT) , 3 => Some (INPUTMODE_A :: EXECFAULT) , 4 => Some (INPUTMODE_A :: FREQ) , 5 => Some (INPUTMODE_A :: EXECDT) , 6 => Some (INPUTMODE_A :: WAIT) , 7 => Some (INPUTMODE_A :: WAITSW) , 8 => Some (INPUTMODE_A :: EDGETRIG) , 9 => Some (INPUTMODE_A :: EDGETRIGFREQ) , 10 => Some (INPUTMODE_A :: LVLTRIGFREQ) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == INPUTMODE_A :: NONE } # [doc = "Checks if the value of the field is `JMPWAIT`"]
# [inline (always)]
pub fn is_jmpwait (& self) -> bool { * self == INPUTMODE_A :: JMPWAIT } # [doc = "Checks if the value of the field is `EXECWAIT`"]
# [inline (always)]
pub fn is_execwait (& self) -> bool { * self == INPUTMODE_A :: EXECWAIT } # [doc = "Checks if the value of the field is `EXECFAULT`"]
# [inline (always)]
pub fn is_execfault (& self) -> bool { * self == INPUTMODE_A :: EXECFAULT } # [doc = "Checks if the value of the field is `FREQ`"]
# [inline (always)]
pub fn is_freq (& self) -> bool { * self == INPUTMODE_A :: FREQ } # [doc = "Checks if the value of the field is `EXECDT`"]
# [inline (always)]
pub fn is_execdt (& self) -> bool { * self == INPUTMODE_A :: EXECDT } # [doc = "Checks if the value of the field is `WAIT`"]
# [inline (always)]
pub fn is_wait (& self) -> bool { * self == INPUTMODE_A :: WAIT } # [doc = "Checks if the value of the field is `WAITSW`"]
# [inline (always)]
pub fn is_waitsw (& self) -> bool { * self == INPUTMODE_A :: WAITSW } # [doc = "Checks if the value of the field is `EDGETRIG`"]
# [inline (always)]
pub fn is_edgetrig (& self) -> bool { * self == INPUTMODE_A :: EDGETRIG } # [doc = "Checks if the value of the field is `EDGETRIGFREQ`"]
# [inline (always)]
pub fn is_edgetrigfreq (& self) -> bool { * self == INPUTMODE_A :: EDGETRIGFREQ } # [doc = "Checks if the value of the field is `LVLTRIGFREQ`"]
# [inline (always)]
pub fn is_lvltrigfreq (& self) -> bool { * self == INPUTMODE_A :: LVLTRIGFREQ } } # [doc = "Field `INPUTMODE` writer - Input mode"]
pub type INPUTMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , INPUTCTRLA_SPEC , u8 , INPUTMODE_A , 4 , O > ; impl < 'a , const O : u8 > INPUTMODE_W < 'a , O > { # [doc = "Input has no actions"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (INPUTMODE_A :: NONE) } # [doc = "Stop output, jump to opposite compare cycle and wait"]
# [inline (always)]
pub fn jmpwait (self) -> & 'a mut W { self . variant (INPUTMODE_A :: JMPWAIT) } # [doc = "Stop output, execute opposite compare cycle and wait"]
# [inline (always)]
pub fn execwait (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EXECWAIT) } # [doc = "stop output, execute opposite compare cycle while fault active"]
# [inline (always)]
pub fn execfault (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EXECFAULT) } # [doc = "Stop all outputs, maintain frequency"]
# [inline (always)]
pub fn freq (self) -> & 'a mut W { self . variant (INPUTMODE_A :: FREQ) } # [doc = "Stop all outputs, execute dead time while fault active"]
# [inline (always)]
pub fn execdt (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EXECDT) } # [doc = "Stop all outputs, jump to next compare cycle and wait"]
# [inline (always)]
pub fn wait (self) -> & 'a mut W { self . variant (INPUTMODE_A :: WAIT) } # [doc = "Stop all outputs, wait for software action"]
# [inline (always)]
pub fn waitsw (self) -> & 'a mut W { self . variant (INPUTMODE_A :: WAITSW) } # [doc = "Stop output on edge, jump to next compare cycle"]
# [inline (always)]
pub fn edgetrig (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EDGETRIG) } # [doc = "Stop output on edge, maintain frequency"]
# [inline (always)]
pub fn edgetrigfreq (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EDGETRIGFREQ) } # [doc = "Stop output at level, maintain frequency"]
# [inline (always)]
pub fn lvltrigfreq (self) -> & 'a mut W { self . variant (INPUTMODE_A :: LVLTRIGFREQ) } } impl R { # [doc = "Bits 0:3 - Input mode"]
# [inline (always)]
pub fn inputmode (& self) -> INPUTMODE_R { INPUTMODE_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Input mode"]
# [inline (always)]
# [must_use]
pub fn inputmode (& mut self) -> INPUTMODE_W < 0 > { INPUTMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [inputctrla](index.html) module"]
pub struct INPUTCTRLA_SPEC ; impl crate :: RegisterSpec for INPUTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [inputctrla::R](R) reader structure"]
impl crate :: Readable for INPUTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [inputctrla::W](W) writer structure"]
impl crate :: Writable for INPUTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INPUTCTRLA to value 0"]
impl crate :: Resettable for INPUTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INPUTCTRLB (rw) register accessor: an alias for `Reg<INPUTCTRLB_SPEC>`"]
pub type INPUTCTRLB = crate :: Reg < inputctrlb :: INPUTCTRLB_SPEC > ; # [doc = "Input Control B"]
pub mod inputctrlb { # [doc = "Register `INPUTCTRLB` reader"]
pub struct R (crate :: R < INPUTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INPUTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INPUTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INPUTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INPUTCTRLB` writer"]
pub struct W (crate :: W < INPUTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INPUTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INPUTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INPUTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `INPUTMODE` reader - Input mode"]
pub type INPUTMODE_R = crate :: FieldReader < u8 , INPUTMODE_A > ; # [doc = "Input mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INPUTMODE_A { # [doc = "0: Input has no actions"]
NONE = 0 , # [doc = "1: Stop output, jump to opposite compare cycle and wait"]
JMPWAIT = 1 , # [doc = "2: Stop output, execute opposite compare cycle and wait"]
EXECWAIT = 2 , # [doc = "3: stop output, execute opposite compare cycle while fault active"]
EXECFAULT = 3 , # [doc = "4: Stop all outputs, maintain frequency"]
FREQ = 4 , # [doc = "5: Stop all outputs, execute dead time while fault active"]
EXECDT = 5 , # [doc = "6: Stop all outputs, jump to next compare cycle and wait"]
WAIT = 6 , # [doc = "7: Stop all outputs, wait for software action"]
WAITSW = 7 , # [doc = "8: Stop output on edge, jump to next compare cycle"]
EDGETRIG = 8 , # [doc = "9: Stop output on edge, maintain frequency"]
EDGETRIGFREQ = 9 , # [doc = "10: Stop output at level, maintain frequency"]
LVLTRIGFREQ = 10 , } impl From < INPUTMODE_A > for u8 { # [inline (always)]
fn from (variant : INPUTMODE_A) -> Self { variant as _ } } impl INPUTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INPUTMODE_A > { match self . bits { 0 => Some (INPUTMODE_A :: NONE) , 1 => Some (INPUTMODE_A :: JMPWAIT) , 2 => Some (INPUTMODE_A :: EXECWAIT) , 3 => Some (INPUTMODE_A :: EXECFAULT) , 4 => Some (INPUTMODE_A :: FREQ) , 5 => Some (INPUTMODE_A :: EXECDT) , 6 => Some (INPUTMODE_A :: WAIT) , 7 => Some (INPUTMODE_A :: WAITSW) , 8 => Some (INPUTMODE_A :: EDGETRIG) , 9 => Some (INPUTMODE_A :: EDGETRIGFREQ) , 10 => Some (INPUTMODE_A :: LVLTRIGFREQ) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == INPUTMODE_A :: NONE } # [doc = "Checks if the value of the field is `JMPWAIT`"]
# [inline (always)]
pub fn is_jmpwait (& self) -> bool { * self == INPUTMODE_A :: JMPWAIT } # [doc = "Checks if the value of the field is `EXECWAIT`"]
# [inline (always)]
pub fn is_execwait (& self) -> bool { * self == INPUTMODE_A :: EXECWAIT } # [doc = "Checks if the value of the field is `EXECFAULT`"]
# [inline (always)]
pub fn is_execfault (& self) -> bool { * self == INPUTMODE_A :: EXECFAULT } # [doc = "Checks if the value of the field is `FREQ`"]
# [inline (always)]
pub fn is_freq (& self) -> bool { * self == INPUTMODE_A :: FREQ } # [doc = "Checks if the value of the field is `EXECDT`"]
# [inline (always)]
pub fn is_execdt (& self) -> bool { * self == INPUTMODE_A :: EXECDT } # [doc = "Checks if the value of the field is `WAIT`"]
# [inline (always)]
pub fn is_wait (& self) -> bool { * self == INPUTMODE_A :: WAIT } # [doc = "Checks if the value of the field is `WAITSW`"]
# [inline (always)]
pub fn is_waitsw (& self) -> bool { * self == INPUTMODE_A :: WAITSW } # [doc = "Checks if the value of the field is `EDGETRIG`"]
# [inline (always)]
pub fn is_edgetrig (& self) -> bool { * self == INPUTMODE_A :: EDGETRIG } # [doc = "Checks if the value of the field is `EDGETRIGFREQ`"]
# [inline (always)]
pub fn is_edgetrigfreq (& self) -> bool { * self == INPUTMODE_A :: EDGETRIGFREQ } # [doc = "Checks if the value of the field is `LVLTRIGFREQ`"]
# [inline (always)]
pub fn is_lvltrigfreq (& self) -> bool { * self == INPUTMODE_A :: LVLTRIGFREQ } } # [doc = "Field `INPUTMODE` writer - Input mode"]
pub type INPUTMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , INPUTCTRLB_SPEC , u8 , INPUTMODE_A , 4 , O > ; impl < 'a , const O : u8 > INPUTMODE_W < 'a , O > { # [doc = "Input has no actions"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (INPUTMODE_A :: NONE) } # [doc = "Stop output, jump to opposite compare cycle and wait"]
# [inline (always)]
pub fn jmpwait (self) -> & 'a mut W { self . variant (INPUTMODE_A :: JMPWAIT) } # [doc = "Stop output, execute opposite compare cycle and wait"]
# [inline (always)]
pub fn execwait (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EXECWAIT) } # [doc = "stop output, execute opposite compare cycle while fault active"]
# [inline (always)]
pub fn execfault (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EXECFAULT) } # [doc = "Stop all outputs, maintain frequency"]
# [inline (always)]
pub fn freq (self) -> & 'a mut W { self . variant (INPUTMODE_A :: FREQ) } # [doc = "Stop all outputs, execute dead time while fault active"]
# [inline (always)]
pub fn execdt (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EXECDT) } # [doc = "Stop all outputs, jump to next compare cycle and wait"]
# [inline (always)]
pub fn wait (self) -> & 'a mut W { self . variant (INPUTMODE_A :: WAIT) } # [doc = "Stop all outputs, wait for software action"]
# [inline (always)]
pub fn waitsw (self) -> & 'a mut W { self . variant (INPUTMODE_A :: WAITSW) } # [doc = "Stop output on edge, jump to next compare cycle"]
# [inline (always)]
pub fn edgetrig (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EDGETRIG) } # [doc = "Stop output on edge, maintain frequency"]
# [inline (always)]
pub fn edgetrigfreq (self) -> & 'a mut W { self . variant (INPUTMODE_A :: EDGETRIGFREQ) } # [doc = "Stop output at level, maintain frequency"]
# [inline (always)]
pub fn lvltrigfreq (self) -> & 'a mut W { self . variant (INPUTMODE_A :: LVLTRIGFREQ) } } impl R { # [doc = "Bits 0:3 - Input mode"]
# [inline (always)]
pub fn inputmode (& self) -> INPUTMODE_R { INPUTMODE_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Input mode"]
# [inline (always)]
# [must_use]
pub fn inputmode (& mut self) -> INPUTMODE_W < 0 > { INPUTMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [inputctrlb](index.html) module"]
pub struct INPUTCTRLB_SPEC ; impl crate :: RegisterSpec for INPUTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [inputctrlb::R](R) reader structure"]
impl crate :: Readable for INPUTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [inputctrlb::W](W) writer structure"]
impl crate :: Writable for INPUTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INPUTCTRLB to value 0"]
impl crate :: Resettable for INPUTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow interrupt enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow interrupt enable"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `TRIGA` reader - Trigger A interrupt enable"]
pub type TRIGA_R = crate :: BitReader < bool > ; # [doc = "Field `TRIGA` writer - Trigger A interrupt enable"]
pub type TRIGA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `TRIGB` reader - Trigger B interrupt enable"]
pub type TRIGB_R = crate :: BitReader < bool > ; # [doc = "Field `TRIGB` writer - Trigger B interrupt enable"]
pub type TRIGB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow interrupt enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Trigger A interrupt enable"]
# [inline (always)]
pub fn triga (& self) -> TRIGA_R { TRIGA_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Trigger B interrupt enable"]
# [inline (always)]
pub fn trigb (& self) -> TRIGB_R { TRIGB_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow interrupt enable"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 2 - Trigger A interrupt enable"]
# [inline (always)]
# [must_use]
pub fn triga (& mut self) -> TRIGA_W < 2 > { TRIGA_W :: new (self) } # [doc = "Bit 3 - Trigger B interrupt enable"]
# [inline (always)]
# [must_use]
pub fn trigb (& mut self) -> TRIGB_W < 3 > { TRIGB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow interrupt enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow interrupt enable"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `TRIGA` reader - Trigger A interrupt enable"]
pub type TRIGA_R = crate :: BitReader < bool > ; # [doc = "Field `TRIGA` writer - Trigger A interrupt enable"]
pub type TRIGA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `TRIGB` reader - Trigger B interrupt enable"]
pub type TRIGB_R = crate :: BitReader < bool > ; # [doc = "Field `TRIGB` writer - Trigger B interrupt enable"]
pub type TRIGB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow interrupt enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Trigger A interrupt enable"]
# [inline (always)]
pub fn triga (& self) -> TRIGA_R { TRIGA_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Trigger B interrupt enable"]
# [inline (always)]
pub fn trigb (& self) -> TRIGB_R { TRIGB_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow interrupt enable"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 2 - Trigger A interrupt enable"]
# [inline (always)]
# [must_use]
pub fn triga (& mut self) -> TRIGA_W < 2 > { TRIGA_W :: new (self) } # [doc = "Bit 3 - Trigger B interrupt enable"]
# [inline (always)]
# [must_use]
pub fn trigb (& mut self) -> TRIGB_W < 3 > { TRIGB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENRDY` reader - Enable ready"]
pub type ENRDY_R = crate :: BitReader < bool > ; # [doc = "Field `CMDRDY` reader - Command ready"]
pub type CMDRDY_R = crate :: BitReader < bool > ; # [doc = "Field `PWMACTA` reader - PWM activity on A"]
pub type PWMACTA_R = crate :: BitReader < bool > ; # [doc = "Field `PWMACTA` writer - PWM activity on A"]
pub type PWMACTA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PWMACTB` reader - PWM activity on B"]
pub type PWMACTB_R = crate :: BitReader < bool > ; # [doc = "Field `PWMACTB` writer - PWM activity on B"]
pub type PWMACTB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable ready"]
# [inline (always)]
pub fn enrdy (& self) -> ENRDY_R { ENRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Command ready"]
# [inline (always)]
pub fn cmdrdy (& self) -> CMDRDY_R { CMDRDY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 6 - PWM activity on A"]
# [inline (always)]
pub fn pwmacta (& self) -> PWMACTA_R { PWMACTA_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - PWM activity on B"]
# [inline (always)]
pub fn pwmactb (& self) -> PWMACTB_R { PWMACTB_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 6 - PWM activity on A"]
# [inline (always)]
# [must_use]
pub fn pwmacta (& mut self) -> PWMACTA_W < 6 > { PWMACTA_W :: new (self) } # [doc = "Bit 7 - PWM activity on B"]
# [inline (always)]
# [must_use]
pub fn pwmactb (& mut self) -> PWMACTB_W < 7 > { PWMACTB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Two-Wire Interface"]
pub struct TWI0 { _marker : PhantomData < * const () > } unsafe impl Send for TWI0 { } impl TWI0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const twi0 :: RegisterBlock = 0x0810 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const twi0 :: RegisterBlock { Self :: PTR } } impl Deref for TWI0 { type Target = twi0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TWI0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TWI0") . finish () } } # [doc = "Two-Wire Interface"]
pub mod twi0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Debug Control Register"]
pub dbgctrl : DBGCTRL , # [doc = "0x03 - Host Control A"]
pub mctrla : MCTRLA , # [doc = "0x04 - Host Control B"]
pub mctrlb : MCTRLB , # [doc = "0x05 - Host Status"]
pub mstatus : MSTATUS , # [doc = "0x06 - Host Baud Rate Control"]
pub mbaud : MBAUD , # [doc = "0x07 - Host Address"]
pub maddr : MADDR , # [doc = "0x08 - Host Data"]
pub mdata : MDATA , # [doc = "0x09 - Client Control A"]
pub sctrla : SCTRLA , # [doc = "0x0a - Client Control B"]
pub sctrlb : SCTRLB , # [doc = "0x0b - Client Status"]
pub sstatus : SSTATUS , # [doc = "0x0c - Client Address"]
pub saddr : SADDR , # [doc = "0x0d - Client Data"]
pub sdata : SDATA , # [doc = "0x0e - Client Address Mask"]
pub saddrmask : SADDRMASK , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `FMPEN` reader - FM Plus Enable"]
pub type FMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `FMPEN` writer - FM Plus Enable"]
pub type FMPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `SDAHOLD` reader - SDA Hold Time"]
pub type SDAHOLD_R = crate :: FieldReader < u8 , SDAHOLD_A > ; # [doc = "SDA Hold Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SDAHOLD_A { # [doc = "0: SDA hold time off"]
OFF = 0 , # [doc = "1: Typical 50ns hold time"]
_50NS = 1 , # [doc = "2: Typical 300ns hold time"]
_300NS = 2 , # [doc = "3: Typical 500ns hold time"]
_500NS = 3 , } impl From < SDAHOLD_A > for u8 { # [inline (always)]
fn from (variant : SDAHOLD_A) -> Self { variant as _ } } impl SDAHOLD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SDAHOLD_A { match self . bits { 0 => SDAHOLD_A :: OFF , 1 => SDAHOLD_A :: _50NS , 2 => SDAHOLD_A :: _300NS , 3 => SDAHOLD_A :: _500NS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SDAHOLD_A :: OFF } # [doc = "Checks if the value of the field is `_50NS`"]
# [inline (always)]
pub fn is_50ns (& self) -> bool { * self == SDAHOLD_A :: _50NS } # [doc = "Checks if the value of the field is `_300NS`"]
# [inline (always)]
pub fn is_300ns (& self) -> bool { * self == SDAHOLD_A :: _300NS } # [doc = "Checks if the value of the field is `_500NS`"]
# [inline (always)]
pub fn is_500ns (& self) -> bool { * self == SDAHOLD_A :: _500NS } } # [doc = "Field `SDAHOLD` writer - SDA Hold Time"]
pub type SDAHOLD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , SDAHOLD_A , 2 , O > ; impl < 'a , const O : u8 > SDAHOLD_W < 'a , O > { # [doc = "SDA hold time off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SDAHOLD_A :: OFF) } # [doc = "Typical 50ns hold time"]
# [inline (always)]
pub fn _50ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _50NS) } # [doc = "Typical 300ns hold time"]
# [inline (always)]
pub fn _300ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _300NS) } # [doc = "Typical 500ns hold time"]
# [inline (always)]
pub fn _500ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _500NS) } } # [doc = "Field `SDASETUP` reader - SDA Setup Time"]
pub type SDASETUP_R = crate :: BitReader < SDASETUP_A > ; # [doc = "SDA Setup Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SDASETUP_A { # [doc = "0: SDA setup time is 4 clock cycles"]
_4CYC = 0 , # [doc = "1: SDA setup time is 8 clock cycles"]
_8CYC = 1 , } impl From < SDASETUP_A > for bool { # [inline (always)]
fn from (variant : SDASETUP_A) -> Self { variant as u8 != 0 } } impl SDASETUP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SDASETUP_A { match self . bits { false => SDASETUP_A :: _4CYC , true => SDASETUP_A :: _8CYC , } } # [doc = "Checks if the value of the field is `_4CYC`"]
# [inline (always)]
pub fn is_4cyc (& self) -> bool { * self == SDASETUP_A :: _4CYC } # [doc = "Checks if the value of the field is `_8CYC`"]
# [inline (always)]
pub fn is_8cyc (& self) -> bool { * self == SDASETUP_A :: _8CYC } } # [doc = "Field `SDASETUP` writer - SDA Setup Time"]
pub type SDASETUP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , SDASETUP_A , O > ; impl < 'a , const O : u8 > SDASETUP_W < 'a , O > { # [doc = "SDA setup time is 4 clock cycles"]
# [inline (always)]
pub fn _4cyc (self) -> & 'a mut W { self . variant (SDASETUP_A :: _4CYC) } # [doc = "SDA setup time is 8 clock cycles"]
# [inline (always)]
pub fn _8cyc (self) -> & 'a mut W { self . variant (SDASETUP_A :: _8CYC) } } impl R { # [doc = "Bit 1 - FM Plus Enable"]
# [inline (always)]
pub fn fmpen (& self) -> FMPEN_R { FMPEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - SDA Hold Time"]
# [inline (always)]
pub fn sdahold (& self) -> SDAHOLD_R { SDAHOLD_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - SDA Setup Time"]
# [inline (always)]
pub fn sdasetup (& self) -> SDASETUP_R { SDASETUP_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 1 - FM Plus Enable"]
# [inline (always)]
# [must_use]
pub fn fmpen (& mut self) -> FMPEN_W < 1 > { FMPEN_W :: new (self) } # [doc = "Bits 2:3 - SDA Hold Time"]
# [inline (always)]
# [must_use]
pub fn sdahold (& mut self) -> SDAHOLD_W < 2 > { SDAHOLD_W :: new (self) } # [doc = "Bit 4 - SDA Setup Time"]
# [inline (always)]
# [must_use]
pub fn sdasetup (& mut self) -> SDASETUP_W < 4 > { SDASETUP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control Register"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MADDR (rw) register accessor: an alias for `Reg<MADDR_SPEC>`"]
pub type MADDR = crate :: Reg < maddr :: MADDR_SPEC > ; # [doc = "Host Address"]
pub mod maddr { # [doc = "Register `MADDR` reader"]
pub struct R (crate :: R < MADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MADDR` writer"]
pub struct W (crate :: W < MADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MADDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Host Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [maddr](index.html) module"]
pub struct MADDR_SPEC ; impl crate :: RegisterSpec for MADDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [maddr::R](R) reader structure"]
impl crate :: Readable for MADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [maddr::W](W) writer structure"]
impl crate :: Writable for MADDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MADDR to value 0"]
impl crate :: Resettable for MADDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MBAUD (rw) register accessor: an alias for `Reg<MBAUD_SPEC>`"]
pub type MBAUD = crate :: Reg < mbaud :: MBAUD_SPEC > ; # [doc = "Host Baud Rate Control"]
pub mod mbaud { # [doc = "Register `MBAUD` reader"]
pub struct R (crate :: R < MBAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MBAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MBAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MBAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `MBAUD` writer"]
pub struct W (crate :: W < MBAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MBAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MBAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MBAUD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Host Baud Rate Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mbaud](index.html) module"]
pub struct MBAUD_SPEC ; impl crate :: RegisterSpec for MBAUD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mbaud::R](R) reader structure"]
impl crate :: Readable for MBAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mbaud::W](W) writer structure"]
impl crate :: Writable for MBAUD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MBAUD to value 0"]
impl crate :: Resettable for MBAUD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCTRLA (rw) register accessor: an alias for `Reg<MCTRLA_SPEC>`"]
pub type MCTRLA = crate :: Reg < mctrla :: MCTRLA_SPEC > ; # [doc = "Host Control A"]
pub mod mctrla { # [doc = "Register `MCTRLA` reader"]
pub struct R (crate :: R < MCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCTRLA` writer"]
pub struct W (crate :: W < MCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable TWI Host"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable TWI Host"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; # [doc = "Field `SMEN` reader - Smart Mode Enable"]
pub type SMEN_R = crate :: BitReader < bool > ; # [doc = "Field `SMEN` writer - Smart Mode Enable"]
pub type SMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; # [doc = "Field `TIMEOUT` reader - Inactive Bus Timeout"]
pub type TIMEOUT_R = crate :: FieldReader < u8 , TIMEOUT_A > ; # [doc = "Inactive Bus Timeout\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TIMEOUT_A { # [doc = "0: Bus Timeout Disabled"]
DISABLED = 0 , # [doc = "1: 50 Microseconds"]
_50US = 1 , # [doc = "2: 100 Microseconds"]
_100US = 2 , # [doc = "3: 200 Microseconds"]
_200US = 3 , } impl From < TIMEOUT_A > for u8 { # [inline (always)]
fn from (variant : TIMEOUT_A) -> Self { variant as _ } } impl TIMEOUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TIMEOUT_A { match self . bits { 0 => TIMEOUT_A :: DISABLED , 1 => TIMEOUT_A :: _50US , 2 => TIMEOUT_A :: _100US , 3 => TIMEOUT_A :: _200US , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == TIMEOUT_A :: DISABLED } # [doc = "Checks if the value of the field is `_50US`"]
# [inline (always)]
pub fn is_50us (& self) -> bool { * self == TIMEOUT_A :: _50US } # [doc = "Checks if the value of the field is `_100US`"]
# [inline (always)]
pub fn is_100us (& self) -> bool { * self == TIMEOUT_A :: _100US } # [doc = "Checks if the value of the field is `_200US`"]
# [inline (always)]
pub fn is_200us (& self) -> bool { * self == TIMEOUT_A :: _200US } } # [doc = "Field `TIMEOUT` writer - Inactive Bus Timeout"]
pub type TIMEOUT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MCTRLA_SPEC , u8 , TIMEOUT_A , 2 , O > ; impl < 'a , const O : u8 > TIMEOUT_W < 'a , O > { # [doc = "Bus Timeout Disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (TIMEOUT_A :: DISABLED) } # [doc = "50 Microseconds"]
# [inline (always)]
pub fn _50us (self) -> & 'a mut W { self . variant (TIMEOUT_A :: _50US) } # [doc = "100 Microseconds"]
# [inline (always)]
pub fn _100us (self) -> & 'a mut W { self . variant (TIMEOUT_A :: _100US) } # [doc = "200 Microseconds"]
# [inline (always)]
pub fn _200us (self) -> & 'a mut W { self . variant (TIMEOUT_A :: _200US) } } # [doc = "Field `QCEN` reader - Quick Command Enable"]
pub type QCEN_R = crate :: BitReader < bool > ; # [doc = "Field `QCEN` writer - Quick Command Enable"]
pub type QCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; # [doc = "Field `WIEN` reader - Write Interrupt Enable"]
pub type WIEN_R = crate :: BitReader < bool > ; # [doc = "Field `WIEN` writer - Write Interrupt Enable"]
pub type WIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; # [doc = "Field `RIEN` reader - Read Interrupt Enable"]
pub type RIEN_R = crate :: BitReader < bool > ; # [doc = "Field `RIEN` writer - Read Interrupt Enable"]
pub type RIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable TWI Host"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Smart Mode Enable"]
# [inline (always)]
pub fn smen (& self) -> SMEN_R { SMEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Inactive Bus Timeout"]
# [inline (always)]
pub fn timeout (& self) -> TIMEOUT_R { TIMEOUT_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Quick Command Enable"]
# [inline (always)]
pub fn qcen (& self) -> QCEN_R { QCEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Write Interrupt Enable"]
# [inline (always)]
pub fn wien (& self) -> WIEN_R { WIEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Read Interrupt Enable"]
# [inline (always)]
pub fn rien (& self) -> RIEN_R { RIEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable TWI Host"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Smart Mode Enable"]
# [inline (always)]
# [must_use]
pub fn smen (& mut self) -> SMEN_W < 1 > { SMEN_W :: new (self) } # [doc = "Bits 2:3 - Inactive Bus Timeout"]
# [inline (always)]
# [must_use]
pub fn timeout (& mut self) -> TIMEOUT_W < 2 > { TIMEOUT_W :: new (self) } # [doc = "Bit 4 - Quick Command Enable"]
# [inline (always)]
# [must_use]
pub fn qcen (& mut self) -> QCEN_W < 4 > { QCEN_W :: new (self) } # [doc = "Bit 6 - Write Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn wien (& mut self) -> WIEN_W < 6 > { WIEN_W :: new (self) } # [doc = "Bit 7 - Read Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rien (& mut self) -> RIEN_W < 7 > { RIEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Host Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mctrla](index.html) module"]
pub struct MCTRLA_SPEC ; impl crate :: RegisterSpec for MCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mctrla::R](R) reader structure"]
impl crate :: Readable for MCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mctrla::W](W) writer structure"]
impl crate :: Writable for MCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCTRLA to value 0"]
impl crate :: Resettable for MCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCTRLB (rw) register accessor: an alias for `Reg<MCTRLB_SPEC>`"]
pub type MCTRLB = crate :: Reg < mctrlb :: MCTRLB_SPEC > ; # [doc = "Host Control B"]
pub mod mctrlb { # [doc = "Register `MCTRLB` reader"]
pub struct R (crate :: R < MCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCTRLB` writer"]
pub struct W (crate :: W < MCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MCMD` reader - Command"]
pub type MCMD_R = crate :: FieldReader < u8 , MCMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MCMD_A { # [doc = "0: No Action"]
NOACT = 0 , # [doc = "1: Issue Repeated Start Condition"]
REPSTART = 1 , # [doc = "2: Receive or Transmit Data, depending on DIR"]
RECVTRANS = 2 , # [doc = "3: Issue Stop Condition"]
STOP = 3 , } impl From < MCMD_A > for u8 { # [inline (always)]
fn from (variant : MCMD_A) -> Self { variant as _ } } impl MCMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MCMD_A { match self . bits { 0 => MCMD_A :: NOACT , 1 => MCMD_A :: REPSTART , 2 => MCMD_A :: RECVTRANS , 3 => MCMD_A :: STOP , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NOACT`"]
# [inline (always)]
pub fn is_noact (& self) -> bool { * self == MCMD_A :: NOACT } # [doc = "Checks if the value of the field is `REPSTART`"]
# [inline (always)]
pub fn is_repstart (& self) -> bool { * self == MCMD_A :: REPSTART } # [doc = "Checks if the value of the field is `RECVTRANS`"]
# [inline (always)]
pub fn is_recvtrans (& self) -> bool { * self == MCMD_A :: RECVTRANS } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == MCMD_A :: STOP } } # [doc = "Field `MCMD` writer - Command"]
pub type MCMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MCTRLB_SPEC , u8 , MCMD_A , 2 , O > ; impl < 'a , const O : u8 > MCMD_W < 'a , O > { # [doc = "No Action"]
# [inline (always)]
pub fn noact (self) -> & 'a mut W { self . variant (MCMD_A :: NOACT) } # [doc = "Issue Repeated Start Condition"]
# [inline (always)]
pub fn repstart (self) -> & 'a mut W { self . variant (MCMD_A :: REPSTART) } # [doc = "Receive or Transmit Data, depending on DIR"]
# [inline (always)]
pub fn recvtrans (self) -> & 'a mut W { self . variant (MCMD_A :: RECVTRANS) } # [doc = "Issue Stop Condition"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (MCMD_A :: STOP) } } # [doc = "Field `ACKACT` reader - Acknowledge Action"]
pub type ACKACT_R = crate :: BitReader < ACKACT_A > ; # [doc = "Acknowledge Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ACKACT_A { # [doc = "0: Send ACK"]
ACK = 0 , # [doc = "1: Send NACK"]
NACK = 1 , } impl From < ACKACT_A > for bool { # [inline (always)]
fn from (variant : ACKACT_A) -> Self { variant as u8 != 0 } } impl ACKACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACKACT_A { match self . bits { false => ACKACT_A :: ACK , true => ACKACT_A :: NACK , } } # [doc = "Checks if the value of the field is `ACK`"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == ACKACT_A :: ACK } # [doc = "Checks if the value of the field is `NACK`"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == ACKACT_A :: NACK } } # [doc = "Field `ACKACT` writer - Acknowledge Action"]
pub type ACKACT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLB_SPEC , ACKACT_A , O > ; impl < 'a , const O : u8 > ACKACT_W < 'a , O > { # [doc = "Send ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut W { self . variant (ACKACT_A :: ACK) } # [doc = "Send NACK"]
# [inline (always)]
pub fn nack (self) -> & 'a mut W { self . variant (ACKACT_A :: NACK) } } # [doc = "Field `FLUSH` reader - Flush"]
pub type FLUSH_R = crate :: BitReader < bool > ; # [doc = "Field `FLUSH` writer - Flush"]
pub type FLUSH_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Command"]
# [inline (always)]
pub fn mcmd (& self) -> MCMD_R { MCMD_R :: new (self . bits & 3) } # [doc = "Bit 2 - Acknowledge Action"]
# [inline (always)]
pub fn ackact (& self) -> ACKACT_R { ACKACT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Flush"]
# [inline (always)]
pub fn flush (& self) -> FLUSH_R { FLUSH_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Command"]
# [inline (always)]
# [must_use]
pub fn mcmd (& mut self) -> MCMD_W < 0 > { MCMD_W :: new (self) } # [doc = "Bit 2 - Acknowledge Action"]
# [inline (always)]
# [must_use]
pub fn ackact (& mut self) -> ACKACT_W < 2 > { ACKACT_W :: new (self) } # [doc = "Bit 3 - Flush"]
# [inline (always)]
# [must_use]
pub fn flush (& mut self) -> FLUSH_W < 3 > { FLUSH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Host Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mctrlb](index.html) module"]
pub struct MCTRLB_SPEC ; impl crate :: RegisterSpec for MCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mctrlb::R](R) reader structure"]
impl crate :: Readable for MCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mctrlb::W](W) writer structure"]
impl crate :: Writable for MCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCTRLB to value 0"]
impl crate :: Resettable for MCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MDATA (rw) register accessor: an alias for `Reg<MDATA_SPEC>`"]
pub type MDATA = crate :: Reg < mdata :: MDATA_SPEC > ; # [doc = "Host Data"]
pub mod mdata { # [doc = "Register `MDATA` reader"]
pub struct R (crate :: R < MDATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MDATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MDATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MDATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `MDATA` writer"]
pub struct W (crate :: W < MDATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MDATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MDATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MDATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Host Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mdata](index.html) module"]
pub struct MDATA_SPEC ; impl crate :: RegisterSpec for MDATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mdata::R](R) reader structure"]
impl crate :: Readable for MDATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mdata::W](W) writer structure"]
impl crate :: Writable for MDATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MDATA to value 0"]
impl crate :: Resettable for MDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MSTATUS (rw) register accessor: an alias for `Reg<MSTATUS_SPEC>`"]
pub type MSTATUS = crate :: Reg < mstatus :: MSTATUS_SPEC > ; # [doc = "Host Status"]
pub mod mstatus { # [doc = "Register `MSTATUS` reader"]
pub struct R (crate :: R < MSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `MSTATUS` writer"]
pub struct W (crate :: W < MSTATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MSTATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MSTATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `BUSSTATE` reader - Bus State"]
pub type BUSSTATE_R = crate :: FieldReader < u8 , BUSSTATE_A > ; # [doc = "Bus State\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BUSSTATE_A { # [doc = "0: Unknown Bus State"]
UNKNOWN = 0 , # [doc = "1: Bus is Idle"]
IDLE = 1 , # [doc = "2: This Module Controls The Bus"]
OWNER = 2 , # [doc = "3: The Bus is Busy"]
BUSY = 3 , } impl From < BUSSTATE_A > for u8 { # [inline (always)]
fn from (variant : BUSSTATE_A) -> Self { variant as _ } } impl BUSSTATE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BUSSTATE_A { match self . bits { 0 => BUSSTATE_A :: UNKNOWN , 1 => BUSSTATE_A :: IDLE , 2 => BUSSTATE_A :: OWNER , 3 => BUSSTATE_A :: BUSY , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UNKNOWN`"]
# [inline (always)]
pub fn is_unknown (& self) -> bool { * self == BUSSTATE_A :: UNKNOWN } # [doc = "Checks if the value of the field is `IDLE`"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == BUSSTATE_A :: IDLE } # [doc = "Checks if the value of the field is `OWNER`"]
# [inline (always)]
pub fn is_owner (& self) -> bool { * self == BUSSTATE_A :: OWNER } # [doc = "Checks if the value of the field is `BUSY`"]
# [inline (always)]
pub fn is_busy (& self) -> bool { * self == BUSSTATE_A :: BUSY } } # [doc = "Field `BUSSTATE` writer - Bus State"]
pub type BUSSTATE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MSTATUS_SPEC , u8 , BUSSTATE_A , 2 , O > ; impl < 'a , const O : u8 > BUSSTATE_W < 'a , O > { # [doc = "Unknown Bus State"]
# [inline (always)]
pub fn unknown (self) -> & 'a mut W { self . variant (BUSSTATE_A :: UNKNOWN) } # [doc = "Bus is Idle"]
# [inline (always)]
pub fn idle (self) -> & 'a mut W { self . variant (BUSSTATE_A :: IDLE) } # [doc = "This Module Controls The Bus"]
# [inline (always)]
pub fn owner (self) -> & 'a mut W { self . variant (BUSSTATE_A :: OWNER) } # [doc = "The Bus is Busy"]
# [inline (always)]
pub fn busy (self) -> & 'a mut W { self . variant (BUSSTATE_A :: BUSY) } } # [doc = "Field `BUSERR` reader - Bus Error"]
pub type BUSERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSERR` writer - Bus Error"]
pub type BUSERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; # [doc = "Field `ARBLOST` reader - Arbitration Lost"]
pub type ARBLOST_R = crate :: BitReader < bool > ; # [doc = "Field `ARBLOST` writer - Arbitration Lost"]
pub type ARBLOST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; # [doc = "Field `RXACK` reader - Received Acknowledge"]
pub type RXACK_R = crate :: BitReader < bool > ; # [doc = "Field `CLKHOLD` reader - Clock Hold"]
pub type CLKHOLD_R = crate :: BitReader < bool > ; # [doc = "Field `CLKHOLD` writer - Clock Hold"]
pub type CLKHOLD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; # [doc = "Field `WIF` reader - Write Interrupt Flag"]
pub type WIF_R = crate :: BitReader < bool > ; # [doc = "Field `WIF` writer - Write Interrupt Flag"]
pub type WIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; # [doc = "Field `RIF` reader - Read Interrupt Flag"]
pub type RIF_R = crate :: BitReader < bool > ; # [doc = "Field `RIF` writer - Read Interrupt Flag"]
pub type RIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Bus State"]
# [inline (always)]
pub fn busstate (& self) -> BUSSTATE_R { BUSSTATE_R :: new (self . bits & 3) } # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
pub fn buserr (& self) -> BUSERR_R { BUSERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Arbitration Lost"]
# [inline (always)]
pub fn arblost (& self) -> ARBLOST_R { ARBLOST_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Received Acknowledge"]
# [inline (always)]
pub fn rxack (& self) -> RXACK_R { RXACK_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Clock Hold"]
# [inline (always)]
pub fn clkhold (& self) -> CLKHOLD_R { CLKHOLD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Write Interrupt Flag"]
# [inline (always)]
pub fn wif (& self) -> WIF_R { WIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Read Interrupt Flag"]
# [inline (always)]
pub fn rif (& self) -> RIF_R { RIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Bus State"]
# [inline (always)]
# [must_use]
pub fn busstate (& mut self) -> BUSSTATE_W < 0 > { BUSSTATE_W :: new (self) } # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
# [must_use]
pub fn buserr (& mut self) -> BUSERR_W < 2 > { BUSERR_W :: new (self) } # [doc = "Bit 3 - Arbitration Lost"]
# [inline (always)]
# [must_use]
pub fn arblost (& mut self) -> ARBLOST_W < 3 > { ARBLOST_W :: new (self) } # [doc = "Bit 5 - Clock Hold"]
# [inline (always)]
# [must_use]
pub fn clkhold (& mut self) -> CLKHOLD_W < 5 > { CLKHOLD_W :: new (self) } # [doc = "Bit 6 - Write Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn wif (& mut self) -> WIF_W < 6 > { WIF_W :: new (self) } # [doc = "Bit 7 - Read Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rif (& mut self) -> RIF_W < 7 > { RIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Host Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mstatus](index.html) module"]
pub struct MSTATUS_SPEC ; impl crate :: RegisterSpec for MSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mstatus::R](R) reader structure"]
impl crate :: Readable for MSTATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mstatus::W](W) writer structure"]
impl crate :: Writable for MSTATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MSTATUS to value 0"]
impl crate :: Resettable for MSTATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SADDR (rw) register accessor: an alias for `Reg<SADDR_SPEC>`"]
pub type SADDR = crate :: Reg < saddr :: SADDR_SPEC > ; # [doc = "Client Address"]
pub mod saddr { # [doc = "Register `SADDR` reader"]
pub struct R (crate :: R < SADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SADDR` writer"]
pub struct W (crate :: W < SADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SADDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Client Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [saddr](index.html) module"]
pub struct SADDR_SPEC ; impl crate :: RegisterSpec for SADDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [saddr::R](R) reader structure"]
impl crate :: Readable for SADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [saddr::W](W) writer structure"]
impl crate :: Writable for SADDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SADDR to value 0"]
impl crate :: Resettable for SADDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SADDRMASK (rw) register accessor: an alias for `Reg<SADDRMASK_SPEC>`"]
pub type SADDRMASK = crate :: Reg < saddrmask :: SADDRMASK_SPEC > ; # [doc = "Client Address Mask"]
pub mod saddrmask { # [doc = "Register `SADDRMASK` reader"]
pub struct R (crate :: R < SADDRMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SADDRMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SADDRMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SADDRMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `SADDRMASK` writer"]
pub struct W (crate :: W < SADDRMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SADDRMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SADDRMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SADDRMASK_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDREN` reader - Address Enable"]
pub type ADDREN_R = crate :: BitReader < bool > ; # [doc = "Field `ADDREN` writer - Address Enable"]
pub type ADDREN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SADDRMASK_SPEC , bool , O > ; # [doc = "Field `ADDRMASK` reader - Address Mask"]
pub type ADDRMASK_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ADDRMASK` writer - Address Mask"]
pub type ADDRMASK_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SADDRMASK_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bit 0 - Address Enable"]
# [inline (always)]
pub fn addren (& self) -> ADDREN_R { ADDREN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:7 - Address Mask"]
# [inline (always)]
pub fn addrmask (& self) -> ADDRMASK_R { ADDRMASK_R :: new ((self . bits >> 1) & 0x7f) } } impl W { # [doc = "Bit 0 - Address Enable"]
# [inline (always)]
# [must_use]
pub fn addren (& mut self) -> ADDREN_W < 0 > { ADDREN_W :: new (self) } # [doc = "Bits 1:7 - Address Mask"]
# [inline (always)]
# [must_use]
pub fn addrmask (& mut self) -> ADDRMASK_W < 1 > { ADDRMASK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Client Address Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [saddrmask](index.html) module"]
pub struct SADDRMASK_SPEC ; impl crate :: RegisterSpec for SADDRMASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [saddrmask::R](R) reader structure"]
impl crate :: Readable for SADDRMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [saddrmask::W](W) writer structure"]
impl crate :: Writable for SADDRMASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SADDRMASK to value 0"]
impl crate :: Resettable for SADDRMASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCTRLA (rw) register accessor: an alias for `Reg<SCTRLA_SPEC>`"]
pub type SCTRLA = crate :: Reg < sctrla :: SCTRLA_SPEC > ; # [doc = "Client Control A"]
pub mod sctrla { # [doc = "Register `SCTRLA` reader"]
pub struct R (crate :: R < SCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCTRLA` writer"]
pub struct W (crate :: W < SCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable TWI Client"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable TWI Client"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `SMEN` reader - Smart Mode Enable"]
pub type SMEN_R = crate :: BitReader < bool > ; # [doc = "Field `SMEN` writer - Smart Mode Enable"]
pub type SMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `PMEN` reader - Promiscuous Mode Enable"]
pub type PMEN_R = crate :: BitReader < bool > ; # [doc = "Field `PMEN` writer - Promiscuous Mode Enable"]
pub type PMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `PIEN` reader - Stop Interrupt Enable"]
pub type PIEN_R = crate :: BitReader < bool > ; # [doc = "Field `PIEN` writer - Stop Interrupt Enable"]
pub type PIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `APIEN` reader - Address/Stop Interrupt Enable"]
pub type APIEN_R = crate :: BitReader < bool > ; # [doc = "Field `APIEN` writer - Address/Stop Interrupt Enable"]
pub type APIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `DIEN` reader - Data Interrupt Enable"]
pub type DIEN_R = crate :: BitReader < bool > ; # [doc = "Field `DIEN` writer - Data Interrupt Enable"]
pub type DIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable TWI Client"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Smart Mode Enable"]
# [inline (always)]
pub fn smen (& self) -> SMEN_R { SMEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Promiscuous Mode Enable"]
# [inline (always)]
pub fn pmen (& self) -> PMEN_R { PMEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 5 - Stop Interrupt Enable"]
# [inline (always)]
pub fn pien (& self) -> PIEN_R { PIEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Address/Stop Interrupt Enable"]
# [inline (always)]
pub fn apien (& self) -> APIEN_R { APIEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Data Interrupt Enable"]
# [inline (always)]
pub fn dien (& self) -> DIEN_R { DIEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable TWI Client"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Smart Mode Enable"]
# [inline (always)]
# [must_use]
pub fn smen (& mut self) -> SMEN_W < 1 > { SMEN_W :: new (self) } # [doc = "Bit 2 - Promiscuous Mode Enable"]
# [inline (always)]
# [must_use]
pub fn pmen (& mut self) -> PMEN_W < 2 > { PMEN_W :: new (self) } # [doc = "Bit 5 - Stop Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn pien (& mut self) -> PIEN_W < 5 > { PIEN_W :: new (self) } # [doc = "Bit 6 - Address/Stop Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn apien (& mut self) -> APIEN_W < 6 > { APIEN_W :: new (self) } # [doc = "Bit 7 - Data Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dien (& mut self) -> DIEN_W < 7 > { DIEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Client Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sctrla](index.html) module"]
pub struct SCTRLA_SPEC ; impl crate :: RegisterSpec for SCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sctrla::R](R) reader structure"]
impl crate :: Readable for SCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sctrla::W](W) writer structure"]
impl crate :: Writable for SCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTRLA to value 0"]
impl crate :: Resettable for SCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCTRLB (rw) register accessor: an alias for `Reg<SCTRLB_SPEC>`"]
pub type SCTRLB = crate :: Reg < sctrlb :: SCTRLB_SPEC > ; # [doc = "Client Control B"]
pub mod sctrlb { # [doc = "Register `SCTRLB` reader"]
pub struct R (crate :: R < SCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCTRLB` writer"]
pub struct W (crate :: W < SCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCMD` reader - Command"]
pub type SCMD_R = crate :: FieldReader < u8 , SCMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SCMD_A { # [doc = "0: No Action"]
NOACT = 0 , # [doc = "2: Used To Complete a Transaction"]
COMPTRANS = 2 , # [doc = "3: Used in Response to Address/Data Interrupt"]
RESPONSE = 3 , } impl From < SCMD_A > for u8 { # [inline (always)]
fn from (variant : SCMD_A) -> Self { variant as _ } } impl SCMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SCMD_A > { match self . bits { 0 => Some (SCMD_A :: NOACT) , 2 => Some (SCMD_A :: COMPTRANS) , 3 => Some (SCMD_A :: RESPONSE) , _ => None , } } # [doc = "Checks if the value of the field is `NOACT`"]
# [inline (always)]
pub fn is_noact (& self) -> bool { * self == SCMD_A :: NOACT } # [doc = "Checks if the value of the field is `COMPTRANS`"]
# [inline (always)]
pub fn is_comptrans (& self) -> bool { * self == SCMD_A :: COMPTRANS } # [doc = "Checks if the value of the field is `RESPONSE`"]
# [inline (always)]
pub fn is_response (& self) -> bool { * self == SCMD_A :: RESPONSE } } # [doc = "Field `SCMD` writer - Command"]
pub type SCMD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SCTRLB_SPEC , u8 , SCMD_A , 2 , O > ; impl < 'a , const O : u8 > SCMD_W < 'a , O > { # [doc = "No Action"]
# [inline (always)]
pub fn noact (self) -> & 'a mut W { self . variant (SCMD_A :: NOACT) } # [doc = "Used To Complete a Transaction"]
# [inline (always)]
pub fn comptrans (self) -> & 'a mut W { self . variant (SCMD_A :: COMPTRANS) } # [doc = "Used in Response to Address/Data Interrupt"]
# [inline (always)]
pub fn response (self) -> & 'a mut W { self . variant (SCMD_A :: RESPONSE) } } # [doc = "Field `ACKACT` reader - Acknowledge Action"]
pub type ACKACT_R = crate :: BitReader < ACKACT_A > ; # [doc = "Acknowledge Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ACKACT_A { # [doc = "0: Send ACK"]
ACK = 0 , # [doc = "1: Send NACK"]
NACK = 1 , } impl From < ACKACT_A > for bool { # [inline (always)]
fn from (variant : ACKACT_A) -> Self { variant as u8 != 0 } } impl ACKACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACKACT_A { match self . bits { false => ACKACT_A :: ACK , true => ACKACT_A :: NACK , } } # [doc = "Checks if the value of the field is `ACK`"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == ACKACT_A :: ACK } # [doc = "Checks if the value of the field is `NACK`"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == ACKACT_A :: NACK } } # [doc = "Field `ACKACT` writer - Acknowledge Action"]
pub type ACKACT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLB_SPEC , ACKACT_A , O > ; impl < 'a , const O : u8 > ACKACT_W < 'a , O > { # [doc = "Send ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut W { self . variant (ACKACT_A :: ACK) } # [doc = "Send NACK"]
# [inline (always)]
pub fn nack (self) -> & 'a mut W { self . variant (ACKACT_A :: NACK) } } impl R { # [doc = "Bits 0:1 - Command"]
# [inline (always)]
pub fn scmd (& self) -> SCMD_R { SCMD_R :: new (self . bits & 3) } # [doc = "Bit 2 - Acknowledge Action"]
# [inline (always)]
pub fn ackact (& self) -> ACKACT_R { ACKACT_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Command"]
# [inline (always)]
# [must_use]
pub fn scmd (& mut self) -> SCMD_W < 0 > { SCMD_W :: new (self) } # [doc = "Bit 2 - Acknowledge Action"]
# [inline (always)]
# [must_use]
pub fn ackact (& mut self) -> ACKACT_W < 2 > { ACKACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Client Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sctrlb](index.html) module"]
pub struct SCTRLB_SPEC ; impl crate :: RegisterSpec for SCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sctrlb::R](R) reader structure"]
impl crate :: Readable for SCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sctrlb::W](W) writer structure"]
impl crate :: Writable for SCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTRLB to value 0"]
impl crate :: Resettable for SCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SDATA (rw) register accessor: an alias for `Reg<SDATA_SPEC>`"]
pub type SDATA = crate :: Reg < sdata :: SDATA_SPEC > ; # [doc = "Client Data"]
pub mod sdata { # [doc = "Register `SDATA` reader"]
pub struct R (crate :: R < SDATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SDATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SDATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SDATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `SDATA` writer"]
pub struct W (crate :: W < SDATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SDATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SDATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SDATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Client Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sdata](index.html) module"]
pub struct SDATA_SPEC ; impl crate :: RegisterSpec for SDATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sdata::R](R) reader structure"]
impl crate :: Readable for SDATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sdata::W](W) writer structure"]
impl crate :: Writable for SDATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SDATA to value 0"]
impl crate :: Resettable for SDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SSTATUS (rw) register accessor: an alias for `Reg<SSTATUS_SPEC>`"]
pub type SSTATUS = crate :: Reg < sstatus :: SSTATUS_SPEC > ; # [doc = "Client Status"]
pub mod sstatus { # [doc = "Register `SSTATUS` reader"]
pub struct R (crate :: R < SSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `SSTATUS` writer"]
pub struct W (crate :: W < SSTATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SSTATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SSTATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `AP` reader - Client Address or Stop"]
pub type AP_R = crate :: BitReader < AP_A > ; # [doc = "Client Address or Stop\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AP_A { # [doc = "0: Stop condition generated APIF"]
STOP = 0 , # [doc = "1: Address detection generated APIF"]
ADR = 1 , } impl From < AP_A > for bool { # [inline (always)]
fn from (variant : AP_A) -> Self { variant as u8 != 0 } } impl AP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AP_A { match self . bits { false => AP_A :: STOP , true => AP_A :: ADR , } } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == AP_A :: STOP } # [doc = "Checks if the value of the field is `ADR`"]
# [inline (always)]
pub fn is_adr (& self) -> bool { * self == AP_A :: ADR } } # [doc = "Field `DIR` reader - Read/Write Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSERR` reader - Bus Error"]
pub type BUSERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSERR` writer - Bus Error"]
pub type BUSERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SSTATUS_SPEC , bool , O > ; # [doc = "Field `COLL` reader - Collision"]
pub type COLL_R = crate :: BitReader < bool > ; # [doc = "Field `COLL` writer - Collision"]
pub type COLL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SSTATUS_SPEC , bool , O > ; # [doc = "Field `RXACK` reader - Received Acknowledge"]
pub type RXACK_R = crate :: BitReader < bool > ; # [doc = "Field `CLKHOLD` reader - Clock Hold"]
pub type CLKHOLD_R = crate :: BitReader < bool > ; # [doc = "Field `APIF` reader - Address/Stop Interrupt Flag"]
pub type APIF_R = crate :: BitReader < bool > ; # [doc = "Field `APIF` writer - Address/Stop Interrupt Flag"]
pub type APIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SSTATUS_SPEC , bool , O > ; # [doc = "Field `DIF` reader - Data Interrupt Flag"]
pub type DIF_R = crate :: BitReader < bool > ; # [doc = "Field `DIF` writer - Data Interrupt Flag"]
pub type DIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SSTATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Client Address or Stop"]
# [inline (always)]
pub fn ap (& self) -> AP_R { AP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Read/Write Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
pub fn buserr (& self) -> BUSERR_R { BUSERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Collision"]
# [inline (always)]
pub fn coll (& self) -> COLL_R { COLL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Received Acknowledge"]
# [inline (always)]
pub fn rxack (& self) -> RXACK_R { RXACK_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Clock Hold"]
# [inline (always)]
pub fn clkhold (& self) -> CLKHOLD_R { CLKHOLD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Address/Stop Interrupt Flag"]
# [inline (always)]
pub fn apif (& self) -> APIF_R { APIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Data Interrupt Flag"]
# [inline (always)]
pub fn dif (& self) -> DIF_R { DIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
# [must_use]
pub fn buserr (& mut self) -> BUSERR_W < 2 > { BUSERR_W :: new (self) } # [doc = "Bit 3 - Collision"]
# [inline (always)]
# [must_use]
pub fn coll (& mut self) -> COLL_W < 3 > { COLL_W :: new (self) } # [doc = "Bit 6 - Address/Stop Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn apif (& mut self) -> APIF_W < 6 > { APIF_W :: new (self) } # [doc = "Bit 7 - Data Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn dif (& mut self) -> DIF_W < 7 > { DIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Client Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sstatus](index.html) module"]
pub struct SSTATUS_SPEC ; impl crate :: RegisterSpec for SSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sstatus::R](R) reader structure"]
impl crate :: Readable for SSTATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sstatus::W](W) writer structure"]
impl crate :: Writable for SSTATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SSTATUS to value 0"]
impl crate :: Resettable for SSTATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub struct USART0 { _marker : PhantomData < * const () > } unsafe impl Send for USART0 { } impl USART0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart0 :: RegisterBlock = 0x0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart0 :: RegisterBlock { Self :: PTR } } impl Deref for USART0 { type Target = usart0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART0") . finish () } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub mod usart0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Receive Data Low Byte"]
pub rxdatal : RXDATAL , # [doc = "0x01 - Receive Data High Byte"]
pub rxdatah : RXDATAH , # [doc = "0x02 - Transmit Data Low Byte"]
pub txdatal : TXDATAL , # [doc = "0x03 - Transmit Data High Byte"]
pub txdatah : TXDATAH , # [doc = "0x04 - Status"]
pub status : STATUS , # [doc = "0x05 - Control A"]
pub ctrla : CTRLA , # [doc = "0x06 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x07 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x08 - Baud Rate"]
pub baud : BAUD , _reserved9 : [u8 ; 0x01]
, # [doc = "0x0b - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x0c - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x0d - IRCOM Transmitter Pulse Length Control"]
pub txplctrl : TXPLCTRL , # [doc = "0x0e - IRCOM Receiver Pulse Length Control"]
pub rxplctrl : RXPLCTRL , } # [doc = "BAUD (rw) register accessor: an alias for `Reg<BAUD_SPEC>`"]
pub type BAUD = crate :: Reg < baud :: BAUD_SPEC > ; # [doc = "Baud Rate"]
pub mod baud { # [doc = "Register `BAUD` reader"]
pub struct R (crate :: R < BAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD` writer"]
pub struct W (crate :: W < BAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud](index.html) module"]
pub struct BAUD_SPEC ; impl crate :: RegisterSpec for BAUD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud::R](R) reader structure"]
impl crate :: Readable for BAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud::W](W) writer structure"]
impl crate :: Writable for BAUD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUD to value 0"]
impl crate :: Resettable for BAUD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RS485` reader - RS485 Mode internal transmitter"]
pub type RS485_R = crate :: FieldReader < u8 , RS485_A > ; # [doc = "RS485 Mode internal transmitter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RS485_A { # [doc = "0: RS485 Mode disabled"]
OFF = 0 , # [doc = "1: RS485 Mode External drive"]
EXT = 1 , # [doc = "2: RS485 Mode Internal drive"]
INT = 2 , } impl From < RS485_A > for u8 { # [inline (always)]
fn from (variant : RS485_A) -> Self { variant as _ } } impl RS485_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RS485_A > { match self . bits { 0 => Some (RS485_A :: OFF) , 1 => Some (RS485_A :: EXT) , 2 => Some (RS485_A :: INT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RS485_A :: OFF } # [doc = "Checks if the value of the field is `EXT`"]
# [inline (always)]
pub fn is_ext (& self) -> bool { * self == RS485_A :: EXT } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == RS485_A :: INT } } # [doc = "Field `RS485` writer - RS485 Mode internal transmitter"]
pub type RS485_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , RS485_A , 2 , O > ; impl < 'a , const O : u8 > RS485_W < 'a , O > { # [doc = "RS485 Mode disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RS485_A :: OFF) } # [doc = "RS485 Mode External drive"]
# [inline (always)]
pub fn ext (self) -> & 'a mut W { self . variant (RS485_A :: EXT) } # [doc = "RS485 Mode Internal drive"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (RS485_A :: INT) } } # [doc = "Field `ABEIE` reader - Auto-baud Error Interrupt Enable"]
pub type ABEIE_R = crate :: BitReader < bool > ; # [doc = "Field `ABEIE` writer - Auto-baud Error Interrupt Enable"]
pub type ABEIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `LBME` reader - Loop-back Mode Enable"]
pub type LBME_R = crate :: BitReader < bool > ; # [doc = "Field `LBME` writer - Loop-back Mode Enable"]
pub type LBME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXSIE` reader - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXSIE` writer - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DREIE` reader - Data Register Empty Interrupt Enable"]
pub type DREIE_R = crate :: BitReader < bool > ; # [doc = "Field `DREIE` writer - Data Register Empty Interrupt Enable"]
pub type DREIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `TXCIE` reader - Transmit Complete Interrupt Enable"]
pub type TXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE` writer - Transmit Complete Interrupt Enable"]
pub type TXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXCIE` reader - Receive Complete Interrupt Enable"]
pub type RXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE` writer - Receive Complete Interrupt Enable"]
pub type RXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
pub fn rs485 (& self) -> RS485_R { RS485_R :: new (self . bits & 3) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
pub fn abeie (& self) -> ABEIE_R { ABEIE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
pub fn lbme (& self) -> LBME_R { LBME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
pub fn rxsie (& self) -> RXSIE_R { RXSIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dreie (& self) -> DREIE_R { DREIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie (& self) -> TXCIE_R { TXCIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie (& self) -> RXCIE_R { RXCIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
# [must_use]
pub fn rs485 (& mut self) -> RS485_W < 0 > { RS485_W :: new (self) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn abeie (& mut self) -> ABEIE_W < 2 > { ABEIE_W :: new (self) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
# [must_use]
pub fn lbme (& mut self) -> LBME_W < 3 > { LBME_W :: new (self) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxsie (& mut self) -> RXSIE_W < 4 > { RXSIE_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dreie (& mut self) -> DREIE_W < 5 > { DREIE_W :: new (self) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie (& mut self) -> TXCIE_W < 6 > { TXCIE_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie (& mut self) -> RXCIE_W < 7 > { RXCIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXMODE` reader - Receiver Mode"]
pub type RXMODE_R = crate :: FieldReader < u8 , RXMODE_A > ; # [doc = "Receiver Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXMODE_A { # [doc = "0: Normal mode"]
NORMAL = 0 , # [doc = "1: CLK2x mode"]
CLK2X = 1 , # [doc = "2: Generic autobaud mode"]
GENAUTO = 2 , # [doc = "3: LIN constrained autobaud mode"]
LINAUTO = 3 , } impl From < RXMODE_A > for u8 { # [inline (always)]
fn from (variant : RXMODE_A) -> Self { variant as _ } } impl RXMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXMODE_A { match self . bits { 0 => RXMODE_A :: NORMAL , 1 => RXMODE_A :: CLK2X , 2 => RXMODE_A :: GENAUTO , 3 => RXMODE_A :: LINAUTO , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == RXMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `CLK2X`"]
# [inline (always)]
pub fn is_clk2x (& self) -> bool { * self == RXMODE_A :: CLK2X } # [doc = "Checks if the value of the field is `GENAUTO`"]
# [inline (always)]
pub fn is_genauto (& self) -> bool { * self == RXMODE_A :: GENAUTO } # [doc = "Checks if the value of the field is `LINAUTO`"]
# [inline (always)]
pub fn is_linauto (& self) -> bool { * self == RXMODE_A :: LINAUTO } } # [doc = "Field `RXMODE` writer - Receiver Mode"]
pub type RXMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , RXMODE_A , 2 , O > ; impl < 'a , const O : u8 > RXMODE_W < 'a , O > { # [doc = "Normal mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (RXMODE_A :: NORMAL) } # [doc = "CLK2x mode"]
# [inline (always)]
pub fn clk2x (self) -> & 'a mut W { self . variant (RXMODE_A :: CLK2X) } # [doc = "Generic autobaud mode"]
# [inline (always)]
pub fn genauto (self) -> & 'a mut W { self . variant (RXMODE_A :: GENAUTO) } # [doc = "LIN constrained autobaud mode"]
# [inline (always)]
pub fn linauto (self) -> & 'a mut W { self . variant (RXMODE_A :: LINAUTO) } } # [doc = "Field `ODME` reader - Open Drain Mode Enable"]
pub type ODME_R = crate :: BitReader < bool > ; # [doc = "Field `ODME` writer - Open Drain Mode Enable"]
pub type ODME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `SFDEN` reader - Start Frame Detection Enable"]
pub type SFDEN_R = crate :: BitReader < bool > ; # [doc = "Field `SFDEN` writer - Start Frame Detection Enable"]
pub type SFDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Reciever enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Reciever enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
pub fn rxmode (& self) -> RXMODE_R { RXMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
pub fn odme (& self) -> ODME_R { ODME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
pub fn sfden (& self) -> SFDEN_R { SFDEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 0 > { MPCM_W :: new (self) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
# [must_use]
pub fn rxmode (& mut self) -> RXMODE_W < 1 > { RXMODE_W :: new (self) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
# [must_use]
pub fn odme (& mut self) -> ODME_W < 3 > { ODME_W :: new (self) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
# [must_use]
pub fn sfden (& mut self) -> SFDEN_W < 4 > { SFDEN_W :: new (self) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 6 > { TXEN_W :: new (self) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 7 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "6: Character size: 9 bit read low byte first"]
_9BITL = 6 , # [doc = "7: Character size: 9 bit read high byte first"]
_9BITH = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 6 => Some (CHSIZE_A :: _9BITL) , 7 => Some (CHSIZE_A :: _9BITH) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BITL`"]
# [inline (always)]
pub fn is_9bitl (& self) -> bool { * self == CHSIZE_A :: _9BITL } # [doc = "Checks if the value of the field is `_9BITH`"]
# [inline (always)]
pub fn is_9bith (& self) -> bool { * self == CHSIZE_A :: _9BITH } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit read low byte first"]
# [inline (always)]
pub fn _9bitl (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BITL) } # [doc = "Character size: 9 bit read high byte first"]
# [inline (always)]
pub fn _9bith (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BITH) } } # [doc = "Field `UCPHA` reader - SPI Host Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Host Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Host Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Host Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < SBMODE_A > ; # [doc = "Stop Bit Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SBMODE_A { # [doc = "0: 1 stop bit"]
_1BIT = 0 , # [doc = "1: 2 stop bits"]
_2BIT = 1 , } impl From < SBMODE_A > for bool { # [inline (always)]
fn from (variant : SBMODE_A) -> Self { variant as u8 != 0 } } impl SBMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SBMODE_A { match self . bits { false => SBMODE_A :: _1BIT , true => SBMODE_A :: _2BIT , } } # [doc = "Checks if the value of the field is `_1BIT`"]
# [inline (always)]
pub fn is_1bit (& self) -> bool { * self == SBMODE_A :: _1BIT } # [doc = "Checks if the value of the field is `_2BIT`"]
# [inline (always)]
pub fn is_2bit (& self) -> bool { * self == SBMODE_A :: _2BIT } } # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , SBMODE_A , O > ; impl < 'a , const O : u8 > SBMODE_W < 'a , O > { # [doc = "1 stop bit"]
# [inline (always)]
pub fn _1bit (self) -> & 'a mut W { self . variant (SBMODE_A :: _1BIT) } # [doc = "2 stop bits"]
# [inline (always)]
pub fn _2bit (self) -> & 'a mut W { self . variant (SBMODE_A :: _2BIT) } } # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: SPI Host Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRCOM , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (CMODE_A :: IRCOM) } # [doc = "SPI Host Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Host Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Host Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Host Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Host Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `IREI` reader - IrDA Event Input Enable"]
pub type IREI_R = crate :: BitReader < bool > ; # [doc = "Field `IREI` writer - IrDA Event Input Enable"]
pub type IREI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
pub fn irei (& self) -> IREI_R { IREI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn irei (& mut self) -> IREI_W < 0 > { IREI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAH (r) register accessor: an alias for `Reg<RXDATAH_SPEC>`"]
pub type RXDATAH = crate :: Reg < rxdatah :: RXDATAH_SPEC > ; # [doc = "Receive Data High Byte"]
pub mod rxdatah { # [doc = "Register `RXDATAH` reader"]
pub struct R (crate :: R < RXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA8` reader - Receiver Data Register"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Receiver Data Register"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Receive Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatah](index.html) module"]
pub struct RXDATAH_SPEC ; impl crate :: RegisterSpec for RXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatah::R](R) reader structure"]
impl crate :: Readable for RXDATAH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAH to value 0"]
impl crate :: Resettable for RXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAL (r) register accessor: an alias for `Reg<RXDATAL_SPEC>`"]
pub type RXDATAL = crate :: Reg < rxdatal :: RXDATAL_SPEC > ; # [doc = "Receive Data Low Byte"]
pub mod rxdatal { # [doc = "Register `RXDATAL` reader"]
pub struct R (crate :: R < RXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA` reader - RX Data"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - RX Data"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } # [doc = "Receive Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatal](index.html) module"]
pub struct RXDATAL_SPEC ; impl crate :: RegisterSpec for RXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatal::R](R) reader structure"]
impl crate :: Readable for RXDATAL_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAL to value 0"]
impl crate :: Resettable for RXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXPLCTRL (rw) register accessor: an alias for `Reg<RXPLCTRL_SPEC>`"]
pub type RXPLCTRL = crate :: Reg < rxplctrl :: RXPLCTRL_SPEC > ; # [doc = "IRCOM Receiver Pulse Length Control"]
pub mod rxplctrl { # [doc = "Register `RXPLCTRL` reader"]
pub struct R (crate :: R < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXPLCTRL` writer"]
pub struct W (crate :: W < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXPL` reader - Receiver Pulse Lenght"]
pub type RXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RXPL` writer - Receiver Pulse Lenght"]
pub type RXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , RXPLCTRL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
pub fn rxpl (& self) -> RXPL_R { RXPL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
# [must_use]
pub fn rxpl (& mut self) -> RXPL_W < 0 > { RXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "IRCOM Receiver Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxplctrl](index.html) module"]
pub struct RXPLCTRL_SPEC ; impl crate :: RegisterSpec for RXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxplctrl::R](R) reader structure"]
impl crate :: Readable for RXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxplctrl::W](W) writer structure"]
impl crate :: Writable for RXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXPLCTRL to value 0"]
impl crate :: Resettable for RXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WFB` reader - Wait For Break"]
pub type WFB_R = crate :: BitReader < bool > ; # [doc = "Field `WFB` writer - Wait For Break"]
pub type WFB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BDF` reader - Break Detected Flag"]
pub type BDF_R = crate :: BitReader < bool > ; # [doc = "Field `BDF` writer - Break Detected Flag"]
pub type BDF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `ISFIF` reader - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_R = crate :: BitReader < bool > ; # [doc = "Field `ISFIF` writer - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXSIF` reader - Receive Start Interrupt"]
pub type RXSIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
pub fn wfb (& self) -> WFB_R { WFB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
pub fn bdf (& self) -> BDF_R { BDF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
pub fn isfif (& self) -> ISFIF_R { ISFIF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receive Start Interrupt"]
# [inline (always)]
pub fn rxsif (& self) -> RXSIF_R { RXSIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
# [must_use]
pub fn wfb (& mut self) -> WFB_W < 0 > { WFB_W :: new (self) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
# [must_use]
pub fn bdf (& mut self) -> BDF_W < 1 > { BDF_W :: new (self) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn isfif (& mut self) -> ISFIF_W < 3 > { ISFIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAH (rw) register accessor: an alias for `Reg<TXDATAH_SPEC>`"]
pub type TXDATAH = crate :: Reg < txdatah :: TXDATAH_SPEC > ; # [doc = "Transmit Data High Byte"]
pub mod txdatah { # [doc = "Register `TXDATAH` reader"]
pub struct R (crate :: R < TXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAH` writer"]
pub struct W (crate :: W < TXDATAH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAH_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA8` reader - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `DATA8` writer - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TXDATAH_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
# [must_use]
pub fn data8 (& mut self) -> DATA8_W < 0 > { DATA8_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transmit Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatah](index.html) module"]
pub struct TXDATAH_SPEC ; impl crate :: RegisterSpec for TXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatah::R](R) reader structure"]
impl crate :: Readable for TXDATAH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatah::W](W) writer structure"]
impl crate :: Writable for TXDATAH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAH to value 0"]
impl crate :: Resettable for TXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAL (rw) register accessor: an alias for `Reg<TXDATAL_SPEC>`"]
pub type TXDATAL = crate :: Reg < txdatal :: TXDATAL_SPEC > ; # [doc = "Transmit Data Low Byte"]
pub mod txdatal { # [doc = "Register `TXDATAL` reader"]
pub struct R (crate :: R < TXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAL` writer"]
pub struct W (crate :: W < TXDATAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Transmit Data Register"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DATA` writer - Transmit Data Register"]
pub type DATA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXDATAL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
# [must_use]
pub fn data (& mut self) -> DATA_W < 0 > { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transmit Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatal](index.html) module"]
pub struct TXDATAL_SPEC ; impl crate :: RegisterSpec for TXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatal::R](R) reader structure"]
impl crate :: Readable for TXDATAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatal::W](W) writer structure"]
impl crate :: Writable for TXDATAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAL to value 0"]
impl crate :: Resettable for TXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXPLCTRL (rw) register accessor: an alias for `Reg<TXPLCTRL_SPEC>`"]
pub type TXPLCTRL = crate :: Reg < txplctrl :: TXPLCTRL_SPEC > ; # [doc = "IRCOM Transmitter Pulse Length Control"]
pub mod txplctrl { # [doc = "Register `TXPLCTRL` reader"]
pub struct R (crate :: R < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXPLCTRL` writer"]
pub struct W (crate :: W < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXPL` reader - Transmit pulse length"]
pub type TXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TXPL` writer - Transmit pulse length"]
pub type TXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXPLCTRL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
pub fn txpl (& self) -> TXPL_R { TXPL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
# [must_use]
pub fn txpl (& mut self) -> TXPL_W < 0 > { TXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "IRCOM Transmitter Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txplctrl](index.html) module"]
pub struct TXPLCTRL_SPEC ; impl crate :: RegisterSpec for TXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txplctrl::R](R) reader structure"]
impl crate :: Readable for TXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txplctrl::W](W) writer structure"]
impl crate :: Writable for TXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXPLCTRL to value 0"]
impl crate :: Resettable for TXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "User Row"]
pub struct USERROW { _marker : PhantomData < * const () > } unsafe impl Send for USERROW { } impl USERROW { # [doc = r"Pointer to the register block"]
pub const PTR : * const userrow :: RegisterBlock = 0x1300 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const userrow :: RegisterBlock { Self :: PTR } } impl Deref for USERROW { type Target = userrow :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USERROW { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USERROW") . finish () } } # [doc = "User Row"]
pub mod userrow { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - User Row Byte 0"]
pub userrow0 : USERROW0 , # [doc = "0x01 - User Row Byte 1"]
pub userrow1 : USERROW1 , # [doc = "0x02 - User Row Byte 2"]
pub userrow2 : USERROW2 , # [doc = "0x03 - User Row Byte 3"]
pub userrow3 : USERROW3 , # [doc = "0x04 - User Row Byte 4"]
pub userrow4 : USERROW4 , # [doc = "0x05 - User Row Byte 5"]
pub userrow5 : USERROW5 , # [doc = "0x06 - User Row Byte 6"]
pub userrow6 : USERROW6 , # [doc = "0x07 - User Row Byte 7"]
pub userrow7 : USERROW7 , # [doc = "0x08 - User Row Byte 8"]
pub userrow8 : USERROW8 , # [doc = "0x09 - User Row Byte 9"]
pub userrow9 : USERROW9 , # [doc = "0x0a - User Row Byte 10"]
pub userrow10 : USERROW10 , # [doc = "0x0b - User Row Byte 11"]
pub userrow11 : USERROW11 , # [doc = "0x0c - User Row Byte 12"]
pub userrow12 : USERROW12 , # [doc = "0x0d - User Row Byte 13"]
pub userrow13 : USERROW13 , # [doc = "0x0e - User Row Byte 14"]
pub userrow14 : USERROW14 , # [doc = "0x0f - User Row Byte 15"]
pub userrow15 : USERROW15 , # [doc = "0x10 - User Row Byte 16"]
pub userrow16 : USERROW16 , # [doc = "0x11 - User Row Byte 17"]
pub userrow17 : USERROW17 , # [doc = "0x12 - User Row Byte 18"]
pub userrow18 : USERROW18 , # [doc = "0x13 - User Row Byte 19"]
pub userrow19 : USERROW19 , # [doc = "0x14 - User Row Byte 20"]
pub userrow20 : USERROW20 , # [doc = "0x15 - User Row Byte 21"]
pub userrow21 : USERROW21 , # [doc = "0x16 - User Row Byte 22"]
pub userrow22 : USERROW22 , # [doc = "0x17 - User Row Byte 23"]
pub userrow23 : USERROW23 , # [doc = "0x18 - User Row Byte 24"]
pub userrow24 : USERROW24 , # [doc = "0x19 - User Row Byte 25"]
pub userrow25 : USERROW25 , # [doc = "0x1a - User Row Byte 26"]
pub userrow26 : USERROW26 , # [doc = "0x1b - User Row Byte 27"]
pub userrow27 : USERROW27 , # [doc = "0x1c - User Row Byte 28"]
pub userrow28 : USERROW28 , # [doc = "0x1d - User Row Byte 29"]
pub userrow29 : USERROW29 , # [doc = "0x1e - User Row Byte 30"]
pub userrow30 : USERROW30 , # [doc = "0x1f - User Row Byte 31"]
pub userrow31 : USERROW31 , } # [doc = "USERROW0 (rw) register accessor: an alias for `Reg<USERROW0_SPEC>`"]
pub type USERROW0 = crate :: Reg < userrow0 :: USERROW0_SPEC > ; # [doc = "User Row Byte 0"]
pub mod userrow0 { # [doc = "Register `USERROW0` reader"]
pub struct R (crate :: R < USERROW0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW0_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW0` writer"]
pub struct W (crate :: W < USERROW0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow0](index.html) module"]
pub struct USERROW0_SPEC ; impl crate :: RegisterSpec for USERROW0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow0::R](R) reader structure"]
impl crate :: Readable for USERROW0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow0::W](W) writer structure"]
impl crate :: Writable for USERROW0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW0 to value 0"]
impl crate :: Resettable for USERROW0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW1 (rw) register accessor: an alias for `Reg<USERROW1_SPEC>`"]
pub type USERROW1 = crate :: Reg < userrow1 :: USERROW1_SPEC > ; # [doc = "User Row Byte 1"]
pub mod userrow1 { # [doc = "Register `USERROW1` reader"]
pub struct R (crate :: R < USERROW1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW1_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW1` writer"]
pub struct W (crate :: W < USERROW1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow1](index.html) module"]
pub struct USERROW1_SPEC ; impl crate :: RegisterSpec for USERROW1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow1::R](R) reader structure"]
impl crate :: Readable for USERROW1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow1::W](W) writer structure"]
impl crate :: Writable for USERROW1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW1 to value 0"]
impl crate :: Resettable for USERROW1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW10 (rw) register accessor: an alias for `Reg<USERROW10_SPEC>`"]
pub type USERROW10 = crate :: Reg < userrow10 :: USERROW10_SPEC > ; # [doc = "User Row Byte 10"]
pub mod userrow10 { # [doc = "Register `USERROW10` reader"]
pub struct R (crate :: R < USERROW10_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW10_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW10_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW10_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW10` writer"]
pub struct W (crate :: W < USERROW10_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW10_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW10_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW10_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 10\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow10](index.html) module"]
pub struct USERROW10_SPEC ; impl crate :: RegisterSpec for USERROW10_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow10::R](R) reader structure"]
impl crate :: Readable for USERROW10_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow10::W](W) writer structure"]
impl crate :: Writable for USERROW10_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW10 to value 0"]
impl crate :: Resettable for USERROW10_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW11 (rw) register accessor: an alias for `Reg<USERROW11_SPEC>`"]
pub type USERROW11 = crate :: Reg < userrow11 :: USERROW11_SPEC > ; # [doc = "User Row Byte 11"]
pub mod userrow11 { # [doc = "Register `USERROW11` reader"]
pub struct R (crate :: R < USERROW11_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW11_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW11_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW11_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW11` writer"]
pub struct W (crate :: W < USERROW11_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW11_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW11_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW11_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 11\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow11](index.html) module"]
pub struct USERROW11_SPEC ; impl crate :: RegisterSpec for USERROW11_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow11::R](R) reader structure"]
impl crate :: Readable for USERROW11_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow11::W](W) writer structure"]
impl crate :: Writable for USERROW11_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW11 to value 0"]
impl crate :: Resettable for USERROW11_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW12 (rw) register accessor: an alias for `Reg<USERROW12_SPEC>`"]
pub type USERROW12 = crate :: Reg < userrow12 :: USERROW12_SPEC > ; # [doc = "User Row Byte 12"]
pub mod userrow12 { # [doc = "Register `USERROW12` reader"]
pub struct R (crate :: R < USERROW12_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW12_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW12_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW12_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW12` writer"]
pub struct W (crate :: W < USERROW12_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW12_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW12_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW12_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 12\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow12](index.html) module"]
pub struct USERROW12_SPEC ; impl crate :: RegisterSpec for USERROW12_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow12::R](R) reader structure"]
impl crate :: Readable for USERROW12_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow12::W](W) writer structure"]
impl crate :: Writable for USERROW12_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW12 to value 0"]
impl crate :: Resettable for USERROW12_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW13 (rw) register accessor: an alias for `Reg<USERROW13_SPEC>`"]
pub type USERROW13 = crate :: Reg < userrow13 :: USERROW13_SPEC > ; # [doc = "User Row Byte 13"]
pub mod userrow13 { # [doc = "Register `USERROW13` reader"]
pub struct R (crate :: R < USERROW13_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW13_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW13_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW13_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW13` writer"]
pub struct W (crate :: W < USERROW13_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW13_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW13_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW13_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 13\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow13](index.html) module"]
pub struct USERROW13_SPEC ; impl crate :: RegisterSpec for USERROW13_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow13::R](R) reader structure"]
impl crate :: Readable for USERROW13_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow13::W](W) writer structure"]
impl crate :: Writable for USERROW13_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW13 to value 0"]
impl crate :: Resettable for USERROW13_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW14 (rw) register accessor: an alias for `Reg<USERROW14_SPEC>`"]
pub type USERROW14 = crate :: Reg < userrow14 :: USERROW14_SPEC > ; # [doc = "User Row Byte 14"]
pub mod userrow14 { # [doc = "Register `USERROW14` reader"]
pub struct R (crate :: R < USERROW14_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW14_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW14_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW14_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW14` writer"]
pub struct W (crate :: W < USERROW14_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW14_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW14_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW14_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 14\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow14](index.html) module"]
pub struct USERROW14_SPEC ; impl crate :: RegisterSpec for USERROW14_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow14::R](R) reader structure"]
impl crate :: Readable for USERROW14_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow14::W](W) writer structure"]
impl crate :: Writable for USERROW14_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW14 to value 0"]
impl crate :: Resettable for USERROW14_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW15 (rw) register accessor: an alias for `Reg<USERROW15_SPEC>`"]
pub type USERROW15 = crate :: Reg < userrow15 :: USERROW15_SPEC > ; # [doc = "User Row Byte 15"]
pub mod userrow15 { # [doc = "Register `USERROW15` reader"]
pub struct R (crate :: R < USERROW15_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW15_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW15_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW15_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW15` writer"]
pub struct W (crate :: W < USERROW15_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW15_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW15_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW15_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 15\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow15](index.html) module"]
pub struct USERROW15_SPEC ; impl crate :: RegisterSpec for USERROW15_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow15::R](R) reader structure"]
impl crate :: Readable for USERROW15_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow15::W](W) writer structure"]
impl crate :: Writable for USERROW15_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW15 to value 0"]
impl crate :: Resettable for USERROW15_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW16 (rw) register accessor: an alias for `Reg<USERROW16_SPEC>`"]
pub type USERROW16 = crate :: Reg < userrow16 :: USERROW16_SPEC > ; # [doc = "User Row Byte 16"]
pub mod userrow16 { # [doc = "Register `USERROW16` reader"]
pub struct R (crate :: R < USERROW16_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW16_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW16_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW16_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW16` writer"]
pub struct W (crate :: W < USERROW16_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW16_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW16_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW16_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 16\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow16](index.html) module"]
pub struct USERROW16_SPEC ; impl crate :: RegisterSpec for USERROW16_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow16::R](R) reader structure"]
impl crate :: Readable for USERROW16_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow16::W](W) writer structure"]
impl crate :: Writable for USERROW16_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW16 to value 0"]
impl crate :: Resettable for USERROW16_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW17 (rw) register accessor: an alias for `Reg<USERROW17_SPEC>`"]
pub type USERROW17 = crate :: Reg < userrow17 :: USERROW17_SPEC > ; # [doc = "User Row Byte 17"]
pub mod userrow17 { # [doc = "Register `USERROW17` reader"]
pub struct R (crate :: R < USERROW17_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW17_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW17_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW17_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW17` writer"]
pub struct W (crate :: W < USERROW17_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW17_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW17_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW17_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 17\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow17](index.html) module"]
pub struct USERROW17_SPEC ; impl crate :: RegisterSpec for USERROW17_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow17::R](R) reader structure"]
impl crate :: Readable for USERROW17_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow17::W](W) writer structure"]
impl crate :: Writable for USERROW17_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW17 to value 0"]
impl crate :: Resettable for USERROW17_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW18 (rw) register accessor: an alias for `Reg<USERROW18_SPEC>`"]
pub type USERROW18 = crate :: Reg < userrow18 :: USERROW18_SPEC > ; # [doc = "User Row Byte 18"]
pub mod userrow18 { # [doc = "Register `USERROW18` reader"]
pub struct R (crate :: R < USERROW18_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW18_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW18_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW18_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW18` writer"]
pub struct W (crate :: W < USERROW18_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW18_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW18_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW18_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 18\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow18](index.html) module"]
pub struct USERROW18_SPEC ; impl crate :: RegisterSpec for USERROW18_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow18::R](R) reader structure"]
impl crate :: Readable for USERROW18_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow18::W](W) writer structure"]
impl crate :: Writable for USERROW18_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW18 to value 0"]
impl crate :: Resettable for USERROW18_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW19 (rw) register accessor: an alias for `Reg<USERROW19_SPEC>`"]
pub type USERROW19 = crate :: Reg < userrow19 :: USERROW19_SPEC > ; # [doc = "User Row Byte 19"]
pub mod userrow19 { # [doc = "Register `USERROW19` reader"]
pub struct R (crate :: R < USERROW19_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW19_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW19_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW19_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW19` writer"]
pub struct W (crate :: W < USERROW19_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW19_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW19_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW19_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 19\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow19](index.html) module"]
pub struct USERROW19_SPEC ; impl crate :: RegisterSpec for USERROW19_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow19::R](R) reader structure"]
impl crate :: Readable for USERROW19_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow19::W](W) writer structure"]
impl crate :: Writable for USERROW19_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW19 to value 0"]
impl crate :: Resettable for USERROW19_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW2 (rw) register accessor: an alias for `Reg<USERROW2_SPEC>`"]
pub type USERROW2 = crate :: Reg < userrow2 :: USERROW2_SPEC > ; # [doc = "User Row Byte 2"]
pub mod userrow2 { # [doc = "Register `USERROW2` reader"]
pub struct R (crate :: R < USERROW2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW2_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW2` writer"]
pub struct W (crate :: W < USERROW2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow2](index.html) module"]
pub struct USERROW2_SPEC ; impl crate :: RegisterSpec for USERROW2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow2::R](R) reader structure"]
impl crate :: Readable for USERROW2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow2::W](W) writer structure"]
impl crate :: Writable for USERROW2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW2 to value 0"]
impl crate :: Resettable for USERROW2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW20 (rw) register accessor: an alias for `Reg<USERROW20_SPEC>`"]
pub type USERROW20 = crate :: Reg < userrow20 :: USERROW20_SPEC > ; # [doc = "User Row Byte 20"]
pub mod userrow20 { # [doc = "Register `USERROW20` reader"]
pub struct R (crate :: R < USERROW20_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW20_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW20_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW20_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW20` writer"]
pub struct W (crate :: W < USERROW20_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW20_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW20_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW20_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 20\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow20](index.html) module"]
pub struct USERROW20_SPEC ; impl crate :: RegisterSpec for USERROW20_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow20::R](R) reader structure"]
impl crate :: Readable for USERROW20_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow20::W](W) writer structure"]
impl crate :: Writable for USERROW20_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW20 to value 0"]
impl crate :: Resettable for USERROW20_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW21 (rw) register accessor: an alias for `Reg<USERROW21_SPEC>`"]
pub type USERROW21 = crate :: Reg < userrow21 :: USERROW21_SPEC > ; # [doc = "User Row Byte 21"]
pub mod userrow21 { # [doc = "Register `USERROW21` reader"]
pub struct R (crate :: R < USERROW21_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW21_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW21_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW21_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW21` writer"]
pub struct W (crate :: W < USERROW21_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW21_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW21_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW21_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 21\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow21](index.html) module"]
pub struct USERROW21_SPEC ; impl crate :: RegisterSpec for USERROW21_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow21::R](R) reader structure"]
impl crate :: Readable for USERROW21_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow21::W](W) writer structure"]
impl crate :: Writable for USERROW21_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW21 to value 0"]
impl crate :: Resettable for USERROW21_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW22 (rw) register accessor: an alias for `Reg<USERROW22_SPEC>`"]
pub type USERROW22 = crate :: Reg < userrow22 :: USERROW22_SPEC > ; # [doc = "User Row Byte 22"]
pub mod userrow22 { # [doc = "Register `USERROW22` reader"]
pub struct R (crate :: R < USERROW22_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW22_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW22_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW22_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW22` writer"]
pub struct W (crate :: W < USERROW22_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW22_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW22_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW22_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 22\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow22](index.html) module"]
pub struct USERROW22_SPEC ; impl crate :: RegisterSpec for USERROW22_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow22::R](R) reader structure"]
impl crate :: Readable for USERROW22_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow22::W](W) writer structure"]
impl crate :: Writable for USERROW22_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW22 to value 0"]
impl crate :: Resettable for USERROW22_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW23 (rw) register accessor: an alias for `Reg<USERROW23_SPEC>`"]
pub type USERROW23 = crate :: Reg < userrow23 :: USERROW23_SPEC > ; # [doc = "User Row Byte 23"]
pub mod userrow23 { # [doc = "Register `USERROW23` reader"]
pub struct R (crate :: R < USERROW23_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW23_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW23_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW23_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW23` writer"]
pub struct W (crate :: W < USERROW23_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW23_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW23_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW23_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 23\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow23](index.html) module"]
pub struct USERROW23_SPEC ; impl crate :: RegisterSpec for USERROW23_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow23::R](R) reader structure"]
impl crate :: Readable for USERROW23_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow23::W](W) writer structure"]
impl crate :: Writable for USERROW23_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW23 to value 0"]
impl crate :: Resettable for USERROW23_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW24 (rw) register accessor: an alias for `Reg<USERROW24_SPEC>`"]
pub type USERROW24 = crate :: Reg < userrow24 :: USERROW24_SPEC > ; # [doc = "User Row Byte 24"]
pub mod userrow24 { # [doc = "Register `USERROW24` reader"]
pub struct R (crate :: R < USERROW24_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW24_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW24_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW24_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW24` writer"]
pub struct W (crate :: W < USERROW24_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW24_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW24_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW24_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 24\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow24](index.html) module"]
pub struct USERROW24_SPEC ; impl crate :: RegisterSpec for USERROW24_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow24::R](R) reader structure"]
impl crate :: Readable for USERROW24_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow24::W](W) writer structure"]
impl crate :: Writable for USERROW24_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW24 to value 0"]
impl crate :: Resettable for USERROW24_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW25 (rw) register accessor: an alias for `Reg<USERROW25_SPEC>`"]
pub type USERROW25 = crate :: Reg < userrow25 :: USERROW25_SPEC > ; # [doc = "User Row Byte 25"]
pub mod userrow25 { # [doc = "Register `USERROW25` reader"]
pub struct R (crate :: R < USERROW25_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW25_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW25_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW25_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW25` writer"]
pub struct W (crate :: W < USERROW25_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW25_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW25_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW25_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 25\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow25](index.html) module"]
pub struct USERROW25_SPEC ; impl crate :: RegisterSpec for USERROW25_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow25::R](R) reader structure"]
impl crate :: Readable for USERROW25_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow25::W](W) writer structure"]
impl crate :: Writable for USERROW25_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW25 to value 0"]
impl crate :: Resettable for USERROW25_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW26 (rw) register accessor: an alias for `Reg<USERROW26_SPEC>`"]
pub type USERROW26 = crate :: Reg < userrow26 :: USERROW26_SPEC > ; # [doc = "User Row Byte 26"]
pub mod userrow26 { # [doc = "Register `USERROW26` reader"]
pub struct R (crate :: R < USERROW26_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW26_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW26_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW26_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW26` writer"]
pub struct W (crate :: W < USERROW26_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW26_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW26_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW26_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 26\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow26](index.html) module"]
pub struct USERROW26_SPEC ; impl crate :: RegisterSpec for USERROW26_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow26::R](R) reader structure"]
impl crate :: Readable for USERROW26_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow26::W](W) writer structure"]
impl crate :: Writable for USERROW26_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW26 to value 0"]
impl crate :: Resettable for USERROW26_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW27 (rw) register accessor: an alias for `Reg<USERROW27_SPEC>`"]
pub type USERROW27 = crate :: Reg < userrow27 :: USERROW27_SPEC > ; # [doc = "User Row Byte 27"]
pub mod userrow27 { # [doc = "Register `USERROW27` reader"]
pub struct R (crate :: R < USERROW27_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW27_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW27_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW27_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW27` writer"]
pub struct W (crate :: W < USERROW27_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW27_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW27_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW27_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 27\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow27](index.html) module"]
pub struct USERROW27_SPEC ; impl crate :: RegisterSpec for USERROW27_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow27::R](R) reader structure"]
impl crate :: Readable for USERROW27_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow27::W](W) writer structure"]
impl crate :: Writable for USERROW27_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW27 to value 0"]
impl crate :: Resettable for USERROW27_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW28 (rw) register accessor: an alias for `Reg<USERROW28_SPEC>`"]
pub type USERROW28 = crate :: Reg < userrow28 :: USERROW28_SPEC > ; # [doc = "User Row Byte 28"]
pub mod userrow28 { # [doc = "Register `USERROW28` reader"]
pub struct R (crate :: R < USERROW28_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW28_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW28_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW28_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW28` writer"]
pub struct W (crate :: W < USERROW28_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW28_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW28_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW28_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 28\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow28](index.html) module"]
pub struct USERROW28_SPEC ; impl crate :: RegisterSpec for USERROW28_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow28::R](R) reader structure"]
impl crate :: Readable for USERROW28_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow28::W](W) writer structure"]
impl crate :: Writable for USERROW28_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW28 to value 0"]
impl crate :: Resettable for USERROW28_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW29 (rw) register accessor: an alias for `Reg<USERROW29_SPEC>`"]
pub type USERROW29 = crate :: Reg < userrow29 :: USERROW29_SPEC > ; # [doc = "User Row Byte 29"]
pub mod userrow29 { # [doc = "Register `USERROW29` reader"]
pub struct R (crate :: R < USERROW29_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW29_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW29_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW29_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW29` writer"]
pub struct W (crate :: W < USERROW29_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW29_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW29_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW29_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 29\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow29](index.html) module"]
pub struct USERROW29_SPEC ; impl crate :: RegisterSpec for USERROW29_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow29::R](R) reader structure"]
impl crate :: Readable for USERROW29_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow29::W](W) writer structure"]
impl crate :: Writable for USERROW29_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW29 to value 0"]
impl crate :: Resettable for USERROW29_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW3 (rw) register accessor: an alias for `Reg<USERROW3_SPEC>`"]
pub type USERROW3 = crate :: Reg < userrow3 :: USERROW3_SPEC > ; # [doc = "User Row Byte 3"]
pub mod userrow3 { # [doc = "Register `USERROW3` reader"]
pub struct R (crate :: R < USERROW3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW3_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW3` writer"]
pub struct W (crate :: W < USERROW3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow3](index.html) module"]
pub struct USERROW3_SPEC ; impl crate :: RegisterSpec for USERROW3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow3::R](R) reader structure"]
impl crate :: Readable for USERROW3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow3::W](W) writer structure"]
impl crate :: Writable for USERROW3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW3 to value 0"]
impl crate :: Resettable for USERROW3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW30 (rw) register accessor: an alias for `Reg<USERROW30_SPEC>`"]
pub type USERROW30 = crate :: Reg < userrow30 :: USERROW30_SPEC > ; # [doc = "User Row Byte 30"]
pub mod userrow30 { # [doc = "Register `USERROW30` reader"]
pub struct R (crate :: R < USERROW30_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW30_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW30_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW30_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW30` writer"]
pub struct W (crate :: W < USERROW30_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW30_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW30_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW30_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 30\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow30](index.html) module"]
pub struct USERROW30_SPEC ; impl crate :: RegisterSpec for USERROW30_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow30::R](R) reader structure"]
impl crate :: Readable for USERROW30_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow30::W](W) writer structure"]
impl crate :: Writable for USERROW30_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW30 to value 0"]
impl crate :: Resettable for USERROW30_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW31 (rw) register accessor: an alias for `Reg<USERROW31_SPEC>`"]
pub type USERROW31 = crate :: Reg < userrow31 :: USERROW31_SPEC > ; # [doc = "User Row Byte 31"]
pub mod userrow31 { # [doc = "Register `USERROW31` reader"]
pub struct R (crate :: R < USERROW31_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW31_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW31_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW31_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW31` writer"]
pub struct W (crate :: W < USERROW31_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW31_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW31_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW31_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 31\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow31](index.html) module"]
pub struct USERROW31_SPEC ; impl crate :: RegisterSpec for USERROW31_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow31::R](R) reader structure"]
impl crate :: Readable for USERROW31_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow31::W](W) writer structure"]
impl crate :: Writable for USERROW31_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW31 to value 0"]
impl crate :: Resettable for USERROW31_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW4 (rw) register accessor: an alias for `Reg<USERROW4_SPEC>`"]
pub type USERROW4 = crate :: Reg < userrow4 :: USERROW4_SPEC > ; # [doc = "User Row Byte 4"]
pub mod userrow4 { # [doc = "Register `USERROW4` reader"]
pub struct R (crate :: R < USERROW4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW4_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW4` writer"]
pub struct W (crate :: W < USERROW4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW4_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow4](index.html) module"]
pub struct USERROW4_SPEC ; impl crate :: RegisterSpec for USERROW4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow4::R](R) reader structure"]
impl crate :: Readable for USERROW4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow4::W](W) writer structure"]
impl crate :: Writable for USERROW4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW4 to value 0"]
impl crate :: Resettable for USERROW4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW5 (rw) register accessor: an alias for `Reg<USERROW5_SPEC>`"]
pub type USERROW5 = crate :: Reg < userrow5 :: USERROW5_SPEC > ; # [doc = "User Row Byte 5"]
pub mod userrow5 { # [doc = "Register `USERROW5` reader"]
pub struct R (crate :: R < USERROW5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW5_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW5` writer"]
pub struct W (crate :: W < USERROW5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW5_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow5](index.html) module"]
pub struct USERROW5_SPEC ; impl crate :: RegisterSpec for USERROW5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow5::R](R) reader structure"]
impl crate :: Readable for USERROW5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow5::W](W) writer structure"]
impl crate :: Writable for USERROW5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW5 to value 0"]
impl crate :: Resettable for USERROW5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW6 (rw) register accessor: an alias for `Reg<USERROW6_SPEC>`"]
pub type USERROW6 = crate :: Reg < userrow6 :: USERROW6_SPEC > ; # [doc = "User Row Byte 6"]
pub mod userrow6 { # [doc = "Register `USERROW6` reader"]
pub struct R (crate :: R < USERROW6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW6_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW6` writer"]
pub struct W (crate :: W < USERROW6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW6_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow6](index.html) module"]
pub struct USERROW6_SPEC ; impl crate :: RegisterSpec for USERROW6_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow6::R](R) reader structure"]
impl crate :: Readable for USERROW6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow6::W](W) writer structure"]
impl crate :: Writable for USERROW6_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW6 to value 0"]
impl crate :: Resettable for USERROW6_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW7 (rw) register accessor: an alias for `Reg<USERROW7_SPEC>`"]
pub type USERROW7 = crate :: Reg < userrow7 :: USERROW7_SPEC > ; # [doc = "User Row Byte 7"]
pub mod userrow7 { # [doc = "Register `USERROW7` reader"]
pub struct R (crate :: R < USERROW7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW7_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW7` writer"]
pub struct W (crate :: W < USERROW7_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW7_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW7_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 7\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow7](index.html) module"]
pub struct USERROW7_SPEC ; impl crate :: RegisterSpec for USERROW7_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow7::R](R) reader structure"]
impl crate :: Readable for USERROW7_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow7::W](W) writer structure"]
impl crate :: Writable for USERROW7_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW7 to value 0"]
impl crate :: Resettable for USERROW7_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW8 (rw) register accessor: an alias for `Reg<USERROW8_SPEC>`"]
pub type USERROW8 = crate :: Reg < userrow8 :: USERROW8_SPEC > ; # [doc = "User Row Byte 8"]
pub mod userrow8 { # [doc = "Register `USERROW8` reader"]
pub struct R (crate :: R < USERROW8_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW8_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW8_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW8` writer"]
pub struct W (crate :: W < USERROW8_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW8_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW8_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 8\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow8](index.html) module"]
pub struct USERROW8_SPEC ; impl crate :: RegisterSpec for USERROW8_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow8::R](R) reader structure"]
impl crate :: Readable for USERROW8_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow8::W](W) writer structure"]
impl crate :: Writable for USERROW8_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW8 to value 0"]
impl crate :: Resettable for USERROW8_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW9 (rw) register accessor: an alias for `Reg<USERROW9_SPEC>`"]
pub type USERROW9 = crate :: Reg < userrow9 :: USERROW9_SPEC > ; # [doc = "User Row Byte 9"]
pub mod userrow9 { # [doc = "Register `USERROW9` reader"]
pub struct R (crate :: R < USERROW9_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW9_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW9_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW9` writer"]
pub struct W (crate :: W < USERROW9_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW9_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW9_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 9\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow9](index.html) module"]
pub struct USERROW9_SPEC ; impl crate :: RegisterSpec for USERROW9_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow9::R](R) reader structure"]
impl crate :: Readable for USERROW9_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow9::W](W) writer structure"]
impl crate :: Writable for USERROW9_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW9 to value 0"]
impl crate :: Resettable for USERROW9_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTA { _marker : PhantomData < * const () > } unsafe impl Send for VPORTA { } impl VPORTA { # [doc = r"Pointer to the register block"]
pub const PTR : * const vporta :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vporta :: RegisterBlock { Self :: PTR } } impl Deref for VPORTA { type Target = vporta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTA") . finish () } } # [doc = "Virtual Ports"]
pub mod vporta { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTB { _marker : PhantomData < * const () > } unsafe impl Send for VPORTB { } impl VPORTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const vportb :: RegisterBlock = 0x04 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vportb :: RegisterBlock { Self :: PTR } } impl Deref for VPORTB { type Target = vportb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTB") . finish () } } # [doc = "Virtual Ports"]
pub mod vportb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTC { _marker : PhantomData < * const () > } unsafe impl Send for VPORTC { } impl VPORTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const vportc :: RegisterBlock = 0x08 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vportc :: RegisterBlock { Self :: PTR } } impl Deref for VPORTC { type Target = vportc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTC") . finish () } } # [doc = "Virtual Ports"]
pub mod vportc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Voltage reference"]
pub struct VREF { _marker : PhantomData < * const () > } unsafe impl Send for VREF { } impl VREF { # [doc = r"Pointer to the register block"]
pub const PTR : * const vref :: RegisterBlock = 0xa0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vref :: RegisterBlock { Self :: PTR } } impl Deref for VREF { type Target = vref :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VREF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VREF") . finish () } } # [doc = "Voltage reference"]
pub mod vref { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DAC0REFSEL` reader - DAC0/AC0 reference select"]
pub type DAC0REFSEL_R = crate :: FieldReader < u8 , DAC0REFSEL_A > ; # [doc = "DAC0/AC0 reference select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DAC0REFSEL_A { # [doc = "0: Voltage reference at 0.55V"]
_0V55 = 0 , # [doc = "1: Voltage reference at 1.1V"]
_1V1 = 1 , # [doc = "2: Voltage reference at 2.5V"]
_2V5 = 2 , # [doc = "3: Voltage reference at 4.34V"]
_4V34 = 3 , # [doc = "4: Voltage reference at 1.5V"]
_1V5 = 4 , } impl From < DAC0REFSEL_A > for u8 { # [inline (always)]
fn from (variant : DAC0REFSEL_A) -> Self { variant as _ } } impl DAC0REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < DAC0REFSEL_A > { match self . bits { 0 => Some (DAC0REFSEL_A :: _0V55) , 1 => Some (DAC0REFSEL_A :: _1V1) , 2 => Some (DAC0REFSEL_A :: _2V5) , 3 => Some (DAC0REFSEL_A :: _4V34) , 4 => Some (DAC0REFSEL_A :: _1V5) , _ => None , } } # [doc = "Checks if the value of the field is `_0V55`"]
# [inline (always)]
pub fn is_0v55 (& self) -> bool { * self == DAC0REFSEL_A :: _0V55 } # [doc = "Checks if the value of the field is `_1V1`"]
# [inline (always)]
pub fn is_1v1 (& self) -> bool { * self == DAC0REFSEL_A :: _1V1 } # [doc = "Checks if the value of the field is `_2V5`"]
# [inline (always)]
pub fn is_2v5 (& self) -> bool { * self == DAC0REFSEL_A :: _2V5 } # [doc = "Checks if the value of the field is `_4V34`"]
# [inline (always)]
pub fn is_4v34 (& self) -> bool { * self == DAC0REFSEL_A :: _4V34 } # [doc = "Checks if the value of the field is `_1V5`"]
# [inline (always)]
pub fn is_1v5 (& self) -> bool { * self == DAC0REFSEL_A :: _1V5 } } # [doc = "Field `DAC0REFSEL` writer - DAC0/AC0 reference select"]
pub type DAC0REFSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , DAC0REFSEL_A , 3 , O > ; impl < 'a , const O : u8 > DAC0REFSEL_W < 'a , O > { # [doc = "Voltage reference at 0.55V"]
# [inline (always)]
pub fn _0v55 (self) -> & 'a mut W { self . variant (DAC0REFSEL_A :: _0V55) } # [doc = "Voltage reference at 1.1V"]
# [inline (always)]
pub fn _1v1 (self) -> & 'a mut W { self . variant (DAC0REFSEL_A :: _1V1) } # [doc = "Voltage reference at 2.5V"]
# [inline (always)]
pub fn _2v5 (self) -> & 'a mut W { self . variant (DAC0REFSEL_A :: _2V5) } # [doc = "Voltage reference at 4.34V"]
# [inline (always)]
pub fn _4v34 (self) -> & 'a mut W { self . variant (DAC0REFSEL_A :: _4V34) } # [doc = "Voltage reference at 1.5V"]
# [inline (always)]
pub fn _1v5 (self) -> & 'a mut W { self . variant (DAC0REFSEL_A :: _1V5) } } # [doc = "Field `ADC0REFSEL` reader - ADC0 reference select"]
pub type ADC0REFSEL_R = crate :: FieldReader < u8 , ADC0REFSEL_A > ; # [doc = "ADC0 reference select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ADC0REFSEL_A { # [doc = "0: Voltage reference at 0.55V"]
_0V55 = 0 , # [doc = "1: Voltage reference at 1.1V"]
_1V1 = 1 , # [doc = "2: Voltage reference at 2.5V"]
_2V5 = 2 , # [doc = "3: Voltage reference at 4.34V"]
_4V34 = 3 , # [doc = "4: Voltage reference at 1.5V"]
_1V5 = 4 , } impl From < ADC0REFSEL_A > for u8 { # [inline (always)]
fn from (variant : ADC0REFSEL_A) -> Self { variant as _ } } impl ADC0REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ADC0REFSEL_A > { match self . bits { 0 => Some (ADC0REFSEL_A :: _0V55) , 1 => Some (ADC0REFSEL_A :: _1V1) , 2 => Some (ADC0REFSEL_A :: _2V5) , 3 => Some (ADC0REFSEL_A :: _4V34) , 4 => Some (ADC0REFSEL_A :: _1V5) , _ => None , } } # [doc = "Checks if the value of the field is `_0V55`"]
# [inline (always)]
pub fn is_0v55 (& self) -> bool { * self == ADC0REFSEL_A :: _0V55 } # [doc = "Checks if the value of the field is `_1V1`"]
# [inline (always)]
pub fn is_1v1 (& self) -> bool { * self == ADC0REFSEL_A :: _1V1 } # [doc = "Checks if the value of the field is `_2V5`"]
# [inline (always)]
pub fn is_2v5 (& self) -> bool { * self == ADC0REFSEL_A :: _2V5 } # [doc = "Checks if the value of the field is `_4V34`"]
# [inline (always)]
pub fn is_4v34 (& self) -> bool { * self == ADC0REFSEL_A :: _4V34 } # [doc = "Checks if the value of the field is `_1V5`"]
# [inline (always)]
pub fn is_1v5 (& self) -> bool { * self == ADC0REFSEL_A :: _1V5 } } # [doc = "Field `ADC0REFSEL` writer - ADC0 reference select"]
pub type ADC0REFSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , ADC0REFSEL_A , 3 , O > ; impl < 'a , const O : u8 > ADC0REFSEL_W < 'a , O > { # [doc = "Voltage reference at 0.55V"]
# [inline (always)]
pub fn _0v55 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _0V55) } # [doc = "Voltage reference at 1.1V"]
# [inline (always)]
pub fn _1v1 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _1V1) } # [doc = "Voltage reference at 2.5V"]
# [inline (always)]
pub fn _2v5 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _2V5) } # [doc = "Voltage reference at 4.34V"]
# [inline (always)]
pub fn _4v34 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _4V34) } # [doc = "Voltage reference at 1.5V"]
# [inline (always)]
pub fn _1v5 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _1V5) } } impl R { # [doc = "Bits 0:2 - DAC0/AC0 reference select"]
# [inline (always)]
pub fn dac0refsel (& self) -> DAC0REFSEL_R { DAC0REFSEL_R :: new (self . bits & 7) } # [doc = "Bits 4:6 - ADC0 reference select"]
# [inline (always)]
pub fn adc0refsel (& self) -> ADC0REFSEL_R { ADC0REFSEL_R :: new ((self . bits >> 4) & 7) } } impl W { # [doc = "Bits 0:2 - DAC0/AC0 reference select"]
# [inline (always)]
# [must_use]
pub fn dac0refsel (& mut self) -> DAC0REFSEL_W < 0 > { DAC0REFSEL_W :: new (self) } # [doc = "Bits 4:6 - ADC0 reference select"]
# [inline (always)]
# [must_use]
pub fn adc0refsel (& mut self) -> ADC0REFSEL_W < 4 > { ADC0REFSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `DAC0REFEN` reader - DAC0/AC0 reference enable"]
pub type DAC0REFEN_R = crate :: BitReader < bool > ; # [doc = "Field `DAC0REFEN` writer - DAC0/AC0 reference enable"]
pub type DAC0REFEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `ADC0REFEN` reader - ADC0 reference enable"]
pub type ADC0REFEN_R = crate :: BitReader < bool > ; # [doc = "Field `ADC0REFEN` writer - ADC0 reference enable"]
pub type ADC0REFEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - DAC0/AC0 reference enable"]
# [inline (always)]
pub fn dac0refen (& self) -> DAC0REFEN_R { DAC0REFEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC0 reference enable"]
# [inline (always)]
pub fn adc0refen (& self) -> ADC0REFEN_R { ADC0REFEN_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - DAC0/AC0 reference enable"]
# [inline (always)]
# [must_use]
pub fn dac0refen (& mut self) -> DAC0REFEN_W < 0 > { DAC0REFEN_W :: new (self) } # [doc = "Bit 1 - ADC0 reference enable"]
# [inline (always)]
# [must_use]
pub fn adc0refen (& mut self) -> ADC0REFEN_W < 1 > { ADC0REFEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Watch-Dog Timer"]
pub struct WDT { _marker : PhantomData < * const () > } unsafe impl Send for WDT { } impl WDT { # [doc = r"Pointer to the register block"]
pub const PTR : * const wdt :: RegisterBlock = 0x0100 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wdt :: RegisterBlock { Self :: PTR } } impl Deref for WDT { type Target = wdt :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WDT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WDT") . finish () } } # [doc = "Watch-Dog Timer"]
pub mod wdt { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Status"]
pub status : STATUS , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERIOD` reader - Period"]
pub type PERIOD_R = crate :: FieldReader < u8 , PERIOD_A > ; # [doc = "Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PERIOD_A { # [doc = "0: Watch-Dog timer Off"]
OFF = 0 , # [doc = "1: 8 cycles (8ms)"]
_8CLK = 1 , # [doc = "2: 16 cycles (16ms)"]
_16CLK = 2 , # [doc = "3: 32 cycles (32ms)"]
_32CLK = 3 , # [doc = "4: 64 cycles (64ms)"]
_64CLK = 4 , # [doc = "5: 128 cycles (0.128s)"]
_128CLK = 5 , # [doc = "6: 256 cycles (0.256s)"]
_256CLK = 6 , # [doc = "7: 512 cycles (0.512s)"]
_512CLK = 7 , # [doc = "8: 1K cycles (1.0s)"]
_1KCLK = 8 , # [doc = "9: 2K cycles (2.0s)"]
_2KCLK = 9 , # [doc = "10: 4K cycles (4.1s)"]
_4KCLK = 10 , # [doc = "11: 8K cycles (8.2s)"]
_8KCLK = 11 , } impl From < PERIOD_A > for u8 { # [inline (always)]
fn from (variant : PERIOD_A) -> Self { variant as _ } } impl PERIOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PERIOD_A > { match self . bits { 0 => Some (PERIOD_A :: OFF) , 1 => Some (PERIOD_A :: _8CLK) , 2 => Some (PERIOD_A :: _16CLK) , 3 => Some (PERIOD_A :: _32CLK) , 4 => Some (PERIOD_A :: _64CLK) , 5 => Some (PERIOD_A :: _128CLK) , 6 => Some (PERIOD_A :: _256CLK) , 7 => Some (PERIOD_A :: _512CLK) , 8 => Some (PERIOD_A :: _1KCLK) , 9 => Some (PERIOD_A :: _2KCLK) , 10 => Some (PERIOD_A :: _4KCLK) , 11 => Some (PERIOD_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == PERIOD_A :: OFF } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == PERIOD_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == PERIOD_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == PERIOD_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == PERIOD_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == PERIOD_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == PERIOD_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == PERIOD_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == PERIOD_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == PERIOD_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == PERIOD_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == PERIOD_A :: _8KCLK } } # [doc = "Field `PERIOD` writer - Period"]
pub type PERIOD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , PERIOD_A , 4 , O > ; impl < 'a , const O : u8 > PERIOD_W < 'a , O > { # [doc = "Watch-Dog timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (PERIOD_A :: OFF) } # [doc = "8 cycles (8ms)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _8CLK) } # [doc = "16 cycles (16ms)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _16CLK) } # [doc = "32 cycles (32ms)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _32CLK) } # [doc = "64 cycles (64ms)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _64CLK) } # [doc = "128 cycles (0.128s)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _128CLK) } # [doc = "256 cycles (0.256s)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _256CLK) } # [doc = "512 cycles (0.512s)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _512CLK) } # [doc = "1K cycles (1.0s)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _1KCLK) } # [doc = "2K cycles (2.0s)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _2KCLK) } # [doc = "4K cycles (4.1s)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _4KCLK) } # [doc = "8K cycles (8.2s)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _8KCLK) } } # [doc = "Field `WINDOW` reader - Window"]
pub type WINDOW_R = crate :: FieldReader < u8 , WINDOW_A > ; # [doc = "Window\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINDOW_A { # [doc = "0: Window mode off"]
OFF = 0 , # [doc = "1: 8 cycles (8ms)"]
_8CLK = 1 , # [doc = "2: 16 cycles (16ms)"]
_16CLK = 2 , # [doc = "3: 32 cycles (32ms)"]
_32CLK = 3 , # [doc = "4: 64 cycles (64ms)"]
_64CLK = 4 , # [doc = "5: 128 cycles (0.128s)"]
_128CLK = 5 , # [doc = "6: 256 cycles (0.256s)"]
_256CLK = 6 , # [doc = "7: 512 cycles (0.512s)"]
_512CLK = 7 , # [doc = "8: 1K cycles (1.0s)"]
_1KCLK = 8 , # [doc = "9: 2K cycles (2.0s)"]
_2KCLK = 9 , # [doc = "10: 4K cycles (4.1s)"]
_4KCLK = 10 , # [doc = "11: 8K cycles (8.2s)"]
_8KCLK = 11 , } impl From < WINDOW_A > for u8 { # [inline (always)]
fn from (variant : WINDOW_A) -> Self { variant as _ } } impl WINDOW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WINDOW_A > { match self . bits { 0 => Some (WINDOW_A :: OFF) , 1 => Some (WINDOW_A :: _8CLK) , 2 => Some (WINDOW_A :: _16CLK) , 3 => Some (WINDOW_A :: _32CLK) , 4 => Some (WINDOW_A :: _64CLK) , 5 => Some (WINDOW_A :: _128CLK) , 6 => Some (WINDOW_A :: _256CLK) , 7 => Some (WINDOW_A :: _512CLK) , 8 => Some (WINDOW_A :: _1KCLK) , 9 => Some (WINDOW_A :: _2KCLK) , 10 => Some (WINDOW_A :: _4KCLK) , 11 => Some (WINDOW_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == WINDOW_A :: OFF } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == WINDOW_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == WINDOW_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == WINDOW_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == WINDOW_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == WINDOW_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == WINDOW_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == WINDOW_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == WINDOW_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == WINDOW_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == WINDOW_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == WINDOW_A :: _8KCLK } } # [doc = "Field `WINDOW` writer - Window"]
pub type WINDOW_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , WINDOW_A , 4 , O > ; impl < 'a , const O : u8 > WINDOW_W < 'a , O > { # [doc = "Window mode off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (WINDOW_A :: OFF) } # [doc = "8 cycles (8ms)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _8CLK) } # [doc = "16 cycles (16ms)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _16CLK) } # [doc = "32 cycles (32ms)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _32CLK) } # [doc = "64 cycles (64ms)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _64CLK) } # [doc = "128 cycles (0.128s)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _128CLK) } # [doc = "256 cycles (0.256s)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _256CLK) } # [doc = "512 cycles (0.512s)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _512CLK) } # [doc = "1K cycles (1.0s)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _1KCLK) } # [doc = "2K cycles (2.0s)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _2KCLK) } # [doc = "4K cycles (4.1s)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _4KCLK) } # [doc = "8K cycles (8.2s)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _8KCLK) } } impl R { # [doc = "Bits 0:3 - Period"]
# [inline (always)]
pub fn period (& self) -> PERIOD_R { PERIOD_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Window"]
# [inline (always)]
pub fn window (& self) -> WINDOW_R { WINDOW_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Period"]
# [inline (always)]
# [must_use]
pub fn period (& mut self) -> PERIOD_W < 0 > { PERIOD_W :: new (self) } # [doc = "Bits 4:7 - Window"]
# [inline (always)]
# [must_use]
pub fn window (& mut self) -> WINDOW_W < 4 > { WINDOW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCBUSY` reader - Syncronization busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `LOCK` reader - Lock enable"]
pub type LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `LOCK` writer - Lock enable"]
pub type LOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Syncronization busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - Lock enable"]
# [inline (always)]
pub fn lock (& self) -> LOCK_R { LOCK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 7 - Lock enable"]
# [inline (always)]
# [must_use]
pub fn lock (& mut self) -> LOCK_W < 7 > { LOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "AC0"]
pub AC0 : AC0 , # [doc = "ADC0"]
pub ADC0 : ADC0 , # [doc = "BOD"]
pub BOD : BOD , # [doc = "CCL"]
pub CCL : CCL , # [doc = "CLKCTRL"]
pub CLKCTRL : CLKCTRL , # [doc = "CPU"]
pub CPU : CPU , # [doc = "CPUINT"]
pub CPUINT : CPUINT , # [doc = "CRCSCAN"]
pub CRCSCAN : CRCSCAN , # [doc = "DAC0"]
pub DAC0 : DAC0 , # [doc = "EVSYS"]
pub EVSYS : EVSYS , # [doc = "FUSE"]
pub FUSE : FUSE , # [doc = "GPIO"]
pub GPIO : GPIO , # [doc = "LOCKBIT"]
pub LOCKBIT : LOCKBIT , # [doc = "NVMCTRL"]
pub NVMCTRL : NVMCTRL , # [doc = "PORTA"]
pub PORTA : PORTA , # [doc = "PORTB"]
pub PORTB : PORTB , # [doc = "PORTC"]
pub PORTC : PORTC , # [doc = "PORTMUX"]
pub PORTMUX : PORTMUX , # [doc = "RSTCTRL"]
pub RSTCTRL : RSTCTRL , # [doc = "RTC"]
pub RTC : RTC , # [doc = "SIGROW"]
pub SIGROW : SIGROW , # [doc = "SLPCTRL"]
pub SLPCTRL : SLPCTRL , # [doc = "SPI0"]
pub SPI0 : SPI0 , # [doc = "SYSCFG"]
pub SYSCFG : SYSCFG , # [doc = "TCA0"]
pub TCA0 : TCA0 , # [doc = "TCB0"]
pub TCB0 : TCB0 , # [doc = "TCD0"]
pub TCD0 : TCD0 , # [doc = "TWI0"]
pub TWI0 : TWI0 , # [doc = "USART0"]
pub USART0 : USART0 , # [doc = "USERROW"]
pub USERROW : USERROW , # [doc = "VPORTA"]
pub VPORTA : VPORTA , # [doc = "VPORTB"]
pub VPORTB : VPORTB , # [doc = "VPORTC"]
pub VPORTC : VPORTC , # [doc = "VREF"]
pub VREF : VREF , # [doc = "WDT"]
pub WDT : WDT , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { AC0 : AC0 { _marker : PhantomData } , ADC0 : ADC0 { _marker : PhantomData } , BOD : BOD { _marker : PhantomData } , CCL : CCL { _marker : PhantomData } , CLKCTRL : CLKCTRL { _marker : PhantomData } , CPU : CPU { _marker : PhantomData } , CPUINT : CPUINT { _marker : PhantomData } , CRCSCAN : CRCSCAN { _marker : PhantomData } , DAC0 : DAC0 { _marker : PhantomData } , EVSYS : EVSYS { _marker : PhantomData } , FUSE : FUSE { _marker : PhantomData } , GPIO : GPIO { _marker : PhantomData } , LOCKBIT : LOCKBIT { _marker : PhantomData } , NVMCTRL : NVMCTRL { _marker : PhantomData } , PORTA : PORTA { _marker : PhantomData } , PORTB : PORTB { _marker : PhantomData } , PORTC : PORTC { _marker : PhantomData } , PORTMUX : PORTMUX { _marker : PhantomData } , RSTCTRL : RSTCTRL { _marker : PhantomData } , RTC : RTC { _marker : PhantomData } , SIGROW : SIGROW { _marker : PhantomData } , SLPCTRL : SLPCTRL { _marker : PhantomData } , SPI0 : SPI0 { _marker : PhantomData } , SYSCFG : SYSCFG { _marker : PhantomData } , TCA0 : TCA0 { _marker : PhantomData } , TCB0 : TCB0 { _marker : PhantomData } , TCD0 : TCD0 { _marker : PhantomData } , TWI0 : TWI0 { _marker : PhantomData } , USART0 : USART0 { _marker : PhantomData } , USERROW : USERROW { _marker : PhantomData } , VPORTA : VPORTA { _marker : PhantomData } , VPORTB : VPORTB { _marker : PhantomData } , VPORTC : VPORTC { _marker : PhantomData } , VREF : VREF { _marker : PhantomData } , WDT : WDT { _marker : PhantomData } , } } }