# ! [doc = "Peripheral access API for ATMEGA4809 microcontrollers (generated using svd2rust v0.28.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS : u8 = 4 ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."]
type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."]
type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Read datasheet or reference manual to find what values are allowed to pass."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc (hidden)]
pub struct FieldReaderRaw < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , FI > FieldReaderRaw < U , FI > where U : Copy , { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitReaderRaw < T > { pub (crate) bits : bool , _reg : marker :: PhantomData < T > , } impl < FI > BitReaderRaw < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < U , FI > = FieldReaderRaw < U , FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI > = BitReaderRaw < FI > ; impl < U , FI > FieldReader < U , FI > where U : Copy , { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , FI > PartialEq < FI > for FieldReader < U , FI > where U : PartialEq , FI : Copy , U : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& U :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc (hidden)]
pub struct FieldWriterRaw < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (N , FI , Safety) > , } impl < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > FieldWriterRaw < 'a , U , REG , N , FI , Safety , WI , O > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitWriterRaw < 'a , U , REG , FI , M , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , U , REG , FI , M , const O : u8 > BitWriterRaw < 'a , U , REG , FI , M , O > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Unsafe , WI , O > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Safe , WI , O > ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , U , REG , FI , const O : u8 > = BitWriterRaw <'a , U , REG , FI , $ mwv , O >; impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; } } ; } macro_rules ! impl_bit_proxy { ($ writer : ident) => { impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, U : RawReg , bool : From < FI >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w . bits |= (U :: from (value) & U :: one ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { unsafe { self . bits (N :: from (variant)) } } } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { self . bits (N :: from (variant)) } } impl_bit_proxy ! (BitWriter) ; impl_bit_proxy ! (BitWriter1S) ; impl_bit_proxy ! (BitWriter0C) ; impl_bit_proxy ! (BitWriter1C) ; impl_bit_proxy ! (BitWriter0S) ; impl_bit_proxy ! (BitWriter1T) ; impl_bit_proxy ! (BitWriter0T) ; impl < 'a , U , REG , FI , const OF : u8 > BitWriter < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } } # [doc (hidden)]
pub mod interrupt { # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "1 - No Description."]
CRCSCAN_NMI = 1 , # [doc = "2 - No Description."]
BOD_VLM = 2 , # [doc = "3 - No Description."]
RTC_CNT = 3 , # [doc = "4 - No Description."]
RTC_PIT = 4 , # [doc = "5 - No Description."]
CCL_CCL = 5 , # [doc = "6 - No Description."]
PORTA_PORT = 6 , # [doc = "7 - No Description."]
TCA0_LUNF_OVF = 7 , # [doc = "8 - No Description."]
TCA0_HUNF = 8 , # [doc = "9 - No Description."]
TCA0_CMP0_LCMP0 = 9 , # [doc = "10 - No Description."]
TCA0_CMP1_LCMP1 = 10 , # [doc = "11 - No Description."]
TCA0_CMP2_LCMP2 = 11 , # [doc = "12 - No Description."]
TCB0_INT = 12 , # [doc = "13 - No Description."]
TCB1_INT = 13 , # [doc = "14 - No Description."]
TWI0_TWIS = 14 , # [doc = "15 - No Description."]
TWI0_TWIM = 15 , # [doc = "16 - No Description."]
SPI0_INT = 16 , # [doc = "17 - No Description."]
USART0_RXC = 17 , # [doc = "18 - No Description."]
USART0_DRE = 18 , # [doc = "19 - No Description."]
USART0_TXC = 19 , # [doc = "20 - No Description."]
PORTD_PORT = 20 , # [doc = "21 - No Description."]
AC0_AC = 21 , # [doc = "22 - No Description."]
ADC0_RESRDY = 22 , # [doc = "23 - No Description."]
ADC0_WCOMP = 23 , # [doc = "24 - No Description."]
PORTC_PORT = 24 , # [doc = "25 - No Description."]
TCB2_INT = 25 , # [doc = "26 - No Description."]
USART1_RXC = 26 , # [doc = "27 - No Description."]
USART1_DRE = 27 , # [doc = "28 - No Description."]
USART1_TXC = 28 , # [doc = "29 - No Description."]
PORTF_PORT = 29 , # [doc = "30 - No Description."]
NVMCTRL_EE = 30 , # [doc = "31 - No Description."]
USART2_RXC = 31 , # [doc = "32 - No Description."]
USART2_DRE = 32 , # [doc = "33 - No Description."]
USART2_TXC = 33 , # [doc = "34 - No Description."]
PORTB_PORT = 34 , # [doc = "35 - No Description."]
PORTE_PORT = 35 , # [doc = "36 - No Description."]
TCB3_INT = 36 , # [doc = "37 - No Description."]
USART3_RXC = 37 , # [doc = "38 - No Description."]
USART3_DRE = 38 , # [doc = "39 - No Description."]
USART3_TXC = 39 , } # [doc = r" TryFromInterruptError"]
# [derive (Debug , Copy , Clone)]
pub struct TryFromInterruptError (()) ; impl Interrupt { # [doc = r" Attempt to convert a given value into an `Interrupt`"]
# [inline]
pub fn try_from (value : u8) -> Result < Self , TryFromInterruptError > { match value { 1 => Ok (Interrupt :: CRCSCAN_NMI) , 2 => Ok (Interrupt :: BOD_VLM) , 3 => Ok (Interrupt :: RTC_CNT) , 4 => Ok (Interrupt :: RTC_PIT) , 5 => Ok (Interrupt :: CCL_CCL) , 6 => Ok (Interrupt :: PORTA_PORT) , 7 => Ok (Interrupt :: TCA0_LUNF_OVF) , 8 => Ok (Interrupt :: TCA0_HUNF) , 9 => Ok (Interrupt :: TCA0_CMP0_LCMP0) , 10 => Ok (Interrupt :: TCA0_CMP1_LCMP1) , 11 => Ok (Interrupt :: TCA0_CMP2_LCMP2) , 12 => Ok (Interrupt :: TCB0_INT) , 13 => Ok (Interrupt :: TCB1_INT) , 14 => Ok (Interrupt :: TWI0_TWIS) , 15 => Ok (Interrupt :: TWI0_TWIM) , 16 => Ok (Interrupt :: SPI0_INT) , 17 => Ok (Interrupt :: USART0_RXC) , 18 => Ok (Interrupt :: USART0_DRE) , 19 => Ok (Interrupt :: USART0_TXC) , 20 => Ok (Interrupt :: PORTD_PORT) , 21 => Ok (Interrupt :: AC0_AC) , 22 => Ok (Interrupt :: ADC0_RESRDY) , 23 => Ok (Interrupt :: ADC0_WCOMP) , 24 => Ok (Interrupt :: PORTC_PORT) , 25 => Ok (Interrupt :: TCB2_INT) , 26 => Ok (Interrupt :: USART1_RXC) , 27 => Ok (Interrupt :: USART1_DRE) , 28 => Ok (Interrupt :: USART1_TXC) , 29 => Ok (Interrupt :: PORTF_PORT) , 30 => Ok (Interrupt :: NVMCTRL_EE) , 31 => Ok (Interrupt :: USART2_RXC) , 32 => Ok (Interrupt :: USART2_DRE) , 33 => Ok (Interrupt :: USART2_TXC) , 34 => Ok (Interrupt :: PORTB_PORT) , 35 => Ok (Interrupt :: PORTE_PORT) , 36 => Ok (Interrupt :: TCB3_INT) , 37 => Ok (Interrupt :: USART3_RXC) , 38 => Ok (Interrupt :: USART3_DRE) , 39 => Ok (Interrupt :: USART3_TXC) , _ => Err (TryFromInterruptError (())) , } } } } pub use self :: interrupt :: Interrupt ; # [doc = "Analog Comparator"]
pub struct AC0 { _marker : PhantomData < * const () > } unsafe impl Send for AC0 { } impl AC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const ac0 :: RegisterBlock = 0x0680 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ac0 :: RegisterBlock { Self :: PTR } } impl Deref for AC0 { type Target = ac0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for AC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AC0") . finish () } } # [doc = "Analog Comparator"]
pub mod ac0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Mux Control A"]
pub muxctrla : MUXCTRLA , _reserved2 : [u8 ; 0x01]
, # [doc = "0x04 - Referance scale control"]
pub dacref : DACREF , _reserved3 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x07 - Status"]
pub status : STATUS , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `HYSMODE` reader - Hysteresis Mode"]
pub type HYSMODE_R = crate :: FieldReader < u8 , HYSMODE_A > ; # [doc = "Hysteresis Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HYSMODE_A { # [doc = "0: No hysteresis"]
OFF = 0 , # [doc = "1: 10mV hysteresis"]
_10M_V = 1 , # [doc = "2: 25mV hysteresis"]
_25M_V = 2 , # [doc = "3: 50mV hysteresis"]
_50M_V = 3 , } impl From < HYSMODE_A > for u8 { # [inline (always)]
fn from (variant : HYSMODE_A) -> Self { variant as _ } } impl HYSMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> HYSMODE_A { match self . bits { 0 => HYSMODE_A :: OFF , 1 => HYSMODE_A :: _10M_V , 2 => HYSMODE_A :: _25M_V , 3 => HYSMODE_A :: _50M_V , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == HYSMODE_A :: OFF } # [doc = "Checks if the value of the field is `_10M_V`"]
# [inline (always)]
pub fn is_10m_v (& self) -> bool { * self == HYSMODE_A :: _10M_V } # [doc = "Checks if the value of the field is `_25M_V`"]
# [inline (always)]
pub fn is_25m_v (& self) -> bool { * self == HYSMODE_A :: _25M_V } # [doc = "Checks if the value of the field is `_50M_V`"]
# [inline (always)]
pub fn is_50m_v (& self) -> bool { * self == HYSMODE_A :: _50M_V } } # [doc = "Field `HYSMODE` writer - Hysteresis Mode"]
pub type HYSMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , HYSMODE_A , 2 , O > ; impl < 'a , const O : u8 > HYSMODE_W < 'a , O > { # [doc = "No hysteresis"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (HYSMODE_A :: OFF) } # [doc = "10mV hysteresis"]
# [inline (always)]
pub fn _10m_v (self) -> & 'a mut W { self . variant (HYSMODE_A :: _10M_V) } # [doc = "25mV hysteresis"]
# [inline (always)]
pub fn _25m_v (self) -> & 'a mut W { self . variant (HYSMODE_A :: _25M_V) } # [doc = "50mV hysteresis"]
# [inline (always)]
pub fn _50m_v (self) -> & 'a mut W { self . variant (HYSMODE_A :: _50M_V) } } # [doc = "Field `LPMODE` reader - Low Power Mode"]
pub type LPMODE_R = crate :: BitReader < LPMODE_A > ; # [doc = "Low Power Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum LPMODE_A { # [doc = "0: Low power mode disabled"]
DIS = 0 , # [doc = "1: Low power mode enabled"]
EN = 1 , } impl From < LPMODE_A > for bool { # [inline (always)]
fn from (variant : LPMODE_A) -> Self { variant as u8 != 0 } } impl LPMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> LPMODE_A { match self . bits { false => LPMODE_A :: DIS , true => LPMODE_A :: EN , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == LPMODE_A :: DIS } # [doc = "Checks if the value of the field is `EN`"]
# [inline (always)]
pub fn is_en (& self) -> bool { * self == LPMODE_A :: EN } } # [doc = "Field `LPMODE` writer - Low Power Mode"]
pub type LPMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , LPMODE_A , O > ; impl < 'a , const O : u8 > LPMODE_W < 'a , O > { # [doc = "Low power mode disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (LPMODE_A :: DIS) } # [doc = "Low power mode enabled"]
# [inline (always)]
pub fn en (self) -> & 'a mut W { self . variant (LPMODE_A :: EN) } } # [doc = "Field `INTMODE` reader - Interrupt Mode"]
pub type INTMODE_R = crate :: FieldReader < u8 , INTMODE_A > ; # [doc = "Interrupt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE_A { # [doc = "0: Any Edge"]
BOTHEDGE = 0 , # [doc = "2: Negative Edge"]
NEGEDGE = 2 , # [doc = "3: Positive Edge"]
POSEDGE = 3 , } impl From < INTMODE_A > for u8 { # [inline (always)]
fn from (variant : INTMODE_A) -> Self { variant as _ } } impl INTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INTMODE_A > { match self . bits { 0 => Some (INTMODE_A :: BOTHEDGE) , 2 => Some (INTMODE_A :: NEGEDGE) , 3 => Some (INTMODE_A :: POSEDGE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGE`"]
# [inline (always)]
pub fn is_bothedge (& self) -> bool { * self == INTMODE_A :: BOTHEDGE } # [doc = "Checks if the value of the field is `NEGEDGE`"]
# [inline (always)]
pub fn is_negedge (& self) -> bool { * self == INTMODE_A :: NEGEDGE } # [doc = "Checks if the value of the field is `POSEDGE`"]
# [inline (always)]
pub fn is_posedge (& self) -> bool { * self == INTMODE_A :: POSEDGE } } # [doc = "Field `INTMODE` writer - Interrupt Mode"]
pub type INTMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , INTMODE_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE_W < 'a , O > { # [doc = "Any Edge"]
# [inline (always)]
pub fn bothedge (self) -> & 'a mut W { self . variant (INTMODE_A :: BOTHEDGE) } # [doc = "Negative Edge"]
# [inline (always)]
pub fn negedge (self) -> & 'a mut W { self . variant (INTMODE_A :: NEGEDGE) } # [doc = "Positive Edge"]
# [inline (always)]
pub fn posedge (self) -> & 'a mut W { self . variant (INTMODE_A :: POSEDGE) } } # [doc = "Field `OUTEN` reader - Output Buffer Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Buffer Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby Mode"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby Mode"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
pub fn hysmode (& self) -> HYSMODE_R { HYSMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Low Power Mode"]
# [inline (always)]
pub fn lpmode (& self) -> LPMODE_R { LPMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Interrupt Mode"]
# [inline (always)]
pub fn intmode (& self) -> INTMODE_R { INTMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Output Buffer Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Run in Standby Mode"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
# [must_use]
pub fn hysmode (& mut self) -> HYSMODE_W < 1 > { HYSMODE_W :: new (self) } # [doc = "Bit 3 - Low Power Mode"]
# [inline (always)]
# [must_use]
pub fn lpmode (& mut self) -> LPMODE_W < 3 > { LPMODE_W :: new (self) } # [doc = "Bits 4:5 - Interrupt Mode"]
# [inline (always)]
# [must_use]
pub fn intmode (& mut self) -> INTMODE_W < 4 > { INTMODE_W :: new (self) } # [doc = "Bit 6 - Output Buffer Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 6 > { OUTEN_W :: new (self) } # [doc = "Bit 7 - Run in Standby Mode"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 7 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DACREF (rw) register accessor: an alias for `Reg<DACREF_SPEC>`"]
pub type DACREF = crate :: Reg < dacref :: DACREF_SPEC > ; # [doc = "Referance scale control"]
pub mod dacref { # [doc = "Register `DACREF` reader"]
pub struct R (crate :: R < DACREF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DACREF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DACREF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DACREF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DACREF` writer"]
pub struct W (crate :: W < DACREF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DACREF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DACREF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DACREF_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - DAC voltage reference"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DATA` writer - DAC voltage reference"]
pub type DATA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DACREF_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - DAC voltage reference"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - DAC voltage reference"]
# [inline (always)]
# [must_use]
pub fn data (& mut self) -> DATA_W < 0 > { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Referance scale control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dacref](index.html) module"]
pub struct DACREF_SPEC ; impl crate :: RegisterSpec for DACREF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dacref::R](R) reader structure"]
impl crate :: Readable for DACREF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dacref::W](W) writer structure"]
impl crate :: Writable for DACREF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DACREF to value 0"]
impl crate :: Resettable for DACREF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP` reader - Analog Comparator 0 Interrupt Enable"]
pub type CMP_R = crate :: BitReader < bool > ; # [doc = "Field `CMP` writer - Analog Comparator 0 Interrupt Enable"]
pub type CMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Analog Comparator 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp (& self) -> CMP_R { CMP_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Analog Comparator 0 Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn cmp (& mut self) -> CMP_W < 0 > { CMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MUXCTRLA (rw) register accessor: an alias for `Reg<MUXCTRLA_SPEC>`"]
pub type MUXCTRLA = crate :: Reg < muxctrla :: MUXCTRLA_SPEC > ; # [doc = "Mux Control A"]
pub mod muxctrla { # [doc = "Register `MUXCTRLA` reader"]
pub struct R (crate :: R < MUXCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MUXCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MUXCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MUXCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `MUXCTRLA` writer"]
pub struct W (crate :: W < MUXCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MUXCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MUXCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MUXCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUXNEG` reader - Negative Input MUX Selection"]
pub type MUXNEG_R = crate :: FieldReader < u8 , MUXNEG_A > ; # [doc = "Negative Input MUX Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXNEG_A { # [doc = "0: Negative Pin 0"]
PIN0 = 0 , # [doc = "1: Negative Pin 1"]
PIN1 = 1 , # [doc = "2: Negative Pin 2"]
PIN2 = 2 , # [doc = "3: DAC Voltage Reference"]
DACREF = 3 , } impl From < MUXNEG_A > for u8 { # [inline (always)]
fn from (variant : MUXNEG_A) -> Self { variant as _ } } impl MUXNEG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXNEG_A { match self . bits { 0 => MUXNEG_A :: PIN0 , 1 => MUXNEG_A :: PIN1 , 2 => MUXNEG_A :: PIN2 , 3 => MUXNEG_A :: DACREF , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXNEG_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXNEG_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXNEG_A :: PIN2 } # [doc = "Checks if the value of the field is `DACREF`"]
# [inline (always)]
pub fn is_dacref (& self) -> bool { * self == MUXNEG_A :: DACREF } } # [doc = "Field `MUXNEG` writer - Negative Input MUX Selection"]
pub type MUXNEG_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MUXCTRLA_SPEC , u8 , MUXNEG_A , 2 , O > ; impl < 'a , const O : u8 > MUXNEG_W < 'a , O > { # [doc = "Negative Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN0) } # [doc = "Negative Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN1) } # [doc = "Negative Pin 2"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN2) } # [doc = "DAC Voltage Reference"]
# [inline (always)]
pub fn dacref (self) -> & 'a mut W { self . variant (MUXNEG_A :: DACREF) } } # [doc = "Field `MUXPOS` reader - Positive Input MUX Selection"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; # [doc = "Positive Input MUX Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: Positive Pin 0"]
PIN0 = 0 , # [doc = "1: Positive Pin 1"]
PIN1 = 1 , # [doc = "2: Positive Pin 2"]
PIN2 = 2 , # [doc = "3: Positive Pin 3"]
PIN3 = 3 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXPOS_A { match self . bits { 0 => MUXPOS_A :: PIN0 , 1 => MUXPOS_A :: PIN1 , 2 => MUXPOS_A :: PIN2 , 3 => MUXPOS_A :: PIN3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXPOS_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXPOS_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXPOS_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXPOS_A :: PIN3 } } # [doc = "Field `MUXPOS` writer - Positive Input MUX Selection"]
pub type MUXPOS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MUXCTRLA_SPEC , u8 , MUXPOS_A , 2 , O > ; impl < 'a , const O : u8 > MUXPOS_W < 'a , O > { # [doc = "Positive Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN0) } # [doc = "Positive Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN1) } # [doc = "Positive Pin 2"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN2) } # [doc = "Positive Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN3) } } # [doc = "Field `INVERT` reader - Invert AC Output"]
pub type INVERT_R = crate :: BitReader < bool > ; # [doc = "Field `INVERT` writer - Invert AC Output"]
pub type INVERT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MUXCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Negative Input MUX Selection"]
# [inline (always)]
pub fn muxneg (& self) -> MUXNEG_R { MUXNEG_R :: new (self . bits & 3) } # [doc = "Bits 3:4 - Positive Input MUX Selection"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new ((self . bits >> 3) & 3) } # [doc = "Bit 7 - Invert AC Output"]
# [inline (always)]
pub fn invert (& self) -> INVERT_R { INVERT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Negative Input MUX Selection"]
# [inline (always)]
# [must_use]
pub fn muxneg (& mut self) -> MUXNEG_W < 0 > { MUXNEG_W :: new (self) } # [doc = "Bits 3:4 - Positive Input MUX Selection"]
# [inline (always)]
# [must_use]
pub fn muxpos (& mut self) -> MUXPOS_W < 3 > { MUXPOS_W :: new (self) } # [doc = "Bit 7 - Invert AC Output"]
# [inline (always)]
# [must_use]
pub fn invert (& mut self) -> INVERT_W < 7 > { INVERT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Mux Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [muxctrla](index.html) module"]
pub struct MUXCTRLA_SPEC ; impl crate :: RegisterSpec for MUXCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [muxctrla::R](R) reader structure"]
impl crate :: Readable for MUXCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [muxctrla::W](W) writer structure"]
impl crate :: Writable for MUXCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MUXCTRLA to value 0"]
impl crate :: Resettable for MUXCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP` reader - Analog Comparator Interrupt Flag"]
pub type CMP_R = crate :: BitReader < bool > ; # [doc = "Field `CMP` writer - Analog Comparator Interrupt Flag"]
pub type CMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `STATE` reader - Analog Comparator State"]
pub type STATE_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Analog Comparator Interrupt Flag"]
# [inline (always)]
pub fn cmp (& self) -> CMP_R { CMP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Analog Comparator State"]
# [inline (always)]
pub fn state (& self) -> STATE_R { STATE_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Analog Comparator Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn cmp (& mut self) -> CMP_W < 0 > { CMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Analog to Digital Converter"]
pub struct ADC0 { _marker : PhantomData < * const () > } unsafe impl Send for ADC0 { } impl ADC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const adc0 :: RegisterBlock = 0x0600 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adc0 :: RegisterBlock { Self :: PTR } } impl Deref for ADC0 { type Target = adc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC0") . finish () } } # [doc = "Analog to Digital Converter"]
pub mod adc0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control E"]
pub ctrle : CTRLE , # [doc = "0x05 - Sample Control"]
pub sampctrl : SAMPCTRL , # [doc = "0x06 - Positive mux input"]
pub muxpos : MUXPOS , _reserved7 : [u8 ; 0x01]
, # [doc = "0x08 - Command"]
pub command : COMMAND , # [doc = "0x09 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x0a - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x0b - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0c - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x0d - Temporary Data"]
pub temp : TEMP , _reserved13 : [u8 ; 0x02]
, # [doc = "0x10 - ADC Accumulator Result"]
pub res : RES , # [doc = "0x12 - Window comparator low threshold"]
pub winlt : WINLT , # [doc = "0x14 - Window comparator high threshold"]
pub winht : WINHT , # [doc = "0x16 - Calibration"]
pub calib : CALIB , } # [doc = "CALIB (rw) register accessor: an alias for `Reg<CALIB_SPEC>`"]
pub type CALIB = crate :: Reg < calib :: CALIB_SPEC > ; # [doc = "Calibration"]
pub mod calib { # [doc = "Register `CALIB` reader"]
pub struct R (crate :: R < CALIB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CALIB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CALIB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CALIB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CALIB` writer"]
pub struct W (crate :: W < CALIB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CALIB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CALIB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CALIB_SPEC >) -> Self { W (writer) } } # [doc = "Field `DUTYCYC` reader - Duty Cycle"]
pub type DUTYCYC_R = crate :: BitReader < DUTYCYC_A > ; # [doc = "Duty Cycle\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DUTYCYC_A { # [doc = "0: 50% Duty cycle"]
DUTY50 = 0 , # [doc = "1: 25% Duty cycle"]
DUTY25 = 1 , } impl From < DUTYCYC_A > for bool { # [inline (always)]
fn from (variant : DUTYCYC_A) -> Self { variant as u8 != 0 } } impl DUTYCYC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DUTYCYC_A { match self . bits { false => DUTYCYC_A :: DUTY50 , true => DUTYCYC_A :: DUTY25 , } } # [doc = "Checks if the value of the field is `DUTY50`"]
# [inline (always)]
pub fn is_duty50 (& self) -> bool { * self == DUTYCYC_A :: DUTY50 } # [doc = "Checks if the value of the field is `DUTY25`"]
# [inline (always)]
pub fn is_duty25 (& self) -> bool { * self == DUTYCYC_A :: DUTY25 } } # [doc = "Field `DUTYCYC` writer - Duty Cycle"]
pub type DUTYCYC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CALIB_SPEC , DUTYCYC_A , O > ; impl < 'a , const O : u8 > DUTYCYC_W < 'a , O > { # [doc = "50% Duty cycle"]
# [inline (always)]
pub fn duty50 (self) -> & 'a mut W { self . variant (DUTYCYC_A :: DUTY50) } # [doc = "25% Duty cycle"]
# [inline (always)]
pub fn duty25 (self) -> & 'a mut W { self . variant (DUTYCYC_A :: DUTY25) } } impl R { # [doc = "Bit 0 - Duty Cycle"]
# [inline (always)]
pub fn dutycyc (& self) -> DUTYCYC_R { DUTYCYC_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Duty Cycle"]
# [inline (always)]
# [must_use]
pub fn dutycyc (& mut self) -> DUTYCYC_W < 0 > { DUTYCYC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calib](index.html) module"]
pub struct CALIB_SPEC ; impl crate :: RegisterSpec for CALIB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [calib::R](R) reader structure"]
impl crate :: Readable for CALIB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [calib::W](W) writer structure"]
impl crate :: Writable for CALIB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CALIB to value 0"]
impl crate :: Resettable for CALIB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMMAND (rw) register accessor: an alias for `Reg<COMMAND_SPEC>`"]
pub type COMMAND = crate :: Reg < command :: COMMAND_SPEC > ; # [doc = "Command"]
pub mod command { # [doc = "Register `COMMAND` reader"]
pub struct R (crate :: R < COMMAND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMMAND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMMAND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMMAND_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMMAND` writer"]
pub struct W (crate :: W < COMMAND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMMAND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMMAND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMMAND_SPEC >) -> Self { W (writer) } } # [doc = "Field `STCONV` reader - Start Conversion Operation"]
pub type STCONV_R = crate :: BitReader < bool > ; # [doc = "Field `STCONV` writer - Start Conversion Operation"]
pub type STCONV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , COMMAND_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Start Conversion Operation"]
# [inline (always)]
pub fn stconv (& self) -> STCONV_R { STCONV_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Start Conversion Operation"]
# [inline (always)]
# [must_use]
pub fn stconv (& mut self) -> STCONV_W < 0 > { STCONV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Command\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [command](index.html) module"]
pub struct COMMAND_SPEC ; impl crate :: RegisterSpec for COMMAND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [command::R](R) reader structure"]
impl crate :: Readable for COMMAND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [command::W](W) writer structure"]
impl crate :: Writable for COMMAND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMMAND to value 0"]
impl crate :: Resettable for COMMAND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - ADC Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - ADC Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `FREERUN` reader - ADC Freerun mode"]
pub type FREERUN_R = crate :: BitReader < bool > ; # [doc = "Field `FREERUN` writer - ADC Freerun mode"]
pub type FREERUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RESSEL` reader - ADC Resolution"]
pub type RESSEL_R = crate :: BitReader < RESSEL_A > ; # [doc = "ADC Resolution\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RESSEL_A { # [doc = "0: 10-bit mode"]
_10BIT = 0 , # [doc = "1: 8-bit mode"]
_8BIT = 1 , } impl From < RESSEL_A > for bool { # [inline (always)]
fn from (variant : RESSEL_A) -> Self { variant as u8 != 0 } } impl RESSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RESSEL_A { match self . bits { false => RESSEL_A :: _10BIT , true => RESSEL_A :: _8BIT , } } # [doc = "Checks if the value of the field is `_10BIT`"]
# [inline (always)]
pub fn is_10bit (& self) -> bool { * self == RESSEL_A :: _10BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == RESSEL_A :: _8BIT } } # [doc = "Field `RESSEL` writer - ADC Resolution"]
pub type RESSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , RESSEL_A , O > ; impl < 'a , const O : u8 > RESSEL_W < 'a , O > { # [doc = "10-bit mode"]
# [inline (always)]
pub fn _10bit (self) -> & 'a mut W { self . variant (RESSEL_A :: _10BIT) } # [doc = "8-bit mode"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (RESSEL_A :: _8BIT) } } # [doc = "Field `RUNSTBY` reader - Run standby mode"]
pub type RUNSTBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTBY` writer - Run standby mode"]
pub type RUNSTBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - ADC Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC Freerun mode"]
# [inline (always)]
pub fn freerun (& self) -> FREERUN_R { FREERUN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - ADC Resolution"]
# [inline (always)]
pub fn ressel (& self) -> RESSEL_R { RESSEL_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Run standby mode"]
# [inline (always)]
pub fn runstby (& self) -> RUNSTBY_R { RUNSTBY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - ADC Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - ADC Freerun mode"]
# [inline (always)]
# [must_use]
pub fn freerun (& mut self) -> FREERUN_W < 1 > { FREERUN_W :: new (self) } # [doc = "Bit 2 - ADC Resolution"]
# [inline (always)]
# [must_use]
pub fn ressel (& mut self) -> RESSEL_W < 2 > { RESSEL_W :: new (self) } # [doc = "Bit 7 - Run standby mode"]
# [inline (always)]
# [must_use]
pub fn runstby (& mut self) -> RUNSTBY_W < 7 > { RUNSTBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SAMPNUM` reader - Accumulation Samples"]
pub type SAMPNUM_R = crate :: FieldReader < u8 , SAMPNUM_A > ; # [doc = "Accumulation Samples\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SAMPNUM_A { # [doc = "0: 1 ADC sample"]
ACC1 = 0 , # [doc = "1: Accumulate 2 samples"]
ACC2 = 1 , # [doc = "2: Accumulate 4 samples"]
ACC4 = 2 , # [doc = "3: Accumulate 8 samples"]
ACC8 = 3 , # [doc = "4: Accumulate 16 samples"]
ACC16 = 4 , # [doc = "5: Accumulate 32 samples"]
ACC32 = 5 , # [doc = "6: Accumulate 64 samples"]
ACC64 = 6 , } impl From < SAMPNUM_A > for u8 { # [inline (always)]
fn from (variant : SAMPNUM_A) -> Self { variant as _ } } impl SAMPNUM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SAMPNUM_A > { match self . bits { 0 => Some (SAMPNUM_A :: ACC1) , 1 => Some (SAMPNUM_A :: ACC2) , 2 => Some (SAMPNUM_A :: ACC4) , 3 => Some (SAMPNUM_A :: ACC8) , 4 => Some (SAMPNUM_A :: ACC16) , 5 => Some (SAMPNUM_A :: ACC32) , 6 => Some (SAMPNUM_A :: ACC64) , _ => None , } } # [doc = "Checks if the value of the field is `ACC1`"]
# [inline (always)]
pub fn is_acc1 (& self) -> bool { * self == SAMPNUM_A :: ACC1 } # [doc = "Checks if the value of the field is `ACC2`"]
# [inline (always)]
pub fn is_acc2 (& self) -> bool { * self == SAMPNUM_A :: ACC2 } # [doc = "Checks if the value of the field is `ACC4`"]
# [inline (always)]
pub fn is_acc4 (& self) -> bool { * self == SAMPNUM_A :: ACC4 } # [doc = "Checks if the value of the field is `ACC8`"]
# [inline (always)]
pub fn is_acc8 (& self) -> bool { * self == SAMPNUM_A :: ACC8 } # [doc = "Checks if the value of the field is `ACC16`"]
# [inline (always)]
pub fn is_acc16 (& self) -> bool { * self == SAMPNUM_A :: ACC16 } # [doc = "Checks if the value of the field is `ACC32`"]
# [inline (always)]
pub fn is_acc32 (& self) -> bool { * self == SAMPNUM_A :: ACC32 } # [doc = "Checks if the value of the field is `ACC64`"]
# [inline (always)]
pub fn is_acc64 (& self) -> bool { * self == SAMPNUM_A :: ACC64 } } # [doc = "Field `SAMPNUM` writer - Accumulation Samples"]
pub type SAMPNUM_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , SAMPNUM_A , 3 , O > ; impl < 'a , const O : u8 > SAMPNUM_W < 'a , O > { # [doc = "1 ADC sample"]
# [inline (always)]
pub fn acc1 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC1) } # [doc = "Accumulate 2 samples"]
# [inline (always)]
pub fn acc2 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC2) } # [doc = "Accumulate 4 samples"]
# [inline (always)]
pub fn acc4 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC4) } # [doc = "Accumulate 8 samples"]
# [inline (always)]
pub fn acc8 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC8) } # [doc = "Accumulate 16 samples"]
# [inline (always)]
pub fn acc16 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC16) } # [doc = "Accumulate 32 samples"]
# [inline (always)]
pub fn acc32 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC32) } # [doc = "Accumulate 64 samples"]
# [inline (always)]
pub fn acc64 (self) -> & 'a mut W { self . variant (SAMPNUM_A :: ACC64) } } impl R { # [doc = "Bits 0:2 - Accumulation Samples"]
# [inline (always)]
pub fn sampnum (& self) -> SAMPNUM_R { SAMPNUM_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Accumulation Samples"]
# [inline (always)]
# [must_use]
pub fn sampnum (& mut self) -> SAMPNUM_W < 0 > { SAMPNUM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESC` reader - Clock Pre-scaler"]
pub type PRESC_R = crate :: FieldReader < u8 , PRESC_A > ; # [doc = "Clock Pre-scaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESC_A { # [doc = "0: CLK_PER divided by 2"]
DIV2 = 0 , # [doc = "1: CLK_PER divided by 4"]
DIV4 = 1 , # [doc = "2: CLK_PER divided by 8"]
DIV8 = 2 , # [doc = "3: CLK_PER divided by 16"]
DIV16 = 3 , # [doc = "4: CLK_PER divided by 32"]
DIV32 = 4 , # [doc = "5: CLK_PER divided by 64"]
DIV64 = 5 , # [doc = "6: CLK_PER divided by 128"]
DIV128 = 6 , # [doc = "7: CLK_PER divided by 256"]
DIV256 = 7 , } impl From < PRESC_A > for u8 { # [inline (always)]
fn from (variant : PRESC_A) -> Self { variant as _ } } impl PRESC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESC_A { match self . bits { 0 => PRESC_A :: DIV2 , 1 => PRESC_A :: DIV4 , 2 => PRESC_A :: DIV8 , 3 => PRESC_A :: DIV16 , 4 => PRESC_A :: DIV32 , 5 => PRESC_A :: DIV64 , 6 => PRESC_A :: DIV128 , 7 => PRESC_A :: DIV256 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESC_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESC_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESC_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESC_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESC_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESC_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESC_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESC_A :: DIV256 } } # [doc = "Field `PRESC` writer - Clock Pre-scaler"]
pub type PRESC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , PRESC_A , 3 , O > ; impl < 'a , const O : u8 > PRESC_W < 'a , O > { # [doc = "CLK_PER divided by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV2) } # [doc = "CLK_PER divided by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV4) } # [doc = "CLK_PER divided by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV8) } # [doc = "CLK_PER divided by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV16) } # [doc = "CLK_PER divided by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV32) } # [doc = "CLK_PER divided by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV64) } # [doc = "CLK_PER divided by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV128) } # [doc = "CLK_PER divided by 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV256) } } # [doc = "Field `REFSEL` reader - Reference Selection"]
pub type REFSEL_R = crate :: FieldReader < u8 , REFSEL_A > ; # [doc = "Reference Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFSEL_A { # [doc = "0: Internal reference"]
INTREF = 0 , # [doc = "1: VDD"]
VDDREF = 1 , # [doc = "2: External reference"]
VREFA = 2 , } impl From < REFSEL_A > for u8 { # [inline (always)]
fn from (variant : REFSEL_A) -> Self { variant as _ } } impl REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < REFSEL_A > { match self . bits { 0 => Some (REFSEL_A :: INTREF) , 1 => Some (REFSEL_A :: VDDREF) , 2 => Some (REFSEL_A :: VREFA) , _ => None , } } # [doc = "Checks if the value of the field is `INTREF`"]
# [inline (always)]
pub fn is_intref (& self) -> bool { * self == REFSEL_A :: INTREF } # [doc = "Checks if the value of the field is `VDDREF`"]
# [inline (always)]
pub fn is_vddref (& self) -> bool { * self == REFSEL_A :: VDDREF } # [doc = "Checks if the value of the field is `VREFA`"]
# [inline (always)]
pub fn is_vrefa (& self) -> bool { * self == REFSEL_A :: VREFA } } # [doc = "Field `REFSEL` writer - Reference Selection"]
pub type REFSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , REFSEL_A , 2 , O > ; impl < 'a , const O : u8 > REFSEL_W < 'a , O > { # [doc = "Internal reference"]
# [inline (always)]
pub fn intref (self) -> & 'a mut W { self . variant (REFSEL_A :: INTREF) } # [doc = "VDD"]
# [inline (always)]
pub fn vddref (self) -> & 'a mut W { self . variant (REFSEL_A :: VDDREF) } # [doc = "External reference"]
# [inline (always)]
pub fn vrefa (self) -> & 'a mut W { self . variant (REFSEL_A :: VREFA) } } # [doc = "Field `SAMPCAP` reader - Sample Capacitance Selection"]
pub type SAMPCAP_R = crate :: BitReader < bool > ; # [doc = "Field `SAMPCAP` writer - Sample Capacitance Selection"]
pub type SAMPCAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Pre-scaler"]
# [inline (always)]
pub fn presc (& self) -> PRESC_R { PRESC_R :: new (self . bits & 7) } # [doc = "Bits 4:5 - Reference Selection"]
# [inline (always)]
pub fn refsel (& self) -> REFSEL_R { REFSEL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Sample Capacitance Selection"]
# [inline (always)]
pub fn sampcap (& self) -> SAMPCAP_R { SAMPCAP_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Pre-scaler"]
# [inline (always)]
# [must_use]
pub fn presc (& mut self) -> PRESC_W < 0 > { PRESC_W :: new (self) } # [doc = "Bits 4:5 - Reference Selection"]
# [inline (always)]
# [must_use]
pub fn refsel (& mut self) -> REFSEL_W < 4 > { REFSEL_W :: new (self) } # [doc = "Bit 6 - Sample Capacitance Selection"]
# [inline (always)]
# [must_use]
pub fn sampcap (& mut self) -> SAMPCAP_W < 6 > { SAMPCAP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `SAMPDLY` reader - Sampling Delay Selection"]
pub type SAMPDLY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SAMPDLY` writer - Sampling Delay Selection"]
pub type SAMPDLY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLD_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `ASDV` reader - Automatic Sampling Delay Variation"]
pub type ASDV_R = crate :: BitReader < ASDV_A > ; # [doc = "Automatic Sampling Delay Variation\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ASDV_A { # [doc = "0: The Automatic Sampling Delay Variation is disabled"]
ASVOFF = 0 , # [doc = "1: The Automatic Sampling Delay Variation is enabled"]
ASVON = 1 , } impl From < ASDV_A > for bool { # [inline (always)]
fn from (variant : ASDV_A) -> Self { variant as u8 != 0 } } impl ASDV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ASDV_A { match self . bits { false => ASDV_A :: ASVOFF , true => ASDV_A :: ASVON , } } # [doc = "Checks if the value of the field is `ASVOFF`"]
# [inline (always)]
pub fn is_asvoff (& self) -> bool { * self == ASDV_A :: ASVOFF } # [doc = "Checks if the value of the field is `ASVON`"]
# [inline (always)]
pub fn is_asvon (& self) -> bool { * self == ASDV_A :: ASVON } } # [doc = "Field `ASDV` writer - Automatic Sampling Delay Variation"]
pub type ASDV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , ASDV_A , O > ; impl < 'a , const O : u8 > ASDV_W < 'a , O > { # [doc = "The Automatic Sampling Delay Variation is disabled"]
# [inline (always)]
pub fn asvoff (self) -> & 'a mut W { self . variant (ASDV_A :: ASVOFF) } # [doc = "The Automatic Sampling Delay Variation is enabled"]
# [inline (always)]
pub fn asvon (self) -> & 'a mut W { self . variant (ASDV_A :: ASVON) } } # [doc = "Field `INITDLY` reader - Initial Delay Selection"]
pub type INITDLY_R = crate :: FieldReader < u8 , INITDLY_A > ; # [doc = "Initial Delay Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INITDLY_A { # [doc = "0: Delay 0 CLK_ADC cycles"]
DLY0 = 0 , # [doc = "1: Delay 16 CLK_ADC cycles"]
DLY16 = 1 , # [doc = "2: Delay 32 CLK_ADC cycles"]
DLY32 = 2 , # [doc = "3: Delay 64 CLK_ADC cycles"]
DLY64 = 3 , # [doc = "4: Delay 128 CLK_ADC cycles"]
DLY128 = 4 , # [doc = "5: Delay 256 CLK_ADC cycles"]
DLY256 = 5 , } impl From < INITDLY_A > for u8 { # [inline (always)]
fn from (variant : INITDLY_A) -> Self { variant as _ } } impl INITDLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INITDLY_A > { match self . bits { 0 => Some (INITDLY_A :: DLY0) , 1 => Some (INITDLY_A :: DLY16) , 2 => Some (INITDLY_A :: DLY32) , 3 => Some (INITDLY_A :: DLY64) , 4 => Some (INITDLY_A :: DLY128) , 5 => Some (INITDLY_A :: DLY256) , _ => None , } } # [doc = "Checks if the value of the field is `DLY0`"]
# [inline (always)]
pub fn is_dly0 (& self) -> bool { * self == INITDLY_A :: DLY0 } # [doc = "Checks if the value of the field is `DLY16`"]
# [inline (always)]
pub fn is_dly16 (& self) -> bool { * self == INITDLY_A :: DLY16 } # [doc = "Checks if the value of the field is `DLY32`"]
# [inline (always)]
pub fn is_dly32 (& self) -> bool { * self == INITDLY_A :: DLY32 } # [doc = "Checks if the value of the field is `DLY64`"]
# [inline (always)]
pub fn is_dly64 (& self) -> bool { * self == INITDLY_A :: DLY64 } # [doc = "Checks if the value of the field is `DLY128`"]
# [inline (always)]
pub fn is_dly128 (& self) -> bool { * self == INITDLY_A :: DLY128 } # [doc = "Checks if the value of the field is `DLY256`"]
# [inline (always)]
pub fn is_dly256 (& self) -> bool { * self == INITDLY_A :: DLY256 } } # [doc = "Field `INITDLY` writer - Initial Delay Selection"]
pub type INITDLY_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , INITDLY_A , 3 , O > ; impl < 'a , const O : u8 > INITDLY_W < 'a , O > { # [doc = "Delay 0 CLK_ADC cycles"]
# [inline (always)]
pub fn dly0 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY0) } # [doc = "Delay 16 CLK_ADC cycles"]
# [inline (always)]
pub fn dly16 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY16) } # [doc = "Delay 32 CLK_ADC cycles"]
# [inline (always)]
pub fn dly32 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY32) } # [doc = "Delay 64 CLK_ADC cycles"]
# [inline (always)]
pub fn dly64 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY64) } # [doc = "Delay 128 CLK_ADC cycles"]
# [inline (always)]
pub fn dly128 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY128) } # [doc = "Delay 256 CLK_ADC cycles"]
# [inline (always)]
pub fn dly256 (self) -> & 'a mut W { self . variant (INITDLY_A :: DLY256) } } impl R { # [doc = "Bits 0:3 - Sampling Delay Selection"]
# [inline (always)]
pub fn sampdly (& self) -> SAMPDLY_R { SAMPDLY_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Automatic Sampling Delay Variation"]
# [inline (always)]
pub fn asdv (& self) -> ASDV_R { ASDV_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Initial Delay Selection"]
# [inline (always)]
pub fn initdly (& self) -> INITDLY_R { INITDLY_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Sampling Delay Selection"]
# [inline (always)]
# [must_use]
pub fn sampdly (& mut self) -> SAMPDLY_W < 0 > { SAMPDLY_W :: new (self) } # [doc = "Bit 4 - Automatic Sampling Delay Variation"]
# [inline (always)]
# [must_use]
pub fn asdv (& mut self) -> ASDV_W < 4 > { ASDV_W :: new (self) } # [doc = "Bits 5:7 - Initial Delay Selection"]
# [inline (always)]
# [must_use]
pub fn initdly (& mut self) -> INITDLY_W < 5 > { INITDLY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `WINCM` reader - Window Comparator Mode"]
pub type WINCM_R = crate :: FieldReader < u8 , WINCM_A > ; # [doc = "Window Comparator Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINCM_A { # [doc = "0: No Window Comparison"]
NONE = 0 , # [doc = "1: Below Window"]
BELOW = 1 , # [doc = "2: Above Window"]
ABOVE = 2 , # [doc = "3: Inside Window"]
INSIDE = 3 , # [doc = "4: Outside Window"]
OUTSIDE = 4 , } impl From < WINCM_A > for u8 { # [inline (always)]
fn from (variant : WINCM_A) -> Self { variant as _ } } impl WINCM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WINCM_A > { match self . bits { 0 => Some (WINCM_A :: NONE) , 1 => Some (WINCM_A :: BELOW) , 2 => Some (WINCM_A :: ABOVE) , 3 => Some (WINCM_A :: INSIDE) , 4 => Some (WINCM_A :: OUTSIDE) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == WINCM_A :: NONE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WINCM_A :: BELOW } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WINCM_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WINCM_A :: INSIDE } # [doc = "Checks if the value of the field is `OUTSIDE`"]
# [inline (always)]
pub fn is_outside (& self) -> bool { * self == WINCM_A :: OUTSIDE } } # [doc = "Field `WINCM` writer - Window Comparator Mode"]
pub type WINCM_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLE_SPEC , u8 , WINCM_A , 3 , O > ; impl < 'a , const O : u8 > WINCM_W < 'a , O > { # [doc = "No Window Comparison"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (WINCM_A :: NONE) } # [doc = "Below Window"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (WINCM_A :: BELOW) } # [doc = "Above Window"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (WINCM_A :: ABOVE) } # [doc = "Inside Window"]
# [inline (always)]
pub fn inside (self) -> & 'a mut W { self . variant (WINCM_A :: INSIDE) } # [doc = "Outside Window"]
# [inline (always)]
pub fn outside (self) -> & 'a mut W { self . variant (WINCM_A :: OUTSIDE) } } impl R { # [doc = "Bits 0:2 - Window Comparator Mode"]
# [inline (always)]
pub fn wincm (& self) -> WINCM_R { WINCM_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Window Comparator Mode"]
# [inline (always)]
# [must_use]
pub fn wincm (& mut self) -> WINCM_W < 0 > { WINCM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `STARTEI` reader - Start Event Input Enable"]
pub type STARTEI_R = crate :: BitReader < bool > ; # [doc = "Field `STARTEI` writer - Start Event Input Enable"]
pub type STARTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Start Event Input Enable"]
# [inline (always)]
pub fn startei (& self) -> STARTEI_R { STARTEI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Start Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn startei (& mut self) -> STARTEI_W < 0 > { STARTEI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESRDY` reader - Result Ready Interrupt Enable"]
pub type RESRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RESRDY` writer - Result Ready Interrupt Enable"]
pub type RESRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `WCMP` reader - Window Comparator Interrupt Enable"]
pub type WCMP_R = crate :: BitReader < bool > ; # [doc = "Field `WCMP` writer - Window Comparator Interrupt Enable"]
pub type WCMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Result Ready Interrupt Enable"]
# [inline (always)]
pub fn resrdy (& self) -> RESRDY_R { RESRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Window Comparator Interrupt Enable"]
# [inline (always)]
pub fn wcmp (& self) -> WCMP_R { WCMP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Result Ready Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn resrdy (& mut self) -> RESRDY_W < 0 > { RESRDY_W :: new (self) } # [doc = "Bit 1 - Window Comparator Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn wcmp (& mut self) -> WCMP_W < 1 > { WCMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESRDY` reader - Result Ready Flag"]
pub type RESRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RESRDY` writer - Result Ready Flag"]
pub type RESRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `WCMP` reader - Window Comparator Flag"]
pub type WCMP_R = crate :: BitReader < bool > ; # [doc = "Field `WCMP` writer - Window Comparator Flag"]
pub type WCMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Result Ready Flag"]
# [inline (always)]
pub fn resrdy (& self) -> RESRDY_R { RESRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Window Comparator Flag"]
# [inline (always)]
pub fn wcmp (& self) -> WCMP_R { WCMP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Result Ready Flag"]
# [inline (always)]
# [must_use]
pub fn resrdy (& mut self) -> RESRDY_W < 0 > { RESRDY_W :: new (self) } # [doc = "Bit 1 - Window Comparator Flag"]
# [inline (always)]
# [must_use]
pub fn wcmp (& mut self) -> WCMP_W < 1 > { WCMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MUXPOS (rw) register accessor: an alias for `Reg<MUXPOS_SPEC>`"]
pub type MUXPOS = crate :: Reg < muxpos :: MUXPOS_SPEC > ; # [doc = "Positive mux input"]
pub mod muxpos { # [doc = "Register `MUXPOS` reader"]
pub struct R (crate :: R < MUXPOS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MUXPOS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MUXPOS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MUXPOS_SPEC >) -> Self { R (reader) } } # [doc = "Register `MUXPOS` writer"]
pub struct W (crate :: W < MUXPOS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MUXPOS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MUXPOS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MUXPOS_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUXPOS` reader - Analog Channel Selection Bits"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; # [doc = "Analog Channel Selection Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: ADC input pin 0"]
AIN0 = 0 , # [doc = "1: ADC input pin 1"]
AIN1 = 1 , # [doc = "2: ADC input pin 2"]
AIN2 = 2 , # [doc = "3: ADC input pin 3"]
AIN3 = 3 , # [doc = "4: ADC input pin 4"]
AIN4 = 4 , # [doc = "5: ADC input pin 5"]
AIN5 = 5 , # [doc = "6: ADC input pin 6"]
AIN6 = 6 , # [doc = "7: ADC input pin 7"]
AIN7 = 7 , # [doc = "8: ADC input pin 8"]
AIN8 = 8 , # [doc = "9: ADC input pin 9"]
AIN9 = 9 , # [doc = "10: ADC input pin 10"]
AIN10 = 10 , # [doc = "11: ADC input pin 11"]
AIN11 = 11 , # [doc = "12: ADC input pin 12"]
AIN12 = 12 , # [doc = "13: ADC input pin 13"]
AIN13 = 13 , # [doc = "14: ADC input pin 14"]
AIN14 = 14 , # [doc = "15: ADC input pin 15"]
AIN15 = 15 , # [doc = "28: AC DAC Reference"]
DACREF = 28 , # [doc = "30: Temperature sensor"]
TEMPSENSE = 30 , # [doc = "31: 0V (GND)"]
GND = 31 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MUXPOS_A > { match self . bits { 0 => Some (MUXPOS_A :: AIN0) , 1 => Some (MUXPOS_A :: AIN1) , 2 => Some (MUXPOS_A :: AIN2) , 3 => Some (MUXPOS_A :: AIN3) , 4 => Some (MUXPOS_A :: AIN4) , 5 => Some (MUXPOS_A :: AIN5) , 6 => Some (MUXPOS_A :: AIN6) , 7 => Some (MUXPOS_A :: AIN7) , 8 => Some (MUXPOS_A :: AIN8) , 9 => Some (MUXPOS_A :: AIN9) , 10 => Some (MUXPOS_A :: AIN10) , 11 => Some (MUXPOS_A :: AIN11) , 12 => Some (MUXPOS_A :: AIN12) , 13 => Some (MUXPOS_A :: AIN13) , 14 => Some (MUXPOS_A :: AIN14) , 15 => Some (MUXPOS_A :: AIN15) , 28 => Some (MUXPOS_A :: DACREF) , 30 => Some (MUXPOS_A :: TEMPSENSE) , 31 => Some (MUXPOS_A :: GND) , _ => None , } } # [doc = "Checks if the value of the field is `AIN0`"]
# [inline (always)]
pub fn is_ain0 (& self) -> bool { * self == MUXPOS_A :: AIN0 } # [doc = "Checks if the value of the field is `AIN1`"]
# [inline (always)]
pub fn is_ain1 (& self) -> bool { * self == MUXPOS_A :: AIN1 } # [doc = "Checks if the value of the field is `AIN2`"]
# [inline (always)]
pub fn is_ain2 (& self) -> bool { * self == MUXPOS_A :: AIN2 } # [doc = "Checks if the value of the field is `AIN3`"]
# [inline (always)]
pub fn is_ain3 (& self) -> bool { * self == MUXPOS_A :: AIN3 } # [doc = "Checks if the value of the field is `AIN4`"]
# [inline (always)]
pub fn is_ain4 (& self) -> bool { * self == MUXPOS_A :: AIN4 } # [doc = "Checks if the value of the field is `AIN5`"]
# [inline (always)]
pub fn is_ain5 (& self) -> bool { * self == MUXPOS_A :: AIN5 } # [doc = "Checks if the value of the field is `AIN6`"]
# [inline (always)]
pub fn is_ain6 (& self) -> bool { * self == MUXPOS_A :: AIN6 } # [doc = "Checks if the value of the field is `AIN7`"]
# [inline (always)]
pub fn is_ain7 (& self) -> bool { * self == MUXPOS_A :: AIN7 } # [doc = "Checks if the value of the field is `AIN8`"]
# [inline (always)]
pub fn is_ain8 (& self) -> bool { * self == MUXPOS_A :: AIN8 } # [doc = "Checks if the value of the field is `AIN9`"]
# [inline (always)]
pub fn is_ain9 (& self) -> bool { * self == MUXPOS_A :: AIN9 } # [doc = "Checks if the value of the field is `AIN10`"]
# [inline (always)]
pub fn is_ain10 (& self) -> bool { * self == MUXPOS_A :: AIN10 } # [doc = "Checks if the value of the field is `AIN11`"]
# [inline (always)]
pub fn is_ain11 (& self) -> bool { * self == MUXPOS_A :: AIN11 } # [doc = "Checks if the value of the field is `AIN12`"]
# [inline (always)]
pub fn is_ain12 (& self) -> bool { * self == MUXPOS_A :: AIN12 } # [doc = "Checks if the value of the field is `AIN13`"]
# [inline (always)]
pub fn is_ain13 (& self) -> bool { * self == MUXPOS_A :: AIN13 } # [doc = "Checks if the value of the field is `AIN14`"]
# [inline (always)]
pub fn is_ain14 (& self) -> bool { * self == MUXPOS_A :: AIN14 } # [doc = "Checks if the value of the field is `AIN15`"]
# [inline (always)]
pub fn is_ain15 (& self) -> bool { * self == MUXPOS_A :: AIN15 } # [doc = "Checks if the value of the field is `DACREF`"]
# [inline (always)]
pub fn is_dacref (& self) -> bool { * self == MUXPOS_A :: DACREF } # [doc = "Checks if the value of the field is `TEMPSENSE`"]
# [inline (always)]
pub fn is_tempsense (& self) -> bool { * self == MUXPOS_A :: TEMPSENSE } # [doc = "Checks if the value of the field is `GND`"]
# [inline (always)]
pub fn is_gnd (& self) -> bool { * self == MUXPOS_A :: GND } } # [doc = "Field `MUXPOS` writer - Analog Channel Selection Bits"]
pub type MUXPOS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , MUXPOS_SPEC , u8 , MUXPOS_A , 5 , O > ; impl < 'a , const O : u8 > MUXPOS_W < 'a , O > { # [doc = "ADC input pin 0"]
# [inline (always)]
pub fn ain0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN0) } # [doc = "ADC input pin 1"]
# [inline (always)]
pub fn ain1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN1) } # [doc = "ADC input pin 2"]
# [inline (always)]
pub fn ain2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN2) } # [doc = "ADC input pin 3"]
# [inline (always)]
pub fn ain3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN3) } # [doc = "ADC input pin 4"]
# [inline (always)]
pub fn ain4 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN4) } # [doc = "ADC input pin 5"]
# [inline (always)]
pub fn ain5 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN5) } # [doc = "ADC input pin 6"]
# [inline (always)]
pub fn ain6 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN6) } # [doc = "ADC input pin 7"]
# [inline (always)]
pub fn ain7 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN7) } # [doc = "ADC input pin 8"]
# [inline (always)]
pub fn ain8 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN8) } # [doc = "ADC input pin 9"]
# [inline (always)]
pub fn ain9 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN9) } # [doc = "ADC input pin 10"]
# [inline (always)]
pub fn ain10 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN10) } # [doc = "ADC input pin 11"]
# [inline (always)]
pub fn ain11 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN11) } # [doc = "ADC input pin 12"]
# [inline (always)]
pub fn ain12 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN12) } # [doc = "ADC input pin 13"]
# [inline (always)]
pub fn ain13 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN13) } # [doc = "ADC input pin 14"]
# [inline (always)]
pub fn ain14 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN14) } # [doc = "ADC input pin 15"]
# [inline (always)]
pub fn ain15 (self) -> & 'a mut W { self . variant (MUXPOS_A :: AIN15) } # [doc = "AC DAC Reference"]
# [inline (always)]
pub fn dacref (self) -> & 'a mut W { self . variant (MUXPOS_A :: DACREF) } # [doc = "Temperature sensor"]
# [inline (always)]
pub fn tempsense (self) -> & 'a mut W { self . variant (MUXPOS_A :: TEMPSENSE) } # [doc = "0V (GND)"]
# [inline (always)]
pub fn gnd (self) -> & 'a mut W { self . variant (MUXPOS_A :: GND) } } impl R { # [doc = "Bits 0:4 - Analog Channel Selection Bits"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new (self . bits & 0x1f) } } impl W { # [doc = "Bits 0:4 - Analog Channel Selection Bits"]
# [inline (always)]
# [must_use]
pub fn muxpos (& mut self) -> MUXPOS_W < 0 > { MUXPOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Positive mux input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [muxpos](index.html) module"]
pub struct MUXPOS_SPEC ; impl crate :: RegisterSpec for MUXPOS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [muxpos::R](R) reader structure"]
impl crate :: Readable for MUXPOS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [muxpos::W](W) writer structure"]
impl crate :: Writable for MUXPOS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MUXPOS to value 0"]
impl crate :: Resettable for MUXPOS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RES (r) register accessor: an alias for `Reg<RES_SPEC>`"]
pub type RES = crate :: Reg < res :: RES_SPEC > ; # [doc = "ADC Accumulator Result"]
pub mod res { # [doc = "Register `RES` reader"]
pub struct R (crate :: R < RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RES_SPEC >) -> Self { R (reader) } } # [doc = "ADC Accumulator Result\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [res](index.html) module"]
pub struct RES_SPEC ; impl crate :: RegisterSpec for RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [res::R](R) reader structure"]
impl crate :: Readable for RES_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RES to value 0"]
impl crate :: Resettable for RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SAMPCTRL (rw) register accessor: an alias for `Reg<SAMPCTRL_SPEC>`"]
pub type SAMPCTRL = crate :: Reg < sampctrl :: SAMPCTRL_SPEC > ; # [doc = "Sample Control"]
pub mod sampctrl { # [doc = "Register `SAMPCTRL` reader"]
pub struct R (crate :: R < SAMPCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SAMPCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SAMPCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SAMPCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SAMPCTRL` writer"]
pub struct W (crate :: W < SAMPCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SAMPCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SAMPCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SAMPCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SAMPLEN` reader - Sample lenght"]
pub type SAMPLEN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SAMPLEN` writer - Sample lenght"]
pub type SAMPLEN_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SAMPCTRL_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bits 0:4 - Sample lenght"]
# [inline (always)]
pub fn samplen (& self) -> SAMPLEN_R { SAMPLEN_R :: new (self . bits & 0x1f) } } impl W { # [doc = "Bits 0:4 - Sample lenght"]
# [inline (always)]
# [must_use]
pub fn samplen (& mut self) -> SAMPLEN_W < 0 > { SAMPLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sample Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sampctrl](index.html) module"]
pub struct SAMPCTRL_SPEC ; impl crate :: RegisterSpec for SAMPCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sampctrl::R](R) reader structure"]
impl crate :: Readable for SAMPCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sampctrl::W](W) writer structure"]
impl crate :: Writable for SAMPCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SAMPCTRL to value 0"]
impl crate :: Resettable for SAMPCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Data"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } # [doc = "Field `TEMP` reader - Temporary"]
pub type TEMP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TEMP` writer - Temporary"]
pub type TEMP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TEMP_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Temporary"]
# [inline (always)]
pub fn temp (& self) -> TEMP_R { TEMP_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Temporary"]
# [inline (always)]
# [must_use]
pub fn temp (& mut self) -> TEMP_W < 0 > { TEMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WINHT (rw) register accessor: an alias for `Reg<WINHT_SPEC>`"]
pub type WINHT = crate :: Reg < winht :: WINHT_SPEC > ; # [doc = "Window comparator high threshold"]
pub mod winht { # [doc = "Register `WINHT` reader"]
pub struct R (crate :: R < WINHT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINHT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINHT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINHT_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINHT` writer"]
pub struct W (crate :: W < WINHT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINHT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINHT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINHT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Window comparator high threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winht](index.html) module"]
pub struct WINHT_SPEC ; impl crate :: RegisterSpec for WINHT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [winht::R](R) reader structure"]
impl crate :: Readable for WINHT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winht::W](W) writer structure"]
impl crate :: Writable for WINHT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WINHT to value 0"]
impl crate :: Resettable for WINHT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WINLT (rw) register accessor: an alias for `Reg<WINLT_SPEC>`"]
pub type WINLT = crate :: Reg < winlt :: WINLT_SPEC > ; # [doc = "Window comparator low threshold"]
pub mod winlt { # [doc = "Register `WINLT` reader"]
pub struct R (crate :: R < WINLT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINLT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINLT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINLT_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINLT` writer"]
pub struct W (crate :: W < WINLT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINLT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINLT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINLT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Window comparator low threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winlt](index.html) module"]
pub struct WINLT_SPEC ; impl crate :: RegisterSpec for WINLT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [winlt::R](R) reader structure"]
impl crate :: Readable for WINLT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winlt::W](W) writer structure"]
impl crate :: Writable for WINLT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WINLT to value 0"]
impl crate :: Resettable for WINLT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Bod interface"]
pub struct BOD { _marker : PhantomData < * const () > } unsafe impl Send for BOD { } impl BOD { # [doc = r"Pointer to the register block"]
pub const PTR : * const bod :: RegisterBlock = 0x80 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const bod :: RegisterBlock { Self :: PTR } } impl Deref for BOD { type Target = bod :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for BOD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("BOD") . finish () } } # [doc = "Bod interface"]
pub mod bod { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , _reserved2 : [u8 ; 0x06]
, # [doc = "0x08 - Voltage level monitor Control"]
pub vlmctrla : VLMCTRLA , # [doc = "0x09 - Voltage level monitor interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x0a - Voltage level monitor interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0b - Voltage level monitor status"]
pub status : STATUS , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SLEEP` reader - Operation in sleep mode"]
pub type SLEEP_R = crate :: FieldReader < u8 , SLEEP_A > ; # [doc = "Operation in sleep mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SLEEP_A { # [doc = "0: Disabled"]
DIS = 0 , # [doc = "1: Enabled"]
ENABLED = 1 , # [doc = "2: Sampled"]
SAMPLED = 2 , } impl From < SLEEP_A > for u8 { # [inline (always)]
fn from (variant : SLEEP_A) -> Self { variant as _ } } impl SLEEP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SLEEP_A > { match self . bits { 0 => Some (SLEEP_A :: DIS) , 1 => Some (SLEEP_A :: ENABLED) , 2 => Some (SLEEP_A :: SAMPLED) , _ => None , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == SLEEP_A :: DIS } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * self == SLEEP_A :: ENABLED } # [doc = "Checks if the value of the field is `SAMPLED`"]
# [inline (always)]
pub fn is_sampled (& self) -> bool { * self == SLEEP_A :: SAMPLED } } # [doc = "Field `SLEEP` writer - Operation in sleep mode"]
pub type SLEEP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , SLEEP_A , 2 , O > ; impl < 'a , const O : u8 > SLEEP_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (SLEEP_A :: DIS) } # [doc = "Enabled"]
# [inline (always)]
pub fn enabled (self) -> & 'a mut W { self . variant (SLEEP_A :: ENABLED) } # [doc = "Sampled"]
# [inline (always)]
pub fn sampled (self) -> & 'a mut W { self . variant (SLEEP_A :: SAMPLED) } } # [doc = "Field `ACTIVE` reader - Operation in active mode"]
pub type ACTIVE_R = crate :: FieldReader < u8 , ACTIVE_A > ; # [doc = "Operation in active mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ACTIVE_A { # [doc = "0: Disabled"]
DIS = 0 , # [doc = "1: Enabled"]
ENABLED = 1 , # [doc = "2: Sampled"]
SAMPLED = 2 , # [doc = "3: Enabled with wake-up halted until BOD is ready"]
ENWAKE = 3 , } impl From < ACTIVE_A > for u8 { # [inline (always)]
fn from (variant : ACTIVE_A) -> Self { variant as _ } } impl ACTIVE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACTIVE_A { match self . bits { 0 => ACTIVE_A :: DIS , 1 => ACTIVE_A :: ENABLED , 2 => ACTIVE_A :: SAMPLED , 3 => ACTIVE_A :: ENWAKE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == ACTIVE_A :: DIS } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * self == ACTIVE_A :: ENABLED } # [doc = "Checks if the value of the field is `SAMPLED`"]
# [inline (always)]
pub fn is_sampled (& self) -> bool { * self == ACTIVE_A :: SAMPLED } # [doc = "Checks if the value of the field is `ENWAKE`"]
# [inline (always)]
pub fn is_enwake (& self) -> bool { * self == ACTIVE_A :: ENWAKE } } # [doc = "Field `SAMPFREQ` reader - Sample frequency"]
pub type SAMPFREQ_R = crate :: BitReader < SAMPFREQ_A > ; # [doc = "Sample frequency\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SAMPFREQ_A { # [doc = "0: 1kHz sampling frequency"]
_1KHZ = 0 , # [doc = "1: 125Hz sampling frequency"]
_125HZ = 1 , } impl From < SAMPFREQ_A > for bool { # [inline (always)]
fn from (variant : SAMPFREQ_A) -> Self { variant as u8 != 0 } } impl SAMPFREQ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SAMPFREQ_A { match self . bits { false => SAMPFREQ_A :: _1KHZ , true => SAMPFREQ_A :: _125HZ , } } # [doc = "Checks if the value of the field is `_1KHZ`"]
# [inline (always)]
pub fn is_1khz (& self) -> bool { * self == SAMPFREQ_A :: _1KHZ } # [doc = "Checks if the value of the field is `_125HZ`"]
# [inline (always)]
pub fn is_125hz (& self) -> bool { * self == SAMPFREQ_A :: _125HZ } } impl R { # [doc = "Bits 0:1 - Operation in sleep mode"]
# [inline (always)]
pub fn sleep (& self) -> SLEEP_R { SLEEP_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Operation in active mode"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Sample frequency"]
# [inline (always)]
pub fn sampfreq (& self) -> SAMPFREQ_R { SAMPFREQ_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Operation in sleep mode"]
# [inline (always)]
# [must_use]
pub fn sleep (& mut self) -> SLEEP_W < 0 > { SLEEP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL` reader - Bod level"]
pub type LVL_R = crate :: FieldReader < u8 , LVL_A > ; # [doc = "Bod level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LVL_A { # [doc = "0: 1.8 V"]
BODLEVEL0 = 0 , # [doc = "2: 2.6 V"]
BODLEVEL2 = 2 , # [doc = "7: 4.2 V"]
BODLEVEL7 = 7 , } impl From < LVL_A > for u8 { # [inline (always)]
fn from (variant : LVL_A) -> Self { variant as _ } } impl LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LVL_A > { match self . bits { 0 => Some (LVL_A :: BODLEVEL0) , 2 => Some (LVL_A :: BODLEVEL2) , 7 => Some (LVL_A :: BODLEVEL7) , _ => None , } } # [doc = "Checks if the value of the field is `BODLEVEL0`"]
# [inline (always)]
pub fn is_bodlevel0 (& self) -> bool { * self == LVL_A :: BODLEVEL0 } # [doc = "Checks if the value of the field is `BODLEVEL2`"]
# [inline (always)]
pub fn is_bodlevel2 (& self) -> bool { * self == LVL_A :: BODLEVEL2 } # [doc = "Checks if the value of the field is `BODLEVEL7`"]
# [inline (always)]
pub fn is_bodlevel7 (& self) -> bool { * self == LVL_A :: BODLEVEL7 } } impl R { # [doc = "Bits 0:2 - Bod level"]
# [inline (always)]
pub fn lvl (& self) -> LVL_R { LVL_R :: new (self . bits & 7) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Voltage level monitor interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `VLMIE` reader - voltage level monitor interrrupt enable"]
pub type VLMIE_R = crate :: BitReader < bool > ; # [doc = "Field `VLMIE` writer - voltage level monitor interrrupt enable"]
pub type VLMIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `VLMCFG` reader - Configuration"]
pub type VLMCFG_R = crate :: FieldReader < u8 , VLMCFG_A > ; # [doc = "Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VLMCFG_A { # [doc = "0: Interrupt when supply goes below VLM level"]
BELOW = 0 , # [doc = "1: Interrupt when supply goes above VLM level"]
ABOVE = 1 , # [doc = "2: Interrupt when supply crosses VLM level"]
CROSS = 2 , } impl From < VLMCFG_A > for u8 { # [inline (always)]
fn from (variant : VLMCFG_A) -> Self { variant as _ } } impl VLMCFG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < VLMCFG_A > { match self . bits { 0 => Some (VLMCFG_A :: BELOW) , 1 => Some (VLMCFG_A :: ABOVE) , 2 => Some (VLMCFG_A :: CROSS) , _ => None , } } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == VLMCFG_A :: BELOW } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == VLMCFG_A :: ABOVE } # [doc = "Checks if the value of the field is `CROSS`"]
# [inline (always)]
pub fn is_cross (& self) -> bool { * self == VLMCFG_A :: CROSS } } # [doc = "Field `VLMCFG` writer - Configuration"]
pub type VLMCFG_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , INTCTRL_SPEC , u8 , VLMCFG_A , 2 , O > ; impl < 'a , const O : u8 > VLMCFG_W < 'a , O > { # [doc = "Interrupt when supply goes below VLM level"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (VLMCFG_A :: BELOW) } # [doc = "Interrupt when supply goes above VLM level"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (VLMCFG_A :: ABOVE) } # [doc = "Interrupt when supply crosses VLM level"]
# [inline (always)]
pub fn cross (self) -> & 'a mut W { self . variant (VLMCFG_A :: CROSS) } } impl R { # [doc = "Bit 0 - voltage level monitor interrrupt enable"]
# [inline (always)]
pub fn vlmie (& self) -> VLMIE_R { VLMIE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Configuration"]
# [inline (always)]
pub fn vlmcfg (& self) -> VLMCFG_R { VLMCFG_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - voltage level monitor interrrupt enable"]
# [inline (always)]
# [must_use]
pub fn vlmie (& mut self) -> VLMIE_W < 0 > { VLMIE_W :: new (self) } # [doc = "Bits 1:2 - Configuration"]
# [inline (always)]
# [must_use]
pub fn vlmcfg (& mut self) -> VLMCFG_W < 1 > { VLMCFG_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage level monitor interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Voltage level monitor interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `VLMIF` reader - Voltage level monitor interrupt flag"]
pub type VLMIF_R = crate :: BitReader < bool > ; # [doc = "Field `VLMIF` writer - Voltage level monitor interrupt flag"]
pub type VLMIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Voltage level monitor interrupt flag"]
# [inline (always)]
pub fn vlmif (& self) -> VLMIF_R { VLMIF_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Voltage level monitor interrupt flag"]
# [inline (always)]
# [must_use]
pub fn vlmif (& mut self) -> VLMIF_W < 0 > { VLMIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage level monitor interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Voltage level monitor status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `VLMS` reader - Voltage level monitor status"]
pub type VLMS_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Voltage level monitor status"]
# [inline (always)]
pub fn vlms (& self) -> VLMS_R { VLMS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage level monitor status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VLMCTRLA (rw) register accessor: an alias for `Reg<VLMCTRLA_SPEC>`"]
pub type VLMCTRLA = crate :: Reg < vlmctrla :: VLMCTRLA_SPEC > ; # [doc = "Voltage level monitor Control"]
pub mod vlmctrla { # [doc = "Register `VLMCTRLA` reader"]
pub struct R (crate :: R < VLMCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VLMCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VLMCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VLMCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `VLMCTRLA` writer"]
pub struct W (crate :: W < VLMCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < VLMCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < VLMCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < VLMCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `VLMLVL` reader - voltage level monitor level"]
pub type VLMLVL_R = crate :: FieldReader < u8 , VLMLVL_A > ; # [doc = "voltage level monitor level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VLMLVL_A { # [doc = "0: VLM threshold 5% above BOD level"]
_5ABOVE = 0 , # [doc = "1: VLM threshold 15% above BOD level"]
_15ABOVE = 1 , # [doc = "2: VLM threshold 25% above BOD level"]
_25ABOVE = 2 , } impl From < VLMLVL_A > for u8 { # [inline (always)]
fn from (variant : VLMLVL_A) -> Self { variant as _ } } impl VLMLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < VLMLVL_A > { match self . bits { 0 => Some (VLMLVL_A :: _5ABOVE) , 1 => Some (VLMLVL_A :: _15ABOVE) , 2 => Some (VLMLVL_A :: _25ABOVE) , _ => None , } } # [doc = "Checks if the value of the field is `_5ABOVE`"]
# [inline (always)]
pub fn is_5above (& self) -> bool { * self == VLMLVL_A :: _5ABOVE } # [doc = "Checks if the value of the field is `_15ABOVE`"]
# [inline (always)]
pub fn is_15above (& self) -> bool { * self == VLMLVL_A :: _15ABOVE } # [doc = "Checks if the value of the field is `_25ABOVE`"]
# [inline (always)]
pub fn is_25above (& self) -> bool { * self == VLMLVL_A :: _25ABOVE } } # [doc = "Field `VLMLVL` writer - voltage level monitor level"]
pub type VLMLVL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , VLMCTRLA_SPEC , u8 , VLMLVL_A , 2 , O > ; impl < 'a , const O : u8 > VLMLVL_W < 'a , O > { # [doc = "VLM threshold 5% above BOD level"]
# [inline (always)]
pub fn _5above (self) -> & 'a mut W { self . variant (VLMLVL_A :: _5ABOVE) } # [doc = "VLM threshold 15% above BOD level"]
# [inline (always)]
pub fn _15above (self) -> & 'a mut W { self . variant (VLMLVL_A :: _15ABOVE) } # [doc = "VLM threshold 25% above BOD level"]
# [inline (always)]
pub fn _25above (self) -> & 'a mut W { self . variant (VLMLVL_A :: _25ABOVE) } } impl R { # [doc = "Bits 0:1 - voltage level monitor level"]
# [inline (always)]
pub fn vlmlvl (& self) -> VLMLVL_R { VLMLVL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - voltage level monitor level"]
# [inline (always)]
# [must_use]
pub fn vlmlvl (& mut self) -> VLMLVL_W < 0 > { VLMLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage level monitor Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vlmctrla](index.html) module"]
pub struct VLMCTRLA_SPEC ; impl crate :: RegisterSpec for VLMCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [vlmctrla::R](R) reader structure"]
impl crate :: Readable for VLMCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [vlmctrla::W](W) writer structure"]
impl crate :: Writable for VLMCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VLMCTRLA to value 0"]
impl crate :: Resettable for VLMCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Configurable Custom Logic"]
pub struct CCL { _marker : PhantomData < * const () > } unsafe impl Send for CCL { } impl CCL { # [doc = r"Pointer to the register block"]
pub const PTR : * const ccl :: RegisterBlock = 0x01c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ccl :: RegisterBlock { Self :: PTR } } impl Deref for CCL { type Target = ccl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CCL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CCL") . finish () } } # [doc = "Configurable Custom Logic"]
pub mod ccl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Sequential Control 0"]
pub seqctrl0 : SEQCTRL0 , # [doc = "0x02 - Sequential Control 1"]
pub seqctrl1 : SEQCTRL1 , _reserved3 : [u8 ; 0x02]
, # [doc = "0x05 - Interrupt Control 0"]
pub intctrl0 : INTCTRL0 , _reserved4 : [u8 ; 0x01]
, # [doc = "0x07 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x08 - LUT Control 0 A"]
pub lut0ctrla : LUT0CTRLA , # [doc = "0x09 - LUT Control 0 B"]
pub lut0ctrlb : LUT0CTRLB , # [doc = "0x0a - LUT Control 0 C"]
pub lut0ctrlc : LUT0CTRLC , # [doc = "0x0b - Truth 0"]
pub truth0 : TRUTH0 , # [doc = "0x0c - LUT Control 1 A"]
pub lut1ctrla : LUT1CTRLA , # [doc = "0x0d - LUT Control 1 B"]
pub lut1ctrlb : LUT1CTRLB , # [doc = "0x0e - LUT Control 1 C"]
pub lut1ctrlc : LUT1CTRLC , # [doc = "0x0f - Truth 1"]
pub truth1 : TRUTH1 , # [doc = "0x10 - LUT Control 2 A"]
pub lut2ctrla : LUT2CTRLA , # [doc = "0x11 - LUT Control 2 B"]
pub lut2ctrlb : LUT2CTRLB , # [doc = "0x12 - LUT Control 2 C"]
pub lut2ctrlc : LUT2CTRLC , # [doc = "0x13 - Truth 2"]
pub truth2 : TRUTH2 , # [doc = "0x14 - LUT Control 3 A"]
pub lut3ctrla : LUT3CTRLA , # [doc = "0x15 - LUT Control 3 B"]
pub lut3ctrlb : LUT3CTRLB , # [doc = "0x16 - LUT Control 3 C"]
pub lut3ctrlc : LUT3CTRLC , # [doc = "0x17 - Truth 3"]
pub truth3 : TRUTH3 , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 6 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL0 (rw) register accessor: an alias for `Reg<INTCTRL0_SPEC>`"]
pub type INTCTRL0 = crate :: Reg < intctrl0 :: INTCTRL0_SPEC > ; # [doc = "Interrupt Control 0"]
pub mod intctrl0 { # [doc = "Register `INTCTRL0` reader"]
pub struct R (crate :: R < INTCTRL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL0` writer"]
pub struct W (crate :: W < INTCTRL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTMODE0` reader - Interrupt Mode for LUT0"]
pub type INTMODE0_R = crate :: FieldReader < u8 , INTMODE0_A > ; # [doc = "Interrupt Mode for LUT0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE0_A { # [doc = "0: Interrupt disabled"]
INTDISABLE = 0 , # [doc = "1: Sense rising edge"]
RISING = 1 , # [doc = "2: Sense falling edge"]
FALLING = 2 , # [doc = "3: Sense both edges"]
BOTH = 3 , } impl From < INTMODE0_A > for u8 { # [inline (always)]
fn from (variant : INTMODE0_A) -> Self { variant as _ } } impl INTMODE0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTMODE0_A { match self . bits { 0 => INTMODE0_A :: INTDISABLE , 1 => INTMODE0_A :: RISING , 2 => INTMODE0_A :: FALLING , 3 => INTMODE0_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == INTMODE0_A :: INTDISABLE } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTMODE0_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTMODE0_A :: FALLING } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == INTMODE0_A :: BOTH } } # [doc = "Field `INTMODE0` writer - Interrupt Mode for LUT0"]
pub type INTMODE0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL0_SPEC , u8 , INTMODE0_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE0_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (INTMODE0_A :: INTDISABLE) } # [doc = "Sense rising edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTMODE0_A :: RISING) } # [doc = "Sense falling edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTMODE0_A :: FALLING) } # [doc = "Sense both edges"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (INTMODE0_A :: BOTH) } } # [doc = "Field `INTMODE1` reader - Interrupt Mode for LUT1"]
pub type INTMODE1_R = crate :: FieldReader < u8 , INTMODE1_A > ; # [doc = "Interrupt Mode for LUT1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE1_A { # [doc = "0: Interrupt disabled"]
INTDISABLE = 0 , # [doc = "1: Sense rising edge"]
RISING = 1 , # [doc = "2: Sense falling edge"]
FALLING = 2 , # [doc = "3: Sense both edges"]
BOTH = 3 , } impl From < INTMODE1_A > for u8 { # [inline (always)]
fn from (variant : INTMODE1_A) -> Self { variant as _ } } impl INTMODE1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTMODE1_A { match self . bits { 0 => INTMODE1_A :: INTDISABLE , 1 => INTMODE1_A :: RISING , 2 => INTMODE1_A :: FALLING , 3 => INTMODE1_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == INTMODE1_A :: INTDISABLE } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTMODE1_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTMODE1_A :: FALLING } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == INTMODE1_A :: BOTH } } # [doc = "Field `INTMODE1` writer - Interrupt Mode for LUT1"]
pub type INTMODE1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL0_SPEC , u8 , INTMODE1_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE1_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (INTMODE1_A :: INTDISABLE) } # [doc = "Sense rising edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTMODE1_A :: RISING) } # [doc = "Sense falling edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTMODE1_A :: FALLING) } # [doc = "Sense both edges"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (INTMODE1_A :: BOTH) } } # [doc = "Field `INTMODE2` reader - Interrupt Mode for LUT2"]
pub type INTMODE2_R = crate :: FieldReader < u8 , INTMODE2_A > ; # [doc = "Interrupt Mode for LUT2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE2_A { # [doc = "0: Interrupt disabled"]
INTDISABLE = 0 , # [doc = "1: Sense rising edge"]
RISING = 1 , # [doc = "2: Sense falling edge"]
FALLING = 2 , # [doc = "3: Sense both edges"]
BOTH = 3 , } impl From < INTMODE2_A > for u8 { # [inline (always)]
fn from (variant : INTMODE2_A) -> Self { variant as _ } } impl INTMODE2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTMODE2_A { match self . bits { 0 => INTMODE2_A :: INTDISABLE , 1 => INTMODE2_A :: RISING , 2 => INTMODE2_A :: FALLING , 3 => INTMODE2_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == INTMODE2_A :: INTDISABLE } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTMODE2_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTMODE2_A :: FALLING } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == INTMODE2_A :: BOTH } } # [doc = "Field `INTMODE2` writer - Interrupt Mode for LUT2"]
pub type INTMODE2_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL0_SPEC , u8 , INTMODE2_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE2_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (INTMODE2_A :: INTDISABLE) } # [doc = "Sense rising edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTMODE2_A :: RISING) } # [doc = "Sense falling edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTMODE2_A :: FALLING) } # [doc = "Sense both edges"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (INTMODE2_A :: BOTH) } } # [doc = "Field `INTMODE3` reader - Interrupt Mode for LUT3"]
pub type INTMODE3_R = crate :: FieldReader < u8 , INTMODE3_A > ; # [doc = "Interrupt Mode for LUT3\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE3_A { # [doc = "0: Interrupt disabled"]
INTDISABLE = 0 , # [doc = "1: Sense rising edge"]
RISING = 1 , # [doc = "2: Sense falling edge"]
FALLING = 2 , # [doc = "3: Sense both edges"]
BOTH = 3 , } impl From < INTMODE3_A > for u8 { # [inline (always)]
fn from (variant : INTMODE3_A) -> Self { variant as _ } } impl INTMODE3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTMODE3_A { match self . bits { 0 => INTMODE3_A :: INTDISABLE , 1 => INTMODE3_A :: RISING , 2 => INTMODE3_A :: FALLING , 3 => INTMODE3_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == INTMODE3_A :: INTDISABLE } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTMODE3_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTMODE3_A :: FALLING } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == INTMODE3_A :: BOTH } } # [doc = "Field `INTMODE3` writer - Interrupt Mode for LUT3"]
pub type INTMODE3_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL0_SPEC , u8 , INTMODE3_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE3_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (INTMODE3_A :: INTDISABLE) } # [doc = "Sense rising edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTMODE3_A :: RISING) } # [doc = "Sense falling edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTMODE3_A :: FALLING) } # [doc = "Sense both edges"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (INTMODE3_A :: BOTH) } } impl R { # [doc = "Bits 0:1 - Interrupt Mode for LUT0"]
# [inline (always)]
pub fn intmode0 (& self) -> INTMODE0_R { INTMODE0_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Interrupt Mode for LUT1"]
# [inline (always)]
pub fn intmode1 (& self) -> INTMODE1_R { INTMODE1_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Interrupt Mode for LUT2"]
# [inline (always)]
pub fn intmode2 (& self) -> INTMODE2_R { INTMODE2_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Interrupt Mode for LUT3"]
# [inline (always)]
pub fn intmode3 (& self) -> INTMODE3_R { INTMODE3_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Interrupt Mode for LUT0"]
# [inline (always)]
# [must_use]
pub fn intmode0 (& mut self) -> INTMODE0_W < 0 > { INTMODE0_W :: new (self) } # [doc = "Bits 2:3 - Interrupt Mode for LUT1"]
# [inline (always)]
# [must_use]
pub fn intmode1 (& mut self) -> INTMODE1_W < 2 > { INTMODE1_W :: new (self) } # [doc = "Bits 4:5 - Interrupt Mode for LUT2"]
# [inline (always)]
# [must_use]
pub fn intmode2 (& mut self) -> INTMODE2_W < 4 > { INTMODE2_W :: new (self) } # [doc = "Bits 6:7 - Interrupt Mode for LUT3"]
# [inline (always)]
# [must_use]
pub fn intmode3 (& mut self) -> INTMODE3_W < 6 > { INTMODE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl0](index.html) module"]
pub struct INTCTRL0_SPEC ; impl crate :: RegisterSpec for INTCTRL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl0::R](R) reader structure"]
impl crate :: Readable for INTCTRL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl0::W](W) writer structure"]
impl crate :: Writable for INTCTRL0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL0 to value 0"]
impl crate :: Resettable for INTCTRL0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Interrupt Flags"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Interrupt Flags"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Interrupt Flags"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Interrupt Flags"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT0CTRLA (rw) register accessor: an alias for `Reg<LUT0CTRLA_SPEC>`"]
pub type LUT0CTRLA = crate :: Reg < lut0ctrla :: LUT0CTRLA_SPEC > ; # [doc = "LUT Control 0 A"]
pub mod lut0ctrla { # [doc = "Register `LUT0CTRLA` reader"]
pub struct R (crate :: R < LUT0CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT0CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT0CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT0CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT0CTRLA` writer"]
pub struct W (crate :: W < LUT0CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT0CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT0CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT0CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - LUT Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - LUT Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT0CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSRC` reader - Clock Source Selection"]
pub type CLKSRC_R = crate :: FieldReader < u8 , CLKSRC_A > ; # [doc = "Clock Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSRC_A { # [doc = "0: CLK_PER is clocking the LUT"]
CLKPER = 0 , # [doc = "1: IN\\[2\\]
is clocking the LUT"]
IN2 = 1 , # [doc = "4: 20MHz oscillator before prescaler is clocking the LUT"]
OSC20M = 4 , # [doc = "5: 32kHz oscillator is clocking the LUT"]
OSCULP32K = 5 , # [doc = "6: 32kHz oscillator after DIV32 is clocking the LUT"]
OSCULP1K = 6 , } impl From < CLKSRC_A > for u8 { # [inline (always)]
fn from (variant : CLKSRC_A) -> Self { variant as _ } } impl CLKSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSRC_A > { match self . bits { 0 => Some (CLKSRC_A :: CLKPER) , 1 => Some (CLKSRC_A :: IN2) , 4 => Some (CLKSRC_A :: OSC20M) , 5 => Some (CLKSRC_A :: OSCULP32K) , 6 => Some (CLKSRC_A :: OSCULP1K) , _ => None , } } # [doc = "Checks if the value of the field is `CLKPER`"]
# [inline (always)]
pub fn is_clkper (& self) -> bool { * self == CLKSRC_A :: CLKPER } # [doc = "Checks if the value of the field is `IN2`"]
# [inline (always)]
pub fn is_in2 (& self) -> bool { * self == CLKSRC_A :: IN2 } # [doc = "Checks if the value of the field is `OSC20M`"]
# [inline (always)]
pub fn is_osc20m (& self) -> bool { * self == CLKSRC_A :: OSC20M } # [doc = "Checks if the value of the field is `OSCULP32K`"]
# [inline (always)]
pub fn is_osculp32k (& self) -> bool { * self == CLKSRC_A :: OSCULP32K } # [doc = "Checks if the value of the field is `OSCULP1K`"]
# [inline (always)]
pub fn is_osculp1k (& self) -> bool { * self == CLKSRC_A :: OSCULP1K } } # [doc = "Field `CLKSRC` writer - Clock Source Selection"]
pub type CLKSRC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLA_SPEC , u8 , CLKSRC_A , 3 , O > ; impl < 'a , const O : u8 > CLKSRC_W < 'a , O > { # [doc = "CLK_PER is clocking the LUT"]
# [inline (always)]
pub fn clkper (self) -> & 'a mut W { self . variant (CLKSRC_A :: CLKPER) } # [doc = "IN\\[2\\]
is clocking the LUT"]
# [inline (always)]
pub fn in2 (self) -> & 'a mut W { self . variant (CLKSRC_A :: IN2) } # [doc = "20MHz oscillator before prescaler is clocking the LUT"]
# [inline (always)]
pub fn osc20m (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSC20M) } # [doc = "32kHz oscillator is clocking the LUT"]
# [inline (always)]
pub fn osculp32k (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSCULP32K) } # [doc = "32kHz oscillator after DIV32 is clocking the LUT"]
# [inline (always)]
pub fn osculp1k (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSCULP1K) } } # [doc = "Field `FILTSEL` reader - Filter Selection"]
pub type FILTSEL_R = crate :: FieldReader < u8 , FILTSEL_A > ; # [doc = "Filter Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FILTSEL_A { # [doc = "0: Filter disabled"]
DISABLE = 0 , # [doc = "1: Synchronizer enabled"]
SYNCH = 1 , # [doc = "2: Filter enabled"]
FILTER = 2 , } impl From < FILTSEL_A > for u8 { # [inline (always)]
fn from (variant : FILTSEL_A) -> Self { variant as _ } } impl FILTSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FILTSEL_A > { match self . bits { 0 => Some (FILTSEL_A :: DISABLE) , 1 => Some (FILTSEL_A :: SYNCH) , 2 => Some (FILTSEL_A :: FILTER) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FILTSEL_A :: DISABLE } # [doc = "Checks if the value of the field is `SYNCH`"]
# [inline (always)]
pub fn is_synch (& self) -> bool { * self == FILTSEL_A :: SYNCH } # [doc = "Checks if the value of the field is `FILTER`"]
# [inline (always)]
pub fn is_filter (& self) -> bool { * self == FILTSEL_A :: FILTER } } # [doc = "Field `FILTSEL` writer - Filter Selection"]
pub type FILTSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLA_SPEC , u8 , FILTSEL_A , 2 , O > ; impl < 'a , const O : u8 > FILTSEL_W < 'a , O > { # [doc = "Filter disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (FILTSEL_A :: DISABLE) } # [doc = "Synchronizer enabled"]
# [inline (always)]
pub fn synch (self) -> & 'a mut W { self . variant (FILTSEL_A :: SYNCH) } # [doc = "Filter enabled"]
# [inline (always)]
pub fn filter (self) -> & 'a mut W { self . variant (FILTSEL_A :: FILTER) } } # [doc = "Field `OUTEN` reader - Output Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT0CTRLA_SPEC , bool , O > ; # [doc = "Field `EDGEDET` reader - Edge Detection Enable"]
pub type EDGEDET_R = crate :: BitReader < EDGEDET_A > ; # [doc = "Edge Detection Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EDGEDET_A { # [doc = "0: Edge detector is disabled"]
DIS = 0 , # [doc = "1: Edge detector is enabled"]
EN = 1 , } impl From < EDGEDET_A > for bool { # [inline (always)]
fn from (variant : EDGEDET_A) -> Self { variant as u8 != 0 } } impl EDGEDET_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGEDET_A { match self . bits { false => EDGEDET_A :: DIS , true => EDGEDET_A :: EN , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == EDGEDET_A :: DIS } # [doc = "Checks if the value of the field is `EN`"]
# [inline (always)]
pub fn is_en (& self) -> bool { * self == EDGEDET_A :: EN } } # [doc = "Field `EDGEDET` writer - Edge Detection Enable"]
pub type EDGEDET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT0CTRLA_SPEC , EDGEDET_A , O > ; impl < 'a , const O : u8 > EDGEDET_W < 'a , O > { # [doc = "Edge detector is disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (EDGEDET_A :: DIS) } # [doc = "Edge detector is enabled"]
# [inline (always)]
pub fn en (self) -> & 'a mut W { self . variant (EDGEDET_A :: EN) } } impl R { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Clock Source Selection"]
# [inline (always)]
pub fn clksrc (& self) -> CLKSRC_R { CLKSRC_R :: new ((self . bits >> 1) & 7) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
pub fn filtsel (& self) -> FILTSEL_R { FILTSEL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Output Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
pub fn edgedet (& self) -> EDGEDET_R { EDGEDET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:3 - Clock Source Selection"]
# [inline (always)]
# [must_use]
pub fn clksrc (& mut self) -> CLKSRC_W < 1 > { CLKSRC_W :: new (self) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
# [must_use]
pub fn filtsel (& mut self) -> FILTSEL_W < 4 > { FILTSEL_W :: new (self) } # [doc = "Bit 6 - Output Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 6 > { OUTEN_W :: new (self) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
# [must_use]
pub fn edgedet (& mut self) -> EDGEDET_W < 7 > { EDGEDET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 0 A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut0ctrla](index.html) module"]
pub struct LUT0CTRLA_SPEC ; impl crate :: RegisterSpec for LUT0CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut0ctrla::R](R) reader structure"]
impl crate :: Readable for LUT0CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut0ctrla::W](W) writer structure"]
impl crate :: Writable for LUT0CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT0CTRLA to value 0"]
impl crate :: Resettable for LUT0CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT0CTRLB (rw) register accessor: an alias for `Reg<LUT0CTRLB_SPEC>`"]
pub type LUT0CTRLB = crate :: Reg < lut0ctrlb :: LUT0CTRLB_SPEC > ; # [doc = "LUT Control 0 B"]
pub mod lut0ctrlb { # [doc = "Register `LUT0CTRLB` reader"]
pub struct R (crate :: R < LUT0CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT0CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT0CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT0CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT0CTRLB` writer"]
pub struct W (crate :: W < LUT0CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT0CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT0CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT0CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL0` reader - LUT Input 0 Source Selection"]
pub type INSEL0_R = crate :: FieldReader < u8 , INSEL0_A > ; # [doc = "LUT Input 0 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL0_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-IN0 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART0 TXD input source"]
USART0 = 8 , # [doc = "9: SPI0 MOSI input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO0 input source"]
TCA0 = 10 , # [doc = "12: TCB0 WO input source"]
TCB0 = 12 , } impl From < INSEL0_A > for u8 { # [inline (always)]
fn from (variant : INSEL0_A) -> Self { variant as _ } } impl INSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL0_A > { match self . bits { 0 => Some (INSEL0_A :: MASK) , 1 => Some (INSEL0_A :: FEEDBACK) , 2 => Some (INSEL0_A :: LINK) , 3 => Some (INSEL0_A :: EVENTA) , 4 => Some (INSEL0_A :: EVENTB) , 5 => Some (INSEL0_A :: IO) , 6 => Some (INSEL0_A :: AC0) , 8 => Some (INSEL0_A :: USART0) , 9 => Some (INSEL0_A :: SPI0) , 10 => Some (INSEL0_A :: TCA0) , 12 => Some (INSEL0_A :: TCB0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL0_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL0_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL0_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL0_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL0_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL0_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL0_A :: AC0 } # [doc = "Checks if the value of the field is `USART0`"]
# [inline (always)]
pub fn is_usart0 (& self) -> bool { * self == INSEL0_A :: USART0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL0_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL0_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL0_A :: TCB0 } } # [doc = "Field `INSEL0` writer - LUT Input 0 Source Selection"]
pub type INSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLB_SPEC , u8 , INSEL0_A , 4 , O > ; impl < 'a , const O : u8 > INSEL0_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL0_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL0_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL0_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENTB) } # [doc = "IO pin LUTn-IN0 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL0_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL0_A :: AC0) } # [doc = "USART0 TXD input source"]
# [inline (always)]
pub fn usart0 (self) -> & 'a mut W { self . variant (INSEL0_A :: USART0) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL0_A :: SPI0) } # [doc = "TCA0 WO0 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCA0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCB0) } } # [doc = "Field `INSEL1` reader - LUT Input 1 Source Selection"]
pub type INSEL1_R = crate :: FieldReader < u8 , INSEL1_A > ; # [doc = "LUT Input 1 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL1_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-N1 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART1 TXD input source"]
USART1 = 8 , # [doc = "9: SPI0 MOSI input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO1 input source"]
TCA0 = 10 , # [doc = "12: TCB1 WO input source"]
TCB1 = 12 , } impl From < INSEL1_A > for u8 { # [inline (always)]
fn from (variant : INSEL1_A) -> Self { variant as _ } } impl INSEL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL1_A > { match self . bits { 0 => Some (INSEL1_A :: MASK) , 1 => Some (INSEL1_A :: FEEDBACK) , 2 => Some (INSEL1_A :: LINK) , 3 => Some (INSEL1_A :: EVENTA) , 4 => Some (INSEL1_A :: EVENTB) , 5 => Some (INSEL1_A :: IO) , 6 => Some (INSEL1_A :: AC0) , 8 => Some (INSEL1_A :: USART1) , 9 => Some (INSEL1_A :: SPI0) , 10 => Some (INSEL1_A :: TCA0) , 12 => Some (INSEL1_A :: TCB1) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL1_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL1_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL1_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL1_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL1_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL1_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL1_A :: AC0 } # [doc = "Checks if the value of the field is `USART1`"]
# [inline (always)]
pub fn is_usart1 (& self) -> bool { * self == INSEL1_A :: USART1 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL1_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL1_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB1`"]
# [inline (always)]
pub fn is_tcb1 (& self) -> bool { * self == INSEL1_A :: TCB1 } } # [doc = "Field `INSEL1` writer - LUT Input 1 Source Selection"]
pub type INSEL1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLB_SPEC , u8 , INSEL1_A , 4 , O > ; impl < 'a , const O : u8 > INSEL1_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL1_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL1_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL1_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENTB) } # [doc = "IO pin LUTn-N1 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL1_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL1_A :: AC0) } # [doc = "USART1 TXD input source"]
# [inline (always)]
pub fn usart1 (self) -> & 'a mut W { self . variant (INSEL1_A :: USART1) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL1_A :: SPI0) } # [doc = "TCA0 WO1 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCA0) } # [doc = "TCB1 WO input source"]
# [inline (always)]
pub fn tcb1 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCB1) } } impl R { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
pub fn insel0 (& self) -> INSEL0_R { INSEL0_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
pub fn insel1 (& self) -> INSEL1_R { INSEL1_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel0 (& mut self) -> INSEL0_W < 0 > { INSEL0_W :: new (self) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel1 (& mut self) -> INSEL1_W < 4 > { INSEL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 0 B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut0ctrlb](index.html) module"]
pub struct LUT0CTRLB_SPEC ; impl crate :: RegisterSpec for LUT0CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut0ctrlb::R](R) reader structure"]
impl crate :: Readable for LUT0CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut0ctrlb::W](W) writer structure"]
impl crate :: Writable for LUT0CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT0CTRLB to value 0"]
impl crate :: Resettable for LUT0CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT0CTRLC (rw) register accessor: an alias for `Reg<LUT0CTRLC_SPEC>`"]
pub type LUT0CTRLC = crate :: Reg < lut0ctrlc :: LUT0CTRLC_SPEC > ; # [doc = "LUT Control 0 C"]
pub mod lut0ctrlc { # [doc = "Register `LUT0CTRLC` reader"]
pub struct R (crate :: R < LUT0CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT0CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT0CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT0CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT0CTRLC` writer"]
pub struct W (crate :: W < LUT0CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT0CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT0CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT0CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL2` reader - LUT Input 2 Source Selection"]
pub type INSEL2_R = crate :: FieldReader < u8 , INSEL2_A > ; # [doc = "LUT Input 2 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL2_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-IN2 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART2 TXD input source"]
USART2 = 8 , # [doc = "9: SPI0 SCK input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO2 input source"]
TCA0 = 10 , # [doc = "12: TCB2 WO input source"]
TCB2 = 12 , } impl From < INSEL2_A > for u8 { # [inline (always)]
fn from (variant : INSEL2_A) -> Self { variant as _ } } impl INSEL2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL2_A > { match self . bits { 0 => Some (INSEL2_A :: MASK) , 1 => Some (INSEL2_A :: FEEDBACK) , 2 => Some (INSEL2_A :: LINK) , 3 => Some (INSEL2_A :: EVENTA) , 4 => Some (INSEL2_A :: EVENTB) , 5 => Some (INSEL2_A :: IO) , 6 => Some (INSEL2_A :: AC0) , 8 => Some (INSEL2_A :: USART2) , 9 => Some (INSEL2_A :: SPI0) , 10 => Some (INSEL2_A :: TCA0) , 12 => Some (INSEL2_A :: TCB2) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL2_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL2_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL2_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL2_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL2_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL2_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL2_A :: AC0 } # [doc = "Checks if the value of the field is `USART2`"]
# [inline (always)]
pub fn is_usart2 (& self) -> bool { * self == INSEL2_A :: USART2 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL2_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL2_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB2`"]
# [inline (always)]
pub fn is_tcb2 (& self) -> bool { * self == INSEL2_A :: TCB2 } } # [doc = "Field `INSEL2` writer - LUT Input 2 Source Selection"]
pub type INSEL2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT0CTRLC_SPEC , u8 , INSEL2_A , 4 , O > ; impl < 'a , const O : u8 > INSEL2_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL2_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL2_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL2_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENTB) } # [doc = "IO pin LUTn-IN2 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL2_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL2_A :: AC0) } # [doc = "USART2 TXD input source"]
# [inline (always)]
pub fn usart2 (self) -> & 'a mut W { self . variant (INSEL2_A :: USART2) } # [doc = "SPI0 SCK input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL2_A :: SPI0) } # [doc = "TCA0 WO2 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCA0) } # [doc = "TCB2 WO input source"]
# [inline (always)]
pub fn tcb2 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCB2) } } impl R { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
pub fn insel2 (& self) -> INSEL2_R { INSEL2_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel2 (& mut self) -> INSEL2_W < 0 > { INSEL2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 0 C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut0ctrlc](index.html) module"]
pub struct LUT0CTRLC_SPEC ; impl crate :: RegisterSpec for LUT0CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut0ctrlc::R](R) reader structure"]
impl crate :: Readable for LUT0CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut0ctrlc::W](W) writer structure"]
impl crate :: Writable for LUT0CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT0CTRLC to value 0"]
impl crate :: Resettable for LUT0CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT1CTRLA (rw) register accessor: an alias for `Reg<LUT1CTRLA_SPEC>`"]
pub type LUT1CTRLA = crate :: Reg < lut1ctrla :: LUT1CTRLA_SPEC > ; # [doc = "LUT Control 1 A"]
pub mod lut1ctrla { # [doc = "Register `LUT1CTRLA` reader"]
pub struct R (crate :: R < LUT1CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT1CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT1CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT1CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT1CTRLA` writer"]
pub struct W (crate :: W < LUT1CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT1CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT1CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT1CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - LUT Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - LUT Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT1CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSRC` reader - Clock Source Selection"]
pub type CLKSRC_R = crate :: FieldReader < u8 , CLKSRC_A > ; # [doc = "Clock Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSRC_A { # [doc = "0: CLK_PER is clocking the LUT"]
CLKPER = 0 , # [doc = "1: IN\\[2\\]
is clocking the LUT"]
IN2 = 1 , # [doc = "4: 20MHz oscillator before prescaler is clocking the LUT"]
OSC20M = 4 , # [doc = "5: 32kHz oscillator is clocking the LUT"]
OSCULP32K = 5 , # [doc = "6: 32kHz oscillator after DIV32 is clocking the LUT"]
OSCULP1K = 6 , } impl From < CLKSRC_A > for u8 { # [inline (always)]
fn from (variant : CLKSRC_A) -> Self { variant as _ } } impl CLKSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSRC_A > { match self . bits { 0 => Some (CLKSRC_A :: CLKPER) , 1 => Some (CLKSRC_A :: IN2) , 4 => Some (CLKSRC_A :: OSC20M) , 5 => Some (CLKSRC_A :: OSCULP32K) , 6 => Some (CLKSRC_A :: OSCULP1K) , _ => None , } } # [doc = "Checks if the value of the field is `CLKPER`"]
# [inline (always)]
pub fn is_clkper (& self) -> bool { * self == CLKSRC_A :: CLKPER } # [doc = "Checks if the value of the field is `IN2`"]
# [inline (always)]
pub fn is_in2 (& self) -> bool { * self == CLKSRC_A :: IN2 } # [doc = "Checks if the value of the field is `OSC20M`"]
# [inline (always)]
pub fn is_osc20m (& self) -> bool { * self == CLKSRC_A :: OSC20M } # [doc = "Checks if the value of the field is `OSCULP32K`"]
# [inline (always)]
pub fn is_osculp32k (& self) -> bool { * self == CLKSRC_A :: OSCULP32K } # [doc = "Checks if the value of the field is `OSCULP1K`"]
# [inline (always)]
pub fn is_osculp1k (& self) -> bool { * self == CLKSRC_A :: OSCULP1K } } # [doc = "Field `CLKSRC` writer - Clock Source Selection"]
pub type CLKSRC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLA_SPEC , u8 , CLKSRC_A , 3 , O > ; impl < 'a , const O : u8 > CLKSRC_W < 'a , O > { # [doc = "CLK_PER is clocking the LUT"]
# [inline (always)]
pub fn clkper (self) -> & 'a mut W { self . variant (CLKSRC_A :: CLKPER) } # [doc = "IN\\[2\\]
is clocking the LUT"]
# [inline (always)]
pub fn in2 (self) -> & 'a mut W { self . variant (CLKSRC_A :: IN2) } # [doc = "20MHz oscillator before prescaler is clocking the LUT"]
# [inline (always)]
pub fn osc20m (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSC20M) } # [doc = "32kHz oscillator is clocking the LUT"]
# [inline (always)]
pub fn osculp32k (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSCULP32K) } # [doc = "32kHz oscillator after DIV32 is clocking the LUT"]
# [inline (always)]
pub fn osculp1k (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSCULP1K) } } # [doc = "Field `FILTSEL` reader - Filter Selection"]
pub type FILTSEL_R = crate :: FieldReader < u8 , FILTSEL_A > ; # [doc = "Filter Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FILTSEL_A { # [doc = "0: Filter disabled"]
DISABLE = 0 , # [doc = "1: Synchronizer enabled"]
SYNCH = 1 , # [doc = "2: Filter enabled"]
FILTER = 2 , } impl From < FILTSEL_A > for u8 { # [inline (always)]
fn from (variant : FILTSEL_A) -> Self { variant as _ } } impl FILTSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FILTSEL_A > { match self . bits { 0 => Some (FILTSEL_A :: DISABLE) , 1 => Some (FILTSEL_A :: SYNCH) , 2 => Some (FILTSEL_A :: FILTER) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FILTSEL_A :: DISABLE } # [doc = "Checks if the value of the field is `SYNCH`"]
# [inline (always)]
pub fn is_synch (& self) -> bool { * self == FILTSEL_A :: SYNCH } # [doc = "Checks if the value of the field is `FILTER`"]
# [inline (always)]
pub fn is_filter (& self) -> bool { * self == FILTSEL_A :: FILTER } } # [doc = "Field `FILTSEL` writer - Filter Selection"]
pub type FILTSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLA_SPEC , u8 , FILTSEL_A , 2 , O > ; impl < 'a , const O : u8 > FILTSEL_W < 'a , O > { # [doc = "Filter disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (FILTSEL_A :: DISABLE) } # [doc = "Synchronizer enabled"]
# [inline (always)]
pub fn synch (self) -> & 'a mut W { self . variant (FILTSEL_A :: SYNCH) } # [doc = "Filter enabled"]
# [inline (always)]
pub fn filter (self) -> & 'a mut W { self . variant (FILTSEL_A :: FILTER) } } # [doc = "Field `OUTEN` reader - Output Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT1CTRLA_SPEC , bool , O > ; # [doc = "Field `EDGEDET` reader - Edge Detection Enable"]
pub type EDGEDET_R = crate :: BitReader < EDGEDET_A > ; # [doc = "Edge Detection Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EDGEDET_A { # [doc = "0: Edge detector is disabled"]
DIS = 0 , # [doc = "1: Edge detector is enabled"]
EN = 1 , } impl From < EDGEDET_A > for bool { # [inline (always)]
fn from (variant : EDGEDET_A) -> Self { variant as u8 != 0 } } impl EDGEDET_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGEDET_A { match self . bits { false => EDGEDET_A :: DIS , true => EDGEDET_A :: EN , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == EDGEDET_A :: DIS } # [doc = "Checks if the value of the field is `EN`"]
# [inline (always)]
pub fn is_en (& self) -> bool { * self == EDGEDET_A :: EN } } # [doc = "Field `EDGEDET` writer - Edge Detection Enable"]
pub type EDGEDET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT1CTRLA_SPEC , EDGEDET_A , O > ; impl < 'a , const O : u8 > EDGEDET_W < 'a , O > { # [doc = "Edge detector is disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (EDGEDET_A :: DIS) } # [doc = "Edge detector is enabled"]
# [inline (always)]
pub fn en (self) -> & 'a mut W { self . variant (EDGEDET_A :: EN) } } impl R { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Clock Source Selection"]
# [inline (always)]
pub fn clksrc (& self) -> CLKSRC_R { CLKSRC_R :: new ((self . bits >> 1) & 7) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
pub fn filtsel (& self) -> FILTSEL_R { FILTSEL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Output Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
pub fn edgedet (& self) -> EDGEDET_R { EDGEDET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:3 - Clock Source Selection"]
# [inline (always)]
# [must_use]
pub fn clksrc (& mut self) -> CLKSRC_W < 1 > { CLKSRC_W :: new (self) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
# [must_use]
pub fn filtsel (& mut self) -> FILTSEL_W < 4 > { FILTSEL_W :: new (self) } # [doc = "Bit 6 - Output Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 6 > { OUTEN_W :: new (self) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
# [must_use]
pub fn edgedet (& mut self) -> EDGEDET_W < 7 > { EDGEDET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 1 A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut1ctrla](index.html) module"]
pub struct LUT1CTRLA_SPEC ; impl crate :: RegisterSpec for LUT1CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut1ctrla::R](R) reader structure"]
impl crate :: Readable for LUT1CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut1ctrla::W](W) writer structure"]
impl crate :: Writable for LUT1CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT1CTRLA to value 0"]
impl crate :: Resettable for LUT1CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT1CTRLB (rw) register accessor: an alias for `Reg<LUT1CTRLB_SPEC>`"]
pub type LUT1CTRLB = crate :: Reg < lut1ctrlb :: LUT1CTRLB_SPEC > ; # [doc = "LUT Control 1 B"]
pub mod lut1ctrlb { # [doc = "Register `LUT1CTRLB` reader"]
pub struct R (crate :: R < LUT1CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT1CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT1CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT1CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT1CTRLB` writer"]
pub struct W (crate :: W < LUT1CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT1CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT1CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT1CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL0` reader - LUT Input 0 Source Selection"]
pub type INSEL0_R = crate :: FieldReader < u8 , INSEL0_A > ; # [doc = "LUT Input 0 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL0_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-IN0 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART0 TXD input source"]
USART0 = 8 , # [doc = "9: SPI0 MOSI input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO0 input source"]
TCA0 = 10 , # [doc = "12: TCB0 WO input source"]
TCB0 = 12 , } impl From < INSEL0_A > for u8 { # [inline (always)]
fn from (variant : INSEL0_A) -> Self { variant as _ } } impl INSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL0_A > { match self . bits { 0 => Some (INSEL0_A :: MASK) , 1 => Some (INSEL0_A :: FEEDBACK) , 2 => Some (INSEL0_A :: LINK) , 3 => Some (INSEL0_A :: EVENTA) , 4 => Some (INSEL0_A :: EVENTB) , 5 => Some (INSEL0_A :: IO) , 6 => Some (INSEL0_A :: AC0) , 8 => Some (INSEL0_A :: USART0) , 9 => Some (INSEL0_A :: SPI0) , 10 => Some (INSEL0_A :: TCA0) , 12 => Some (INSEL0_A :: TCB0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL0_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL0_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL0_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL0_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL0_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL0_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL0_A :: AC0 } # [doc = "Checks if the value of the field is `USART0`"]
# [inline (always)]
pub fn is_usart0 (& self) -> bool { * self == INSEL0_A :: USART0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL0_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL0_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL0_A :: TCB0 } } # [doc = "Field `INSEL0` writer - LUT Input 0 Source Selection"]
pub type INSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLB_SPEC , u8 , INSEL0_A , 4 , O > ; impl < 'a , const O : u8 > INSEL0_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL0_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL0_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL0_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENTB) } # [doc = "IO pin LUTn-IN0 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL0_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL0_A :: AC0) } # [doc = "USART0 TXD input source"]
# [inline (always)]
pub fn usart0 (self) -> & 'a mut W { self . variant (INSEL0_A :: USART0) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL0_A :: SPI0) } # [doc = "TCA0 WO0 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCA0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCB0) } } # [doc = "Field `INSEL1` reader - LUT Input 1 Source Selection"]
pub type INSEL1_R = crate :: FieldReader < u8 , INSEL1_A > ; # [doc = "LUT Input 1 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL1_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-N1 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART1 TXD input source"]
USART1 = 8 , # [doc = "9: SPI0 MOSI input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO1 input source"]
TCA0 = 10 , # [doc = "12: TCB1 WO input source"]
TCB1 = 12 , } impl From < INSEL1_A > for u8 { # [inline (always)]
fn from (variant : INSEL1_A) -> Self { variant as _ } } impl INSEL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL1_A > { match self . bits { 0 => Some (INSEL1_A :: MASK) , 1 => Some (INSEL1_A :: FEEDBACK) , 2 => Some (INSEL1_A :: LINK) , 3 => Some (INSEL1_A :: EVENTA) , 4 => Some (INSEL1_A :: EVENTB) , 5 => Some (INSEL1_A :: IO) , 6 => Some (INSEL1_A :: AC0) , 8 => Some (INSEL1_A :: USART1) , 9 => Some (INSEL1_A :: SPI0) , 10 => Some (INSEL1_A :: TCA0) , 12 => Some (INSEL1_A :: TCB1) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL1_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL1_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL1_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL1_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL1_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL1_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL1_A :: AC0 } # [doc = "Checks if the value of the field is `USART1`"]
# [inline (always)]
pub fn is_usart1 (& self) -> bool { * self == INSEL1_A :: USART1 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL1_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL1_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB1`"]
# [inline (always)]
pub fn is_tcb1 (& self) -> bool { * self == INSEL1_A :: TCB1 } } # [doc = "Field `INSEL1` writer - LUT Input 1 Source Selection"]
pub type INSEL1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLB_SPEC , u8 , INSEL1_A , 4 , O > ; impl < 'a , const O : u8 > INSEL1_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL1_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL1_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL1_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENTB) } # [doc = "IO pin LUTn-N1 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL1_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL1_A :: AC0) } # [doc = "USART1 TXD input source"]
# [inline (always)]
pub fn usart1 (self) -> & 'a mut W { self . variant (INSEL1_A :: USART1) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL1_A :: SPI0) } # [doc = "TCA0 WO1 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCA0) } # [doc = "TCB1 WO input source"]
# [inline (always)]
pub fn tcb1 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCB1) } } impl R { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
pub fn insel0 (& self) -> INSEL0_R { INSEL0_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
pub fn insel1 (& self) -> INSEL1_R { INSEL1_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel0 (& mut self) -> INSEL0_W < 0 > { INSEL0_W :: new (self) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel1 (& mut self) -> INSEL1_W < 4 > { INSEL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 1 B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut1ctrlb](index.html) module"]
pub struct LUT1CTRLB_SPEC ; impl crate :: RegisterSpec for LUT1CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut1ctrlb::R](R) reader structure"]
impl crate :: Readable for LUT1CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut1ctrlb::W](W) writer structure"]
impl crate :: Writable for LUT1CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT1CTRLB to value 0"]
impl crate :: Resettable for LUT1CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT1CTRLC (rw) register accessor: an alias for `Reg<LUT1CTRLC_SPEC>`"]
pub type LUT1CTRLC = crate :: Reg < lut1ctrlc :: LUT1CTRLC_SPEC > ; # [doc = "LUT Control 1 C"]
pub mod lut1ctrlc { # [doc = "Register `LUT1CTRLC` reader"]
pub struct R (crate :: R < LUT1CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT1CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT1CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT1CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT1CTRLC` writer"]
pub struct W (crate :: W < LUT1CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT1CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT1CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT1CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL2` reader - LUT Input 2 Source Selection"]
pub type INSEL2_R = crate :: FieldReader < u8 , INSEL2_A > ; # [doc = "LUT Input 2 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL2_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-IN2 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART2 TXD input source"]
USART2 = 8 , # [doc = "9: SPI0 SCK input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO2 input source"]
TCA0 = 10 , # [doc = "12: TCB2 WO input source"]
TCB2 = 12 , } impl From < INSEL2_A > for u8 { # [inline (always)]
fn from (variant : INSEL2_A) -> Self { variant as _ } } impl INSEL2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL2_A > { match self . bits { 0 => Some (INSEL2_A :: MASK) , 1 => Some (INSEL2_A :: FEEDBACK) , 2 => Some (INSEL2_A :: LINK) , 3 => Some (INSEL2_A :: EVENTA) , 4 => Some (INSEL2_A :: EVENTB) , 5 => Some (INSEL2_A :: IO) , 6 => Some (INSEL2_A :: AC0) , 8 => Some (INSEL2_A :: USART2) , 9 => Some (INSEL2_A :: SPI0) , 10 => Some (INSEL2_A :: TCA0) , 12 => Some (INSEL2_A :: TCB2) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL2_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL2_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL2_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL2_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL2_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL2_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL2_A :: AC0 } # [doc = "Checks if the value of the field is `USART2`"]
# [inline (always)]
pub fn is_usart2 (& self) -> bool { * self == INSEL2_A :: USART2 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL2_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL2_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB2`"]
# [inline (always)]
pub fn is_tcb2 (& self) -> bool { * self == INSEL2_A :: TCB2 } } # [doc = "Field `INSEL2` writer - LUT Input 2 Source Selection"]
pub type INSEL2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT1CTRLC_SPEC , u8 , INSEL2_A , 4 , O > ; impl < 'a , const O : u8 > INSEL2_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL2_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL2_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL2_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENTB) } # [doc = "IO pin LUTn-IN2 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL2_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL2_A :: AC0) } # [doc = "USART2 TXD input source"]
# [inline (always)]
pub fn usart2 (self) -> & 'a mut W { self . variant (INSEL2_A :: USART2) } # [doc = "SPI0 SCK input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL2_A :: SPI0) } # [doc = "TCA0 WO2 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCA0) } # [doc = "TCB2 WO input source"]
# [inline (always)]
pub fn tcb2 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCB2) } } impl R { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
pub fn insel2 (& self) -> INSEL2_R { INSEL2_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel2 (& mut self) -> INSEL2_W < 0 > { INSEL2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 1 C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut1ctrlc](index.html) module"]
pub struct LUT1CTRLC_SPEC ; impl crate :: RegisterSpec for LUT1CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut1ctrlc::R](R) reader structure"]
impl crate :: Readable for LUT1CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut1ctrlc::W](W) writer structure"]
impl crate :: Writable for LUT1CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT1CTRLC to value 0"]
impl crate :: Resettable for LUT1CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT2CTRLA (rw) register accessor: an alias for `Reg<LUT2CTRLA_SPEC>`"]
pub type LUT2CTRLA = crate :: Reg < lut2ctrla :: LUT2CTRLA_SPEC > ; # [doc = "LUT Control 2 A"]
pub mod lut2ctrla { # [doc = "Register `LUT2CTRLA` reader"]
pub struct R (crate :: R < LUT2CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT2CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT2CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT2CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT2CTRLA` writer"]
pub struct W (crate :: W < LUT2CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT2CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT2CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT2CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - LUT Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - LUT Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT2CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSRC` reader - Clock Source Selection"]
pub type CLKSRC_R = crate :: FieldReader < u8 , CLKSRC_A > ; # [doc = "Clock Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSRC_A { # [doc = "0: CLK_PER is clocking the LUT"]
CLKPER = 0 , # [doc = "1: IN\\[2\\]
is clocking the LUT"]
IN2 = 1 , # [doc = "4: 20MHz oscillator before prescaler is clocking the LUT"]
OSC20M = 4 , # [doc = "5: 32kHz oscillator is clocking the LUT"]
OSCULP32K = 5 , # [doc = "6: 32kHz oscillator after DIV32 is clocking the LUT"]
OSCULP1K = 6 , } impl From < CLKSRC_A > for u8 { # [inline (always)]
fn from (variant : CLKSRC_A) -> Self { variant as _ } } impl CLKSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSRC_A > { match self . bits { 0 => Some (CLKSRC_A :: CLKPER) , 1 => Some (CLKSRC_A :: IN2) , 4 => Some (CLKSRC_A :: OSC20M) , 5 => Some (CLKSRC_A :: OSCULP32K) , 6 => Some (CLKSRC_A :: OSCULP1K) , _ => None , } } # [doc = "Checks if the value of the field is `CLKPER`"]
# [inline (always)]
pub fn is_clkper (& self) -> bool { * self == CLKSRC_A :: CLKPER } # [doc = "Checks if the value of the field is `IN2`"]
# [inline (always)]
pub fn is_in2 (& self) -> bool { * self == CLKSRC_A :: IN2 } # [doc = "Checks if the value of the field is `OSC20M`"]
# [inline (always)]
pub fn is_osc20m (& self) -> bool { * self == CLKSRC_A :: OSC20M } # [doc = "Checks if the value of the field is `OSCULP32K`"]
# [inline (always)]
pub fn is_osculp32k (& self) -> bool { * self == CLKSRC_A :: OSCULP32K } # [doc = "Checks if the value of the field is `OSCULP1K`"]
# [inline (always)]
pub fn is_osculp1k (& self) -> bool { * self == CLKSRC_A :: OSCULP1K } } # [doc = "Field `CLKSRC` writer - Clock Source Selection"]
pub type CLKSRC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT2CTRLA_SPEC , u8 , CLKSRC_A , 3 , O > ; impl < 'a , const O : u8 > CLKSRC_W < 'a , O > { # [doc = "CLK_PER is clocking the LUT"]
# [inline (always)]
pub fn clkper (self) -> & 'a mut W { self . variant (CLKSRC_A :: CLKPER) } # [doc = "IN\\[2\\]
is clocking the LUT"]
# [inline (always)]
pub fn in2 (self) -> & 'a mut W { self . variant (CLKSRC_A :: IN2) } # [doc = "20MHz oscillator before prescaler is clocking the LUT"]
# [inline (always)]
pub fn osc20m (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSC20M) } # [doc = "32kHz oscillator is clocking the LUT"]
# [inline (always)]
pub fn osculp32k (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSCULP32K) } # [doc = "32kHz oscillator after DIV32 is clocking the LUT"]
# [inline (always)]
pub fn osculp1k (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSCULP1K) } } # [doc = "Field `FILTSEL` reader - Filter Selection"]
pub type FILTSEL_R = crate :: FieldReader < u8 , FILTSEL_A > ; # [doc = "Filter Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FILTSEL_A { # [doc = "0: Filter disabled"]
DISABLE = 0 , # [doc = "1: Synchronizer enabled"]
SYNCH = 1 , # [doc = "2: Filter enabled"]
FILTER = 2 , } impl From < FILTSEL_A > for u8 { # [inline (always)]
fn from (variant : FILTSEL_A) -> Self { variant as _ } } impl FILTSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FILTSEL_A > { match self . bits { 0 => Some (FILTSEL_A :: DISABLE) , 1 => Some (FILTSEL_A :: SYNCH) , 2 => Some (FILTSEL_A :: FILTER) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FILTSEL_A :: DISABLE } # [doc = "Checks if the value of the field is `SYNCH`"]
# [inline (always)]
pub fn is_synch (& self) -> bool { * self == FILTSEL_A :: SYNCH } # [doc = "Checks if the value of the field is `FILTER`"]
# [inline (always)]
pub fn is_filter (& self) -> bool { * self == FILTSEL_A :: FILTER } } # [doc = "Field `FILTSEL` writer - Filter Selection"]
pub type FILTSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT2CTRLA_SPEC , u8 , FILTSEL_A , 2 , O > ; impl < 'a , const O : u8 > FILTSEL_W < 'a , O > { # [doc = "Filter disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (FILTSEL_A :: DISABLE) } # [doc = "Synchronizer enabled"]
# [inline (always)]
pub fn synch (self) -> & 'a mut W { self . variant (FILTSEL_A :: SYNCH) } # [doc = "Filter enabled"]
# [inline (always)]
pub fn filter (self) -> & 'a mut W { self . variant (FILTSEL_A :: FILTER) } } # [doc = "Field `OUTEN` reader - Output Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT2CTRLA_SPEC , bool , O > ; # [doc = "Field `EDGEDET` reader - Edge Detection Enable"]
pub type EDGEDET_R = crate :: BitReader < EDGEDET_A > ; # [doc = "Edge Detection Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EDGEDET_A { # [doc = "0: Edge detector is disabled"]
DIS = 0 , # [doc = "1: Edge detector is enabled"]
EN = 1 , } impl From < EDGEDET_A > for bool { # [inline (always)]
fn from (variant : EDGEDET_A) -> Self { variant as u8 != 0 } } impl EDGEDET_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGEDET_A { match self . bits { false => EDGEDET_A :: DIS , true => EDGEDET_A :: EN , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == EDGEDET_A :: DIS } # [doc = "Checks if the value of the field is `EN`"]
# [inline (always)]
pub fn is_en (& self) -> bool { * self == EDGEDET_A :: EN } } # [doc = "Field `EDGEDET` writer - Edge Detection Enable"]
pub type EDGEDET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT2CTRLA_SPEC , EDGEDET_A , O > ; impl < 'a , const O : u8 > EDGEDET_W < 'a , O > { # [doc = "Edge detector is disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (EDGEDET_A :: DIS) } # [doc = "Edge detector is enabled"]
# [inline (always)]
pub fn en (self) -> & 'a mut W { self . variant (EDGEDET_A :: EN) } } impl R { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Clock Source Selection"]
# [inline (always)]
pub fn clksrc (& self) -> CLKSRC_R { CLKSRC_R :: new ((self . bits >> 1) & 7) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
pub fn filtsel (& self) -> FILTSEL_R { FILTSEL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Output Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
pub fn edgedet (& self) -> EDGEDET_R { EDGEDET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:3 - Clock Source Selection"]
# [inline (always)]
# [must_use]
pub fn clksrc (& mut self) -> CLKSRC_W < 1 > { CLKSRC_W :: new (self) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
# [must_use]
pub fn filtsel (& mut self) -> FILTSEL_W < 4 > { FILTSEL_W :: new (self) } # [doc = "Bit 6 - Output Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 6 > { OUTEN_W :: new (self) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
# [must_use]
pub fn edgedet (& mut self) -> EDGEDET_W < 7 > { EDGEDET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 2 A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut2ctrla](index.html) module"]
pub struct LUT2CTRLA_SPEC ; impl crate :: RegisterSpec for LUT2CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut2ctrla::R](R) reader structure"]
impl crate :: Readable for LUT2CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut2ctrla::W](W) writer structure"]
impl crate :: Writable for LUT2CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT2CTRLA to value 0"]
impl crate :: Resettable for LUT2CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT2CTRLB (rw) register accessor: an alias for `Reg<LUT2CTRLB_SPEC>`"]
pub type LUT2CTRLB = crate :: Reg < lut2ctrlb :: LUT2CTRLB_SPEC > ; # [doc = "LUT Control 2 B"]
pub mod lut2ctrlb { # [doc = "Register `LUT2CTRLB` reader"]
pub struct R (crate :: R < LUT2CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT2CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT2CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT2CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT2CTRLB` writer"]
pub struct W (crate :: W < LUT2CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT2CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT2CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT2CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL0` reader - LUT Input 0 Source Selection"]
pub type INSEL0_R = crate :: FieldReader < u8 , INSEL0_A > ; # [doc = "LUT Input 0 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL0_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-IN0 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART0 TXD input source"]
USART0 = 8 , # [doc = "9: SPI0 MOSI input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO0 input source"]
TCA0 = 10 , # [doc = "12: TCB0 WO input source"]
TCB0 = 12 , } impl From < INSEL0_A > for u8 { # [inline (always)]
fn from (variant : INSEL0_A) -> Self { variant as _ } } impl INSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL0_A > { match self . bits { 0 => Some (INSEL0_A :: MASK) , 1 => Some (INSEL0_A :: FEEDBACK) , 2 => Some (INSEL0_A :: LINK) , 3 => Some (INSEL0_A :: EVENTA) , 4 => Some (INSEL0_A :: EVENTB) , 5 => Some (INSEL0_A :: IO) , 6 => Some (INSEL0_A :: AC0) , 8 => Some (INSEL0_A :: USART0) , 9 => Some (INSEL0_A :: SPI0) , 10 => Some (INSEL0_A :: TCA0) , 12 => Some (INSEL0_A :: TCB0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL0_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL0_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL0_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL0_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL0_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL0_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL0_A :: AC0 } # [doc = "Checks if the value of the field is `USART0`"]
# [inline (always)]
pub fn is_usart0 (& self) -> bool { * self == INSEL0_A :: USART0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL0_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL0_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL0_A :: TCB0 } } # [doc = "Field `INSEL0` writer - LUT Input 0 Source Selection"]
pub type INSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT2CTRLB_SPEC , u8 , INSEL0_A , 4 , O > ; impl < 'a , const O : u8 > INSEL0_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL0_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL0_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL0_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENTB) } # [doc = "IO pin LUTn-IN0 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL0_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL0_A :: AC0) } # [doc = "USART0 TXD input source"]
# [inline (always)]
pub fn usart0 (self) -> & 'a mut W { self . variant (INSEL0_A :: USART0) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL0_A :: SPI0) } # [doc = "TCA0 WO0 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCA0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCB0) } } # [doc = "Field `INSEL1` reader - LUT Input 1 Source Selection"]
pub type INSEL1_R = crate :: FieldReader < u8 , INSEL1_A > ; # [doc = "LUT Input 1 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL1_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-N1 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART1 TXD input source"]
USART1 = 8 , # [doc = "9: SPI0 MOSI input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO1 input source"]
TCA0 = 10 , # [doc = "12: TCB1 WO input source"]
TCB1 = 12 , } impl From < INSEL1_A > for u8 { # [inline (always)]
fn from (variant : INSEL1_A) -> Self { variant as _ } } impl INSEL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL1_A > { match self . bits { 0 => Some (INSEL1_A :: MASK) , 1 => Some (INSEL1_A :: FEEDBACK) , 2 => Some (INSEL1_A :: LINK) , 3 => Some (INSEL1_A :: EVENTA) , 4 => Some (INSEL1_A :: EVENTB) , 5 => Some (INSEL1_A :: IO) , 6 => Some (INSEL1_A :: AC0) , 8 => Some (INSEL1_A :: USART1) , 9 => Some (INSEL1_A :: SPI0) , 10 => Some (INSEL1_A :: TCA0) , 12 => Some (INSEL1_A :: TCB1) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL1_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL1_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL1_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL1_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL1_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL1_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL1_A :: AC0 } # [doc = "Checks if the value of the field is `USART1`"]
# [inline (always)]
pub fn is_usart1 (& self) -> bool { * self == INSEL1_A :: USART1 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL1_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL1_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB1`"]
# [inline (always)]
pub fn is_tcb1 (& self) -> bool { * self == INSEL1_A :: TCB1 } } # [doc = "Field `INSEL1` writer - LUT Input 1 Source Selection"]
pub type INSEL1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT2CTRLB_SPEC , u8 , INSEL1_A , 4 , O > ; impl < 'a , const O : u8 > INSEL1_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL1_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL1_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL1_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENTB) } # [doc = "IO pin LUTn-N1 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL1_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL1_A :: AC0) } # [doc = "USART1 TXD input source"]
# [inline (always)]
pub fn usart1 (self) -> & 'a mut W { self . variant (INSEL1_A :: USART1) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL1_A :: SPI0) } # [doc = "TCA0 WO1 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCA0) } # [doc = "TCB1 WO input source"]
# [inline (always)]
pub fn tcb1 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCB1) } } impl R { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
pub fn insel0 (& self) -> INSEL0_R { INSEL0_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
pub fn insel1 (& self) -> INSEL1_R { INSEL1_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel0 (& mut self) -> INSEL0_W < 0 > { INSEL0_W :: new (self) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel1 (& mut self) -> INSEL1_W < 4 > { INSEL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 2 B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut2ctrlb](index.html) module"]
pub struct LUT2CTRLB_SPEC ; impl crate :: RegisterSpec for LUT2CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut2ctrlb::R](R) reader structure"]
impl crate :: Readable for LUT2CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut2ctrlb::W](W) writer structure"]
impl crate :: Writable for LUT2CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT2CTRLB to value 0"]
impl crate :: Resettable for LUT2CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT2CTRLC (rw) register accessor: an alias for `Reg<LUT2CTRLC_SPEC>`"]
pub type LUT2CTRLC = crate :: Reg < lut2ctrlc :: LUT2CTRLC_SPEC > ; # [doc = "LUT Control 2 C"]
pub mod lut2ctrlc { # [doc = "Register `LUT2CTRLC` reader"]
pub struct R (crate :: R < LUT2CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT2CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT2CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT2CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT2CTRLC` writer"]
pub struct W (crate :: W < LUT2CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT2CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT2CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT2CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL2` reader - LUT Input 2 Source Selection"]
pub type INSEL2_R = crate :: FieldReader < u8 , INSEL2_A > ; # [doc = "LUT Input 2 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL2_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-IN2 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART2 TXD input source"]
USART2 = 8 , # [doc = "9: SPI0 SCK input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO2 input source"]
TCA0 = 10 , # [doc = "12: TCB2 WO input source"]
TCB2 = 12 , } impl From < INSEL2_A > for u8 { # [inline (always)]
fn from (variant : INSEL2_A) -> Self { variant as _ } } impl INSEL2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL2_A > { match self . bits { 0 => Some (INSEL2_A :: MASK) , 1 => Some (INSEL2_A :: FEEDBACK) , 2 => Some (INSEL2_A :: LINK) , 3 => Some (INSEL2_A :: EVENTA) , 4 => Some (INSEL2_A :: EVENTB) , 5 => Some (INSEL2_A :: IO) , 6 => Some (INSEL2_A :: AC0) , 8 => Some (INSEL2_A :: USART2) , 9 => Some (INSEL2_A :: SPI0) , 10 => Some (INSEL2_A :: TCA0) , 12 => Some (INSEL2_A :: TCB2) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL2_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL2_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL2_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL2_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL2_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL2_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL2_A :: AC0 } # [doc = "Checks if the value of the field is `USART2`"]
# [inline (always)]
pub fn is_usart2 (& self) -> bool { * self == INSEL2_A :: USART2 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL2_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL2_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB2`"]
# [inline (always)]
pub fn is_tcb2 (& self) -> bool { * self == INSEL2_A :: TCB2 } } # [doc = "Field `INSEL2` writer - LUT Input 2 Source Selection"]
pub type INSEL2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT2CTRLC_SPEC , u8 , INSEL2_A , 4 , O > ; impl < 'a , const O : u8 > INSEL2_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL2_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL2_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL2_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENTB) } # [doc = "IO pin LUTn-IN2 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL2_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL2_A :: AC0) } # [doc = "USART2 TXD input source"]
# [inline (always)]
pub fn usart2 (self) -> & 'a mut W { self . variant (INSEL2_A :: USART2) } # [doc = "SPI0 SCK input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL2_A :: SPI0) } # [doc = "TCA0 WO2 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCA0) } # [doc = "TCB2 WO input source"]
# [inline (always)]
pub fn tcb2 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCB2) } } impl R { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
pub fn insel2 (& self) -> INSEL2_R { INSEL2_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel2 (& mut self) -> INSEL2_W < 0 > { INSEL2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 2 C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut2ctrlc](index.html) module"]
pub struct LUT2CTRLC_SPEC ; impl crate :: RegisterSpec for LUT2CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut2ctrlc::R](R) reader structure"]
impl crate :: Readable for LUT2CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut2ctrlc::W](W) writer structure"]
impl crate :: Writable for LUT2CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT2CTRLC to value 0"]
impl crate :: Resettable for LUT2CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT3CTRLA (rw) register accessor: an alias for `Reg<LUT3CTRLA_SPEC>`"]
pub type LUT3CTRLA = crate :: Reg < lut3ctrla :: LUT3CTRLA_SPEC > ; # [doc = "LUT Control 3 A"]
pub mod lut3ctrla { # [doc = "Register `LUT3CTRLA` reader"]
pub struct R (crate :: R < LUT3CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT3CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT3CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT3CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT3CTRLA` writer"]
pub struct W (crate :: W < LUT3CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT3CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT3CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT3CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - LUT Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - LUT Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT3CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSRC` reader - Clock Source Selection"]
pub type CLKSRC_R = crate :: FieldReader < u8 , CLKSRC_A > ; # [doc = "Clock Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSRC_A { # [doc = "0: CLK_PER is clocking the LUT"]
CLKPER = 0 , # [doc = "1: IN\\[2\\]
is clocking the LUT"]
IN2 = 1 , # [doc = "4: 20MHz oscillator before prescaler is clocking the LUT"]
OSC20M = 4 , # [doc = "5: 32kHz oscillator is clocking the LUT"]
OSCULP32K = 5 , # [doc = "6: 32kHz oscillator after DIV32 is clocking the LUT"]
OSCULP1K = 6 , } impl From < CLKSRC_A > for u8 { # [inline (always)]
fn from (variant : CLKSRC_A) -> Self { variant as _ } } impl CLKSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSRC_A > { match self . bits { 0 => Some (CLKSRC_A :: CLKPER) , 1 => Some (CLKSRC_A :: IN2) , 4 => Some (CLKSRC_A :: OSC20M) , 5 => Some (CLKSRC_A :: OSCULP32K) , 6 => Some (CLKSRC_A :: OSCULP1K) , _ => None , } } # [doc = "Checks if the value of the field is `CLKPER`"]
# [inline (always)]
pub fn is_clkper (& self) -> bool { * self == CLKSRC_A :: CLKPER } # [doc = "Checks if the value of the field is `IN2`"]
# [inline (always)]
pub fn is_in2 (& self) -> bool { * self == CLKSRC_A :: IN2 } # [doc = "Checks if the value of the field is `OSC20M`"]
# [inline (always)]
pub fn is_osc20m (& self) -> bool { * self == CLKSRC_A :: OSC20M } # [doc = "Checks if the value of the field is `OSCULP32K`"]
# [inline (always)]
pub fn is_osculp32k (& self) -> bool { * self == CLKSRC_A :: OSCULP32K } # [doc = "Checks if the value of the field is `OSCULP1K`"]
# [inline (always)]
pub fn is_osculp1k (& self) -> bool { * self == CLKSRC_A :: OSCULP1K } } # [doc = "Field `CLKSRC` writer - Clock Source Selection"]
pub type CLKSRC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT3CTRLA_SPEC , u8 , CLKSRC_A , 3 , O > ; impl < 'a , const O : u8 > CLKSRC_W < 'a , O > { # [doc = "CLK_PER is clocking the LUT"]
# [inline (always)]
pub fn clkper (self) -> & 'a mut W { self . variant (CLKSRC_A :: CLKPER) } # [doc = "IN\\[2\\]
is clocking the LUT"]
# [inline (always)]
pub fn in2 (self) -> & 'a mut W { self . variant (CLKSRC_A :: IN2) } # [doc = "20MHz oscillator before prescaler is clocking the LUT"]
# [inline (always)]
pub fn osc20m (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSC20M) } # [doc = "32kHz oscillator is clocking the LUT"]
# [inline (always)]
pub fn osculp32k (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSCULP32K) } # [doc = "32kHz oscillator after DIV32 is clocking the LUT"]
# [inline (always)]
pub fn osculp1k (self) -> & 'a mut W { self . variant (CLKSRC_A :: OSCULP1K) } } # [doc = "Field `FILTSEL` reader - Filter Selection"]
pub type FILTSEL_R = crate :: FieldReader < u8 , FILTSEL_A > ; # [doc = "Filter Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FILTSEL_A { # [doc = "0: Filter disabled"]
DISABLE = 0 , # [doc = "1: Synchronizer enabled"]
SYNCH = 1 , # [doc = "2: Filter enabled"]
FILTER = 2 , } impl From < FILTSEL_A > for u8 { # [inline (always)]
fn from (variant : FILTSEL_A) -> Self { variant as _ } } impl FILTSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FILTSEL_A > { match self . bits { 0 => Some (FILTSEL_A :: DISABLE) , 1 => Some (FILTSEL_A :: SYNCH) , 2 => Some (FILTSEL_A :: FILTER) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FILTSEL_A :: DISABLE } # [doc = "Checks if the value of the field is `SYNCH`"]
# [inline (always)]
pub fn is_synch (& self) -> bool { * self == FILTSEL_A :: SYNCH } # [doc = "Checks if the value of the field is `FILTER`"]
# [inline (always)]
pub fn is_filter (& self) -> bool { * self == FILTSEL_A :: FILTER } } # [doc = "Field `FILTSEL` writer - Filter Selection"]
pub type FILTSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT3CTRLA_SPEC , u8 , FILTSEL_A , 2 , O > ; impl < 'a , const O : u8 > FILTSEL_W < 'a , O > { # [doc = "Filter disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (FILTSEL_A :: DISABLE) } # [doc = "Synchronizer enabled"]
# [inline (always)]
pub fn synch (self) -> & 'a mut W { self . variant (FILTSEL_A :: SYNCH) } # [doc = "Filter enabled"]
# [inline (always)]
pub fn filter (self) -> & 'a mut W { self . variant (FILTSEL_A :: FILTER) } } # [doc = "Field `OUTEN` reader - Output Enable"]
pub type OUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `OUTEN` writer - Output Enable"]
pub type OUTEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT3CTRLA_SPEC , bool , O > ; # [doc = "Field `EDGEDET` reader - Edge Detection Enable"]
pub type EDGEDET_R = crate :: BitReader < EDGEDET_A > ; # [doc = "Edge Detection Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EDGEDET_A { # [doc = "0: Edge detector is disabled"]
DIS = 0 , # [doc = "1: Edge detector is enabled"]
EN = 1 , } impl From < EDGEDET_A > for bool { # [inline (always)]
fn from (variant : EDGEDET_A) -> Self { variant as u8 != 0 } } impl EDGEDET_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGEDET_A { match self . bits { false => EDGEDET_A :: DIS , true => EDGEDET_A :: EN , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == EDGEDET_A :: DIS } # [doc = "Checks if the value of the field is `EN`"]
# [inline (always)]
pub fn is_en (& self) -> bool { * self == EDGEDET_A :: EN } } # [doc = "Field `EDGEDET` writer - Edge Detection Enable"]
pub type EDGEDET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LUT3CTRLA_SPEC , EDGEDET_A , O > ; impl < 'a , const O : u8 > EDGEDET_W < 'a , O > { # [doc = "Edge detector is disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (EDGEDET_A :: DIS) } # [doc = "Edge detector is enabled"]
# [inline (always)]
pub fn en (self) -> & 'a mut W { self . variant (EDGEDET_A :: EN) } } impl R { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Clock Source Selection"]
# [inline (always)]
pub fn clksrc (& self) -> CLKSRC_R { CLKSRC_R :: new ((self . bits >> 1) & 7) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
pub fn filtsel (& self) -> FILTSEL_R { FILTSEL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bit 6 - Output Enable"]
# [inline (always)]
pub fn outen (& self) -> OUTEN_R { OUTEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
pub fn edgedet (& self) -> EDGEDET_R { EDGEDET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - LUT Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:3 - Clock Source Selection"]
# [inline (always)]
# [must_use]
pub fn clksrc (& mut self) -> CLKSRC_W < 1 > { CLKSRC_W :: new (self) } # [doc = "Bits 4:5 - Filter Selection"]
# [inline (always)]
# [must_use]
pub fn filtsel (& mut self) -> FILTSEL_W < 4 > { FILTSEL_W :: new (self) } # [doc = "Bit 6 - Output Enable"]
# [inline (always)]
# [must_use]
pub fn outen (& mut self) -> OUTEN_W < 6 > { OUTEN_W :: new (self) } # [doc = "Bit 7 - Edge Detection Enable"]
# [inline (always)]
# [must_use]
pub fn edgedet (& mut self) -> EDGEDET_W < 7 > { EDGEDET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 3 A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut3ctrla](index.html) module"]
pub struct LUT3CTRLA_SPEC ; impl crate :: RegisterSpec for LUT3CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut3ctrla::R](R) reader structure"]
impl crate :: Readable for LUT3CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut3ctrla::W](W) writer structure"]
impl crate :: Writable for LUT3CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT3CTRLA to value 0"]
impl crate :: Resettable for LUT3CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT3CTRLB (rw) register accessor: an alias for `Reg<LUT3CTRLB_SPEC>`"]
pub type LUT3CTRLB = crate :: Reg < lut3ctrlb :: LUT3CTRLB_SPEC > ; # [doc = "LUT Control 3 B"]
pub mod lut3ctrlb { # [doc = "Register `LUT3CTRLB` reader"]
pub struct R (crate :: R < LUT3CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT3CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT3CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT3CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT3CTRLB` writer"]
pub struct W (crate :: W < LUT3CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT3CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT3CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT3CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL0` reader - LUT Input 0 Source Selection"]
pub type INSEL0_R = crate :: FieldReader < u8 , INSEL0_A > ; # [doc = "LUT Input 0 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL0_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-IN0 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART0 TXD input source"]
USART0 = 8 , # [doc = "9: SPI0 MOSI input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO0 input source"]
TCA0 = 10 , # [doc = "12: TCB0 WO input source"]
TCB0 = 12 , } impl From < INSEL0_A > for u8 { # [inline (always)]
fn from (variant : INSEL0_A) -> Self { variant as _ } } impl INSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL0_A > { match self . bits { 0 => Some (INSEL0_A :: MASK) , 1 => Some (INSEL0_A :: FEEDBACK) , 2 => Some (INSEL0_A :: LINK) , 3 => Some (INSEL0_A :: EVENTA) , 4 => Some (INSEL0_A :: EVENTB) , 5 => Some (INSEL0_A :: IO) , 6 => Some (INSEL0_A :: AC0) , 8 => Some (INSEL0_A :: USART0) , 9 => Some (INSEL0_A :: SPI0) , 10 => Some (INSEL0_A :: TCA0) , 12 => Some (INSEL0_A :: TCB0) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL0_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL0_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL0_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL0_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL0_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL0_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL0_A :: AC0 } # [doc = "Checks if the value of the field is `USART0`"]
# [inline (always)]
pub fn is_usart0 (& self) -> bool { * self == INSEL0_A :: USART0 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL0_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL0_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB0`"]
# [inline (always)]
pub fn is_tcb0 (& self) -> bool { * self == INSEL0_A :: TCB0 } } # [doc = "Field `INSEL0` writer - LUT Input 0 Source Selection"]
pub type INSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT3CTRLB_SPEC , u8 , INSEL0_A , 4 , O > ; impl < 'a , const O : u8 > INSEL0_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL0_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL0_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL0_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL0_A :: EVENTB) } # [doc = "IO pin LUTn-IN0 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL0_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL0_A :: AC0) } # [doc = "USART0 TXD input source"]
# [inline (always)]
pub fn usart0 (self) -> & 'a mut W { self . variant (INSEL0_A :: USART0) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL0_A :: SPI0) } # [doc = "TCA0 WO0 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCA0) } # [doc = "TCB0 WO input source"]
# [inline (always)]
pub fn tcb0 (self) -> & 'a mut W { self . variant (INSEL0_A :: TCB0) } } # [doc = "Field `INSEL1` reader - LUT Input 1 Source Selection"]
pub type INSEL1_R = crate :: FieldReader < u8 , INSEL1_A > ; # [doc = "LUT Input 1 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL1_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-N1 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART1 TXD input source"]
USART1 = 8 , # [doc = "9: SPI0 MOSI input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO1 input source"]
TCA0 = 10 , # [doc = "12: TCB1 WO input source"]
TCB1 = 12 , } impl From < INSEL1_A > for u8 { # [inline (always)]
fn from (variant : INSEL1_A) -> Self { variant as _ } } impl INSEL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL1_A > { match self . bits { 0 => Some (INSEL1_A :: MASK) , 1 => Some (INSEL1_A :: FEEDBACK) , 2 => Some (INSEL1_A :: LINK) , 3 => Some (INSEL1_A :: EVENTA) , 4 => Some (INSEL1_A :: EVENTB) , 5 => Some (INSEL1_A :: IO) , 6 => Some (INSEL1_A :: AC0) , 8 => Some (INSEL1_A :: USART1) , 9 => Some (INSEL1_A :: SPI0) , 10 => Some (INSEL1_A :: TCA0) , 12 => Some (INSEL1_A :: TCB1) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL1_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL1_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL1_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL1_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL1_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL1_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL1_A :: AC0 } # [doc = "Checks if the value of the field is `USART1`"]
# [inline (always)]
pub fn is_usart1 (& self) -> bool { * self == INSEL1_A :: USART1 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL1_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL1_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB1`"]
# [inline (always)]
pub fn is_tcb1 (& self) -> bool { * self == INSEL1_A :: TCB1 } } # [doc = "Field `INSEL1` writer - LUT Input 1 Source Selection"]
pub type INSEL1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT3CTRLB_SPEC , u8 , INSEL1_A , 4 , O > ; impl < 'a , const O : u8 > INSEL1_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL1_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL1_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL1_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL1_A :: EVENTB) } # [doc = "IO pin LUTn-N1 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL1_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL1_A :: AC0) } # [doc = "USART1 TXD input source"]
# [inline (always)]
pub fn usart1 (self) -> & 'a mut W { self . variant (INSEL1_A :: USART1) } # [doc = "SPI0 MOSI input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL1_A :: SPI0) } # [doc = "TCA0 WO1 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCA0) } # [doc = "TCB1 WO input source"]
# [inline (always)]
pub fn tcb1 (self) -> & 'a mut W { self . variant (INSEL1_A :: TCB1) } } impl R { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
pub fn insel0 (& self) -> INSEL0_R { INSEL0_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
pub fn insel1 (& self) -> INSEL1_R { INSEL1_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 0 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel0 (& mut self) -> INSEL0_W < 0 > { INSEL0_W :: new (self) } # [doc = "Bits 4:7 - LUT Input 1 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel1 (& mut self) -> INSEL1_W < 4 > { INSEL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 3 B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut3ctrlb](index.html) module"]
pub struct LUT3CTRLB_SPEC ; impl crate :: RegisterSpec for LUT3CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut3ctrlb::R](R) reader structure"]
impl crate :: Readable for LUT3CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut3ctrlb::W](W) writer structure"]
impl crate :: Writable for LUT3CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT3CTRLB to value 0"]
impl crate :: Resettable for LUT3CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LUT3CTRLC (rw) register accessor: an alias for `Reg<LUT3CTRLC_SPEC>`"]
pub type LUT3CTRLC = crate :: Reg < lut3ctrlc :: LUT3CTRLC_SPEC > ; # [doc = "LUT Control 3 C"]
pub mod lut3ctrlc { # [doc = "Register `LUT3CTRLC` reader"]
pub struct R (crate :: R < LUT3CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LUT3CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LUT3CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LUT3CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `LUT3CTRLC` writer"]
pub struct W (crate :: W < LUT3CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LUT3CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LUT3CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LUT3CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INSEL2` reader - LUT Input 2 Source Selection"]
pub type INSEL2_R = crate :: FieldReader < u8 , INSEL2_A > ; # [doc = "LUT Input 2 Source Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INSEL2_A { # [doc = "0: Masked input"]
MASK = 0 , # [doc = "1: Feedback input source"]
FEEDBACK = 1 , # [doc = "2: Linked LUT input source"]
LINK = 2 , # [doc = "3: Event input source A"]
EVENTA = 3 , # [doc = "4: Event input source B"]
EVENTB = 4 , # [doc = "5: IO pin LUTn-IN2 input source"]
IO = 5 , # [doc = "6: AC0 OUT input source"]
AC0 = 6 , # [doc = "8: USART2 TXD input source"]
USART2 = 8 , # [doc = "9: SPI0 SCK input source"]
SPI0 = 9 , # [doc = "10: TCA0 WO2 input source"]
TCA0 = 10 , # [doc = "12: TCB2 WO input source"]
TCB2 = 12 , } impl From < INSEL2_A > for u8 { # [inline (always)]
fn from (variant : INSEL2_A) -> Self { variant as _ } } impl INSEL2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INSEL2_A > { match self . bits { 0 => Some (INSEL2_A :: MASK) , 1 => Some (INSEL2_A :: FEEDBACK) , 2 => Some (INSEL2_A :: LINK) , 3 => Some (INSEL2_A :: EVENTA) , 4 => Some (INSEL2_A :: EVENTB) , 5 => Some (INSEL2_A :: IO) , 6 => Some (INSEL2_A :: AC0) , 8 => Some (INSEL2_A :: USART2) , 9 => Some (INSEL2_A :: SPI0) , 10 => Some (INSEL2_A :: TCA0) , 12 => Some (INSEL2_A :: TCB2) , _ => None , } } # [doc = "Checks if the value of the field is `MASK`"]
# [inline (always)]
pub fn is_mask (& self) -> bool { * self == INSEL2_A :: MASK } # [doc = "Checks if the value of the field is `FEEDBACK`"]
# [inline (always)]
pub fn is_feedback (& self) -> bool { * self == INSEL2_A :: FEEDBACK } # [doc = "Checks if the value of the field is `LINK`"]
# [inline (always)]
pub fn is_link (& self) -> bool { * self == INSEL2_A :: LINK } # [doc = "Checks if the value of the field is `EVENTA`"]
# [inline (always)]
pub fn is_eventa (& self) -> bool { * self == INSEL2_A :: EVENTA } # [doc = "Checks if the value of the field is `EVENTB`"]
# [inline (always)]
pub fn is_eventb (& self) -> bool { * self == INSEL2_A :: EVENTB } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == INSEL2_A :: IO } # [doc = "Checks if the value of the field is `AC0`"]
# [inline (always)]
pub fn is_ac0 (& self) -> bool { * self == INSEL2_A :: AC0 } # [doc = "Checks if the value of the field is `USART2`"]
# [inline (always)]
pub fn is_usart2 (& self) -> bool { * self == INSEL2_A :: USART2 } # [doc = "Checks if the value of the field is `SPI0`"]
# [inline (always)]
pub fn is_spi0 (& self) -> bool { * self == INSEL2_A :: SPI0 } # [doc = "Checks if the value of the field is `TCA0`"]
# [inline (always)]
pub fn is_tca0 (& self) -> bool { * self == INSEL2_A :: TCA0 } # [doc = "Checks if the value of the field is `TCB2`"]
# [inline (always)]
pub fn is_tcb2 (& self) -> bool { * self == INSEL2_A :: TCB2 } } # [doc = "Field `INSEL2` writer - LUT Input 2 Source Selection"]
pub type INSEL2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LUT3CTRLC_SPEC , u8 , INSEL2_A , 4 , O > ; impl < 'a , const O : u8 > INSEL2_W < 'a , O > { # [doc = "Masked input"]
# [inline (always)]
pub fn mask (self) -> & 'a mut W { self . variant (INSEL2_A :: MASK) } # [doc = "Feedback input source"]
# [inline (always)]
pub fn feedback (self) -> & 'a mut W { self . variant (INSEL2_A :: FEEDBACK) } # [doc = "Linked LUT input source"]
# [inline (always)]
pub fn link (self) -> & 'a mut W { self . variant (INSEL2_A :: LINK) } # [doc = "Event input source A"]
# [inline (always)]
pub fn eventa (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENTA) } # [doc = "Event input source B"]
# [inline (always)]
pub fn eventb (self) -> & 'a mut W { self . variant (INSEL2_A :: EVENTB) } # [doc = "IO pin LUTn-IN2 input source"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (INSEL2_A :: IO) } # [doc = "AC0 OUT input source"]
# [inline (always)]
pub fn ac0 (self) -> & 'a mut W { self . variant (INSEL2_A :: AC0) } # [doc = "USART2 TXD input source"]
# [inline (always)]
pub fn usart2 (self) -> & 'a mut W { self . variant (INSEL2_A :: USART2) } # [doc = "SPI0 SCK input source"]
# [inline (always)]
pub fn spi0 (self) -> & 'a mut W { self . variant (INSEL2_A :: SPI0) } # [doc = "TCA0 WO2 input source"]
# [inline (always)]
pub fn tca0 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCA0) } # [doc = "TCB2 WO input source"]
# [inline (always)]
pub fn tcb2 (self) -> & 'a mut W { self . variant (INSEL2_A :: TCB2) } } impl R { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
pub fn insel2 (& self) -> INSEL2_R { INSEL2_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - LUT Input 2 Source Selection"]
# [inline (always)]
# [must_use]
pub fn insel2 (& mut self) -> INSEL2_W < 0 > { INSEL2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "LUT Control 3 C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lut3ctrlc](index.html) module"]
pub struct LUT3CTRLC_SPEC ; impl crate :: RegisterSpec for LUT3CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lut3ctrlc::R](R) reader structure"]
impl crate :: Readable for LUT3CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lut3ctrlc::W](W) writer structure"]
impl crate :: Writable for LUT3CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LUT3CTRLC to value 0"]
impl crate :: Resettable for LUT3CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SEQCTRL0 (rw) register accessor: an alias for `Reg<SEQCTRL0_SPEC>`"]
pub type SEQCTRL0 = crate :: Reg < seqctrl0 :: SEQCTRL0_SPEC > ; # [doc = "Sequential Control 0"]
pub mod seqctrl0 { # [doc = "Register `SEQCTRL0` reader"]
pub struct R (crate :: R < SEQCTRL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SEQCTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SEQCTRL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SEQCTRL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SEQCTRL0` writer"]
pub struct W (crate :: W < SEQCTRL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SEQCTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SEQCTRL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SEQCTRL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `SEQSEL0` reader - Sequential Selection"]
pub type SEQSEL0_R = crate :: FieldReader < u8 , SEQSEL0_A > ; # [doc = "Sequential Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SEQSEL0_A { # [doc = "0: Sequential logic disabled"]
DISABLE = 0 , # [doc = "1: D FlipFlop"]
DFF = 1 , # [doc = "2: JK FlipFlop"]
JK = 2 , # [doc = "3: D Latch"]
LATCH = 3 , # [doc = "4: RS Latch"]
RS = 4 , } impl From < SEQSEL0_A > for u8 { # [inline (always)]
fn from (variant : SEQSEL0_A) -> Self { variant as _ } } impl SEQSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SEQSEL0_A > { match self . bits { 0 => Some (SEQSEL0_A :: DISABLE) , 1 => Some (SEQSEL0_A :: DFF) , 2 => Some (SEQSEL0_A :: JK) , 3 => Some (SEQSEL0_A :: LATCH) , 4 => Some (SEQSEL0_A :: RS) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SEQSEL0_A :: DISABLE } # [doc = "Checks if the value of the field is `DFF`"]
# [inline (always)]
pub fn is_dff (& self) -> bool { * self == SEQSEL0_A :: DFF } # [doc = "Checks if the value of the field is `JK`"]
# [inline (always)]
pub fn is_jk (& self) -> bool { * self == SEQSEL0_A :: JK } # [doc = "Checks if the value of the field is `LATCH`"]
# [inline (always)]
pub fn is_latch (& self) -> bool { * self == SEQSEL0_A :: LATCH } # [doc = "Checks if the value of the field is `RS`"]
# [inline (always)]
pub fn is_rs (& self) -> bool { * self == SEQSEL0_A :: RS } } # [doc = "Field `SEQSEL0` writer - Sequential Selection"]
pub type SEQSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SEQCTRL0_SPEC , u8 , SEQSEL0_A , 3 , O > ; impl < 'a , const O : u8 > SEQSEL0_W < 'a , O > { # [doc = "Sequential logic disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (SEQSEL0_A :: DISABLE) } # [doc = "D FlipFlop"]
# [inline (always)]
pub fn dff (self) -> & 'a mut W { self . variant (SEQSEL0_A :: DFF) } # [doc = "JK FlipFlop"]
# [inline (always)]
pub fn jk (self) -> & 'a mut W { self . variant (SEQSEL0_A :: JK) } # [doc = "D Latch"]
# [inline (always)]
pub fn latch (self) -> & 'a mut W { self . variant (SEQSEL0_A :: LATCH) } # [doc = "RS Latch"]
# [inline (always)]
pub fn rs (self) -> & 'a mut W { self . variant (SEQSEL0_A :: RS) } } impl R { # [doc = "Bits 0:2 - Sequential Selection"]
# [inline (always)]
pub fn seqsel0 (& self) -> SEQSEL0_R { SEQSEL0_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Sequential Selection"]
# [inline (always)]
# [must_use]
pub fn seqsel0 (& mut self) -> SEQSEL0_W < 0 > { SEQSEL0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sequential Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [seqctrl0](index.html) module"]
pub struct SEQCTRL0_SPEC ; impl crate :: RegisterSpec for SEQCTRL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [seqctrl0::R](R) reader structure"]
impl crate :: Readable for SEQCTRL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [seqctrl0::W](W) writer structure"]
impl crate :: Writable for SEQCTRL0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SEQCTRL0 to value 0"]
impl crate :: Resettable for SEQCTRL0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SEQCTRL1 (rw) register accessor: an alias for `Reg<SEQCTRL1_SPEC>`"]
pub type SEQCTRL1 = crate :: Reg < seqctrl1 :: SEQCTRL1_SPEC > ; # [doc = "Sequential Control 1"]
pub mod seqctrl1 { # [doc = "Register `SEQCTRL1` reader"]
pub struct R (crate :: R < SEQCTRL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SEQCTRL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SEQCTRL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SEQCTRL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SEQCTRL1` writer"]
pub struct W (crate :: W < SEQCTRL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SEQCTRL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SEQCTRL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SEQCTRL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `SEQSEL1` reader - Sequential Selection"]
pub type SEQSEL1_R = crate :: FieldReader < u8 , SEQSEL1_A > ; # [doc = "Sequential Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SEQSEL1_A { # [doc = "0: Sequential logic disabled"]
DISABLE = 0 , # [doc = "1: D FlipFlop"]
DFF = 1 , # [doc = "2: JK FlipFlop"]
JK = 2 , # [doc = "3: D Latch"]
LATCH = 3 , # [doc = "4: RS Latch"]
RS = 4 , } impl From < SEQSEL1_A > for u8 { # [inline (always)]
fn from (variant : SEQSEL1_A) -> Self { variant as _ } } impl SEQSEL1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SEQSEL1_A > { match self . bits { 0 => Some (SEQSEL1_A :: DISABLE) , 1 => Some (SEQSEL1_A :: DFF) , 2 => Some (SEQSEL1_A :: JK) , 3 => Some (SEQSEL1_A :: LATCH) , 4 => Some (SEQSEL1_A :: RS) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SEQSEL1_A :: DISABLE } # [doc = "Checks if the value of the field is `DFF`"]
# [inline (always)]
pub fn is_dff (& self) -> bool { * self == SEQSEL1_A :: DFF } # [doc = "Checks if the value of the field is `JK`"]
# [inline (always)]
pub fn is_jk (& self) -> bool { * self == SEQSEL1_A :: JK } # [doc = "Checks if the value of the field is `LATCH`"]
# [inline (always)]
pub fn is_latch (& self) -> bool { * self == SEQSEL1_A :: LATCH } # [doc = "Checks if the value of the field is `RS`"]
# [inline (always)]
pub fn is_rs (& self) -> bool { * self == SEQSEL1_A :: RS } } # [doc = "Field `SEQSEL1` writer - Sequential Selection"]
pub type SEQSEL1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SEQCTRL1_SPEC , u8 , SEQSEL1_A , 3 , O > ; impl < 'a , const O : u8 > SEQSEL1_W < 'a , O > { # [doc = "Sequential logic disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (SEQSEL1_A :: DISABLE) } # [doc = "D FlipFlop"]
# [inline (always)]
pub fn dff (self) -> & 'a mut W { self . variant (SEQSEL1_A :: DFF) } # [doc = "JK FlipFlop"]
# [inline (always)]
pub fn jk (self) -> & 'a mut W { self . variant (SEQSEL1_A :: JK) } # [doc = "D Latch"]
# [inline (always)]
pub fn latch (self) -> & 'a mut W { self . variant (SEQSEL1_A :: LATCH) } # [doc = "RS Latch"]
# [inline (always)]
pub fn rs (self) -> & 'a mut W { self . variant (SEQSEL1_A :: RS) } } impl R { # [doc = "Bits 0:2 - Sequential Selection"]
# [inline (always)]
pub fn seqsel1 (& self) -> SEQSEL1_R { SEQSEL1_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Sequential Selection"]
# [inline (always)]
# [must_use]
pub fn seqsel1 (& mut self) -> SEQSEL1_W < 0 > { SEQSEL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sequential Control 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [seqctrl1](index.html) module"]
pub struct SEQCTRL1_SPEC ; impl crate :: RegisterSpec for SEQCTRL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [seqctrl1::R](R) reader structure"]
impl crate :: Readable for SEQCTRL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [seqctrl1::W](W) writer structure"]
impl crate :: Writable for SEQCTRL1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SEQCTRL1 to value 0"]
impl crate :: Resettable for SEQCTRL1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRUTH0 (rw) register accessor: an alias for `Reg<TRUTH0_SPEC>`"]
pub type TRUTH0 = crate :: Reg < truth0 :: TRUTH0_SPEC > ; # [doc = "Truth 0"]
pub mod truth0 { # [doc = "Register `TRUTH0` reader"]
pub struct R (crate :: R < TRUTH0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRUTH0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRUTH0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRUTH0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRUTH0` writer"]
pub struct W (crate :: W < TRUTH0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRUTH0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRUTH0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRUTH0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Truth 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [truth0](index.html) module"]
pub struct TRUTH0_SPEC ; impl crate :: RegisterSpec for TRUTH0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [truth0::R](R) reader structure"]
impl crate :: Readable for TRUTH0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [truth0::W](W) writer structure"]
impl crate :: Writable for TRUTH0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRUTH0 to value 0"]
impl crate :: Resettable for TRUTH0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRUTH1 (rw) register accessor: an alias for `Reg<TRUTH1_SPEC>`"]
pub type TRUTH1 = crate :: Reg < truth1 :: TRUTH1_SPEC > ; # [doc = "Truth 1"]
pub mod truth1 { # [doc = "Register `TRUTH1` reader"]
pub struct R (crate :: R < TRUTH1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRUTH1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRUTH1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRUTH1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRUTH1` writer"]
pub struct W (crate :: W < TRUTH1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRUTH1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRUTH1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRUTH1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Truth 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [truth1](index.html) module"]
pub struct TRUTH1_SPEC ; impl crate :: RegisterSpec for TRUTH1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [truth1::R](R) reader structure"]
impl crate :: Readable for TRUTH1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [truth1::W](W) writer structure"]
impl crate :: Writable for TRUTH1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRUTH1 to value 0"]
impl crate :: Resettable for TRUTH1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRUTH2 (rw) register accessor: an alias for `Reg<TRUTH2_SPEC>`"]
pub type TRUTH2 = crate :: Reg < truth2 :: TRUTH2_SPEC > ; # [doc = "Truth 2"]
pub mod truth2 { # [doc = "Register `TRUTH2` reader"]
pub struct R (crate :: R < TRUTH2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRUTH2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRUTH2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRUTH2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRUTH2` writer"]
pub struct W (crate :: W < TRUTH2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRUTH2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRUTH2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRUTH2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Truth 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [truth2](index.html) module"]
pub struct TRUTH2_SPEC ; impl crate :: RegisterSpec for TRUTH2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [truth2::R](R) reader structure"]
impl crate :: Readable for TRUTH2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [truth2::W](W) writer structure"]
impl crate :: Writable for TRUTH2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRUTH2 to value 0"]
impl crate :: Resettable for TRUTH2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TRUTH3 (rw) register accessor: an alias for `Reg<TRUTH3_SPEC>`"]
pub type TRUTH3 = crate :: Reg < truth3 :: TRUTH3_SPEC > ; # [doc = "Truth 3"]
pub mod truth3 { # [doc = "Register `TRUTH3` reader"]
pub struct R (crate :: R < TRUTH3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TRUTH3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TRUTH3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TRUTH3_SPEC >) -> Self { R (reader) } } # [doc = "Register `TRUTH3` writer"]
pub struct W (crate :: W < TRUTH3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TRUTH3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TRUTH3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TRUTH3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Truth 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [truth3](index.html) module"]
pub struct TRUTH3_SPEC ; impl crate :: RegisterSpec for TRUTH3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [truth3::R](R) reader structure"]
impl crate :: Readable for TRUTH3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [truth3::W](W) writer structure"]
impl crate :: Writable for TRUTH3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TRUTH3 to value 0"]
impl crate :: Resettable for TRUTH3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Clock controller"]
pub struct CLKCTRL { _marker : PhantomData < * const () > } unsafe impl Send for CLKCTRL { } impl CLKCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const clkctrl :: RegisterBlock = 0x60 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const clkctrl :: RegisterBlock { Self :: PTR } } impl Deref for CLKCTRL { type Target = clkctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CLKCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CLKCTRL") . finish () } } # [doc = "Clock controller"]
pub mod clkctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - MCLK Control A"]
pub mclkctrla : MCLKCTRLA , # [doc = "0x01 - MCLK Control B"]
pub mclkctrlb : MCLKCTRLB , # [doc = "0x02 - MCLK Lock"]
pub mclklock : MCLKLOCK , # [doc = "0x03 - MCLK Status"]
pub mclkstatus : MCLKSTATUS , _reserved4 : [u8 ; 0x0c]
, # [doc = "0x10 - OSC20M Control A"]
pub osc20mctrla : OSC20MCTRLA , # [doc = "0x11 - OSC20M Calibration A"]
pub osc20mcaliba : OSC20MCALIBA , # [doc = "0x12 - OSC20M Calibration B"]
pub osc20mcalibb : OSC20MCALIBB , _reserved7 : [u8 ; 0x05]
, # [doc = "0x18 - OSC32K Control A"]
pub osc32kctrla : OSC32KCTRLA , _reserved8 : [u8 ; 0x03]
, # [doc = "0x1c - XOSC32K Control A"]
pub xosc32kctrla : XOSC32KCTRLA , } # [doc = "MCLKCTRLA (rw) register accessor: an alias for `Reg<MCLKCTRLA_SPEC>`"]
pub type MCLKCTRLA = crate :: Reg < mclkctrla :: MCLKCTRLA_SPEC > ; # [doc = "MCLK Control A"]
pub mod mclkctrla { # [doc = "Register `MCLKCTRLA` reader"]
pub struct R (crate :: R < MCLKCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCLKCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCLKCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCLKCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCLKCTRLA` writer"]
pub struct W (crate :: W < MCLKCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCLKCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCLKCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCLKCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - clock select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "clock select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: 20MHz oscillator"]
OSC20M = 0 , # [doc = "1: 32KHz oscillator"]
OSCULP32K = 1 , # [doc = "2: 32.768kHz crystal oscillator"]
XOSC32K = 2 , # [doc = "3: External clock"]
EXTCLK = 3 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OSC20M , 1 => CLKSEL_A :: OSCULP32K , 2 => CLKSEL_A :: XOSC32K , 3 => CLKSEL_A :: EXTCLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OSC20M`"]
# [inline (always)]
pub fn is_osc20m (& self) -> bool { * self == CLKSEL_A :: OSC20M } # [doc = "Checks if the value of the field is `OSCULP32K`"]
# [inline (always)]
pub fn is_osculp32k (& self) -> bool { * self == CLKSEL_A :: OSCULP32K } # [doc = "Checks if the value of the field is `XOSC32K`"]
# [inline (always)]
pub fn is_xosc32k (& self) -> bool { * self == CLKSEL_A :: XOSC32K } # [doc = "Checks if the value of the field is `EXTCLK`"]
# [inline (always)]
pub fn is_extclk (& self) -> bool { * self == CLKSEL_A :: EXTCLK } } # [doc = "Field `CLKSEL` writer - clock select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MCLKCTRLA_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "20MHz oscillator"]
# [inline (always)]
pub fn osc20m (self) -> & 'a mut W { self . variant (CLKSEL_A :: OSC20M) } # [doc = "32KHz oscillator"]
# [inline (always)]
pub fn osculp32k (self) -> & 'a mut W { self . variant (CLKSEL_A :: OSCULP32K) } # [doc = "32.768kHz crystal oscillator"]
# [inline (always)]
pub fn xosc32k (self) -> & 'a mut W { self . variant (CLKSEL_A :: XOSC32K) } # [doc = "External clock"]
# [inline (always)]
pub fn extclk (self) -> & 'a mut W { self . variant (CLKSEL_A :: EXTCLK) } } # [doc = "Field `CLKOUT` reader - System clock out"]
pub type CLKOUT_R = crate :: BitReader < bool > ; # [doc = "Field `CLKOUT` writer - System clock out"]
pub type CLKOUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCLKCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - clock select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 3) } # [doc = "Bit 7 - System clock out"]
# [inline (always)]
pub fn clkout (& self) -> CLKOUT_R { CLKOUT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - clock select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Bit 7 - System clock out"]
# [inline (always)]
# [must_use]
pub fn clkout (& mut self) -> CLKOUT_W < 7 > { CLKOUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCLK Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mclkctrla](index.html) module"]
pub struct MCLKCTRLA_SPEC ; impl crate :: RegisterSpec for MCLKCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mclkctrla::R](R) reader structure"]
impl crate :: Readable for MCLKCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mclkctrla::W](W) writer structure"]
impl crate :: Writable for MCLKCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCLKCTRLA to value 0"]
impl crate :: Resettable for MCLKCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCLKCTRLB (rw) register accessor: an alias for `Reg<MCLKCTRLB_SPEC>`"]
pub type MCLKCTRLB = crate :: Reg < mclkctrlb :: MCLKCTRLB_SPEC > ; # [doc = "MCLK Control B"]
pub mod mclkctrlb { # [doc = "Register `MCLKCTRLB` reader"]
pub struct R (crate :: R < MCLKCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCLKCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCLKCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCLKCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCLKCTRLB` writer"]
pub struct W (crate :: W < MCLKCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCLKCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCLKCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCLKCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `PEN` reader - Prescaler enable"]
pub type PEN_R = crate :: BitReader < bool > ; # [doc = "Field `PEN` writer - Prescaler enable"]
pub type PEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCLKCTRLB_SPEC , bool , O > ; # [doc = "Field `PDIV` reader - Prescaler division"]
pub type PDIV_R = crate :: FieldReader < u8 , PDIV_A > ; # [doc = "Prescaler division\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PDIV_A { # [doc = "0: 2X"]
_2X = 0 , # [doc = "1: 4X"]
_4X = 1 , # [doc = "2: 8X"]
_8X = 2 , # [doc = "3: 16X"]
_16X = 3 , # [doc = "4: 32X"]
_32X = 4 , # [doc = "5: 64X"]
_64X = 5 , # [doc = "8: 6X"]
_6X = 8 , # [doc = "9: 10X"]
_10X = 9 , # [doc = "10: 12X"]
_12X = 10 , # [doc = "11: 24X"]
_24X = 11 , # [doc = "12: 48X"]
_48X = 12 , } impl From < PDIV_A > for u8 { # [inline (always)]
fn from (variant : PDIV_A) -> Self { variant as _ } } impl PDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PDIV_A > { match self . bits { 0 => Some (PDIV_A :: _2X) , 1 => Some (PDIV_A :: _4X) , 2 => Some (PDIV_A :: _8X) , 3 => Some (PDIV_A :: _16X) , 4 => Some (PDIV_A :: _32X) , 5 => Some (PDIV_A :: _64X) , 8 => Some (PDIV_A :: _6X) , 9 => Some (PDIV_A :: _10X) , 10 => Some (PDIV_A :: _12X) , 11 => Some (PDIV_A :: _24X) , 12 => Some (PDIV_A :: _48X) , _ => None , } } # [doc = "Checks if the value of the field is `_2X`"]
# [inline (always)]
pub fn is_2x (& self) -> bool { * self == PDIV_A :: _2X } # [doc = "Checks if the value of the field is `_4X`"]
# [inline (always)]
pub fn is_4x (& self) -> bool { * self == PDIV_A :: _4X } # [doc = "Checks if the value of the field is `_8X`"]
# [inline (always)]
pub fn is_8x (& self) -> bool { * self == PDIV_A :: _8X } # [doc = "Checks if the value of the field is `_16X`"]
# [inline (always)]
pub fn is_16x (& self) -> bool { * self == PDIV_A :: _16X } # [doc = "Checks if the value of the field is `_32X`"]
# [inline (always)]
pub fn is_32x (& self) -> bool { * self == PDIV_A :: _32X } # [doc = "Checks if the value of the field is `_64X`"]
# [inline (always)]
pub fn is_64x (& self) -> bool { * self == PDIV_A :: _64X } # [doc = "Checks if the value of the field is `_6X`"]
# [inline (always)]
pub fn is_6x (& self) -> bool { * self == PDIV_A :: _6X } # [doc = "Checks if the value of the field is `_10X`"]
# [inline (always)]
pub fn is_10x (& self) -> bool { * self == PDIV_A :: _10X } # [doc = "Checks if the value of the field is `_12X`"]
# [inline (always)]
pub fn is_12x (& self) -> bool { * self == PDIV_A :: _12X } # [doc = "Checks if the value of the field is `_24X`"]
# [inline (always)]
pub fn is_24x (& self) -> bool { * self == PDIV_A :: _24X } # [doc = "Checks if the value of the field is `_48X`"]
# [inline (always)]
pub fn is_48x (& self) -> bool { * self == PDIV_A :: _48X } } # [doc = "Field `PDIV` writer - Prescaler division"]
pub type PDIV_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , MCLKCTRLB_SPEC , u8 , PDIV_A , 4 , O > ; impl < 'a , const O : u8 > PDIV_W < 'a , O > { # [doc = "2X"]
# [inline (always)]
pub fn _2x (self) -> & 'a mut W { self . variant (PDIV_A :: _2X) } # [doc = "4X"]
# [inline (always)]
pub fn _4x (self) -> & 'a mut W { self . variant (PDIV_A :: _4X) } # [doc = "8X"]
# [inline (always)]
pub fn _8x (self) -> & 'a mut W { self . variant (PDIV_A :: _8X) } # [doc = "16X"]
# [inline (always)]
pub fn _16x (self) -> & 'a mut W { self . variant (PDIV_A :: _16X) } # [doc = "32X"]
# [inline (always)]
pub fn _32x (self) -> & 'a mut W { self . variant (PDIV_A :: _32X) } # [doc = "64X"]
# [inline (always)]
pub fn _64x (self) -> & 'a mut W { self . variant (PDIV_A :: _64X) } # [doc = "6X"]
# [inline (always)]
pub fn _6x (self) -> & 'a mut W { self . variant (PDIV_A :: _6X) } # [doc = "10X"]
# [inline (always)]
pub fn _10x (self) -> & 'a mut W { self . variant (PDIV_A :: _10X) } # [doc = "12X"]
# [inline (always)]
pub fn _12x (self) -> & 'a mut W { self . variant (PDIV_A :: _12X) } # [doc = "24X"]
# [inline (always)]
pub fn _24x (self) -> & 'a mut W { self . variant (PDIV_A :: _24X) } # [doc = "48X"]
# [inline (always)]
pub fn _48x (self) -> & 'a mut W { self . variant (PDIV_A :: _48X) } } impl R { # [doc = "Bit 0 - Prescaler enable"]
# [inline (always)]
pub fn pen (& self) -> PEN_R { PEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:4 - Prescaler division"]
# [inline (always)]
pub fn pdiv (& self) -> PDIV_R { PDIV_R :: new ((self . bits >> 1) & 0x0f) } } impl W { # [doc = "Bit 0 - Prescaler enable"]
# [inline (always)]
# [must_use]
pub fn pen (& mut self) -> PEN_W < 0 > { PEN_W :: new (self) } # [doc = "Bits 1:4 - Prescaler division"]
# [inline (always)]
# [must_use]
pub fn pdiv (& mut self) -> PDIV_W < 1 > { PDIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCLK Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mclkctrlb](index.html) module"]
pub struct MCLKCTRLB_SPEC ; impl crate :: RegisterSpec for MCLKCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mclkctrlb::R](R) reader structure"]
impl crate :: Readable for MCLKCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mclkctrlb::W](W) writer structure"]
impl crate :: Writable for MCLKCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCLKCTRLB to value 0"]
impl crate :: Resettable for MCLKCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCLKLOCK (rw) register accessor: an alias for `Reg<MCLKLOCK_SPEC>`"]
pub type MCLKLOCK = crate :: Reg < mclklock :: MCLKLOCK_SPEC > ; # [doc = "MCLK Lock"]
pub mod mclklock { # [doc = "Register `MCLKLOCK` reader"]
pub struct R (crate :: R < MCLKLOCK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCLKLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCLKLOCK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCLKLOCK_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCLKLOCK` writer"]
pub struct W (crate :: W < MCLKLOCK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCLKLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCLKLOCK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCLKLOCK_SPEC >) -> Self { W (writer) } } # [doc = "Field `LOCKEN` reader - lock ebable"]
pub type LOCKEN_R = crate :: BitReader < bool > ; # [doc = "Field `LOCKEN` writer - lock ebable"]
pub type LOCKEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCLKLOCK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - lock ebable"]
# [inline (always)]
pub fn locken (& self) -> LOCKEN_R { LOCKEN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - lock ebable"]
# [inline (always)]
# [must_use]
pub fn locken (& mut self) -> LOCKEN_W < 0 > { LOCKEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCLK Lock\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mclklock](index.html) module"]
pub struct MCLKLOCK_SPEC ; impl crate :: RegisterSpec for MCLKLOCK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mclklock::R](R) reader structure"]
impl crate :: Readable for MCLKLOCK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mclklock::W](W) writer structure"]
impl crate :: Writable for MCLKLOCK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCLKLOCK to value 0"]
impl crate :: Resettable for MCLKLOCK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCLKSTATUS (r) register accessor: an alias for `Reg<MCLKSTATUS_SPEC>`"]
pub type MCLKSTATUS = crate :: Reg < mclkstatus :: MCLKSTATUS_SPEC > ; # [doc = "MCLK Status"]
pub mod mclkstatus { # [doc = "Register `MCLKSTATUS` reader"]
pub struct R (crate :: R < MCLKSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCLKSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCLKSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCLKSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `SOSC` reader - System Oscillator changing"]
pub type SOSC_R = crate :: BitReader < bool > ; # [doc = "Field `OSC20MS` reader - 20MHz oscillator status"]
pub type OSC20MS_R = crate :: BitReader < bool > ; # [doc = "Field `OSC32KS` reader - 32KHz oscillator status"]
pub type OSC32KS_R = crate :: BitReader < bool > ; # [doc = "Field `XOSC32KS` reader - 32.768 kHz Crystal Oscillator status"]
pub type XOSC32KS_R = crate :: BitReader < bool > ; # [doc = "Field `EXTS` reader - External Clock status"]
pub type EXTS_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - System Oscillator changing"]
# [inline (always)]
pub fn sosc (& self) -> SOSC_R { SOSC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - 20MHz oscillator status"]
# [inline (always)]
pub fn osc20ms (& self) -> OSC20MS_R { OSC20MS_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - 32KHz oscillator status"]
# [inline (always)]
pub fn osc32ks (& self) -> OSC32KS_R { OSC32KS_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - 32.768 kHz Crystal Oscillator status"]
# [inline (always)]
pub fn xosc32ks (& self) -> XOSC32KS_R { XOSC32KS_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - External Clock status"]
# [inline (always)]
pub fn exts (& self) -> EXTS_R { EXTS_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "MCLK Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mclkstatus](index.html) module"]
pub struct MCLKSTATUS_SPEC ; impl crate :: RegisterSpec for MCLKSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mclkstatus::R](R) reader structure"]
impl crate :: Readable for MCLKSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets MCLKSTATUS to value 0"]
impl crate :: Resettable for MCLKSTATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20MCALIBA (rw) register accessor: an alias for `Reg<OSC20MCALIBA_SPEC>`"]
pub type OSC20MCALIBA = crate :: Reg < osc20mcaliba :: OSC20MCALIBA_SPEC > ; # [doc = "OSC20M Calibration A"]
pub mod osc20mcaliba { # [doc = "Register `OSC20MCALIBA` reader"]
pub struct R (crate :: R < OSC20MCALIBA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20MCALIBA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20MCALIBA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20MCALIBA_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC20MCALIBA` writer"]
pub struct W (crate :: W < OSC20MCALIBA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC20MCALIBA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC20MCALIBA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC20MCALIBA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAL20M` reader - Calibration"]
pub type CAL20M_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CAL20M` writer - Calibration"]
pub type CAL20M_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OSC20MCALIBA_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Calibration"]
# [inline (always)]
pub fn cal20m (& self) -> CAL20M_R { CAL20M_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Calibration"]
# [inline (always)]
# [must_use]
pub fn cal20m (& mut self) -> CAL20M_W < 0 > { CAL20M_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OSC20M Calibration A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20mcaliba](index.html) module"]
pub struct OSC20MCALIBA_SPEC ; impl crate :: RegisterSpec for OSC20MCALIBA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20mcaliba::R](R) reader structure"]
impl crate :: Readable for OSC20MCALIBA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc20mcaliba::W](W) writer structure"]
impl crate :: Writable for OSC20MCALIBA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSC20MCALIBA to value 0"]
impl crate :: Resettable for OSC20MCALIBA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20MCALIBB (rw) register accessor: an alias for `Reg<OSC20MCALIBB_SPEC>`"]
pub type OSC20MCALIBB = crate :: Reg < osc20mcalibb :: OSC20MCALIBB_SPEC > ; # [doc = "OSC20M Calibration B"]
pub mod osc20mcalibb { # [doc = "Register `OSC20MCALIBB` reader"]
pub struct R (crate :: R < OSC20MCALIBB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20MCALIBB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20MCALIBB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20MCALIBB_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC20MCALIBB` writer"]
pub struct W (crate :: W < OSC20MCALIBB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC20MCALIBB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC20MCALIBB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC20MCALIBB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TEMPCAL20M` reader - Oscillator temperature coefficient"]
pub type TEMPCAL20M_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TEMPCAL20M` writer - Oscillator temperature coefficient"]
pub type TEMPCAL20M_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OSC20MCALIBB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `LOCK` reader - Lock"]
pub type LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `LOCK` writer - Lock"]
pub type LOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OSC20MCALIBB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:3 - Oscillator temperature coefficient"]
# [inline (always)]
pub fn tempcal20m (& self) -> TEMPCAL20M_R { TEMPCAL20M_R :: new (self . bits & 0x0f) } # [doc = "Bit 7 - Lock"]
# [inline (always)]
pub fn lock (& self) -> LOCK_R { LOCK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Oscillator temperature coefficient"]
# [inline (always)]
# [must_use]
pub fn tempcal20m (& mut self) -> TEMPCAL20M_W < 0 > { TEMPCAL20M_W :: new (self) } # [doc = "Bit 7 - Lock"]
# [inline (always)]
# [must_use]
pub fn lock (& mut self) -> LOCK_W < 7 > { LOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OSC20M Calibration B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20mcalibb](index.html) module"]
pub struct OSC20MCALIBB_SPEC ; impl crate :: RegisterSpec for OSC20MCALIBB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20mcalibb::R](R) reader structure"]
impl crate :: Readable for OSC20MCALIBB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc20mcalibb::W](W) writer structure"]
impl crate :: Writable for OSC20MCALIBB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSC20MCALIBB to value 0"]
impl crate :: Resettable for OSC20MCALIBB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20MCTRLA (rw) register accessor: an alias for `Reg<OSC20MCTRLA_SPEC>`"]
pub type OSC20MCTRLA = crate :: Reg < osc20mctrla :: OSC20MCTRLA_SPEC > ; # [doc = "OSC20M Control A"]
pub mod osc20mctrla { # [doc = "Register `OSC20MCTRLA` reader"]
pub struct R (crate :: R < OSC20MCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20MCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20MCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20MCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC20MCTRLA` writer"]
pub struct W (crate :: W < OSC20MCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC20MCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC20MCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC20MCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RUNSTDBY` reader - Run standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OSC20MCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - Run standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 1 - Run standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 1 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OSC20M Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20mctrla](index.html) module"]
pub struct OSC20MCTRLA_SPEC ; impl crate :: RegisterSpec for OSC20MCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20mctrla::R](R) reader structure"]
impl crate :: Readable for OSC20MCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc20mctrla::W](W) writer structure"]
impl crate :: Writable for OSC20MCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSC20MCTRLA to value 0"]
impl crate :: Resettable for OSC20MCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC32KCTRLA (rw) register accessor: an alias for `Reg<OSC32KCTRLA_SPEC>`"]
pub type OSC32KCTRLA = crate :: Reg < osc32kctrla :: OSC32KCTRLA_SPEC > ; # [doc = "OSC32K Control A"]
pub mod osc32kctrla { # [doc = "Register `OSC32KCTRLA` reader"]
pub struct R (crate :: R < OSC32KCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC32KCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC32KCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC32KCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC32KCTRLA` writer"]
pub struct W (crate :: W < OSC32KCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC32KCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC32KCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC32KCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RUNSTDBY` reader - Run standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OSC32KCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - Run standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 1 - Run standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 1 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OSC32K Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc32kctrla](index.html) module"]
pub struct OSC32KCTRLA_SPEC ; impl crate :: RegisterSpec for OSC32KCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc32kctrla::R](R) reader structure"]
impl crate :: Readable for OSC32KCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc32kctrla::W](W) writer structure"]
impl crate :: Writable for OSC32KCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSC32KCTRLA to value 0"]
impl crate :: Resettable for OSC32KCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "XOSC32KCTRLA (rw) register accessor: an alias for `Reg<XOSC32KCTRLA_SPEC>`"]
pub type XOSC32KCTRLA = crate :: Reg < xosc32kctrla :: XOSC32KCTRLA_SPEC > ; # [doc = "XOSC32K Control A"]
pub mod xosc32kctrla { # [doc = "Register `XOSC32KCTRLA` reader"]
pub struct R (crate :: R < XOSC32KCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XOSC32KCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XOSC32KCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XOSC32KCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `XOSC32KCTRLA` writer"]
pub struct W (crate :: W < XOSC32KCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XOSC32KCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XOSC32KCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XOSC32KCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSC32KCTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSC32KCTRLA_SPEC , bool , O > ; # [doc = "Field `SEL` reader - Select"]
pub type SEL_R = crate :: BitReader < bool > ; # [doc = "Field `SEL` writer - Select"]
pub type SEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSC32KCTRLA_SPEC , bool , O > ; # [doc = "Field `CSUT` reader - Crystal startup time"]
pub type CSUT_R = crate :: FieldReader < u8 , CSUT_A > ; # [doc = "Crystal startup time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CSUT_A { # [doc = "0: 1k cycles"]
_1K = 0 , # [doc = "1: 16k cycles"]
_16K = 1 , # [doc = "2: 32k cycles"]
_32K = 2 , # [doc = "3: 64k cycles"]
_64K = 3 , } impl From < CSUT_A > for u8 { # [inline (always)]
fn from (variant : CSUT_A) -> Self { variant as _ } } impl CSUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CSUT_A { match self . bits { 0 => CSUT_A :: _1K , 1 => CSUT_A :: _16K , 2 => CSUT_A :: _32K , 3 => CSUT_A :: _64K , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1K`"]
# [inline (always)]
pub fn is_1k (& self) -> bool { * self == CSUT_A :: _1K } # [doc = "Checks if the value of the field is `_16K`"]
# [inline (always)]
pub fn is_16k (& self) -> bool { * self == CSUT_A :: _16K } # [doc = "Checks if the value of the field is `_32K`"]
# [inline (always)]
pub fn is_32k (& self) -> bool { * self == CSUT_A :: _32K } # [doc = "Checks if the value of the field is `_64K`"]
# [inline (always)]
pub fn is_64k (& self) -> bool { * self == CSUT_A :: _64K } } # [doc = "Field `CSUT` writer - Crystal startup time"]
pub type CSUT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , XOSC32KCTRLA_SPEC , u8 , CSUT_A , 2 , O > ; impl < 'a , const O : u8 > CSUT_W < 'a , O > { # [doc = "1k cycles"]
# [inline (always)]
pub fn _1k (self) -> & 'a mut W { self . variant (CSUT_A :: _1K) } # [doc = "16k cycles"]
# [inline (always)]
pub fn _16k (self) -> & 'a mut W { self . variant (CSUT_A :: _16K) } # [doc = "32k cycles"]
# [inline (always)]
pub fn _32k (self) -> & 'a mut W { self . variant (CSUT_A :: _32K) } # [doc = "64k cycles"]
# [inline (always)]
pub fn _64k (self) -> & 'a mut W { self . variant (CSUT_A :: _64K) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Run standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Select"]
# [inline (always)]
pub fn sel (& self) -> SEL_R { SEL_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 4:5 - Crystal startup time"]
# [inline (always)]
pub fn csut (& self) -> CSUT_R { CSUT_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Run standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 1 > { RUNSTDBY_W :: new (self) } # [doc = "Bit 2 - Select"]
# [inline (always)]
# [must_use]
pub fn sel (& mut self) -> SEL_W < 2 > { SEL_W :: new (self) } # [doc = "Bits 4:5 - Crystal startup time"]
# [inline (always)]
# [must_use]
pub fn csut (& mut self) -> CSUT_W < 4 > { CSUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "XOSC32K Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xosc32kctrla](index.html) module"]
pub struct XOSC32KCTRLA_SPEC ; impl crate :: RegisterSpec for XOSC32KCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [xosc32kctrla::R](R) reader structure"]
impl crate :: Readable for XOSC32KCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xosc32kctrla::W](W) writer structure"]
impl crate :: Writable for XOSC32KCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets XOSC32KCTRLA to value 0"]
impl crate :: Resettable for XOSC32KCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "CPU"]
pub struct CPU { _marker : PhantomData < * const () > } unsafe impl Send for CPU { } impl CPU { # [doc = r"Pointer to the register block"]
pub const PTR : * const cpu :: RegisterBlock = 0x30 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const cpu :: RegisterBlock { Self :: PTR } } impl Deref for CPU { type Target = cpu :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CPU { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CPU") . finish () } } # [doc = "CPU"]
pub mod cpu { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved0 : [u8 ; 0x04]
, # [doc = "0x04 - Configuration Change Protection"]
pub ccp : CCP , _reserved1 : [u8 ; 0x08]
, # [doc = "0x0d - Stack Pointer Low"]
pub spl : SPL , # [doc = "0x0e - Stack Pointer High"]
pub sph : SPH , } # [doc = "CCP (rw) register accessor: an alias for `Reg<CCP_SPEC>`"]
pub type CCP = crate :: Reg < ccp :: CCP_SPEC > ; # [doc = "Configuration Change Protection"]
pub mod ccp { # [doc = "Register `CCP` reader"]
pub struct R (crate :: R < CCP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCP` writer"]
pub struct W (crate :: W < CCP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCP_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCP` reader - CCP signature"]
pub type CCP_R = crate :: FieldReader < u8 , CCP_A > ; # [doc = "CCP signature\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCP_A { # [doc = "157: SPM Instruction Protection"]
SPM = 157 , # [doc = "216: IO Register Protection"]
IOREG = 216 , } impl From < CCP_A > for u8 { # [inline (always)]
fn from (variant : CCP_A) -> Self { variant as _ } } impl CCP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CCP_A > { match self . bits { 157 => Some (CCP_A :: SPM) , 216 => Some (CCP_A :: IOREG) , _ => None , } } # [doc = "Checks if the value of the field is `SPM`"]
# [inline (always)]
pub fn is_spm (& self) -> bool { * self == CCP_A :: SPM } # [doc = "Checks if the value of the field is `IOREG`"]
# [inline (always)]
pub fn is_ioreg (& self) -> bool { * self == CCP_A :: IOREG } } # [doc = "Field `CCP` writer - CCP signature"]
pub type CCP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CCP_SPEC , u8 , CCP_A , 8 , O > ; impl < 'a , const O : u8 > CCP_W < 'a , O > { # [doc = "SPM Instruction Protection"]
# [inline (always)]
pub fn spm (self) -> & 'a mut W { self . variant (CCP_A :: SPM) } # [doc = "IO Register Protection"]
# [inline (always)]
pub fn ioreg (self) -> & 'a mut W { self . variant (CCP_A :: IOREG) } } impl R { # [doc = "Bits 0:7 - CCP signature"]
# [inline (always)]
pub fn ccp (& self) -> CCP_R { CCP_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - CCP signature"]
# [inline (always)]
# [must_use]
pub fn ccp (& mut self) -> CCP_W < 0 > { CCP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Configuration Change Protection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccp](index.html) module"]
pub struct CCP_SPEC ; impl crate :: RegisterSpec for CCP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ccp::R](R) reader structure"]
impl crate :: Readable for CCP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccp::W](W) writer structure"]
impl crate :: Writable for CCP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCP to value 0"]
impl crate :: Resettable for CCP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPH (rw) register accessor: an alias for `Reg<SPH_SPEC>`"]
pub type SPH = crate :: Reg < sph :: SPH_SPEC > ; # [doc = "Stack Pointer High"]
pub mod sph { # [doc = "Register `SPH` reader"]
pub struct R (crate :: R < SPH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPH` writer"]
pub struct W (crate :: W < SPH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPH_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Stack Pointer High\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sph](index.html) module"]
pub struct SPH_SPEC ; impl crate :: RegisterSpec for SPH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sph::R](R) reader structure"]
impl crate :: Readable for SPH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sph::W](W) writer structure"]
impl crate :: Writable for SPH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPH to value 0"]
impl crate :: Resettable for SPH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPL (rw) register accessor: an alias for `Reg<SPL_SPEC>`"]
pub type SPL = crate :: Reg < spl :: SPL_SPEC > ; # [doc = "Stack Pointer Low"]
pub mod spl { # [doc = "Register `SPL` reader"]
pub struct R (crate :: R < SPL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPL` writer"]
pub struct W (crate :: W < SPL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Stack Pointer Low\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spl](index.html) module"]
pub struct SPL_SPEC ; impl crate :: RegisterSpec for SPL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spl::R](R) reader structure"]
impl crate :: Readable for SPL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spl::W](W) writer structure"]
impl crate :: Writable for SPL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPL to value 0"]
impl crate :: Resettable for SPL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Interrupt Controller"]
pub struct CPUINT { _marker : PhantomData < * const () > } unsafe impl Send for CPUINT { } impl CPUINT { # [doc = r"Pointer to the register block"]
pub const PTR : * const cpuint :: RegisterBlock = 0x0110 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const cpuint :: RegisterBlock { Self :: PTR } } impl Deref for CPUINT { type Target = cpuint :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CPUINT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CPUINT") . finish () } } # [doc = "Interrupt Controller"]
pub mod cpuint { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Status"]
pub status : STATUS , # [doc = "0x02 - Interrupt Level 0 Priority"]
pub lvl0pri : LVL0PRI , # [doc = "0x03 - Interrupt Level 1 Priority Vector"]
pub lvl1vec : LVL1VEC , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL0RR` reader - Round-robin Scheduling Enable"]
pub type LVL0RR_R = crate :: BitReader < bool > ; # [doc = "Field `LVL0RR` writer - Round-robin Scheduling Enable"]
pub type LVL0RR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CVT` reader - Compact Vector Table"]
pub type CVT_R = crate :: BitReader < bool > ; # [doc = "Field `CVT` writer - Compact Vector Table"]
pub type CVT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `IVSEL` reader - Interrupt Vector Select"]
pub type IVSEL_R = crate :: BitReader < bool > ; # [doc = "Field `IVSEL` writer - Interrupt Vector Select"]
pub type IVSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Round-robin Scheduling Enable"]
# [inline (always)]
pub fn lvl0rr (& self) -> LVL0RR_R { LVL0RR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 5 - Compact Vector Table"]
# [inline (always)]
pub fn cvt (& self) -> CVT_R { CVT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Interrupt Vector Select"]
# [inline (always)]
pub fn ivsel (& self) -> IVSEL_R { IVSEL_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Round-robin Scheduling Enable"]
# [inline (always)]
# [must_use]
pub fn lvl0rr (& mut self) -> LVL0RR_W < 0 > { LVL0RR_W :: new (self) } # [doc = "Bit 5 - Compact Vector Table"]
# [inline (always)]
# [must_use]
pub fn cvt (& mut self) -> CVT_W < 5 > { CVT_W :: new (self) } # [doc = "Bit 6 - Interrupt Vector Select"]
# [inline (always)]
# [must_use]
pub fn ivsel (& mut self) -> IVSEL_W < 6 > { IVSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LVL0PRI (rw) register accessor: an alias for `Reg<LVL0PRI_SPEC>`"]
pub type LVL0PRI = crate :: Reg < lvl0pri :: LVL0PRI_SPEC > ; # [doc = "Interrupt Level 0 Priority"]
pub mod lvl0pri { # [doc = "Register `LVL0PRI` reader"]
pub struct R (crate :: R < LVL0PRI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LVL0PRI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LVL0PRI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LVL0PRI_SPEC >) -> Self { R (reader) } } # [doc = "Register `LVL0PRI` writer"]
pub struct W (crate :: W < LVL0PRI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LVL0PRI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LVL0PRI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LVL0PRI_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL0PRI` reader - Interrupt Level Priority"]
pub type LVL0PRI_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LVL0PRI` writer - Interrupt Level Priority"]
pub type LVL0PRI_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LVL0PRI_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Interrupt Level Priority"]
# [inline (always)]
pub fn lvl0pri (& self) -> LVL0PRI_R { LVL0PRI_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Interrupt Level Priority"]
# [inline (always)]
# [must_use]
pub fn lvl0pri (& mut self) -> LVL0PRI_W < 0 > { LVL0PRI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Level 0 Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lvl0pri](index.html) module"]
pub struct LVL0PRI_SPEC ; impl crate :: RegisterSpec for LVL0PRI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lvl0pri::R](R) reader structure"]
impl crate :: Readable for LVL0PRI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lvl0pri::W](W) writer structure"]
impl crate :: Writable for LVL0PRI_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LVL0PRI to value 0"]
impl crate :: Resettable for LVL0PRI_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LVL1VEC (rw) register accessor: an alias for `Reg<LVL1VEC_SPEC>`"]
pub type LVL1VEC = crate :: Reg < lvl1vec :: LVL1VEC_SPEC > ; # [doc = "Interrupt Level 1 Priority Vector"]
pub mod lvl1vec { # [doc = "Register `LVL1VEC` reader"]
pub struct R (crate :: R < LVL1VEC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LVL1VEC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LVL1VEC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LVL1VEC_SPEC >) -> Self { R (reader) } } # [doc = "Register `LVL1VEC` writer"]
pub struct W (crate :: W < LVL1VEC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LVL1VEC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LVL1VEC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LVL1VEC_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL1VEC` reader - Interrupt Vector with High Priority"]
pub type LVL1VEC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LVL1VEC` writer - Interrupt Vector with High Priority"]
pub type LVL1VEC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LVL1VEC_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Interrupt Vector with High Priority"]
# [inline (always)]
pub fn lvl1vec (& self) -> LVL1VEC_R { LVL1VEC_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Interrupt Vector with High Priority"]
# [inline (always)]
# [must_use]
pub fn lvl1vec (& mut self) -> LVL1VEC_W < 0 > { LVL1VEC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Level 1 Priority Vector\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lvl1vec](index.html) module"]
pub struct LVL1VEC_SPEC ; impl crate :: RegisterSpec for LVL1VEC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lvl1vec::R](R) reader structure"]
impl crate :: Readable for LVL1VEC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lvl1vec::W](W) writer structure"]
impl crate :: Writable for LVL1VEC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LVL1VEC to value 0"]
impl crate :: Resettable for LVL1VEC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVL0EX` reader - Level 0 Interrupt Executing"]
pub type LVL0EX_R = crate :: BitReader < bool > ; # [doc = "Field `LVL1EX` reader - Level 1 Interrupt Executing"]
pub type LVL1EX_R = crate :: BitReader < bool > ; # [doc = "Field `NMIEX` reader - Non-maskable Interrupt Executing"]
pub type NMIEX_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Level 0 Interrupt Executing"]
# [inline (always)]
pub fn lvl0ex (& self) -> LVL0EX_R { LVL0EX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Level 1 Interrupt Executing"]
# [inline (always)]
pub fn lvl1ex (& self) -> LVL1EX_R { LVL1EX_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Non-maskable Interrupt Executing"]
# [inline (always)]
pub fn nmiex (& self) -> NMIEX_R { NMIEX_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "CRCSCAN"]
pub struct CRCSCAN { _marker : PhantomData < * const () > } unsafe impl Send for CRCSCAN { } impl CRCSCAN { # [doc = r"Pointer to the register block"]
pub const PTR : * const crcscan :: RegisterBlock = 0x0120 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const crcscan :: RegisterBlock { Self :: PTR } } impl Deref for CRCSCAN { type Target = crcscan :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CRCSCAN { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CRCSCAN") . finish () } } # [doc = "CRCSCAN"]
pub mod crcscan { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Status"]
pub status : STATUS , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable CRC scan"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable CRC scan"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `NMIEN` reader - Enable NMI Trigger"]
pub type NMIEN_R = crate :: BitReader < bool > ; # [doc = "Field `NMIEN` writer - Enable NMI Trigger"]
pub type NMIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RESET` reader - Reset CRC scan"]
pub type RESET_R = crate :: BitReader < bool > ; # [doc = "Field `RESET` writer - Reset CRC scan"]
pub type RESET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable CRC scan"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable NMI Trigger"]
# [inline (always)]
pub fn nmien (& self) -> NMIEN_R { NMIEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Reset CRC scan"]
# [inline (always)]
pub fn reset (& self) -> RESET_R { RESET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable CRC scan"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Enable NMI Trigger"]
# [inline (always)]
# [must_use]
pub fn nmien (& mut self) -> NMIEN_W < 1 > { NMIEN_W :: new (self) } # [doc = "Bit 7 - Reset CRC scan"]
# [inline (always)]
# [must_use]
pub fn reset (& mut self) -> RESET_W < 7 > { RESET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRC` reader - CRC Source"]
pub type SRC_R = crate :: FieldReader < u8 , SRC_A > ; # [doc = "CRC Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SRC_A { # [doc = "0: CRC on entire flash"]
FLASH = 0 , # [doc = "1: CRC on boot and appl section of flash"]
APPLICATION = 1 , # [doc = "2: CRC on boot section of flash"]
BOOT = 2 , } impl From < SRC_A > for u8 { # [inline (always)]
fn from (variant : SRC_A) -> Self { variant as _ } } impl SRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SRC_A > { match self . bits { 0 => Some (SRC_A :: FLASH) , 1 => Some (SRC_A :: APPLICATION) , 2 => Some (SRC_A :: BOOT) , _ => None , } } # [doc = "Checks if the value of the field is `FLASH`"]
# [inline (always)]
pub fn is_flash (& self) -> bool { * self == SRC_A :: FLASH } # [doc = "Checks if the value of the field is `APPLICATION`"]
# [inline (always)]
pub fn is_application (& self) -> bool { * self == SRC_A :: APPLICATION } # [doc = "Checks if the value of the field is `BOOT`"]
# [inline (always)]
pub fn is_boot (& self) -> bool { * self == SRC_A :: BOOT } } # [doc = "Field `SRC` writer - CRC Source"]
pub type SRC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , SRC_A , 2 , O > ; impl < 'a , const O : u8 > SRC_W < 'a , O > { # [doc = "CRC on entire flash"]
# [inline (always)]
pub fn flash (self) -> & 'a mut W { self . variant (SRC_A :: FLASH) } # [doc = "CRC on boot and appl section of flash"]
# [inline (always)]
pub fn application (self) -> & 'a mut W { self . variant (SRC_A :: APPLICATION) } # [doc = "CRC on boot section of flash"]
# [inline (always)]
pub fn boot (self) -> & 'a mut W { self . variant (SRC_A :: BOOT) } } impl R { # [doc = "Bits 0:1 - CRC Source"]
# [inline (always)]
pub fn src (& self) -> SRC_R { SRC_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - CRC Source"]
# [inline (always)]
# [must_use]
pub fn src (& mut self) -> SRC_W < 0 > { SRC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `BUSY` reader - CRC Busy"]
pub type BUSY_R = crate :: BitReader < bool > ; # [doc = "Field `OK` reader - CRC Ok"]
pub type OK_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - CRC Busy"]
# [inline (always)]
pub fn busy (& self) -> BUSY_R { BUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - CRC Ok"]
# [inline (always)]
pub fn ok (& self) -> OK_R { OK_R :: new (((self . bits >> 1) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Event System"]
pub struct EVSYS { _marker : PhantomData < * const () > } unsafe impl Send for EVSYS { } impl EVSYS { # [doc = r"Pointer to the register block"]
pub const PTR : * const evsys :: RegisterBlock = 0x0180 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const evsys :: RegisterBlock { Self :: PTR } } impl Deref for EVSYS { type Target = evsys :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EVSYS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EVSYS") . finish () } } # [doc = "Event System"]
pub mod evsys { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Channel Strobe"]
pub strobe : STROBE , _reserved1 : [u8 ; 0x0f]
, # [doc = "0x10 - Multiplexer Channel 0"]
pub channel0 : CHANNEL0 , # [doc = "0x11 - Multiplexer Channel 1"]
pub channel1 : CHANNEL1 , # [doc = "0x12 - Multiplexer Channel 2"]
pub channel2 : CHANNEL2 , # [doc = "0x13 - Multiplexer Channel 3"]
pub channel3 : CHANNEL3 , # [doc = "0x14 - Multiplexer Channel 4"]
pub channel4 : CHANNEL4 , # [doc = "0x15 - Multiplexer Channel 5"]
pub channel5 : CHANNEL5 , # [doc = "0x16 - Multiplexer Channel 6"]
pub channel6 : CHANNEL6 , # [doc = "0x17 - Multiplexer Channel 7"]
pub channel7 : CHANNEL7 , _reserved9 : [u8 ; 0x08]
, # [doc = "0x20 - User CCL LUT0 Event A"]
pub userccllut0a : USERCCLLUT0A , # [doc = "0x21 - User CCL LUT0 Event B"]
pub userccllut0b : USERCCLLUT0B , # [doc = "0x22 - User CCL LUT1 Event A"]
pub userccllut1a : USERCCLLUT1A , # [doc = "0x23 - User CCL LUT1 Event B"]
pub userccllut1b : USERCCLLUT1B , # [doc = "0x24 - User CCL LUT2 Event A"]
pub userccllut2a : USERCCLLUT2A , # [doc = "0x25 - User CCL LUT2 Event B"]
pub userccllut2b : USERCCLLUT2B , # [doc = "0x26 - User CCL LUT3 Event A"]
pub userccllut3a : USERCCLLUT3A , # [doc = "0x27 - User CCL LUT3 Event B"]
pub userccllut3b : USERCCLLUT3B , # [doc = "0x28 - User ADC0"]
pub useradc0 : USERADC0 , # [doc = "0x29 - User EVOUT Port A"]
pub userevouta : USEREVOUTA , # [doc = "0x2a - User EVOUT Port B"]
pub userevoutb : USEREVOUTB , # [doc = "0x2b - User EVOUT Port C"]
pub userevoutc : USEREVOUTC , # [doc = "0x2c - User EVOUT Port D"]
pub userevoutd : USEREVOUTD , # [doc = "0x2d - User EVOUT Port E"]
pub userevoute : USEREVOUTE , # [doc = "0x2e - User EVOUT Port F"]
pub userevoutf : USEREVOUTF , # [doc = "0x2f - User USART0"]
pub userusart0 : USERUSART0 , # [doc = "0x30 - User USART1"]
pub userusart1 : USERUSART1 , # [doc = "0x31 - User USART2"]
pub userusart2 : USERUSART2 , # [doc = "0x32 - User USART3"]
pub userusart3 : USERUSART3 , # [doc = "0x33 - User TCA0"]
pub usertca0 : USERTCA0 , # [doc = "0x34 - User TCB0"]
pub usertcb0 : USERTCB0 , # [doc = "0x35 - User TCB1"]
pub usertcb1 : USERTCB1 , # [doc = "0x36 - User TCB2"]
pub usertcb2 : USERTCB2 , # [doc = "0x37 - User TCB3"]
pub usertcb3 : USERTCB3 , } # [doc = "CHANNEL0 (rw) register accessor: an alias for `Reg<CHANNEL0_SPEC>`"]
pub type CHANNEL0 = crate :: Reg < channel0 :: CHANNEL0_SPEC > ; # [doc = "Multiplexer Channel 0"]
pub mod channel0 { # [doc = "Register `CHANNEL0` reader"]
pub struct R (crate :: R < CHANNEL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL0` writer"]
pub struct W (crate :: W < CHANNEL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENERATOR` reader - Generator selector"]
pub type GENERATOR_R = crate :: FieldReader < u8 , GENERATOR_A > ; # [doc = "Generator selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum GENERATOR_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Unified Program and Debug Interface"]
UPDI = 1 , # [doc = "6: Real Time Counter overflow"]
RTC_OVF = 6 , # [doc = "7: Real Time Counter compare"]
RTC_CMP = 7 , # [doc = "8: Periodic Interrupt Timer output 0"]
RTC_PIT0 = 8 , # [doc = "9: Periodic Interrupt Timer output 1"]
RTC_PIT1 = 9 , # [doc = "10: Periodic Interrupt Timer output 2"]
RTC_PIT2 = 10 , # [doc = "11: Periodic Interrupt Timer output 3"]
RTC_PIT3 = 11 , # [doc = "16: Configurable Custom Logic LUT0"]
CCL_LUT0 = 16 , # [doc = "17: Configurable Custom Logic LUT1"]
CCL_LUT1 = 17 , # [doc = "18: Configurable Custom Logic LUT2"]
CCL_LUT2 = 18 , # [doc = "19: Configurable Custom Logic LUT3"]
CCL_LUT3 = 19 , # [doc = "32: Analog Comparator 0 out"]
AC0_OUT = 32 , # [doc = "36: ADC 0 Result Ready Event"]
ADC0_RESRDY = 36 , # [doc = "64: Port 0 Pin 0"]
PORT0_PIN0 = 64 , # [doc = "65: Port 0 Pin 1"]
PORT0_PIN1 = 65 , # [doc = "66: Port 0 Pin 2"]
PORT0_PIN2 = 66 , # [doc = "67: Port 0 Pin 3"]
PORT0_PIN3 = 67 , # [doc = "68: Port 0 Pin 4"]
PORT0_PIN4 = 68 , # [doc = "69: Port 0 Pin 5"]
PORT0_PIN5 = 69 , # [doc = "70: Port 0 Pin 6"]
PORT0_PIN6 = 70 , # [doc = "71: Port 0 Pin 7"]
PORT0_PIN7 = 71 , # [doc = "72: Port 1 Pin 0"]
PORT1_PIN0 = 72 , # [doc = "73: Port 1 Pin 1"]
PORT1_PIN1 = 73 , # [doc = "74: Port 1 Pin 2"]
PORT1_PIN2 = 74 , # [doc = "75: Port 1 Pin 3"]
PORT1_PIN3 = 75 , # [doc = "76: Port 1 Pin 4"]
PORT1_PIN4 = 76 , # [doc = "77: Port 1 Pin 5"]
PORT1_PIN5 = 77 , # [doc = "78: Port 1 Pin 6"]
PORT1_PIN6 = 78 , # [doc = "79: Port 1 Pin 7"]
PORT1_PIN7 = 79 , # [doc = "96: USART 0 Xclock"]
USART0_XCK = 96 , # [doc = "97: USART 1 Xclock"]
USART1_XCK = 97 , # [doc = "98: USART 2 Xclock"]
USART2_XCK = 98 , # [doc = "99: USART 3 Xclock"]
USART3_XCK = 99 , # [doc = "104: SPI 0 Sclock"]
SPI0_SCK = 104 , # [doc = "128: Timer/Counter A0 overflow / low byte underflow"]
TCA0_OVF_LUNF = 128 , # [doc = "129: Timer/Counter A0 high byte underflow (split mode)"]
TCA0_HUNF = 129 , # [doc = "132: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 132 , # [doc = "133: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 133 , # [doc = "134: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 134 , # [doc = "160: Timer/Counter B0 capture"]
TCB0_CAPT = 160 , # [doc = "162: Timer/Counter B1 capture"]
TCB1_CAPT = 162 , # [doc = "164: Timer/Counter B2 capture"]
TCB2_CAPT = 164 , # [doc = "166: Timer/Counter B3 capture"]
TCB3_CAPT = 166 , } impl From < GENERATOR_A > for u8 { # [inline (always)]
fn from (variant : GENERATOR_A) -> Self { variant as _ } } impl GENERATOR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GENERATOR_A > { match self . bits { 0 => Some (GENERATOR_A :: OFF) , 1 => Some (GENERATOR_A :: UPDI) , 6 => Some (GENERATOR_A :: RTC_OVF) , 7 => Some (GENERATOR_A :: RTC_CMP) , 8 => Some (GENERATOR_A :: RTC_PIT0) , 9 => Some (GENERATOR_A :: RTC_PIT1) , 10 => Some (GENERATOR_A :: RTC_PIT2) , 11 => Some (GENERATOR_A :: RTC_PIT3) , 16 => Some (GENERATOR_A :: CCL_LUT0) , 17 => Some (GENERATOR_A :: CCL_LUT1) , 18 => Some (GENERATOR_A :: CCL_LUT2) , 19 => Some (GENERATOR_A :: CCL_LUT3) , 32 => Some (GENERATOR_A :: AC0_OUT) , 36 => Some (GENERATOR_A :: ADC0_RESRDY) , 64 => Some (GENERATOR_A :: PORT0_PIN0) , 65 => Some (GENERATOR_A :: PORT0_PIN1) , 66 => Some (GENERATOR_A :: PORT0_PIN2) , 67 => Some (GENERATOR_A :: PORT0_PIN3) , 68 => Some (GENERATOR_A :: PORT0_PIN4) , 69 => Some (GENERATOR_A :: PORT0_PIN5) , 70 => Some (GENERATOR_A :: PORT0_PIN6) , 71 => Some (GENERATOR_A :: PORT0_PIN7) , 72 => Some (GENERATOR_A :: PORT1_PIN0) , 73 => Some (GENERATOR_A :: PORT1_PIN1) , 74 => Some (GENERATOR_A :: PORT1_PIN2) , 75 => Some (GENERATOR_A :: PORT1_PIN3) , 76 => Some (GENERATOR_A :: PORT1_PIN4) , 77 => Some (GENERATOR_A :: PORT1_PIN5) , 78 => Some (GENERATOR_A :: PORT1_PIN6) , 79 => Some (GENERATOR_A :: PORT1_PIN7) , 96 => Some (GENERATOR_A :: USART0_XCK) , 97 => Some (GENERATOR_A :: USART1_XCK) , 98 => Some (GENERATOR_A :: USART2_XCK) , 99 => Some (GENERATOR_A :: USART3_XCK) , 104 => Some (GENERATOR_A :: SPI0_SCK) , 128 => Some (GENERATOR_A :: TCA0_OVF_LUNF) , 129 => Some (GENERATOR_A :: TCA0_HUNF) , 132 => Some (GENERATOR_A :: TCA0_CMP0) , 133 => Some (GENERATOR_A :: TCA0_CMP1) , 134 => Some (GENERATOR_A :: TCA0_CMP2) , 160 => Some (GENERATOR_A :: TCB0_CAPT) , 162 => Some (GENERATOR_A :: TCB1_CAPT) , 164 => Some (GENERATOR_A :: TCB2_CAPT) , 166 => Some (GENERATOR_A :: TCB3_CAPT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == GENERATOR_A :: OFF } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == GENERATOR_A :: UPDI } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == GENERATOR_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == GENERATOR_A :: RTC_CMP } # [doc = "Checks if the value of the field is `RTC_PIT0`"]
# [inline (always)]
pub fn is_rtc_pit0 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT0 } # [doc = "Checks if the value of the field is `RTC_PIT1`"]
# [inline (always)]
pub fn is_rtc_pit1 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT1 } # [doc = "Checks if the value of the field is `RTC_PIT2`"]
# [inline (always)]
pub fn is_rtc_pit2 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT2 } # [doc = "Checks if the value of the field is `RTC_PIT3`"]
# [inline (always)]
pub fn is_rtc_pit3 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT3 } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `CCL_LUT2`"]
# [inline (always)]
pub fn is_ccl_lut2 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT2 } # [doc = "Checks if the value of the field is `CCL_LUT3`"]
# [inline (always)]
pub fn is_ccl_lut3 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT3 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == GENERATOR_A :: AC0_OUT } # [doc = "Checks if the value of the field is `ADC0_RESRDY`"]
# [inline (always)]
pub fn is_adc0_resrdy (& self) -> bool { * self == GENERATOR_A :: ADC0_RESRDY } # [doc = "Checks if the value of the field is `PORT0_PIN0`"]
# [inline (always)]
pub fn is_port0_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN0 } # [doc = "Checks if the value of the field is `PORT0_PIN1`"]
# [inline (always)]
pub fn is_port0_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN1 } # [doc = "Checks if the value of the field is `PORT0_PIN2`"]
# [inline (always)]
pub fn is_port0_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN2 } # [doc = "Checks if the value of the field is `PORT0_PIN3`"]
# [inline (always)]
pub fn is_port0_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN3 } # [doc = "Checks if the value of the field is `PORT0_PIN4`"]
# [inline (always)]
pub fn is_port0_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN4 } # [doc = "Checks if the value of the field is `PORT0_PIN5`"]
# [inline (always)]
pub fn is_port0_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN5 } # [doc = "Checks if the value of the field is `PORT0_PIN6`"]
# [inline (always)]
pub fn is_port0_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN6 } # [doc = "Checks if the value of the field is `PORT0_PIN7`"]
# [inline (always)]
pub fn is_port0_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN7 } # [doc = "Checks if the value of the field is `PORT1_PIN0`"]
# [inline (always)]
pub fn is_port1_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN0 } # [doc = "Checks if the value of the field is `PORT1_PIN1`"]
# [inline (always)]
pub fn is_port1_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN1 } # [doc = "Checks if the value of the field is `PORT1_PIN2`"]
# [inline (always)]
pub fn is_port1_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN2 } # [doc = "Checks if the value of the field is `PORT1_PIN3`"]
# [inline (always)]
pub fn is_port1_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN3 } # [doc = "Checks if the value of the field is `PORT1_PIN4`"]
# [inline (always)]
pub fn is_port1_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN4 } # [doc = "Checks if the value of the field is `PORT1_PIN5`"]
# [inline (always)]
pub fn is_port1_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN5 } # [doc = "Checks if the value of the field is `PORT1_PIN6`"]
# [inline (always)]
pub fn is_port1_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN6 } # [doc = "Checks if the value of the field is `PORT1_PIN7`"]
# [inline (always)]
pub fn is_port1_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN7 } # [doc = "Checks if the value of the field is `USART0_XCK`"]
# [inline (always)]
pub fn is_usart0_xck (& self) -> bool { * self == GENERATOR_A :: USART0_XCK } # [doc = "Checks if the value of the field is `USART1_XCK`"]
# [inline (always)]
pub fn is_usart1_xck (& self) -> bool { * self == GENERATOR_A :: USART1_XCK } # [doc = "Checks if the value of the field is `USART2_XCK`"]
# [inline (always)]
pub fn is_usart2_xck (& self) -> bool { * self == GENERATOR_A :: USART2_XCK } # [doc = "Checks if the value of the field is `USART3_XCK`"]
# [inline (always)]
pub fn is_usart3_xck (& self) -> bool { * self == GENERATOR_A :: USART3_XCK } # [doc = "Checks if the value of the field is `SPI0_SCK`"]
# [inline (always)]
pub fn is_spi0_sck (& self) -> bool { * self == GENERATOR_A :: SPI0_SCK } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == GENERATOR_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == GENERATOR_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `TCB0_CAPT`"]
# [inline (always)]
pub fn is_tcb0_capt (& self) -> bool { * self == GENERATOR_A :: TCB0_CAPT } # [doc = "Checks if the value of the field is `TCB1_CAPT`"]
# [inline (always)]
pub fn is_tcb1_capt (& self) -> bool { * self == GENERATOR_A :: TCB1_CAPT } # [doc = "Checks if the value of the field is `TCB2_CAPT`"]
# [inline (always)]
pub fn is_tcb2_capt (& self) -> bool { * self == GENERATOR_A :: TCB2_CAPT } # [doc = "Checks if the value of the field is `TCB3_CAPT`"]
# [inline (always)]
pub fn is_tcb3_capt (& self) -> bool { * self == GENERATOR_A :: TCB3_CAPT } } # [doc = "Field `GENERATOR` writer - Generator selector"]
pub type GENERATOR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CHANNEL0_SPEC , u8 , GENERATOR_A , 8 , O > ; impl < 'a , const O : u8 > GENERATOR_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (GENERATOR_A :: OFF) } # [doc = "Unified Program and Debug Interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (GENERATOR_A :: UPDI) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_CMP) } # [doc = "Periodic Interrupt Timer output 0"]
# [inline (always)]
pub fn rtc_pit0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT0) } # [doc = "Periodic Interrupt Timer output 1"]
# [inline (always)]
pub fn rtc_pit1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT1) } # [doc = "Periodic Interrupt Timer output 2"]
# [inline (always)]
pub fn rtc_pit2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT2) } # [doc = "Periodic Interrupt Timer output 3"]
# [inline (always)]
pub fn rtc_pit3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT3) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT1) } # [doc = "Configurable Custom Logic LUT2"]
# [inline (always)]
pub fn ccl_lut2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT2) } # [doc = "Configurable Custom Logic LUT3"]
# [inline (always)]
pub fn ccl_lut3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT3) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (GENERATOR_A :: AC0_OUT) } # [doc = "ADC 0 Result Ready Event"]
# [inline (always)]
pub fn adc0_resrdy (self) -> & 'a mut W { self . variant (GENERATOR_A :: ADC0_RESRDY) } # [doc = "Port 0 Pin 0"]
# [inline (always)]
pub fn port0_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN0) } # [doc = "Port 0 Pin 1"]
# [inline (always)]
pub fn port0_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN1) } # [doc = "Port 0 Pin 2"]
# [inline (always)]
pub fn port0_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN2) } # [doc = "Port 0 Pin 3"]
# [inline (always)]
pub fn port0_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN3) } # [doc = "Port 0 Pin 4"]
# [inline (always)]
pub fn port0_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN4) } # [doc = "Port 0 Pin 5"]
# [inline (always)]
pub fn port0_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN5) } # [doc = "Port 0 Pin 6"]
# [inline (always)]
pub fn port0_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN6) } # [doc = "Port 0 Pin 7"]
# [inline (always)]
pub fn port0_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN7) } # [doc = "Port 1 Pin 0"]
# [inline (always)]
pub fn port1_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN0) } # [doc = "Port 1 Pin 1"]
# [inline (always)]
pub fn port1_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN1) } # [doc = "Port 1 Pin 2"]
# [inline (always)]
pub fn port1_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN2) } # [doc = "Port 1 Pin 3"]
# [inline (always)]
pub fn port1_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN3) } # [doc = "Port 1 Pin 4"]
# [inline (always)]
pub fn port1_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN4) } # [doc = "Port 1 Pin 5"]
# [inline (always)]
pub fn port1_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN5) } # [doc = "Port 1 Pin 6"]
# [inline (always)]
pub fn port1_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN6) } # [doc = "Port 1 Pin 7"]
# [inline (always)]
pub fn port1_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN7) } # [doc = "USART 0 Xclock"]
# [inline (always)]
pub fn usart0_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART0_XCK) } # [doc = "USART 1 Xclock"]
# [inline (always)]
pub fn usart1_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART1_XCK) } # [doc = "USART 2 Xclock"]
# [inline (always)]
pub fn usart2_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART2_XCK) } # [doc = "USART 3 Xclock"]
# [inline (always)]
pub fn usart3_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART3_XCK) } # [doc = "SPI 0 Sclock"]
# [inline (always)]
pub fn spi0_sck (self) -> & 'a mut W { self . variant (GENERATOR_A :: SPI0_SCK) } # [doc = "Timer/Counter A0 overflow / low byte underflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 high byte underflow (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP2) } # [doc = "Timer/Counter B0 capture"]
# [inline (always)]
pub fn tcb0_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB0_CAPT) } # [doc = "Timer/Counter B1 capture"]
# [inline (always)]
pub fn tcb1_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB1_CAPT) } # [doc = "Timer/Counter B2 capture"]
# [inline (always)]
pub fn tcb2_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB2_CAPT) } # [doc = "Timer/Counter B3 capture"]
# [inline (always)]
pub fn tcb3_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB3_CAPT) } } impl R { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
pub fn generator (& self) -> GENERATOR_R { GENERATOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
# [must_use]
pub fn generator (& mut self) -> GENERATOR_W < 0 > { GENERATOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiplexer Channel 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel0](index.html) module"]
pub struct CHANNEL0_SPEC ; impl crate :: RegisterSpec for CHANNEL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [channel0::R](R) reader structure"]
impl crate :: Readable for CHANNEL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel0::W](W) writer structure"]
impl crate :: Writable for CHANNEL0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHANNEL0 to value 0"]
impl crate :: Resettable for CHANNEL0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHANNEL1 (rw) register accessor: an alias for `Reg<CHANNEL1_SPEC>`"]
pub type CHANNEL1 = crate :: Reg < channel1 :: CHANNEL1_SPEC > ; # [doc = "Multiplexer Channel 1"]
pub mod channel1 { # [doc = "Register `CHANNEL1` reader"]
pub struct R (crate :: R < CHANNEL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL1` writer"]
pub struct W (crate :: W < CHANNEL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL1_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENERATOR` reader - Generator selector"]
pub type GENERATOR_R = crate :: FieldReader < u8 , GENERATOR_A > ; # [doc = "Generator selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum GENERATOR_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Unified Program and Debug Interface"]
UPDI = 1 , # [doc = "6: Real Time Counter overflow"]
RTC_OVF = 6 , # [doc = "7: Real Time Counter compare"]
RTC_CMP = 7 , # [doc = "8: Periodic Interrupt Timer output 0"]
RTC_PIT0 = 8 , # [doc = "9: Periodic Interrupt Timer output 1"]
RTC_PIT1 = 9 , # [doc = "10: Periodic Interrupt Timer output 2"]
RTC_PIT2 = 10 , # [doc = "11: Periodic Interrupt Timer output 3"]
RTC_PIT3 = 11 , # [doc = "16: Configurable Custom Logic LUT0"]
CCL_LUT0 = 16 , # [doc = "17: Configurable Custom Logic LUT1"]
CCL_LUT1 = 17 , # [doc = "18: Configurable Custom Logic LUT2"]
CCL_LUT2 = 18 , # [doc = "19: Configurable Custom Logic LUT3"]
CCL_LUT3 = 19 , # [doc = "32: Analog Comparator 0 out"]
AC0_OUT = 32 , # [doc = "36: ADC 0 Result Ready Event"]
ADC0_RESRDY = 36 , # [doc = "64: Port 0 Pin 0"]
PORT0_PIN0 = 64 , # [doc = "65: Port 0 Pin 1"]
PORT0_PIN1 = 65 , # [doc = "66: Port 0 Pin 2"]
PORT0_PIN2 = 66 , # [doc = "67: Port 0 Pin 3"]
PORT0_PIN3 = 67 , # [doc = "68: Port 0 Pin 4"]
PORT0_PIN4 = 68 , # [doc = "69: Port 0 Pin 5"]
PORT0_PIN5 = 69 , # [doc = "70: Port 0 Pin 6"]
PORT0_PIN6 = 70 , # [doc = "71: Port 0 Pin 7"]
PORT0_PIN7 = 71 , # [doc = "72: Port 1 Pin 0"]
PORT1_PIN0 = 72 , # [doc = "73: Port 1 Pin 1"]
PORT1_PIN1 = 73 , # [doc = "74: Port 1 Pin 2"]
PORT1_PIN2 = 74 , # [doc = "75: Port 1 Pin 3"]
PORT1_PIN3 = 75 , # [doc = "76: Port 1 Pin 4"]
PORT1_PIN4 = 76 , # [doc = "77: Port 1 Pin 5"]
PORT1_PIN5 = 77 , # [doc = "78: Port 1 Pin 6"]
PORT1_PIN6 = 78 , # [doc = "79: Port 1 Pin 7"]
PORT1_PIN7 = 79 , # [doc = "96: USART 0 Xclock"]
USART0_XCK = 96 , # [doc = "97: USART 1 Xclock"]
USART1_XCK = 97 , # [doc = "98: USART 2 Xclock"]
USART2_XCK = 98 , # [doc = "99: USART 3 Xclock"]
USART3_XCK = 99 , # [doc = "104: SPI 0 Sclock"]
SPI0_SCK = 104 , # [doc = "128: Timer/Counter A0 overflow / low byte underflow"]
TCA0_OVF_LUNF = 128 , # [doc = "129: Timer/Counter A0 high byte underflow (split mode)"]
TCA0_HUNF = 129 , # [doc = "132: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 132 , # [doc = "133: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 133 , # [doc = "134: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 134 , # [doc = "160: Timer/Counter B0 capture"]
TCB0_CAPT = 160 , # [doc = "162: Timer/Counter B1 capture"]
TCB1_CAPT = 162 , # [doc = "164: Timer/Counter B2 capture"]
TCB2_CAPT = 164 , # [doc = "166: Timer/Counter B3 capture"]
TCB3_CAPT = 166 , } impl From < GENERATOR_A > for u8 { # [inline (always)]
fn from (variant : GENERATOR_A) -> Self { variant as _ } } impl GENERATOR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GENERATOR_A > { match self . bits { 0 => Some (GENERATOR_A :: OFF) , 1 => Some (GENERATOR_A :: UPDI) , 6 => Some (GENERATOR_A :: RTC_OVF) , 7 => Some (GENERATOR_A :: RTC_CMP) , 8 => Some (GENERATOR_A :: RTC_PIT0) , 9 => Some (GENERATOR_A :: RTC_PIT1) , 10 => Some (GENERATOR_A :: RTC_PIT2) , 11 => Some (GENERATOR_A :: RTC_PIT3) , 16 => Some (GENERATOR_A :: CCL_LUT0) , 17 => Some (GENERATOR_A :: CCL_LUT1) , 18 => Some (GENERATOR_A :: CCL_LUT2) , 19 => Some (GENERATOR_A :: CCL_LUT3) , 32 => Some (GENERATOR_A :: AC0_OUT) , 36 => Some (GENERATOR_A :: ADC0_RESRDY) , 64 => Some (GENERATOR_A :: PORT0_PIN0) , 65 => Some (GENERATOR_A :: PORT0_PIN1) , 66 => Some (GENERATOR_A :: PORT0_PIN2) , 67 => Some (GENERATOR_A :: PORT0_PIN3) , 68 => Some (GENERATOR_A :: PORT0_PIN4) , 69 => Some (GENERATOR_A :: PORT0_PIN5) , 70 => Some (GENERATOR_A :: PORT0_PIN6) , 71 => Some (GENERATOR_A :: PORT0_PIN7) , 72 => Some (GENERATOR_A :: PORT1_PIN0) , 73 => Some (GENERATOR_A :: PORT1_PIN1) , 74 => Some (GENERATOR_A :: PORT1_PIN2) , 75 => Some (GENERATOR_A :: PORT1_PIN3) , 76 => Some (GENERATOR_A :: PORT1_PIN4) , 77 => Some (GENERATOR_A :: PORT1_PIN5) , 78 => Some (GENERATOR_A :: PORT1_PIN6) , 79 => Some (GENERATOR_A :: PORT1_PIN7) , 96 => Some (GENERATOR_A :: USART0_XCK) , 97 => Some (GENERATOR_A :: USART1_XCK) , 98 => Some (GENERATOR_A :: USART2_XCK) , 99 => Some (GENERATOR_A :: USART3_XCK) , 104 => Some (GENERATOR_A :: SPI0_SCK) , 128 => Some (GENERATOR_A :: TCA0_OVF_LUNF) , 129 => Some (GENERATOR_A :: TCA0_HUNF) , 132 => Some (GENERATOR_A :: TCA0_CMP0) , 133 => Some (GENERATOR_A :: TCA0_CMP1) , 134 => Some (GENERATOR_A :: TCA0_CMP2) , 160 => Some (GENERATOR_A :: TCB0_CAPT) , 162 => Some (GENERATOR_A :: TCB1_CAPT) , 164 => Some (GENERATOR_A :: TCB2_CAPT) , 166 => Some (GENERATOR_A :: TCB3_CAPT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == GENERATOR_A :: OFF } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == GENERATOR_A :: UPDI } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == GENERATOR_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == GENERATOR_A :: RTC_CMP } # [doc = "Checks if the value of the field is `RTC_PIT0`"]
# [inline (always)]
pub fn is_rtc_pit0 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT0 } # [doc = "Checks if the value of the field is `RTC_PIT1`"]
# [inline (always)]
pub fn is_rtc_pit1 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT1 } # [doc = "Checks if the value of the field is `RTC_PIT2`"]
# [inline (always)]
pub fn is_rtc_pit2 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT2 } # [doc = "Checks if the value of the field is `RTC_PIT3`"]
# [inline (always)]
pub fn is_rtc_pit3 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT3 } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `CCL_LUT2`"]
# [inline (always)]
pub fn is_ccl_lut2 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT2 } # [doc = "Checks if the value of the field is `CCL_LUT3`"]
# [inline (always)]
pub fn is_ccl_lut3 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT3 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == GENERATOR_A :: AC0_OUT } # [doc = "Checks if the value of the field is `ADC0_RESRDY`"]
# [inline (always)]
pub fn is_adc0_resrdy (& self) -> bool { * self == GENERATOR_A :: ADC0_RESRDY } # [doc = "Checks if the value of the field is `PORT0_PIN0`"]
# [inline (always)]
pub fn is_port0_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN0 } # [doc = "Checks if the value of the field is `PORT0_PIN1`"]
# [inline (always)]
pub fn is_port0_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN1 } # [doc = "Checks if the value of the field is `PORT0_PIN2`"]
# [inline (always)]
pub fn is_port0_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN2 } # [doc = "Checks if the value of the field is `PORT0_PIN3`"]
# [inline (always)]
pub fn is_port0_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN3 } # [doc = "Checks if the value of the field is `PORT0_PIN4`"]
# [inline (always)]
pub fn is_port0_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN4 } # [doc = "Checks if the value of the field is `PORT0_PIN5`"]
# [inline (always)]
pub fn is_port0_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN5 } # [doc = "Checks if the value of the field is `PORT0_PIN6`"]
# [inline (always)]
pub fn is_port0_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN6 } # [doc = "Checks if the value of the field is `PORT0_PIN7`"]
# [inline (always)]
pub fn is_port0_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN7 } # [doc = "Checks if the value of the field is `PORT1_PIN0`"]
# [inline (always)]
pub fn is_port1_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN0 } # [doc = "Checks if the value of the field is `PORT1_PIN1`"]
# [inline (always)]
pub fn is_port1_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN1 } # [doc = "Checks if the value of the field is `PORT1_PIN2`"]
# [inline (always)]
pub fn is_port1_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN2 } # [doc = "Checks if the value of the field is `PORT1_PIN3`"]
# [inline (always)]
pub fn is_port1_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN3 } # [doc = "Checks if the value of the field is `PORT1_PIN4`"]
# [inline (always)]
pub fn is_port1_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN4 } # [doc = "Checks if the value of the field is `PORT1_PIN5`"]
# [inline (always)]
pub fn is_port1_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN5 } # [doc = "Checks if the value of the field is `PORT1_PIN6`"]
# [inline (always)]
pub fn is_port1_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN6 } # [doc = "Checks if the value of the field is `PORT1_PIN7`"]
# [inline (always)]
pub fn is_port1_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN7 } # [doc = "Checks if the value of the field is `USART0_XCK`"]
# [inline (always)]
pub fn is_usart0_xck (& self) -> bool { * self == GENERATOR_A :: USART0_XCK } # [doc = "Checks if the value of the field is `USART1_XCK`"]
# [inline (always)]
pub fn is_usart1_xck (& self) -> bool { * self == GENERATOR_A :: USART1_XCK } # [doc = "Checks if the value of the field is `USART2_XCK`"]
# [inline (always)]
pub fn is_usart2_xck (& self) -> bool { * self == GENERATOR_A :: USART2_XCK } # [doc = "Checks if the value of the field is `USART3_XCK`"]
# [inline (always)]
pub fn is_usart3_xck (& self) -> bool { * self == GENERATOR_A :: USART3_XCK } # [doc = "Checks if the value of the field is `SPI0_SCK`"]
# [inline (always)]
pub fn is_spi0_sck (& self) -> bool { * self == GENERATOR_A :: SPI0_SCK } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == GENERATOR_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == GENERATOR_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `TCB0_CAPT`"]
# [inline (always)]
pub fn is_tcb0_capt (& self) -> bool { * self == GENERATOR_A :: TCB0_CAPT } # [doc = "Checks if the value of the field is `TCB1_CAPT`"]
# [inline (always)]
pub fn is_tcb1_capt (& self) -> bool { * self == GENERATOR_A :: TCB1_CAPT } # [doc = "Checks if the value of the field is `TCB2_CAPT`"]
# [inline (always)]
pub fn is_tcb2_capt (& self) -> bool { * self == GENERATOR_A :: TCB2_CAPT } # [doc = "Checks if the value of the field is `TCB3_CAPT`"]
# [inline (always)]
pub fn is_tcb3_capt (& self) -> bool { * self == GENERATOR_A :: TCB3_CAPT } } # [doc = "Field `GENERATOR` writer - Generator selector"]
pub type GENERATOR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CHANNEL1_SPEC , u8 , GENERATOR_A , 8 , O > ; impl < 'a , const O : u8 > GENERATOR_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (GENERATOR_A :: OFF) } # [doc = "Unified Program and Debug Interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (GENERATOR_A :: UPDI) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_CMP) } # [doc = "Periodic Interrupt Timer output 0"]
# [inline (always)]
pub fn rtc_pit0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT0) } # [doc = "Periodic Interrupt Timer output 1"]
# [inline (always)]
pub fn rtc_pit1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT1) } # [doc = "Periodic Interrupt Timer output 2"]
# [inline (always)]
pub fn rtc_pit2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT2) } # [doc = "Periodic Interrupt Timer output 3"]
# [inline (always)]
pub fn rtc_pit3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT3) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT1) } # [doc = "Configurable Custom Logic LUT2"]
# [inline (always)]
pub fn ccl_lut2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT2) } # [doc = "Configurable Custom Logic LUT3"]
# [inline (always)]
pub fn ccl_lut3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT3) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (GENERATOR_A :: AC0_OUT) } # [doc = "ADC 0 Result Ready Event"]
# [inline (always)]
pub fn adc0_resrdy (self) -> & 'a mut W { self . variant (GENERATOR_A :: ADC0_RESRDY) } # [doc = "Port 0 Pin 0"]
# [inline (always)]
pub fn port0_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN0) } # [doc = "Port 0 Pin 1"]
# [inline (always)]
pub fn port0_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN1) } # [doc = "Port 0 Pin 2"]
# [inline (always)]
pub fn port0_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN2) } # [doc = "Port 0 Pin 3"]
# [inline (always)]
pub fn port0_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN3) } # [doc = "Port 0 Pin 4"]
# [inline (always)]
pub fn port0_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN4) } # [doc = "Port 0 Pin 5"]
# [inline (always)]
pub fn port0_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN5) } # [doc = "Port 0 Pin 6"]
# [inline (always)]
pub fn port0_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN6) } # [doc = "Port 0 Pin 7"]
# [inline (always)]
pub fn port0_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN7) } # [doc = "Port 1 Pin 0"]
# [inline (always)]
pub fn port1_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN0) } # [doc = "Port 1 Pin 1"]
# [inline (always)]
pub fn port1_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN1) } # [doc = "Port 1 Pin 2"]
# [inline (always)]
pub fn port1_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN2) } # [doc = "Port 1 Pin 3"]
# [inline (always)]
pub fn port1_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN3) } # [doc = "Port 1 Pin 4"]
# [inline (always)]
pub fn port1_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN4) } # [doc = "Port 1 Pin 5"]
# [inline (always)]
pub fn port1_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN5) } # [doc = "Port 1 Pin 6"]
# [inline (always)]
pub fn port1_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN6) } # [doc = "Port 1 Pin 7"]
# [inline (always)]
pub fn port1_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN7) } # [doc = "USART 0 Xclock"]
# [inline (always)]
pub fn usart0_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART0_XCK) } # [doc = "USART 1 Xclock"]
# [inline (always)]
pub fn usart1_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART1_XCK) } # [doc = "USART 2 Xclock"]
# [inline (always)]
pub fn usart2_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART2_XCK) } # [doc = "USART 3 Xclock"]
# [inline (always)]
pub fn usart3_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART3_XCK) } # [doc = "SPI 0 Sclock"]
# [inline (always)]
pub fn spi0_sck (self) -> & 'a mut W { self . variant (GENERATOR_A :: SPI0_SCK) } # [doc = "Timer/Counter A0 overflow / low byte underflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 high byte underflow (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP2) } # [doc = "Timer/Counter B0 capture"]
# [inline (always)]
pub fn tcb0_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB0_CAPT) } # [doc = "Timer/Counter B1 capture"]
# [inline (always)]
pub fn tcb1_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB1_CAPT) } # [doc = "Timer/Counter B2 capture"]
# [inline (always)]
pub fn tcb2_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB2_CAPT) } # [doc = "Timer/Counter B3 capture"]
# [inline (always)]
pub fn tcb3_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB3_CAPT) } } impl R { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
pub fn generator (& self) -> GENERATOR_R { GENERATOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
# [must_use]
pub fn generator (& mut self) -> GENERATOR_W < 0 > { GENERATOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiplexer Channel 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel1](index.html) module"]
pub struct CHANNEL1_SPEC ; impl crate :: RegisterSpec for CHANNEL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [channel1::R](R) reader structure"]
impl crate :: Readable for CHANNEL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel1::W](W) writer structure"]
impl crate :: Writable for CHANNEL1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHANNEL1 to value 0"]
impl crate :: Resettable for CHANNEL1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHANNEL2 (rw) register accessor: an alias for `Reg<CHANNEL2_SPEC>`"]
pub type CHANNEL2 = crate :: Reg < channel2 :: CHANNEL2_SPEC > ; # [doc = "Multiplexer Channel 2"]
pub mod channel2 { # [doc = "Register `CHANNEL2` reader"]
pub struct R (crate :: R < CHANNEL2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL2_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL2` writer"]
pub struct W (crate :: W < CHANNEL2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL2_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENERATOR` reader - Generator selector"]
pub type GENERATOR_R = crate :: FieldReader < u8 , GENERATOR_A > ; # [doc = "Generator selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum GENERATOR_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Unified Program and Debug Interface"]
UPDI = 1 , # [doc = "6: Real Time Counter overflow"]
RTC_OVF = 6 , # [doc = "7: Real Time Counter compare"]
RTC_CMP = 7 , # [doc = "8: Periodic Interrupt Timer output 0"]
RTC_PIT0 = 8 , # [doc = "9: Periodic Interrupt Timer output 1"]
RTC_PIT1 = 9 , # [doc = "10: Periodic Interrupt Timer output 2"]
RTC_PIT2 = 10 , # [doc = "11: Periodic Interrupt Timer output 3"]
RTC_PIT3 = 11 , # [doc = "16: Configurable Custom Logic LUT0"]
CCL_LUT0 = 16 , # [doc = "17: Configurable Custom Logic LUT1"]
CCL_LUT1 = 17 , # [doc = "18: Configurable Custom Logic LUT2"]
CCL_LUT2 = 18 , # [doc = "19: Configurable Custom Logic LUT3"]
CCL_LUT3 = 19 , # [doc = "32: Analog Comparator 0 out"]
AC0_OUT = 32 , # [doc = "36: ADC 0 Result Ready Event"]
ADC0_RESRDY = 36 , # [doc = "64: Port 0 Pin 0"]
PORT0_PIN0 = 64 , # [doc = "65: Port 0 Pin 1"]
PORT0_PIN1 = 65 , # [doc = "66: Port 0 Pin 2"]
PORT0_PIN2 = 66 , # [doc = "67: Port 0 Pin 3"]
PORT0_PIN3 = 67 , # [doc = "68: Port 0 Pin 4"]
PORT0_PIN4 = 68 , # [doc = "69: Port 0 Pin 5"]
PORT0_PIN5 = 69 , # [doc = "70: Port 0 Pin 6"]
PORT0_PIN6 = 70 , # [doc = "71: Port 0 Pin 7"]
PORT0_PIN7 = 71 , # [doc = "72: Port 1 Pin 0"]
PORT1_PIN0 = 72 , # [doc = "73: Port 1 Pin 1"]
PORT1_PIN1 = 73 , # [doc = "74: Port 1 Pin 2"]
PORT1_PIN2 = 74 , # [doc = "75: Port 1 Pin 3"]
PORT1_PIN3 = 75 , # [doc = "76: Port 1 Pin 4"]
PORT1_PIN4 = 76 , # [doc = "77: Port 1 Pin 5"]
PORT1_PIN5 = 77 , # [doc = "78: Port 1 Pin 6"]
PORT1_PIN6 = 78 , # [doc = "79: Port 1 Pin 7"]
PORT1_PIN7 = 79 , # [doc = "96: USART 0 Xclock"]
USART0_XCK = 96 , # [doc = "97: USART 1 Xclock"]
USART1_XCK = 97 , # [doc = "98: USART 2 Xclock"]
USART2_XCK = 98 , # [doc = "99: USART 3 Xclock"]
USART3_XCK = 99 , # [doc = "104: SPI 0 Sclock"]
SPI0_SCK = 104 , # [doc = "128: Timer/Counter A0 overflow / low byte underflow"]
TCA0_OVF_LUNF = 128 , # [doc = "129: Timer/Counter A0 high byte underflow (split mode)"]
TCA0_HUNF = 129 , # [doc = "132: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 132 , # [doc = "133: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 133 , # [doc = "134: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 134 , # [doc = "160: Timer/Counter B0 capture"]
TCB0_CAPT = 160 , # [doc = "162: Timer/Counter B1 capture"]
TCB1_CAPT = 162 , # [doc = "164: Timer/Counter B2 capture"]
TCB2_CAPT = 164 , # [doc = "166: Timer/Counter B3 capture"]
TCB3_CAPT = 166 , } impl From < GENERATOR_A > for u8 { # [inline (always)]
fn from (variant : GENERATOR_A) -> Self { variant as _ } } impl GENERATOR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GENERATOR_A > { match self . bits { 0 => Some (GENERATOR_A :: OFF) , 1 => Some (GENERATOR_A :: UPDI) , 6 => Some (GENERATOR_A :: RTC_OVF) , 7 => Some (GENERATOR_A :: RTC_CMP) , 8 => Some (GENERATOR_A :: RTC_PIT0) , 9 => Some (GENERATOR_A :: RTC_PIT1) , 10 => Some (GENERATOR_A :: RTC_PIT2) , 11 => Some (GENERATOR_A :: RTC_PIT3) , 16 => Some (GENERATOR_A :: CCL_LUT0) , 17 => Some (GENERATOR_A :: CCL_LUT1) , 18 => Some (GENERATOR_A :: CCL_LUT2) , 19 => Some (GENERATOR_A :: CCL_LUT3) , 32 => Some (GENERATOR_A :: AC0_OUT) , 36 => Some (GENERATOR_A :: ADC0_RESRDY) , 64 => Some (GENERATOR_A :: PORT0_PIN0) , 65 => Some (GENERATOR_A :: PORT0_PIN1) , 66 => Some (GENERATOR_A :: PORT0_PIN2) , 67 => Some (GENERATOR_A :: PORT0_PIN3) , 68 => Some (GENERATOR_A :: PORT0_PIN4) , 69 => Some (GENERATOR_A :: PORT0_PIN5) , 70 => Some (GENERATOR_A :: PORT0_PIN6) , 71 => Some (GENERATOR_A :: PORT0_PIN7) , 72 => Some (GENERATOR_A :: PORT1_PIN0) , 73 => Some (GENERATOR_A :: PORT1_PIN1) , 74 => Some (GENERATOR_A :: PORT1_PIN2) , 75 => Some (GENERATOR_A :: PORT1_PIN3) , 76 => Some (GENERATOR_A :: PORT1_PIN4) , 77 => Some (GENERATOR_A :: PORT1_PIN5) , 78 => Some (GENERATOR_A :: PORT1_PIN6) , 79 => Some (GENERATOR_A :: PORT1_PIN7) , 96 => Some (GENERATOR_A :: USART0_XCK) , 97 => Some (GENERATOR_A :: USART1_XCK) , 98 => Some (GENERATOR_A :: USART2_XCK) , 99 => Some (GENERATOR_A :: USART3_XCK) , 104 => Some (GENERATOR_A :: SPI0_SCK) , 128 => Some (GENERATOR_A :: TCA0_OVF_LUNF) , 129 => Some (GENERATOR_A :: TCA0_HUNF) , 132 => Some (GENERATOR_A :: TCA0_CMP0) , 133 => Some (GENERATOR_A :: TCA0_CMP1) , 134 => Some (GENERATOR_A :: TCA0_CMP2) , 160 => Some (GENERATOR_A :: TCB0_CAPT) , 162 => Some (GENERATOR_A :: TCB1_CAPT) , 164 => Some (GENERATOR_A :: TCB2_CAPT) , 166 => Some (GENERATOR_A :: TCB3_CAPT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == GENERATOR_A :: OFF } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == GENERATOR_A :: UPDI } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == GENERATOR_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == GENERATOR_A :: RTC_CMP } # [doc = "Checks if the value of the field is `RTC_PIT0`"]
# [inline (always)]
pub fn is_rtc_pit0 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT0 } # [doc = "Checks if the value of the field is `RTC_PIT1`"]
# [inline (always)]
pub fn is_rtc_pit1 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT1 } # [doc = "Checks if the value of the field is `RTC_PIT2`"]
# [inline (always)]
pub fn is_rtc_pit2 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT2 } # [doc = "Checks if the value of the field is `RTC_PIT3`"]
# [inline (always)]
pub fn is_rtc_pit3 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT3 } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `CCL_LUT2`"]
# [inline (always)]
pub fn is_ccl_lut2 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT2 } # [doc = "Checks if the value of the field is `CCL_LUT3`"]
# [inline (always)]
pub fn is_ccl_lut3 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT3 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == GENERATOR_A :: AC0_OUT } # [doc = "Checks if the value of the field is `ADC0_RESRDY`"]
# [inline (always)]
pub fn is_adc0_resrdy (& self) -> bool { * self == GENERATOR_A :: ADC0_RESRDY } # [doc = "Checks if the value of the field is `PORT0_PIN0`"]
# [inline (always)]
pub fn is_port0_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN0 } # [doc = "Checks if the value of the field is `PORT0_PIN1`"]
# [inline (always)]
pub fn is_port0_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN1 } # [doc = "Checks if the value of the field is `PORT0_PIN2`"]
# [inline (always)]
pub fn is_port0_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN2 } # [doc = "Checks if the value of the field is `PORT0_PIN3`"]
# [inline (always)]
pub fn is_port0_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN3 } # [doc = "Checks if the value of the field is `PORT0_PIN4`"]
# [inline (always)]
pub fn is_port0_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN4 } # [doc = "Checks if the value of the field is `PORT0_PIN5`"]
# [inline (always)]
pub fn is_port0_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN5 } # [doc = "Checks if the value of the field is `PORT0_PIN6`"]
# [inline (always)]
pub fn is_port0_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN6 } # [doc = "Checks if the value of the field is `PORT0_PIN7`"]
# [inline (always)]
pub fn is_port0_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN7 } # [doc = "Checks if the value of the field is `PORT1_PIN0`"]
# [inline (always)]
pub fn is_port1_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN0 } # [doc = "Checks if the value of the field is `PORT1_PIN1`"]
# [inline (always)]
pub fn is_port1_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN1 } # [doc = "Checks if the value of the field is `PORT1_PIN2`"]
# [inline (always)]
pub fn is_port1_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN2 } # [doc = "Checks if the value of the field is `PORT1_PIN3`"]
# [inline (always)]
pub fn is_port1_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN3 } # [doc = "Checks if the value of the field is `PORT1_PIN4`"]
# [inline (always)]
pub fn is_port1_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN4 } # [doc = "Checks if the value of the field is `PORT1_PIN5`"]
# [inline (always)]
pub fn is_port1_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN5 } # [doc = "Checks if the value of the field is `PORT1_PIN6`"]
# [inline (always)]
pub fn is_port1_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN6 } # [doc = "Checks if the value of the field is `PORT1_PIN7`"]
# [inline (always)]
pub fn is_port1_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN7 } # [doc = "Checks if the value of the field is `USART0_XCK`"]
# [inline (always)]
pub fn is_usart0_xck (& self) -> bool { * self == GENERATOR_A :: USART0_XCK } # [doc = "Checks if the value of the field is `USART1_XCK`"]
# [inline (always)]
pub fn is_usart1_xck (& self) -> bool { * self == GENERATOR_A :: USART1_XCK } # [doc = "Checks if the value of the field is `USART2_XCK`"]
# [inline (always)]
pub fn is_usart2_xck (& self) -> bool { * self == GENERATOR_A :: USART2_XCK } # [doc = "Checks if the value of the field is `USART3_XCK`"]
# [inline (always)]
pub fn is_usart3_xck (& self) -> bool { * self == GENERATOR_A :: USART3_XCK } # [doc = "Checks if the value of the field is `SPI0_SCK`"]
# [inline (always)]
pub fn is_spi0_sck (& self) -> bool { * self == GENERATOR_A :: SPI0_SCK } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == GENERATOR_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == GENERATOR_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `TCB0_CAPT`"]
# [inline (always)]
pub fn is_tcb0_capt (& self) -> bool { * self == GENERATOR_A :: TCB0_CAPT } # [doc = "Checks if the value of the field is `TCB1_CAPT`"]
# [inline (always)]
pub fn is_tcb1_capt (& self) -> bool { * self == GENERATOR_A :: TCB1_CAPT } # [doc = "Checks if the value of the field is `TCB2_CAPT`"]
# [inline (always)]
pub fn is_tcb2_capt (& self) -> bool { * self == GENERATOR_A :: TCB2_CAPT } # [doc = "Checks if the value of the field is `TCB3_CAPT`"]
# [inline (always)]
pub fn is_tcb3_capt (& self) -> bool { * self == GENERATOR_A :: TCB3_CAPT } } # [doc = "Field `GENERATOR` writer - Generator selector"]
pub type GENERATOR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CHANNEL2_SPEC , u8 , GENERATOR_A , 8 , O > ; impl < 'a , const O : u8 > GENERATOR_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (GENERATOR_A :: OFF) } # [doc = "Unified Program and Debug Interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (GENERATOR_A :: UPDI) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_CMP) } # [doc = "Periodic Interrupt Timer output 0"]
# [inline (always)]
pub fn rtc_pit0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT0) } # [doc = "Periodic Interrupt Timer output 1"]
# [inline (always)]
pub fn rtc_pit1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT1) } # [doc = "Periodic Interrupt Timer output 2"]
# [inline (always)]
pub fn rtc_pit2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT2) } # [doc = "Periodic Interrupt Timer output 3"]
# [inline (always)]
pub fn rtc_pit3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT3) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT1) } # [doc = "Configurable Custom Logic LUT2"]
# [inline (always)]
pub fn ccl_lut2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT2) } # [doc = "Configurable Custom Logic LUT3"]
# [inline (always)]
pub fn ccl_lut3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT3) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (GENERATOR_A :: AC0_OUT) } # [doc = "ADC 0 Result Ready Event"]
# [inline (always)]
pub fn adc0_resrdy (self) -> & 'a mut W { self . variant (GENERATOR_A :: ADC0_RESRDY) } # [doc = "Port 0 Pin 0"]
# [inline (always)]
pub fn port0_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN0) } # [doc = "Port 0 Pin 1"]
# [inline (always)]
pub fn port0_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN1) } # [doc = "Port 0 Pin 2"]
# [inline (always)]
pub fn port0_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN2) } # [doc = "Port 0 Pin 3"]
# [inline (always)]
pub fn port0_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN3) } # [doc = "Port 0 Pin 4"]
# [inline (always)]
pub fn port0_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN4) } # [doc = "Port 0 Pin 5"]
# [inline (always)]
pub fn port0_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN5) } # [doc = "Port 0 Pin 6"]
# [inline (always)]
pub fn port0_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN6) } # [doc = "Port 0 Pin 7"]
# [inline (always)]
pub fn port0_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN7) } # [doc = "Port 1 Pin 0"]
# [inline (always)]
pub fn port1_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN0) } # [doc = "Port 1 Pin 1"]
# [inline (always)]
pub fn port1_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN1) } # [doc = "Port 1 Pin 2"]
# [inline (always)]
pub fn port1_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN2) } # [doc = "Port 1 Pin 3"]
# [inline (always)]
pub fn port1_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN3) } # [doc = "Port 1 Pin 4"]
# [inline (always)]
pub fn port1_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN4) } # [doc = "Port 1 Pin 5"]
# [inline (always)]
pub fn port1_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN5) } # [doc = "Port 1 Pin 6"]
# [inline (always)]
pub fn port1_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN6) } # [doc = "Port 1 Pin 7"]
# [inline (always)]
pub fn port1_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN7) } # [doc = "USART 0 Xclock"]
# [inline (always)]
pub fn usart0_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART0_XCK) } # [doc = "USART 1 Xclock"]
# [inline (always)]
pub fn usart1_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART1_XCK) } # [doc = "USART 2 Xclock"]
# [inline (always)]
pub fn usart2_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART2_XCK) } # [doc = "USART 3 Xclock"]
# [inline (always)]
pub fn usart3_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART3_XCK) } # [doc = "SPI 0 Sclock"]
# [inline (always)]
pub fn spi0_sck (self) -> & 'a mut W { self . variant (GENERATOR_A :: SPI0_SCK) } # [doc = "Timer/Counter A0 overflow / low byte underflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 high byte underflow (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP2) } # [doc = "Timer/Counter B0 capture"]
# [inline (always)]
pub fn tcb0_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB0_CAPT) } # [doc = "Timer/Counter B1 capture"]
# [inline (always)]
pub fn tcb1_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB1_CAPT) } # [doc = "Timer/Counter B2 capture"]
# [inline (always)]
pub fn tcb2_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB2_CAPT) } # [doc = "Timer/Counter B3 capture"]
# [inline (always)]
pub fn tcb3_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB3_CAPT) } } impl R { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
pub fn generator (& self) -> GENERATOR_R { GENERATOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
# [must_use]
pub fn generator (& mut self) -> GENERATOR_W < 0 > { GENERATOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiplexer Channel 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel2](index.html) module"]
pub struct CHANNEL2_SPEC ; impl crate :: RegisterSpec for CHANNEL2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [channel2::R](R) reader structure"]
impl crate :: Readable for CHANNEL2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel2::W](W) writer structure"]
impl crate :: Writable for CHANNEL2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHANNEL2 to value 0"]
impl crate :: Resettable for CHANNEL2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHANNEL3 (rw) register accessor: an alias for `Reg<CHANNEL3_SPEC>`"]
pub type CHANNEL3 = crate :: Reg < channel3 :: CHANNEL3_SPEC > ; # [doc = "Multiplexer Channel 3"]
pub mod channel3 { # [doc = "Register `CHANNEL3` reader"]
pub struct R (crate :: R < CHANNEL3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL3_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL3` writer"]
pub struct W (crate :: W < CHANNEL3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL3_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENERATOR` reader - Generator selector"]
pub type GENERATOR_R = crate :: FieldReader < u8 , GENERATOR_A > ; # [doc = "Generator selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum GENERATOR_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Unified Program and Debug Interface"]
UPDI = 1 , # [doc = "6: Real Time Counter overflow"]
RTC_OVF = 6 , # [doc = "7: Real Time Counter compare"]
RTC_CMP = 7 , # [doc = "8: Periodic Interrupt Timer output 0"]
RTC_PIT0 = 8 , # [doc = "9: Periodic Interrupt Timer output 1"]
RTC_PIT1 = 9 , # [doc = "10: Periodic Interrupt Timer output 2"]
RTC_PIT2 = 10 , # [doc = "11: Periodic Interrupt Timer output 3"]
RTC_PIT3 = 11 , # [doc = "16: Configurable Custom Logic LUT0"]
CCL_LUT0 = 16 , # [doc = "17: Configurable Custom Logic LUT1"]
CCL_LUT1 = 17 , # [doc = "18: Configurable Custom Logic LUT2"]
CCL_LUT2 = 18 , # [doc = "19: Configurable Custom Logic LUT3"]
CCL_LUT3 = 19 , # [doc = "32: Analog Comparator 0 out"]
AC0_OUT = 32 , # [doc = "36: ADC 0 Result Ready Event"]
ADC0_RESRDY = 36 , # [doc = "64: Port 0 Pin 0"]
PORT0_PIN0 = 64 , # [doc = "65: Port 0 Pin 1"]
PORT0_PIN1 = 65 , # [doc = "66: Port 0 Pin 2"]
PORT0_PIN2 = 66 , # [doc = "67: Port 0 Pin 3"]
PORT0_PIN3 = 67 , # [doc = "68: Port 0 Pin 4"]
PORT0_PIN4 = 68 , # [doc = "69: Port 0 Pin 5"]
PORT0_PIN5 = 69 , # [doc = "70: Port 0 Pin 6"]
PORT0_PIN6 = 70 , # [doc = "71: Port 0 Pin 7"]
PORT0_PIN7 = 71 , # [doc = "72: Port 1 Pin 0"]
PORT1_PIN0 = 72 , # [doc = "73: Port 1 Pin 1"]
PORT1_PIN1 = 73 , # [doc = "74: Port 1 Pin 2"]
PORT1_PIN2 = 74 , # [doc = "75: Port 1 Pin 3"]
PORT1_PIN3 = 75 , # [doc = "76: Port 1 Pin 4"]
PORT1_PIN4 = 76 , # [doc = "77: Port 1 Pin 5"]
PORT1_PIN5 = 77 , # [doc = "78: Port 1 Pin 6"]
PORT1_PIN6 = 78 , # [doc = "79: Port 1 Pin 7"]
PORT1_PIN7 = 79 , # [doc = "96: USART 0 Xclock"]
USART0_XCK = 96 , # [doc = "97: USART 1 Xclock"]
USART1_XCK = 97 , # [doc = "98: USART 2 Xclock"]
USART2_XCK = 98 , # [doc = "99: USART 3 Xclock"]
USART3_XCK = 99 , # [doc = "104: SPI 0 Sclock"]
SPI0_SCK = 104 , # [doc = "128: Timer/Counter A0 overflow / low byte underflow"]
TCA0_OVF_LUNF = 128 , # [doc = "129: Timer/Counter A0 high byte underflow (split mode)"]
TCA0_HUNF = 129 , # [doc = "132: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 132 , # [doc = "133: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 133 , # [doc = "134: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 134 , # [doc = "160: Timer/Counter B0 capture"]
TCB0_CAPT = 160 , # [doc = "162: Timer/Counter B1 capture"]
TCB1_CAPT = 162 , # [doc = "164: Timer/Counter B2 capture"]
TCB2_CAPT = 164 , # [doc = "166: Timer/Counter B3 capture"]
TCB3_CAPT = 166 , } impl From < GENERATOR_A > for u8 { # [inline (always)]
fn from (variant : GENERATOR_A) -> Self { variant as _ } } impl GENERATOR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GENERATOR_A > { match self . bits { 0 => Some (GENERATOR_A :: OFF) , 1 => Some (GENERATOR_A :: UPDI) , 6 => Some (GENERATOR_A :: RTC_OVF) , 7 => Some (GENERATOR_A :: RTC_CMP) , 8 => Some (GENERATOR_A :: RTC_PIT0) , 9 => Some (GENERATOR_A :: RTC_PIT1) , 10 => Some (GENERATOR_A :: RTC_PIT2) , 11 => Some (GENERATOR_A :: RTC_PIT3) , 16 => Some (GENERATOR_A :: CCL_LUT0) , 17 => Some (GENERATOR_A :: CCL_LUT1) , 18 => Some (GENERATOR_A :: CCL_LUT2) , 19 => Some (GENERATOR_A :: CCL_LUT3) , 32 => Some (GENERATOR_A :: AC0_OUT) , 36 => Some (GENERATOR_A :: ADC0_RESRDY) , 64 => Some (GENERATOR_A :: PORT0_PIN0) , 65 => Some (GENERATOR_A :: PORT0_PIN1) , 66 => Some (GENERATOR_A :: PORT0_PIN2) , 67 => Some (GENERATOR_A :: PORT0_PIN3) , 68 => Some (GENERATOR_A :: PORT0_PIN4) , 69 => Some (GENERATOR_A :: PORT0_PIN5) , 70 => Some (GENERATOR_A :: PORT0_PIN6) , 71 => Some (GENERATOR_A :: PORT0_PIN7) , 72 => Some (GENERATOR_A :: PORT1_PIN0) , 73 => Some (GENERATOR_A :: PORT1_PIN1) , 74 => Some (GENERATOR_A :: PORT1_PIN2) , 75 => Some (GENERATOR_A :: PORT1_PIN3) , 76 => Some (GENERATOR_A :: PORT1_PIN4) , 77 => Some (GENERATOR_A :: PORT1_PIN5) , 78 => Some (GENERATOR_A :: PORT1_PIN6) , 79 => Some (GENERATOR_A :: PORT1_PIN7) , 96 => Some (GENERATOR_A :: USART0_XCK) , 97 => Some (GENERATOR_A :: USART1_XCK) , 98 => Some (GENERATOR_A :: USART2_XCK) , 99 => Some (GENERATOR_A :: USART3_XCK) , 104 => Some (GENERATOR_A :: SPI0_SCK) , 128 => Some (GENERATOR_A :: TCA0_OVF_LUNF) , 129 => Some (GENERATOR_A :: TCA0_HUNF) , 132 => Some (GENERATOR_A :: TCA0_CMP0) , 133 => Some (GENERATOR_A :: TCA0_CMP1) , 134 => Some (GENERATOR_A :: TCA0_CMP2) , 160 => Some (GENERATOR_A :: TCB0_CAPT) , 162 => Some (GENERATOR_A :: TCB1_CAPT) , 164 => Some (GENERATOR_A :: TCB2_CAPT) , 166 => Some (GENERATOR_A :: TCB3_CAPT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == GENERATOR_A :: OFF } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == GENERATOR_A :: UPDI } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == GENERATOR_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == GENERATOR_A :: RTC_CMP } # [doc = "Checks if the value of the field is `RTC_PIT0`"]
# [inline (always)]
pub fn is_rtc_pit0 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT0 } # [doc = "Checks if the value of the field is `RTC_PIT1`"]
# [inline (always)]
pub fn is_rtc_pit1 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT1 } # [doc = "Checks if the value of the field is `RTC_PIT2`"]
# [inline (always)]
pub fn is_rtc_pit2 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT2 } # [doc = "Checks if the value of the field is `RTC_PIT3`"]
# [inline (always)]
pub fn is_rtc_pit3 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT3 } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `CCL_LUT2`"]
# [inline (always)]
pub fn is_ccl_lut2 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT2 } # [doc = "Checks if the value of the field is `CCL_LUT3`"]
# [inline (always)]
pub fn is_ccl_lut3 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT3 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == GENERATOR_A :: AC0_OUT } # [doc = "Checks if the value of the field is `ADC0_RESRDY`"]
# [inline (always)]
pub fn is_adc0_resrdy (& self) -> bool { * self == GENERATOR_A :: ADC0_RESRDY } # [doc = "Checks if the value of the field is `PORT0_PIN0`"]
# [inline (always)]
pub fn is_port0_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN0 } # [doc = "Checks if the value of the field is `PORT0_PIN1`"]
# [inline (always)]
pub fn is_port0_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN1 } # [doc = "Checks if the value of the field is `PORT0_PIN2`"]
# [inline (always)]
pub fn is_port0_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN2 } # [doc = "Checks if the value of the field is `PORT0_PIN3`"]
# [inline (always)]
pub fn is_port0_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN3 } # [doc = "Checks if the value of the field is `PORT0_PIN4`"]
# [inline (always)]
pub fn is_port0_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN4 } # [doc = "Checks if the value of the field is `PORT0_PIN5`"]
# [inline (always)]
pub fn is_port0_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN5 } # [doc = "Checks if the value of the field is `PORT0_PIN6`"]
# [inline (always)]
pub fn is_port0_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN6 } # [doc = "Checks if the value of the field is `PORT0_PIN7`"]
# [inline (always)]
pub fn is_port0_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN7 } # [doc = "Checks if the value of the field is `PORT1_PIN0`"]
# [inline (always)]
pub fn is_port1_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN0 } # [doc = "Checks if the value of the field is `PORT1_PIN1`"]
# [inline (always)]
pub fn is_port1_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN1 } # [doc = "Checks if the value of the field is `PORT1_PIN2`"]
# [inline (always)]
pub fn is_port1_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN2 } # [doc = "Checks if the value of the field is `PORT1_PIN3`"]
# [inline (always)]
pub fn is_port1_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN3 } # [doc = "Checks if the value of the field is `PORT1_PIN4`"]
# [inline (always)]
pub fn is_port1_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN4 } # [doc = "Checks if the value of the field is `PORT1_PIN5`"]
# [inline (always)]
pub fn is_port1_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN5 } # [doc = "Checks if the value of the field is `PORT1_PIN6`"]
# [inline (always)]
pub fn is_port1_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN6 } # [doc = "Checks if the value of the field is `PORT1_PIN7`"]
# [inline (always)]
pub fn is_port1_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN7 } # [doc = "Checks if the value of the field is `USART0_XCK`"]
# [inline (always)]
pub fn is_usart0_xck (& self) -> bool { * self == GENERATOR_A :: USART0_XCK } # [doc = "Checks if the value of the field is `USART1_XCK`"]
# [inline (always)]
pub fn is_usart1_xck (& self) -> bool { * self == GENERATOR_A :: USART1_XCK } # [doc = "Checks if the value of the field is `USART2_XCK`"]
# [inline (always)]
pub fn is_usart2_xck (& self) -> bool { * self == GENERATOR_A :: USART2_XCK } # [doc = "Checks if the value of the field is `USART3_XCK`"]
# [inline (always)]
pub fn is_usart3_xck (& self) -> bool { * self == GENERATOR_A :: USART3_XCK } # [doc = "Checks if the value of the field is `SPI0_SCK`"]
# [inline (always)]
pub fn is_spi0_sck (& self) -> bool { * self == GENERATOR_A :: SPI0_SCK } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == GENERATOR_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == GENERATOR_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `TCB0_CAPT`"]
# [inline (always)]
pub fn is_tcb0_capt (& self) -> bool { * self == GENERATOR_A :: TCB0_CAPT } # [doc = "Checks if the value of the field is `TCB1_CAPT`"]
# [inline (always)]
pub fn is_tcb1_capt (& self) -> bool { * self == GENERATOR_A :: TCB1_CAPT } # [doc = "Checks if the value of the field is `TCB2_CAPT`"]
# [inline (always)]
pub fn is_tcb2_capt (& self) -> bool { * self == GENERATOR_A :: TCB2_CAPT } # [doc = "Checks if the value of the field is `TCB3_CAPT`"]
# [inline (always)]
pub fn is_tcb3_capt (& self) -> bool { * self == GENERATOR_A :: TCB3_CAPT } } # [doc = "Field `GENERATOR` writer - Generator selector"]
pub type GENERATOR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CHANNEL3_SPEC , u8 , GENERATOR_A , 8 , O > ; impl < 'a , const O : u8 > GENERATOR_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (GENERATOR_A :: OFF) } # [doc = "Unified Program and Debug Interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (GENERATOR_A :: UPDI) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_CMP) } # [doc = "Periodic Interrupt Timer output 0"]
# [inline (always)]
pub fn rtc_pit0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT0) } # [doc = "Periodic Interrupt Timer output 1"]
# [inline (always)]
pub fn rtc_pit1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT1) } # [doc = "Periodic Interrupt Timer output 2"]
# [inline (always)]
pub fn rtc_pit2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT2) } # [doc = "Periodic Interrupt Timer output 3"]
# [inline (always)]
pub fn rtc_pit3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT3) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT1) } # [doc = "Configurable Custom Logic LUT2"]
# [inline (always)]
pub fn ccl_lut2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT2) } # [doc = "Configurable Custom Logic LUT3"]
# [inline (always)]
pub fn ccl_lut3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT3) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (GENERATOR_A :: AC0_OUT) } # [doc = "ADC 0 Result Ready Event"]
# [inline (always)]
pub fn adc0_resrdy (self) -> & 'a mut W { self . variant (GENERATOR_A :: ADC0_RESRDY) } # [doc = "Port 0 Pin 0"]
# [inline (always)]
pub fn port0_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN0) } # [doc = "Port 0 Pin 1"]
# [inline (always)]
pub fn port0_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN1) } # [doc = "Port 0 Pin 2"]
# [inline (always)]
pub fn port0_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN2) } # [doc = "Port 0 Pin 3"]
# [inline (always)]
pub fn port0_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN3) } # [doc = "Port 0 Pin 4"]
# [inline (always)]
pub fn port0_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN4) } # [doc = "Port 0 Pin 5"]
# [inline (always)]
pub fn port0_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN5) } # [doc = "Port 0 Pin 6"]
# [inline (always)]
pub fn port0_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN6) } # [doc = "Port 0 Pin 7"]
# [inline (always)]
pub fn port0_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN7) } # [doc = "Port 1 Pin 0"]
# [inline (always)]
pub fn port1_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN0) } # [doc = "Port 1 Pin 1"]
# [inline (always)]
pub fn port1_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN1) } # [doc = "Port 1 Pin 2"]
# [inline (always)]
pub fn port1_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN2) } # [doc = "Port 1 Pin 3"]
# [inline (always)]
pub fn port1_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN3) } # [doc = "Port 1 Pin 4"]
# [inline (always)]
pub fn port1_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN4) } # [doc = "Port 1 Pin 5"]
# [inline (always)]
pub fn port1_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN5) } # [doc = "Port 1 Pin 6"]
# [inline (always)]
pub fn port1_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN6) } # [doc = "Port 1 Pin 7"]
# [inline (always)]
pub fn port1_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN7) } # [doc = "USART 0 Xclock"]
# [inline (always)]
pub fn usart0_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART0_XCK) } # [doc = "USART 1 Xclock"]
# [inline (always)]
pub fn usart1_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART1_XCK) } # [doc = "USART 2 Xclock"]
# [inline (always)]
pub fn usart2_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART2_XCK) } # [doc = "USART 3 Xclock"]
# [inline (always)]
pub fn usart3_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART3_XCK) } # [doc = "SPI 0 Sclock"]
# [inline (always)]
pub fn spi0_sck (self) -> & 'a mut W { self . variant (GENERATOR_A :: SPI0_SCK) } # [doc = "Timer/Counter A0 overflow / low byte underflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 high byte underflow (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP2) } # [doc = "Timer/Counter B0 capture"]
# [inline (always)]
pub fn tcb0_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB0_CAPT) } # [doc = "Timer/Counter B1 capture"]
# [inline (always)]
pub fn tcb1_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB1_CAPT) } # [doc = "Timer/Counter B2 capture"]
# [inline (always)]
pub fn tcb2_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB2_CAPT) } # [doc = "Timer/Counter B3 capture"]
# [inline (always)]
pub fn tcb3_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB3_CAPT) } } impl R { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
pub fn generator (& self) -> GENERATOR_R { GENERATOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
# [must_use]
pub fn generator (& mut self) -> GENERATOR_W < 0 > { GENERATOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiplexer Channel 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel3](index.html) module"]
pub struct CHANNEL3_SPEC ; impl crate :: RegisterSpec for CHANNEL3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [channel3::R](R) reader structure"]
impl crate :: Readable for CHANNEL3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel3::W](W) writer structure"]
impl crate :: Writable for CHANNEL3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHANNEL3 to value 0"]
impl crate :: Resettable for CHANNEL3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHANNEL4 (rw) register accessor: an alias for `Reg<CHANNEL4_SPEC>`"]
pub type CHANNEL4 = crate :: Reg < channel4 :: CHANNEL4_SPEC > ; # [doc = "Multiplexer Channel 4"]
pub mod channel4 { # [doc = "Register `CHANNEL4` reader"]
pub struct R (crate :: R < CHANNEL4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL4_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL4` writer"]
pub struct W (crate :: W < CHANNEL4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL4_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENERATOR` reader - Generator selector"]
pub type GENERATOR_R = crate :: FieldReader < u8 , GENERATOR_A > ; # [doc = "Generator selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum GENERATOR_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Unified Program and Debug Interface"]
UPDI = 1 , # [doc = "6: Real Time Counter overflow"]
RTC_OVF = 6 , # [doc = "7: Real Time Counter compare"]
RTC_CMP = 7 , # [doc = "8: Periodic Interrupt Timer output 0"]
RTC_PIT0 = 8 , # [doc = "9: Periodic Interrupt Timer output 1"]
RTC_PIT1 = 9 , # [doc = "10: Periodic Interrupt Timer output 2"]
RTC_PIT2 = 10 , # [doc = "11: Periodic Interrupt Timer output 3"]
RTC_PIT3 = 11 , # [doc = "16: Configurable Custom Logic LUT0"]
CCL_LUT0 = 16 , # [doc = "17: Configurable Custom Logic LUT1"]
CCL_LUT1 = 17 , # [doc = "18: Configurable Custom Logic LUT2"]
CCL_LUT2 = 18 , # [doc = "19: Configurable Custom Logic LUT3"]
CCL_LUT3 = 19 , # [doc = "32: Analog Comparator 0 out"]
AC0_OUT = 32 , # [doc = "36: ADC 0 Result Ready Event"]
ADC0_RESRDY = 36 , # [doc = "64: Port 0 Pin 0"]
PORT0_PIN0 = 64 , # [doc = "65: Port 0 Pin 1"]
PORT0_PIN1 = 65 , # [doc = "66: Port 0 Pin 2"]
PORT0_PIN2 = 66 , # [doc = "67: Port 0 Pin 3"]
PORT0_PIN3 = 67 , # [doc = "68: Port 0 Pin 4"]
PORT0_PIN4 = 68 , # [doc = "69: Port 0 Pin 5"]
PORT0_PIN5 = 69 , # [doc = "70: Port 0 Pin 6"]
PORT0_PIN6 = 70 , # [doc = "71: Port 0 Pin 7"]
PORT0_PIN7 = 71 , # [doc = "72: Port 1 Pin 0"]
PORT1_PIN0 = 72 , # [doc = "73: Port 1 Pin 1"]
PORT1_PIN1 = 73 , # [doc = "74: Port 1 Pin 2"]
PORT1_PIN2 = 74 , # [doc = "75: Port 1 Pin 3"]
PORT1_PIN3 = 75 , # [doc = "76: Port 1 Pin 4"]
PORT1_PIN4 = 76 , # [doc = "77: Port 1 Pin 5"]
PORT1_PIN5 = 77 , # [doc = "78: Port 1 Pin 6"]
PORT1_PIN6 = 78 , # [doc = "79: Port 1 Pin 7"]
PORT1_PIN7 = 79 , # [doc = "96: USART 0 Xclock"]
USART0_XCK = 96 , # [doc = "97: USART 1 Xclock"]
USART1_XCK = 97 , # [doc = "98: USART 2 Xclock"]
USART2_XCK = 98 , # [doc = "99: USART 3 Xclock"]
USART3_XCK = 99 , # [doc = "104: SPI 0 Sclock"]
SPI0_SCK = 104 , # [doc = "128: Timer/Counter A0 overflow / low byte underflow"]
TCA0_OVF_LUNF = 128 , # [doc = "129: Timer/Counter A0 high byte underflow (split mode)"]
TCA0_HUNF = 129 , # [doc = "132: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 132 , # [doc = "133: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 133 , # [doc = "134: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 134 , # [doc = "160: Timer/Counter B0 capture"]
TCB0_CAPT = 160 , # [doc = "162: Timer/Counter B1 capture"]
TCB1_CAPT = 162 , # [doc = "164: Timer/Counter B2 capture"]
TCB2_CAPT = 164 , # [doc = "166: Timer/Counter B3 capture"]
TCB3_CAPT = 166 , } impl From < GENERATOR_A > for u8 { # [inline (always)]
fn from (variant : GENERATOR_A) -> Self { variant as _ } } impl GENERATOR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GENERATOR_A > { match self . bits { 0 => Some (GENERATOR_A :: OFF) , 1 => Some (GENERATOR_A :: UPDI) , 6 => Some (GENERATOR_A :: RTC_OVF) , 7 => Some (GENERATOR_A :: RTC_CMP) , 8 => Some (GENERATOR_A :: RTC_PIT0) , 9 => Some (GENERATOR_A :: RTC_PIT1) , 10 => Some (GENERATOR_A :: RTC_PIT2) , 11 => Some (GENERATOR_A :: RTC_PIT3) , 16 => Some (GENERATOR_A :: CCL_LUT0) , 17 => Some (GENERATOR_A :: CCL_LUT1) , 18 => Some (GENERATOR_A :: CCL_LUT2) , 19 => Some (GENERATOR_A :: CCL_LUT3) , 32 => Some (GENERATOR_A :: AC0_OUT) , 36 => Some (GENERATOR_A :: ADC0_RESRDY) , 64 => Some (GENERATOR_A :: PORT0_PIN0) , 65 => Some (GENERATOR_A :: PORT0_PIN1) , 66 => Some (GENERATOR_A :: PORT0_PIN2) , 67 => Some (GENERATOR_A :: PORT0_PIN3) , 68 => Some (GENERATOR_A :: PORT0_PIN4) , 69 => Some (GENERATOR_A :: PORT0_PIN5) , 70 => Some (GENERATOR_A :: PORT0_PIN6) , 71 => Some (GENERATOR_A :: PORT0_PIN7) , 72 => Some (GENERATOR_A :: PORT1_PIN0) , 73 => Some (GENERATOR_A :: PORT1_PIN1) , 74 => Some (GENERATOR_A :: PORT1_PIN2) , 75 => Some (GENERATOR_A :: PORT1_PIN3) , 76 => Some (GENERATOR_A :: PORT1_PIN4) , 77 => Some (GENERATOR_A :: PORT1_PIN5) , 78 => Some (GENERATOR_A :: PORT1_PIN6) , 79 => Some (GENERATOR_A :: PORT1_PIN7) , 96 => Some (GENERATOR_A :: USART0_XCK) , 97 => Some (GENERATOR_A :: USART1_XCK) , 98 => Some (GENERATOR_A :: USART2_XCK) , 99 => Some (GENERATOR_A :: USART3_XCK) , 104 => Some (GENERATOR_A :: SPI0_SCK) , 128 => Some (GENERATOR_A :: TCA0_OVF_LUNF) , 129 => Some (GENERATOR_A :: TCA0_HUNF) , 132 => Some (GENERATOR_A :: TCA0_CMP0) , 133 => Some (GENERATOR_A :: TCA0_CMP1) , 134 => Some (GENERATOR_A :: TCA0_CMP2) , 160 => Some (GENERATOR_A :: TCB0_CAPT) , 162 => Some (GENERATOR_A :: TCB1_CAPT) , 164 => Some (GENERATOR_A :: TCB2_CAPT) , 166 => Some (GENERATOR_A :: TCB3_CAPT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == GENERATOR_A :: OFF } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == GENERATOR_A :: UPDI } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == GENERATOR_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == GENERATOR_A :: RTC_CMP } # [doc = "Checks if the value of the field is `RTC_PIT0`"]
# [inline (always)]
pub fn is_rtc_pit0 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT0 } # [doc = "Checks if the value of the field is `RTC_PIT1`"]
# [inline (always)]
pub fn is_rtc_pit1 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT1 } # [doc = "Checks if the value of the field is `RTC_PIT2`"]
# [inline (always)]
pub fn is_rtc_pit2 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT2 } # [doc = "Checks if the value of the field is `RTC_PIT3`"]
# [inline (always)]
pub fn is_rtc_pit3 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT3 } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `CCL_LUT2`"]
# [inline (always)]
pub fn is_ccl_lut2 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT2 } # [doc = "Checks if the value of the field is `CCL_LUT3`"]
# [inline (always)]
pub fn is_ccl_lut3 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT3 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == GENERATOR_A :: AC0_OUT } # [doc = "Checks if the value of the field is `ADC0_RESRDY`"]
# [inline (always)]
pub fn is_adc0_resrdy (& self) -> bool { * self == GENERATOR_A :: ADC0_RESRDY } # [doc = "Checks if the value of the field is `PORT0_PIN0`"]
# [inline (always)]
pub fn is_port0_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN0 } # [doc = "Checks if the value of the field is `PORT0_PIN1`"]
# [inline (always)]
pub fn is_port0_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN1 } # [doc = "Checks if the value of the field is `PORT0_PIN2`"]
# [inline (always)]
pub fn is_port0_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN2 } # [doc = "Checks if the value of the field is `PORT0_PIN3`"]
# [inline (always)]
pub fn is_port0_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN3 } # [doc = "Checks if the value of the field is `PORT0_PIN4`"]
# [inline (always)]
pub fn is_port0_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN4 } # [doc = "Checks if the value of the field is `PORT0_PIN5`"]
# [inline (always)]
pub fn is_port0_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN5 } # [doc = "Checks if the value of the field is `PORT0_PIN6`"]
# [inline (always)]
pub fn is_port0_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN6 } # [doc = "Checks if the value of the field is `PORT0_PIN7`"]
# [inline (always)]
pub fn is_port0_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN7 } # [doc = "Checks if the value of the field is `PORT1_PIN0`"]
# [inline (always)]
pub fn is_port1_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN0 } # [doc = "Checks if the value of the field is `PORT1_PIN1`"]
# [inline (always)]
pub fn is_port1_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN1 } # [doc = "Checks if the value of the field is `PORT1_PIN2`"]
# [inline (always)]
pub fn is_port1_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN2 } # [doc = "Checks if the value of the field is `PORT1_PIN3`"]
# [inline (always)]
pub fn is_port1_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN3 } # [doc = "Checks if the value of the field is `PORT1_PIN4`"]
# [inline (always)]
pub fn is_port1_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN4 } # [doc = "Checks if the value of the field is `PORT1_PIN5`"]
# [inline (always)]
pub fn is_port1_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN5 } # [doc = "Checks if the value of the field is `PORT1_PIN6`"]
# [inline (always)]
pub fn is_port1_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN6 } # [doc = "Checks if the value of the field is `PORT1_PIN7`"]
# [inline (always)]
pub fn is_port1_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN7 } # [doc = "Checks if the value of the field is `USART0_XCK`"]
# [inline (always)]
pub fn is_usart0_xck (& self) -> bool { * self == GENERATOR_A :: USART0_XCK } # [doc = "Checks if the value of the field is `USART1_XCK`"]
# [inline (always)]
pub fn is_usart1_xck (& self) -> bool { * self == GENERATOR_A :: USART1_XCK } # [doc = "Checks if the value of the field is `USART2_XCK`"]
# [inline (always)]
pub fn is_usart2_xck (& self) -> bool { * self == GENERATOR_A :: USART2_XCK } # [doc = "Checks if the value of the field is `USART3_XCK`"]
# [inline (always)]
pub fn is_usart3_xck (& self) -> bool { * self == GENERATOR_A :: USART3_XCK } # [doc = "Checks if the value of the field is `SPI0_SCK`"]
# [inline (always)]
pub fn is_spi0_sck (& self) -> bool { * self == GENERATOR_A :: SPI0_SCK } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == GENERATOR_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == GENERATOR_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `TCB0_CAPT`"]
# [inline (always)]
pub fn is_tcb0_capt (& self) -> bool { * self == GENERATOR_A :: TCB0_CAPT } # [doc = "Checks if the value of the field is `TCB1_CAPT`"]
# [inline (always)]
pub fn is_tcb1_capt (& self) -> bool { * self == GENERATOR_A :: TCB1_CAPT } # [doc = "Checks if the value of the field is `TCB2_CAPT`"]
# [inline (always)]
pub fn is_tcb2_capt (& self) -> bool { * self == GENERATOR_A :: TCB2_CAPT } # [doc = "Checks if the value of the field is `TCB3_CAPT`"]
# [inline (always)]
pub fn is_tcb3_capt (& self) -> bool { * self == GENERATOR_A :: TCB3_CAPT } } # [doc = "Field `GENERATOR` writer - Generator selector"]
pub type GENERATOR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CHANNEL4_SPEC , u8 , GENERATOR_A , 8 , O > ; impl < 'a , const O : u8 > GENERATOR_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (GENERATOR_A :: OFF) } # [doc = "Unified Program and Debug Interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (GENERATOR_A :: UPDI) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_CMP) } # [doc = "Periodic Interrupt Timer output 0"]
# [inline (always)]
pub fn rtc_pit0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT0) } # [doc = "Periodic Interrupt Timer output 1"]
# [inline (always)]
pub fn rtc_pit1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT1) } # [doc = "Periodic Interrupt Timer output 2"]
# [inline (always)]
pub fn rtc_pit2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT2) } # [doc = "Periodic Interrupt Timer output 3"]
# [inline (always)]
pub fn rtc_pit3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT3) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT1) } # [doc = "Configurable Custom Logic LUT2"]
# [inline (always)]
pub fn ccl_lut2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT2) } # [doc = "Configurable Custom Logic LUT3"]
# [inline (always)]
pub fn ccl_lut3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT3) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (GENERATOR_A :: AC0_OUT) } # [doc = "ADC 0 Result Ready Event"]
# [inline (always)]
pub fn adc0_resrdy (self) -> & 'a mut W { self . variant (GENERATOR_A :: ADC0_RESRDY) } # [doc = "Port 0 Pin 0"]
# [inline (always)]
pub fn port0_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN0) } # [doc = "Port 0 Pin 1"]
# [inline (always)]
pub fn port0_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN1) } # [doc = "Port 0 Pin 2"]
# [inline (always)]
pub fn port0_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN2) } # [doc = "Port 0 Pin 3"]
# [inline (always)]
pub fn port0_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN3) } # [doc = "Port 0 Pin 4"]
# [inline (always)]
pub fn port0_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN4) } # [doc = "Port 0 Pin 5"]
# [inline (always)]
pub fn port0_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN5) } # [doc = "Port 0 Pin 6"]
# [inline (always)]
pub fn port0_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN6) } # [doc = "Port 0 Pin 7"]
# [inline (always)]
pub fn port0_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN7) } # [doc = "Port 1 Pin 0"]
# [inline (always)]
pub fn port1_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN0) } # [doc = "Port 1 Pin 1"]
# [inline (always)]
pub fn port1_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN1) } # [doc = "Port 1 Pin 2"]
# [inline (always)]
pub fn port1_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN2) } # [doc = "Port 1 Pin 3"]
# [inline (always)]
pub fn port1_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN3) } # [doc = "Port 1 Pin 4"]
# [inline (always)]
pub fn port1_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN4) } # [doc = "Port 1 Pin 5"]
# [inline (always)]
pub fn port1_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN5) } # [doc = "Port 1 Pin 6"]
# [inline (always)]
pub fn port1_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN6) } # [doc = "Port 1 Pin 7"]
# [inline (always)]
pub fn port1_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN7) } # [doc = "USART 0 Xclock"]
# [inline (always)]
pub fn usart0_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART0_XCK) } # [doc = "USART 1 Xclock"]
# [inline (always)]
pub fn usart1_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART1_XCK) } # [doc = "USART 2 Xclock"]
# [inline (always)]
pub fn usart2_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART2_XCK) } # [doc = "USART 3 Xclock"]
# [inline (always)]
pub fn usart3_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART3_XCK) } # [doc = "SPI 0 Sclock"]
# [inline (always)]
pub fn spi0_sck (self) -> & 'a mut W { self . variant (GENERATOR_A :: SPI0_SCK) } # [doc = "Timer/Counter A0 overflow / low byte underflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 high byte underflow (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP2) } # [doc = "Timer/Counter B0 capture"]
# [inline (always)]
pub fn tcb0_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB0_CAPT) } # [doc = "Timer/Counter B1 capture"]
# [inline (always)]
pub fn tcb1_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB1_CAPT) } # [doc = "Timer/Counter B2 capture"]
# [inline (always)]
pub fn tcb2_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB2_CAPT) } # [doc = "Timer/Counter B3 capture"]
# [inline (always)]
pub fn tcb3_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB3_CAPT) } } impl R { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
pub fn generator (& self) -> GENERATOR_R { GENERATOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
# [must_use]
pub fn generator (& mut self) -> GENERATOR_W < 0 > { GENERATOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiplexer Channel 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel4](index.html) module"]
pub struct CHANNEL4_SPEC ; impl crate :: RegisterSpec for CHANNEL4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [channel4::R](R) reader structure"]
impl crate :: Readable for CHANNEL4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel4::W](W) writer structure"]
impl crate :: Writable for CHANNEL4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHANNEL4 to value 0"]
impl crate :: Resettable for CHANNEL4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHANNEL5 (rw) register accessor: an alias for `Reg<CHANNEL5_SPEC>`"]
pub type CHANNEL5 = crate :: Reg < channel5 :: CHANNEL5_SPEC > ; # [doc = "Multiplexer Channel 5"]
pub mod channel5 { # [doc = "Register `CHANNEL5` reader"]
pub struct R (crate :: R < CHANNEL5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL5_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL5` writer"]
pub struct W (crate :: W < CHANNEL5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL5_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENERATOR` reader - Generator selector"]
pub type GENERATOR_R = crate :: FieldReader < u8 , GENERATOR_A > ; # [doc = "Generator selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum GENERATOR_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Unified Program and Debug Interface"]
UPDI = 1 , # [doc = "6: Real Time Counter overflow"]
RTC_OVF = 6 , # [doc = "7: Real Time Counter compare"]
RTC_CMP = 7 , # [doc = "8: Periodic Interrupt Timer output 0"]
RTC_PIT0 = 8 , # [doc = "9: Periodic Interrupt Timer output 1"]
RTC_PIT1 = 9 , # [doc = "10: Periodic Interrupt Timer output 2"]
RTC_PIT2 = 10 , # [doc = "11: Periodic Interrupt Timer output 3"]
RTC_PIT3 = 11 , # [doc = "16: Configurable Custom Logic LUT0"]
CCL_LUT0 = 16 , # [doc = "17: Configurable Custom Logic LUT1"]
CCL_LUT1 = 17 , # [doc = "18: Configurable Custom Logic LUT2"]
CCL_LUT2 = 18 , # [doc = "19: Configurable Custom Logic LUT3"]
CCL_LUT3 = 19 , # [doc = "32: Analog Comparator 0 out"]
AC0_OUT = 32 , # [doc = "36: ADC 0 Result Ready Event"]
ADC0_RESRDY = 36 , # [doc = "64: Port 0 Pin 0"]
PORT0_PIN0 = 64 , # [doc = "65: Port 0 Pin 1"]
PORT0_PIN1 = 65 , # [doc = "66: Port 0 Pin 2"]
PORT0_PIN2 = 66 , # [doc = "67: Port 0 Pin 3"]
PORT0_PIN3 = 67 , # [doc = "68: Port 0 Pin 4"]
PORT0_PIN4 = 68 , # [doc = "69: Port 0 Pin 5"]
PORT0_PIN5 = 69 , # [doc = "70: Port 0 Pin 6"]
PORT0_PIN6 = 70 , # [doc = "71: Port 0 Pin 7"]
PORT0_PIN7 = 71 , # [doc = "72: Port 1 Pin 0"]
PORT1_PIN0 = 72 , # [doc = "73: Port 1 Pin 1"]
PORT1_PIN1 = 73 , # [doc = "74: Port 1 Pin 2"]
PORT1_PIN2 = 74 , # [doc = "75: Port 1 Pin 3"]
PORT1_PIN3 = 75 , # [doc = "76: Port 1 Pin 4"]
PORT1_PIN4 = 76 , # [doc = "77: Port 1 Pin 5"]
PORT1_PIN5 = 77 , # [doc = "78: Port 1 Pin 6"]
PORT1_PIN6 = 78 , # [doc = "79: Port 1 Pin 7"]
PORT1_PIN7 = 79 , # [doc = "96: USART 0 Xclock"]
USART0_XCK = 96 , # [doc = "97: USART 1 Xclock"]
USART1_XCK = 97 , # [doc = "98: USART 2 Xclock"]
USART2_XCK = 98 , # [doc = "99: USART 3 Xclock"]
USART3_XCK = 99 , # [doc = "104: SPI 0 Sclock"]
SPI0_SCK = 104 , # [doc = "128: Timer/Counter A0 overflow / low byte underflow"]
TCA0_OVF_LUNF = 128 , # [doc = "129: Timer/Counter A0 high byte underflow (split mode)"]
TCA0_HUNF = 129 , # [doc = "132: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 132 , # [doc = "133: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 133 , # [doc = "134: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 134 , # [doc = "160: Timer/Counter B0 capture"]
TCB0_CAPT = 160 , # [doc = "162: Timer/Counter B1 capture"]
TCB1_CAPT = 162 , # [doc = "164: Timer/Counter B2 capture"]
TCB2_CAPT = 164 , # [doc = "166: Timer/Counter B3 capture"]
TCB3_CAPT = 166 , } impl From < GENERATOR_A > for u8 { # [inline (always)]
fn from (variant : GENERATOR_A) -> Self { variant as _ } } impl GENERATOR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GENERATOR_A > { match self . bits { 0 => Some (GENERATOR_A :: OFF) , 1 => Some (GENERATOR_A :: UPDI) , 6 => Some (GENERATOR_A :: RTC_OVF) , 7 => Some (GENERATOR_A :: RTC_CMP) , 8 => Some (GENERATOR_A :: RTC_PIT0) , 9 => Some (GENERATOR_A :: RTC_PIT1) , 10 => Some (GENERATOR_A :: RTC_PIT2) , 11 => Some (GENERATOR_A :: RTC_PIT3) , 16 => Some (GENERATOR_A :: CCL_LUT0) , 17 => Some (GENERATOR_A :: CCL_LUT1) , 18 => Some (GENERATOR_A :: CCL_LUT2) , 19 => Some (GENERATOR_A :: CCL_LUT3) , 32 => Some (GENERATOR_A :: AC0_OUT) , 36 => Some (GENERATOR_A :: ADC0_RESRDY) , 64 => Some (GENERATOR_A :: PORT0_PIN0) , 65 => Some (GENERATOR_A :: PORT0_PIN1) , 66 => Some (GENERATOR_A :: PORT0_PIN2) , 67 => Some (GENERATOR_A :: PORT0_PIN3) , 68 => Some (GENERATOR_A :: PORT0_PIN4) , 69 => Some (GENERATOR_A :: PORT0_PIN5) , 70 => Some (GENERATOR_A :: PORT0_PIN6) , 71 => Some (GENERATOR_A :: PORT0_PIN7) , 72 => Some (GENERATOR_A :: PORT1_PIN0) , 73 => Some (GENERATOR_A :: PORT1_PIN1) , 74 => Some (GENERATOR_A :: PORT1_PIN2) , 75 => Some (GENERATOR_A :: PORT1_PIN3) , 76 => Some (GENERATOR_A :: PORT1_PIN4) , 77 => Some (GENERATOR_A :: PORT1_PIN5) , 78 => Some (GENERATOR_A :: PORT1_PIN6) , 79 => Some (GENERATOR_A :: PORT1_PIN7) , 96 => Some (GENERATOR_A :: USART0_XCK) , 97 => Some (GENERATOR_A :: USART1_XCK) , 98 => Some (GENERATOR_A :: USART2_XCK) , 99 => Some (GENERATOR_A :: USART3_XCK) , 104 => Some (GENERATOR_A :: SPI0_SCK) , 128 => Some (GENERATOR_A :: TCA0_OVF_LUNF) , 129 => Some (GENERATOR_A :: TCA0_HUNF) , 132 => Some (GENERATOR_A :: TCA0_CMP0) , 133 => Some (GENERATOR_A :: TCA0_CMP1) , 134 => Some (GENERATOR_A :: TCA0_CMP2) , 160 => Some (GENERATOR_A :: TCB0_CAPT) , 162 => Some (GENERATOR_A :: TCB1_CAPT) , 164 => Some (GENERATOR_A :: TCB2_CAPT) , 166 => Some (GENERATOR_A :: TCB3_CAPT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == GENERATOR_A :: OFF } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == GENERATOR_A :: UPDI } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == GENERATOR_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == GENERATOR_A :: RTC_CMP } # [doc = "Checks if the value of the field is `RTC_PIT0`"]
# [inline (always)]
pub fn is_rtc_pit0 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT0 } # [doc = "Checks if the value of the field is `RTC_PIT1`"]
# [inline (always)]
pub fn is_rtc_pit1 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT1 } # [doc = "Checks if the value of the field is `RTC_PIT2`"]
# [inline (always)]
pub fn is_rtc_pit2 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT2 } # [doc = "Checks if the value of the field is `RTC_PIT3`"]
# [inline (always)]
pub fn is_rtc_pit3 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT3 } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `CCL_LUT2`"]
# [inline (always)]
pub fn is_ccl_lut2 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT2 } # [doc = "Checks if the value of the field is `CCL_LUT3`"]
# [inline (always)]
pub fn is_ccl_lut3 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT3 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == GENERATOR_A :: AC0_OUT } # [doc = "Checks if the value of the field is `ADC0_RESRDY`"]
# [inline (always)]
pub fn is_adc0_resrdy (& self) -> bool { * self == GENERATOR_A :: ADC0_RESRDY } # [doc = "Checks if the value of the field is `PORT0_PIN0`"]
# [inline (always)]
pub fn is_port0_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN0 } # [doc = "Checks if the value of the field is `PORT0_PIN1`"]
# [inline (always)]
pub fn is_port0_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN1 } # [doc = "Checks if the value of the field is `PORT0_PIN2`"]
# [inline (always)]
pub fn is_port0_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN2 } # [doc = "Checks if the value of the field is `PORT0_PIN3`"]
# [inline (always)]
pub fn is_port0_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN3 } # [doc = "Checks if the value of the field is `PORT0_PIN4`"]
# [inline (always)]
pub fn is_port0_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN4 } # [doc = "Checks if the value of the field is `PORT0_PIN5`"]
# [inline (always)]
pub fn is_port0_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN5 } # [doc = "Checks if the value of the field is `PORT0_PIN6`"]
# [inline (always)]
pub fn is_port0_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN6 } # [doc = "Checks if the value of the field is `PORT0_PIN7`"]
# [inline (always)]
pub fn is_port0_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN7 } # [doc = "Checks if the value of the field is `PORT1_PIN0`"]
# [inline (always)]
pub fn is_port1_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN0 } # [doc = "Checks if the value of the field is `PORT1_PIN1`"]
# [inline (always)]
pub fn is_port1_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN1 } # [doc = "Checks if the value of the field is `PORT1_PIN2`"]
# [inline (always)]
pub fn is_port1_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN2 } # [doc = "Checks if the value of the field is `PORT1_PIN3`"]
# [inline (always)]
pub fn is_port1_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN3 } # [doc = "Checks if the value of the field is `PORT1_PIN4`"]
# [inline (always)]
pub fn is_port1_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN4 } # [doc = "Checks if the value of the field is `PORT1_PIN5`"]
# [inline (always)]
pub fn is_port1_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN5 } # [doc = "Checks if the value of the field is `PORT1_PIN6`"]
# [inline (always)]
pub fn is_port1_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN6 } # [doc = "Checks if the value of the field is `PORT1_PIN7`"]
# [inline (always)]
pub fn is_port1_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN7 } # [doc = "Checks if the value of the field is `USART0_XCK`"]
# [inline (always)]
pub fn is_usart0_xck (& self) -> bool { * self == GENERATOR_A :: USART0_XCK } # [doc = "Checks if the value of the field is `USART1_XCK`"]
# [inline (always)]
pub fn is_usart1_xck (& self) -> bool { * self == GENERATOR_A :: USART1_XCK } # [doc = "Checks if the value of the field is `USART2_XCK`"]
# [inline (always)]
pub fn is_usart2_xck (& self) -> bool { * self == GENERATOR_A :: USART2_XCK } # [doc = "Checks if the value of the field is `USART3_XCK`"]
# [inline (always)]
pub fn is_usart3_xck (& self) -> bool { * self == GENERATOR_A :: USART3_XCK } # [doc = "Checks if the value of the field is `SPI0_SCK`"]
# [inline (always)]
pub fn is_spi0_sck (& self) -> bool { * self == GENERATOR_A :: SPI0_SCK } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == GENERATOR_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == GENERATOR_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `TCB0_CAPT`"]
# [inline (always)]
pub fn is_tcb0_capt (& self) -> bool { * self == GENERATOR_A :: TCB0_CAPT } # [doc = "Checks if the value of the field is `TCB1_CAPT`"]
# [inline (always)]
pub fn is_tcb1_capt (& self) -> bool { * self == GENERATOR_A :: TCB1_CAPT } # [doc = "Checks if the value of the field is `TCB2_CAPT`"]
# [inline (always)]
pub fn is_tcb2_capt (& self) -> bool { * self == GENERATOR_A :: TCB2_CAPT } # [doc = "Checks if the value of the field is `TCB3_CAPT`"]
# [inline (always)]
pub fn is_tcb3_capt (& self) -> bool { * self == GENERATOR_A :: TCB3_CAPT } } # [doc = "Field `GENERATOR` writer - Generator selector"]
pub type GENERATOR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CHANNEL5_SPEC , u8 , GENERATOR_A , 8 , O > ; impl < 'a , const O : u8 > GENERATOR_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (GENERATOR_A :: OFF) } # [doc = "Unified Program and Debug Interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (GENERATOR_A :: UPDI) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_CMP) } # [doc = "Periodic Interrupt Timer output 0"]
# [inline (always)]
pub fn rtc_pit0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT0) } # [doc = "Periodic Interrupt Timer output 1"]
# [inline (always)]
pub fn rtc_pit1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT1) } # [doc = "Periodic Interrupt Timer output 2"]
# [inline (always)]
pub fn rtc_pit2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT2) } # [doc = "Periodic Interrupt Timer output 3"]
# [inline (always)]
pub fn rtc_pit3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT3) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT1) } # [doc = "Configurable Custom Logic LUT2"]
# [inline (always)]
pub fn ccl_lut2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT2) } # [doc = "Configurable Custom Logic LUT3"]
# [inline (always)]
pub fn ccl_lut3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT3) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (GENERATOR_A :: AC0_OUT) } # [doc = "ADC 0 Result Ready Event"]
# [inline (always)]
pub fn adc0_resrdy (self) -> & 'a mut W { self . variant (GENERATOR_A :: ADC0_RESRDY) } # [doc = "Port 0 Pin 0"]
# [inline (always)]
pub fn port0_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN0) } # [doc = "Port 0 Pin 1"]
# [inline (always)]
pub fn port0_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN1) } # [doc = "Port 0 Pin 2"]
# [inline (always)]
pub fn port0_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN2) } # [doc = "Port 0 Pin 3"]
# [inline (always)]
pub fn port0_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN3) } # [doc = "Port 0 Pin 4"]
# [inline (always)]
pub fn port0_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN4) } # [doc = "Port 0 Pin 5"]
# [inline (always)]
pub fn port0_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN5) } # [doc = "Port 0 Pin 6"]
# [inline (always)]
pub fn port0_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN6) } # [doc = "Port 0 Pin 7"]
# [inline (always)]
pub fn port0_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN7) } # [doc = "Port 1 Pin 0"]
# [inline (always)]
pub fn port1_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN0) } # [doc = "Port 1 Pin 1"]
# [inline (always)]
pub fn port1_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN1) } # [doc = "Port 1 Pin 2"]
# [inline (always)]
pub fn port1_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN2) } # [doc = "Port 1 Pin 3"]
# [inline (always)]
pub fn port1_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN3) } # [doc = "Port 1 Pin 4"]
# [inline (always)]
pub fn port1_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN4) } # [doc = "Port 1 Pin 5"]
# [inline (always)]
pub fn port1_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN5) } # [doc = "Port 1 Pin 6"]
# [inline (always)]
pub fn port1_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN6) } # [doc = "Port 1 Pin 7"]
# [inline (always)]
pub fn port1_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN7) } # [doc = "USART 0 Xclock"]
# [inline (always)]
pub fn usart0_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART0_XCK) } # [doc = "USART 1 Xclock"]
# [inline (always)]
pub fn usart1_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART1_XCK) } # [doc = "USART 2 Xclock"]
# [inline (always)]
pub fn usart2_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART2_XCK) } # [doc = "USART 3 Xclock"]
# [inline (always)]
pub fn usart3_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART3_XCK) } # [doc = "SPI 0 Sclock"]
# [inline (always)]
pub fn spi0_sck (self) -> & 'a mut W { self . variant (GENERATOR_A :: SPI0_SCK) } # [doc = "Timer/Counter A0 overflow / low byte underflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 high byte underflow (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP2) } # [doc = "Timer/Counter B0 capture"]
# [inline (always)]
pub fn tcb0_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB0_CAPT) } # [doc = "Timer/Counter B1 capture"]
# [inline (always)]
pub fn tcb1_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB1_CAPT) } # [doc = "Timer/Counter B2 capture"]
# [inline (always)]
pub fn tcb2_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB2_CAPT) } # [doc = "Timer/Counter B3 capture"]
# [inline (always)]
pub fn tcb3_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB3_CAPT) } } impl R { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
pub fn generator (& self) -> GENERATOR_R { GENERATOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
# [must_use]
pub fn generator (& mut self) -> GENERATOR_W < 0 > { GENERATOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiplexer Channel 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel5](index.html) module"]
pub struct CHANNEL5_SPEC ; impl crate :: RegisterSpec for CHANNEL5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [channel5::R](R) reader structure"]
impl crate :: Readable for CHANNEL5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel5::W](W) writer structure"]
impl crate :: Writable for CHANNEL5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHANNEL5 to value 0"]
impl crate :: Resettable for CHANNEL5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHANNEL6 (rw) register accessor: an alias for `Reg<CHANNEL6_SPEC>`"]
pub type CHANNEL6 = crate :: Reg < channel6 :: CHANNEL6_SPEC > ; # [doc = "Multiplexer Channel 6"]
pub mod channel6 { # [doc = "Register `CHANNEL6` reader"]
pub struct R (crate :: R < CHANNEL6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL6_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL6` writer"]
pub struct W (crate :: W < CHANNEL6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL6_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENERATOR` reader - Generator selector"]
pub type GENERATOR_R = crate :: FieldReader < u8 , GENERATOR_A > ; # [doc = "Generator selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum GENERATOR_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Unified Program and Debug Interface"]
UPDI = 1 , # [doc = "6: Real Time Counter overflow"]
RTC_OVF = 6 , # [doc = "7: Real Time Counter compare"]
RTC_CMP = 7 , # [doc = "8: Periodic Interrupt Timer output 0"]
RTC_PIT0 = 8 , # [doc = "9: Periodic Interrupt Timer output 1"]
RTC_PIT1 = 9 , # [doc = "10: Periodic Interrupt Timer output 2"]
RTC_PIT2 = 10 , # [doc = "11: Periodic Interrupt Timer output 3"]
RTC_PIT3 = 11 , # [doc = "16: Configurable Custom Logic LUT0"]
CCL_LUT0 = 16 , # [doc = "17: Configurable Custom Logic LUT1"]
CCL_LUT1 = 17 , # [doc = "18: Configurable Custom Logic LUT2"]
CCL_LUT2 = 18 , # [doc = "19: Configurable Custom Logic LUT3"]
CCL_LUT3 = 19 , # [doc = "32: Analog Comparator 0 out"]
AC0_OUT = 32 , # [doc = "36: ADC 0 Result Ready Event"]
ADC0_RESRDY = 36 , # [doc = "64: Port 0 Pin 0"]
PORT0_PIN0 = 64 , # [doc = "65: Port 0 Pin 1"]
PORT0_PIN1 = 65 , # [doc = "66: Port 0 Pin 2"]
PORT0_PIN2 = 66 , # [doc = "67: Port 0 Pin 3"]
PORT0_PIN3 = 67 , # [doc = "68: Port 0 Pin 4"]
PORT0_PIN4 = 68 , # [doc = "69: Port 0 Pin 5"]
PORT0_PIN5 = 69 , # [doc = "70: Port 0 Pin 6"]
PORT0_PIN6 = 70 , # [doc = "71: Port 0 Pin 7"]
PORT0_PIN7 = 71 , # [doc = "72: Port 1 Pin 0"]
PORT1_PIN0 = 72 , # [doc = "73: Port 1 Pin 1"]
PORT1_PIN1 = 73 , # [doc = "74: Port 1 Pin 2"]
PORT1_PIN2 = 74 , # [doc = "75: Port 1 Pin 3"]
PORT1_PIN3 = 75 , # [doc = "76: Port 1 Pin 4"]
PORT1_PIN4 = 76 , # [doc = "77: Port 1 Pin 5"]
PORT1_PIN5 = 77 , # [doc = "78: Port 1 Pin 6"]
PORT1_PIN6 = 78 , # [doc = "79: Port 1 Pin 7"]
PORT1_PIN7 = 79 , # [doc = "96: USART 0 Xclock"]
USART0_XCK = 96 , # [doc = "97: USART 1 Xclock"]
USART1_XCK = 97 , # [doc = "98: USART 2 Xclock"]
USART2_XCK = 98 , # [doc = "99: USART 3 Xclock"]
USART3_XCK = 99 , # [doc = "104: SPI 0 Sclock"]
SPI0_SCK = 104 , # [doc = "128: Timer/Counter A0 overflow / low byte underflow"]
TCA0_OVF_LUNF = 128 , # [doc = "129: Timer/Counter A0 high byte underflow (split mode)"]
TCA0_HUNF = 129 , # [doc = "132: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 132 , # [doc = "133: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 133 , # [doc = "134: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 134 , # [doc = "160: Timer/Counter B0 capture"]
TCB0_CAPT = 160 , # [doc = "162: Timer/Counter B1 capture"]
TCB1_CAPT = 162 , # [doc = "164: Timer/Counter B2 capture"]
TCB2_CAPT = 164 , # [doc = "166: Timer/Counter B3 capture"]
TCB3_CAPT = 166 , } impl From < GENERATOR_A > for u8 { # [inline (always)]
fn from (variant : GENERATOR_A) -> Self { variant as _ } } impl GENERATOR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GENERATOR_A > { match self . bits { 0 => Some (GENERATOR_A :: OFF) , 1 => Some (GENERATOR_A :: UPDI) , 6 => Some (GENERATOR_A :: RTC_OVF) , 7 => Some (GENERATOR_A :: RTC_CMP) , 8 => Some (GENERATOR_A :: RTC_PIT0) , 9 => Some (GENERATOR_A :: RTC_PIT1) , 10 => Some (GENERATOR_A :: RTC_PIT2) , 11 => Some (GENERATOR_A :: RTC_PIT3) , 16 => Some (GENERATOR_A :: CCL_LUT0) , 17 => Some (GENERATOR_A :: CCL_LUT1) , 18 => Some (GENERATOR_A :: CCL_LUT2) , 19 => Some (GENERATOR_A :: CCL_LUT3) , 32 => Some (GENERATOR_A :: AC0_OUT) , 36 => Some (GENERATOR_A :: ADC0_RESRDY) , 64 => Some (GENERATOR_A :: PORT0_PIN0) , 65 => Some (GENERATOR_A :: PORT0_PIN1) , 66 => Some (GENERATOR_A :: PORT0_PIN2) , 67 => Some (GENERATOR_A :: PORT0_PIN3) , 68 => Some (GENERATOR_A :: PORT0_PIN4) , 69 => Some (GENERATOR_A :: PORT0_PIN5) , 70 => Some (GENERATOR_A :: PORT0_PIN6) , 71 => Some (GENERATOR_A :: PORT0_PIN7) , 72 => Some (GENERATOR_A :: PORT1_PIN0) , 73 => Some (GENERATOR_A :: PORT1_PIN1) , 74 => Some (GENERATOR_A :: PORT1_PIN2) , 75 => Some (GENERATOR_A :: PORT1_PIN3) , 76 => Some (GENERATOR_A :: PORT1_PIN4) , 77 => Some (GENERATOR_A :: PORT1_PIN5) , 78 => Some (GENERATOR_A :: PORT1_PIN6) , 79 => Some (GENERATOR_A :: PORT1_PIN7) , 96 => Some (GENERATOR_A :: USART0_XCK) , 97 => Some (GENERATOR_A :: USART1_XCK) , 98 => Some (GENERATOR_A :: USART2_XCK) , 99 => Some (GENERATOR_A :: USART3_XCK) , 104 => Some (GENERATOR_A :: SPI0_SCK) , 128 => Some (GENERATOR_A :: TCA0_OVF_LUNF) , 129 => Some (GENERATOR_A :: TCA0_HUNF) , 132 => Some (GENERATOR_A :: TCA0_CMP0) , 133 => Some (GENERATOR_A :: TCA0_CMP1) , 134 => Some (GENERATOR_A :: TCA0_CMP2) , 160 => Some (GENERATOR_A :: TCB0_CAPT) , 162 => Some (GENERATOR_A :: TCB1_CAPT) , 164 => Some (GENERATOR_A :: TCB2_CAPT) , 166 => Some (GENERATOR_A :: TCB3_CAPT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == GENERATOR_A :: OFF } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == GENERATOR_A :: UPDI } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == GENERATOR_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == GENERATOR_A :: RTC_CMP } # [doc = "Checks if the value of the field is `RTC_PIT0`"]
# [inline (always)]
pub fn is_rtc_pit0 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT0 } # [doc = "Checks if the value of the field is `RTC_PIT1`"]
# [inline (always)]
pub fn is_rtc_pit1 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT1 } # [doc = "Checks if the value of the field is `RTC_PIT2`"]
# [inline (always)]
pub fn is_rtc_pit2 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT2 } # [doc = "Checks if the value of the field is `RTC_PIT3`"]
# [inline (always)]
pub fn is_rtc_pit3 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT3 } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `CCL_LUT2`"]
# [inline (always)]
pub fn is_ccl_lut2 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT2 } # [doc = "Checks if the value of the field is `CCL_LUT3`"]
# [inline (always)]
pub fn is_ccl_lut3 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT3 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == GENERATOR_A :: AC0_OUT } # [doc = "Checks if the value of the field is `ADC0_RESRDY`"]
# [inline (always)]
pub fn is_adc0_resrdy (& self) -> bool { * self == GENERATOR_A :: ADC0_RESRDY } # [doc = "Checks if the value of the field is `PORT0_PIN0`"]
# [inline (always)]
pub fn is_port0_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN0 } # [doc = "Checks if the value of the field is `PORT0_PIN1`"]
# [inline (always)]
pub fn is_port0_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN1 } # [doc = "Checks if the value of the field is `PORT0_PIN2`"]
# [inline (always)]
pub fn is_port0_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN2 } # [doc = "Checks if the value of the field is `PORT0_PIN3`"]
# [inline (always)]
pub fn is_port0_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN3 } # [doc = "Checks if the value of the field is `PORT0_PIN4`"]
# [inline (always)]
pub fn is_port0_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN4 } # [doc = "Checks if the value of the field is `PORT0_PIN5`"]
# [inline (always)]
pub fn is_port0_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN5 } # [doc = "Checks if the value of the field is `PORT0_PIN6`"]
# [inline (always)]
pub fn is_port0_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN6 } # [doc = "Checks if the value of the field is `PORT0_PIN7`"]
# [inline (always)]
pub fn is_port0_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN7 } # [doc = "Checks if the value of the field is `PORT1_PIN0`"]
# [inline (always)]
pub fn is_port1_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN0 } # [doc = "Checks if the value of the field is `PORT1_PIN1`"]
# [inline (always)]
pub fn is_port1_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN1 } # [doc = "Checks if the value of the field is `PORT1_PIN2`"]
# [inline (always)]
pub fn is_port1_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN2 } # [doc = "Checks if the value of the field is `PORT1_PIN3`"]
# [inline (always)]
pub fn is_port1_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN3 } # [doc = "Checks if the value of the field is `PORT1_PIN4`"]
# [inline (always)]
pub fn is_port1_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN4 } # [doc = "Checks if the value of the field is `PORT1_PIN5`"]
# [inline (always)]
pub fn is_port1_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN5 } # [doc = "Checks if the value of the field is `PORT1_PIN6`"]
# [inline (always)]
pub fn is_port1_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN6 } # [doc = "Checks if the value of the field is `PORT1_PIN7`"]
# [inline (always)]
pub fn is_port1_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN7 } # [doc = "Checks if the value of the field is `USART0_XCK`"]
# [inline (always)]
pub fn is_usart0_xck (& self) -> bool { * self == GENERATOR_A :: USART0_XCK } # [doc = "Checks if the value of the field is `USART1_XCK`"]
# [inline (always)]
pub fn is_usart1_xck (& self) -> bool { * self == GENERATOR_A :: USART1_XCK } # [doc = "Checks if the value of the field is `USART2_XCK`"]
# [inline (always)]
pub fn is_usart2_xck (& self) -> bool { * self == GENERATOR_A :: USART2_XCK } # [doc = "Checks if the value of the field is `USART3_XCK`"]
# [inline (always)]
pub fn is_usart3_xck (& self) -> bool { * self == GENERATOR_A :: USART3_XCK } # [doc = "Checks if the value of the field is `SPI0_SCK`"]
# [inline (always)]
pub fn is_spi0_sck (& self) -> bool { * self == GENERATOR_A :: SPI0_SCK } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == GENERATOR_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == GENERATOR_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `TCB0_CAPT`"]
# [inline (always)]
pub fn is_tcb0_capt (& self) -> bool { * self == GENERATOR_A :: TCB0_CAPT } # [doc = "Checks if the value of the field is `TCB1_CAPT`"]
# [inline (always)]
pub fn is_tcb1_capt (& self) -> bool { * self == GENERATOR_A :: TCB1_CAPT } # [doc = "Checks if the value of the field is `TCB2_CAPT`"]
# [inline (always)]
pub fn is_tcb2_capt (& self) -> bool { * self == GENERATOR_A :: TCB2_CAPT } # [doc = "Checks if the value of the field is `TCB3_CAPT`"]
# [inline (always)]
pub fn is_tcb3_capt (& self) -> bool { * self == GENERATOR_A :: TCB3_CAPT } } # [doc = "Field `GENERATOR` writer - Generator selector"]
pub type GENERATOR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CHANNEL6_SPEC , u8 , GENERATOR_A , 8 , O > ; impl < 'a , const O : u8 > GENERATOR_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (GENERATOR_A :: OFF) } # [doc = "Unified Program and Debug Interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (GENERATOR_A :: UPDI) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_CMP) } # [doc = "Periodic Interrupt Timer output 0"]
# [inline (always)]
pub fn rtc_pit0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT0) } # [doc = "Periodic Interrupt Timer output 1"]
# [inline (always)]
pub fn rtc_pit1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT1) } # [doc = "Periodic Interrupt Timer output 2"]
# [inline (always)]
pub fn rtc_pit2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT2) } # [doc = "Periodic Interrupt Timer output 3"]
# [inline (always)]
pub fn rtc_pit3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT3) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT1) } # [doc = "Configurable Custom Logic LUT2"]
# [inline (always)]
pub fn ccl_lut2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT2) } # [doc = "Configurable Custom Logic LUT3"]
# [inline (always)]
pub fn ccl_lut3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT3) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (GENERATOR_A :: AC0_OUT) } # [doc = "ADC 0 Result Ready Event"]
# [inline (always)]
pub fn adc0_resrdy (self) -> & 'a mut W { self . variant (GENERATOR_A :: ADC0_RESRDY) } # [doc = "Port 0 Pin 0"]
# [inline (always)]
pub fn port0_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN0) } # [doc = "Port 0 Pin 1"]
# [inline (always)]
pub fn port0_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN1) } # [doc = "Port 0 Pin 2"]
# [inline (always)]
pub fn port0_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN2) } # [doc = "Port 0 Pin 3"]
# [inline (always)]
pub fn port0_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN3) } # [doc = "Port 0 Pin 4"]
# [inline (always)]
pub fn port0_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN4) } # [doc = "Port 0 Pin 5"]
# [inline (always)]
pub fn port0_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN5) } # [doc = "Port 0 Pin 6"]
# [inline (always)]
pub fn port0_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN6) } # [doc = "Port 0 Pin 7"]
# [inline (always)]
pub fn port0_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN7) } # [doc = "Port 1 Pin 0"]
# [inline (always)]
pub fn port1_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN0) } # [doc = "Port 1 Pin 1"]
# [inline (always)]
pub fn port1_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN1) } # [doc = "Port 1 Pin 2"]
# [inline (always)]
pub fn port1_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN2) } # [doc = "Port 1 Pin 3"]
# [inline (always)]
pub fn port1_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN3) } # [doc = "Port 1 Pin 4"]
# [inline (always)]
pub fn port1_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN4) } # [doc = "Port 1 Pin 5"]
# [inline (always)]
pub fn port1_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN5) } # [doc = "Port 1 Pin 6"]
# [inline (always)]
pub fn port1_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN6) } # [doc = "Port 1 Pin 7"]
# [inline (always)]
pub fn port1_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN7) } # [doc = "USART 0 Xclock"]
# [inline (always)]
pub fn usart0_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART0_XCK) } # [doc = "USART 1 Xclock"]
# [inline (always)]
pub fn usart1_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART1_XCK) } # [doc = "USART 2 Xclock"]
# [inline (always)]
pub fn usart2_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART2_XCK) } # [doc = "USART 3 Xclock"]
# [inline (always)]
pub fn usart3_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART3_XCK) } # [doc = "SPI 0 Sclock"]
# [inline (always)]
pub fn spi0_sck (self) -> & 'a mut W { self . variant (GENERATOR_A :: SPI0_SCK) } # [doc = "Timer/Counter A0 overflow / low byte underflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 high byte underflow (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP2) } # [doc = "Timer/Counter B0 capture"]
# [inline (always)]
pub fn tcb0_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB0_CAPT) } # [doc = "Timer/Counter B1 capture"]
# [inline (always)]
pub fn tcb1_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB1_CAPT) } # [doc = "Timer/Counter B2 capture"]
# [inline (always)]
pub fn tcb2_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB2_CAPT) } # [doc = "Timer/Counter B3 capture"]
# [inline (always)]
pub fn tcb3_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB3_CAPT) } } impl R { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
pub fn generator (& self) -> GENERATOR_R { GENERATOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
# [must_use]
pub fn generator (& mut self) -> GENERATOR_W < 0 > { GENERATOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiplexer Channel 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel6](index.html) module"]
pub struct CHANNEL6_SPEC ; impl crate :: RegisterSpec for CHANNEL6_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [channel6::R](R) reader structure"]
impl crate :: Readable for CHANNEL6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel6::W](W) writer structure"]
impl crate :: Writable for CHANNEL6_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHANNEL6 to value 0"]
impl crate :: Resettable for CHANNEL6_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CHANNEL7 (rw) register accessor: an alias for `Reg<CHANNEL7_SPEC>`"]
pub type CHANNEL7 = crate :: Reg < channel7 :: CHANNEL7_SPEC > ; # [doc = "Multiplexer Channel 7"]
pub mod channel7 { # [doc = "Register `CHANNEL7` reader"]
pub struct R (crate :: R < CHANNEL7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL7_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL7` writer"]
pub struct W (crate :: W < CHANNEL7_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL7_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL7_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENERATOR` reader - Generator selector"]
pub type GENERATOR_R = crate :: FieldReader < u8 , GENERATOR_A > ; # [doc = "Generator selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum GENERATOR_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Unified Program and Debug Interface"]
UPDI = 1 , # [doc = "6: Real Time Counter overflow"]
RTC_OVF = 6 , # [doc = "7: Real Time Counter compare"]
RTC_CMP = 7 , # [doc = "8: Periodic Interrupt Timer output 0"]
RTC_PIT0 = 8 , # [doc = "9: Periodic Interrupt Timer output 1"]
RTC_PIT1 = 9 , # [doc = "10: Periodic Interrupt Timer output 2"]
RTC_PIT2 = 10 , # [doc = "11: Periodic Interrupt Timer output 3"]
RTC_PIT3 = 11 , # [doc = "16: Configurable Custom Logic LUT0"]
CCL_LUT0 = 16 , # [doc = "17: Configurable Custom Logic LUT1"]
CCL_LUT1 = 17 , # [doc = "18: Configurable Custom Logic LUT2"]
CCL_LUT2 = 18 , # [doc = "19: Configurable Custom Logic LUT3"]
CCL_LUT3 = 19 , # [doc = "32: Analog Comparator 0 out"]
AC0_OUT = 32 , # [doc = "36: ADC 0 Result Ready Event"]
ADC0_RESRDY = 36 , # [doc = "64: Port 0 Pin 0"]
PORT0_PIN0 = 64 , # [doc = "65: Port 0 Pin 1"]
PORT0_PIN1 = 65 , # [doc = "66: Port 0 Pin 2"]
PORT0_PIN2 = 66 , # [doc = "67: Port 0 Pin 3"]
PORT0_PIN3 = 67 , # [doc = "68: Port 0 Pin 4"]
PORT0_PIN4 = 68 , # [doc = "69: Port 0 Pin 5"]
PORT0_PIN5 = 69 , # [doc = "70: Port 0 Pin 6"]
PORT0_PIN6 = 70 , # [doc = "71: Port 0 Pin 7"]
PORT0_PIN7 = 71 , # [doc = "72: Port 1 Pin 0"]
PORT1_PIN0 = 72 , # [doc = "73: Port 1 Pin 1"]
PORT1_PIN1 = 73 , # [doc = "74: Port 1 Pin 2"]
PORT1_PIN2 = 74 , # [doc = "75: Port 1 Pin 3"]
PORT1_PIN3 = 75 , # [doc = "76: Port 1 Pin 4"]
PORT1_PIN4 = 76 , # [doc = "77: Port 1 Pin 5"]
PORT1_PIN5 = 77 , # [doc = "78: Port 1 Pin 6"]
PORT1_PIN6 = 78 , # [doc = "79: Port 1 Pin 7"]
PORT1_PIN7 = 79 , # [doc = "96: USART 0 Xclock"]
USART0_XCK = 96 , # [doc = "97: USART 1 Xclock"]
USART1_XCK = 97 , # [doc = "98: USART 2 Xclock"]
USART2_XCK = 98 , # [doc = "99: USART 3 Xclock"]
USART3_XCK = 99 , # [doc = "104: SPI 0 Sclock"]
SPI0_SCK = 104 , # [doc = "128: Timer/Counter A0 overflow / low byte underflow"]
TCA0_OVF_LUNF = 128 , # [doc = "129: Timer/Counter A0 high byte underflow (split mode)"]
TCA0_HUNF = 129 , # [doc = "132: Timer/Counter A0 compare 0"]
TCA0_CMP0 = 132 , # [doc = "133: Timer/Counter A0 compare 1"]
TCA0_CMP1 = 133 , # [doc = "134: Timer/Counter A0 compare 2"]
TCA0_CMP2 = 134 , # [doc = "160: Timer/Counter B0 capture"]
TCB0_CAPT = 160 , # [doc = "162: Timer/Counter B1 capture"]
TCB1_CAPT = 162 , # [doc = "164: Timer/Counter B2 capture"]
TCB2_CAPT = 164 , # [doc = "166: Timer/Counter B3 capture"]
TCB3_CAPT = 166 , } impl From < GENERATOR_A > for u8 { # [inline (always)]
fn from (variant : GENERATOR_A) -> Self { variant as _ } } impl GENERATOR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GENERATOR_A > { match self . bits { 0 => Some (GENERATOR_A :: OFF) , 1 => Some (GENERATOR_A :: UPDI) , 6 => Some (GENERATOR_A :: RTC_OVF) , 7 => Some (GENERATOR_A :: RTC_CMP) , 8 => Some (GENERATOR_A :: RTC_PIT0) , 9 => Some (GENERATOR_A :: RTC_PIT1) , 10 => Some (GENERATOR_A :: RTC_PIT2) , 11 => Some (GENERATOR_A :: RTC_PIT3) , 16 => Some (GENERATOR_A :: CCL_LUT0) , 17 => Some (GENERATOR_A :: CCL_LUT1) , 18 => Some (GENERATOR_A :: CCL_LUT2) , 19 => Some (GENERATOR_A :: CCL_LUT3) , 32 => Some (GENERATOR_A :: AC0_OUT) , 36 => Some (GENERATOR_A :: ADC0_RESRDY) , 64 => Some (GENERATOR_A :: PORT0_PIN0) , 65 => Some (GENERATOR_A :: PORT0_PIN1) , 66 => Some (GENERATOR_A :: PORT0_PIN2) , 67 => Some (GENERATOR_A :: PORT0_PIN3) , 68 => Some (GENERATOR_A :: PORT0_PIN4) , 69 => Some (GENERATOR_A :: PORT0_PIN5) , 70 => Some (GENERATOR_A :: PORT0_PIN6) , 71 => Some (GENERATOR_A :: PORT0_PIN7) , 72 => Some (GENERATOR_A :: PORT1_PIN0) , 73 => Some (GENERATOR_A :: PORT1_PIN1) , 74 => Some (GENERATOR_A :: PORT1_PIN2) , 75 => Some (GENERATOR_A :: PORT1_PIN3) , 76 => Some (GENERATOR_A :: PORT1_PIN4) , 77 => Some (GENERATOR_A :: PORT1_PIN5) , 78 => Some (GENERATOR_A :: PORT1_PIN6) , 79 => Some (GENERATOR_A :: PORT1_PIN7) , 96 => Some (GENERATOR_A :: USART0_XCK) , 97 => Some (GENERATOR_A :: USART1_XCK) , 98 => Some (GENERATOR_A :: USART2_XCK) , 99 => Some (GENERATOR_A :: USART3_XCK) , 104 => Some (GENERATOR_A :: SPI0_SCK) , 128 => Some (GENERATOR_A :: TCA0_OVF_LUNF) , 129 => Some (GENERATOR_A :: TCA0_HUNF) , 132 => Some (GENERATOR_A :: TCA0_CMP0) , 133 => Some (GENERATOR_A :: TCA0_CMP1) , 134 => Some (GENERATOR_A :: TCA0_CMP2) , 160 => Some (GENERATOR_A :: TCB0_CAPT) , 162 => Some (GENERATOR_A :: TCB1_CAPT) , 164 => Some (GENERATOR_A :: TCB2_CAPT) , 166 => Some (GENERATOR_A :: TCB3_CAPT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == GENERATOR_A :: OFF } # [doc = "Checks if the value of the field is `UPDI`"]
# [inline (always)]
pub fn is_updi (& self) -> bool { * self == GENERATOR_A :: UPDI } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == GENERATOR_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == GENERATOR_A :: RTC_CMP } # [doc = "Checks if the value of the field is `RTC_PIT0`"]
# [inline (always)]
pub fn is_rtc_pit0 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT0 } # [doc = "Checks if the value of the field is `RTC_PIT1`"]
# [inline (always)]
pub fn is_rtc_pit1 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT1 } # [doc = "Checks if the value of the field is `RTC_PIT2`"]
# [inline (always)]
pub fn is_rtc_pit2 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT2 } # [doc = "Checks if the value of the field is `RTC_PIT3`"]
# [inline (always)]
pub fn is_rtc_pit3 (& self) -> bool { * self == GENERATOR_A :: RTC_PIT3 } # [doc = "Checks if the value of the field is `CCL_LUT0`"]
# [inline (always)]
pub fn is_ccl_lut0 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT0 } # [doc = "Checks if the value of the field is `CCL_LUT1`"]
# [inline (always)]
pub fn is_ccl_lut1 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT1 } # [doc = "Checks if the value of the field is `CCL_LUT2`"]
# [inline (always)]
pub fn is_ccl_lut2 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT2 } # [doc = "Checks if the value of the field is `CCL_LUT3`"]
# [inline (always)]
pub fn is_ccl_lut3 (& self) -> bool { * self == GENERATOR_A :: CCL_LUT3 } # [doc = "Checks if the value of the field is `AC0_OUT`"]
# [inline (always)]
pub fn is_ac0_out (& self) -> bool { * self == GENERATOR_A :: AC0_OUT } # [doc = "Checks if the value of the field is `ADC0_RESRDY`"]
# [inline (always)]
pub fn is_adc0_resrdy (& self) -> bool { * self == GENERATOR_A :: ADC0_RESRDY } # [doc = "Checks if the value of the field is `PORT0_PIN0`"]
# [inline (always)]
pub fn is_port0_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN0 } # [doc = "Checks if the value of the field is `PORT0_PIN1`"]
# [inline (always)]
pub fn is_port0_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN1 } # [doc = "Checks if the value of the field is `PORT0_PIN2`"]
# [inline (always)]
pub fn is_port0_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN2 } # [doc = "Checks if the value of the field is `PORT0_PIN3`"]
# [inline (always)]
pub fn is_port0_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN3 } # [doc = "Checks if the value of the field is `PORT0_PIN4`"]
# [inline (always)]
pub fn is_port0_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN4 } # [doc = "Checks if the value of the field is `PORT0_PIN5`"]
# [inline (always)]
pub fn is_port0_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN5 } # [doc = "Checks if the value of the field is `PORT0_PIN6`"]
# [inline (always)]
pub fn is_port0_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN6 } # [doc = "Checks if the value of the field is `PORT0_PIN7`"]
# [inline (always)]
pub fn is_port0_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT0_PIN7 } # [doc = "Checks if the value of the field is `PORT1_PIN0`"]
# [inline (always)]
pub fn is_port1_pin0 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN0 } # [doc = "Checks if the value of the field is `PORT1_PIN1`"]
# [inline (always)]
pub fn is_port1_pin1 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN1 } # [doc = "Checks if the value of the field is `PORT1_PIN2`"]
# [inline (always)]
pub fn is_port1_pin2 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN2 } # [doc = "Checks if the value of the field is `PORT1_PIN3`"]
# [inline (always)]
pub fn is_port1_pin3 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN3 } # [doc = "Checks if the value of the field is `PORT1_PIN4`"]
# [inline (always)]
pub fn is_port1_pin4 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN4 } # [doc = "Checks if the value of the field is `PORT1_PIN5`"]
# [inline (always)]
pub fn is_port1_pin5 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN5 } # [doc = "Checks if the value of the field is `PORT1_PIN6`"]
# [inline (always)]
pub fn is_port1_pin6 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN6 } # [doc = "Checks if the value of the field is `PORT1_PIN7`"]
# [inline (always)]
pub fn is_port1_pin7 (& self) -> bool { * self == GENERATOR_A :: PORT1_PIN7 } # [doc = "Checks if the value of the field is `USART0_XCK`"]
# [inline (always)]
pub fn is_usart0_xck (& self) -> bool { * self == GENERATOR_A :: USART0_XCK } # [doc = "Checks if the value of the field is `USART1_XCK`"]
# [inline (always)]
pub fn is_usart1_xck (& self) -> bool { * self == GENERATOR_A :: USART1_XCK } # [doc = "Checks if the value of the field is `USART2_XCK`"]
# [inline (always)]
pub fn is_usart2_xck (& self) -> bool { * self == GENERATOR_A :: USART2_XCK } # [doc = "Checks if the value of the field is `USART3_XCK`"]
# [inline (always)]
pub fn is_usart3_xck (& self) -> bool { * self == GENERATOR_A :: USART3_XCK } # [doc = "Checks if the value of the field is `SPI0_SCK`"]
# [inline (always)]
pub fn is_spi0_sck (& self) -> bool { * self == GENERATOR_A :: SPI0_SCK } # [doc = "Checks if the value of the field is `TCA0_OVF_LUNF`"]
# [inline (always)]
pub fn is_tca0_ovf_lunf (& self) -> bool { * self == GENERATOR_A :: TCA0_OVF_LUNF } # [doc = "Checks if the value of the field is `TCA0_HUNF`"]
# [inline (always)]
pub fn is_tca0_hunf (& self) -> bool { * self == GENERATOR_A :: TCA0_HUNF } # [doc = "Checks if the value of the field is `TCA0_CMP0`"]
# [inline (always)]
pub fn is_tca0_cmp0 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP0 } # [doc = "Checks if the value of the field is `TCA0_CMP1`"]
# [inline (always)]
pub fn is_tca0_cmp1 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP1 } # [doc = "Checks if the value of the field is `TCA0_CMP2`"]
# [inline (always)]
pub fn is_tca0_cmp2 (& self) -> bool { * self == GENERATOR_A :: TCA0_CMP2 } # [doc = "Checks if the value of the field is `TCB0_CAPT`"]
# [inline (always)]
pub fn is_tcb0_capt (& self) -> bool { * self == GENERATOR_A :: TCB0_CAPT } # [doc = "Checks if the value of the field is `TCB1_CAPT`"]
# [inline (always)]
pub fn is_tcb1_capt (& self) -> bool { * self == GENERATOR_A :: TCB1_CAPT } # [doc = "Checks if the value of the field is `TCB2_CAPT`"]
# [inline (always)]
pub fn is_tcb2_capt (& self) -> bool { * self == GENERATOR_A :: TCB2_CAPT } # [doc = "Checks if the value of the field is `TCB3_CAPT`"]
# [inline (always)]
pub fn is_tcb3_capt (& self) -> bool { * self == GENERATOR_A :: TCB3_CAPT } } # [doc = "Field `GENERATOR` writer - Generator selector"]
pub type GENERATOR_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CHANNEL7_SPEC , u8 , GENERATOR_A , 8 , O > ; impl < 'a , const O : u8 > GENERATOR_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (GENERATOR_A :: OFF) } # [doc = "Unified Program and Debug Interface"]
# [inline (always)]
pub fn updi (self) -> & 'a mut W { self . variant (GENERATOR_A :: UPDI) } # [doc = "Real Time Counter overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_OVF) } # [doc = "Real Time Counter compare"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_CMP) } # [doc = "Periodic Interrupt Timer output 0"]
# [inline (always)]
pub fn rtc_pit0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT0) } # [doc = "Periodic Interrupt Timer output 1"]
# [inline (always)]
pub fn rtc_pit1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT1) } # [doc = "Periodic Interrupt Timer output 2"]
# [inline (always)]
pub fn rtc_pit2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT2) } # [doc = "Periodic Interrupt Timer output 3"]
# [inline (always)]
pub fn rtc_pit3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: RTC_PIT3) } # [doc = "Configurable Custom Logic LUT0"]
# [inline (always)]
pub fn ccl_lut0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT0) } # [doc = "Configurable Custom Logic LUT1"]
# [inline (always)]
pub fn ccl_lut1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT1) } # [doc = "Configurable Custom Logic LUT2"]
# [inline (always)]
pub fn ccl_lut2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT2) } # [doc = "Configurable Custom Logic LUT3"]
# [inline (always)]
pub fn ccl_lut3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: CCL_LUT3) } # [doc = "Analog Comparator 0 out"]
# [inline (always)]
pub fn ac0_out (self) -> & 'a mut W { self . variant (GENERATOR_A :: AC0_OUT) } # [doc = "ADC 0 Result Ready Event"]
# [inline (always)]
pub fn adc0_resrdy (self) -> & 'a mut W { self . variant (GENERATOR_A :: ADC0_RESRDY) } # [doc = "Port 0 Pin 0"]
# [inline (always)]
pub fn port0_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN0) } # [doc = "Port 0 Pin 1"]
# [inline (always)]
pub fn port0_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN1) } # [doc = "Port 0 Pin 2"]
# [inline (always)]
pub fn port0_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN2) } # [doc = "Port 0 Pin 3"]
# [inline (always)]
pub fn port0_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN3) } # [doc = "Port 0 Pin 4"]
# [inline (always)]
pub fn port0_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN4) } # [doc = "Port 0 Pin 5"]
# [inline (always)]
pub fn port0_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN5) } # [doc = "Port 0 Pin 6"]
# [inline (always)]
pub fn port0_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN6) } # [doc = "Port 0 Pin 7"]
# [inline (always)]
pub fn port0_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT0_PIN7) } # [doc = "Port 1 Pin 0"]
# [inline (always)]
pub fn port1_pin0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN0) } # [doc = "Port 1 Pin 1"]
# [inline (always)]
pub fn port1_pin1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN1) } # [doc = "Port 1 Pin 2"]
# [inline (always)]
pub fn port1_pin2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN2) } # [doc = "Port 1 Pin 3"]
# [inline (always)]
pub fn port1_pin3 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN3) } # [doc = "Port 1 Pin 4"]
# [inline (always)]
pub fn port1_pin4 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN4) } # [doc = "Port 1 Pin 5"]
# [inline (always)]
pub fn port1_pin5 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN5) } # [doc = "Port 1 Pin 6"]
# [inline (always)]
pub fn port1_pin6 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN6) } # [doc = "Port 1 Pin 7"]
# [inline (always)]
pub fn port1_pin7 (self) -> & 'a mut W { self . variant (GENERATOR_A :: PORT1_PIN7) } # [doc = "USART 0 Xclock"]
# [inline (always)]
pub fn usart0_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART0_XCK) } # [doc = "USART 1 Xclock"]
# [inline (always)]
pub fn usart1_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART1_XCK) } # [doc = "USART 2 Xclock"]
# [inline (always)]
pub fn usart2_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART2_XCK) } # [doc = "USART 3 Xclock"]
# [inline (always)]
pub fn usart3_xck (self) -> & 'a mut W { self . variant (GENERATOR_A :: USART3_XCK) } # [doc = "SPI 0 Sclock"]
# [inline (always)]
pub fn spi0_sck (self) -> & 'a mut W { self . variant (GENERATOR_A :: SPI0_SCK) } # [doc = "Timer/Counter A0 overflow / low byte underflow"]
# [inline (always)]
pub fn tca0_ovf_lunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_OVF_LUNF) } # [doc = "Timer/Counter A0 high byte underflow (split mode)"]
# [inline (always)]
pub fn tca0_hunf (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_HUNF) } # [doc = "Timer/Counter A0 compare 0"]
# [inline (always)]
pub fn tca0_cmp0 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP0) } # [doc = "Timer/Counter A0 compare 1"]
# [inline (always)]
pub fn tca0_cmp1 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP1) } # [doc = "Timer/Counter A0 compare 2"]
# [inline (always)]
pub fn tca0_cmp2 (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCA0_CMP2) } # [doc = "Timer/Counter B0 capture"]
# [inline (always)]
pub fn tcb0_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB0_CAPT) } # [doc = "Timer/Counter B1 capture"]
# [inline (always)]
pub fn tcb1_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB1_CAPT) } # [doc = "Timer/Counter B2 capture"]
# [inline (always)]
pub fn tcb2_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB2_CAPT) } # [doc = "Timer/Counter B3 capture"]
# [inline (always)]
pub fn tcb3_capt (self) -> & 'a mut W { self . variant (GENERATOR_A :: TCB3_CAPT) } } impl R { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
pub fn generator (& self) -> GENERATOR_R { GENERATOR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Generator selector"]
# [inline (always)]
# [must_use]
pub fn generator (& mut self) -> GENERATOR_W < 0 > { GENERATOR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Multiplexer Channel 7\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel7](index.html) module"]
pub struct CHANNEL7_SPEC ; impl crate :: RegisterSpec for CHANNEL7_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [channel7::R](R) reader structure"]
impl crate :: Readable for CHANNEL7_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel7::W](W) writer structure"]
impl crate :: Writable for CHANNEL7_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CHANNEL7 to value 0"]
impl crate :: Resettable for CHANNEL7_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STROBE (w) register accessor: an alias for `Reg<STROBE_SPEC>`"]
pub type STROBE = crate :: Reg < strobe :: STROBE_SPEC > ; # [doc = "Channel Strobe"]
pub mod strobe { # [doc = "Register `STROBE` writer"]
pub struct W (crate :: W < STROBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STROBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STROBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STROBE_SPEC >) -> Self { W (writer) } } # [doc = "Software event on channels\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum STROBE0_AW { # [doc = "1: No Description."]
EV_STROBE_CH0 = 1 , # [doc = "2: No Description."]
EV_STROBE_CH1 = 2 , # [doc = "4: No Description."]
EV_STROBE_CH2 = 4 , # [doc = "8: No Description."]
EV_STROBE_CH3 = 8 , # [doc = "16: No Description."]
EV_STROBE_CH4 = 16 , # [doc = "32: No Description."]
EV_STROBE_CH5 = 32 , # [doc = "64: No Description."]
EV_STROBE_CH6 = 64 , # [doc = "128: No Description."]
EV_STROBE_CH7 = 128 , } impl From < STROBE0_AW > for u8 { # [inline (always)]
fn from (variant : STROBE0_AW) -> Self { variant as _ } } # [doc = "Field `STROBE0` writer - Software event on channels"]
pub type STROBE0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , STROBE_SPEC , u8 , STROBE0_AW , 8 , O > ; impl < 'a , const O : u8 > STROBE0_W < 'a , O > { # [doc = "No Description."]
# [inline (always)]
pub fn ev_strobe_ch0 (self) -> & 'a mut W { self . variant (STROBE0_AW :: EV_STROBE_CH0) } # [doc = "No Description."]
# [inline (always)]
pub fn ev_strobe_ch1 (self) -> & 'a mut W { self . variant (STROBE0_AW :: EV_STROBE_CH1) } # [doc = "No Description."]
# [inline (always)]
pub fn ev_strobe_ch2 (self) -> & 'a mut W { self . variant (STROBE0_AW :: EV_STROBE_CH2) } # [doc = "No Description."]
# [inline (always)]
pub fn ev_strobe_ch3 (self) -> & 'a mut W { self . variant (STROBE0_AW :: EV_STROBE_CH3) } # [doc = "No Description."]
# [inline (always)]
pub fn ev_strobe_ch4 (self) -> & 'a mut W { self . variant (STROBE0_AW :: EV_STROBE_CH4) } # [doc = "No Description."]
# [inline (always)]
pub fn ev_strobe_ch5 (self) -> & 'a mut W { self . variant (STROBE0_AW :: EV_STROBE_CH5) } # [doc = "No Description."]
# [inline (always)]
pub fn ev_strobe_ch6 (self) -> & 'a mut W { self . variant (STROBE0_AW :: EV_STROBE_CH6) } # [doc = "No Description."]
# [inline (always)]
pub fn ev_strobe_ch7 (self) -> & 'a mut W { self . variant (STROBE0_AW :: EV_STROBE_CH7) } } impl W { # [doc = "Bits 0:7 - Software event on channels"]
# [inline (always)]
# [must_use]
pub fn strobe0 (& mut self) -> STROBE0_W < 0 > { STROBE0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel Strobe\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [strobe](index.html) module"]
pub struct STROBE_SPEC ; impl crate :: RegisterSpec for STROBE_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [strobe::W](W) writer structure"]
impl crate :: Writable for STROBE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STROBE to value 0"]
impl crate :: Resettable for STROBE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERADC0 (rw) register accessor: an alias for `Reg<USERADC0_SPEC>`"]
pub type USERADC0 = crate :: Reg < useradc0 :: USERADC0_SPEC > ; # [doc = "User ADC0"]
pub mod useradc0 { # [doc = "Register `USERADC0` reader"]
pub struct R (crate :: R < USERADC0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERADC0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERADC0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERADC0_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERADC0` writer"]
pub struct W (crate :: W < USERADC0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERADC0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERADC0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERADC0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERADC0_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User ADC0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [useradc0](index.html) module"]
pub struct USERADC0_SPEC ; impl crate :: RegisterSpec for USERADC0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [useradc0::R](R) reader structure"]
impl crate :: Readable for USERADC0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [useradc0::W](W) writer structure"]
impl crate :: Writable for USERADC0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERADC0 to value 0"]
impl crate :: Resettable for USERADC0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERCCLLUT0A (rw) register accessor: an alias for `Reg<USERCCLLUT0A_SPEC>`"]
pub type USERCCLLUT0A = crate :: Reg < userccllut0a :: USERCCLLUT0A_SPEC > ; # [doc = "User CCL LUT0 Event A"]
pub mod userccllut0a { # [doc = "Register `USERCCLLUT0A` reader"]
pub struct R (crate :: R < USERCCLLUT0A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERCCLLUT0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERCCLLUT0A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERCCLLUT0A_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERCCLLUT0A` writer"]
pub struct W (crate :: W < USERCCLLUT0A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERCCLLUT0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERCCLLUT0A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERCCLLUT0A_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERCCLLUT0A_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User CCL LUT0 Event A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userccllut0a](index.html) module"]
pub struct USERCCLLUT0A_SPEC ; impl crate :: RegisterSpec for USERCCLLUT0A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userccllut0a::R](R) reader structure"]
impl crate :: Readable for USERCCLLUT0A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userccllut0a::W](W) writer structure"]
impl crate :: Writable for USERCCLLUT0A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERCCLLUT0A to value 0"]
impl crate :: Resettable for USERCCLLUT0A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERCCLLUT0B (rw) register accessor: an alias for `Reg<USERCCLLUT0B_SPEC>`"]
pub type USERCCLLUT0B = crate :: Reg < userccllut0b :: USERCCLLUT0B_SPEC > ; # [doc = "User CCL LUT0 Event B"]
pub mod userccllut0b { # [doc = "Register `USERCCLLUT0B` reader"]
pub struct R (crate :: R < USERCCLLUT0B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERCCLLUT0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERCCLLUT0B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERCCLLUT0B_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERCCLLUT0B` writer"]
pub struct W (crate :: W < USERCCLLUT0B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERCCLLUT0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERCCLLUT0B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERCCLLUT0B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERCCLLUT0B_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User CCL LUT0 Event B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userccllut0b](index.html) module"]
pub struct USERCCLLUT0B_SPEC ; impl crate :: RegisterSpec for USERCCLLUT0B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userccllut0b::R](R) reader structure"]
impl crate :: Readable for USERCCLLUT0B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userccllut0b::W](W) writer structure"]
impl crate :: Writable for USERCCLLUT0B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERCCLLUT0B to value 0"]
impl crate :: Resettable for USERCCLLUT0B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERCCLLUT1A (rw) register accessor: an alias for `Reg<USERCCLLUT1A_SPEC>`"]
pub type USERCCLLUT1A = crate :: Reg < userccllut1a :: USERCCLLUT1A_SPEC > ; # [doc = "User CCL LUT1 Event A"]
pub mod userccllut1a { # [doc = "Register `USERCCLLUT1A` reader"]
pub struct R (crate :: R < USERCCLLUT1A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERCCLLUT1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERCCLLUT1A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERCCLLUT1A_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERCCLLUT1A` writer"]
pub struct W (crate :: W < USERCCLLUT1A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERCCLLUT1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERCCLLUT1A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERCCLLUT1A_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERCCLLUT1A_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User CCL LUT1 Event A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userccllut1a](index.html) module"]
pub struct USERCCLLUT1A_SPEC ; impl crate :: RegisterSpec for USERCCLLUT1A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userccllut1a::R](R) reader structure"]
impl crate :: Readable for USERCCLLUT1A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userccllut1a::W](W) writer structure"]
impl crate :: Writable for USERCCLLUT1A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERCCLLUT1A to value 0"]
impl crate :: Resettable for USERCCLLUT1A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERCCLLUT1B (rw) register accessor: an alias for `Reg<USERCCLLUT1B_SPEC>`"]
pub type USERCCLLUT1B = crate :: Reg < userccllut1b :: USERCCLLUT1B_SPEC > ; # [doc = "User CCL LUT1 Event B"]
pub mod userccllut1b { # [doc = "Register `USERCCLLUT1B` reader"]
pub struct R (crate :: R < USERCCLLUT1B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERCCLLUT1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERCCLLUT1B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERCCLLUT1B_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERCCLLUT1B` writer"]
pub struct W (crate :: W < USERCCLLUT1B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERCCLLUT1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERCCLLUT1B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERCCLLUT1B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERCCLLUT1B_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User CCL LUT1 Event B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userccllut1b](index.html) module"]
pub struct USERCCLLUT1B_SPEC ; impl crate :: RegisterSpec for USERCCLLUT1B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userccllut1b::R](R) reader structure"]
impl crate :: Readable for USERCCLLUT1B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userccllut1b::W](W) writer structure"]
impl crate :: Writable for USERCCLLUT1B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERCCLLUT1B to value 0"]
impl crate :: Resettable for USERCCLLUT1B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERCCLLUT2A (rw) register accessor: an alias for `Reg<USERCCLLUT2A_SPEC>`"]
pub type USERCCLLUT2A = crate :: Reg < userccllut2a :: USERCCLLUT2A_SPEC > ; # [doc = "User CCL LUT2 Event A"]
pub mod userccllut2a { # [doc = "Register `USERCCLLUT2A` reader"]
pub struct R (crate :: R < USERCCLLUT2A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERCCLLUT2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERCCLLUT2A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERCCLLUT2A_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERCCLLUT2A` writer"]
pub struct W (crate :: W < USERCCLLUT2A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERCCLLUT2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERCCLLUT2A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERCCLLUT2A_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERCCLLUT2A_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User CCL LUT2 Event A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userccllut2a](index.html) module"]
pub struct USERCCLLUT2A_SPEC ; impl crate :: RegisterSpec for USERCCLLUT2A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userccllut2a::R](R) reader structure"]
impl crate :: Readable for USERCCLLUT2A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userccllut2a::W](W) writer structure"]
impl crate :: Writable for USERCCLLUT2A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERCCLLUT2A to value 0"]
impl crate :: Resettable for USERCCLLUT2A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERCCLLUT2B (rw) register accessor: an alias for `Reg<USERCCLLUT2B_SPEC>`"]
pub type USERCCLLUT2B = crate :: Reg < userccllut2b :: USERCCLLUT2B_SPEC > ; # [doc = "User CCL LUT2 Event B"]
pub mod userccllut2b { # [doc = "Register `USERCCLLUT2B` reader"]
pub struct R (crate :: R < USERCCLLUT2B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERCCLLUT2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERCCLLUT2B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERCCLLUT2B_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERCCLLUT2B` writer"]
pub struct W (crate :: W < USERCCLLUT2B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERCCLLUT2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERCCLLUT2B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERCCLLUT2B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERCCLLUT2B_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User CCL LUT2 Event B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userccllut2b](index.html) module"]
pub struct USERCCLLUT2B_SPEC ; impl crate :: RegisterSpec for USERCCLLUT2B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userccllut2b::R](R) reader structure"]
impl crate :: Readable for USERCCLLUT2B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userccllut2b::W](W) writer structure"]
impl crate :: Writable for USERCCLLUT2B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERCCLLUT2B to value 0"]
impl crate :: Resettable for USERCCLLUT2B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERCCLLUT3A (rw) register accessor: an alias for `Reg<USERCCLLUT3A_SPEC>`"]
pub type USERCCLLUT3A = crate :: Reg < userccllut3a :: USERCCLLUT3A_SPEC > ; # [doc = "User CCL LUT3 Event A"]
pub mod userccllut3a { # [doc = "Register `USERCCLLUT3A` reader"]
pub struct R (crate :: R < USERCCLLUT3A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERCCLLUT3A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERCCLLUT3A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERCCLLUT3A_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERCCLLUT3A` writer"]
pub struct W (crate :: W < USERCCLLUT3A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERCCLLUT3A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERCCLLUT3A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERCCLLUT3A_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERCCLLUT3A_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User CCL LUT3 Event A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userccllut3a](index.html) module"]
pub struct USERCCLLUT3A_SPEC ; impl crate :: RegisterSpec for USERCCLLUT3A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userccllut3a::R](R) reader structure"]
impl crate :: Readable for USERCCLLUT3A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userccllut3a::W](W) writer structure"]
impl crate :: Writable for USERCCLLUT3A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERCCLLUT3A to value 0"]
impl crate :: Resettable for USERCCLLUT3A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERCCLLUT3B (rw) register accessor: an alias for `Reg<USERCCLLUT3B_SPEC>`"]
pub type USERCCLLUT3B = crate :: Reg < userccllut3b :: USERCCLLUT3B_SPEC > ; # [doc = "User CCL LUT3 Event B"]
pub mod userccllut3b { # [doc = "Register `USERCCLLUT3B` reader"]
pub struct R (crate :: R < USERCCLLUT3B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERCCLLUT3B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERCCLLUT3B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERCCLLUT3B_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERCCLLUT3B` writer"]
pub struct W (crate :: W < USERCCLLUT3B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERCCLLUT3B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERCCLLUT3B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERCCLLUT3B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERCCLLUT3B_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User CCL LUT3 Event B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userccllut3b](index.html) module"]
pub struct USERCCLLUT3B_SPEC ; impl crate :: RegisterSpec for USERCCLLUT3B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userccllut3b::R](R) reader structure"]
impl crate :: Readable for USERCCLLUT3B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userccllut3b::W](W) writer structure"]
impl crate :: Writable for USERCCLLUT3B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERCCLLUT3B to value 0"]
impl crate :: Resettable for USERCCLLUT3B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USEREVOUTA (rw) register accessor: an alias for `Reg<USEREVOUTA_SPEC>`"]
pub type USEREVOUTA = crate :: Reg < userevouta :: USEREVOUTA_SPEC > ; # [doc = "User EVOUT Port A"]
pub mod userevouta { # [doc = "Register `USEREVOUTA` reader"]
pub struct R (crate :: R < USEREVOUTA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USEREVOUTA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USEREVOUTA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USEREVOUTA_SPEC >) -> Self { R (reader) } } # [doc = "Register `USEREVOUTA` writer"]
pub struct W (crate :: W < USEREVOUTA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USEREVOUTA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USEREVOUTA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USEREVOUTA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USEREVOUTA_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User EVOUT Port A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userevouta](index.html) module"]
pub struct USEREVOUTA_SPEC ; impl crate :: RegisterSpec for USEREVOUTA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userevouta::R](R) reader structure"]
impl crate :: Readable for USEREVOUTA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userevouta::W](W) writer structure"]
impl crate :: Writable for USEREVOUTA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USEREVOUTA to value 0"]
impl crate :: Resettable for USEREVOUTA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USEREVOUTB (rw) register accessor: an alias for `Reg<USEREVOUTB_SPEC>`"]
pub type USEREVOUTB = crate :: Reg < userevoutb :: USEREVOUTB_SPEC > ; # [doc = "User EVOUT Port B"]
pub mod userevoutb { # [doc = "Register `USEREVOUTB` reader"]
pub struct R (crate :: R < USEREVOUTB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USEREVOUTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USEREVOUTB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USEREVOUTB_SPEC >) -> Self { R (reader) } } # [doc = "Register `USEREVOUTB` writer"]
pub struct W (crate :: W < USEREVOUTB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USEREVOUTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USEREVOUTB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USEREVOUTB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USEREVOUTB_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User EVOUT Port B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userevoutb](index.html) module"]
pub struct USEREVOUTB_SPEC ; impl crate :: RegisterSpec for USEREVOUTB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userevoutb::R](R) reader structure"]
impl crate :: Readable for USEREVOUTB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userevoutb::W](W) writer structure"]
impl crate :: Writable for USEREVOUTB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USEREVOUTB to value 0"]
impl crate :: Resettable for USEREVOUTB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USEREVOUTC (rw) register accessor: an alias for `Reg<USEREVOUTC_SPEC>`"]
pub type USEREVOUTC = crate :: Reg < userevoutc :: USEREVOUTC_SPEC > ; # [doc = "User EVOUT Port C"]
pub mod userevoutc { # [doc = "Register `USEREVOUTC` reader"]
pub struct R (crate :: R < USEREVOUTC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USEREVOUTC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USEREVOUTC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USEREVOUTC_SPEC >) -> Self { R (reader) } } # [doc = "Register `USEREVOUTC` writer"]
pub struct W (crate :: W < USEREVOUTC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USEREVOUTC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USEREVOUTC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USEREVOUTC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USEREVOUTC_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User EVOUT Port C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userevoutc](index.html) module"]
pub struct USEREVOUTC_SPEC ; impl crate :: RegisterSpec for USEREVOUTC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userevoutc::R](R) reader structure"]
impl crate :: Readable for USEREVOUTC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userevoutc::W](W) writer structure"]
impl crate :: Writable for USEREVOUTC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USEREVOUTC to value 0"]
impl crate :: Resettable for USEREVOUTC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USEREVOUTD (rw) register accessor: an alias for `Reg<USEREVOUTD_SPEC>`"]
pub type USEREVOUTD = crate :: Reg < userevoutd :: USEREVOUTD_SPEC > ; # [doc = "User EVOUT Port D"]
pub mod userevoutd { # [doc = "Register `USEREVOUTD` reader"]
pub struct R (crate :: R < USEREVOUTD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USEREVOUTD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USEREVOUTD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USEREVOUTD_SPEC >) -> Self { R (reader) } } # [doc = "Register `USEREVOUTD` writer"]
pub struct W (crate :: W < USEREVOUTD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USEREVOUTD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USEREVOUTD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USEREVOUTD_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USEREVOUTD_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User EVOUT Port D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userevoutd](index.html) module"]
pub struct USEREVOUTD_SPEC ; impl crate :: RegisterSpec for USEREVOUTD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userevoutd::R](R) reader structure"]
impl crate :: Readable for USEREVOUTD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userevoutd::W](W) writer structure"]
impl crate :: Writable for USEREVOUTD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USEREVOUTD to value 0"]
impl crate :: Resettable for USEREVOUTD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USEREVOUTE (rw) register accessor: an alias for `Reg<USEREVOUTE_SPEC>`"]
pub type USEREVOUTE = crate :: Reg < userevoute :: USEREVOUTE_SPEC > ; # [doc = "User EVOUT Port E"]
pub mod userevoute { # [doc = "Register `USEREVOUTE` reader"]
pub struct R (crate :: R < USEREVOUTE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USEREVOUTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USEREVOUTE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USEREVOUTE_SPEC >) -> Self { R (reader) } } # [doc = "Register `USEREVOUTE` writer"]
pub struct W (crate :: W < USEREVOUTE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USEREVOUTE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USEREVOUTE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USEREVOUTE_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USEREVOUTE_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User EVOUT Port E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userevoute](index.html) module"]
pub struct USEREVOUTE_SPEC ; impl crate :: RegisterSpec for USEREVOUTE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userevoute::R](R) reader structure"]
impl crate :: Readable for USEREVOUTE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userevoute::W](W) writer structure"]
impl crate :: Writable for USEREVOUTE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USEREVOUTE to value 0"]
impl crate :: Resettable for USEREVOUTE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USEREVOUTF (rw) register accessor: an alias for `Reg<USEREVOUTF_SPEC>`"]
pub type USEREVOUTF = crate :: Reg < userevoutf :: USEREVOUTF_SPEC > ; # [doc = "User EVOUT Port F"]
pub mod userevoutf { # [doc = "Register `USEREVOUTF` reader"]
pub struct R (crate :: R < USEREVOUTF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USEREVOUTF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USEREVOUTF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USEREVOUTF_SPEC >) -> Self { R (reader) } } # [doc = "Register `USEREVOUTF` writer"]
pub struct W (crate :: W < USEREVOUTF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USEREVOUTF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USEREVOUTF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USEREVOUTF_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USEREVOUTF_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User EVOUT Port F\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userevoutf](index.html) module"]
pub struct USEREVOUTF_SPEC ; impl crate :: RegisterSpec for USEREVOUTF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userevoutf::R](R) reader structure"]
impl crate :: Readable for USEREVOUTF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userevoutf::W](W) writer structure"]
impl crate :: Writable for USEREVOUTF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USEREVOUTF to value 0"]
impl crate :: Resettable for USEREVOUTF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERTCA0 (rw) register accessor: an alias for `Reg<USERTCA0_SPEC>`"]
pub type USERTCA0 = crate :: Reg < usertca0 :: USERTCA0_SPEC > ; # [doc = "User TCA0"]
pub mod usertca0 { # [doc = "Register `USERTCA0` reader"]
pub struct R (crate :: R < USERTCA0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERTCA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERTCA0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERTCA0_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERTCA0` writer"]
pub struct W (crate :: W < USERTCA0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERTCA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERTCA0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERTCA0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERTCA0_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User TCA0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [usertca0](index.html) module"]
pub struct USERTCA0_SPEC ; impl crate :: RegisterSpec for USERTCA0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [usertca0::R](R) reader structure"]
impl crate :: Readable for USERTCA0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [usertca0::W](W) writer structure"]
impl crate :: Writable for USERTCA0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERTCA0 to value 0"]
impl crate :: Resettable for USERTCA0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERTCB0 (rw) register accessor: an alias for `Reg<USERTCB0_SPEC>`"]
pub type USERTCB0 = crate :: Reg < usertcb0 :: USERTCB0_SPEC > ; # [doc = "User TCB0"]
pub mod usertcb0 { # [doc = "Register `USERTCB0` reader"]
pub struct R (crate :: R < USERTCB0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERTCB0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERTCB0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERTCB0_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERTCB0` writer"]
pub struct W (crate :: W < USERTCB0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERTCB0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERTCB0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERTCB0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERTCB0_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User TCB0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [usertcb0](index.html) module"]
pub struct USERTCB0_SPEC ; impl crate :: RegisterSpec for USERTCB0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [usertcb0::R](R) reader structure"]
impl crate :: Readable for USERTCB0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [usertcb0::W](W) writer structure"]
impl crate :: Writable for USERTCB0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERTCB0 to value 0"]
impl crate :: Resettable for USERTCB0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERTCB1 (rw) register accessor: an alias for `Reg<USERTCB1_SPEC>`"]
pub type USERTCB1 = crate :: Reg < usertcb1 :: USERTCB1_SPEC > ; # [doc = "User TCB1"]
pub mod usertcb1 { # [doc = "Register `USERTCB1` reader"]
pub struct R (crate :: R < USERTCB1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERTCB1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERTCB1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERTCB1_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERTCB1` writer"]
pub struct W (crate :: W < USERTCB1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERTCB1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERTCB1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERTCB1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERTCB1_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User TCB1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [usertcb1](index.html) module"]
pub struct USERTCB1_SPEC ; impl crate :: RegisterSpec for USERTCB1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [usertcb1::R](R) reader structure"]
impl crate :: Readable for USERTCB1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [usertcb1::W](W) writer structure"]
impl crate :: Writable for USERTCB1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERTCB1 to value 0"]
impl crate :: Resettable for USERTCB1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERTCB2 (rw) register accessor: an alias for `Reg<USERTCB2_SPEC>`"]
pub type USERTCB2 = crate :: Reg < usertcb2 :: USERTCB2_SPEC > ; # [doc = "User TCB2"]
pub mod usertcb2 { # [doc = "Register `USERTCB2` reader"]
pub struct R (crate :: R < USERTCB2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERTCB2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERTCB2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERTCB2_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERTCB2` writer"]
pub struct W (crate :: W < USERTCB2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERTCB2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERTCB2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERTCB2_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERTCB2_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User TCB2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [usertcb2](index.html) module"]
pub struct USERTCB2_SPEC ; impl crate :: RegisterSpec for USERTCB2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [usertcb2::R](R) reader structure"]
impl crate :: Readable for USERTCB2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [usertcb2::W](W) writer structure"]
impl crate :: Writable for USERTCB2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERTCB2 to value 0"]
impl crate :: Resettable for USERTCB2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERTCB3 (rw) register accessor: an alias for `Reg<USERTCB3_SPEC>`"]
pub type USERTCB3 = crate :: Reg < usertcb3 :: USERTCB3_SPEC > ; # [doc = "User TCB3"]
pub mod usertcb3 { # [doc = "Register `USERTCB3` reader"]
pub struct R (crate :: R < USERTCB3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERTCB3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERTCB3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERTCB3_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERTCB3` writer"]
pub struct W (crate :: W < USERTCB3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERTCB3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERTCB3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERTCB3_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERTCB3_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User TCB3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [usertcb3](index.html) module"]
pub struct USERTCB3_SPEC ; impl crate :: RegisterSpec for USERTCB3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [usertcb3::R](R) reader structure"]
impl crate :: Readable for USERTCB3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [usertcb3::W](W) writer structure"]
impl crate :: Writable for USERTCB3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERTCB3 to value 0"]
impl crate :: Resettable for USERTCB3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERUSART0 (rw) register accessor: an alias for `Reg<USERUSART0_SPEC>`"]
pub type USERUSART0 = crate :: Reg < userusart0 :: USERUSART0_SPEC > ; # [doc = "User USART0"]
pub mod userusart0 { # [doc = "Register `USERUSART0` reader"]
pub struct R (crate :: R < USERUSART0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERUSART0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERUSART0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERUSART0_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERUSART0` writer"]
pub struct W (crate :: W < USERUSART0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERUSART0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERUSART0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERUSART0_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERUSART0_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User USART0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userusart0](index.html) module"]
pub struct USERUSART0_SPEC ; impl crate :: RegisterSpec for USERUSART0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userusart0::R](R) reader structure"]
impl crate :: Readable for USERUSART0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userusart0::W](W) writer structure"]
impl crate :: Writable for USERUSART0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERUSART0 to value 0"]
impl crate :: Resettable for USERUSART0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERUSART1 (rw) register accessor: an alias for `Reg<USERUSART1_SPEC>`"]
pub type USERUSART1 = crate :: Reg < userusart1 :: USERUSART1_SPEC > ; # [doc = "User USART1"]
pub mod userusart1 { # [doc = "Register `USERUSART1` reader"]
pub struct R (crate :: R < USERUSART1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERUSART1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERUSART1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERUSART1_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERUSART1` writer"]
pub struct W (crate :: W < USERUSART1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERUSART1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERUSART1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERUSART1_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERUSART1_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User USART1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userusart1](index.html) module"]
pub struct USERUSART1_SPEC ; impl crate :: RegisterSpec for USERUSART1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userusart1::R](R) reader structure"]
impl crate :: Readable for USERUSART1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userusart1::W](W) writer structure"]
impl crate :: Writable for USERUSART1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERUSART1 to value 0"]
impl crate :: Resettable for USERUSART1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERUSART2 (rw) register accessor: an alias for `Reg<USERUSART2_SPEC>`"]
pub type USERUSART2 = crate :: Reg < userusart2 :: USERUSART2_SPEC > ; # [doc = "User USART2"]
pub mod userusart2 { # [doc = "Register `USERUSART2` reader"]
pub struct R (crate :: R < USERUSART2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERUSART2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERUSART2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERUSART2_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERUSART2` writer"]
pub struct W (crate :: W < USERUSART2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERUSART2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERUSART2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERUSART2_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERUSART2_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User USART2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userusart2](index.html) module"]
pub struct USERUSART2_SPEC ; impl crate :: RegisterSpec for USERUSART2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userusart2::R](R) reader structure"]
impl crate :: Readable for USERUSART2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userusart2::W](W) writer structure"]
impl crate :: Writable for USERUSART2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERUSART2 to value 0"]
impl crate :: Resettable for USERUSART2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERUSART3 (rw) register accessor: an alias for `Reg<USERUSART3_SPEC>`"]
pub type USERUSART3 = crate :: Reg < userusart3 :: USERUSART3_SPEC > ; # [doc = "User USART3"]
pub mod userusart3 { # [doc = "Register `USERUSART3` reader"]
pub struct R (crate :: R < USERUSART3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERUSART3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERUSART3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERUSART3_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERUSART3` writer"]
pub struct W (crate :: W < USERUSART3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERUSART3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERUSART3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERUSART3_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel selector"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; # [doc = "Channel selector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: Connect user to event channel 0"]
CHANNEL0 = 1 , # [doc = "2: Connect user to event channel 1"]
CHANNEL1 = 2 , # [doc = "3: Connect user to event channel 2"]
CHANNEL2 = 3 , # [doc = "4: Connect user to event channel 3"]
CHANNEL3 = 4 , # [doc = "5: Connect user to event channel 4"]
CHANNEL4 = 5 , # [doc = "6: Connect user to event channel 5"]
CHANNEL5 = 6 , # [doc = "7: Connect user to event channel 6"]
CHANNEL6 = 7 , # [doc = "8: Connect user to event channel 7"]
CHANNEL7 = 8 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: OFF) , 1 => Some (CHANNEL_A :: CHANNEL0) , 2 => Some (CHANNEL_A :: CHANNEL1) , 3 => Some (CHANNEL_A :: CHANNEL2) , 4 => Some (CHANNEL_A :: CHANNEL3) , 5 => Some (CHANNEL_A :: CHANNEL4) , 6 => Some (CHANNEL_A :: CHANNEL5) , 7 => Some (CHANNEL_A :: CHANNEL6) , 8 => Some (CHANNEL_A :: CHANNEL7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHANNEL_A :: OFF } # [doc = "Checks if the value of the field is `CHANNEL0`"]
# [inline (always)]
pub fn is_channel0 (& self) -> bool { * self == CHANNEL_A :: CHANNEL0 } # [doc = "Checks if the value of the field is `CHANNEL1`"]
# [inline (always)]
pub fn is_channel1 (& self) -> bool { * self == CHANNEL_A :: CHANNEL1 } # [doc = "Checks if the value of the field is `CHANNEL2`"]
# [inline (always)]
pub fn is_channel2 (& self) -> bool { * self == CHANNEL_A :: CHANNEL2 } # [doc = "Checks if the value of the field is `CHANNEL3`"]
# [inline (always)]
pub fn is_channel3 (& self) -> bool { * self == CHANNEL_A :: CHANNEL3 } # [doc = "Checks if the value of the field is `CHANNEL4`"]
# [inline (always)]
pub fn is_channel4 (& self) -> bool { * self == CHANNEL_A :: CHANNEL4 } # [doc = "Checks if the value of the field is `CHANNEL5`"]
# [inline (always)]
pub fn is_channel5 (& self) -> bool { * self == CHANNEL_A :: CHANNEL5 } # [doc = "Checks if the value of the field is `CHANNEL6`"]
# [inline (always)]
pub fn is_channel6 (& self) -> bool { * self == CHANNEL_A :: CHANNEL6 } # [doc = "Checks if the value of the field is `CHANNEL7`"]
# [inline (always)]
pub fn is_channel7 (& self) -> bool { * self == CHANNEL_A :: CHANNEL7 } } # [doc = "Field `CHANNEL` writer - Channel selector"]
pub type CHANNEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USERUSART3_SPEC , u8 , CHANNEL_A , 8 , O > ; impl < 'a , const O : u8 > CHANNEL_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHANNEL_A :: OFF) } # [doc = "Connect user to event channel 0"]
# [inline (always)]
pub fn channel0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL0) } # [doc = "Connect user to event channel 1"]
# [inline (always)]
pub fn channel1 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL1) } # [doc = "Connect user to event channel 2"]
# [inline (always)]
pub fn channel2 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL2) } # [doc = "Connect user to event channel 3"]
# [inline (always)]
pub fn channel3 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL3) } # [doc = "Connect user to event channel 4"]
# [inline (always)]
pub fn channel4 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL4) } # [doc = "Connect user to event channel 5"]
# [inline (always)]
pub fn channel5 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL5) } # [doc = "Connect user to event channel 6"]
# [inline (always)]
pub fn channel6 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL6) } # [doc = "Connect user to event channel 7"]
# [inline (always)]
pub fn channel7 (self) -> & 'a mut W { self . variant (CHANNEL_A :: CHANNEL7) } } impl R { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Channel selector"]
# [inline (always)]
# [must_use]
pub fn channel (& mut self) -> CHANNEL_W < 0 > { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User USART3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userusart3](index.html) module"]
pub struct USERUSART3_SPEC ; impl crate :: RegisterSpec for USERUSART3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userusart3::R](R) reader structure"]
impl crate :: Readable for USERUSART3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userusart3::W](W) writer structure"]
impl crate :: Writable for USERUSART3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERUSART3 to value 0"]
impl crate :: Resettable for USERUSART3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Fuses"]
pub struct FUSE { _marker : PhantomData < * const () > } unsafe impl Send for FUSE { } impl FUSE { # [doc = r"Pointer to the register block"]
pub const PTR : * const fuse :: RegisterBlock = 0x1280 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const fuse :: RegisterBlock { Self :: PTR } } impl Deref for FUSE { type Target = fuse :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FUSE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FUSE") . finish () } } # [doc = "Fuses"]
pub mod fuse { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Watchdog Configuration"]
pub wdtcfg : WDTCFG , # [doc = "0x01 - BOD Configuration"]
pub bodcfg : BODCFG , # [doc = "0x02 - Oscillator Configuration"]
pub osccfg : OSCCFG , _reserved3 : [u8 ; 0x02]
, # [doc = "0x05 - System Configuration 0"]
pub syscfg0 : SYSCFG0 , # [doc = "0x06 - System Configuration 1"]
pub syscfg1 : SYSCFG1 , # [doc = "0x07 - Application Code Section End"]
pub append : APPEND , # [doc = "0x08 - Boot Section End"]
pub bootend : BOOTEND , } # [doc = "APPEND (rw) register accessor: an alias for `Reg<APPEND_SPEC>`"]
pub type APPEND = crate :: Reg < append :: APPEND_SPEC > ; # [doc = "Application Code Section End"]
pub mod append { # [doc = "Register `APPEND` reader"]
pub struct R (crate :: R < APPEND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < APPEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < APPEND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < APPEND_SPEC >) -> Self { R (reader) } } # [doc = "Register `APPEND` writer"]
pub struct W (crate :: W < APPEND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < APPEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < APPEND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < APPEND_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Application Code Section End\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [append](index.html) module"]
pub struct APPEND_SPEC ; impl crate :: RegisterSpec for APPEND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [append::R](R) reader structure"]
impl crate :: Readable for APPEND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [append::W](W) writer structure"]
impl crate :: Writable for APPEND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets APPEND to value 0"]
impl crate :: Resettable for APPEND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BODCFG (rw) register accessor: an alias for `Reg<BODCFG_SPEC>`"]
pub type BODCFG = crate :: Reg < bodcfg :: BODCFG_SPEC > ; # [doc = "BOD Configuration"]
pub mod bodcfg { # [doc = "Register `BODCFG` reader"]
pub struct R (crate :: R < BODCFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BODCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BODCFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BODCFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `BODCFG` writer"]
pub struct W (crate :: W < BODCFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BODCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BODCFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BODCFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `SLEEP` reader - BOD Operation in Sleep Mode"]
pub type SLEEP_R = crate :: FieldReader < u8 , SLEEP_A > ; # [doc = "BOD Operation in Sleep Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SLEEP_A { # [doc = "0: Disabled"]
DIS = 0 , # [doc = "1: Enabled"]
ENABLED = 1 , # [doc = "2: Sampled"]
SAMPLED = 2 , } impl From < SLEEP_A > for u8 { # [inline (always)]
fn from (variant : SLEEP_A) -> Self { variant as _ } } impl SLEEP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SLEEP_A > { match self . bits { 0 => Some (SLEEP_A :: DIS) , 1 => Some (SLEEP_A :: ENABLED) , 2 => Some (SLEEP_A :: SAMPLED) , _ => None , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == SLEEP_A :: DIS } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * self == SLEEP_A :: ENABLED } # [doc = "Checks if the value of the field is `SAMPLED`"]
# [inline (always)]
pub fn is_sampled (& self) -> bool { * self == SLEEP_A :: SAMPLED } } # [doc = "Field `SLEEP` writer - BOD Operation in Sleep Mode"]
pub type SLEEP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , BODCFG_SPEC , u8 , SLEEP_A , 2 , O > ; impl < 'a , const O : u8 > SLEEP_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (SLEEP_A :: DIS) } # [doc = "Enabled"]
# [inline (always)]
pub fn enabled (self) -> & 'a mut W { self . variant (SLEEP_A :: ENABLED) } # [doc = "Sampled"]
# [inline (always)]
pub fn sampled (self) -> & 'a mut W { self . variant (SLEEP_A :: SAMPLED) } } # [doc = "Field `ACTIVE` reader - BOD Operation in Active Mode"]
pub type ACTIVE_R = crate :: FieldReader < u8 , ACTIVE_A > ; # [doc = "BOD Operation in Active Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ACTIVE_A { # [doc = "0: Disabled"]
DIS = 0 , # [doc = "1: Enabled"]
ENABLED = 1 , # [doc = "2: Sampled"]
SAMPLED = 2 , # [doc = "3: Enabled with wake-up halted until BOD is ready"]
ENWAKE = 3 , } impl From < ACTIVE_A > for u8 { # [inline (always)]
fn from (variant : ACTIVE_A) -> Self { variant as _ } } impl ACTIVE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACTIVE_A { match self . bits { 0 => ACTIVE_A :: DIS , 1 => ACTIVE_A :: ENABLED , 2 => ACTIVE_A :: SAMPLED , 3 => ACTIVE_A :: ENWAKE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIS`"]
# [inline (always)]
pub fn is_dis (& self) -> bool { * self == ACTIVE_A :: DIS } # [doc = "Checks if the value of the field is `ENABLED`"]
# [inline (always)]
pub fn is_enabled (& self) -> bool { * self == ACTIVE_A :: ENABLED } # [doc = "Checks if the value of the field is `SAMPLED`"]
# [inline (always)]
pub fn is_sampled (& self) -> bool { * self == ACTIVE_A :: SAMPLED } # [doc = "Checks if the value of the field is `ENWAKE`"]
# [inline (always)]
pub fn is_enwake (& self) -> bool { * self == ACTIVE_A :: ENWAKE } } # [doc = "Field `ACTIVE` writer - BOD Operation in Active Mode"]
pub type ACTIVE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BODCFG_SPEC , u8 , ACTIVE_A , 2 , O > ; impl < 'a , const O : u8 > ACTIVE_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn dis (self) -> & 'a mut W { self . variant (ACTIVE_A :: DIS) } # [doc = "Enabled"]
# [inline (always)]
pub fn enabled (self) -> & 'a mut W { self . variant (ACTIVE_A :: ENABLED) } # [doc = "Sampled"]
# [inline (always)]
pub fn sampled (self) -> & 'a mut W { self . variant (ACTIVE_A :: SAMPLED) } # [doc = "Enabled with wake-up halted until BOD is ready"]
# [inline (always)]
pub fn enwake (self) -> & 'a mut W { self . variant (ACTIVE_A :: ENWAKE) } } # [doc = "Field `SAMPFREQ` reader - BOD Sample Frequency"]
pub type SAMPFREQ_R = crate :: BitReader < SAMPFREQ_A > ; # [doc = "BOD Sample Frequency\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SAMPFREQ_A { # [doc = "0: 1kHz sampling frequency"]
_1KHZ = 0 , # [doc = "1: 125Hz sampling frequency"]
_125HZ = 1 , } impl From < SAMPFREQ_A > for bool { # [inline (always)]
fn from (variant : SAMPFREQ_A) -> Self { variant as u8 != 0 } } impl SAMPFREQ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SAMPFREQ_A { match self . bits { false => SAMPFREQ_A :: _1KHZ , true => SAMPFREQ_A :: _125HZ , } } # [doc = "Checks if the value of the field is `_1KHZ`"]
# [inline (always)]
pub fn is_1khz (& self) -> bool { * self == SAMPFREQ_A :: _1KHZ } # [doc = "Checks if the value of the field is `_125HZ`"]
# [inline (always)]
pub fn is_125hz (& self) -> bool { * self == SAMPFREQ_A :: _125HZ } } # [doc = "Field `SAMPFREQ` writer - BOD Sample Frequency"]
pub type SAMPFREQ_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , BODCFG_SPEC , SAMPFREQ_A , O > ; impl < 'a , const O : u8 > SAMPFREQ_W < 'a , O > { # [doc = "1kHz sampling frequency"]
# [inline (always)]
pub fn _1khz (self) -> & 'a mut W { self . variant (SAMPFREQ_A :: _1KHZ) } # [doc = "125Hz sampling frequency"]
# [inline (always)]
pub fn _125hz (self) -> & 'a mut W { self . variant (SAMPFREQ_A :: _125HZ) } } # [doc = "Field `LVL` reader - BOD Level"]
pub type LVL_R = crate :: FieldReader < u8 , LVL_A > ; # [doc = "BOD Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LVL_A { # [doc = "0: 1.8 V"]
BODLEVEL0 = 0 , # [doc = "2: 2.6 V"]
BODLEVEL2 = 2 , # [doc = "7: 4.2 V"]
BODLEVEL7 = 7 , } impl From < LVL_A > for u8 { # [inline (always)]
fn from (variant : LVL_A) -> Self { variant as _ } } impl LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LVL_A > { match self . bits { 0 => Some (LVL_A :: BODLEVEL0) , 2 => Some (LVL_A :: BODLEVEL2) , 7 => Some (LVL_A :: BODLEVEL7) , _ => None , } } # [doc = "Checks if the value of the field is `BODLEVEL0`"]
# [inline (always)]
pub fn is_bodlevel0 (& self) -> bool { * self == LVL_A :: BODLEVEL0 } # [doc = "Checks if the value of the field is `BODLEVEL2`"]
# [inline (always)]
pub fn is_bodlevel2 (& self) -> bool { * self == LVL_A :: BODLEVEL2 } # [doc = "Checks if the value of the field is `BODLEVEL7`"]
# [inline (always)]
pub fn is_bodlevel7 (& self) -> bool { * self == LVL_A :: BODLEVEL7 } } # [doc = "Field `LVL` writer - BOD Level"]
pub type LVL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , BODCFG_SPEC , u8 , LVL_A , 3 , O > ; impl < 'a , const O : u8 > LVL_W < 'a , O > { # [doc = "1.8 V"]
# [inline (always)]
pub fn bodlevel0 (self) -> & 'a mut W { self . variant (LVL_A :: BODLEVEL0) } # [doc = "2.6 V"]
# [inline (always)]
pub fn bodlevel2 (self) -> & 'a mut W { self . variant (LVL_A :: BODLEVEL2) } # [doc = "4.2 V"]
# [inline (always)]
pub fn bodlevel7 (self) -> & 'a mut W { self . variant (LVL_A :: BODLEVEL7) } } impl R { # [doc = "Bits 0:1 - BOD Operation in Sleep Mode"]
# [inline (always)]
pub fn sleep (& self) -> SLEEP_R { SLEEP_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - BOD Operation in Active Mode"]
# [inline (always)]
pub fn active (& self) -> ACTIVE_R { ACTIVE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - BOD Sample Frequency"]
# [inline (always)]
pub fn sampfreq (& self) -> SAMPFREQ_R { SAMPFREQ_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - BOD Level"]
# [inline (always)]
pub fn lvl (& self) -> LVL_R { LVL_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:1 - BOD Operation in Sleep Mode"]
# [inline (always)]
# [must_use]
pub fn sleep (& mut self) -> SLEEP_W < 0 > { SLEEP_W :: new (self) } # [doc = "Bits 2:3 - BOD Operation in Active Mode"]
# [inline (always)]
# [must_use]
pub fn active (& mut self) -> ACTIVE_W < 2 > { ACTIVE_W :: new (self) } # [doc = "Bit 4 - BOD Sample Frequency"]
# [inline (always)]
# [must_use]
pub fn sampfreq (& mut self) -> SAMPFREQ_W < 4 > { SAMPFREQ_W :: new (self) } # [doc = "Bits 5:7 - BOD Level"]
# [inline (always)]
# [must_use]
pub fn lvl (& mut self) -> LVL_W < 5 > { LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "BOD Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bodcfg](index.html) module"]
pub struct BODCFG_SPEC ; impl crate :: RegisterSpec for BODCFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [bodcfg::R](R) reader structure"]
impl crate :: Readable for BODCFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bodcfg::W](W) writer structure"]
impl crate :: Writable for BODCFG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BODCFG to value 0"]
impl crate :: Resettable for BODCFG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BOOTEND (rw) register accessor: an alias for `Reg<BOOTEND_SPEC>`"]
pub type BOOTEND = crate :: Reg < bootend :: BOOTEND_SPEC > ; # [doc = "Boot Section End"]
pub mod bootend { # [doc = "Register `BOOTEND` reader"]
pub struct R (crate :: R < BOOTEND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BOOTEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BOOTEND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BOOTEND_SPEC >) -> Self { R (reader) } } # [doc = "Register `BOOTEND` writer"]
pub struct W (crate :: W < BOOTEND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BOOTEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BOOTEND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BOOTEND_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Boot Section End\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bootend](index.html) module"]
pub struct BOOTEND_SPEC ; impl crate :: RegisterSpec for BOOTEND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [bootend::R](R) reader structure"]
impl crate :: Readable for BOOTEND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bootend::W](W) writer structure"]
impl crate :: Writable for BOOTEND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BOOTEND to value 0"]
impl crate :: Resettable for BOOTEND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCFG (rw) register accessor: an alias for `Reg<OSCCFG_SPEC>`"]
pub type OSCCFG = crate :: Reg < osccfg :: OSCCFG_SPEC > ; # [doc = "Oscillator Configuration"]
pub mod osccfg { # [doc = "Register `OSCCFG` reader"]
pub struct R (crate :: R < OSCCFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSCCFG` writer"]
pub struct W (crate :: W < OSCCFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSCCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSCCFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSCCFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `FREQSEL` reader - Frequency Select"]
pub type FREQSEL_R = crate :: FieldReader < u8 , FREQSEL_A > ; # [doc = "Frequency Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FREQSEL_A { # [doc = "1: 16 MHz"]
_16MHZ = 1 , # [doc = "2: 20 MHz"]
_20MHZ = 2 , } impl From < FREQSEL_A > for u8 { # [inline (always)]
fn from (variant : FREQSEL_A) -> Self { variant as _ } } impl FREQSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FREQSEL_A > { match self . bits { 1 => Some (FREQSEL_A :: _16MHZ) , 2 => Some (FREQSEL_A :: _20MHZ) , _ => None , } } # [doc = "Checks if the value of the field is `_16MHZ`"]
# [inline (always)]
pub fn is_16mhz (& self) -> bool { * self == FREQSEL_A :: _16MHZ } # [doc = "Checks if the value of the field is `_20MHZ`"]
# [inline (always)]
pub fn is_20mhz (& self) -> bool { * self == FREQSEL_A :: _20MHZ } } # [doc = "Field `FREQSEL` writer - Frequency Select"]
pub type FREQSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , OSCCFG_SPEC , u8 , FREQSEL_A , 2 , O > ; impl < 'a , const O : u8 > FREQSEL_W < 'a , O > { # [doc = "16 MHz"]
# [inline (always)]
pub fn _16mhz (self) -> & 'a mut W { self . variant (FREQSEL_A :: _16MHZ) } # [doc = "20 MHz"]
# [inline (always)]
pub fn _20mhz (self) -> & 'a mut W { self . variant (FREQSEL_A :: _20MHZ) } } # [doc = "Field `OSCLOCK` reader - Oscillator Lock"]
pub type OSCLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `OSCLOCK` writer - Oscillator Lock"]
pub type OSCLOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OSCCFG_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Frequency Select"]
# [inline (always)]
pub fn freqsel (& self) -> FREQSEL_R { FREQSEL_R :: new (self . bits & 3) } # [doc = "Bit 7 - Oscillator Lock"]
# [inline (always)]
pub fn osclock (& self) -> OSCLOCK_R { OSCLOCK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Frequency Select"]
# [inline (always)]
# [must_use]
pub fn freqsel (& mut self) -> FREQSEL_W < 0 > { FREQSEL_W :: new (self) } # [doc = "Bit 7 - Oscillator Lock"]
# [inline (always)]
# [must_use]
pub fn osclock (& mut self) -> OSCLOCK_W < 7 > { OSCLOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Oscillator Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccfg](index.html) module"]
pub struct OSCCFG_SPEC ; impl crate :: RegisterSpec for OSCCFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccfg::R](R) reader structure"]
impl crate :: Readable for OSCCFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osccfg::W](W) writer structure"]
impl crate :: Writable for OSCCFG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSCCFG to value 0"]
impl crate :: Resettable for OSCCFG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYSCFG0 (rw) register accessor: an alias for `Reg<SYSCFG0_SPEC>`"]
pub type SYSCFG0 = crate :: Reg < syscfg0 :: SYSCFG0_SPEC > ; # [doc = "System Configuration 0"]
pub mod syscfg0 { # [doc = "Register `SYSCFG0` reader"]
pub struct R (crate :: R < SYSCFG0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSCFG0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSCFG0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSCFG0_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSCFG0` writer"]
pub struct W (crate :: W < SYSCFG0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSCFG0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSCFG0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSCFG0_SPEC >) -> Self { W (writer) } } # [doc = "Field `EESAVE` reader - EEPROM Save"]
pub type EESAVE_R = crate :: BitReader < bool > ; # [doc = "Field `EESAVE` writer - EEPROM Save"]
pub type EESAVE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SYSCFG0_SPEC , bool , O > ; # [doc = "Field `RSTPINCFG` reader - Reset Pin Configuration"]
pub type RSTPINCFG_R = crate :: BitReader < RSTPINCFG_A > ; # [doc = "Reset Pin Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RSTPINCFG_A { # [doc = "0: GPIO mode"]
GPIO = 0 , # [doc = "1: Reset mode"]
RST = 1 , } impl From < RSTPINCFG_A > for bool { # [inline (always)]
fn from (variant : RSTPINCFG_A) -> Self { variant as u8 != 0 } } impl RSTPINCFG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RSTPINCFG_A { match self . bits { false => RSTPINCFG_A :: GPIO , true => RSTPINCFG_A :: RST , } } # [doc = "Checks if the value of the field is `GPIO`"]
# [inline (always)]
pub fn is_gpio (& self) -> bool { * self == RSTPINCFG_A :: GPIO } # [doc = "Checks if the value of the field is `RST`"]
# [inline (always)]
pub fn is_rst (& self) -> bool { * self == RSTPINCFG_A :: RST } } # [doc = "Field `RSTPINCFG` writer - Reset Pin Configuration"]
pub type RSTPINCFG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SYSCFG0_SPEC , RSTPINCFG_A , O > ; impl < 'a , const O : u8 > RSTPINCFG_W < 'a , O > { # [doc = "GPIO mode"]
# [inline (always)]
pub fn gpio (self) -> & 'a mut W { self . variant (RSTPINCFG_A :: GPIO) } # [doc = "Reset mode"]
# [inline (always)]
pub fn rst (self) -> & 'a mut W { self . variant (RSTPINCFG_A :: RST) } } # [doc = "Field `CRCSRC` reader - CRC Source"]
pub type CRCSRC_R = crate :: FieldReader < u8 , CRCSRC_A > ; # [doc = "CRC Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CRCSRC_A { # [doc = "0: The CRC is performed on the entire Flash (boot, application code and application data section)."]
FLASH = 0 , # [doc = "1: The CRC is performed on the boot section of Flash"]
BOOT = 1 , # [doc = "2: The CRC is performed on the boot and application code section of Flash"]
BOOTAPP = 2 , # [doc = "3: Disable CRC."]
NOCRC = 3 , } impl From < CRCSRC_A > for u8 { # [inline (always)]
fn from (variant : CRCSRC_A) -> Self { variant as _ } } impl CRCSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CRCSRC_A { match self . bits { 0 => CRCSRC_A :: FLASH , 1 => CRCSRC_A :: BOOT , 2 => CRCSRC_A :: BOOTAPP , 3 => CRCSRC_A :: NOCRC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FLASH`"]
# [inline (always)]
pub fn is_flash (& self) -> bool { * self == CRCSRC_A :: FLASH } # [doc = "Checks if the value of the field is `BOOT`"]
# [inline (always)]
pub fn is_boot (& self) -> bool { * self == CRCSRC_A :: BOOT } # [doc = "Checks if the value of the field is `BOOTAPP`"]
# [inline (always)]
pub fn is_bootapp (& self) -> bool { * self == CRCSRC_A :: BOOTAPP } # [doc = "Checks if the value of the field is `NOCRC`"]
# [inline (always)]
pub fn is_nocrc (& self) -> bool { * self == CRCSRC_A :: NOCRC } } # [doc = "Field `CRCSRC` writer - CRC Source"]
pub type CRCSRC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SYSCFG0_SPEC , u8 , CRCSRC_A , 2 , O > ; impl < 'a , const O : u8 > CRCSRC_W < 'a , O > { # [doc = "The CRC is performed on the entire Flash (boot, application code and application data section)."]
# [inline (always)]
pub fn flash (self) -> & 'a mut W { self . variant (CRCSRC_A :: FLASH) } # [doc = "The CRC is performed on the boot section of Flash"]
# [inline (always)]
pub fn boot (self) -> & 'a mut W { self . variant (CRCSRC_A :: BOOT) } # [doc = "The CRC is performed on the boot and application code section of Flash"]
# [inline (always)]
pub fn bootapp (self) -> & 'a mut W { self . variant (CRCSRC_A :: BOOTAPP) } # [doc = "Disable CRC."]
# [inline (always)]
pub fn nocrc (self) -> & 'a mut W { self . variant (CRCSRC_A :: NOCRC) } } impl R { # [doc = "Bit 0 - EEPROM Save"]
# [inline (always)]
pub fn eesave (& self) -> EESAVE_R { EESAVE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 3 - Reset Pin Configuration"]
# [inline (always)]
pub fn rstpincfg (& self) -> RSTPINCFG_R { RSTPINCFG_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 6:7 - CRC Source"]
# [inline (always)]
pub fn crcsrc (& self) -> CRCSRC_R { CRCSRC_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - EEPROM Save"]
# [inline (always)]
# [must_use]
pub fn eesave (& mut self) -> EESAVE_W < 0 > { EESAVE_W :: new (self) } # [doc = "Bit 3 - Reset Pin Configuration"]
# [inline (always)]
# [must_use]
pub fn rstpincfg (& mut self) -> RSTPINCFG_W < 3 > { RSTPINCFG_W :: new (self) } # [doc = "Bits 6:7 - CRC Source"]
# [inline (always)]
# [must_use]
pub fn crcsrc (& mut self) -> CRCSRC_W < 6 > { CRCSRC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System Configuration 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg0](index.html) module"]
pub struct SYSCFG0_SPEC ; impl crate :: RegisterSpec for SYSCFG0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syscfg0::R](R) reader structure"]
impl crate :: Readable for SYSCFG0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syscfg0::W](W) writer structure"]
impl crate :: Writable for SYSCFG0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYSCFG0 to value 0"]
impl crate :: Resettable for SYSCFG0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SYSCFG1 (rw) register accessor: an alias for `Reg<SYSCFG1_SPEC>`"]
pub type SYSCFG1 = crate :: Reg < syscfg1 :: SYSCFG1_SPEC > ; # [doc = "System Configuration 1"]
pub mod syscfg1 { # [doc = "Register `SYSCFG1` reader"]
pub struct R (crate :: R < SYSCFG1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYSCFG1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYSCFG1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYSCFG1_SPEC >) -> Self { R (reader) } } # [doc = "Register `SYSCFG1` writer"]
pub struct W (crate :: W < SYSCFG1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SYSCFG1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SYSCFG1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SYSCFG1_SPEC >) -> Self { W (writer) } } # [doc = "Field `SUT` reader - Startup Time"]
pub type SUT_R = crate :: FieldReader < u8 , SUT_A > ; # [doc = "Startup Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SUT_A { # [doc = "0: 0 ms"]
_0MS = 0 , # [doc = "1: 1 ms"]
_1MS = 1 , # [doc = "2: 2 ms"]
_2MS = 2 , # [doc = "3: 4 ms"]
_4MS = 3 , # [doc = "4: 8 ms"]
_8MS = 4 , # [doc = "5: 16 ms"]
_16MS = 5 , # [doc = "6: 32 ms"]
_32MS = 6 , # [doc = "7: 64 ms"]
_64MS = 7 , } impl From < SUT_A > for u8 { # [inline (always)]
fn from (variant : SUT_A) -> Self { variant as _ } } impl SUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SUT_A { match self . bits { 0 => SUT_A :: _0MS , 1 => SUT_A :: _1MS , 2 => SUT_A :: _2MS , 3 => SUT_A :: _4MS , 4 => SUT_A :: _8MS , 5 => SUT_A :: _16MS , 6 => SUT_A :: _32MS , 7 => SUT_A :: _64MS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0MS`"]
# [inline (always)]
pub fn is_0ms (& self) -> bool { * self == SUT_A :: _0MS } # [doc = "Checks if the value of the field is `_1MS`"]
# [inline (always)]
pub fn is_1ms (& self) -> bool { * self == SUT_A :: _1MS } # [doc = "Checks if the value of the field is `_2MS`"]
# [inline (always)]
pub fn is_2ms (& self) -> bool { * self == SUT_A :: _2MS } # [doc = "Checks if the value of the field is `_4MS`"]
# [inline (always)]
pub fn is_4ms (& self) -> bool { * self == SUT_A :: _4MS } # [doc = "Checks if the value of the field is `_8MS`"]
# [inline (always)]
pub fn is_8ms (& self) -> bool { * self == SUT_A :: _8MS } # [doc = "Checks if the value of the field is `_16MS`"]
# [inline (always)]
pub fn is_16ms (& self) -> bool { * self == SUT_A :: _16MS } # [doc = "Checks if the value of the field is `_32MS`"]
# [inline (always)]
pub fn is_32ms (& self) -> bool { * self == SUT_A :: _32MS } # [doc = "Checks if the value of the field is `_64MS`"]
# [inline (always)]
pub fn is_64ms (& self) -> bool { * self == SUT_A :: _64MS } } # [doc = "Field `SUT` writer - Startup Time"]
pub type SUT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SYSCFG1_SPEC , u8 , SUT_A , 3 , O > ; impl < 'a , const O : u8 > SUT_W < 'a , O > { # [doc = "0 ms"]
# [inline (always)]
pub fn _0ms (self) -> & 'a mut W { self . variant (SUT_A :: _0MS) } # [doc = "1 ms"]
# [inline (always)]
pub fn _1ms (self) -> & 'a mut W { self . variant (SUT_A :: _1MS) } # [doc = "2 ms"]
# [inline (always)]
pub fn _2ms (self) -> & 'a mut W { self . variant (SUT_A :: _2MS) } # [doc = "4 ms"]
# [inline (always)]
pub fn _4ms (self) -> & 'a mut W { self . variant (SUT_A :: _4MS) } # [doc = "8 ms"]
# [inline (always)]
pub fn _8ms (self) -> & 'a mut W { self . variant (SUT_A :: _8MS) } # [doc = "16 ms"]
# [inline (always)]
pub fn _16ms (self) -> & 'a mut W { self . variant (SUT_A :: _16MS) } # [doc = "32 ms"]
# [inline (always)]
pub fn _32ms (self) -> & 'a mut W { self . variant (SUT_A :: _32MS) } # [doc = "64 ms"]
# [inline (always)]
pub fn _64ms (self) -> & 'a mut W { self . variant (SUT_A :: _64MS) } } impl R { # [doc = "Bits 0:2 - Startup Time"]
# [inline (always)]
pub fn sut (& self) -> SUT_R { SUT_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Startup Time"]
# [inline (always)]
# [must_use]
pub fn sut (& mut self) -> SUT_W < 0 > { SUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "System Configuration 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syscfg1](index.html) module"]
pub struct SYSCFG1_SPEC ; impl crate :: RegisterSpec for SYSCFG1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syscfg1::R](R) reader structure"]
impl crate :: Readable for SYSCFG1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [syscfg1::W](W) writer structure"]
impl crate :: Writable for SYSCFG1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SYSCFG1 to value 0"]
impl crate :: Resettable for SYSCFG1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WDTCFG (rw) register accessor: an alias for `Reg<WDTCFG_SPEC>`"]
pub type WDTCFG = crate :: Reg < wdtcfg :: WDTCFG_SPEC > ; # [doc = "Watchdog Configuration"]
pub mod wdtcfg { # [doc = "Register `WDTCFG` reader"]
pub struct R (crate :: R < WDTCFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WDTCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WDTCFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WDTCFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `WDTCFG` writer"]
pub struct W (crate :: W < WDTCFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WDTCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WDTCFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WDTCFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERIOD` reader - Watchdog Timeout Period"]
pub type PERIOD_R = crate :: FieldReader < u8 , PERIOD_A > ; # [doc = "Watchdog Timeout Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PERIOD_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: 8 cycles (8ms)"]
_8CLK = 1 , # [doc = "2: 16 cycles (16ms)"]
_16CLK = 2 , # [doc = "3: 32 cycles (32ms)"]
_32CLK = 3 , # [doc = "4: 64 cycles (64ms)"]
_64CLK = 4 , # [doc = "5: 128 cycles (0.128s)"]
_128CLK = 5 , # [doc = "6: 256 cycles (0.256s)"]
_256CLK = 6 , # [doc = "7: 512 cycles (0.512s)"]
_512CLK = 7 , # [doc = "8: 1K cycles (1.0s)"]
_1KCLK = 8 , # [doc = "9: 2K cycles (2.0s)"]
_2KCLK = 9 , # [doc = "10: 4K cycles (4.1s)"]
_4KCLK = 10 , # [doc = "11: 8K cycles (8.2s)"]
_8KCLK = 11 , } impl From < PERIOD_A > for u8 { # [inline (always)]
fn from (variant : PERIOD_A) -> Self { variant as _ } } impl PERIOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PERIOD_A > { match self . bits { 0 => Some (PERIOD_A :: OFF) , 1 => Some (PERIOD_A :: _8CLK) , 2 => Some (PERIOD_A :: _16CLK) , 3 => Some (PERIOD_A :: _32CLK) , 4 => Some (PERIOD_A :: _64CLK) , 5 => Some (PERIOD_A :: _128CLK) , 6 => Some (PERIOD_A :: _256CLK) , 7 => Some (PERIOD_A :: _512CLK) , 8 => Some (PERIOD_A :: _1KCLK) , 9 => Some (PERIOD_A :: _2KCLK) , 10 => Some (PERIOD_A :: _4KCLK) , 11 => Some (PERIOD_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == PERIOD_A :: OFF } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == PERIOD_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == PERIOD_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == PERIOD_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == PERIOD_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == PERIOD_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == PERIOD_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == PERIOD_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == PERIOD_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == PERIOD_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == PERIOD_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == PERIOD_A :: _8KCLK } } # [doc = "Field `PERIOD` writer - Watchdog Timeout Period"]
pub type PERIOD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , WDTCFG_SPEC , u8 , PERIOD_A , 4 , O > ; impl < 'a , const O : u8 > PERIOD_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (PERIOD_A :: OFF) } # [doc = "8 cycles (8ms)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _8CLK) } # [doc = "16 cycles (16ms)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _16CLK) } # [doc = "32 cycles (32ms)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _32CLK) } # [doc = "64 cycles (64ms)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _64CLK) } # [doc = "128 cycles (0.128s)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _128CLK) } # [doc = "256 cycles (0.256s)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _256CLK) } # [doc = "512 cycles (0.512s)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _512CLK) } # [doc = "1K cycles (1.0s)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _1KCLK) } # [doc = "2K cycles (2.0s)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _2KCLK) } # [doc = "4K cycles (4.1s)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _4KCLK) } # [doc = "8K cycles (8.2s)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _8KCLK) } } # [doc = "Field `WINDOW` reader - Watchdog Window Timeout Period"]
pub type WINDOW_R = crate :: FieldReader < u8 , WINDOW_A > ; # [doc = "Watchdog Window Timeout Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINDOW_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: 8 cycles (8ms)"]
_8CLK = 1 , # [doc = "2: 16 cycles (16ms)"]
_16CLK = 2 , # [doc = "3: 32 cycles (32ms)"]
_32CLK = 3 , # [doc = "4: 64 cycles (64ms)"]
_64CLK = 4 , # [doc = "5: 128 cycles (0.128s)"]
_128CLK = 5 , # [doc = "6: 256 cycles (0.256s)"]
_256CLK = 6 , # [doc = "7: 512 cycles (0.512s)"]
_512CLK = 7 , # [doc = "8: 1K cycles (1.0s)"]
_1KCLK = 8 , # [doc = "9: 2K cycles (2.0s)"]
_2KCLK = 9 , # [doc = "10: 4K cycles (4.1s)"]
_4KCLK = 10 , # [doc = "11: 8K cycles (8.2s)"]
_8KCLK = 11 , } impl From < WINDOW_A > for u8 { # [inline (always)]
fn from (variant : WINDOW_A) -> Self { variant as _ } } impl WINDOW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WINDOW_A > { match self . bits { 0 => Some (WINDOW_A :: OFF) , 1 => Some (WINDOW_A :: _8CLK) , 2 => Some (WINDOW_A :: _16CLK) , 3 => Some (WINDOW_A :: _32CLK) , 4 => Some (WINDOW_A :: _64CLK) , 5 => Some (WINDOW_A :: _128CLK) , 6 => Some (WINDOW_A :: _256CLK) , 7 => Some (WINDOW_A :: _512CLK) , 8 => Some (WINDOW_A :: _1KCLK) , 9 => Some (WINDOW_A :: _2KCLK) , 10 => Some (WINDOW_A :: _4KCLK) , 11 => Some (WINDOW_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == WINDOW_A :: OFF } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == WINDOW_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == WINDOW_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == WINDOW_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == WINDOW_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == WINDOW_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == WINDOW_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == WINDOW_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == WINDOW_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == WINDOW_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == WINDOW_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == WINDOW_A :: _8KCLK } } # [doc = "Field `WINDOW` writer - Watchdog Window Timeout Period"]
pub type WINDOW_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , WDTCFG_SPEC , u8 , WINDOW_A , 4 , O > ; impl < 'a , const O : u8 > WINDOW_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (WINDOW_A :: OFF) } # [doc = "8 cycles (8ms)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _8CLK) } # [doc = "16 cycles (16ms)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _16CLK) } # [doc = "32 cycles (32ms)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _32CLK) } # [doc = "64 cycles (64ms)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _64CLK) } # [doc = "128 cycles (0.128s)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _128CLK) } # [doc = "256 cycles (0.256s)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _256CLK) } # [doc = "512 cycles (0.512s)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _512CLK) } # [doc = "1K cycles (1.0s)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _1KCLK) } # [doc = "2K cycles (2.0s)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _2KCLK) } # [doc = "4K cycles (4.1s)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _4KCLK) } # [doc = "8K cycles (8.2s)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _8KCLK) } } impl R { # [doc = "Bits 0:3 - Watchdog Timeout Period"]
# [inline (always)]
pub fn period (& self) -> PERIOD_R { PERIOD_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Watchdog Window Timeout Period"]
# [inline (always)]
pub fn window (& self) -> WINDOW_R { WINDOW_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Watchdog Timeout Period"]
# [inline (always)]
# [must_use]
pub fn period (& mut self) -> PERIOD_W < 0 > { PERIOD_W :: new (self) } # [doc = "Bits 4:7 - Watchdog Window Timeout Period"]
# [inline (always)]
# [must_use]
pub fn window (& mut self) -> WINDOW_W < 4 > { WINDOW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Watchdog Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wdtcfg](index.html) module"]
pub struct WDTCFG_SPEC ; impl crate :: RegisterSpec for WDTCFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [wdtcfg::R](R) reader structure"]
impl crate :: Readable for WDTCFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wdtcfg::W](W) writer structure"]
impl crate :: Writable for WDTCFG_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WDTCFG to value 0"]
impl crate :: Resettable for WDTCFG_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "General Purpose IO"]
pub struct GPIO { _marker : PhantomData < * const () > } unsafe impl Send for GPIO { } impl GPIO { # [doc = r"Pointer to the register block"]
pub const PTR : * const gpio :: RegisterBlock = 0x1c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const gpio :: RegisterBlock { Self :: PTR } } impl Deref for GPIO { type Target = gpio :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for GPIO { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("GPIO") . finish () } } # [doc = "General Purpose IO"]
pub mod gpio { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - General Purpose IO Register 0"]
pub gpior0 : GPIOR0 , # [doc = "0x01 - General Purpose IO Register 1"]
pub gpior1 : GPIOR1 , # [doc = "0x02 - General Purpose IO Register 2"]
pub gpior2 : GPIOR2 , # [doc = "0x03 - General Purpose IO Register 3"]
pub gpior3 : GPIOR3 , } # [doc = "GPIOR0 (rw) register accessor: an alias for `Reg<GPIOR0_SPEC>`"]
pub type GPIOR0 = crate :: Reg < gpior0 :: GPIOR0_SPEC > ; # [doc = "General Purpose IO Register 0"]
pub mod gpior0 { # [doc = "Register `GPIOR0` reader"]
pub struct R (crate :: R < GPIOR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR0` writer"]
pub struct W (crate :: W < GPIOR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior0](index.html) module"]
pub struct GPIOR0_SPEC ; impl crate :: RegisterSpec for GPIOR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior0::R](R) reader structure"]
impl crate :: Readable for GPIOR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior0::W](W) writer structure"]
impl crate :: Writable for GPIOR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR0 to value 0"]
impl crate :: Resettable for GPIOR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR1 (rw) register accessor: an alias for `Reg<GPIOR1_SPEC>`"]
pub type GPIOR1 = crate :: Reg < gpior1 :: GPIOR1_SPEC > ; # [doc = "General Purpose IO Register 1"]
pub mod gpior1 { # [doc = "Register `GPIOR1` reader"]
pub struct R (crate :: R < GPIOR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR1` writer"]
pub struct W (crate :: W < GPIOR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior1](index.html) module"]
pub struct GPIOR1_SPEC ; impl crate :: RegisterSpec for GPIOR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior1::R](R) reader structure"]
impl crate :: Readable for GPIOR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior1::W](W) writer structure"]
impl crate :: Writable for GPIOR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR1 to value 0"]
impl crate :: Resettable for GPIOR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR2 (rw) register accessor: an alias for `Reg<GPIOR2_SPEC>`"]
pub type GPIOR2 = crate :: Reg < gpior2 :: GPIOR2_SPEC > ; # [doc = "General Purpose IO Register 2"]
pub mod gpior2 { # [doc = "Register `GPIOR2` reader"]
pub struct R (crate :: R < GPIOR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR2` writer"]
pub struct W (crate :: W < GPIOR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior2](index.html) module"]
pub struct GPIOR2_SPEC ; impl crate :: RegisterSpec for GPIOR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior2::R](R) reader structure"]
impl crate :: Readable for GPIOR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior2::W](W) writer structure"]
impl crate :: Writable for GPIOR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR2 to value 0"]
impl crate :: Resettable for GPIOR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR3 (rw) register accessor: an alias for `Reg<GPIOR3_SPEC>`"]
pub type GPIOR3 = crate :: Reg < gpior3 :: GPIOR3_SPEC > ; # [doc = "General Purpose IO Register 3"]
pub mod gpior3 { # [doc = "Register `GPIOR3` reader"]
pub struct R (crate :: R < GPIOR3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR3_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR3` writer"]
pub struct W (crate :: W < GPIOR3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior3](index.html) module"]
pub struct GPIOR3_SPEC ; impl crate :: RegisterSpec for GPIOR3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior3::R](R) reader structure"]
impl crate :: Readable for GPIOR3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior3::W](W) writer structure"]
impl crate :: Writable for GPIOR3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR3 to value 0"]
impl crate :: Resettable for GPIOR3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Lockbit"]
pub struct LOCKBIT { _marker : PhantomData < * const () > } unsafe impl Send for LOCKBIT { } impl LOCKBIT { # [doc = r"Pointer to the register block"]
pub const PTR : * const lockbit :: RegisterBlock = 0x128a as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const lockbit :: RegisterBlock { Self :: PTR } } impl Deref for LOCKBIT { type Target = lockbit :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for LOCKBIT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("LOCKBIT") . finish () } } # [doc = "Lockbit"]
pub mod lockbit { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Lock Bits"]
pub lockbit : LOCKBIT , } # [doc = "LOCKBIT (rw) register accessor: an alias for `Reg<LOCKBIT_SPEC>`"]
pub type LOCKBIT = crate :: Reg < lockbit :: LOCKBIT_SPEC > ; # [doc = "Lock Bits"]
pub mod lockbit { # [doc = "Register `LOCKBIT` reader"]
pub struct R (crate :: R < LOCKBIT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKBIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKBIT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKBIT_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCKBIT` writer"]
pub struct W (crate :: W < LOCKBIT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCKBIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCKBIT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCKBIT_SPEC >) -> Self { W (writer) } } # [doc = "Field `LB` reader - Lock Bits"]
pub type LB_R = crate :: FieldReader < u8 , LB_A > ; # [doc = "Lock Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LB_A { # [doc = "58: Read and write lock"]
RWLOCK = 58 , # [doc = "197: No locks"]
NOLOCK = 197 , } impl From < LB_A > for u8 { # [inline (always)]
fn from (variant : LB_A) -> Self { variant as _ } } impl LB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LB_A > { match self . bits { 58 => Some (LB_A :: RWLOCK) , 197 => Some (LB_A :: NOLOCK) , _ => None , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == LB_A :: RWLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == LB_A :: NOLOCK } } # [doc = "Field `LB` writer - Lock Bits"]
pub type LB_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LOCKBIT_SPEC , u8 , LB_A , 8 , O > ; impl < 'a , const O : u8 > LB_W < 'a , O > { # [doc = "Read and write lock"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (LB_A :: RWLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (LB_A :: NOLOCK) } } impl R { # [doc = "Bits 0:7 - Lock Bits"]
# [inline (always)]
pub fn lb (& self) -> LB_R { LB_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Lock Bits"]
# [inline (always)]
# [must_use]
pub fn lb (& mut self) -> LB_W < 0 > { LB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Lock Bits\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockbit](index.html) module"]
pub struct LOCKBIT_SPEC ; impl crate :: RegisterSpec for LOCKBIT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lockbit::R](R) reader structure"]
impl crate :: Readable for LOCKBIT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lockbit::W](W) writer structure"]
impl crate :: Writable for LOCKBIT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOCKBIT to value 0"]
impl crate :: Resettable for LOCKBIT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Non-volatile Memory Controller"]
pub struct NVMCTRL { _marker : PhantomData < * const () > } unsafe impl Send for NVMCTRL { } impl NVMCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const nvmctrl :: RegisterBlock = 0x1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const nvmctrl :: RegisterBlock { Self :: PTR } } impl Deref for NVMCTRL { type Target = nvmctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for NVMCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("NVMCTRL") . finish () } } # [doc = "Non-volatile Memory Controller"]
pub mod nvmctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Status"]
pub status : STATUS , # [doc = "0x03 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x04 - Interrupt Flags"]
pub intflags : INTFLAGS , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Data"]
pub data : DATA , # [doc = "0x08 - Address"]
pub addr : ADDR , } # [doc = "ADDR (rw) register accessor: an alias for `Reg<ADDR_SPEC>`"]
pub type ADDR = crate :: Reg < addr :: ADDR_SPEC > ; # [doc = "Address"]
pub mod addr { # [doc = "Register `ADDR` reader"]
pub struct R (crate :: R < ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR` writer"]
pub struct W (crate :: W < ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr](index.html) module"]
pub struct ADDR_SPEC ; impl crate :: RegisterSpec for ADDR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [addr::R](R) reader structure"]
impl crate :: Readable for ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr::W](W) writer structure"]
impl crate :: Writable for ADDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADDR to value 0"]
impl crate :: Resettable for ADDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Write page"]
PAGEWRITE = 1 , # [doc = "2: Erase page"]
PAGEERASE = 2 , # [doc = "3: Erase and write page"]
PAGEERASEWRITE = 3 , # [doc = "4: Page buffer clear"]
PAGEBUFCLR = 4 , # [doc = "5: Chip erase"]
CHIPERASE = 5 , # [doc = "6: EEPROM erase"]
EEERASE = 6 , # [doc = "7: Write fuse (PDI only)"]
FUSEWRITE = 7 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: PAGEWRITE , 2 => CMD_A :: PAGEERASE , 3 => CMD_A :: PAGEERASEWRITE , 4 => CMD_A :: PAGEBUFCLR , 5 => CMD_A :: CHIPERASE , 6 => CMD_A :: EEERASE , 7 => CMD_A :: FUSEWRITE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `PAGEWRITE`"]
# [inline (always)]
pub fn is_pagewrite (& self) -> bool { * self == CMD_A :: PAGEWRITE } # [doc = "Checks if the value of the field is `PAGEERASE`"]
# [inline (always)]
pub fn is_pageerase (& self) -> bool { * self == CMD_A :: PAGEERASE } # [doc = "Checks if the value of the field is `PAGEERASEWRITE`"]
# [inline (always)]
pub fn is_pageerasewrite (& self) -> bool { * self == CMD_A :: PAGEERASEWRITE } # [doc = "Checks if the value of the field is `PAGEBUFCLR`"]
# [inline (always)]
pub fn is_pagebufclr (& self) -> bool { * self == CMD_A :: PAGEBUFCLR } # [doc = "Checks if the value of the field is `CHIPERASE`"]
# [inline (always)]
pub fn is_chiperase (& self) -> bool { * self == CMD_A :: CHIPERASE } # [doc = "Checks if the value of the field is `EEERASE`"]
# [inline (always)]
pub fn is_eeerase (& self) -> bool { * self == CMD_A :: EEERASE } # [doc = "Checks if the value of the field is `FUSEWRITE`"]
# [inline (always)]
pub fn is_fusewrite (& self) -> bool { * self == CMD_A :: FUSEWRITE } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CMD_A , 3 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Write page"]
# [inline (always)]
pub fn pagewrite (self) -> & 'a mut W { self . variant (CMD_A :: PAGEWRITE) } # [doc = "Erase page"]
# [inline (always)]
pub fn pageerase (self) -> & 'a mut W { self . variant (CMD_A :: PAGEERASE) } # [doc = "Erase and write page"]
# [inline (always)]
pub fn pageerasewrite (self) -> & 'a mut W { self . variant (CMD_A :: PAGEERASEWRITE) } # [doc = "Page buffer clear"]
# [inline (always)]
pub fn pagebufclr (self) -> & 'a mut W { self . variant (CMD_A :: PAGEBUFCLR) } # [doc = "Chip erase"]
# [inline (always)]
pub fn chiperase (self) -> & 'a mut W { self . variant (CMD_A :: CHIPERASE) } # [doc = "EEPROM erase"]
# [inline (always)]
pub fn eeerase (self) -> & 'a mut W { self . variant (CMD_A :: EEERASE) } # [doc = "Write fuse (PDI only)"]
# [inline (always)]
pub fn fusewrite (self) -> & 'a mut W { self . variant (CMD_A :: FUSEWRITE) } } impl R { # [doc = "Bits 0:2 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 0 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `APCWP` reader - Application code write protect"]
pub type APCWP_R = crate :: BitReader < bool > ; # [doc = "Field `APCWP` writer - Application code write protect"]
pub type APCWP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `BOOTLOCK` reader - Boot Lock"]
pub type BOOTLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `BOOTLOCK` writer - Boot Lock"]
pub type BOOTLOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Application code write protect"]
# [inline (always)]
pub fn apcwp (& self) -> APCWP_R { APCWP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Boot Lock"]
# [inline (always)]
pub fn bootlock (& self) -> BOOTLOCK_R { BOOTLOCK_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Application code write protect"]
# [inline (always)]
# [must_use]
pub fn apcwp (& mut self) -> APCWP_W < 0 > { APCWP_W :: new (self) } # [doc = "Bit 1 - Boot Lock"]
# [inline (always)]
# [must_use]
pub fn bootlock (& mut self) -> BOOTLOCK_W < 1 > { BOOTLOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EEREADY` reader - EEPROM Ready"]
pub type EEREADY_R = crate :: BitReader < bool > ; # [doc = "Field `EEREADY` writer - EEPROM Ready"]
pub type EEREADY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - EEPROM Ready"]
# [inline (always)]
pub fn eeready (& self) -> EEREADY_R { EEREADY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - EEPROM Ready"]
# [inline (always)]
# [must_use]
pub fn eeready (& mut self) -> EEREADY_W < 0 > { EEREADY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `EEREADY` reader - EEPROM Ready"]
pub type EEREADY_R = crate :: BitReader < bool > ; # [doc = "Field `EEREADY` writer - EEPROM Ready"]
pub type EEREADY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - EEPROM Ready"]
# [inline (always)]
pub fn eeready (& self) -> EEREADY_R { EEREADY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - EEPROM Ready"]
# [inline (always)]
# [must_use]
pub fn eeready (& mut self) -> EEREADY_W < 0 > { EEREADY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `FBUSY` reader - Flash busy"]
pub type FBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `EEBUSY` reader - EEPROM busy"]
pub type EEBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `WRERROR` reader - Write error"]
pub type WRERROR_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Flash busy"]
# [inline (always)]
pub fn fbusy (& self) -> FBUSY_R { FBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EEPROM busy"]
# [inline (always)]
pub fn eebusy (& self) -> EEBUSY_R { EEBUSY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Write error"]
# [inline (always)]
pub fn wrerror (& self) -> WRERROR_R { WRERROR_R :: new (((self . bits >> 2) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTA { _marker : PhantomData < * const () > } unsafe impl Send for PORTA { } impl PORTA { # [doc = r"Pointer to the register block"]
pub const PTR : * const porta :: RegisterBlock = 0x0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porta :: RegisterBlock { Self :: PTR } } impl Deref for PORTA { type Target = porta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTA") . finish () } } # [doc = "I/O Ports"]
pub mod porta { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0a - Port Control"]
pub portctrl : PORTCTRL , _reserved11 : [u8 ; 0x05]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PA0` reader - Pin A0"]
pub type PA0_R = crate :: BitReader < bool > ; # [doc = "Field `PA0` writer - Pin A0"]
pub type PA0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA1` reader - Pin A1"]
pub type PA1_R = crate :: BitReader < bool > ; # [doc = "Field `PA1` writer - Pin A1"]
pub type PA1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA2` reader - Pin A2"]
pub type PA2_R = crate :: BitReader < bool > ; # [doc = "Field `PA2` writer - Pin A2"]
pub type PA2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA3` reader - Pin A3"]
pub type PA3_R = crate :: BitReader < bool > ; # [doc = "Field `PA3` writer - Pin A3"]
pub type PA3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA4` reader - Pin A4"]
pub type PA4_R = crate :: BitReader < bool > ; # [doc = "Field `PA4` writer - Pin A4"]
pub type PA4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA5` reader - Pin A5"]
pub type PA5_R = crate :: BitReader < bool > ; # [doc = "Field `PA5` writer - Pin A5"]
pub type PA5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA6` reader - Pin A6"]
pub type PA6_R = crate :: BitReader < bool > ; # [doc = "Field `PA6` writer - Pin A6"]
pub type PA6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PA7` reader - Pin A7"]
pub type PA7_R = crate :: BitReader < bool > ; # [doc = "Field `PA7` writer - Pin A7"]
pub type PA7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
pub fn pa0 (& self) -> PA0_R { PA0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
pub fn pa1 (& self) -> PA1_R { PA1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
pub fn pa2 (& self) -> PA2_R { PA2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
pub fn pa3 (& self) -> PA3_R { PA3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
pub fn pa4 (& self) -> PA4_R { PA4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
pub fn pa5 (& self) -> PA5_R { PA5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
pub fn pa6 (& self) -> PA6_R { PA6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
pub fn pa7 (& self) -> PA7_R { PA7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin A0"]
# [inline (always)]
# [must_use]
pub fn pa0 (& mut self) -> PA0_W < 0 > { PA0_W :: new (self) } # [doc = "Bit 1 - Pin A1"]
# [inline (always)]
# [must_use]
pub fn pa1 (& mut self) -> PA1_W < 1 > { PA1_W :: new (self) } # [doc = "Bit 2 - Pin A2"]
# [inline (always)]
# [must_use]
pub fn pa2 (& mut self) -> PA2_W < 2 > { PA2_W :: new (self) } # [doc = "Bit 3 - Pin A3"]
# [inline (always)]
# [must_use]
pub fn pa3 (& mut self) -> PA3_W < 3 > { PA3_W :: new (self) } # [doc = "Bit 4 - Pin A4"]
# [inline (always)]
# [must_use]
pub fn pa4 (& mut self) -> PA4_W < 4 > { PA4_W :: new (self) } # [doc = "Bit 5 - Pin A5"]
# [inline (always)]
# [must_use]
pub fn pa5 (& mut self) -> PA5_W < 5 > { PA5_W :: new (self) } # [doc = "Bit 6 - Pin A6"]
# [inline (always)]
# [must_use]
pub fn pa6 (& mut self) -> PA6_W < 6 > { PA6_W :: new (self) } # [doc = "Bit 7 - Pin A7"]
# [inline (always)]
# [must_use]
pub fn pa7 (& mut self) -> PA7_W < 7 > { PA7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTCTRL (rw) register accessor: an alias for `Reg<PORTCTRL_SPEC>`"]
pub type PORTCTRL = crate :: Reg < portctrl :: PORTCTRL_SPEC > ; # [doc = "Port Control"]
pub mod portctrl { # [doc = "Register `PORTCTRL` reader"]
pub struct R (crate :: R < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTCTRL` writer"]
pub struct W (crate :: W < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRL` reader - Slew Rate Limit Enable"]
pub type SRL_R = crate :: BitReader < bool > ; # [doc = "Field `SRL` writer - Slew Rate Limit Enable"]
pub type SRL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
pub fn srl (& self) -> SRL_R { SRL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
# [must_use]
pub fn srl (& mut self) -> SRL_W < 0 > { SRL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portctrl](index.html) module"]
pub struct PORTCTRL_SPEC ; impl crate :: RegisterSpec for PORTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portctrl::R](R) reader structure"]
impl crate :: Readable for PORTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portctrl::W](W) writer structure"]
impl crate :: Writable for PORTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTCTRL to value 0"]
impl crate :: Resettable for PORTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTB { _marker : PhantomData < * const () > } unsafe impl Send for PORTB { } impl PORTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const portb :: RegisterBlock = 0x0420 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portb :: RegisterBlock { Self :: PTR } } impl Deref for PORTB { type Target = portb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTB") . finish () } } # [doc = "I/O Ports"]
pub mod portb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0a - Port Control"]
pub portctrl : PORTCTRL , _reserved11 : [u8 ; 0x05]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTCTRL (rw) register accessor: an alias for `Reg<PORTCTRL_SPEC>`"]
pub type PORTCTRL = crate :: Reg < portctrl :: PORTCTRL_SPEC > ; # [doc = "Port Control"]
pub mod portctrl { # [doc = "Register `PORTCTRL` reader"]
pub struct R (crate :: R < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTCTRL` writer"]
pub struct W (crate :: W < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRL` reader - Slew Rate Limit Enable"]
pub type SRL_R = crate :: BitReader < bool > ; # [doc = "Field `SRL` writer - Slew Rate Limit Enable"]
pub type SRL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
pub fn srl (& self) -> SRL_R { SRL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
# [must_use]
pub fn srl (& mut self) -> SRL_W < 0 > { SRL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portctrl](index.html) module"]
pub struct PORTCTRL_SPEC ; impl crate :: RegisterSpec for PORTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portctrl::R](R) reader structure"]
impl crate :: Readable for PORTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portctrl::W](W) writer structure"]
impl crate :: Writable for PORTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTCTRL to value 0"]
impl crate :: Resettable for PORTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTC { _marker : PhantomData < * const () > } unsafe impl Send for PORTC { } impl PORTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const portc :: RegisterBlock = 0x0440 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portc :: RegisterBlock { Self :: PTR } } impl Deref for PORTC { type Target = portc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTC") . finish () } } # [doc = "I/O Ports"]
pub mod portc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0a - Port Control"]
pub portctrl : PORTCTRL , _reserved11 : [u8 ; 0x05]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PC7` reader - Pin C7"]
pub type PC7_R = crate :: BitReader < bool > ; # [doc = "Field `PC7` writer - Pin C7"]
pub type PC7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
pub fn pc7 (& self) -> PC7_R { PC7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Bit 7 - Pin C7"]
# [inline (always)]
# [must_use]
pub fn pc7 (& mut self) -> PC7_W < 7 > { PC7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTCTRL (rw) register accessor: an alias for `Reg<PORTCTRL_SPEC>`"]
pub type PORTCTRL = crate :: Reg < portctrl :: PORTCTRL_SPEC > ; # [doc = "Port Control"]
pub mod portctrl { # [doc = "Register `PORTCTRL` reader"]
pub struct R (crate :: R < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTCTRL` writer"]
pub struct W (crate :: W < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRL` reader - Slew Rate Limit Enable"]
pub type SRL_R = crate :: BitReader < bool > ; # [doc = "Field `SRL` writer - Slew Rate Limit Enable"]
pub type SRL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
pub fn srl (& self) -> SRL_R { SRL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
# [must_use]
pub fn srl (& mut self) -> SRL_W < 0 > { SRL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portctrl](index.html) module"]
pub struct PORTCTRL_SPEC ; impl crate :: RegisterSpec for PORTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portctrl::R](R) reader structure"]
impl crate :: Readable for PORTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portctrl::W](W) writer structure"]
impl crate :: Writable for PORTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTCTRL to value 0"]
impl crate :: Resettable for PORTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTD { _marker : PhantomData < * const () > } unsafe impl Send for PORTD { } impl PORTD { # [doc = r"Pointer to the register block"]
pub const PTR : * const portd :: RegisterBlock = 0x0460 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portd :: RegisterBlock { Self :: PTR } } impl Deref for PORTD { type Target = portd :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTD") . finish () } } # [doc = "I/O Ports"]
pub mod portd { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0a - Port Control"]
pub portctrl : PORTCTRL , _reserved11 : [u8 ; 0x05]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTCTRL (rw) register accessor: an alias for `Reg<PORTCTRL_SPEC>`"]
pub type PORTCTRL = crate :: Reg < portctrl :: PORTCTRL_SPEC > ; # [doc = "Port Control"]
pub mod portctrl { # [doc = "Register `PORTCTRL` reader"]
pub struct R (crate :: R < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTCTRL` writer"]
pub struct W (crate :: W < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRL` reader - Slew Rate Limit Enable"]
pub type SRL_R = crate :: BitReader < bool > ; # [doc = "Field `SRL` writer - Slew Rate Limit Enable"]
pub type SRL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
pub fn srl (& self) -> SRL_R { SRL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
# [must_use]
pub fn srl (& mut self) -> SRL_W < 0 > { SRL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portctrl](index.html) module"]
pub struct PORTCTRL_SPEC ; impl crate :: RegisterSpec for PORTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portctrl::R](R) reader structure"]
impl crate :: Readable for PORTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portctrl::W](W) writer structure"]
impl crate :: Writable for PORTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTCTRL to value 0"]
impl crate :: Resettable for PORTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTE { _marker : PhantomData < * const () > } unsafe impl Send for PORTE { } impl PORTE { # [doc = r"Pointer to the register block"]
pub const PTR : * const porte :: RegisterBlock = 0x0480 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porte :: RegisterBlock { Self :: PTR } } impl Deref for PORTE { type Target = porte :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTE") . finish () } } # [doc = "I/O Ports"]
pub mod porte { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0a - Port Control"]
pub portctrl : PORTCTRL , _reserved11 : [u8 ; 0x05]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PE0` reader - Pin E0"]
pub type PE0_R = crate :: BitReader < bool > ; # [doc = "Field `PE0` writer - Pin E0"]
pub type PE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PE1` reader - Pin E1"]
pub type PE1_R = crate :: BitReader < bool > ; # [doc = "Field `PE1` writer - Pin E1"]
pub type PE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PE2` reader - Pin E2"]
pub type PE2_R = crate :: BitReader < bool > ; # [doc = "Field `PE2` writer - Pin E2"]
pub type PE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PE3` reader - Pin E3"]
pub type PE3_R = crate :: BitReader < bool > ; # [doc = "Field `PE3` writer - Pin E3"]
pub type PE3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
pub fn pe0 (& self) -> PE0_R { PE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
pub fn pe1 (& self) -> PE1_R { PE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
pub fn pe2 (& self) -> PE2_R { PE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
pub fn pe3 (& self) -> PE3_R { PE3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin E0"]
# [inline (always)]
# [must_use]
pub fn pe0 (& mut self) -> PE0_W < 0 > { PE0_W :: new (self) } # [doc = "Bit 1 - Pin E1"]
# [inline (always)]
# [must_use]
pub fn pe1 (& mut self) -> PE1_W < 1 > { PE1_W :: new (self) } # [doc = "Bit 2 - Pin E2"]
# [inline (always)]
# [must_use]
pub fn pe2 (& mut self) -> PE2_W < 2 > { PE2_W :: new (self) } # [doc = "Bit 3 - Pin E3"]
# [inline (always)]
# [must_use]
pub fn pe3 (& mut self) -> PE3_W < 3 > { PE3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTCTRL (rw) register accessor: an alias for `Reg<PORTCTRL_SPEC>`"]
pub type PORTCTRL = crate :: Reg < portctrl :: PORTCTRL_SPEC > ; # [doc = "Port Control"]
pub mod portctrl { # [doc = "Register `PORTCTRL` reader"]
pub struct R (crate :: R < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTCTRL` writer"]
pub struct W (crate :: W < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRL` reader - Slew Rate Limit Enable"]
pub type SRL_R = crate :: BitReader < bool > ; # [doc = "Field `SRL` writer - Slew Rate Limit Enable"]
pub type SRL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
pub fn srl (& self) -> SRL_R { SRL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
# [must_use]
pub fn srl (& mut self) -> SRL_W < 0 > { SRL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portctrl](index.html) module"]
pub struct PORTCTRL_SPEC ; impl crate :: RegisterSpec for PORTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portctrl::R](R) reader structure"]
impl crate :: Readable for PORTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portctrl::W](W) writer structure"]
impl crate :: Writable for PORTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTCTRL to value 0"]
impl crate :: Resettable for PORTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Ports"]
pub struct PORTF { _marker : PhantomData < * const () > } unsafe impl Send for PORTF { } impl PORTF { # [doc = r"Pointer to the register block"]
pub const PTR : * const portf :: RegisterBlock = 0x04a0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portf :: RegisterBlock { Self :: PTR } } impl Deref for PORTF { type Target = portf :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTF") . finish () } } # [doc = "I/O Ports"]
pub mod portf { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - Output Value"]
pub out : OUT , # [doc = "0x05 - Output Value Set"]
pub outset : OUTSET , # [doc = "0x06 - Output Value Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - Output Value Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - Input Value"]
pub in_ : IN , # [doc = "0x09 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x0a - Port Control"]
pub portctrl : PORTCTRL , _reserved11 : [u8 ; 0x05]
, # [doc = "0x10 - Pin 0 Control"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIRTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , IN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUT_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PF0` reader - Pin F0"]
pub type PF0_R = crate :: BitReader < bool > ; # [doc = "Field `PF0` writer - Pin F0"]
pub type PF0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PF1` reader - Pin F1"]
pub type PF1_R = crate :: BitReader < bool > ; # [doc = "Field `PF1` writer - Pin F1"]
pub type PF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PF2` reader - Pin F2"]
pub type PF2_R = crate :: BitReader < bool > ; # [doc = "Field `PF2` writer - Pin F2"]
pub type PF2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PF3` reader - Pin F3"]
pub type PF3_R = crate :: BitReader < bool > ; # [doc = "Field `PF3` writer - Pin F3"]
pub type PF3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PF4` reader - Pin F4"]
pub type PF4_R = crate :: BitReader < bool > ; # [doc = "Field `PF4` writer - Pin F4"]
pub type PF4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PF5` reader - Pin F5"]
pub type PF5_R = crate :: BitReader < bool > ; # [doc = "Field `PF5` writer - Pin F5"]
pub type PF5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; # [doc = "Field `PF6` reader - Pin F6"]
pub type PF6_R = crate :: BitReader < bool > ; # [doc = "Field `PF6` writer - Pin F6"]
pub type PF6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OUTTGL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
pub fn pf0 (& self) -> PF0_R { PF0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
pub fn pf1 (& self) -> PF1_R { PF1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
pub fn pf2 (& self) -> PF2_R { PF2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
pub fn pf3 (& self) -> PF3_R { PF3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
pub fn pf4 (& self) -> PF4_R { PF4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
pub fn pf5 (& self) -> PF5_R { PF5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
pub fn pf6 (& self) -> PF6_R { PF6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin F0"]
# [inline (always)]
# [must_use]
pub fn pf0 (& mut self) -> PF0_W < 0 > { PF0_W :: new (self) } # [doc = "Bit 1 - Pin F1"]
# [inline (always)]
# [must_use]
pub fn pf1 (& mut self) -> PF1_W < 1 > { PF1_W :: new (self) } # [doc = "Bit 2 - Pin F2"]
# [inline (always)]
# [must_use]
pub fn pf2 (& mut self) -> PF2_W < 2 > { PF2_W :: new (self) } # [doc = "Bit 3 - Pin F3"]
# [inline (always)]
# [must_use]
pub fn pf3 (& mut self) -> PF3_W < 3 > { PF3_W :: new (self) } # [doc = "Bit 4 - Pin F4"]
# [inline (always)]
# [must_use]
pub fn pf4 (& mut self) -> PF4_W < 4 > { PF4_W :: new (self) } # [doc = "Bit 5 - Pin F5"]
# [inline (always)]
# [must_use]
pub fn pf5 (& mut self) -> PF5_W < 5 > { PF5_W :: new (self) } # [doc = "Bit 6 - Pin F6"]
# [inline (always)]
# [must_use]
pub fn pf6 (& mut self) -> PF6_W < 6 > { PF6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Interrupt disabled but input buffer enabled"]
INTDISABLE = 0 , # [doc = "1: Sense Both Edges"]
BOTHEDGES = 1 , # [doc = "2: Sense Rising Edge"]
RISING = 2 , # [doc = "3: Sense Falling Edge"]
FALLING = 3 , # [doc = "4: Digital Input Buffer disabled"]
INPUT_DISABLE = 4 , # [doc = "5: Sense low Level"]
LEVEL = 5 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: INTDISABLE) , 1 => Some (ISC_A :: BOTHEDGES) , 2 => Some (ISC_A :: RISING) , 3 => Some (ISC_A :: FALLING) , 4 => Some (ISC_A :: INPUT_DISABLE) , 5 => Some (ISC_A :: LEVEL) , _ => None , } } # [doc = "Checks if the value of the field is `INTDISABLE`"]
# [inline (always)]
pub fn is_intdisable (& self) -> bool { * self == ISC_A :: INTDISABLE } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Interrupt disabled but input buffer enabled"]
# [inline (always)]
pub fn intdisable (self) -> & 'a mut W { self . variant (ISC_A :: INTDISABLE) } # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Digital Input Buffer disabled"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } # [doc = "Sense low Level"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } } # [doc = "Field `PULLUPEN` reader - Pullup enable"]
pub type PULLUPEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLUPEN` writer - Pullup enable"]
pub type PULLUPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
pub fn pullupen (& self) -> PULLUPEN_R { PULLUPEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bit 3 - Pullup enable"]
# [inline (always)]
# [must_use]
pub fn pullupen (& mut self) -> PULLUPEN_W < 3 > { PULLUPEN_W :: new (self) } # [doc = "Bit 7 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 7 > { INVEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTCTRL (rw) register accessor: an alias for `Reg<PORTCTRL_SPEC>`"]
pub type PORTCTRL = crate :: Reg < portctrl :: PORTCTRL_SPEC > ; # [doc = "Port Control"]
pub mod portctrl { # [doc = "Register `PORTCTRL` reader"]
pub struct R (crate :: R < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTCTRL` writer"]
pub struct W (crate :: W < PORTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRL` reader - Slew Rate Limit Enable"]
pub type SRL_R = crate :: BitReader < bool > ; # [doc = "Field `SRL` writer - Slew Rate Limit Enable"]
pub type SRL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
pub fn srl (& self) -> SRL_R { SRL_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Slew Rate Limit Enable"]
# [inline (always)]
# [must_use]
pub fn srl (& mut self) -> SRL_W < 0 > { SRL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portctrl](index.html) module"]
pub struct PORTCTRL_SPEC ; impl crate :: RegisterSpec for PORTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portctrl::R](R) reader structure"]
impl crate :: Readable for PORTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portctrl::W](W) writer structure"]
impl crate :: Writable for PORTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTCTRL to value 0"]
impl crate :: Resettable for PORTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Multiplexer"]
pub struct PORTMUX { _marker : PhantomData < * const () > } unsafe impl Send for PORTMUX { } impl PORTMUX { # [doc = r"Pointer to the register block"]
pub const PTR : * const portmux :: RegisterBlock = 0x05e0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portmux :: RegisterBlock { Self :: PTR } } impl Deref for PORTMUX { type Target = portmux :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTMUX { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTMUX") . finish () } } # [doc = "Port Multiplexer"]
pub mod portmux { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port Multiplexer EVSYS"]
pub evsysroutea : EVSYSROUTEA , # [doc = "0x01 - Port Multiplexer CCL"]
pub cclroutea : CCLROUTEA , # [doc = "0x02 - Port Multiplexer USART register A"]
pub usartroutea : USARTROUTEA , # [doc = "0x03 - Port Multiplexer TWI and SPI"]
pub twispiroutea : TWISPIROUTEA , # [doc = "0x04 - Port Multiplexer TCA"]
pub tcaroutea : TCAROUTEA , # [doc = "0x05 - Port Multiplexer TCB"]
pub tcbroutea : TCBROUTEA , } # [doc = "CCLROUTEA (rw) register accessor: an alias for `Reg<CCLROUTEA_SPEC>`"]
pub type CCLROUTEA = crate :: Reg < cclroutea :: CCLROUTEA_SPEC > ; # [doc = "Port Multiplexer CCL"]
pub mod cclroutea { # [doc = "Register `CCLROUTEA` reader"]
pub struct R (crate :: R < CCLROUTEA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCLROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCLROUTEA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCLROUTEA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCLROUTEA` writer"]
pub struct W (crate :: W < CCLROUTEA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCLROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCLROUTEA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCLROUTEA_SPEC >) -> Self { W (writer) } } # [doc = "Field `LUT0` reader - CCL LUT0"]
pub type LUT0_R = crate :: BitReader < bool > ; # [doc = "Field `LUT0` writer - CCL LUT0"]
pub type LUT0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CCLROUTEA_SPEC , bool , O > ; # [doc = "Field `LUT1` reader - CCL LUT1"]
pub type LUT1_R = crate :: BitReader < bool > ; # [doc = "Field `LUT1` writer - CCL LUT1"]
pub type LUT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CCLROUTEA_SPEC , bool , O > ; # [doc = "Field `LUT2` reader - CCL LUT2"]
pub type LUT2_R = crate :: BitReader < bool > ; # [doc = "Field `LUT2` writer - CCL LUT2"]
pub type LUT2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CCLROUTEA_SPEC , bool , O > ; # [doc = "Field `LUT3` reader - CCL LUT3"]
pub type LUT3_R = crate :: BitReader < bool > ; # [doc = "Field `LUT3` writer - CCL LUT3"]
pub type LUT3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CCLROUTEA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - CCL LUT0"]
# [inline (always)]
pub fn lut0 (& self) -> LUT0_R { LUT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - CCL LUT1"]
# [inline (always)]
pub fn lut1 (& self) -> LUT1_R { LUT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - CCL LUT2"]
# [inline (always)]
pub fn lut2 (& self) -> LUT2_R { LUT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - CCL LUT3"]
# [inline (always)]
pub fn lut3 (& self) -> LUT3_R { LUT3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - CCL LUT0"]
# [inline (always)]
# [must_use]
pub fn lut0 (& mut self) -> LUT0_W < 0 > { LUT0_W :: new (self) } # [doc = "Bit 1 - CCL LUT1"]
# [inline (always)]
# [must_use]
pub fn lut1 (& mut self) -> LUT1_W < 1 > { LUT1_W :: new (self) } # [doc = "Bit 2 - CCL LUT2"]
# [inline (always)]
# [must_use]
pub fn lut2 (& mut self) -> LUT2_W < 2 > { LUT2_W :: new (self) } # [doc = "Bit 3 - CCL LUT3"]
# [inline (always)]
# [must_use]
pub fn lut3 (& mut self) -> LUT3_W < 3 > { LUT3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer CCL\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cclroutea](index.html) module"]
pub struct CCLROUTEA_SPEC ; impl crate :: RegisterSpec for CCLROUTEA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [cclroutea::R](R) reader structure"]
impl crate :: Readable for CCLROUTEA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cclroutea::W](W) writer structure"]
impl crate :: Writable for CCLROUTEA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCLROUTEA to value 0"]
impl crate :: Resettable for CCLROUTEA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVSYSROUTEA (rw) register accessor: an alias for `Reg<EVSYSROUTEA_SPEC>`"]
pub type EVSYSROUTEA = crate :: Reg < evsysroutea :: EVSYSROUTEA_SPEC > ; # [doc = "Port Multiplexer EVSYS"]
pub mod evsysroutea { # [doc = "Register `EVSYSROUTEA` reader"]
pub struct R (crate :: R < EVSYSROUTEA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVSYSROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVSYSROUTEA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVSYSROUTEA_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVSYSROUTEA` writer"]
pub struct W (crate :: W < EVSYSROUTEA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVSYSROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVSYSROUTEA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVSYSROUTEA_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVOUT0` reader - Event Output 0"]
pub type EVOUT0_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT0` writer - Event Output 0"]
pub type EVOUT0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVSYSROUTEA_SPEC , bool , O > ; # [doc = "Field `EVOUT1` reader - Event Output 1"]
pub type EVOUT1_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT1` writer - Event Output 1"]
pub type EVOUT1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVSYSROUTEA_SPEC , bool , O > ; # [doc = "Field `EVOUT2` reader - Event Output 2"]
pub type EVOUT2_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT2` writer - Event Output 2"]
pub type EVOUT2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVSYSROUTEA_SPEC , bool , O > ; # [doc = "Field `EVOUT3` reader - Event Output 3"]
pub type EVOUT3_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT3` writer - Event Output 3"]
pub type EVOUT3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVSYSROUTEA_SPEC , bool , O > ; # [doc = "Field `EVOUT4` reader - Event Output 4"]
pub type EVOUT4_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT4` writer - Event Output 4"]
pub type EVOUT4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVSYSROUTEA_SPEC , bool , O > ; # [doc = "Field `EVOUT5` reader - Event Output 5"]
pub type EVOUT5_R = crate :: BitReader < bool > ; # [doc = "Field `EVOUT5` writer - Event Output 5"]
pub type EVOUT5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVSYSROUTEA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Event Output 0"]
# [inline (always)]
pub fn evout0 (& self) -> EVOUT0_R { EVOUT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Event Output 1"]
# [inline (always)]
pub fn evout1 (& self) -> EVOUT1_R { EVOUT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Event Output 2"]
# [inline (always)]
pub fn evout2 (& self) -> EVOUT2_R { EVOUT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Event Output 3"]
# [inline (always)]
pub fn evout3 (& self) -> EVOUT3_R { EVOUT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Event Output 4"]
# [inline (always)]
pub fn evout4 (& self) -> EVOUT4_R { EVOUT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Event Output 5"]
# [inline (always)]
pub fn evout5 (& self) -> EVOUT5_R { EVOUT5_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Event Output 0"]
# [inline (always)]
# [must_use]
pub fn evout0 (& mut self) -> EVOUT0_W < 0 > { EVOUT0_W :: new (self) } # [doc = "Bit 1 - Event Output 1"]
# [inline (always)]
# [must_use]
pub fn evout1 (& mut self) -> EVOUT1_W < 1 > { EVOUT1_W :: new (self) } # [doc = "Bit 2 - Event Output 2"]
# [inline (always)]
# [must_use]
pub fn evout2 (& mut self) -> EVOUT2_W < 2 > { EVOUT2_W :: new (self) } # [doc = "Bit 3 - Event Output 3"]
# [inline (always)]
# [must_use]
pub fn evout3 (& mut self) -> EVOUT3_W < 3 > { EVOUT3_W :: new (self) } # [doc = "Bit 4 - Event Output 4"]
# [inline (always)]
# [must_use]
pub fn evout4 (& mut self) -> EVOUT4_W < 4 > { EVOUT4_W :: new (self) } # [doc = "Bit 5 - Event Output 5"]
# [inline (always)]
# [must_use]
pub fn evout5 (& mut self) -> EVOUT5_W < 5 > { EVOUT5_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer EVSYS\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evsysroutea](index.html) module"]
pub struct EVSYSROUTEA_SPEC ; impl crate :: RegisterSpec for EVSYSROUTEA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evsysroutea::R](R) reader structure"]
impl crate :: Readable for EVSYSROUTEA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evsysroutea::W](W) writer structure"]
impl crate :: Writable for EVSYSROUTEA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVSYSROUTEA to value 0"]
impl crate :: Resettable for EVSYSROUTEA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCAROUTEA (rw) register accessor: an alias for `Reg<TCAROUTEA_SPEC>`"]
pub type TCAROUTEA = crate :: Reg < tcaroutea :: TCAROUTEA_SPEC > ; # [doc = "Port Multiplexer TCA"]
pub mod tcaroutea { # [doc = "Register `TCAROUTEA` reader"]
pub struct R (crate :: R < TCAROUTEA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCAROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCAROUTEA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCAROUTEA_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCAROUTEA` writer"]
pub struct W (crate :: W < TCAROUTEA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCAROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCAROUTEA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCAROUTEA_SPEC >) -> Self { W (writer) } } # [doc = "Field `TCA0` reader - Port Multiplexer TCA0"]
pub type TCA0_R = crate :: FieldReader < u8 , TCA0_A > ; # [doc = "Port Multiplexer TCA0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TCA0_A { # [doc = "0: TCA0 pins on PA\\[5:0\\]"]
PORTA = 0 , # [doc = "1: TCA0 pins on PB\\[5:0\\]"]
PORTB = 1 , # [doc = "2: TCA0 pins on PC\\[5:0\\]"]
PORTC = 2 , # [doc = "3: TCA0 pins on PD\\[5:0\\]"]
PORTD = 3 , # [doc = "4: TCA0 pins on PE\\[5:0\\]"]
PORTE = 4 , # [doc = "5: TCA0 pins on PF\\[5:0\\]"]
PORTF = 5 , } impl From < TCA0_A > for u8 { # [inline (always)]
fn from (variant : TCA0_A) -> Self { variant as _ } } impl TCA0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TCA0_A > { match self . bits { 0 => Some (TCA0_A :: PORTA) , 1 => Some (TCA0_A :: PORTB) , 2 => Some (TCA0_A :: PORTC) , 3 => Some (TCA0_A :: PORTD) , 4 => Some (TCA0_A :: PORTE) , 5 => Some (TCA0_A :: PORTF) , _ => None , } } # [doc = "Checks if the value of the field is `PORTA`"]
# [inline (always)]
pub fn is_porta (& self) -> bool { * self == TCA0_A :: PORTA } # [doc = "Checks if the value of the field is `PORTB`"]
# [inline (always)]
pub fn is_portb (& self) -> bool { * self == TCA0_A :: PORTB } # [doc = "Checks if the value of the field is `PORTC`"]
# [inline (always)]
pub fn is_portc (& self) -> bool { * self == TCA0_A :: PORTC } # [doc = "Checks if the value of the field is `PORTD`"]
# [inline (always)]
pub fn is_portd (& self) -> bool { * self == TCA0_A :: PORTD } # [doc = "Checks if the value of the field is `PORTE`"]
# [inline (always)]
pub fn is_porte (& self) -> bool { * self == TCA0_A :: PORTE } # [doc = "Checks if the value of the field is `PORTF`"]
# [inline (always)]
pub fn is_portf (& self) -> bool { * self == TCA0_A :: PORTF } } # [doc = "Field `TCA0` writer - Port Multiplexer TCA0"]
pub type TCA0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TCAROUTEA_SPEC , u8 , TCA0_A , 3 , O > ; impl < 'a , const O : u8 > TCA0_W < 'a , O > { # [doc = "TCA0 pins on PA\\[5:0\\]"]
# [inline (always)]
pub fn porta (self) -> & 'a mut W { self . variant (TCA0_A :: PORTA) } # [doc = "TCA0 pins on PB\\[5:0\\]"]
# [inline (always)]
pub fn portb (self) -> & 'a mut W { self . variant (TCA0_A :: PORTB) } # [doc = "TCA0 pins on PC\\[5:0\\]"]
# [inline (always)]
pub fn portc (self) -> & 'a mut W { self . variant (TCA0_A :: PORTC) } # [doc = "TCA0 pins on PD\\[5:0\\]"]
# [inline (always)]
pub fn portd (self) -> & 'a mut W { self . variant (TCA0_A :: PORTD) } # [doc = "TCA0 pins on PE\\[5:0\\]"]
# [inline (always)]
pub fn porte (self) -> & 'a mut W { self . variant (TCA0_A :: PORTE) } # [doc = "TCA0 pins on PF\\[5:0\\]"]
# [inline (always)]
pub fn portf (self) -> & 'a mut W { self . variant (TCA0_A :: PORTF) } } impl R { # [doc = "Bits 0:2 - Port Multiplexer TCA0"]
# [inline (always)]
pub fn tca0 (& self) -> TCA0_R { TCA0_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Port Multiplexer TCA0"]
# [inline (always)]
# [must_use]
pub fn tca0 (& mut self) -> TCA0_W < 0 > { TCA0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer TCA\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcaroutea](index.html) module"]
pub struct TCAROUTEA_SPEC ; impl crate :: RegisterSpec for TCAROUTEA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tcaroutea::R](R) reader structure"]
impl crate :: Readable for TCAROUTEA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcaroutea::W](W) writer structure"]
impl crate :: Writable for TCAROUTEA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCAROUTEA to value 0"]
impl crate :: Resettable for TCAROUTEA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCBROUTEA (rw) register accessor: an alias for `Reg<TCBROUTEA_SPEC>`"]
pub type TCBROUTEA = crate :: Reg < tcbroutea :: TCBROUTEA_SPEC > ; # [doc = "Port Multiplexer TCB"]
pub mod tcbroutea { # [doc = "Register `TCBROUTEA` reader"]
pub struct R (crate :: R < TCBROUTEA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCBROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCBROUTEA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCBROUTEA_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCBROUTEA` writer"]
pub struct W (crate :: W < TCBROUTEA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCBROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCBROUTEA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCBROUTEA_SPEC >) -> Self { W (writer) } } # [doc = "Field `TCB0` reader - Port Multiplexer TCB0"]
pub type TCB0_R = crate :: BitReader < bool > ; # [doc = "Field `TCB0` writer - Port Multiplexer TCB0"]
pub type TCB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCBROUTEA_SPEC , bool , O > ; # [doc = "Field `TCB1` reader - Port Multiplexer TCB1"]
pub type TCB1_R = crate :: BitReader < bool > ; # [doc = "Field `TCB1` writer - Port Multiplexer TCB1"]
pub type TCB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCBROUTEA_SPEC , bool , O > ; # [doc = "Field `TCB2` reader - Port Multiplexer TCB2"]
pub type TCB2_R = crate :: BitReader < bool > ; # [doc = "Field `TCB2` writer - Port Multiplexer TCB2"]
pub type TCB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCBROUTEA_SPEC , bool , O > ; # [doc = "Field `TCB3` reader - Port Multiplexer TCB3"]
pub type TCB3_R = crate :: BitReader < bool > ; # [doc = "Field `TCB3` writer - Port Multiplexer TCB3"]
pub type TCB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCBROUTEA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Multiplexer TCB0"]
# [inline (always)]
pub fn tcb0 (& self) -> TCB0_R { TCB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Multiplexer TCB1"]
# [inline (always)]
pub fn tcb1 (& self) -> TCB1_R { TCB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Port Multiplexer TCB2"]
# [inline (always)]
pub fn tcb2 (& self) -> TCB2_R { TCB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Port Multiplexer TCB3"]
# [inline (always)]
pub fn tcb3 (& self) -> TCB3_R { TCB3_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Multiplexer TCB0"]
# [inline (always)]
# [must_use]
pub fn tcb0 (& mut self) -> TCB0_W < 0 > { TCB0_W :: new (self) } # [doc = "Bit 1 - Port Multiplexer TCB1"]
# [inline (always)]
# [must_use]
pub fn tcb1 (& mut self) -> TCB1_W < 1 > { TCB1_W :: new (self) } # [doc = "Bit 2 - Port Multiplexer TCB2"]
# [inline (always)]
# [must_use]
pub fn tcb2 (& mut self) -> TCB2_W < 2 > { TCB2_W :: new (self) } # [doc = "Bit 3 - Port Multiplexer TCB3"]
# [inline (always)]
# [must_use]
pub fn tcb3 (& mut self) -> TCB3_W < 3 > { TCB3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer TCB\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcbroutea](index.html) module"]
pub struct TCBROUTEA_SPEC ; impl crate :: RegisterSpec for TCBROUTEA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tcbroutea::R](R) reader structure"]
impl crate :: Readable for TCBROUTEA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcbroutea::W](W) writer structure"]
impl crate :: Writable for TCBROUTEA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCBROUTEA to value 0"]
impl crate :: Resettable for TCBROUTEA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWISPIROUTEA (rw) register accessor: an alias for `Reg<TWISPIROUTEA_SPEC>`"]
pub type TWISPIROUTEA = crate :: Reg < twispiroutea :: TWISPIROUTEA_SPEC > ; # [doc = "Port Multiplexer TWI and SPI"]
pub mod twispiroutea { # [doc = "Register `TWISPIROUTEA` reader"]
pub struct R (crate :: R < TWISPIROUTEA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWISPIROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWISPIROUTEA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWISPIROUTEA_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWISPIROUTEA` writer"]
pub struct W (crate :: W < TWISPIROUTEA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWISPIROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWISPIROUTEA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWISPIROUTEA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPI0` reader - Port Multiplexer SPI0"]
pub type SPI0_R = crate :: FieldReader < u8 , SPI0_A > ; # [doc = "Port Multiplexer SPI0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SPI0_A { # [doc = "0: SPI0 on PA\\[7:4\\]"]
DEFAULT = 0 , # [doc = "1: SPI0 on PC\\[3:0\\]"]
ALT1 = 1 , # [doc = "2: SPI0 on PE\\[3:0\\]"]
ALT2 = 2 , # [doc = "3: Not connected to any pins"]
NONE = 3 , } impl From < SPI0_A > for u8 { # [inline (always)]
fn from (variant : SPI0_A) -> Self { variant as _ } } impl SPI0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SPI0_A { match self . bits { 0 => SPI0_A :: DEFAULT , 1 => SPI0_A :: ALT1 , 2 => SPI0_A :: ALT2 , 3 => SPI0_A :: NONE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == SPI0_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALT1`"]
# [inline (always)]
pub fn is_alt1 (& self) -> bool { * self == SPI0_A :: ALT1 } # [doc = "Checks if the value of the field is `ALT2`"]
# [inline (always)]
pub fn is_alt2 (& self) -> bool { * self == SPI0_A :: ALT2 } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SPI0_A :: NONE } } # [doc = "Field `SPI0` writer - Port Multiplexer SPI0"]
pub type SPI0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWISPIROUTEA_SPEC , u8 , SPI0_A , 2 , O > ; impl < 'a , const O : u8 > SPI0_W < 'a , O > { # [doc = "SPI0 on PA\\[7:4\\]"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (SPI0_A :: DEFAULT) } # [doc = "SPI0 on PC\\[3:0\\]"]
# [inline (always)]
pub fn alt1 (self) -> & 'a mut W { self . variant (SPI0_A :: ALT1) } # [doc = "SPI0 on PE\\[3:0\\]"]
# [inline (always)]
pub fn alt2 (self) -> & 'a mut W { self . variant (SPI0_A :: ALT2) } # [doc = "Not connected to any pins"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SPI0_A :: NONE) } } # [doc = "Field `TWI0` reader - Port Multiplexer TWI0"]
pub type TWI0_R = crate :: FieldReader < u8 , TWI0_A > ; # [doc = "Port Multiplexer TWI0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TWI0_A { # [doc = "0: SCL/SDA on PA\\[3:2\\], Slave mode on PC\\[3:2\\]
in dual TWI mode"]
DEFAULT = 0 , # [doc = "1: SCL/SDA on PA\\[3:2\\], Slave mode on PF\\[3:2\\]
in dual TWI mode"]
ALT1 = 1 , # [doc = "2: SCL/SDA on PC\\[3:2\\], Slave mode on PF\\[3:2\\]
in dual TWI mode"]
ALT2 = 2 , # [doc = "3: Not connected to any pins"]
NONE = 3 , } impl From < TWI0_A > for u8 { # [inline (always)]
fn from (variant : TWI0_A) -> Self { variant as _ } } impl TWI0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TWI0_A { match self . bits { 0 => TWI0_A :: DEFAULT , 1 => TWI0_A :: ALT1 , 2 => TWI0_A :: ALT2 , 3 => TWI0_A :: NONE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == TWI0_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALT1`"]
# [inline (always)]
pub fn is_alt1 (& self) -> bool { * self == TWI0_A :: ALT1 } # [doc = "Checks if the value of the field is `ALT2`"]
# [inline (always)]
pub fn is_alt2 (& self) -> bool { * self == TWI0_A :: ALT2 } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == TWI0_A :: NONE } } # [doc = "Field `TWI0` writer - Port Multiplexer TWI0"]
pub type TWI0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWISPIROUTEA_SPEC , u8 , TWI0_A , 2 , O > ; impl < 'a , const O : u8 > TWI0_W < 'a , O > { # [doc = "SCL/SDA on PA\\[3:2\\], Slave mode on PC\\[3:2\\]
in dual TWI mode"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (TWI0_A :: DEFAULT) } # [doc = "SCL/SDA on PA\\[3:2\\], Slave mode on PF\\[3:2\\]
in dual TWI mode"]
# [inline (always)]
pub fn alt1 (self) -> & 'a mut W { self . variant (TWI0_A :: ALT1) } # [doc = "SCL/SDA on PC\\[3:2\\], Slave mode on PF\\[3:2\\]
in dual TWI mode"]
# [inline (always)]
pub fn alt2 (self) -> & 'a mut W { self . variant (TWI0_A :: ALT2) } # [doc = "Not connected to any pins"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (TWI0_A :: NONE) } } impl R { # [doc = "Bits 0:1 - Port Multiplexer SPI0"]
# [inline (always)]
pub fn spi0 (& self) -> SPI0_R { SPI0_R :: new (self . bits & 3) } # [doc = "Bits 4:5 - Port Multiplexer TWI0"]
# [inline (always)]
pub fn twi0 (& self) -> TWI0_R { TWI0_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Port Multiplexer SPI0"]
# [inline (always)]
# [must_use]
pub fn spi0 (& mut self) -> SPI0_W < 0 > { SPI0_W :: new (self) } # [doc = "Bits 4:5 - Port Multiplexer TWI0"]
# [inline (always)]
# [must_use]
pub fn twi0 (& mut self) -> TWI0_W < 4 > { TWI0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer TWI and SPI\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twispiroutea](index.html) module"]
pub struct TWISPIROUTEA_SPEC ; impl crate :: RegisterSpec for TWISPIROUTEA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twispiroutea::R](R) reader structure"]
impl crate :: Readable for TWISPIROUTEA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twispiroutea::W](W) writer structure"]
impl crate :: Writable for TWISPIROUTEA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWISPIROUTEA to value 0"]
impl crate :: Resettable for TWISPIROUTEA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USARTROUTEA (rw) register accessor: an alias for `Reg<USARTROUTEA_SPEC>`"]
pub type USARTROUTEA = crate :: Reg < usartroutea :: USARTROUTEA_SPEC > ; # [doc = "Port Multiplexer USART register A"]
pub mod usartroutea { # [doc = "Register `USARTROUTEA` reader"]
pub struct R (crate :: R < USARTROUTEA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USARTROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USARTROUTEA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USARTROUTEA_SPEC >) -> Self { R (reader) } } # [doc = "Register `USARTROUTEA` writer"]
pub struct W (crate :: W < USARTROUTEA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USARTROUTEA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USARTROUTEA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USARTROUTEA_SPEC >) -> Self { W (writer) } } # [doc = "Field `USART0` reader - Port Multiplexer USART0"]
pub type USART0_R = crate :: FieldReader < u8 , USART0_A > ; # [doc = "Port Multiplexer USART0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum USART0_A { # [doc = "0: USART0 on PA\\[3:0\\]"]
DEFAULT = 0 , # [doc = "1: USART0 on PA\\[7:4\\]"]
ALT1 = 1 , # [doc = "3: Not connected to any pins"]
NONE = 3 , } impl From < USART0_A > for u8 { # [inline (always)]
fn from (variant : USART0_A) -> Self { variant as _ } } impl USART0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < USART0_A > { match self . bits { 0 => Some (USART0_A :: DEFAULT) , 1 => Some (USART0_A :: ALT1) , 3 => Some (USART0_A :: NONE) , _ => None , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == USART0_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALT1`"]
# [inline (always)]
pub fn is_alt1 (& self) -> bool { * self == USART0_A :: ALT1 } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == USART0_A :: NONE } } # [doc = "Field `USART0` writer - Port Multiplexer USART0"]
pub type USART0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USARTROUTEA_SPEC , u8 , USART0_A , 2 , O > ; impl < 'a , const O : u8 > USART0_W < 'a , O > { # [doc = "USART0 on PA\\[3:0\\]"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (USART0_A :: DEFAULT) } # [doc = "USART0 on PA\\[7:4\\]"]
# [inline (always)]
pub fn alt1 (self) -> & 'a mut W { self . variant (USART0_A :: ALT1) } # [doc = "Not connected to any pins"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (USART0_A :: NONE) } } # [doc = "Field `USART1` reader - Port Multiplexer USART1"]
pub type USART1_R = crate :: FieldReader < u8 , USART1_A > ; # [doc = "Port Multiplexer USART1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum USART1_A { # [doc = "0: USART1 on PC\\[3:0\\]"]
DEFAULT = 0 , # [doc = "1: USART1 on PC\\[7:4\\]"]
ALT1 = 1 , # [doc = "3: Not connected to any pins"]
NONE = 3 , } impl From < USART1_A > for u8 { # [inline (always)]
fn from (variant : USART1_A) -> Self { variant as _ } } impl USART1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < USART1_A > { match self . bits { 0 => Some (USART1_A :: DEFAULT) , 1 => Some (USART1_A :: ALT1) , 3 => Some (USART1_A :: NONE) , _ => None , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == USART1_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALT1`"]
# [inline (always)]
pub fn is_alt1 (& self) -> bool { * self == USART1_A :: ALT1 } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == USART1_A :: NONE } } # [doc = "Field `USART1` writer - Port Multiplexer USART1"]
pub type USART1_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USARTROUTEA_SPEC , u8 , USART1_A , 2 , O > ; impl < 'a , const O : u8 > USART1_W < 'a , O > { # [doc = "USART1 on PC\\[3:0\\]"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (USART1_A :: DEFAULT) } # [doc = "USART1 on PC\\[7:4\\]"]
# [inline (always)]
pub fn alt1 (self) -> & 'a mut W { self . variant (USART1_A :: ALT1) } # [doc = "Not connected to any pins"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (USART1_A :: NONE) } } # [doc = "Field `USART2` reader - Port Multiplexer USART2"]
pub type USART2_R = crate :: FieldReader < u8 , USART2_A > ; # [doc = "Port Multiplexer USART2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum USART2_A { # [doc = "0: USART2 on PF\\[3:0\\]"]
DEFAULT = 0 , # [doc = "1: USART2 on PF\\[6:4\\]"]
ALT1 = 1 , # [doc = "3: Not connected to any pins"]
NONE = 3 , } impl From < USART2_A > for u8 { # [inline (always)]
fn from (variant : USART2_A) -> Self { variant as _ } } impl USART2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < USART2_A > { match self . bits { 0 => Some (USART2_A :: DEFAULT) , 1 => Some (USART2_A :: ALT1) , 3 => Some (USART2_A :: NONE) , _ => None , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == USART2_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALT1`"]
# [inline (always)]
pub fn is_alt1 (& self) -> bool { * self == USART2_A :: ALT1 } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == USART2_A :: NONE } } # [doc = "Field `USART2` writer - Port Multiplexer USART2"]
pub type USART2_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USARTROUTEA_SPEC , u8 , USART2_A , 2 , O > ; impl < 'a , const O : u8 > USART2_W < 'a , O > { # [doc = "USART2 on PF\\[3:0\\]"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (USART2_A :: DEFAULT) } # [doc = "USART2 on PF\\[6:4\\]"]
# [inline (always)]
pub fn alt1 (self) -> & 'a mut W { self . variant (USART2_A :: ALT1) } # [doc = "Not connected to any pins"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (USART2_A :: NONE) } } # [doc = "Field `USART3` reader - Port Multiplexer USART3"]
pub type USART3_R = crate :: FieldReader < u8 , USART3_A > ; # [doc = "Port Multiplexer USART3\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum USART3_A { # [doc = "0: USART3 on PB\\[3:0\\]"]
DEFAULT = 0 , # [doc = "1: USART3 on PB\\[5:4\\]"]
ALT1 = 1 , # [doc = "3: Not connected to any pins"]
NONE = 3 , } impl From < USART3_A > for u8 { # [inline (always)]
fn from (variant : USART3_A) -> Self { variant as _ } } impl USART3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < USART3_A > { match self . bits { 0 => Some (USART3_A :: DEFAULT) , 1 => Some (USART3_A :: ALT1) , 3 => Some (USART3_A :: NONE) , _ => None , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == USART3_A :: DEFAULT } # [doc = "Checks if the value of the field is `ALT1`"]
# [inline (always)]
pub fn is_alt1 (& self) -> bool { * self == USART3_A :: ALT1 } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == USART3_A :: NONE } } # [doc = "Field `USART3` writer - Port Multiplexer USART3"]
pub type USART3_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , USARTROUTEA_SPEC , u8 , USART3_A , 2 , O > ; impl < 'a , const O : u8 > USART3_W < 'a , O > { # [doc = "USART3 on PB\\[3:0\\]"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (USART3_A :: DEFAULT) } # [doc = "USART3 on PB\\[5:4\\]"]
# [inline (always)]
pub fn alt1 (self) -> & 'a mut W { self . variant (USART3_A :: ALT1) } # [doc = "Not connected to any pins"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (USART3_A :: NONE) } } impl R { # [doc = "Bits 0:1 - Port Multiplexer USART0"]
# [inline (always)]
pub fn usart0 (& self) -> USART0_R { USART0_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Multiplexer USART1"]
# [inline (always)]
pub fn usart1 (& self) -> USART1_R { USART1_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Port Multiplexer USART2"]
# [inline (always)]
pub fn usart2 (& self) -> USART2_R { USART2_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Port Multiplexer USART3"]
# [inline (always)]
pub fn usart3 (& self) -> USART3_R { USART3_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Port Multiplexer USART0"]
# [inline (always)]
# [must_use]
pub fn usart0 (& mut self) -> USART0_W < 0 > { USART0_W :: new (self) } # [doc = "Bits 2:3 - Port Multiplexer USART1"]
# [inline (always)]
# [must_use]
pub fn usart1 (& mut self) -> USART1_W < 2 > { USART1_W :: new (self) } # [doc = "Bits 4:5 - Port Multiplexer USART2"]
# [inline (always)]
# [must_use]
pub fn usart2 (& mut self) -> USART2_W < 4 > { USART2_W :: new (self) } # [doc = "Bits 6:7 - Port Multiplexer USART3"]
# [inline (always)]
# [must_use]
pub fn usart3 (& mut self) -> USART3_W < 6 > { USART3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port Multiplexer USART register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [usartroutea](index.html) module"]
pub struct USARTROUTEA_SPEC ; impl crate :: RegisterSpec for USARTROUTEA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [usartroutea::R](R) reader structure"]
impl crate :: Readable for USARTROUTEA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [usartroutea::W](W) writer structure"]
impl crate :: Writable for USARTROUTEA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USARTROUTEA to value 0"]
impl crate :: Resettable for USARTROUTEA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Reset controller"]
pub struct RSTCTRL { _marker : PhantomData < * const () > } unsafe impl Send for RSTCTRL { } impl RSTCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const rstctrl :: RegisterBlock = 0x40 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rstctrl :: RegisterBlock { Self :: PTR } } impl Deref for RSTCTRL { type Target = rstctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RSTCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RSTCTRL") . finish () } } # [doc = "Reset controller"]
pub mod rstctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Reset Flags"]
pub rstfr : RSTFR , # [doc = "0x01 - Software Reset"]
pub swrr : SWRR , } # [doc = "RSTFR (rw) register accessor: an alias for `Reg<RSTFR_SPEC>`"]
pub type RSTFR = crate :: Reg < rstfr :: RSTFR_SPEC > ; # [doc = "Reset Flags"]
pub mod rstfr { # [doc = "Register `RSTFR` reader"]
pub struct R (crate :: R < RSTFR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RSTFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RSTFR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RSTFR_SPEC >) -> Self { R (reader) } } # [doc = "Register `RSTFR` writer"]
pub struct W (crate :: W < RSTFR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RSTFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RSTFR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RSTFR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PORF` reader - Power on Reset flag"]
pub type PORF_R = crate :: BitReader < bool > ; # [doc = "Field `PORF` writer - Power on Reset flag"]
pub type PORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `BORF` reader - Brown out detector Reset flag"]
pub type BORF_R = crate :: BitReader < bool > ; # [doc = "Field `BORF` writer - Brown out detector Reset flag"]
pub type BORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `EXTRF` reader - External Reset flag"]
pub type EXTRF_R = crate :: BitReader < bool > ; # [doc = "Field `EXTRF` writer - External Reset flag"]
pub type EXTRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `WDRF` reader - Watch dog Reset flag"]
pub type WDRF_R = crate :: BitReader < bool > ; # [doc = "Field `WDRF` writer - Watch dog Reset flag"]
pub type WDRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `SWRF` reader - Software Reset flag"]
pub type SWRF_R = crate :: BitReader < bool > ; # [doc = "Field `SWRF` writer - Software Reset flag"]
pub type SWRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; # [doc = "Field `UPDIRF` reader - UPDI Reset flag"]
pub type UPDIRF_R = crate :: BitReader < bool > ; # [doc = "Field `UPDIRF` writer - UPDI Reset flag"]
pub type UPDIRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RSTFR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Power on Reset flag"]
# [inline (always)]
pub fn porf (& self) -> PORF_R { PORF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Brown out detector Reset flag"]
# [inline (always)]
pub fn borf (& self) -> BORF_R { BORF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - External Reset flag"]
# [inline (always)]
pub fn extrf (& self) -> EXTRF_R { EXTRF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Watch dog Reset flag"]
# [inline (always)]
pub fn wdrf (& self) -> WDRF_R { WDRF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Software Reset flag"]
# [inline (always)]
pub fn swrf (& self) -> SWRF_R { SWRF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - UPDI Reset flag"]
# [inline (always)]
pub fn updirf (& self) -> UPDIRF_R { UPDIRF_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Power on Reset flag"]
# [inline (always)]
# [must_use]
pub fn porf (& mut self) -> PORF_W < 0 > { PORF_W :: new (self) } # [doc = "Bit 1 - Brown out detector Reset flag"]
# [inline (always)]
# [must_use]
pub fn borf (& mut self) -> BORF_W < 1 > { BORF_W :: new (self) } # [doc = "Bit 2 - External Reset flag"]
# [inline (always)]
# [must_use]
pub fn extrf (& mut self) -> EXTRF_W < 2 > { EXTRF_W :: new (self) } # [doc = "Bit 3 - Watch dog Reset flag"]
# [inline (always)]
# [must_use]
pub fn wdrf (& mut self) -> WDRF_W < 3 > { WDRF_W :: new (self) } # [doc = "Bit 4 - Software Reset flag"]
# [inline (always)]
# [must_use]
pub fn swrf (& mut self) -> SWRF_W < 4 > { SWRF_W :: new (self) } # [doc = "Bit 5 - UPDI Reset flag"]
# [inline (always)]
# [must_use]
pub fn updirf (& mut self) -> UPDIRF_W < 5 > { UPDIRF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Reset Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rstfr](index.html) module"]
pub struct RSTFR_SPEC ; impl crate :: RegisterSpec for RSTFR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rstfr::R](R) reader structure"]
impl crate :: Readable for RSTFR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rstfr::W](W) writer structure"]
impl crate :: Writable for RSTFR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RSTFR to value 0"]
impl crate :: Resettable for RSTFR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SWRR (rw) register accessor: an alias for `Reg<SWRR_SPEC>`"]
pub type SWRR = crate :: Reg < swrr :: SWRR_SPEC > ; # [doc = "Software Reset"]
pub mod swrr { # [doc = "Register `SWRR` reader"]
pub struct R (crate :: R < SWRR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SWRR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SWRR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SWRR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SWRR` writer"]
pub struct W (crate :: W < SWRR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SWRR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SWRR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SWRR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRE` reader - Software reset enable"]
pub type SWRE_R = crate :: BitReader < bool > ; # [doc = "Field `SWRE` writer - Software reset enable"]
pub type SWRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SWRR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Software reset enable"]
# [inline (always)]
pub fn swre (& self) -> SWRE_R { SWRE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Software reset enable"]
# [inline (always)]
# [must_use]
pub fn swre (& mut self) -> SWRE_W < 0 > { SWRE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Software Reset\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swrr](index.html) module"]
pub struct SWRR_SPEC ; impl crate :: RegisterSpec for SWRR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [swrr::R](R) reader structure"]
impl crate :: Readable for SWRR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [swrr::W](W) writer structure"]
impl crate :: Writable for SWRR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SWRR to value 0"]
impl crate :: Resettable for SWRR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Real-Time Counter"]
pub struct RTC { _marker : PhantomData < * const () > } unsafe impl Send for RTC { } impl RTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const rtc :: RegisterBlock = 0x0140 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rtc :: RegisterBlock { Self :: PTR } } impl Deref for RTC { type Target = rtc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RTC") . finish () } } # [doc = "Real-Time Counter"]
pub mod rtc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Status"]
pub status : STATUS , # [doc = "0x02 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x04 - Temporary"]
pub temp : TEMP , # [doc = "0x05 - Debug control"]
pub dbgctrl : DBGCTRL , # [doc = "0x06 - Calibration"]
pub calib : CALIB , # [doc = "0x07 - Clock Select"]
pub clksel : CLKSEL , # [doc = "0x08 - Counter"]
pub cnt : CNT , # [doc = "0x0a - Period"]
pub per : PER , # [doc = "0x0c - Compare"]
pub cmp : CMP , _reserved11 : [u8 ; 0x02]
, # [doc = "0x10 - PIT Control A"]
pub pitctrla : PITCTRLA , # [doc = "0x11 - PIT Status"]
pub pitstatus : PITSTATUS , # [doc = "0x12 - PIT Interrupt Control"]
pub pitintctrl : PITINTCTRL , # [doc = "0x13 - PIT Interrupt Flags"]
pub pitintflags : PITINTFLAGS , _reserved15 : [u8 ; 0x01]
, # [doc = "0x15 - PIT Debug control"]
pub pitdbgctrl : PITDBGCTRL , } # [doc = "CALIB (rw) register accessor: an alias for `Reg<CALIB_SPEC>`"]
pub type CALIB = crate :: Reg < calib :: CALIB_SPEC > ; # [doc = "Calibration"]
pub mod calib { # [doc = "Register `CALIB` reader"]
pub struct R (crate :: R < CALIB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CALIB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CALIB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CALIB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CALIB` writer"]
pub struct W (crate :: W < CALIB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CALIB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CALIB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CALIB_SPEC >) -> Self { W (writer) } } # [doc = "Field `ERROR` reader - Error Correction Value"]
pub type ERROR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ERROR` writer - Error Correction Value"]
pub type ERROR_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CALIB_SPEC , u8 , u8 , 7 , O > ; # [doc = "Field `SIGN` reader - Error Correction Sign Bit"]
pub type SIGN_R = crate :: BitReader < bool > ; # [doc = "Field `SIGN` writer - Error Correction Sign Bit"]
pub type SIGN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CALIB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:6 - Error Correction Value"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (self . bits & 0x7f) } # [doc = "Bit 7 - Error Correction Sign Bit"]
# [inline (always)]
pub fn sign (& self) -> SIGN_R { SIGN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:6 - Error Correction Value"]
# [inline (always)]
# [must_use]
pub fn error (& mut self) -> ERROR_W < 0 > { ERROR_W :: new (self) } # [doc = "Bit 7 - Error Correction Sign Bit"]
# [inline (always)]
# [must_use]
pub fn sign (& mut self) -> SIGN_W < 7 > { SIGN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calib](index.html) module"]
pub struct CALIB_SPEC ; impl crate :: RegisterSpec for CALIB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [calib::R](R) reader structure"]
impl crate :: Readable for CALIB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [calib::W](W) writer structure"]
impl crate :: Writable for CALIB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CALIB to value 0"]
impl crate :: Resettable for CALIB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CLKSEL (rw) register accessor: an alias for `Reg<CLKSEL_SPEC>`"]
pub type CLKSEL = crate :: Reg < clksel :: CLKSEL_SPEC > ; # [doc = "Clock Select"]
pub mod clksel { # [doc = "Register `CLKSEL` reader"]
pub struct R (crate :: R < CLKSEL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKSEL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKSEL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKSEL` writer"]
pub struct W (crate :: W < CLKSEL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKSEL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKSEL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Internal 32kHz OSC"]
INT32K = 0 , # [doc = "1: Internal 1kHz OSC"]
INT1K = 1 , # [doc = "2: 32KHz Crystal OSC"]
TOSC32K = 2 , # [doc = "3: External Clock"]
EXTCLK = 3 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: INT32K , 1 => CLKSEL_A :: INT1K , 2 => CLKSEL_A :: TOSC32K , 3 => CLKSEL_A :: EXTCLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT32K`"]
# [inline (always)]
pub fn is_int32k (& self) -> bool { * self == CLKSEL_A :: INT32K } # [doc = "Checks if the value of the field is `INT1K`"]
# [inline (always)]
pub fn is_int1k (& self) -> bool { * self == CLKSEL_A :: INT1K } # [doc = "Checks if the value of the field is `TOSC32K`"]
# [inline (always)]
pub fn is_tosc32k (& self) -> bool { * self == CLKSEL_A :: TOSC32K } # [doc = "Checks if the value of the field is `EXTCLK`"]
# [inline (always)]
pub fn is_extclk (& self) -> bool { * self == CLKSEL_A :: EXTCLK } } # [doc = "Field `CLKSEL` writer - Clock Select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CLKSEL_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Internal 32kHz OSC"]
# [inline (always)]
pub fn int32k (self) -> & 'a mut W { self . variant (CLKSEL_A :: INT32K) } # [doc = "Internal 1kHz OSC"]
# [inline (always)]
pub fn int1k (self) -> & 'a mut W { self . variant (CLKSEL_A :: INT1K) } # [doc = "32KHz Crystal OSC"]
# [inline (always)]
pub fn tosc32k (self) -> & 'a mut W { self . variant (CLKSEL_A :: TOSC32K) } # [doc = "External Clock"]
# [inline (always)]
pub fn extclk (self) -> & 'a mut W { self . variant (CLKSEL_A :: EXTCLK) } } impl R { # [doc = "Bits 0:1 - Clock Select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clksel](index.html) module"]
pub struct CLKSEL_SPEC ; impl crate :: RegisterSpec for CLKSEL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [clksel::R](R) reader structure"]
impl crate :: Readable for CLKSEL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clksel::W](W) writer structure"]
impl crate :: Writable for CLKSEL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CLKSEL to value 0"]
impl crate :: Resettable for CLKSEL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP (rw) register accessor: an alias for `Reg<CMP_SPEC>`"]
pub type CMP = crate :: Reg < cmp :: CMP_SPEC > ; # [doc = "Compare"]
pub mod cmp { # [doc = "Register `CMP` reader"]
pub struct R (crate :: R < CMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP` writer"]
pub struct W (crate :: W < CMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp](index.html) module"]
pub struct CMP_SPEC ; impl crate :: RegisterSpec for CMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp::R](R) reader structure"]
impl crate :: Readable for CMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp::W](W) writer structure"]
impl crate :: Writable for CMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP to value 0"]
impl crate :: Resettable for CMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Counter"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RTCEN` reader - Enable"]
pub type RTCEN_R = crate :: BitReader < bool > ; # [doc = "Field `RTCEN` writer - Enable"]
pub type RTCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CORREN` reader - Correction enable"]
pub type CORREN_R = crate :: BitReader < bool > ; # [doc = "Field `CORREN` writer - Correction enable"]
pub type CORREN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `PRESCALER` reader - Prescaling Factor"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Prescaling Factor\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: RTC Clock / 1"]
DIV1 = 0 , # [doc = "1: RTC Clock / 2"]
DIV2 = 1 , # [doc = "2: RTC Clock / 4"]
DIV4 = 2 , # [doc = "3: RTC Clock / 8"]
DIV8 = 3 , # [doc = "4: RTC Clock / 16"]
DIV16 = 4 , # [doc = "5: RTC Clock / 32"]
DIV32 = 5 , # [doc = "6: RTC Clock / 64"]
DIV64 = 6 , # [doc = "7: RTC Clock / 128"]
DIV128 = 7 , # [doc = "8: RTC Clock / 256"]
DIV256 = 8 , # [doc = "9: RTC Clock / 512"]
DIV512 = 9 , # [doc = "10: RTC Clock / 1024"]
DIV1024 = 10 , # [doc = "11: RTC Clock / 2048"]
DIV2048 = 11 , # [doc = "12: RTC Clock / 4096"]
DIV4096 = 12 , # [doc = "13: RTC Clock / 8192"]
DIV8192 = 13 , # [doc = "14: RTC Clock / 16384"]
DIV16384 = 14 , # [doc = "15: RTC Clock / 32768"]
DIV32768 = 15 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV32 , 6 => PRESCALER_A :: DIV64 , 7 => PRESCALER_A :: DIV128 , 8 => PRESCALER_A :: DIV256 , 9 => PRESCALER_A :: DIV512 , 10 => PRESCALER_A :: DIV1024 , 11 => PRESCALER_A :: DIV2048 , 12 => PRESCALER_A :: DIV4096 , 13 => PRESCALER_A :: DIV8192 , 14 => PRESCALER_A :: DIV16384 , 15 => PRESCALER_A :: DIV32768 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESCALER_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PRESCALER_A :: DIV512 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } # [doc = "Checks if the value of the field is `DIV2048`"]
# [inline (always)]
pub fn is_div2048 (& self) -> bool { * self == PRESCALER_A :: DIV2048 } # [doc = "Checks if the value of the field is `DIV4096`"]
# [inline (always)]
pub fn is_div4096 (& self) -> bool { * self == PRESCALER_A :: DIV4096 } # [doc = "Checks if the value of the field is `DIV8192`"]
# [inline (always)]
pub fn is_div8192 (& self) -> bool { * self == PRESCALER_A :: DIV8192 } # [doc = "Checks if the value of the field is `DIV16384`"]
# [inline (always)]
pub fn is_div16384 (& self) -> bool { * self == PRESCALER_A :: DIV16384 } # [doc = "Checks if the value of the field is `DIV32768`"]
# [inline (always)]
pub fn is_div32768 (& self) -> bool { * self == PRESCALER_A :: DIV32768 } } # [doc = "Field `PRESCALER` writer - Prescaling Factor"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , PRESCALER_A , 4 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "RTC Clock / 1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "RTC Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "RTC Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "RTC Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "RTC Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "RTC Clock / 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32) } # [doc = "RTC Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "RTC Clock / 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } # [doc = "RTC Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "RTC Clock / 512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV512) } # [doc = "RTC Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } # [doc = "RTC Clock / 2048"]
# [inline (always)]
pub fn div2048 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2048) } # [doc = "RTC Clock / 4096"]
# [inline (always)]
pub fn div4096 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4096) } # [doc = "RTC Clock / 8192"]
# [inline (always)]
pub fn div8192 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8192) } # [doc = "RTC Clock / 16384"]
# [inline (always)]
pub fn div16384 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16384) } # [doc = "RTC Clock / 32768"]
# [inline (always)]
pub fn div32768 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32768) } } # [doc = "Field `RUNSTDBY` reader - Run In Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run In Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn rtcen (& self) -> RTCEN_R { RTCEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Correction enable"]
# [inline (always)]
pub fn corren (& self) -> CORREN_R { CORREN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:6 - Prescaling Factor"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new ((self . bits >> 3) & 0x0f) } # [doc = "Bit 7 - Run In Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn rtcen (& mut self) -> RTCEN_W < 0 > { RTCEN_W :: new (self) } # [doc = "Bit 2 - Correction enable"]
# [inline (always)]
# [must_use]
pub fn corren (& mut self) -> CORREN_W < 2 > { CORREN_W :: new (self) } # [doc = "Bits 3:6 - Prescaling Factor"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 3 > { PRESCALER_W :: new (self) } # [doc = "Bit 7 - Run In Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 7 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Run in debug"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Run in debug"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Run in debug"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Run in debug"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt enable"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `CMP` reader - Compare Match Interrupt enable"]
pub type CMP_R = crate :: BitReader < bool > ; # [doc = "Field `CMP` writer - Compare Match Interrupt enable"]
pub type CMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare Match Interrupt enable"]
# [inline (always)]
pub fn cmp (& self) -> CMP_R { CMP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt enable"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 1 - Compare Match Interrupt enable"]
# [inline (always)]
# [must_use]
pub fn cmp (& mut self) -> CMP_W < 1 > { CMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Flag"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Flag"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CMP` reader - Compare Match Interrupt"]
pub type CMP_R = crate :: BitReader < bool > ; # [doc = "Field `CMP` writer - Compare Match Interrupt"]
pub type CMP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare Match Interrupt"]
# [inline (always)]
pub fn cmp (& self) -> CMP_R { CMP_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 1 - Compare Match Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp (& mut self) -> CMP_W < 1 > { CMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITCTRLA (rw) register accessor: an alias for `Reg<PITCTRLA_SPEC>`"]
pub type PITCTRLA = crate :: Reg < pitctrla :: PITCTRLA_SPEC > ; # [doc = "PIT Control A"]
pub mod pitctrla { # [doc = "Register `PITCTRLA` reader"]
pub struct R (crate :: R < PITCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `PITCTRLA` writer"]
pub struct W (crate :: W < PITCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PITCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PITCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PITCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `PITEN` reader - Enable"]
pub type PITEN_R = crate :: BitReader < bool > ; # [doc = "Field `PITEN` writer - Enable"]
pub type PITEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PITCTRLA_SPEC , bool , O > ; # [doc = "Field `PERIOD` reader - Period"]
pub type PERIOD_R = crate :: FieldReader < u8 , PERIOD_A > ; # [doc = "Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PERIOD_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: RTC Clock Cycles 4"]
CYC4 = 1 , # [doc = "2: RTC Clock Cycles 8"]
CYC8 = 2 , # [doc = "3: RTC Clock Cycles 16"]
CYC16 = 3 , # [doc = "4: RTC Clock Cycles 32"]
CYC32 = 4 , # [doc = "5: RTC Clock Cycles 64"]
CYC64 = 5 , # [doc = "6: RTC Clock Cycles 128"]
CYC128 = 6 , # [doc = "7: RTC Clock Cycles 256"]
CYC256 = 7 , # [doc = "8: RTC Clock Cycles 512"]
CYC512 = 8 , # [doc = "9: RTC Clock Cycles 1024"]
CYC1024 = 9 , # [doc = "10: RTC Clock Cycles 2048"]
CYC2048 = 10 , # [doc = "11: RTC Clock Cycles 4096"]
CYC4096 = 11 , # [doc = "12: RTC Clock Cycles 8192"]
CYC8192 = 12 , # [doc = "13: RTC Clock Cycles 16384"]
CYC16384 = 13 , # [doc = "14: RTC Clock Cycles 32768"]
CYC32768 = 14 , } impl From < PERIOD_A > for u8 { # [inline (always)]
fn from (variant : PERIOD_A) -> Self { variant as _ } } impl PERIOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PERIOD_A > { match self . bits { 0 => Some (PERIOD_A :: OFF) , 1 => Some (PERIOD_A :: CYC4) , 2 => Some (PERIOD_A :: CYC8) , 3 => Some (PERIOD_A :: CYC16) , 4 => Some (PERIOD_A :: CYC32) , 5 => Some (PERIOD_A :: CYC64) , 6 => Some (PERIOD_A :: CYC128) , 7 => Some (PERIOD_A :: CYC256) , 8 => Some (PERIOD_A :: CYC512) , 9 => Some (PERIOD_A :: CYC1024) , 10 => Some (PERIOD_A :: CYC2048) , 11 => Some (PERIOD_A :: CYC4096) , 12 => Some (PERIOD_A :: CYC8192) , 13 => Some (PERIOD_A :: CYC16384) , 14 => Some (PERIOD_A :: CYC32768) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == PERIOD_A :: OFF } # [doc = "Checks if the value of the field is `CYC4`"]
# [inline (always)]
pub fn is_cyc4 (& self) -> bool { * self == PERIOD_A :: CYC4 } # [doc = "Checks if the value of the field is `CYC8`"]
# [inline (always)]
pub fn is_cyc8 (& self) -> bool { * self == PERIOD_A :: CYC8 } # [doc = "Checks if the value of the field is `CYC16`"]
# [inline (always)]
pub fn is_cyc16 (& self) -> bool { * self == PERIOD_A :: CYC16 } # [doc = "Checks if the value of the field is `CYC32`"]
# [inline (always)]
pub fn is_cyc32 (& self) -> bool { * self == PERIOD_A :: CYC32 } # [doc = "Checks if the value of the field is `CYC64`"]
# [inline (always)]
pub fn is_cyc64 (& self) -> bool { * self == PERIOD_A :: CYC64 } # [doc = "Checks if the value of the field is `CYC128`"]
# [inline (always)]
pub fn is_cyc128 (& self) -> bool { * self == PERIOD_A :: CYC128 } # [doc = "Checks if the value of the field is `CYC256`"]
# [inline (always)]
pub fn is_cyc256 (& self) -> bool { * self == PERIOD_A :: CYC256 } # [doc = "Checks if the value of the field is `CYC512`"]
# [inline (always)]
pub fn is_cyc512 (& self) -> bool { * self == PERIOD_A :: CYC512 } # [doc = "Checks if the value of the field is `CYC1024`"]
# [inline (always)]
pub fn is_cyc1024 (& self) -> bool { * self == PERIOD_A :: CYC1024 } # [doc = "Checks if the value of the field is `CYC2048`"]
# [inline (always)]
pub fn is_cyc2048 (& self) -> bool { * self == PERIOD_A :: CYC2048 } # [doc = "Checks if the value of the field is `CYC4096`"]
# [inline (always)]
pub fn is_cyc4096 (& self) -> bool { * self == PERIOD_A :: CYC4096 } # [doc = "Checks if the value of the field is `CYC8192`"]
# [inline (always)]
pub fn is_cyc8192 (& self) -> bool { * self == PERIOD_A :: CYC8192 } # [doc = "Checks if the value of the field is `CYC16384`"]
# [inline (always)]
pub fn is_cyc16384 (& self) -> bool { * self == PERIOD_A :: CYC16384 } # [doc = "Checks if the value of the field is `CYC32768`"]
# [inline (always)]
pub fn is_cyc32768 (& self) -> bool { * self == PERIOD_A :: CYC32768 } } # [doc = "Field `PERIOD` writer - Period"]
pub type PERIOD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PITCTRLA_SPEC , u8 , PERIOD_A , 4 , O > ; impl < 'a , const O : u8 > PERIOD_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (PERIOD_A :: OFF) } # [doc = "RTC Clock Cycles 4"]
# [inline (always)]
pub fn cyc4 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC4) } # [doc = "RTC Clock Cycles 8"]
# [inline (always)]
pub fn cyc8 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC8) } # [doc = "RTC Clock Cycles 16"]
# [inline (always)]
pub fn cyc16 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC16) } # [doc = "RTC Clock Cycles 32"]
# [inline (always)]
pub fn cyc32 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC32) } # [doc = "RTC Clock Cycles 64"]
# [inline (always)]
pub fn cyc64 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC64) } # [doc = "RTC Clock Cycles 128"]
# [inline (always)]
pub fn cyc128 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC128) } # [doc = "RTC Clock Cycles 256"]
# [inline (always)]
pub fn cyc256 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC256) } # [doc = "RTC Clock Cycles 512"]
# [inline (always)]
pub fn cyc512 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC512) } # [doc = "RTC Clock Cycles 1024"]
# [inline (always)]
pub fn cyc1024 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC1024) } # [doc = "RTC Clock Cycles 2048"]
# [inline (always)]
pub fn cyc2048 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC2048) } # [doc = "RTC Clock Cycles 4096"]
# [inline (always)]
pub fn cyc4096 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC4096) } # [doc = "RTC Clock Cycles 8192"]
# [inline (always)]
pub fn cyc8192 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC8192) } # [doc = "RTC Clock Cycles 16384"]
# [inline (always)]
pub fn cyc16384 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC16384) } # [doc = "RTC Clock Cycles 32768"]
# [inline (always)]
pub fn cyc32768 (self) -> & 'a mut W { self . variant (PERIOD_A :: CYC32768) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn piten (& self) -> PITEN_R { PITEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 3:6 - Period"]
# [inline (always)]
pub fn period (& self) -> PERIOD_R { PERIOD_R :: new ((self . bits >> 3) & 0x0f) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn piten (& mut self) -> PITEN_W < 0 > { PITEN_W :: new (self) } # [doc = "Bits 3:6 - Period"]
# [inline (always)]
# [must_use]
pub fn period (& mut self) -> PERIOD_W < 3 > { PERIOD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PIT Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitctrla](index.html) module"]
pub struct PITCTRLA_SPEC ; impl crate :: RegisterSpec for PITCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitctrla::R](R) reader structure"]
impl crate :: Readable for PITCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pitctrla::W](W) writer structure"]
impl crate :: Writable for PITCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PITCTRLA to value 0"]
impl crate :: Resettable for PITCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITDBGCTRL (rw) register accessor: an alias for `Reg<PITDBGCTRL_SPEC>`"]
pub type PITDBGCTRL = crate :: Reg < pitdbgctrl :: PITDBGCTRL_SPEC > ; # [doc = "PIT Debug control"]
pub mod pitdbgctrl { # [doc = "Register `PITDBGCTRL` reader"]
pub struct R (crate :: R < PITDBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITDBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITDBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITDBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PITDBGCTRL` writer"]
pub struct W (crate :: W < PITDBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PITDBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PITDBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PITDBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Run in debug"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Run in debug"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PITDBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Run in debug"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Run in debug"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PIT Debug control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitdbgctrl](index.html) module"]
pub struct PITDBGCTRL_SPEC ; impl crate :: RegisterSpec for PITDBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitdbgctrl::R](R) reader structure"]
impl crate :: Readable for PITDBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pitdbgctrl::W](W) writer structure"]
impl crate :: Writable for PITDBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PITDBGCTRL to value 0"]
impl crate :: Resettable for PITDBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITINTCTRL (rw) register accessor: an alias for `Reg<PITINTCTRL_SPEC>`"]
pub type PITINTCTRL = crate :: Reg < pitintctrl :: PITINTCTRL_SPEC > ; # [doc = "PIT Interrupt Control"]
pub mod pitintctrl { # [doc = "Register `PITINTCTRL` reader"]
pub struct R (crate :: R < PITINTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITINTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITINTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITINTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PITINTCTRL` writer"]
pub struct W (crate :: W < PITINTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PITINTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PITINTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PITINTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PI` reader - Periodic Interrupt"]
pub type PI_R = crate :: BitReader < bool > ; # [doc = "Field `PI` writer - Periodic Interrupt"]
pub type PI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PITINTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Periodic Interrupt"]
# [inline (always)]
pub fn pi (& self) -> PI_R { PI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Periodic Interrupt"]
# [inline (always)]
# [must_use]
pub fn pi (& mut self) -> PI_W < 0 > { PI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PIT Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitintctrl](index.html) module"]
pub struct PITINTCTRL_SPEC ; impl crate :: RegisterSpec for PITINTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitintctrl::R](R) reader structure"]
impl crate :: Readable for PITINTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pitintctrl::W](W) writer structure"]
impl crate :: Writable for PITINTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PITINTCTRL to value 0"]
impl crate :: Resettable for PITINTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITINTFLAGS (rw) register accessor: an alias for `Reg<PITINTFLAGS_SPEC>`"]
pub type PITINTFLAGS = crate :: Reg < pitintflags :: PITINTFLAGS_SPEC > ; # [doc = "PIT Interrupt Flags"]
pub mod pitintflags { # [doc = "Register `PITINTFLAGS` reader"]
pub struct R (crate :: R < PITINTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITINTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITINTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITINTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `PITINTFLAGS` writer"]
pub struct W (crate :: W < PITINTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PITINTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PITINTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PITINTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PI` reader - Periodic Interrupt"]
pub type PI_R = crate :: BitReader < bool > ; # [doc = "Field `PI` writer - Periodic Interrupt"]
pub type PI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PITINTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Periodic Interrupt"]
# [inline (always)]
pub fn pi (& self) -> PI_R { PI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Periodic Interrupt"]
# [inline (always)]
# [must_use]
pub fn pi (& mut self) -> PI_W < 0 > { PI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PIT Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitintflags](index.html) module"]
pub struct PITINTFLAGS_SPEC ; impl crate :: RegisterSpec for PITINTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitintflags::R](R) reader structure"]
impl crate :: Readable for PITINTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pitintflags::W](W) writer structure"]
impl crate :: Writable for PITINTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PITINTFLAGS to value 0"]
impl crate :: Resettable for PITINTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PITSTATUS (r) register accessor: an alias for `Reg<PITSTATUS_SPEC>`"]
pub type PITSTATUS = crate :: Reg < pitstatus :: PITSTATUS_SPEC > ; # [doc = "PIT Status"]
pub mod pitstatus { # [doc = "Register `PITSTATUS` reader"]
pub struct R (crate :: R < PITSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PITSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PITSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PITSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `CTRLBUSY` reader - CTRLA Synchronization Busy Flag"]
pub type CTRLBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - CTRLA Synchronization Busy Flag"]
# [inline (always)]
pub fn ctrlbusy (& self) -> CTRLBUSY_R { CTRLBUSY_R :: new ((self . bits & 1) != 0) } } # [doc = "PIT Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pitstatus](index.html) module"]
pub struct PITSTATUS_SPEC ; impl crate :: RegisterSpec for PITSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pitstatus::R](R) reader structure"]
impl crate :: Readable for PITSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PITSTATUS to value 0"]
impl crate :: Resettable for PITSTATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `CTRLABUSY` reader - CTRLA Synchronization Busy Flag"]
pub type CTRLABUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CNTBUSY` reader - Count Synchronization Busy Flag"]
pub type CNTBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `PERBUSY` reader - Period Synchronization Busy Flag"]
pub type PERBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CMPBUSY` reader - Comparator Synchronization Busy Flag"]
pub type CMPBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - CTRLA Synchronization Busy Flag"]
# [inline (always)]
pub fn ctrlabusy (& self) -> CTRLABUSY_R { CTRLABUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Count Synchronization Busy Flag"]
# [inline (always)]
pub fn cntbusy (& self) -> CNTBUSY_R { CNTBUSY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Period Synchronization Busy Flag"]
# [inline (always)]
pub fn perbusy (& self) -> PERBUSY_R { PERBUSY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Comparator Synchronization Busy Flag"]
# [inline (always)]
pub fn cmpbusy (& self) -> CMPBUSY_R { CMPBUSY_R :: new (((self . bits >> 3) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Signature row"]
pub struct SIGROW { _marker : PhantomData < * const () > } unsafe impl Send for SIGROW { } impl SIGROW { # [doc = r"Pointer to the register block"]
pub const PTR : * const sigrow :: RegisterBlock = 0x1100 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sigrow :: RegisterBlock { Self :: PTR } } impl Deref for SIGROW { type Target = sigrow :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SIGROW { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SIGROW") . finish () } } # [doc = "Signature row"]
pub mod sigrow { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Device ID Byte 0"]
pub deviceid0 : DEVICEID0 , # [doc = "0x01 - Device ID Byte 1"]
pub deviceid1 : DEVICEID1 , # [doc = "0x02 - Device ID Byte 2"]
pub deviceid2 : DEVICEID2 , # [doc = "0x03 - Serial Number Byte 0"]
pub sernum0 : SERNUM0 , # [doc = "0x04 - Serial Number Byte 1"]
pub sernum1 : SERNUM1 , # [doc = "0x05 - Serial Number Byte 2"]
pub sernum2 : SERNUM2 , # [doc = "0x06 - Serial Number Byte 3"]
pub sernum3 : SERNUM3 , # [doc = "0x07 - Serial Number Byte 4"]
pub sernum4 : SERNUM4 , # [doc = "0x08 - Serial Number Byte 5"]
pub sernum5 : SERNUM5 , # [doc = "0x09 - Serial Number Byte 6"]
pub sernum6 : SERNUM6 , # [doc = "0x0a - Serial Number Byte 7"]
pub sernum7 : SERNUM7 , # [doc = "0x0b - Serial Number Byte 8"]
pub sernum8 : SERNUM8 , # [doc = "0x0c - Serial Number Byte 9"]
pub sernum9 : SERNUM9 , _reserved13 : [u8 ; 0x07]
, # [doc = "0x14 - Oscillator Calibration for 32kHz ULP"]
pub osccal32k : OSCCAL32K , _reserved14 : [u8 ; 0x03]
, # [doc = "0x18 - Oscillator Calibration 16 MHz Byte 0"]
pub osccal16m0 : OSCCAL16M0 , # [doc = "0x19 - Oscillator Calibration 16 MHz Byte 1"]
pub osccal16m1 : OSCCAL16M1 , # [doc = "0x1a - Oscillator Calibration 20 MHz Byte 0"]
pub osccal20m0 : OSCCAL20M0 , # [doc = "0x1b - Oscillator Calibration 20 MHz Byte 1"]
pub osccal20m1 : OSCCAL20M1 , _reserved18 : [u8 ; 0x04]
, # [doc = "0x20 - Temperature Sensor Calibration Byte 0"]
pub tempsense0 : TEMPSENSE0 , # [doc = "0x21 - Temperature Sensor Calibration Byte 1"]
pub tempsense1 : TEMPSENSE1 , # [doc = "0x22 - OSC16 error at 3V"]
pub osc16err3v : OSC16ERR3V , # [doc = "0x23 - OSC16 error at 5V"]
pub osc16err5v : OSC16ERR5V , # [doc = "0x24 - OSC20 error at 3V"]
pub osc20err3v : OSC20ERR3V , # [doc = "0x25 - OSC20 error at 5V"]
pub osc20err5v : OSC20ERR5V , _reserved24 : [u8 ; 0x09]
, # [doc = "0x2f - CRC Checksum Byte 1"]
pub checksum1 : CHECKSUM1 , } # [doc = "CHECKSUM1 (r) register accessor: an alias for `Reg<CHECKSUM1_SPEC>`"]
pub type CHECKSUM1 = crate :: Reg < checksum1 :: CHECKSUM1_SPEC > ; # [doc = "CRC Checksum Byte 1"]
pub mod checksum1 { # [doc = "Register `CHECKSUM1` reader"]
pub struct R (crate :: R < CHECKSUM1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHECKSUM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHECKSUM1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHECKSUM1_SPEC >) -> Self { R (reader) } } # [doc = "CRC Checksum Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [checksum1](index.html) module"]
pub struct CHECKSUM1_SPEC ; impl crate :: RegisterSpec for CHECKSUM1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [checksum1::R](R) reader structure"]
impl crate :: Readable for CHECKSUM1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CHECKSUM1 to value 0"]
impl crate :: Resettable for CHECKSUM1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DEVICEID0 (r) register accessor: an alias for `Reg<DEVICEID0_SPEC>`"]
pub type DEVICEID0 = crate :: Reg < deviceid0 :: DEVICEID0_SPEC > ; # [doc = "Device ID Byte 0"]
pub mod deviceid0 { # [doc = "Register `DEVICEID0` reader"]
pub struct R (crate :: R < DEVICEID0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVICEID0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVICEID0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVICEID0_SPEC >) -> Self { R (reader) } } # [doc = "Device ID Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [deviceid0](index.html) module"]
pub struct DEVICEID0_SPEC ; impl crate :: RegisterSpec for DEVICEID0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [deviceid0::R](R) reader structure"]
impl crate :: Readable for DEVICEID0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVICEID0 to value 0"]
impl crate :: Resettable for DEVICEID0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DEVICEID1 (r) register accessor: an alias for `Reg<DEVICEID1_SPEC>`"]
pub type DEVICEID1 = crate :: Reg < deviceid1 :: DEVICEID1_SPEC > ; # [doc = "Device ID Byte 1"]
pub mod deviceid1 { # [doc = "Register `DEVICEID1` reader"]
pub struct R (crate :: R < DEVICEID1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVICEID1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVICEID1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVICEID1_SPEC >) -> Self { R (reader) } } # [doc = "Device ID Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [deviceid1](index.html) module"]
pub struct DEVICEID1_SPEC ; impl crate :: RegisterSpec for DEVICEID1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [deviceid1::R](R) reader structure"]
impl crate :: Readable for DEVICEID1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVICEID1 to value 0"]
impl crate :: Resettable for DEVICEID1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DEVICEID2 (r) register accessor: an alias for `Reg<DEVICEID2_SPEC>`"]
pub type DEVICEID2 = crate :: Reg < deviceid2 :: DEVICEID2_SPEC > ; # [doc = "Device ID Byte 2"]
pub mod deviceid2 { # [doc = "Register `DEVICEID2` reader"]
pub struct R (crate :: R < DEVICEID2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVICEID2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVICEID2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVICEID2_SPEC >) -> Self { R (reader) } } # [doc = "Device ID Byte 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [deviceid2](index.html) module"]
pub struct DEVICEID2_SPEC ; impl crate :: RegisterSpec for DEVICEID2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [deviceid2::R](R) reader structure"]
impl crate :: Readable for DEVICEID2_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVICEID2 to value 0"]
impl crate :: Resettable for DEVICEID2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC16ERR3V (r) register accessor: an alias for `Reg<OSC16ERR3V_SPEC>`"]
pub type OSC16ERR3V = crate :: Reg < osc16err3v :: OSC16ERR3V_SPEC > ; # [doc = "OSC16 error at 3V"]
pub mod osc16err3v { # [doc = "Register `OSC16ERR3V` reader"]
pub struct R (crate :: R < OSC16ERR3V_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC16ERR3V_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC16ERR3V_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC16ERR3V_SPEC >) -> Self { R (reader) } } # [doc = "OSC16 error at 3V\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc16err3v](index.html) module"]
pub struct OSC16ERR3V_SPEC ; impl crate :: RegisterSpec for OSC16ERR3V_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc16err3v::R](R) reader structure"]
impl crate :: Readable for OSC16ERR3V_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSC16ERR3V to value 0"]
impl crate :: Resettable for OSC16ERR3V_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC16ERR5V (r) register accessor: an alias for `Reg<OSC16ERR5V_SPEC>`"]
pub type OSC16ERR5V = crate :: Reg < osc16err5v :: OSC16ERR5V_SPEC > ; # [doc = "OSC16 error at 5V"]
pub mod osc16err5v { # [doc = "Register `OSC16ERR5V` reader"]
pub struct R (crate :: R < OSC16ERR5V_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC16ERR5V_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC16ERR5V_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC16ERR5V_SPEC >) -> Self { R (reader) } } # [doc = "OSC16 error at 5V\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc16err5v](index.html) module"]
pub struct OSC16ERR5V_SPEC ; impl crate :: RegisterSpec for OSC16ERR5V_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc16err5v::R](R) reader structure"]
impl crate :: Readable for OSC16ERR5V_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSC16ERR5V to value 0"]
impl crate :: Resettable for OSC16ERR5V_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20ERR3V (r) register accessor: an alias for `Reg<OSC20ERR3V_SPEC>`"]
pub type OSC20ERR3V = crate :: Reg < osc20err3v :: OSC20ERR3V_SPEC > ; # [doc = "OSC20 error at 3V"]
pub mod osc20err3v { # [doc = "Register `OSC20ERR3V` reader"]
pub struct R (crate :: R < OSC20ERR3V_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20ERR3V_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20ERR3V_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20ERR3V_SPEC >) -> Self { R (reader) } } # [doc = "OSC20 error at 3V\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20err3v](index.html) module"]
pub struct OSC20ERR3V_SPEC ; impl crate :: RegisterSpec for OSC20ERR3V_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20err3v::R](R) reader structure"]
impl crate :: Readable for OSC20ERR3V_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSC20ERR3V to value 0"]
impl crate :: Resettable for OSC20ERR3V_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSC20ERR5V (r) register accessor: an alias for `Reg<OSC20ERR5V_SPEC>`"]
pub type OSC20ERR5V = crate :: Reg < osc20err5v :: OSC20ERR5V_SPEC > ; # [doc = "OSC20 error at 5V"]
pub mod osc20err5v { # [doc = "Register `OSC20ERR5V` reader"]
pub struct R (crate :: R < OSC20ERR5V_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC20ERR5V_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC20ERR5V_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC20ERR5V_SPEC >) -> Self { R (reader) } } # [doc = "OSC20 error at 5V\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc20err5v](index.html) module"]
pub struct OSC20ERR5V_SPEC ; impl crate :: RegisterSpec for OSC20ERR5V_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osc20err5v::R](R) reader structure"]
impl crate :: Readable for OSC20ERR5V_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSC20ERR5V to value 0"]
impl crate :: Resettable for OSC20ERR5V_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCAL16M0 (r) register accessor: an alias for `Reg<OSCCAL16M0_SPEC>`"]
pub type OSCCAL16M0 = crate :: Reg < osccal16m0 :: OSCCAL16M0_SPEC > ; # [doc = "Oscillator Calibration 16 MHz Byte 0"]
pub mod osccal16m0 { # [doc = "Register `OSCCAL16M0` reader"]
pub struct R (crate :: R < OSCCAL16M0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCAL16M0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCAL16M0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCAL16M0_SPEC >) -> Self { R (reader) } } # [doc = "Oscillator Calibration 16 MHz Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccal16m0](index.html) module"]
pub struct OSCCAL16M0_SPEC ; impl crate :: RegisterSpec for OSCCAL16M0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccal16m0::R](R) reader structure"]
impl crate :: Readable for OSCCAL16M0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSCCAL16M0 to value 0"]
impl crate :: Resettable for OSCCAL16M0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCAL16M1 (r) register accessor: an alias for `Reg<OSCCAL16M1_SPEC>`"]
pub type OSCCAL16M1 = crate :: Reg < osccal16m1 :: OSCCAL16M1_SPEC > ; # [doc = "Oscillator Calibration 16 MHz Byte 1"]
pub mod osccal16m1 { # [doc = "Register `OSCCAL16M1` reader"]
pub struct R (crate :: R < OSCCAL16M1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCAL16M1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCAL16M1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCAL16M1_SPEC >) -> Self { R (reader) } } # [doc = "Oscillator Calibration 16 MHz Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccal16m1](index.html) module"]
pub struct OSCCAL16M1_SPEC ; impl crate :: RegisterSpec for OSCCAL16M1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccal16m1::R](R) reader structure"]
impl crate :: Readable for OSCCAL16M1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSCCAL16M1 to value 0"]
impl crate :: Resettable for OSCCAL16M1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCAL20M0 (r) register accessor: an alias for `Reg<OSCCAL20M0_SPEC>`"]
pub type OSCCAL20M0 = crate :: Reg < osccal20m0 :: OSCCAL20M0_SPEC > ; # [doc = "Oscillator Calibration 20 MHz Byte 0"]
pub mod osccal20m0 { # [doc = "Register `OSCCAL20M0` reader"]
pub struct R (crate :: R < OSCCAL20M0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCAL20M0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCAL20M0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCAL20M0_SPEC >) -> Self { R (reader) } } # [doc = "Oscillator Calibration 20 MHz Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccal20m0](index.html) module"]
pub struct OSCCAL20M0_SPEC ; impl crate :: RegisterSpec for OSCCAL20M0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccal20m0::R](R) reader structure"]
impl crate :: Readable for OSCCAL20M0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSCCAL20M0 to value 0"]
impl crate :: Resettable for OSCCAL20M0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCAL20M1 (r) register accessor: an alias for `Reg<OSCCAL20M1_SPEC>`"]
pub type OSCCAL20M1 = crate :: Reg < osccal20m1 :: OSCCAL20M1_SPEC > ; # [doc = "Oscillator Calibration 20 MHz Byte 1"]
pub mod osccal20m1 { # [doc = "Register `OSCCAL20M1` reader"]
pub struct R (crate :: R < OSCCAL20M1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCAL20M1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCAL20M1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCAL20M1_SPEC >) -> Self { R (reader) } } # [doc = "Oscillator Calibration 20 MHz Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccal20m1](index.html) module"]
pub struct OSCCAL20M1_SPEC ; impl crate :: RegisterSpec for OSCCAL20M1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccal20m1::R](R) reader structure"]
impl crate :: Readable for OSCCAL20M1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSCCAL20M1 to value 0"]
impl crate :: Resettable for OSCCAL20M1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCAL32K (r) register accessor: an alias for `Reg<OSCCAL32K_SPEC>`"]
pub type OSCCAL32K = crate :: Reg < osccal32k :: OSCCAL32K_SPEC > ; # [doc = "Oscillator Calibration for 32kHz ULP"]
pub mod osccal32k { # [doc = "Register `OSCCAL32K` reader"]
pub struct R (crate :: R < OSCCAL32K_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCAL32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCAL32K_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCAL32K_SPEC >) -> Self { R (reader) } } # [doc = "Oscillator Calibration for 32kHz ULP\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccal32k](index.html) module"]
pub struct OSCCAL32K_SPEC ; impl crate :: RegisterSpec for OSCCAL32K_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccal32k::R](R) reader structure"]
impl crate :: Readable for OSCCAL32K_SPEC { type Reader = R ; } # [doc = "`reset()` method sets OSCCAL32K to value 0"]
impl crate :: Resettable for OSCCAL32K_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM0 (r) register accessor: an alias for `Reg<SERNUM0_SPEC>`"]
pub type SERNUM0 = crate :: Reg < sernum0 :: SERNUM0_SPEC > ; # [doc = "Serial Number Byte 0"]
pub mod sernum0 { # [doc = "Register `SERNUM0` reader"]
pub struct R (crate :: R < SERNUM0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM0_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum0](index.html) module"]
pub struct SERNUM0_SPEC ; impl crate :: RegisterSpec for SERNUM0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum0::R](R) reader structure"]
impl crate :: Readable for SERNUM0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM0 to value 0"]
impl crate :: Resettable for SERNUM0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM1 (r) register accessor: an alias for `Reg<SERNUM1_SPEC>`"]
pub type SERNUM1 = crate :: Reg < sernum1 :: SERNUM1_SPEC > ; # [doc = "Serial Number Byte 1"]
pub mod sernum1 { # [doc = "Register `SERNUM1` reader"]
pub struct R (crate :: R < SERNUM1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM1_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum1](index.html) module"]
pub struct SERNUM1_SPEC ; impl crate :: RegisterSpec for SERNUM1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum1::R](R) reader structure"]
impl crate :: Readable for SERNUM1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM1 to value 0"]
impl crate :: Resettable for SERNUM1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM2 (r) register accessor: an alias for `Reg<SERNUM2_SPEC>`"]
pub type SERNUM2 = crate :: Reg < sernum2 :: SERNUM2_SPEC > ; # [doc = "Serial Number Byte 2"]
pub mod sernum2 { # [doc = "Register `SERNUM2` reader"]
pub struct R (crate :: R < SERNUM2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM2_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum2](index.html) module"]
pub struct SERNUM2_SPEC ; impl crate :: RegisterSpec for SERNUM2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum2::R](R) reader structure"]
impl crate :: Readable for SERNUM2_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM2 to value 0"]
impl crate :: Resettable for SERNUM2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM3 (r) register accessor: an alias for `Reg<SERNUM3_SPEC>`"]
pub type SERNUM3 = crate :: Reg < sernum3 :: SERNUM3_SPEC > ; # [doc = "Serial Number Byte 3"]
pub mod sernum3 { # [doc = "Register `SERNUM3` reader"]
pub struct R (crate :: R < SERNUM3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM3_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 3\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum3](index.html) module"]
pub struct SERNUM3_SPEC ; impl crate :: RegisterSpec for SERNUM3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum3::R](R) reader structure"]
impl crate :: Readable for SERNUM3_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM3 to value 0"]
impl crate :: Resettable for SERNUM3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM4 (r) register accessor: an alias for `Reg<SERNUM4_SPEC>`"]
pub type SERNUM4 = crate :: Reg < sernum4 :: SERNUM4_SPEC > ; # [doc = "Serial Number Byte 4"]
pub mod sernum4 { # [doc = "Register `SERNUM4` reader"]
pub struct R (crate :: R < SERNUM4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM4_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 4\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum4](index.html) module"]
pub struct SERNUM4_SPEC ; impl crate :: RegisterSpec for SERNUM4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum4::R](R) reader structure"]
impl crate :: Readable for SERNUM4_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM4 to value 0"]
impl crate :: Resettable for SERNUM4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM5 (r) register accessor: an alias for `Reg<SERNUM5_SPEC>`"]
pub type SERNUM5 = crate :: Reg < sernum5 :: SERNUM5_SPEC > ; # [doc = "Serial Number Byte 5"]
pub mod sernum5 { # [doc = "Register `SERNUM5` reader"]
pub struct R (crate :: R < SERNUM5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM5_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 5\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum5](index.html) module"]
pub struct SERNUM5_SPEC ; impl crate :: RegisterSpec for SERNUM5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum5::R](R) reader structure"]
impl crate :: Readable for SERNUM5_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM5 to value 0"]
impl crate :: Resettable for SERNUM5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM6 (r) register accessor: an alias for `Reg<SERNUM6_SPEC>`"]
pub type SERNUM6 = crate :: Reg < sernum6 :: SERNUM6_SPEC > ; # [doc = "Serial Number Byte 6"]
pub mod sernum6 { # [doc = "Register `SERNUM6` reader"]
pub struct R (crate :: R < SERNUM6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM6_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 6\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum6](index.html) module"]
pub struct SERNUM6_SPEC ; impl crate :: RegisterSpec for SERNUM6_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum6::R](R) reader structure"]
impl crate :: Readable for SERNUM6_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM6 to value 0"]
impl crate :: Resettable for SERNUM6_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM7 (r) register accessor: an alias for `Reg<SERNUM7_SPEC>`"]
pub type SERNUM7 = crate :: Reg < sernum7 :: SERNUM7_SPEC > ; # [doc = "Serial Number Byte 7"]
pub mod sernum7 { # [doc = "Register `SERNUM7` reader"]
pub struct R (crate :: R < SERNUM7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM7_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 7\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum7](index.html) module"]
pub struct SERNUM7_SPEC ; impl crate :: RegisterSpec for SERNUM7_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum7::R](R) reader structure"]
impl crate :: Readable for SERNUM7_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM7 to value 0"]
impl crate :: Resettable for SERNUM7_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM8 (r) register accessor: an alias for `Reg<SERNUM8_SPEC>`"]
pub type SERNUM8 = crate :: Reg < sernum8 :: SERNUM8_SPEC > ; # [doc = "Serial Number Byte 8"]
pub mod sernum8 { # [doc = "Register `SERNUM8` reader"]
pub struct R (crate :: R < SERNUM8_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM8_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM8_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 8\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum8](index.html) module"]
pub struct SERNUM8_SPEC ; impl crate :: RegisterSpec for SERNUM8_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum8::R](R) reader structure"]
impl crate :: Readable for SERNUM8_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM8 to value 0"]
impl crate :: Resettable for SERNUM8_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SERNUM9 (r) register accessor: an alias for `Reg<SERNUM9_SPEC>`"]
pub type SERNUM9 = crate :: Reg < sernum9 :: SERNUM9_SPEC > ; # [doc = "Serial Number Byte 9"]
pub mod sernum9 { # [doc = "Register `SERNUM9` reader"]
pub struct R (crate :: R < SERNUM9_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERNUM9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERNUM9_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERNUM9_SPEC >) -> Self { R (reader) } } # [doc = "Serial Number Byte 9\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sernum9](index.html) module"]
pub struct SERNUM9_SPEC ; impl crate :: RegisterSpec for SERNUM9_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sernum9::R](R) reader structure"]
impl crate :: Readable for SERNUM9_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SERNUM9 to value 0"]
impl crate :: Resettable for SERNUM9_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMPSENSE0 (r) register accessor: an alias for `Reg<TEMPSENSE0_SPEC>`"]
pub type TEMPSENSE0 = crate :: Reg < tempsense0 :: TEMPSENSE0_SPEC > ; # [doc = "Temperature Sensor Calibration Byte 0"]
pub mod tempsense0 { # [doc = "Register `TEMPSENSE0` reader"]
pub struct R (crate :: R < TEMPSENSE0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMPSENSE0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMPSENSE0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMPSENSE0_SPEC >) -> Self { R (reader) } } # [doc = "Temperature Sensor Calibration Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tempsense0](index.html) module"]
pub struct TEMPSENSE0_SPEC ; impl crate :: RegisterSpec for TEMPSENSE0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tempsense0::R](R) reader structure"]
impl crate :: Readable for TEMPSENSE0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets TEMPSENSE0 to value 0"]
impl crate :: Resettable for TEMPSENSE0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMPSENSE1 (r) register accessor: an alias for `Reg<TEMPSENSE1_SPEC>`"]
pub type TEMPSENSE1 = crate :: Reg < tempsense1 :: TEMPSENSE1_SPEC > ; # [doc = "Temperature Sensor Calibration Byte 1"]
pub mod tempsense1 { # [doc = "Register `TEMPSENSE1` reader"]
pub struct R (crate :: R < TEMPSENSE1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMPSENSE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMPSENSE1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMPSENSE1_SPEC >) -> Self { R (reader) } } # [doc = "Temperature Sensor Calibration Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tempsense1](index.html) module"]
pub struct TEMPSENSE1_SPEC ; impl crate :: RegisterSpec for TEMPSENSE1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tempsense1::R](R) reader structure"]
impl crate :: Readable for TEMPSENSE1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets TEMPSENSE1 to value 0"]
impl crate :: Resettable for TEMPSENSE1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Sleep Controller"]
pub struct SLPCTRL { _marker : PhantomData < * const () > } unsafe impl Send for SLPCTRL { } impl SLPCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const slpctrl :: RegisterBlock = 0x50 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const slpctrl :: RegisterBlock { Self :: PTR } } impl Deref for SLPCTRL { type Target = slpctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SLPCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SLPCTRL") . finish () } } # [doc = "Sleep Controller"]
pub mod slpctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrla : CTRLA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SEN` reader - Sleep enable"]
pub type SEN_R = crate :: BitReader < bool > ; # [doc = "Field `SEN` writer - Sleep enable"]
pub type SEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `SMODE` reader - Sleep mode"]
pub type SMODE_R = crate :: FieldReader < u8 , SMODE_A > ; # [doc = "Sleep mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SMODE_A { # [doc = "0: Idle mode"]
IDLE = 0 , # [doc = "1: Standby Mode"]
STDBY = 1 , # [doc = "2: Power-down Mode"]
PDOWN = 2 , } impl From < SMODE_A > for u8 { # [inline (always)]
fn from (variant : SMODE_A) -> Self { variant as _ } } impl SMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SMODE_A > { match self . bits { 0 => Some (SMODE_A :: IDLE) , 1 => Some (SMODE_A :: STDBY) , 2 => Some (SMODE_A :: PDOWN) , _ => None , } } # [doc = "Checks if the value of the field is `IDLE`"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == SMODE_A :: IDLE } # [doc = "Checks if the value of the field is `STDBY`"]
# [inline (always)]
pub fn is_stdby (& self) -> bool { * self == SMODE_A :: STDBY } # [doc = "Checks if the value of the field is `PDOWN`"]
# [inline (always)]
pub fn is_pdown (& self) -> bool { * self == SMODE_A :: PDOWN } } # [doc = "Field `SMODE` writer - Sleep mode"]
pub type SMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , SMODE_A , 2 , O > ; impl < 'a , const O : u8 > SMODE_W < 'a , O > { # [doc = "Idle mode"]
# [inline (always)]
pub fn idle (self) -> & 'a mut W { self . variant (SMODE_A :: IDLE) } # [doc = "Standby Mode"]
# [inline (always)]
pub fn stdby (self) -> & 'a mut W { self . variant (SMODE_A :: STDBY) } # [doc = "Power-down Mode"]
# [inline (always)]
pub fn pdown (self) -> & 'a mut W { self . variant (SMODE_A :: PDOWN) } } impl R { # [doc = "Bit 0 - Sleep enable"]
# [inline (always)]
pub fn sen (& self) -> SEN_R { SEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Sleep mode"]
# [inline (always)]
pub fn smode (& self) -> SMODE_R { SMODE_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - Sleep enable"]
# [inline (always)]
# [must_use]
pub fn sen (& mut self) -> SEN_W < 0 > { SEN_W :: new (self) } # [doc = "Bits 1:2 - Sleep mode"]
# [inline (always)]
# [must_use]
pub fn smode (& mut self) -> SMODE_W < 1 > { SMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct SPI0 { _marker : PhantomData < * const () > } unsafe impl Send for SPI0 { } impl SPI0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const spi0 :: RegisterBlock = 0x08c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spi0 :: RegisterBlock { Self :: PTR } } impl Deref for SPI0 { type Target = spi0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPI0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPI0") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod spi0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x04 - Data"]
pub data : DATA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable Module"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable Module"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `PRESC` reader - Prescaler"]
pub type PRESC_R = crate :: FieldReader < u8 , PRESC_A > ; # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESC_A { # [doc = "0: System Clock / 4"]
DIV4 = 0 , # [doc = "1: System Clock / 16"]
DIV16 = 1 , # [doc = "2: System Clock / 64"]
DIV64 = 2 , # [doc = "3: System Clock / 128"]
DIV128 = 3 , } impl From < PRESC_A > for u8 { # [inline (always)]
fn from (variant : PRESC_A) -> Self { variant as _ } } impl PRESC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESC_A { match self . bits { 0 => PRESC_A :: DIV4 , 1 => PRESC_A :: DIV16 , 2 => PRESC_A :: DIV64 , 3 => PRESC_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESC_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESC_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESC_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESC_A :: DIV128 } } # [doc = "Field `PRESC` writer - Prescaler"]
pub type PRESC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , PRESC_A , 2 , O > ; impl < 'a , const O : u8 > PRESC_W < 'a , O > { # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV4) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV64) } # [doc = "System Clock / 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESC_A :: DIV128) } } # [doc = "Field `CLK2X` reader - Enable Double Speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Enable Double Speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `MASTER` reader - Master Operation Enable"]
pub type MASTER_R = crate :: BitReader < bool > ; # [doc = "Field `MASTER` writer - Master Operation Enable"]
pub type MASTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DORD` reader - Data Order Setting"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order Setting"]
pub type DORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable Module"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Prescaler"]
# [inline (always)]
pub fn presc (& self) -> PRESC_R { PRESC_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 4 - Enable Double Speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Master Operation Enable"]
# [inline (always)]
pub fn master (& self) -> MASTER_R { MASTER_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Data Order Setting"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable Module"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Prescaler"]
# [inline (always)]
# [must_use]
pub fn presc (& mut self) -> PRESC_W < 1 > { PRESC_W :: new (self) } # [doc = "Bit 4 - Enable Double Speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 4 > { CLK2X_W :: new (self) } # [doc = "Bit 5 - Master Operation Enable"]
# [inline (always)]
# [must_use]
pub fn master (& mut self) -> MASTER_W < 5 > { MASTER_W :: new (self) } # [doc = "Bit 6 - Data Order Setting"]
# [inline (always)]
# [must_use]
pub fn dord (& mut self) -> DORD_W < 6 > { DORD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MODE` reader - SPI Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; # [doc = "SPI Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: SPI Mode 0"]
_0 = 0 , # [doc = "1: SPI Mode 1"]
_1 = 1 , # [doc = "2: SPI Mode 2"]
_2 = 2 , # [doc = "3: SPI Mode 3"]
_3 = 3 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MODE_A { match self . bits { 0 => MODE_A :: _0 , 1 => MODE_A :: _1 , 2 => MODE_A :: _2 , 3 => MODE_A :: _3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == MODE_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == MODE_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == MODE_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == MODE_A :: _3 } } # [doc = "Field `MODE` writer - SPI Mode"]
pub type MODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , MODE_A , 2 , O > ; impl < 'a , const O : u8 > MODE_W < 'a , O > { # [doc = "SPI Mode 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (MODE_A :: _0) } # [doc = "SPI Mode 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (MODE_A :: _1) } # [doc = "SPI Mode 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (MODE_A :: _2) } # [doc = "SPI Mode 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (MODE_A :: _3) } } # [doc = "Field `SSD` reader - Slave Select Disable"]
pub type SSD_R = crate :: BitReader < bool > ; # [doc = "Field `SSD` writer - Slave Select Disable"]
pub type SSD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `BUFWR` reader - Buffer Write Mode"]
pub type BUFWR_R = crate :: BitReader < bool > ; # [doc = "Field `BUFWR` writer - Buffer Write Mode"]
pub type BUFWR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `BUFEN` reader - Buffer Mode Enable"]
pub type BUFEN_R = crate :: BitReader < bool > ; # [doc = "Field `BUFEN` writer - Buffer Mode Enable"]
pub type BUFEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - SPI Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (self . bits & 3) } # [doc = "Bit 2 - Slave Select Disable"]
# [inline (always)]
pub fn ssd (& self) -> SSD_R { SSD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Buffer Write Mode"]
# [inline (always)]
pub fn bufwr (& self) -> BUFWR_R { BUFWR_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Buffer Mode Enable"]
# [inline (always)]
pub fn bufen (& self) -> BUFEN_R { BUFEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - SPI Mode"]
# [inline (always)]
# [must_use]
pub fn mode (& mut self) -> MODE_W < 0 > { MODE_W :: new (self) } # [doc = "Bit 2 - Slave Select Disable"]
# [inline (always)]
# [must_use]
pub fn ssd (& mut self) -> SSD_W < 2 > { SSD_W :: new (self) } # [doc = "Bit 6 - Buffer Write Mode"]
# [inline (always)]
# [must_use]
pub fn bufwr (& mut self) -> BUFWR_W < 6 > { BUFWR_W :: new (self) } # [doc = "Bit 7 - Buffer Mode Enable"]
# [inline (always)]
# [must_use]
pub fn bufen (& mut self) -> BUFEN_W < 7 > { BUFEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `IE` reader - Interrupt Enable"]
pub type IE_R = crate :: BitReader < bool > ; # [doc = "Field `IE` writer - Interrupt Enable"]
pub type IE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `SSIE` reader - Slave Select Trigger Interrupt Enable"]
pub type SSIE_R = crate :: BitReader < bool > ; # [doc = "Field `SSIE` writer - Slave Select Trigger Interrupt Enable"]
pub type SSIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `DREIE` reader - Data Register Empty Interrupt Enable"]
pub type DREIE_R = crate :: BitReader < bool > ; # [doc = "Field `DREIE` writer - Data Register Empty Interrupt Enable"]
pub type DREIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `TXCIE` reader - Transfer Complete Interrupt Enable"]
pub type TXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE` writer - Transfer Complete Interrupt Enable"]
pub type TXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `RXCIE` reader - Receive Complete Interrupt Enable"]
pub type RXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE` writer - Receive Complete Interrupt Enable"]
pub type RXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Interrupt Enable"]
# [inline (always)]
pub fn ie (& self) -> IE_R { IE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Slave Select Trigger Interrupt Enable"]
# [inline (always)]
pub fn ssie (& self) -> SSIE_R { SSIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dreie (& self) -> DREIE_R { DREIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transfer Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie (& self) -> TXCIE_R { TXCIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie (& self) -> RXCIE_R { RXCIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ie (& mut self) -> IE_W < 0 > { IE_W :: new (self) } # [doc = "Bit 4 - Slave Select Trigger Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ssie (& mut self) -> SSIE_W < 4 > { SSIE_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dreie (& mut self) -> DREIE_W < 5 > { DREIE_W :: new (self) } # [doc = "Bit 6 - Transfer Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie (& mut self) -> TXCIE_W < 6 > { TXCIE_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie (& mut self) -> RXCIE_W < 7 > { RXCIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `BUFFERED_BUFOVF` reader - Buffer Overflow"]
pub type BUFFERED_BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFFERED_BUFOVF` writer - Buffer Overflow"]
pub type BUFFERED_BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `BUFFERED_SSIF` reader - Slave Select Trigger Interrupt Flag"]
pub type BUFFERED_SSIF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFFERED_SSIF` writer - Slave Select Trigger Interrupt Flag"]
pub type BUFFERED_SSIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `BUFFERED_DREIF` reader - Data Register Empty Interrupt Flag"]
pub type BUFFERED_DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFFERED_DREIF` writer - Data Register Empty Interrupt Flag"]
pub type BUFFERED_DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `BUFFERED_TXCIF` reader - Transfer Complete Interrupt Flag"]
pub type BUFFERED_TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFFERED_TXCIF` writer - Transfer Complete Interrupt Flag"]
pub type BUFFERED_TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `DEFAULT_WRCOL` reader - Write Collision"]
pub type DEFAULT_WRCOL_R = crate :: BitReader < bool > ; # [doc = "Field `DEFAULT_WRCOL` writer - Write Collision"]
pub type DEFAULT_WRCOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `BUFFERED_RXCIF` reader - Receive Complete Interrupt Flag"]
pub type BUFFERED_RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFFERED_RXCIF` writer - Receive Complete Interrupt Flag"]
pub type BUFFERED_RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `DEFAULT_IF` reader - Interrupt Flag"]
pub type DEFAULT_IF_R = crate :: BitReader < bool > ; # [doc = "Field `DEFAULT_IF` writer - Interrupt Flag"]
pub type DEFAULT_IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Buffer Overflow"]
# [inline (always)]
pub fn buffered_bufovf (& self) -> BUFFERED_BUFOVF_R { BUFFERED_BUFOVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Slave Select Trigger Interrupt Flag"]
# [inline (always)]
pub fn buffered_ssif (& self) -> BUFFERED_SSIF_R { BUFFERED_SSIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Flag"]
# [inline (always)]
pub fn buffered_dreif (& self) -> BUFFERED_DREIF_R { BUFFERED_DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transfer Complete Interrupt Flag"]
# [inline (always)]
pub fn buffered_txcif (& self) -> BUFFERED_TXCIF_R { BUFFERED_TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
pub fn default_wrcol (& self) -> DEFAULT_WRCOL_R { DEFAULT_WRCOL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn buffered_rxcif (& self) -> BUFFERED_RXCIF_R { BUFFERED_RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
pub fn default_if (& self) -> DEFAULT_IF_R { DEFAULT_IF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn buffered_bufovf (& mut self) -> BUFFERED_BUFOVF_W < 0 > { BUFFERED_BUFOVF_W :: new (self) } # [doc = "Bit 4 - Slave Select Trigger Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn buffered_ssif (& mut self) -> BUFFERED_SSIF_W < 4 > { BUFFERED_SSIF_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn buffered_dreif (& mut self) -> BUFFERED_DREIF_W < 5 > { BUFFERED_DREIF_W :: new (self) } # [doc = "Bit 6 - Transfer Complete Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn buffered_txcif (& mut self) -> BUFFERED_TXCIF_W < 6 > { BUFFERED_TXCIF_W :: new (self) } # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
# [must_use]
pub fn default_wrcol (& mut self) -> DEFAULT_WRCOL_W < 6 > { DEFAULT_WRCOL_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn buffered_rxcif (& mut self) -> BUFFERED_RXCIF_W < 7 > { BUFFERED_RXCIF_W :: new (self) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn default_if (& mut self) -> DEFAULT_IF_W < 7 > { DEFAULT_IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "System Configuration Registers"]
pub struct SYSCFG { _marker : PhantomData < * const () > } unsafe impl Send for SYSCFG { } impl SYSCFG { # [doc = r"Pointer to the register block"]
pub const PTR : * const syscfg :: RegisterBlock = 0x0f00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const syscfg :: RegisterBlock { Self :: PTR } } impl Deref for SYSCFG { type Target = syscfg :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SYSCFG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYSCFG") . finish () } } # [doc = "System Configuration Registers"]
pub mod syscfg { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved0 : [u8 ; 0x01]
, # [doc = "0x01 - Revision ID"]
pub revid : REVID , # [doc = "0x02 - External Break"]
pub extbrk : EXTBRK , _reserved2 : [u8 ; 0x15]
, # [doc = "0x18 - OCD Message Register"]
pub ocdm : OCDM , # [doc = "0x19 - OCD Message Status"]
pub ocdms : OCDMS , } # [doc = "EXTBRK (rw) register accessor: an alias for `Reg<EXTBRK_SPEC>`"]
pub type EXTBRK = crate :: Reg < extbrk :: EXTBRK_SPEC > ; # [doc = "External Break"]
pub mod extbrk { # [doc = "Register `EXTBRK` reader"]
pub struct R (crate :: R < EXTBRK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EXTBRK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EXTBRK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EXTBRK_SPEC >) -> Self { R (reader) } } # [doc = "Register `EXTBRK` writer"]
pub struct W (crate :: W < EXTBRK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EXTBRK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EXTBRK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EXTBRK_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENEXTBRK` reader - External break enable"]
pub type ENEXTBRK_R = crate :: BitReader < bool > ; # [doc = "Field `ENEXTBRK` writer - External break enable"]
pub type ENEXTBRK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EXTBRK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - External break enable"]
# [inline (always)]
pub fn enextbrk (& self) -> ENEXTBRK_R { ENEXTBRK_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - External break enable"]
# [inline (always)]
# [must_use]
pub fn enextbrk (& mut self) -> ENEXTBRK_W < 0 > { ENEXTBRK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Break\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [extbrk](index.html) module"]
pub struct EXTBRK_SPEC ; impl crate :: RegisterSpec for EXTBRK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [extbrk::R](R) reader structure"]
impl crate :: Readable for EXTBRK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [extbrk::W](W) writer structure"]
impl crate :: Writable for EXTBRK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EXTBRK to value 0"]
impl crate :: Resettable for EXTBRK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCDM (rw) register accessor: an alias for `Reg<OCDM_SPEC>`"]
pub type OCDM = crate :: Reg < ocdm :: OCDM_SPEC > ; # [doc = "OCD Message Register"]
pub mod ocdm { # [doc = "Register `OCDM` reader"]
pub struct R (crate :: R < OCDM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCDM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCDM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCDM_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCDM` writer"]
pub struct W (crate :: W < OCDM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCDM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCDM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCDM_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "OCD Message Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocdm](index.html) module"]
pub struct OCDM_SPEC ; impl crate :: RegisterSpec for OCDM_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocdm::R](R) reader structure"]
impl crate :: Readable for OCDM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocdm::W](W) writer structure"]
impl crate :: Writable for OCDM_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCDM to value 0"]
impl crate :: Resettable for OCDM_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCDMS (rw) register accessor: an alias for `Reg<OCDMS_SPEC>`"]
pub type OCDMS = crate :: Reg < ocdms :: OCDMS_SPEC > ; # [doc = "OCD Message Status"]
pub mod ocdms { # [doc = "Register `OCDMS` reader"]
pub struct R (crate :: R < OCDMS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCDMS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCDMS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCDMS_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCDMS` writer"]
pub struct W (crate :: W < OCDMS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCDMS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCDMS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCDMS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OCDMR` reader - OCD Message Read"]
pub type OCDMR_R = crate :: BitReader < bool > ; # [doc = "Field `OCDMR` writer - OCD Message Read"]
pub type OCDMR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OCDMS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - OCD Message Read"]
# [inline (always)]
pub fn ocdmr (& self) -> OCDMR_R { OCDMR_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - OCD Message Read"]
# [inline (always)]
# [must_use]
pub fn ocdmr (& mut self) -> OCDMR_W < 0 > { OCDMR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OCD Message Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocdms](index.html) module"]
pub struct OCDMS_SPEC ; impl crate :: RegisterSpec for OCDMS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocdms::R](R) reader structure"]
impl crate :: Readable for OCDMS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocdms::W](W) writer structure"]
impl crate :: Writable for OCDMS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCDMS to value 0"]
impl crate :: Resettable for OCDMS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "REVID (rw) register accessor: an alias for `Reg<REVID_SPEC>`"]
pub type REVID = crate :: Reg < revid :: REVID_SPEC > ; # [doc = "Revision ID"]
pub mod revid { # [doc = "Register `REVID` reader"]
pub struct R (crate :: R < REVID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < REVID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < REVID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < REVID_SPEC >) -> Self { R (reader) } } # [doc = "Register `REVID` writer"]
pub struct W (crate :: W < REVID_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < REVID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < REVID_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < REVID_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Revision ID\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [revid](index.html) module"]
pub struct REVID_SPEC ; impl crate :: RegisterSpec for REVID_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [revid::R](R) reader structure"]
impl crate :: Readable for REVID_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [revid::W](W) writer structure"]
impl crate :: Writable for REVID_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets REVID to value 0"]
impl crate :: Resettable for REVID_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter Type A"]
pub struct TCA0 { _marker : PhantomData < * const () > } unsafe impl Send for TCA0 { } impl TCA0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tca0 :: RegisterBlock = 0x0a00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tca0 :: RegisterBlock { Self :: PTR } } impl Deref for TCA0 { type Target = tca0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCA0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCA0") . finish () } } # [doc = "16-bit Timer/Counter Type A"]
pub mod tca0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_split : [u8 ; 0x3e]
, } impl RegisterBlock { # [doc = "0x00..0x2e - 16-bit Timer/Counter Type A - Split Mode"]
# [inline (always)]
pub const fn split (& self) -> & SPLIT { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (0usize) . cast () } } # [doc = "0x00..0x3e - 16-bit Timer/Counter Type A - Single Mode"]
# [inline (always)]
pub const fn single (& self) -> & SINGLE { unsafe { & * (self as * const Self) . cast :: < u8 > () . add (0usize) . cast () } } } # [doc = "16-bit Timer/Counter Type A - Single Mode"]
pub use self :: single :: SINGLE ; # [doc = r"Cluster"]
# [doc = "16-bit Timer/Counter Type A - Single Mode"]
pub mod single { # [doc = r"Register block"]
# [repr (C)]
pub struct SINGLE { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control E Clear"]
pub ctrleclr : CTRLECLR , # [doc = "0x05 - Control E Set"]
pub ctrleset : CTRLESET , # [doc = "0x06 - Control F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x07 - Control F Set"]
pub ctrlfset : CTRLFSET , _reserved8 : [u8 ; 0x01]
, # [doc = "0x09 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x0a - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x0b - Interrupt Flags"]
pub intflags : INTFLAGS , _reserved11 : [u8 ; 0x02]
, # [doc = "0x0e - Degbug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x0f - Temporary data for 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare 0"]
pub cmp0 : CMP0 , # [doc = "0x2a - Compare 1"]
pub cmp1 : CMP1 , # [doc = "0x2c - Compare 2"]
pub cmp2 : CMP2 , _reserved18 : [u8 ; 0x08]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare 0 Buffer"]
pub cmp0buf : CMP0BUF , # [doc = "0x3a - Compare 1 Buffer"]
pub cmp1buf : CMP1BUF , # [doc = "0x3c - Compare 2 Buffer"]
pub cmp2buf : CMP2BUF , } # [doc = "CMP0 (rw) register accessor: an alias for `Reg<CMP0_SPEC>`"]
pub type CMP0 = crate :: Reg < cmp0 :: CMP0_SPEC > ; # [doc = "Compare 0"]
pub mod cmp0 { # [doc = "Register `CMP0` reader"]
pub struct R (crate :: R < CMP0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP0_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP0` writer"]
pub struct W (crate :: W < CMP0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp0](index.html) module"]
pub struct CMP0_SPEC ; impl crate :: RegisterSpec for CMP0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp0::R](R) reader structure"]
impl crate :: Readable for CMP0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp0::W](W) writer structure"]
impl crate :: Writable for CMP0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP0 to value 0"]
impl crate :: Resettable for CMP0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP0BUF (rw) register accessor: an alias for `Reg<CMP0BUF_SPEC>`"]
pub type CMP0BUF = crate :: Reg < cmp0buf :: CMP0BUF_SPEC > ; # [doc = "Compare 0 Buffer"]
pub mod cmp0buf { # [doc = "Register `CMP0BUF` reader"]
pub struct R (crate :: R < CMP0BUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP0BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP0BUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP0BUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP0BUF` writer"]
pub struct W (crate :: W < CMP0BUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP0BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP0BUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP0BUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 0 Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp0buf](index.html) module"]
pub struct CMP0BUF_SPEC ; impl crate :: RegisterSpec for CMP0BUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp0buf::R](R) reader structure"]
impl crate :: Readable for CMP0BUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp0buf::W](W) writer structure"]
impl crate :: Writable for CMP0BUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP0BUF to value 0"]
impl crate :: Resettable for CMP0BUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP1 (rw) register accessor: an alias for `Reg<CMP1_SPEC>`"]
pub type CMP1 = crate :: Reg < cmp1 :: CMP1_SPEC > ; # [doc = "Compare 1"]
pub mod cmp1 { # [doc = "Register `CMP1` reader"]
pub struct R (crate :: R < CMP1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP1_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP1` writer"]
pub struct W (crate :: W < CMP1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp1](index.html) module"]
pub struct CMP1_SPEC ; impl crate :: RegisterSpec for CMP1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp1::R](R) reader structure"]
impl crate :: Readable for CMP1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp1::W](W) writer structure"]
impl crate :: Writable for CMP1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP1 to value 0"]
impl crate :: Resettable for CMP1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP1BUF (rw) register accessor: an alias for `Reg<CMP1BUF_SPEC>`"]
pub type CMP1BUF = crate :: Reg < cmp1buf :: CMP1BUF_SPEC > ; # [doc = "Compare 1 Buffer"]
pub mod cmp1buf { # [doc = "Register `CMP1BUF` reader"]
pub struct R (crate :: R < CMP1BUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP1BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP1BUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP1BUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP1BUF` writer"]
pub struct W (crate :: W < CMP1BUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP1BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP1BUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP1BUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 1 Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp1buf](index.html) module"]
pub struct CMP1BUF_SPEC ; impl crate :: RegisterSpec for CMP1BUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp1buf::R](R) reader structure"]
impl crate :: Readable for CMP1BUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp1buf::W](W) writer structure"]
impl crate :: Writable for CMP1BUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP1BUF to value 0"]
impl crate :: Resettable for CMP1BUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP2 (rw) register accessor: an alias for `Reg<CMP2_SPEC>`"]
pub type CMP2 = crate :: Reg < cmp2 :: CMP2_SPEC > ; # [doc = "Compare 2"]
pub mod cmp2 { # [doc = "Register `CMP2` reader"]
pub struct R (crate :: R < CMP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP2` writer"]
pub struct W (crate :: W < CMP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp2](index.html) module"]
pub struct CMP2_SPEC ; impl crate :: RegisterSpec for CMP2_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp2::R](R) reader structure"]
impl crate :: Readable for CMP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp2::W](W) writer structure"]
impl crate :: Writable for CMP2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP2 to value 0"]
impl crate :: Resettable for CMP2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP2BUF (rw) register accessor: an alias for `Reg<CMP2BUF_SPEC>`"]
pub type CMP2BUF = crate :: Reg < cmp2buf :: CMP2BUF_SPEC > ; # [doc = "Compare 2 Buffer"]
pub mod cmp2buf { # [doc = "Register `CMP2BUF` reader"]
pub struct R (crate :: R < CMP2BUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP2BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP2BUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP2BUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP2BUF` writer"]
pub struct W (crate :: W < CMP2BUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP2BUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP2BUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP2BUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare 2 Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp2buf](index.html) module"]
pub struct CMP2BUF_SPEC ; impl crate :: RegisterSpec for CMP2BUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp2buf::R](R) reader structure"]
impl crate :: Readable for CMP2BUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp2buf::W](W) writer structure"]
impl crate :: Writable for CMP2BUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP2BUF to value 0"]
impl crate :: Resettable for CMP2BUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Module Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Module Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: System Clock"]
DIV1 = 0 , # [doc = "1: System Clock / 2"]
DIV2 = 1 , # [doc = "2: System Clock / 4"]
DIV4 = 2 , # [doc = "3: System Clock / 8"]
DIV8 = 3 , # [doc = "4: System Clock / 16"]
DIV16 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: DIV1 , 1 => CLKSEL_A :: DIV2 , 2 => CLKSEL_A :: DIV4 , 3 => CLKSEL_A :: DIV8 , 4 => CLKSEL_A :: DIV16 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == CLKSEL_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 3 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } } impl R { # [doc = "Bit 0 - Module Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 7) } } impl W { # [doc = "Bit 0 - Module Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope PWM"]
SINGLESLOPE = 3 , # [doc = "5: Dual Slope PWM, overflow on TOP"]
DSTOP = 5 , # [doc = "6: Dual Slope PWM, overflow on TOP and BOTTOM"]
DSBOTH = 6 , # [doc = "7: Dual Slope PWM, overflow on BOTTOM"]
DSBOTTOM = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SINGLESLOPE) , 5 => Some (WGMODE_A :: DSTOP) , 6 => Some (WGMODE_A :: DSBOTH) , 7 => Some (WGMODE_A :: DSBOTTOM) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SINGLESLOPE`"]
# [inline (always)]
pub fn is_singleslope (& self) -> bool { * self == WGMODE_A :: SINGLESLOPE } # [doc = "Checks if the value of the field is `DSTOP`"]
# [inline (always)]
pub fn is_dstop (& self) -> bool { * self == WGMODE_A :: DSTOP } # [doc = "Checks if the value of the field is `DSBOTH`"]
# [inline (always)]
pub fn is_dsboth (& self) -> bool { * self == WGMODE_A :: DSBOTH } # [doc = "Checks if the value of the field is `DSBOTTOM`"]
# [inline (always)]
pub fn is_dsbottom (& self) -> bool { * self == WGMODE_A :: DSBOTTOM } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope PWM"]
# [inline (always)]
pub fn singleslope (self) -> & 'a mut W { self . variant (WGMODE_A :: SINGLESLOPE) } # [doc = "Dual Slope PWM, overflow on TOP"]
# [inline (always)]
pub fn dstop (self) -> & 'a mut W { self . variant (WGMODE_A :: DSTOP) } # [doc = "Dual Slope PWM, overflow on TOP and BOTTOM"]
# [inline (always)]
pub fn dsboth (self) -> & 'a mut W { self . variant (WGMODE_A :: DSBOTH) } # [doc = "Dual Slope PWM, overflow on BOTTOM"]
# [inline (always)]
pub fn dsbottom (self) -> & 'a mut W { self . variant (WGMODE_A :: DSBOTTOM) } } # [doc = "Field `ALUPD` reader - Auto Lock Update"]
pub type ALUPD_R = crate :: BitReader < bool > ; # [doc = "Field `ALUPD` writer - Auto Lock Update"]
pub type ALUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CMP0EN` reader - Compare 0 Enable"]
pub type CMP0EN_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0EN` writer - Compare 0 Enable"]
pub type CMP0EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CMP1EN` reader - Compare 1 Enable"]
pub type CMP1EN_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1EN` writer - Compare 1 Enable"]
pub type CMP1EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CMP2EN` reader - Compare 2 Enable"]
pub type CMP2EN_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2EN` writer - Compare 2 Enable"]
pub type CMP2EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 3 - Auto Lock Update"]
# [inline (always)]
pub fn alupd (& self) -> ALUPD_R { ALUPD_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare 0 Enable"]
# [inline (always)]
pub fn cmp0en (& self) -> CMP0EN_R { CMP0EN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare 1 Enable"]
# [inline (always)]
pub fn cmp1en (& self) -> CMP1EN_R { CMP1EN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare 2 Enable"]
# [inline (always)]
pub fn cmp2en (& self) -> CMP2EN_R { CMP2EN_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 3 - Auto Lock Update"]
# [inline (always)]
# [must_use]
pub fn alupd (& mut self) -> ALUPD_W < 3 > { ALUPD_W :: new (self) } # [doc = "Bit 4 - Compare 0 Enable"]
# [inline (always)]
# [must_use]
pub fn cmp0en (& mut self) -> CMP0EN_W < 4 > { CMP0EN_W :: new (self) } # [doc = "Bit 5 - Compare 1 Enable"]
# [inline (always)]
# [must_use]
pub fn cmp1en (& mut self) -> CMP1EN_W < 5 > { CMP1EN_W :: new (self) } # [doc = "Bit 6 - Compare 2 Enable"]
# [inline (always)]
# [must_use]
pub fn cmp2en (& mut self) -> CMP2EN_W < 6 > { CMP2EN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP0OV` reader - Compare 0 Waveform Output Value"]
pub type CMP0OV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0OV` writer - Compare 0 Waveform Output Value"]
pub type CMP0OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMP1OV` reader - Compare 1 Waveform Output Value"]
pub type CMP1OV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1OV` writer - Compare 1 Waveform Output Value"]
pub type CMP1OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMP2OV` reader - Compare 2 Waveform Output Value"]
pub type CMP2OV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2OV` writer - Compare 2 Waveform Output Value"]
pub type CMP2OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare 0 Waveform Output Value"]
# [inline (always)]
pub fn cmp0ov (& self) -> CMP0OV_R { CMP0OV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 1 Waveform Output Value"]
# [inline (always)]
pub fn cmp1ov (& self) -> CMP1OV_R { CMP1OV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare 2 Waveform Output Value"]
# [inline (always)]
pub fn cmp2ov (& self) -> CMP2OV_R { CMP2OV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare 0 Waveform Output Value"]
# [inline (always)]
# [must_use]
pub fn cmp0ov (& mut self) -> CMP0OV_W < 0 > { CMP0OV_W :: new (self) } # [doc = "Bit 1 - Compare 1 Waveform Output Value"]
# [inline (always)]
# [must_use]
pub fn cmp1ov (& mut self) -> CMP1OV_W < 1 > { CMP1OV_W :: new (self) } # [doc = "Bit 2 - Compare 2 Waveform Output Value"]
# [inline (always)]
# [must_use]
pub fn cmp2ov (& mut self) -> CMP2OV_W < 2 > { CMP2OV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPLITM` reader - Split Mode Enable"]
pub type SPLITM_R = crate :: BitReader < bool > ; # [doc = "Field `SPLITM` writer - Split Mode Enable"]
pub type SPLITM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Split Mode Enable"]
# [inline (always)]
pub fn splitm (& self) -> SPLITM_R { SPLITM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Split Mode Enable"]
# [inline (always)]
# [must_use]
pub fn splitm (& mut self) -> SPLITM_W < 0 > { SPLITM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLECLR (rw) register accessor: an alias for `Reg<CTRLECLR_SPEC>`"]
pub type CTRLECLR = crate :: Reg < ctrleclr :: CTRLECLR_SPEC > ; # [doc = "Control E Clear"]
pub mod ctrleclr { # [doc = "Register `CTRLECLR` reader"]
pub struct R (crate :: R < CTRLECLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLECLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLECLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLECLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLECLR` writer"]
pub struct W (crate :: W < CTRLECLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLECLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLECLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLECLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLECLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLECLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLECLR_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrleclr](index.html) module"]
pub struct CTRLECLR_SPEC ; impl crate :: RegisterSpec for CTRLECLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrleclr::R](R) reader structure"]
impl crate :: Readable for CTRLECLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrleclr::W](W) writer structure"]
impl crate :: Writable for CTRLECLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLECLR to value 0"]
impl crate :: Resettable for CTRLECLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLESET (rw) register accessor: an alias for `Reg<CTRLESET_SPEC>`"]
pub type CTRLESET = crate :: Reg < ctrleset :: CTRLESET_SPEC > ; # [doc = "Control E Set"]
pub mod ctrleset { # [doc = "Register `CTRLESET` reader"]
pub struct R (crate :: R < CTRLESET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLESET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLESET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLESET` writer"]
pub struct W (crate :: W < CTRLESET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLESET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLESET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < DIR_A > ; # [doc = "Direction\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DIR_A { # [doc = "0: Count up"]
UP = 0 , # [doc = "1: Count down"]
DOWN = 1 , } impl From < DIR_A > for bool { # [inline (always)]
fn from (variant : DIR_A) -> Self { variant as u8 != 0 } } impl DIR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIR_A { match self . bits { false => DIR_A :: UP , true => DIR_A :: DOWN , } } # [doc = "Checks if the value of the field is `UP`"]
# [inline (always)]
pub fn is_up (& self) -> bool { * self == DIR_A :: UP } # [doc = "Checks if the value of the field is `DOWN`"]
# [inline (always)]
pub fn is_down (& self) -> bool { * self == DIR_A :: DOWN } } # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLESET_SPEC , DIR_A , O > ; impl < 'a , const O : u8 > DIR_W < 'a , O > { # [doc = "Count up"]
# [inline (always)]
pub fn up (self) -> & 'a mut W { self . variant (DIR_A :: UP) } # [doc = "Count down"]
# [inline (always)]
pub fn down (self) -> & 'a mut W { self . variant (DIR_A :: DOWN) } } # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLESET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLESET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrleset](index.html) module"]
pub struct CTRLESET_SPEC ; impl crate :: RegisterSpec for CTRLESET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrleset::R](R) reader structure"]
impl crate :: Readable for CTRLESET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrleset::W](W) writer structure"]
impl crate :: Writable for CTRLESET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLESET to value 0"]
impl crate :: Resettable for CTRLESET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMP0BV` reader - Compare 0 Buffer Valid"]
pub type CMP0BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0BV` writer - Compare 0 Buffer Valid"]
pub type CMP0BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMP1BV` reader - Compare 1 Buffer Valid"]
pub type CMP1BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1BV` writer - Compare 1 Buffer Valid"]
pub type CMP1BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMP2BV` reader - Compare 2 Buffer Valid"]
pub type CMP2BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2BV` writer - Compare 2 Buffer Valid"]
pub type CMP2BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 0 Buffer Valid"]
# [inline (always)]
pub fn cmp0bv (& self) -> CMP0BV_R { CMP0BV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare 1 Buffer Valid"]
# [inline (always)]
pub fn cmp1bv (& self) -> CMP1BV_R { CMP1BV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare 2 Buffer Valid"]
# [inline (always)]
pub fn cmp2bv (& self) -> CMP2BV_R { CMP2BV_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare 0 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp0bv (& mut self) -> CMP0BV_W < 1 > { CMP0BV_W :: new (self) } # [doc = "Bit 2 - Compare 1 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp1bv (& mut self) -> CMP1BV_W < 2 > { CMP1BV_W :: new (self) } # [doc = "Bit 3 - Compare 2 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp2bv (& mut self) -> CMP2BV_W < 3 > { CMP2BV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMP0BV` reader - Compare 0 Buffer Valid"]
pub type CMP0BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0BV` writer - Compare 0 Buffer Valid"]
pub type CMP0BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMP1BV` reader - Compare 1 Buffer Valid"]
pub type CMP1BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1BV` writer - Compare 1 Buffer Valid"]
pub type CMP1BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMP2BV` reader - Compare 2 Buffer Valid"]
pub type CMP2BV_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2BV` writer - Compare 2 Buffer Valid"]
pub type CMP2BV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 0 Buffer Valid"]
# [inline (always)]
pub fn cmp0bv (& self) -> CMP0BV_R { CMP0BV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare 1 Buffer Valid"]
# [inline (always)]
pub fn cmp1bv (& self) -> CMP1BV_R { CMP1BV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare 2 Buffer Valid"]
# [inline (always)]
pub fn cmp2bv (& self) -> CMP2BV_R { CMP2BV_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare 0 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp0bv (& mut self) -> CMP0BV_W < 1 > { CMP0BV_W :: new (self) } # [doc = "Bit 2 - Compare 1 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp1bv (& mut self) -> CMP1BV_W < 2 > { CMP1BV_W :: new (self) } # [doc = "Bit 3 - Compare 2 Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cmp2bv (& mut self) -> CMP2BV_W < 3 > { CMP2BV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Degbug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Degbug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CNTEI` reader - Count on Event Input"]
pub type CNTEI_R = crate :: BitReader < bool > ; # [doc = "Field `CNTEI` writer - Count on Event Input"]
pub type CNTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: Count on positive edge event"]
POSEDGE = 0 , # [doc = "1: Count on any edge event"]
ANYEDGE = 1 , # [doc = "2: Count on prescaled clock while event line is 1."]
HIGHLVL = 2 , # [doc = "3: Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1."]
UPDOWN = 3 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EVACT_A { match self . bits { 0 => EVACT_A :: POSEDGE , 1 => EVACT_A :: ANYEDGE , 2 => EVACT_A :: HIGHLVL , 3 => EVACT_A :: UPDOWN , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `POSEDGE`"]
# [inline (always)]
pub fn is_posedge (& self) -> bool { * self == EVACT_A :: POSEDGE } # [doc = "Checks if the value of the field is `ANYEDGE`"]
# [inline (always)]
pub fn is_anyedge (& self) -> bool { * self == EVACT_A :: ANYEDGE } # [doc = "Checks if the value of the field is `HIGHLVL`"]
# [inline (always)]
pub fn is_highlvl (& self) -> bool { * self == EVACT_A :: HIGHLVL } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EVCTRL_SPEC , u8 , EVACT_A , 2 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "Count on positive edge event"]
# [inline (always)]
pub fn posedge (self) -> & 'a mut W { self . variant (EVACT_A :: POSEDGE) } # [doc = "Count on any edge event"]
# [inline (always)]
pub fn anyedge (self) -> & 'a mut W { self . variant (EVACT_A :: ANYEDGE) } # [doc = "Count on prescaled clock while event line is 1."]
# [inline (always)]
pub fn highlvl (self) -> & 'a mut W { self . variant (EVACT_A :: HIGHLVL) } # [doc = "Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1."]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } } impl R { # [doc = "Bit 0 - Count on Event Input"]
# [inline (always)]
pub fn cntei (& self) -> CNTEI_R { CNTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - Count on Event Input"]
# [inline (always)]
# [must_use]
pub fn cntei (& mut self) -> CNTEI_W < 0 > { CNTEI_W :: new (self) } # [doc = "Bits 1:2 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 1 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `CMP0` reader - Compare 0 Interrupt"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0 Interrupt"]
pub type CMP0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `CMP1` reader - Compare 1 Interrupt"]
pub type CMP1_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1` writer - Compare 1 Interrupt"]
pub type CMP1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `CMP2` reader - Compare 2 Interrupt"]
pub type CMP2_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2` writer - Compare 2 Interrupt"]
pub type CMP2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Compare 0 Interrupt"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare 1 Interrupt"]
# [inline (always)]
pub fn cmp1 (& self) -> CMP1_R { CMP1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare 2 Interrupt"]
# [inline (always)]
pub fn cmp2 (& self) -> CMP2_R { CMP2_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 4 - Compare 0 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp0 (& mut self) -> CMP0_W < 4 > { CMP0_W :: new (self) } # [doc = "Bit 5 - Compare 1 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp1 (& mut self) -> CMP1_W < 5 > { CMP1_W :: new (self) } # [doc = "Bit 6 - Compare 2 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp2 (& mut self) -> CMP2_W < 6 > { CMP2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt"]
pub type OVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CMP0` reader - Compare 0 Interrupt"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0 Interrupt"]
pub type CMP0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CMP1` reader - Compare 1 Interrupt"]
pub type CMP1_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1` writer - Compare 1 Interrupt"]
pub type CMP1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CMP2` reader - Compare 2 Interrupt"]
pub type CMP2_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2` writer - Compare 2 Interrupt"]
pub type CMP2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Compare 0 Interrupt"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare 1 Interrupt"]
# [inline (always)]
pub fn cmp1 (& self) -> CMP1_R { CMP1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare 2 Interrupt"]
# [inline (always)]
pub fn cmp2 (& self) -> CMP2_R { CMP2_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt"]
# [inline (always)]
# [must_use]
pub fn ovf (& mut self) -> OVF_W < 0 > { OVF_W :: new (self) } # [doc = "Bit 4 - Compare 0 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp0 (& mut self) -> CMP0_W < 4 > { CMP0_W :: new (self) } # [doc = "Bit 5 - Compare 1 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp1 (& mut self) -> CMP1_W < 5 > { CMP1_W :: new (self) } # [doc = "Bit 6 - Compare 2 Interrupt"]
# [inline (always)]
# [must_use]
pub fn cmp2 (& mut self) -> CMP2_W < 6 > { CMP2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary data for 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary data for 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter Type A - Split Mode"]
pub use self :: split :: SPLIT ; # [doc = r"Cluster"]
# [doc = "16-bit Timer/Counter Type A - Split Mode"]
pub mod split { # [doc = r"Register block"]
# [repr (C)]
pub struct SPLIT { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control E Clear"]
pub ctrleclr : CTRLECLR , # [doc = "0x05 - Control E Set"]
pub ctrleset : CTRLESET , _reserved6 : [u8 ; 0x04]
, # [doc = "0x0a - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x0b - Interrupt Flags"]
pub intflags : INTFLAGS , _reserved8 : [u8 ; 0x02]
, # [doc = "0x0e - Degbug Control"]
pub dbgctrl : DBGCTRL , _reserved9 : [u8 ; 0x11]
, # [doc = "0x20 - Low Count"]
pub lcnt : LCNT , # [doc = "0x21 - High Count"]
pub hcnt : HCNT , _reserved11 : [u8 ; 0x04]
, # [doc = "0x26 - Low Period"]
pub lper : LPER , # [doc = "0x27 - High Period"]
pub hper : HPER , # [doc = "0x28 - Low Compare"]
pub lcmp0 : LCMP0 , # [doc = "0x29 - High Compare"]
pub hcmp0 : HCMP0 , # [doc = "0x2a - Low Compare"]
pub lcmp1 : LCMP1 , # [doc = "0x2b - High Compare"]
pub hcmp1 : HCMP1 , # [doc = "0x2c - Low Compare"]
pub lcmp2 : LCMP2 , # [doc = "0x2d - High Compare"]
pub hcmp2 : HCMP2 , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Module Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Module Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: System Clock"]
DIV1 = 0 , # [doc = "1: System Clock / 2"]
DIV2 = 1 , # [doc = "2: System Clock / 4"]
DIV4 = 2 , # [doc = "3: System Clock / 8"]
DIV8 = 3 , # [doc = "4: System Clock / 16"]
DIV16 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: DIV1 , 1 => CLKSEL_A :: DIV2 , 2 => CLKSEL_A :: DIV4 , 3 => CLKSEL_A :: DIV8 , 4 => CLKSEL_A :: DIV16 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == CLKSEL_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 3 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } } impl R { # [doc = "Bit 0 - Module Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 7) } } impl W { # [doc = "Bit 0 - Module Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `LCMP0EN` reader - Low Compare 0 Enable"]
pub type LCMP0EN_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP0EN` writer - Low Compare 0 Enable"]
pub type LCMP0EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `LCMP1EN` reader - Low Compare 1 Enable"]
pub type LCMP1EN_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP1EN` writer - Low Compare 1 Enable"]
pub type LCMP1EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `LCMP2EN` reader - Low Compare 2 Enable"]
pub type LCMP2EN_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP2EN` writer - Low Compare 2 Enable"]
pub type LCMP2EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `HCMP0EN` reader - High Compare 0 Enable"]
pub type HCMP0EN_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP0EN` writer - High Compare 0 Enable"]
pub type HCMP0EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `HCMP1EN` reader - High Compare 1 Enable"]
pub type HCMP1EN_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP1EN` writer - High Compare 1 Enable"]
pub type HCMP1EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `HCMP2EN` reader - High Compare 2 Enable"]
pub type HCMP2EN_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP2EN` writer - High Compare 2 Enable"]
pub type HCMP2EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Compare 0 Enable"]
# [inline (always)]
pub fn lcmp0en (& self) -> LCMP0EN_R { LCMP0EN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Low Compare 1 Enable"]
# [inline (always)]
pub fn lcmp1en (& self) -> LCMP1EN_R { LCMP1EN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Low Compare 2 Enable"]
# [inline (always)]
pub fn lcmp2en (& self) -> LCMP2EN_R { LCMP2EN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - High Compare 0 Enable"]
# [inline (always)]
pub fn hcmp0en (& self) -> HCMP0EN_R { HCMP0EN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - High Compare 1 Enable"]
# [inline (always)]
pub fn hcmp1en (& self) -> HCMP1EN_R { HCMP1EN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - High Compare 2 Enable"]
# [inline (always)]
pub fn hcmp2en (& self) -> HCMP2EN_R { HCMP2EN_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Compare 0 Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp0en (& mut self) -> LCMP0EN_W < 0 > { LCMP0EN_W :: new (self) } # [doc = "Bit 1 - Low Compare 1 Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp1en (& mut self) -> LCMP1EN_W < 1 > { LCMP1EN_W :: new (self) } # [doc = "Bit 2 - Low Compare 2 Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp2en (& mut self) -> LCMP2EN_W < 2 > { LCMP2EN_W :: new (self) } # [doc = "Bit 4 - High Compare 0 Enable"]
# [inline (always)]
# [must_use]
pub fn hcmp0en (& mut self) -> HCMP0EN_W < 4 > { HCMP0EN_W :: new (self) } # [doc = "Bit 5 - High Compare 1 Enable"]
# [inline (always)]
# [must_use]
pub fn hcmp1en (& mut self) -> HCMP1EN_W < 5 > { HCMP1EN_W :: new (self) } # [doc = "Bit 6 - High Compare 2 Enable"]
# [inline (always)]
# [must_use]
pub fn hcmp2en (& mut self) -> HCMP2EN_W < 6 > { HCMP2EN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `LCMP0OV` reader - Low Compare 0 Output Value"]
pub type LCMP0OV_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP0OV` writer - Low Compare 0 Output Value"]
pub type LCMP0OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `LCMP1OV` reader - Low Compare 1 Output Value"]
pub type LCMP1OV_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP1OV` writer - Low Compare 1 Output Value"]
pub type LCMP1OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `LCMP2OV` reader - Low Compare 2 Output Value"]
pub type LCMP2OV_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP2OV` writer - Low Compare 2 Output Value"]
pub type LCMP2OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `HCMP0OV` reader - High Compare 0 Output Value"]
pub type HCMP0OV_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP0OV` writer - High Compare 0 Output Value"]
pub type HCMP0OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `HCMP1OV` reader - High Compare 1 Output Value"]
pub type HCMP1OV_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP1OV` writer - High Compare 1 Output Value"]
pub type HCMP1OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `HCMP2OV` reader - High Compare 2 Output Value"]
pub type HCMP2OV_R = crate :: BitReader < bool > ; # [doc = "Field `HCMP2OV` writer - High Compare 2 Output Value"]
pub type HCMP2OV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Compare 0 Output Value"]
# [inline (always)]
pub fn lcmp0ov (& self) -> LCMP0OV_R { LCMP0OV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Low Compare 1 Output Value"]
# [inline (always)]
pub fn lcmp1ov (& self) -> LCMP1OV_R { LCMP1OV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Low Compare 2 Output Value"]
# [inline (always)]
pub fn lcmp2ov (& self) -> LCMP2OV_R { LCMP2OV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - High Compare 0 Output Value"]
# [inline (always)]
pub fn hcmp0ov (& self) -> HCMP0OV_R { HCMP0OV_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - High Compare 1 Output Value"]
# [inline (always)]
pub fn hcmp1ov (& self) -> HCMP1OV_R { HCMP1OV_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - High Compare 2 Output Value"]
# [inline (always)]
pub fn hcmp2ov (& self) -> HCMP2OV_R { HCMP2OV_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Compare 0 Output Value"]
# [inline (always)]
# [must_use]
pub fn lcmp0ov (& mut self) -> LCMP0OV_W < 0 > { LCMP0OV_W :: new (self) } # [doc = "Bit 1 - Low Compare 1 Output Value"]
# [inline (always)]
# [must_use]
pub fn lcmp1ov (& mut self) -> LCMP1OV_W < 1 > { LCMP1OV_W :: new (self) } # [doc = "Bit 2 - Low Compare 2 Output Value"]
# [inline (always)]
# [must_use]
pub fn lcmp2ov (& mut self) -> LCMP2OV_W < 2 > { LCMP2OV_W :: new (self) } # [doc = "Bit 4 - High Compare 0 Output Value"]
# [inline (always)]
# [must_use]
pub fn hcmp0ov (& mut self) -> HCMP0OV_W < 4 > { HCMP0OV_W :: new (self) } # [doc = "Bit 5 - High Compare 1 Output Value"]
# [inline (always)]
# [must_use]
pub fn hcmp1ov (& mut self) -> HCMP1OV_W < 5 > { HCMP1OV_W :: new (self) } # [doc = "Bit 6 - High Compare 2 Output Value"]
# [inline (always)]
# [must_use]
pub fn hcmp2ov (& mut self) -> HCMP2OV_W < 6 > { HCMP2OV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPLITM` reader - Split Mode Enable"]
pub type SPLITM_R = crate :: BitReader < bool > ; # [doc = "Field `SPLITM` writer - Split Mode Enable"]
pub type SPLITM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Split Mode Enable"]
# [inline (always)]
pub fn splitm (& self) -> SPLITM_R { SPLITM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Split Mode Enable"]
# [inline (always)]
# [must_use]
pub fn splitm (& mut self) -> SPLITM_W < 0 > { SPLITM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLECLR (rw) register accessor: an alias for `Reg<CTRLECLR_SPEC>`"]
pub type CTRLECLR = crate :: Reg < ctrleclr :: CTRLECLR_SPEC > ; # [doc = "Control E Clear"]
pub mod ctrleclr { # [doc = "Register `CTRLECLR` reader"]
pub struct R (crate :: R < CTRLECLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLECLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLECLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLECLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLECLR` writer"]
pub struct W (crate :: W < CTRLECLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLECLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLECLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLECLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLECLR_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrleclr](index.html) module"]
pub struct CTRLECLR_SPEC ; impl crate :: RegisterSpec for CTRLECLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrleclr::R](R) reader structure"]
impl crate :: Readable for CTRLECLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrleclr::W](W) writer structure"]
impl crate :: Writable for CTRLECLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLECLR to value 0"]
impl crate :: Resettable for CTRLECLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLESET (rw) register accessor: an alias for `Reg<CTRLESET_SPEC>`"]
pub type CTRLESET = crate :: Reg < ctrleset :: CTRLESET_SPEC > ; # [doc = "Control E Set"]
pub mod ctrleset { # [doc = "Register `CTRLESET` reader"]
pub struct R (crate :: R < CTRLESET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLESET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLESET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLESET` writer"]
pub struct W (crate :: W < CTRLESET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLESET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLESET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLESET_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLESET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control E Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrleset](index.html) module"]
pub struct CTRLESET_SPEC ; impl crate :: RegisterSpec for CTRLESET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrleset::R](R) reader structure"]
impl crate :: Readable for CTRLESET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrleset::W](W) writer structure"]
impl crate :: Writable for CTRLESET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLESET to value 0"]
impl crate :: Resettable for CTRLESET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Degbug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Degbug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "HCMP0 (rw) register accessor: an alias for `Reg<HCMP0_SPEC>`"]
pub type HCMP0 = crate :: Reg < hcmp0 :: HCMP0_SPEC > ; # [doc = "High Compare"]
pub mod hcmp0 { # [doc = "Register `HCMP0` reader"]
pub struct R (crate :: R < HCMP0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < HCMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < HCMP0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < HCMP0_SPEC >) -> Self { R (reader) } } # [doc = "Register `HCMP0` writer"]
pub struct W (crate :: W < HCMP0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < HCMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < HCMP0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < HCMP0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [hcmp0](index.html) module"]
pub struct HCMP0_SPEC ; impl crate :: RegisterSpec for HCMP0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [hcmp0::R](R) reader structure"]
impl crate :: Readable for HCMP0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [hcmp0::W](W) writer structure"]
impl crate :: Writable for HCMP0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HCMP0 to value 0"]
impl crate :: Resettable for HCMP0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "HCMP1 (rw) register accessor: an alias for `Reg<HCMP1_SPEC>`"]
pub type HCMP1 = crate :: Reg < hcmp1 :: HCMP1_SPEC > ; # [doc = "High Compare"]
pub mod hcmp1 { # [doc = "Register `HCMP1` reader"]
pub struct R (crate :: R < HCMP1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < HCMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < HCMP1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < HCMP1_SPEC >) -> Self { R (reader) } } # [doc = "Register `HCMP1` writer"]
pub struct W (crate :: W < HCMP1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < HCMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < HCMP1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < HCMP1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [hcmp1](index.html) module"]
pub struct HCMP1_SPEC ; impl crate :: RegisterSpec for HCMP1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [hcmp1::R](R) reader structure"]
impl crate :: Readable for HCMP1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [hcmp1::W](W) writer structure"]
impl crate :: Writable for HCMP1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HCMP1 to value 0"]
impl crate :: Resettable for HCMP1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "HCMP2 (rw) register accessor: an alias for `Reg<HCMP2_SPEC>`"]
pub type HCMP2 = crate :: Reg < hcmp2 :: HCMP2_SPEC > ; # [doc = "High Compare"]
pub mod hcmp2 { # [doc = "Register `HCMP2` reader"]
pub struct R (crate :: R < HCMP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < HCMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < HCMP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < HCMP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `HCMP2` writer"]
pub struct W (crate :: W < HCMP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < HCMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < HCMP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < HCMP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [hcmp2](index.html) module"]
pub struct HCMP2_SPEC ; impl crate :: RegisterSpec for HCMP2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [hcmp2::R](R) reader structure"]
impl crate :: Readable for HCMP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [hcmp2::W](W) writer structure"]
impl crate :: Writable for HCMP2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HCMP2 to value 0"]
impl crate :: Resettable for HCMP2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "HCNT (rw) register accessor: an alias for `Reg<HCNT_SPEC>`"]
pub type HCNT = crate :: Reg < hcnt :: HCNT_SPEC > ; # [doc = "High Count"]
pub mod hcnt { # [doc = "Register `HCNT` reader"]
pub struct R (crate :: R < HCNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < HCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < HCNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < HCNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `HCNT` writer"]
pub struct W (crate :: W < HCNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < HCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < HCNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < HCNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [hcnt](index.html) module"]
pub struct HCNT_SPEC ; impl crate :: RegisterSpec for HCNT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [hcnt::R](R) reader structure"]
impl crate :: Readable for HCNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [hcnt::W](W) writer structure"]
impl crate :: Writable for HCNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HCNT to value 0"]
impl crate :: Resettable for HCNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "HPER (rw) register accessor: an alias for `Reg<HPER_SPEC>`"]
pub type HPER = crate :: Reg < hper :: HPER_SPEC > ; # [doc = "High Period"]
pub mod hper { # [doc = "Register `HPER` reader"]
pub struct R (crate :: R < HPER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < HPER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < HPER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < HPER_SPEC >) -> Self { R (reader) } } # [doc = "Register `HPER` writer"]
pub struct W (crate :: W < HPER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < HPER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < HPER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < HPER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "High Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [hper](index.html) module"]
pub struct HPER_SPEC ; impl crate :: RegisterSpec for HPER_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [hper::R](R) reader structure"]
impl crate :: Readable for HPER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [hper::W](W) writer structure"]
impl crate :: Writable for HPER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HPER to value 0"]
impl crate :: Resettable for HPER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `LUNF` reader - Low Underflow Interrupt Enable"]
pub type LUNF_R = crate :: BitReader < bool > ; # [doc = "Field `LUNF` writer - Low Underflow Interrupt Enable"]
pub type LUNF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `HUNF` reader - High Underflow Interrupt Enable"]
pub type HUNF_R = crate :: BitReader < bool > ; # [doc = "Field `HUNF` writer - High Underflow Interrupt Enable"]
pub type HUNF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `LCMP0` reader - Low Compare 0 Interrupt Enable"]
pub type LCMP0_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP0` writer - Low Compare 0 Interrupt Enable"]
pub type LCMP0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `LCMP1` reader - Low Compare 1 Interrupt Enable"]
pub type LCMP1_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP1` writer - Low Compare 1 Interrupt Enable"]
pub type LCMP1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; # [doc = "Field `LCMP2` reader - Low Compare 2 Interrupt Enable"]
pub type LCMP2_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP2` writer - Low Compare 2 Interrupt Enable"]
pub type LCMP2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Underflow Interrupt Enable"]
# [inline (always)]
pub fn lunf (& self) -> LUNF_R { LUNF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - High Underflow Interrupt Enable"]
# [inline (always)]
pub fn hunf (& self) -> HUNF_R { HUNF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Low Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn lcmp0 (& self) -> LCMP0_R { LCMP0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Low Compare 1 Interrupt Enable"]
# [inline (always)]
pub fn lcmp1 (& self) -> LCMP1_R { LCMP1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Low Compare 2 Interrupt Enable"]
# [inline (always)]
pub fn lcmp2 (& self) -> LCMP2_R { LCMP2_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Underflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn lunf (& mut self) -> LUNF_W < 0 > { LUNF_W :: new (self) } # [doc = "Bit 1 - High Underflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn hunf (& mut self) -> HUNF_W < 1 > { HUNF_W :: new (self) } # [doc = "Bit 4 - Low Compare 0 Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp0 (& mut self) -> LCMP0_W < 4 > { LCMP0_W :: new (self) } # [doc = "Bit 5 - Low Compare 1 Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp1 (& mut self) -> LCMP1_W < 5 > { LCMP1_W :: new (self) } # [doc = "Bit 6 - Low Compare 2 Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn lcmp2 (& mut self) -> LCMP2_W < 6 > { LCMP2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `LUNF` reader - Low Underflow Interrupt Flag"]
pub type LUNF_R = crate :: BitReader < bool > ; # [doc = "Field `LUNF` writer - Low Underflow Interrupt Flag"]
pub type LUNF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `HUNF` reader - High Underflow Interrupt Flag"]
pub type HUNF_R = crate :: BitReader < bool > ; # [doc = "Field `HUNF` writer - High Underflow Interrupt Flag"]
pub type HUNF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `LCMP0` reader - Low Compare 2 Interrupt Flag"]
pub type LCMP0_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP0` writer - Low Compare 2 Interrupt Flag"]
pub type LCMP0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `LCMP1` reader - Low Compare 1 Interrupt Flag"]
pub type LCMP1_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP1` writer - Low Compare 1 Interrupt Flag"]
pub type LCMP1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `LCMP2` reader - Low Compare 0 Interrupt Flag"]
pub type LCMP2_R = crate :: BitReader < bool > ; # [doc = "Field `LCMP2` writer - Low Compare 0 Interrupt Flag"]
pub type LCMP2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Underflow Interrupt Flag"]
# [inline (always)]
pub fn lunf (& self) -> LUNF_R { LUNF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - High Underflow Interrupt Flag"]
# [inline (always)]
pub fn hunf (& self) -> HUNF_R { HUNF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Low Compare 2 Interrupt Flag"]
# [inline (always)]
pub fn lcmp0 (& self) -> LCMP0_R { LCMP0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Low Compare 1 Interrupt Flag"]
# [inline (always)]
pub fn lcmp1 (& self) -> LCMP1_R { LCMP1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Low Compare 0 Interrupt Flag"]
# [inline (always)]
pub fn lcmp2 (& self) -> LCMP2_R { LCMP2_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Underflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn lunf (& mut self) -> LUNF_W < 0 > { LUNF_W :: new (self) } # [doc = "Bit 1 - High Underflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn hunf (& mut self) -> HUNF_W < 1 > { HUNF_W :: new (self) } # [doc = "Bit 4 - Low Compare 2 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn lcmp0 (& mut self) -> LCMP0_W < 4 > { LCMP0_W :: new (self) } # [doc = "Bit 5 - Low Compare 1 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn lcmp1 (& mut self) -> LCMP1_W < 5 > { LCMP1_W :: new (self) } # [doc = "Bit 6 - Low Compare 0 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn lcmp2 (& mut self) -> LCMP2_W < 6 > { LCMP2_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LCMP0 (rw) register accessor: an alias for `Reg<LCMP0_SPEC>`"]
pub type LCMP0 = crate :: Reg < lcmp0 :: LCMP0_SPEC > ; # [doc = "Low Compare"]
pub mod lcmp0 { # [doc = "Register `LCMP0` reader"]
pub struct R (crate :: R < LCMP0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LCMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LCMP0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LCMP0_SPEC >) -> Self { R (reader) } } # [doc = "Register `LCMP0` writer"]
pub struct W (crate :: W < LCMP0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LCMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LCMP0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LCMP0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lcmp0](index.html) module"]
pub struct LCMP0_SPEC ; impl crate :: RegisterSpec for LCMP0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lcmp0::R](R) reader structure"]
impl crate :: Readable for LCMP0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lcmp0::W](W) writer structure"]
impl crate :: Writable for LCMP0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCMP0 to value 0"]
impl crate :: Resettable for LCMP0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LCMP1 (rw) register accessor: an alias for `Reg<LCMP1_SPEC>`"]
pub type LCMP1 = crate :: Reg < lcmp1 :: LCMP1_SPEC > ; # [doc = "Low Compare"]
pub mod lcmp1 { # [doc = "Register `LCMP1` reader"]
pub struct R (crate :: R < LCMP1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LCMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LCMP1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LCMP1_SPEC >) -> Self { R (reader) } } # [doc = "Register `LCMP1` writer"]
pub struct W (crate :: W < LCMP1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LCMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LCMP1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LCMP1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lcmp1](index.html) module"]
pub struct LCMP1_SPEC ; impl crate :: RegisterSpec for LCMP1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lcmp1::R](R) reader structure"]
impl crate :: Readable for LCMP1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lcmp1::W](W) writer structure"]
impl crate :: Writable for LCMP1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCMP1 to value 0"]
impl crate :: Resettable for LCMP1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LCMP2 (rw) register accessor: an alias for `Reg<LCMP2_SPEC>`"]
pub type LCMP2 = crate :: Reg < lcmp2 :: LCMP2_SPEC > ; # [doc = "Low Compare"]
pub mod lcmp2 { # [doc = "Register `LCMP2` reader"]
pub struct R (crate :: R < LCMP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LCMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LCMP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LCMP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `LCMP2` writer"]
pub struct W (crate :: W < LCMP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LCMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LCMP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LCMP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Compare\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lcmp2](index.html) module"]
pub struct LCMP2_SPEC ; impl crate :: RegisterSpec for LCMP2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lcmp2::R](R) reader structure"]
impl crate :: Readable for LCMP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lcmp2::W](W) writer structure"]
impl crate :: Writable for LCMP2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCMP2 to value 0"]
impl crate :: Resettable for LCMP2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LCNT (rw) register accessor: an alias for `Reg<LCNT_SPEC>`"]
pub type LCNT = crate :: Reg < lcnt :: LCNT_SPEC > ; # [doc = "Low Count"]
pub mod lcnt { # [doc = "Register `LCNT` reader"]
pub struct R (crate :: R < LCNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LCNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LCNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `LCNT` writer"]
pub struct W (crate :: W < LCNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LCNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LCNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LCNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lcnt](index.html) module"]
pub struct LCNT_SPEC ; impl crate :: RegisterSpec for LCNT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lcnt::R](R) reader structure"]
impl crate :: Readable for LCNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lcnt::W](W) writer structure"]
impl crate :: Writable for LCNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LCNT to value 0"]
impl crate :: Resettable for LCNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LPER (rw) register accessor: an alias for `Reg<LPER_SPEC>`"]
pub type LPER = crate :: Reg < lper :: LPER_SPEC > ; # [doc = "Low Period"]
pub mod lper { # [doc = "Register `LPER` reader"]
pub struct R (crate :: R < LPER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LPER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LPER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LPER_SPEC >) -> Self { R (reader) } } # [doc = "Register `LPER` writer"]
pub struct W (crate :: W < LPER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LPER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LPER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LPER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Low Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lper](index.html) module"]
pub struct LPER_SPEC ; impl crate :: RegisterSpec for LPER_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lper::R](R) reader structure"]
impl crate :: Readable for LPER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lper::W](W) writer structure"]
impl crate :: Writable for LPER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LPER to value 0"]
impl crate :: Resettable for LPER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } } # [doc = "16-bit Timer Type B"]
pub struct TCB0 { _marker : PhantomData < * const () > } unsafe impl Send for TCB0 { } impl TCB0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcb0 :: RegisterBlock = 0x0a80 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcb0 :: RegisterBlock { Self :: PTR } } impl Deref for TCB0 { type Target = tcb0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCB0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCB0") . finish () } } # [doc = "16-bit Timer Type B"]
pub mod tcb0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , _reserved2 : [u8 ; 0x02]
, # [doc = "0x04 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x05 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x06 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x07 - Status"]
pub status : STATUS , # [doc = "0x08 - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x09 - Temporary Value"]
pub temp : TEMP , # [doc = "0x0a - Count"]
pub cnt : CNT , # [doc = "0x0c - Compare or Capture"]
pub ccmp : CCMP , } # [doc = "CCMP (rw) register accessor: an alias for `Reg<CCMP_SPEC>`"]
pub type CCMP = crate :: Reg < ccmp :: CCMP_SPEC > ; # [doc = "Compare or Capture"]
pub mod ccmp { # [doc = "Register `CCMP` reader"]
pub struct R (crate :: R < CCMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCMP` writer"]
pub struct W (crate :: W < CCMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmp](index.html) module"]
pub struct CCMP_SPEC ; impl crate :: RegisterSpec for CCMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccmp::R](R) reader structure"]
impl crate :: Readable for CCMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccmp::W](W) writer structure"]
impl crate :: Writable for CCMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCMP to value 0"]
impl crate :: Resettable for CCMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: CLK_PER (No Prescaling)"]
CLKDIV1 = 0 , # [doc = "1: CLK_PER/2 (From Prescaler)"]
CLKDIV2 = 1 , # [doc = "2: Use Clock from TCA"]
CLKTCA = 2 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSEL_A > { match self . bits { 0 => Some (CLKSEL_A :: CLKDIV1) , 1 => Some (CLKSEL_A :: CLKDIV2) , 2 => Some (CLKSEL_A :: CLKTCA) , _ => None , } } # [doc = "Checks if the value of the field is `CLKDIV1`"]
# [inline (always)]
pub fn is_clkdiv1 (& self) -> bool { * self == CLKSEL_A :: CLKDIV1 } # [doc = "Checks if the value of the field is `CLKDIV2`"]
# [inline (always)]
pub fn is_clkdiv2 (& self) -> bool { * self == CLKSEL_A :: CLKDIV2 } # [doc = "Checks if the value of the field is `CLKTCA`"]
# [inline (always)]
pub fn is_clktca (& self) -> bool { * self == CLKSEL_A :: CLKTCA } } # [doc = "Field `CLKSEL` writer - Clock Select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "CLK_PER (No Prescaling)"]
# [inline (always)]
pub fn clkdiv1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV1) } # [doc = "CLK_PER/2 (From Prescaler)"]
# [inline (always)]
pub fn clkdiv2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV2) } # [doc = "Use Clock from TCA"]
# [inline (always)]
pub fn clktca (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKTCA) } } # [doc = "Field `SYNCUPD` reader - Synchronize Update"]
pub type SYNCUPD_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCUPD` writer - Synchronize Update"]
pub type SYNCUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
pub fn syncupd (& self) -> SYNCUPD_R { SYNCUPD_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
# [must_use]
pub fn syncupd (& mut self) -> SYNCUPD_W < 4 > { SYNCUPD_W :: new (self) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 6 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CNTMODE` reader - Timer Mode"]
pub type CNTMODE_R = crate :: FieldReader < u8 , CNTMODE_A > ; # [doc = "Timer Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CNTMODE_A { # [doc = "0: Periodic Interrupt"]
INT = 0 , # [doc = "1: Periodic Timeout"]
TIMEOUT = 1 , # [doc = "2: Input Capture Event"]
CAPT = 2 , # [doc = "3: Input Capture Frequency measurement"]
FRQ = 3 , # [doc = "4: Input Capture Pulse-Width measurement"]
PW = 4 , # [doc = "5: Input Capture Frequency and Pulse-Width measurement"]
FRQPW = 5 , # [doc = "6: Single Shot"]
SINGLE = 6 , # [doc = "7: 8-bit PWM"]
PWM8 = 7 , } impl From < CNTMODE_A > for u8 { # [inline (always)]
fn from (variant : CNTMODE_A) -> Self { variant as _ } } impl CNTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CNTMODE_A { match self . bits { 0 => CNTMODE_A :: INT , 1 => CNTMODE_A :: TIMEOUT , 2 => CNTMODE_A :: CAPT , 3 => CNTMODE_A :: FRQ , 4 => CNTMODE_A :: PW , 5 => CNTMODE_A :: FRQPW , 6 => CNTMODE_A :: SINGLE , 7 => CNTMODE_A :: PWM8 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == CNTMODE_A :: INT } # [doc = "Checks if the value of the field is `TIMEOUT`"]
# [inline (always)]
pub fn is_timeout (& self) -> bool { * self == CNTMODE_A :: TIMEOUT } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == CNTMODE_A :: CAPT } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == CNTMODE_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == CNTMODE_A :: PW } # [doc = "Checks if the value of the field is `FRQPW`"]
# [inline (always)]
pub fn is_frqpw (& self) -> bool { * self == CNTMODE_A :: FRQPW } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == CNTMODE_A :: SINGLE } # [doc = "Checks if the value of the field is `PWM8`"]
# [inline (always)]
pub fn is_pwm8 (& self) -> bool { * self == CNTMODE_A :: PWM8 } } # [doc = "Field `CNTMODE` writer - Timer Mode"]
pub type CNTMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , CNTMODE_A , 3 , O > ; impl < 'a , const O : u8 > CNTMODE_W < 'a , O > { # [doc = "Periodic Interrupt"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (CNTMODE_A :: INT) } # [doc = "Periodic Timeout"]
# [inline (always)]
pub fn timeout (self) -> & 'a mut W { self . variant (CNTMODE_A :: TIMEOUT) } # [doc = "Input Capture Event"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (CNTMODE_A :: CAPT) } # [doc = "Input Capture Frequency measurement"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQ) } # [doc = "Input Capture Pulse-Width measurement"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (CNTMODE_A :: PW) } # [doc = "Input Capture Frequency and Pulse-Width measurement"]
# [inline (always)]
pub fn frqpw (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQPW) } # [doc = "Single Shot"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (CNTMODE_A :: SINGLE) } # [doc = "8-bit PWM"]
# [inline (always)]
pub fn pwm8 (self) -> & 'a mut W { self . variant (CNTMODE_A :: PWM8) } } # [doc = "Field `CCMPEN` reader - Pin Output Enable"]
pub type CCMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPEN` writer - Pin Output Enable"]
pub type CCMPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCMPINIT` reader - Pin Initial State"]
pub type CCMPINIT_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPINIT` writer - Pin Initial State"]
pub type CCMPINIT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `ASYNC` reader - Asynchronous Enable"]
pub type ASYNC_R = crate :: BitReader < bool > ; # [doc = "Field `ASYNC` writer - Asynchronous Enable"]
pub type ASYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
pub fn cntmode (& self) -> CNTMODE_R { CNTMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
pub fn ccmpen (& self) -> CCMPEN_R { CCMPEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
pub fn ccmpinit (& self) -> CCMPINIT_R { CCMPINIT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
pub fn async_ (& self) -> ASYNC_R { ASYNC_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
# [must_use]
pub fn cntmode (& mut self) -> CNTMODE_W < 0 > { CNTMODE_W :: new (self) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
# [must_use]
pub fn ccmpen (& mut self) -> CCMPEN_W < 4 > { CCMPEN_W :: new (self) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
# [must_use]
pub fn ccmpinit (& mut self) -> CCMPINIT_W < 5 > { CCMPINIT_W :: new (self) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
# [must_use]
pub fn async_ (& mut self) -> ASYNC_W < 6 > { ASYNC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPTEI` reader - Event Input Enable"]
pub type CAPTEI_R = crate :: BitReader < bool > ; # [doc = "Field `CAPTEI` writer - Event Input Enable"]
pub type CAPTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `EDGE` reader - Event Edge"]
pub type EDGE_R = crate :: BitReader < bool > ; # [doc = "Field `EDGE` writer - Event Edge"]
pub type EDGE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `FILTER` reader - Input Capture Noise Cancellation Filter"]
pub type FILTER_R = crate :: BitReader < bool > ; # [doc = "Field `FILTER` writer - Input Capture Noise Cancellation Filter"]
pub type FILTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
pub fn captei (& self) -> CAPTEI_R { CAPTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
pub fn edge (& self) -> EDGE_R { EDGE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
pub fn filter (& self) -> FILTER_R { FILTER_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn captei (& mut self) -> CAPTEI_W < 0 > { CAPTEI_W :: new (self) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
# [must_use]
pub fn edge (& mut self) -> EDGE_W < 4 > { EDGE_W :: new (self) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
# [must_use]
pub fn filter (& mut self) -> FILTER_W < 6 > { FILTER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `RUN` reader - Run"]
pub type RUN_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Run"]
# [inline (always)]
pub fn run (& self) -> RUN_R { RUN_R :: new ((self . bits & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Value"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer Type B"]
pub struct TCB1 { _marker : PhantomData < * const () > } unsafe impl Send for TCB1 { } impl TCB1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcb1 :: RegisterBlock = 0x0a90 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcb1 :: RegisterBlock { Self :: PTR } } impl Deref for TCB1 { type Target = tcb1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCB1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCB1") . finish () } } # [doc = "16-bit Timer Type B"]
pub mod tcb1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , _reserved2 : [u8 ; 0x02]
, # [doc = "0x04 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x05 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x06 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x07 - Status"]
pub status : STATUS , # [doc = "0x08 - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x09 - Temporary Value"]
pub temp : TEMP , # [doc = "0x0a - Count"]
pub cnt : CNT , # [doc = "0x0c - Compare or Capture"]
pub ccmp : CCMP , } # [doc = "CCMP (rw) register accessor: an alias for `Reg<CCMP_SPEC>`"]
pub type CCMP = crate :: Reg < ccmp :: CCMP_SPEC > ; # [doc = "Compare or Capture"]
pub mod ccmp { # [doc = "Register `CCMP` reader"]
pub struct R (crate :: R < CCMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCMP` writer"]
pub struct W (crate :: W < CCMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmp](index.html) module"]
pub struct CCMP_SPEC ; impl crate :: RegisterSpec for CCMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccmp::R](R) reader structure"]
impl crate :: Readable for CCMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccmp::W](W) writer structure"]
impl crate :: Writable for CCMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCMP to value 0"]
impl crate :: Resettable for CCMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: CLK_PER (No Prescaling)"]
CLKDIV1 = 0 , # [doc = "1: CLK_PER/2 (From Prescaler)"]
CLKDIV2 = 1 , # [doc = "2: Use Clock from TCA"]
CLKTCA = 2 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSEL_A > { match self . bits { 0 => Some (CLKSEL_A :: CLKDIV1) , 1 => Some (CLKSEL_A :: CLKDIV2) , 2 => Some (CLKSEL_A :: CLKTCA) , _ => None , } } # [doc = "Checks if the value of the field is `CLKDIV1`"]
# [inline (always)]
pub fn is_clkdiv1 (& self) -> bool { * self == CLKSEL_A :: CLKDIV1 } # [doc = "Checks if the value of the field is `CLKDIV2`"]
# [inline (always)]
pub fn is_clkdiv2 (& self) -> bool { * self == CLKSEL_A :: CLKDIV2 } # [doc = "Checks if the value of the field is `CLKTCA`"]
# [inline (always)]
pub fn is_clktca (& self) -> bool { * self == CLKSEL_A :: CLKTCA } } # [doc = "Field `CLKSEL` writer - Clock Select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "CLK_PER (No Prescaling)"]
# [inline (always)]
pub fn clkdiv1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV1) } # [doc = "CLK_PER/2 (From Prescaler)"]
# [inline (always)]
pub fn clkdiv2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV2) } # [doc = "Use Clock from TCA"]
# [inline (always)]
pub fn clktca (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKTCA) } } # [doc = "Field `SYNCUPD` reader - Synchronize Update"]
pub type SYNCUPD_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCUPD` writer - Synchronize Update"]
pub type SYNCUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
pub fn syncupd (& self) -> SYNCUPD_R { SYNCUPD_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
# [must_use]
pub fn syncupd (& mut self) -> SYNCUPD_W < 4 > { SYNCUPD_W :: new (self) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 6 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CNTMODE` reader - Timer Mode"]
pub type CNTMODE_R = crate :: FieldReader < u8 , CNTMODE_A > ; # [doc = "Timer Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CNTMODE_A { # [doc = "0: Periodic Interrupt"]
INT = 0 , # [doc = "1: Periodic Timeout"]
TIMEOUT = 1 , # [doc = "2: Input Capture Event"]
CAPT = 2 , # [doc = "3: Input Capture Frequency measurement"]
FRQ = 3 , # [doc = "4: Input Capture Pulse-Width measurement"]
PW = 4 , # [doc = "5: Input Capture Frequency and Pulse-Width measurement"]
FRQPW = 5 , # [doc = "6: Single Shot"]
SINGLE = 6 , # [doc = "7: 8-bit PWM"]
PWM8 = 7 , } impl From < CNTMODE_A > for u8 { # [inline (always)]
fn from (variant : CNTMODE_A) -> Self { variant as _ } } impl CNTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CNTMODE_A { match self . bits { 0 => CNTMODE_A :: INT , 1 => CNTMODE_A :: TIMEOUT , 2 => CNTMODE_A :: CAPT , 3 => CNTMODE_A :: FRQ , 4 => CNTMODE_A :: PW , 5 => CNTMODE_A :: FRQPW , 6 => CNTMODE_A :: SINGLE , 7 => CNTMODE_A :: PWM8 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == CNTMODE_A :: INT } # [doc = "Checks if the value of the field is `TIMEOUT`"]
# [inline (always)]
pub fn is_timeout (& self) -> bool { * self == CNTMODE_A :: TIMEOUT } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == CNTMODE_A :: CAPT } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == CNTMODE_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == CNTMODE_A :: PW } # [doc = "Checks if the value of the field is `FRQPW`"]
# [inline (always)]
pub fn is_frqpw (& self) -> bool { * self == CNTMODE_A :: FRQPW } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == CNTMODE_A :: SINGLE } # [doc = "Checks if the value of the field is `PWM8`"]
# [inline (always)]
pub fn is_pwm8 (& self) -> bool { * self == CNTMODE_A :: PWM8 } } # [doc = "Field `CNTMODE` writer - Timer Mode"]
pub type CNTMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , CNTMODE_A , 3 , O > ; impl < 'a , const O : u8 > CNTMODE_W < 'a , O > { # [doc = "Periodic Interrupt"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (CNTMODE_A :: INT) } # [doc = "Periodic Timeout"]
# [inline (always)]
pub fn timeout (self) -> & 'a mut W { self . variant (CNTMODE_A :: TIMEOUT) } # [doc = "Input Capture Event"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (CNTMODE_A :: CAPT) } # [doc = "Input Capture Frequency measurement"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQ) } # [doc = "Input Capture Pulse-Width measurement"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (CNTMODE_A :: PW) } # [doc = "Input Capture Frequency and Pulse-Width measurement"]
# [inline (always)]
pub fn frqpw (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQPW) } # [doc = "Single Shot"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (CNTMODE_A :: SINGLE) } # [doc = "8-bit PWM"]
# [inline (always)]
pub fn pwm8 (self) -> & 'a mut W { self . variant (CNTMODE_A :: PWM8) } } # [doc = "Field `CCMPEN` reader - Pin Output Enable"]
pub type CCMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPEN` writer - Pin Output Enable"]
pub type CCMPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCMPINIT` reader - Pin Initial State"]
pub type CCMPINIT_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPINIT` writer - Pin Initial State"]
pub type CCMPINIT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `ASYNC` reader - Asynchronous Enable"]
pub type ASYNC_R = crate :: BitReader < bool > ; # [doc = "Field `ASYNC` writer - Asynchronous Enable"]
pub type ASYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
pub fn cntmode (& self) -> CNTMODE_R { CNTMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
pub fn ccmpen (& self) -> CCMPEN_R { CCMPEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
pub fn ccmpinit (& self) -> CCMPINIT_R { CCMPINIT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
pub fn async_ (& self) -> ASYNC_R { ASYNC_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
# [must_use]
pub fn cntmode (& mut self) -> CNTMODE_W < 0 > { CNTMODE_W :: new (self) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
# [must_use]
pub fn ccmpen (& mut self) -> CCMPEN_W < 4 > { CCMPEN_W :: new (self) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
# [must_use]
pub fn ccmpinit (& mut self) -> CCMPINIT_W < 5 > { CCMPINIT_W :: new (self) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
# [must_use]
pub fn async_ (& mut self) -> ASYNC_W < 6 > { ASYNC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPTEI` reader - Event Input Enable"]
pub type CAPTEI_R = crate :: BitReader < bool > ; # [doc = "Field `CAPTEI` writer - Event Input Enable"]
pub type CAPTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `EDGE` reader - Event Edge"]
pub type EDGE_R = crate :: BitReader < bool > ; # [doc = "Field `EDGE` writer - Event Edge"]
pub type EDGE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `FILTER` reader - Input Capture Noise Cancellation Filter"]
pub type FILTER_R = crate :: BitReader < bool > ; # [doc = "Field `FILTER` writer - Input Capture Noise Cancellation Filter"]
pub type FILTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
pub fn captei (& self) -> CAPTEI_R { CAPTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
pub fn edge (& self) -> EDGE_R { EDGE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
pub fn filter (& self) -> FILTER_R { FILTER_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn captei (& mut self) -> CAPTEI_W < 0 > { CAPTEI_W :: new (self) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
# [must_use]
pub fn edge (& mut self) -> EDGE_W < 4 > { EDGE_W :: new (self) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
# [must_use]
pub fn filter (& mut self) -> FILTER_W < 6 > { FILTER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `RUN` reader - Run"]
pub type RUN_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Run"]
# [inline (always)]
pub fn run (& self) -> RUN_R { RUN_R :: new ((self . bits & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Value"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer Type B"]
pub struct TCB2 { _marker : PhantomData < * const () > } unsafe impl Send for TCB2 { } impl TCB2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcb2 :: RegisterBlock = 0x0aa0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcb2 :: RegisterBlock { Self :: PTR } } impl Deref for TCB2 { type Target = tcb2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCB2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCB2") . finish () } } # [doc = "16-bit Timer Type B"]
pub mod tcb2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , _reserved2 : [u8 ; 0x02]
, # [doc = "0x04 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x05 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x06 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x07 - Status"]
pub status : STATUS , # [doc = "0x08 - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x09 - Temporary Value"]
pub temp : TEMP , # [doc = "0x0a - Count"]
pub cnt : CNT , # [doc = "0x0c - Compare or Capture"]
pub ccmp : CCMP , } # [doc = "CCMP (rw) register accessor: an alias for `Reg<CCMP_SPEC>`"]
pub type CCMP = crate :: Reg < ccmp :: CCMP_SPEC > ; # [doc = "Compare or Capture"]
pub mod ccmp { # [doc = "Register `CCMP` reader"]
pub struct R (crate :: R < CCMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCMP` writer"]
pub struct W (crate :: W < CCMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmp](index.html) module"]
pub struct CCMP_SPEC ; impl crate :: RegisterSpec for CCMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccmp::R](R) reader structure"]
impl crate :: Readable for CCMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccmp::W](W) writer structure"]
impl crate :: Writable for CCMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCMP to value 0"]
impl crate :: Resettable for CCMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: CLK_PER (No Prescaling)"]
CLKDIV1 = 0 , # [doc = "1: CLK_PER/2 (From Prescaler)"]
CLKDIV2 = 1 , # [doc = "2: Use Clock from TCA"]
CLKTCA = 2 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSEL_A > { match self . bits { 0 => Some (CLKSEL_A :: CLKDIV1) , 1 => Some (CLKSEL_A :: CLKDIV2) , 2 => Some (CLKSEL_A :: CLKTCA) , _ => None , } } # [doc = "Checks if the value of the field is `CLKDIV1`"]
# [inline (always)]
pub fn is_clkdiv1 (& self) -> bool { * self == CLKSEL_A :: CLKDIV1 } # [doc = "Checks if the value of the field is `CLKDIV2`"]
# [inline (always)]
pub fn is_clkdiv2 (& self) -> bool { * self == CLKSEL_A :: CLKDIV2 } # [doc = "Checks if the value of the field is `CLKTCA`"]
# [inline (always)]
pub fn is_clktca (& self) -> bool { * self == CLKSEL_A :: CLKTCA } } # [doc = "Field `CLKSEL` writer - Clock Select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "CLK_PER (No Prescaling)"]
# [inline (always)]
pub fn clkdiv1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV1) } # [doc = "CLK_PER/2 (From Prescaler)"]
# [inline (always)]
pub fn clkdiv2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV2) } # [doc = "Use Clock from TCA"]
# [inline (always)]
pub fn clktca (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKTCA) } } # [doc = "Field `SYNCUPD` reader - Synchronize Update"]
pub type SYNCUPD_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCUPD` writer - Synchronize Update"]
pub type SYNCUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
pub fn syncupd (& self) -> SYNCUPD_R { SYNCUPD_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
# [must_use]
pub fn syncupd (& mut self) -> SYNCUPD_W < 4 > { SYNCUPD_W :: new (self) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 6 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CNTMODE` reader - Timer Mode"]
pub type CNTMODE_R = crate :: FieldReader < u8 , CNTMODE_A > ; # [doc = "Timer Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CNTMODE_A { # [doc = "0: Periodic Interrupt"]
INT = 0 , # [doc = "1: Periodic Timeout"]
TIMEOUT = 1 , # [doc = "2: Input Capture Event"]
CAPT = 2 , # [doc = "3: Input Capture Frequency measurement"]
FRQ = 3 , # [doc = "4: Input Capture Pulse-Width measurement"]
PW = 4 , # [doc = "5: Input Capture Frequency and Pulse-Width measurement"]
FRQPW = 5 , # [doc = "6: Single Shot"]
SINGLE = 6 , # [doc = "7: 8-bit PWM"]
PWM8 = 7 , } impl From < CNTMODE_A > for u8 { # [inline (always)]
fn from (variant : CNTMODE_A) -> Self { variant as _ } } impl CNTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CNTMODE_A { match self . bits { 0 => CNTMODE_A :: INT , 1 => CNTMODE_A :: TIMEOUT , 2 => CNTMODE_A :: CAPT , 3 => CNTMODE_A :: FRQ , 4 => CNTMODE_A :: PW , 5 => CNTMODE_A :: FRQPW , 6 => CNTMODE_A :: SINGLE , 7 => CNTMODE_A :: PWM8 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == CNTMODE_A :: INT } # [doc = "Checks if the value of the field is `TIMEOUT`"]
# [inline (always)]
pub fn is_timeout (& self) -> bool { * self == CNTMODE_A :: TIMEOUT } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == CNTMODE_A :: CAPT } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == CNTMODE_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == CNTMODE_A :: PW } # [doc = "Checks if the value of the field is `FRQPW`"]
# [inline (always)]
pub fn is_frqpw (& self) -> bool { * self == CNTMODE_A :: FRQPW } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == CNTMODE_A :: SINGLE } # [doc = "Checks if the value of the field is `PWM8`"]
# [inline (always)]
pub fn is_pwm8 (& self) -> bool { * self == CNTMODE_A :: PWM8 } } # [doc = "Field `CNTMODE` writer - Timer Mode"]
pub type CNTMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , CNTMODE_A , 3 , O > ; impl < 'a , const O : u8 > CNTMODE_W < 'a , O > { # [doc = "Periodic Interrupt"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (CNTMODE_A :: INT) } # [doc = "Periodic Timeout"]
# [inline (always)]
pub fn timeout (self) -> & 'a mut W { self . variant (CNTMODE_A :: TIMEOUT) } # [doc = "Input Capture Event"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (CNTMODE_A :: CAPT) } # [doc = "Input Capture Frequency measurement"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQ) } # [doc = "Input Capture Pulse-Width measurement"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (CNTMODE_A :: PW) } # [doc = "Input Capture Frequency and Pulse-Width measurement"]
# [inline (always)]
pub fn frqpw (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQPW) } # [doc = "Single Shot"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (CNTMODE_A :: SINGLE) } # [doc = "8-bit PWM"]
# [inline (always)]
pub fn pwm8 (self) -> & 'a mut W { self . variant (CNTMODE_A :: PWM8) } } # [doc = "Field `CCMPEN` reader - Pin Output Enable"]
pub type CCMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPEN` writer - Pin Output Enable"]
pub type CCMPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCMPINIT` reader - Pin Initial State"]
pub type CCMPINIT_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPINIT` writer - Pin Initial State"]
pub type CCMPINIT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `ASYNC` reader - Asynchronous Enable"]
pub type ASYNC_R = crate :: BitReader < bool > ; # [doc = "Field `ASYNC` writer - Asynchronous Enable"]
pub type ASYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
pub fn cntmode (& self) -> CNTMODE_R { CNTMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
pub fn ccmpen (& self) -> CCMPEN_R { CCMPEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
pub fn ccmpinit (& self) -> CCMPINIT_R { CCMPINIT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
pub fn async_ (& self) -> ASYNC_R { ASYNC_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
# [must_use]
pub fn cntmode (& mut self) -> CNTMODE_W < 0 > { CNTMODE_W :: new (self) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
# [must_use]
pub fn ccmpen (& mut self) -> CCMPEN_W < 4 > { CCMPEN_W :: new (self) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
# [must_use]
pub fn ccmpinit (& mut self) -> CCMPINIT_W < 5 > { CCMPINIT_W :: new (self) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
# [must_use]
pub fn async_ (& mut self) -> ASYNC_W < 6 > { ASYNC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPTEI` reader - Event Input Enable"]
pub type CAPTEI_R = crate :: BitReader < bool > ; # [doc = "Field `CAPTEI` writer - Event Input Enable"]
pub type CAPTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `EDGE` reader - Event Edge"]
pub type EDGE_R = crate :: BitReader < bool > ; # [doc = "Field `EDGE` writer - Event Edge"]
pub type EDGE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `FILTER` reader - Input Capture Noise Cancellation Filter"]
pub type FILTER_R = crate :: BitReader < bool > ; # [doc = "Field `FILTER` writer - Input Capture Noise Cancellation Filter"]
pub type FILTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
pub fn captei (& self) -> CAPTEI_R { CAPTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
pub fn edge (& self) -> EDGE_R { EDGE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
pub fn filter (& self) -> FILTER_R { FILTER_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn captei (& mut self) -> CAPTEI_W < 0 > { CAPTEI_W :: new (self) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
# [must_use]
pub fn edge (& mut self) -> EDGE_W < 4 > { EDGE_W :: new (self) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
# [must_use]
pub fn filter (& mut self) -> FILTER_W < 6 > { FILTER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `RUN` reader - Run"]
pub type RUN_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Run"]
# [inline (always)]
pub fn run (& self) -> RUN_R { RUN_R :: new ((self . bits & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Value"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer Type B"]
pub struct TCB3 { _marker : PhantomData < * const () > } unsafe impl Send for TCB3 { } impl TCB3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcb3 :: RegisterBlock = 0x0ab0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcb3 :: RegisterBlock { Self :: PTR } } impl Deref for TCB3 { type Target = tcb3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCB3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCB3") . finish () } } # [doc = "16-bit Timer Type B"]
pub mod tcb3 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , _reserved2 : [u8 ; 0x02]
, # [doc = "0x04 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x05 - Interrupt Control"]
pub intctrl : INTCTRL , # [doc = "0x06 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x07 - Status"]
pub status : STATUS , # [doc = "0x08 - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x09 - Temporary Value"]
pub temp : TEMP , # [doc = "0x0a - Count"]
pub cnt : CNT , # [doc = "0x0c - Compare or Capture"]
pub ccmp : CCMP , } # [doc = "CCMP (rw) register accessor: an alias for `Reg<CCMP_SPEC>`"]
pub type CCMP = crate :: Reg < ccmp :: CCMP_SPEC > ; # [doc = "Compare or Capture"]
pub mod ccmp { # [doc = "Register `CCMP` reader"]
pub struct R (crate :: R < CCMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCMP` writer"]
pub struct W (crate :: W < CCMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccmp](index.html) module"]
pub struct CCMP_SPEC ; impl crate :: RegisterSpec for CCMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccmp::R](R) reader structure"]
impl crate :: Readable for CCMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccmp::W](W) writer structure"]
impl crate :: Writable for CCMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCMP to value 0"]
impl crate :: Resettable for CCMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CLKSEL` reader - Clock Select"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: CLK_PER (No Prescaling)"]
CLKDIV1 = 0 , # [doc = "1: CLK_PER/2 (From Prescaler)"]
CLKDIV2 = 1 , # [doc = "2: Use Clock from TCA"]
CLKTCA = 2 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKSEL_A > { match self . bits { 0 => Some (CLKSEL_A :: CLKDIV1) , 1 => Some (CLKSEL_A :: CLKDIV2) , 2 => Some (CLKSEL_A :: CLKTCA) , _ => None , } } # [doc = "Checks if the value of the field is `CLKDIV1`"]
# [inline (always)]
pub fn is_clkdiv1 (& self) -> bool { * self == CLKSEL_A :: CLKDIV1 } # [doc = "Checks if the value of the field is `CLKDIV2`"]
# [inline (always)]
pub fn is_clkdiv2 (& self) -> bool { * self == CLKSEL_A :: CLKDIV2 } # [doc = "Checks if the value of the field is `CLKTCA`"]
# [inline (always)]
pub fn is_clktca (& self) -> bool { * self == CLKSEL_A :: CLKTCA } } # [doc = "Field `CLKSEL` writer - Clock Select"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 2 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "CLK_PER (No Prescaling)"]
# [inline (always)]
pub fn clkdiv1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV1) } # [doc = "CLK_PER/2 (From Prescaler)"]
# [inline (always)]
pub fn clkdiv2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKDIV2) } # [doc = "Use Clock from TCA"]
# [inline (always)]
pub fn clktca (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLKTCA) } } # [doc = "Field `SYNCUPD` reader - Synchronize Update"]
pub type SYNCUPD_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCUPD` writer - Synchronize Update"]
pub type SYNCUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RUNSTDBY` reader - Run Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run Standby"]
pub type RUNSTDBY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
pub fn syncupd (& self) -> SYNCUPD_R { SYNCUPD_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 1 > { CLKSEL_W :: new (self) } # [doc = "Bit 4 - Synchronize Update"]
# [inline (always)]
# [must_use]
pub fn syncupd (& mut self) -> SYNCUPD_W < 4 > { SYNCUPD_W :: new (self) } # [doc = "Bit 6 - Run Standby"]
# [inline (always)]
# [must_use]
pub fn runstdby (& mut self) -> RUNSTDBY_W < 6 > { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CNTMODE` reader - Timer Mode"]
pub type CNTMODE_R = crate :: FieldReader < u8 , CNTMODE_A > ; # [doc = "Timer Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CNTMODE_A { # [doc = "0: Periodic Interrupt"]
INT = 0 , # [doc = "1: Periodic Timeout"]
TIMEOUT = 1 , # [doc = "2: Input Capture Event"]
CAPT = 2 , # [doc = "3: Input Capture Frequency measurement"]
FRQ = 3 , # [doc = "4: Input Capture Pulse-Width measurement"]
PW = 4 , # [doc = "5: Input Capture Frequency and Pulse-Width measurement"]
FRQPW = 5 , # [doc = "6: Single Shot"]
SINGLE = 6 , # [doc = "7: 8-bit PWM"]
PWM8 = 7 , } impl From < CNTMODE_A > for u8 { # [inline (always)]
fn from (variant : CNTMODE_A) -> Self { variant as _ } } impl CNTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CNTMODE_A { match self . bits { 0 => CNTMODE_A :: INT , 1 => CNTMODE_A :: TIMEOUT , 2 => CNTMODE_A :: CAPT , 3 => CNTMODE_A :: FRQ , 4 => CNTMODE_A :: PW , 5 => CNTMODE_A :: FRQPW , 6 => CNTMODE_A :: SINGLE , 7 => CNTMODE_A :: PWM8 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == CNTMODE_A :: INT } # [doc = "Checks if the value of the field is `TIMEOUT`"]
# [inline (always)]
pub fn is_timeout (& self) -> bool { * self == CNTMODE_A :: TIMEOUT } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == CNTMODE_A :: CAPT } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == CNTMODE_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == CNTMODE_A :: PW } # [doc = "Checks if the value of the field is `FRQPW`"]
# [inline (always)]
pub fn is_frqpw (& self) -> bool { * self == CNTMODE_A :: FRQPW } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == CNTMODE_A :: SINGLE } # [doc = "Checks if the value of the field is `PWM8`"]
# [inline (always)]
pub fn is_pwm8 (& self) -> bool { * self == CNTMODE_A :: PWM8 } } # [doc = "Field `CNTMODE` writer - Timer Mode"]
pub type CNTMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , CNTMODE_A , 3 , O > ; impl < 'a , const O : u8 > CNTMODE_W < 'a , O > { # [doc = "Periodic Interrupt"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (CNTMODE_A :: INT) } # [doc = "Periodic Timeout"]
# [inline (always)]
pub fn timeout (self) -> & 'a mut W { self . variant (CNTMODE_A :: TIMEOUT) } # [doc = "Input Capture Event"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (CNTMODE_A :: CAPT) } # [doc = "Input Capture Frequency measurement"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQ) } # [doc = "Input Capture Pulse-Width measurement"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (CNTMODE_A :: PW) } # [doc = "Input Capture Frequency and Pulse-Width measurement"]
# [inline (always)]
pub fn frqpw (self) -> & 'a mut W { self . variant (CNTMODE_A :: FRQPW) } # [doc = "Single Shot"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (CNTMODE_A :: SINGLE) } # [doc = "8-bit PWM"]
# [inline (always)]
pub fn pwm8 (self) -> & 'a mut W { self . variant (CNTMODE_A :: PWM8) } } # [doc = "Field `CCMPEN` reader - Pin Output Enable"]
pub type CCMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPEN` writer - Pin Output Enable"]
pub type CCMPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCMPINIT` reader - Pin Initial State"]
pub type CCMPINIT_R = crate :: BitReader < bool > ; # [doc = "Field `CCMPINIT` writer - Pin Initial State"]
pub type CCMPINIT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `ASYNC` reader - Asynchronous Enable"]
pub type ASYNC_R = crate :: BitReader < bool > ; # [doc = "Field `ASYNC` writer - Asynchronous Enable"]
pub type ASYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
pub fn cntmode (& self) -> CNTMODE_R { CNTMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
pub fn ccmpen (& self) -> CCMPEN_R { CCMPEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
pub fn ccmpinit (& self) -> CCMPINIT_R { CCMPINIT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
pub fn async_ (& self) -> ASYNC_R { ASYNC_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Timer Mode"]
# [inline (always)]
# [must_use]
pub fn cntmode (& mut self) -> CNTMODE_W < 0 > { CNTMODE_W :: new (self) } # [doc = "Bit 4 - Pin Output Enable"]
# [inline (always)]
# [must_use]
pub fn ccmpen (& mut self) -> CCMPEN_W < 4 > { CCMPEN_W :: new (self) } # [doc = "Bit 5 - Pin Initial State"]
# [inline (always)]
# [must_use]
pub fn ccmpinit (& mut self) -> CCMPINIT_W < 5 > { CCMPINIT_W :: new (self) } # [doc = "Bit 6 - Asynchronous Enable"]
# [inline (always)]
# [must_use]
pub fn async_ (& mut self) -> ASYNC_W < 6 > { ASYNC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPTEI` reader - Event Input Enable"]
pub type CAPTEI_R = crate :: BitReader < bool > ; # [doc = "Field `CAPTEI` writer - Event Input Enable"]
pub type CAPTEI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `EDGE` reader - Event Edge"]
pub type EDGE_R = crate :: BitReader < bool > ; # [doc = "Field `EDGE` writer - Event Edge"]
pub type EDGE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; # [doc = "Field `FILTER` reader - Input Capture Noise Cancellation Filter"]
pub type FILTER_R = crate :: BitReader < bool > ; # [doc = "Field `FILTER` writer - Input Capture Noise Cancellation Filter"]
pub type FILTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
pub fn captei (& self) -> CAPTEI_R { CAPTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
pub fn edge (& self) -> EDGE_R { EDGE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
pub fn filter (& self) -> FILTER_R { FILTER_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn captei (& mut self) -> CAPTEI_W < 0 > { CAPTEI_W :: new (self) } # [doc = "Bit 4 - Event Edge"]
# [inline (always)]
# [must_use]
pub fn edge (& mut self) -> EDGE_W < 4 > { EDGE_W :: new (self) } # [doc = "Bit 6 - Input Capture Noise Cancellation Filter"]
# [inline (always)]
# [must_use]
pub fn filter (& mut self) -> FILTER_W < 6 > { FILTER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CAPT` reader - Capture or Timeout"]
pub type CAPT_R = crate :: BitReader < bool > ; # [doc = "Field `CAPT` writer - Capture or Timeout"]
pub type CAPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
pub fn capt (& self) -> CAPT_R { CAPT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Capture or Timeout"]
# [inline (always)]
# [must_use]
pub fn capt (& mut self) -> CAPT_W < 0 > { CAPT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (r) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `RUN` reader - Run"]
pub type RUN_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Run"]
# [inline (always)]
pub fn run (& self) -> RUN_R { RUN_R :: new ((self . bits & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Value"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Two-Wire Interface"]
pub struct TWI0 { _marker : PhantomData < * const () > } unsafe impl Send for TWI0 { } impl TWI0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const twi0 :: RegisterBlock = 0x08a0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const twi0 :: RegisterBlock { Self :: PTR } } impl Deref for TWI0 { type Target = twi0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TWI0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TWI0") . finish () } } # [doc = "Two-Wire Interface"]
pub mod twi0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Dual Control"]
pub dualctrl : DUALCTRL , # [doc = "0x02 - Debug Control Register"]
pub dbgctrl : DBGCTRL , # [doc = "0x03 - Master Control A"]
pub mctrla : MCTRLA , # [doc = "0x04 - Master Control B"]
pub mctrlb : MCTRLB , # [doc = "0x05 - Master Status"]
pub mstatus : MSTATUS , # [doc = "0x06 - Master Baurd Rate Control"]
pub mbaud : MBAUD , # [doc = "0x07 - Master Address"]
pub maddr : MADDR , # [doc = "0x08 - Master Data"]
pub mdata : MDATA , # [doc = "0x09 - Slave Control A"]
pub sctrla : SCTRLA , # [doc = "0x0a - Slave Control B"]
pub sctrlb : SCTRLB , # [doc = "0x0b - Slave Status"]
pub sstatus : SSTATUS , # [doc = "0x0c - Slave Address"]
pub saddr : SADDR , # [doc = "0x0d - Slave Data"]
pub sdata : SDATA , # [doc = "0x0e - Slave Address Mask"]
pub saddrmask : SADDRMASK , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DEFAULT_FMPEN` reader - FM Plus Enable"]
pub type DEFAULT_FMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `DEFAULT_FMPEN` writer - FM Plus Enable"]
pub type DEFAULT_FMPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DEFAULT_SDAHOLD` reader - SDA Hold Time"]
pub type DEFAULT_SDAHOLD_R = crate :: FieldReader < u8 , DEFAULT_SDAHOLD_A > ; # [doc = "SDA Hold Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DEFAULT_SDAHOLD_A { # [doc = "0: SDA hold time off"]
OFF = 0 , # [doc = "1: Typical 50ns hold time"]
_50NS = 1 , # [doc = "2: Typical 300ns hold time"]
_300NS = 2 , # [doc = "3: Typical 500ns hold time"]
_500NS = 3 , } impl From < DEFAULT_SDAHOLD_A > for u8 { # [inline (always)]
fn from (variant : DEFAULT_SDAHOLD_A) -> Self { variant as _ } } impl DEFAULT_SDAHOLD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DEFAULT_SDAHOLD_A { match self . bits { 0 => DEFAULT_SDAHOLD_A :: OFF , 1 => DEFAULT_SDAHOLD_A :: _50NS , 2 => DEFAULT_SDAHOLD_A :: _300NS , 3 => DEFAULT_SDAHOLD_A :: _500NS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DEFAULT_SDAHOLD_A :: OFF } # [doc = "Checks if the value of the field is `_50NS`"]
# [inline (always)]
pub fn is_50ns (& self) -> bool { * self == DEFAULT_SDAHOLD_A :: _50NS } # [doc = "Checks if the value of the field is `_300NS`"]
# [inline (always)]
pub fn is_300ns (& self) -> bool { * self == DEFAULT_SDAHOLD_A :: _300NS } # [doc = "Checks if the value of the field is `_500NS`"]
# [inline (always)]
pub fn is_500ns (& self) -> bool { * self == DEFAULT_SDAHOLD_A :: _500NS } } # [doc = "Field `DEFAULT_SDAHOLD` writer - SDA Hold Time"]
pub type DEFAULT_SDAHOLD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DEFAULT_SDAHOLD_A , 2 , O > ; impl < 'a , const O : u8 > DEFAULT_SDAHOLD_W < 'a , O > { # [doc = "SDA hold time off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DEFAULT_SDAHOLD_A :: OFF) } # [doc = "Typical 50ns hold time"]
# [inline (always)]
pub fn _50ns (self) -> & 'a mut W { self . variant (DEFAULT_SDAHOLD_A :: _50NS) } # [doc = "Typical 300ns hold time"]
# [inline (always)]
pub fn _300ns (self) -> & 'a mut W { self . variant (DEFAULT_SDAHOLD_A :: _300NS) } # [doc = "Typical 500ns hold time"]
# [inline (always)]
pub fn _500ns (self) -> & 'a mut W { self . variant (DEFAULT_SDAHOLD_A :: _500NS) } } # [doc = "Field `DEFAULT_SDASETUP` reader - SDA Setup Time"]
pub type DEFAULT_SDASETUP_R = crate :: BitReader < DEFAULT_SDASETUP_A > ; # [doc = "SDA Setup Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DEFAULT_SDASETUP_A { # [doc = "0: SDA setup time is 4 clock cycles"]
_4CYC = 0 , # [doc = "1: SDA setup time is 8 clock cycles"]
_8CYC = 1 , } impl From < DEFAULT_SDASETUP_A > for bool { # [inline (always)]
fn from (variant : DEFAULT_SDASETUP_A) -> Self { variant as u8 != 0 } } impl DEFAULT_SDASETUP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DEFAULT_SDASETUP_A { match self . bits { false => DEFAULT_SDASETUP_A :: _4CYC , true => DEFAULT_SDASETUP_A :: _8CYC , } } # [doc = "Checks if the value of the field is `_4CYC`"]
# [inline (always)]
pub fn is_4cyc (& self) -> bool { * self == DEFAULT_SDASETUP_A :: _4CYC } # [doc = "Checks if the value of the field is `_8CYC`"]
# [inline (always)]
pub fn is_8cyc (& self) -> bool { * self == DEFAULT_SDASETUP_A :: _8CYC } } # [doc = "Field `DEFAULT_SDASETUP` writer - SDA Setup Time"]
pub type DEFAULT_SDASETUP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , DEFAULT_SDASETUP_A , O > ; impl < 'a , const O : u8 > DEFAULT_SDASETUP_W < 'a , O > { # [doc = "SDA setup time is 4 clock cycles"]
# [inline (always)]
pub fn _4cyc (self) -> & 'a mut W { self . variant (DEFAULT_SDASETUP_A :: _4CYC) } # [doc = "SDA setup time is 8 clock cycles"]
# [inline (always)]
pub fn _8cyc (self) -> & 'a mut W { self . variant (DEFAULT_SDASETUP_A :: _8CYC) } } impl R { # [doc = "Bit 1 - FM Plus Enable"]
# [inline (always)]
pub fn default_fmpen (& self) -> DEFAULT_FMPEN_R { DEFAULT_FMPEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - SDA Hold Time"]
# [inline (always)]
pub fn default_sdahold (& self) -> DEFAULT_SDAHOLD_R { DEFAULT_SDAHOLD_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - SDA Setup Time"]
# [inline (always)]
pub fn default_sdasetup (& self) -> DEFAULT_SDASETUP_R { DEFAULT_SDASETUP_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 1 - FM Plus Enable"]
# [inline (always)]
# [must_use]
pub fn default_fmpen (& mut self) -> DEFAULT_FMPEN_W < 1 > { DEFAULT_FMPEN_W :: new (self) } # [doc = "Bits 2:3 - SDA Hold Time"]
# [inline (always)]
# [must_use]
pub fn default_sdahold (& mut self) -> DEFAULT_SDAHOLD_W < 2 > { DEFAULT_SDAHOLD_W :: new (self) } # [doc = "Bit 4 - SDA Setup Time"]
# [inline (always)]
# [must_use]
pub fn default_sdasetup (& mut self) -> DEFAULT_SDASETUP_W < 4 > { DEFAULT_SDASETUP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control Register"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DEFAULT_DBGRUN` reader - Debug Run"]
pub type DEFAULT_DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DEFAULT_DBGRUN` writer - Debug Run"]
pub type DEFAULT_DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn default_dbgrun (& self) -> DEFAULT_DBGRUN_R { DEFAULT_DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn default_dbgrun (& mut self) -> DEFAULT_DBGRUN_W < 0 > { DEFAULT_DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DUALCTRL (rw) register accessor: an alias for `Reg<DUALCTRL_SPEC>`"]
pub type DUALCTRL = crate :: Reg < dualctrl :: DUALCTRL_SPEC > ; # [doc = "Dual Control"]
pub mod dualctrl { # [doc = "Register `DUALCTRL` reader"]
pub struct R (crate :: R < DUALCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DUALCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DUALCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DUALCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DUALCTRL` writer"]
pub struct W (crate :: W < DUALCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DUALCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DUALCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DUALCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DEFAULT_ENABLE` reader - Dual Control Enable"]
pub type DEFAULT_ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `DEFAULT_ENABLE` writer - Dual Control Enable"]
pub type DEFAULT_ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DUALCTRL_SPEC , bool , O > ; # [doc = "Field `DEFAULT_FMPEN` reader - FM Plus Enable"]
pub type DEFAULT_FMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `DEFAULT_FMPEN` writer - FM Plus Enable"]
pub type DEFAULT_FMPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DUALCTRL_SPEC , bool , O > ; # [doc = "Field `DEFAULT_SDAHOLD` reader - SDA Hold Time"]
pub type DEFAULT_SDAHOLD_R = crate :: FieldReader < u8 , DEFAULT_SDAHOLD_A > ; # [doc = "SDA Hold Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DEFAULT_SDAHOLD_A { # [doc = "0: SDA hold time off"]
OFF = 0 , # [doc = "1: Typical 50ns hold time"]
_50NS = 1 , # [doc = "2: Typical 300ns hold time"]
_300NS = 2 , # [doc = "3: Typical 500ns hold time"]
_500NS = 3 , } impl From < DEFAULT_SDAHOLD_A > for u8 { # [inline (always)]
fn from (variant : DEFAULT_SDAHOLD_A) -> Self { variant as _ } } impl DEFAULT_SDAHOLD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DEFAULT_SDAHOLD_A { match self . bits { 0 => DEFAULT_SDAHOLD_A :: OFF , 1 => DEFAULT_SDAHOLD_A :: _50NS , 2 => DEFAULT_SDAHOLD_A :: _300NS , 3 => DEFAULT_SDAHOLD_A :: _500NS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DEFAULT_SDAHOLD_A :: OFF } # [doc = "Checks if the value of the field is `_50NS`"]
# [inline (always)]
pub fn is_50ns (& self) -> bool { * self == DEFAULT_SDAHOLD_A :: _50NS } # [doc = "Checks if the value of the field is `_300NS`"]
# [inline (always)]
pub fn is_300ns (& self) -> bool { * self == DEFAULT_SDAHOLD_A :: _300NS } # [doc = "Checks if the value of the field is `_500NS`"]
# [inline (always)]
pub fn is_500ns (& self) -> bool { * self == DEFAULT_SDAHOLD_A :: _500NS } } # [doc = "Field `DEFAULT_SDAHOLD` writer - SDA Hold Time"]
pub type DEFAULT_SDAHOLD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , DUALCTRL_SPEC , u8 , DEFAULT_SDAHOLD_A , 2 , O > ; impl < 'a , const O : u8 > DEFAULT_SDAHOLD_W < 'a , O > { # [doc = "SDA hold time off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DEFAULT_SDAHOLD_A :: OFF) } # [doc = "Typical 50ns hold time"]
# [inline (always)]
pub fn _50ns (self) -> & 'a mut W { self . variant (DEFAULT_SDAHOLD_A :: _50NS) } # [doc = "Typical 300ns hold time"]
# [inline (always)]
pub fn _300ns (self) -> & 'a mut W { self . variant (DEFAULT_SDAHOLD_A :: _300NS) } # [doc = "Typical 500ns hold time"]
# [inline (always)]
pub fn _500ns (self) -> & 'a mut W { self . variant (DEFAULT_SDAHOLD_A :: _500NS) } } impl R { # [doc = "Bit 0 - Dual Control Enable"]
# [inline (always)]
pub fn default_enable (& self) -> DEFAULT_ENABLE_R { DEFAULT_ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - FM Plus Enable"]
# [inline (always)]
pub fn default_fmpen (& self) -> DEFAULT_FMPEN_R { DEFAULT_FMPEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - SDA Hold Time"]
# [inline (always)]
pub fn default_sdahold (& self) -> DEFAULT_SDAHOLD_R { DEFAULT_SDAHOLD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Dual Control Enable"]
# [inline (always)]
# [must_use]
pub fn default_enable (& mut self) -> DEFAULT_ENABLE_W < 0 > { DEFAULT_ENABLE_W :: new (self) } # [doc = "Bit 1 - FM Plus Enable"]
# [inline (always)]
# [must_use]
pub fn default_fmpen (& mut self) -> DEFAULT_FMPEN_W < 1 > { DEFAULT_FMPEN_W :: new (self) } # [doc = "Bits 2:3 - SDA Hold Time"]
# [inline (always)]
# [must_use]
pub fn default_sdahold (& mut self) -> DEFAULT_SDAHOLD_W < 2 > { DEFAULT_SDAHOLD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Dual Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dualctrl](index.html) module"]
pub struct DUALCTRL_SPEC ; impl crate :: RegisterSpec for DUALCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dualctrl::R](R) reader structure"]
impl crate :: Readable for DUALCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dualctrl::W](W) writer structure"]
impl crate :: Writable for DUALCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DUALCTRL to value 0"]
impl crate :: Resettable for DUALCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MADDR (rw) register accessor: an alias for `Reg<MADDR_SPEC>`"]
pub type MADDR = crate :: Reg < maddr :: MADDR_SPEC > ; # [doc = "Master Address"]
pub mod maddr { # [doc = "Register `MADDR` reader"]
pub struct R (crate :: R < MADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MADDR` writer"]
pub struct W (crate :: W < MADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MADDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Master Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [maddr](index.html) module"]
pub struct MADDR_SPEC ; impl crate :: RegisterSpec for MADDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [maddr::R](R) reader structure"]
impl crate :: Readable for MADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [maddr::W](W) writer structure"]
impl crate :: Writable for MADDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MADDR to value 0"]
impl crate :: Resettable for MADDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MBAUD (rw) register accessor: an alias for `Reg<MBAUD_SPEC>`"]
pub type MBAUD = crate :: Reg < mbaud :: MBAUD_SPEC > ; # [doc = "Master Baurd Rate Control"]
pub mod mbaud { # [doc = "Register `MBAUD` reader"]
pub struct R (crate :: R < MBAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MBAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MBAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MBAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `MBAUD` writer"]
pub struct W (crate :: W < MBAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MBAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MBAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MBAUD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Master Baurd Rate Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mbaud](index.html) module"]
pub struct MBAUD_SPEC ; impl crate :: RegisterSpec for MBAUD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mbaud::R](R) reader structure"]
impl crate :: Readable for MBAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mbaud::W](W) writer structure"]
impl crate :: Writable for MBAUD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MBAUD to value 0"]
impl crate :: Resettable for MBAUD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCTRLA (rw) register accessor: an alias for `Reg<MCTRLA_SPEC>`"]
pub type MCTRLA = crate :: Reg < mctrla :: MCTRLA_SPEC > ; # [doc = "Master Control A"]
pub mod mctrla { # [doc = "Register `MCTRLA` reader"]
pub struct R (crate :: R < MCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCTRLA` writer"]
pub struct W (crate :: W < MCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable TWI Master"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable TWI Master"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; # [doc = "Field `SMEN` reader - Smart Mode Enable"]
pub type SMEN_R = crate :: BitReader < bool > ; # [doc = "Field `SMEN` writer - Smart Mode Enable"]
pub type SMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; # [doc = "Field `TIMEOUT` reader - Inactive Bus Timeout"]
pub type TIMEOUT_R = crate :: FieldReader < u8 , TIMEOUT_A > ; # [doc = "Inactive Bus Timeout\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TIMEOUT_A { # [doc = "0: Bus Timeout Disabled"]
DISABLED = 0 , # [doc = "1: 50 Microseconds"]
_50US = 1 , # [doc = "2: 100 Microseconds"]
_100US = 2 , # [doc = "3: 200 Microseconds"]
_200US = 3 , } impl From < TIMEOUT_A > for u8 { # [inline (always)]
fn from (variant : TIMEOUT_A) -> Self { variant as _ } } impl TIMEOUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TIMEOUT_A { match self . bits { 0 => TIMEOUT_A :: DISABLED , 1 => TIMEOUT_A :: _50US , 2 => TIMEOUT_A :: _100US , 3 => TIMEOUT_A :: _200US , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == TIMEOUT_A :: DISABLED } # [doc = "Checks if the value of the field is `_50US`"]
# [inline (always)]
pub fn is_50us (& self) -> bool { * self == TIMEOUT_A :: _50US } # [doc = "Checks if the value of the field is `_100US`"]
# [inline (always)]
pub fn is_100us (& self) -> bool { * self == TIMEOUT_A :: _100US } # [doc = "Checks if the value of the field is `_200US`"]
# [inline (always)]
pub fn is_200us (& self) -> bool { * self == TIMEOUT_A :: _200US } } # [doc = "Field `TIMEOUT` writer - Inactive Bus Timeout"]
pub type TIMEOUT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MCTRLA_SPEC , u8 , TIMEOUT_A , 2 , O > ; impl < 'a , const O : u8 > TIMEOUT_W < 'a , O > { # [doc = "Bus Timeout Disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (TIMEOUT_A :: DISABLED) } # [doc = "50 Microseconds"]
# [inline (always)]
pub fn _50us (self) -> & 'a mut W { self . variant (TIMEOUT_A :: _50US) } # [doc = "100 Microseconds"]
# [inline (always)]
pub fn _100us (self) -> & 'a mut W { self . variant (TIMEOUT_A :: _100US) } # [doc = "200 Microseconds"]
# [inline (always)]
pub fn _200us (self) -> & 'a mut W { self . variant (TIMEOUT_A :: _200US) } } # [doc = "Field `QCEN` reader - Quick Command Enable"]
pub type QCEN_R = crate :: BitReader < bool > ; # [doc = "Field `QCEN` writer - Quick Command Enable"]
pub type QCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; # [doc = "Field `WIEN` reader - Write Interrupt Enable"]
pub type WIEN_R = crate :: BitReader < bool > ; # [doc = "Field `WIEN` writer - Write Interrupt Enable"]
pub type WIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; # [doc = "Field `RIEN` reader - Read Interrupt Enable"]
pub type RIEN_R = crate :: BitReader < bool > ; # [doc = "Field `RIEN` writer - Read Interrupt Enable"]
pub type RIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable TWI Master"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Smart Mode Enable"]
# [inline (always)]
pub fn smen (& self) -> SMEN_R { SMEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Inactive Bus Timeout"]
# [inline (always)]
pub fn timeout (& self) -> TIMEOUT_R { TIMEOUT_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Quick Command Enable"]
# [inline (always)]
pub fn qcen (& self) -> QCEN_R { QCEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Write Interrupt Enable"]
# [inline (always)]
pub fn wien (& self) -> WIEN_R { WIEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Read Interrupt Enable"]
# [inline (always)]
pub fn rien (& self) -> RIEN_R { RIEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable TWI Master"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Smart Mode Enable"]
# [inline (always)]
# [must_use]
pub fn smen (& mut self) -> SMEN_W < 1 > { SMEN_W :: new (self) } # [doc = "Bits 2:3 - Inactive Bus Timeout"]
# [inline (always)]
# [must_use]
pub fn timeout (& mut self) -> TIMEOUT_W < 2 > { TIMEOUT_W :: new (self) } # [doc = "Bit 4 - Quick Command Enable"]
# [inline (always)]
# [must_use]
pub fn qcen (& mut self) -> QCEN_W < 4 > { QCEN_W :: new (self) } # [doc = "Bit 6 - Write Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn wien (& mut self) -> WIEN_W < 6 > { WIEN_W :: new (self) } # [doc = "Bit 7 - Read Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rien (& mut self) -> RIEN_W < 7 > { RIEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Master Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mctrla](index.html) module"]
pub struct MCTRLA_SPEC ; impl crate :: RegisterSpec for MCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mctrla::R](R) reader structure"]
impl crate :: Readable for MCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mctrla::W](W) writer structure"]
impl crate :: Writable for MCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCTRLA to value 0"]
impl crate :: Resettable for MCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCTRLB (rw) register accessor: an alias for `Reg<MCTRLB_SPEC>`"]
pub type MCTRLB = crate :: Reg < mctrlb :: MCTRLB_SPEC > ; # [doc = "Master Control B"]
pub mod mctrlb { # [doc = "Register `MCTRLB` reader"]
pub struct R (crate :: R < MCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCTRLB` writer"]
pub struct W (crate :: W < MCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MCMD` reader - Command"]
pub type MCMD_R = crate :: FieldReader < u8 , MCMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MCMD_A { # [doc = "0: No Action"]
NOACT = 0 , # [doc = "1: Issue Repeated Start Condition"]
REPSTART = 1 , # [doc = "2: Receive or Transmit Data, depending on DIR"]
RECVTRANS = 2 , # [doc = "3: Issue Stop Condition"]
STOP = 3 , } impl From < MCMD_A > for u8 { # [inline (always)]
fn from (variant : MCMD_A) -> Self { variant as _ } } impl MCMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MCMD_A { match self . bits { 0 => MCMD_A :: NOACT , 1 => MCMD_A :: REPSTART , 2 => MCMD_A :: RECVTRANS , 3 => MCMD_A :: STOP , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NOACT`"]
# [inline (always)]
pub fn is_noact (& self) -> bool { * self == MCMD_A :: NOACT } # [doc = "Checks if the value of the field is `REPSTART`"]
# [inline (always)]
pub fn is_repstart (& self) -> bool { * self == MCMD_A :: REPSTART } # [doc = "Checks if the value of the field is `RECVTRANS`"]
# [inline (always)]
pub fn is_recvtrans (& self) -> bool { * self == MCMD_A :: RECVTRANS } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == MCMD_A :: STOP } } # [doc = "Field `MCMD` writer - Command"]
pub type MCMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MCTRLB_SPEC , u8 , MCMD_A , 2 , O > ; impl < 'a , const O : u8 > MCMD_W < 'a , O > { # [doc = "No Action"]
# [inline (always)]
pub fn noact (self) -> & 'a mut W { self . variant (MCMD_A :: NOACT) } # [doc = "Issue Repeated Start Condition"]
# [inline (always)]
pub fn repstart (self) -> & 'a mut W { self . variant (MCMD_A :: REPSTART) } # [doc = "Receive or Transmit Data, depending on DIR"]
# [inline (always)]
pub fn recvtrans (self) -> & 'a mut W { self . variant (MCMD_A :: RECVTRANS) } # [doc = "Issue Stop Condition"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (MCMD_A :: STOP) } } # [doc = "Field `ACKACT` reader - Acknowledge Action"]
pub type ACKACT_R = crate :: BitReader < ACKACT_A > ; # [doc = "Acknowledge Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ACKACT_A { # [doc = "0: Send ACK"]
ACK = 0 , # [doc = "1: Send NACK"]
NACK = 1 , } impl From < ACKACT_A > for bool { # [inline (always)]
fn from (variant : ACKACT_A) -> Self { variant as u8 != 0 } } impl ACKACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACKACT_A { match self . bits { false => ACKACT_A :: ACK , true => ACKACT_A :: NACK , } } # [doc = "Checks if the value of the field is `ACK`"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == ACKACT_A :: ACK } # [doc = "Checks if the value of the field is `NACK`"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == ACKACT_A :: NACK } } # [doc = "Field `ACKACT` writer - Acknowledge Action"]
pub type ACKACT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLB_SPEC , ACKACT_A , O > ; impl < 'a , const O : u8 > ACKACT_W < 'a , O > { # [doc = "Send ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut W { self . variant (ACKACT_A :: ACK) } # [doc = "Send NACK"]
# [inline (always)]
pub fn nack (self) -> & 'a mut W { self . variant (ACKACT_A :: NACK) } } # [doc = "Field `FLUSH` reader - Flush"]
pub type FLUSH_R = crate :: BitReader < bool > ; # [doc = "Field `FLUSH` writer - Flush"]
pub type FLUSH_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Command"]
# [inline (always)]
pub fn mcmd (& self) -> MCMD_R { MCMD_R :: new (self . bits & 3) } # [doc = "Bit 2 - Acknowledge Action"]
# [inline (always)]
pub fn ackact (& self) -> ACKACT_R { ACKACT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Flush"]
# [inline (always)]
pub fn flush (& self) -> FLUSH_R { FLUSH_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Command"]
# [inline (always)]
# [must_use]
pub fn mcmd (& mut self) -> MCMD_W < 0 > { MCMD_W :: new (self) } # [doc = "Bit 2 - Acknowledge Action"]
# [inline (always)]
# [must_use]
pub fn ackact (& mut self) -> ACKACT_W < 2 > { ACKACT_W :: new (self) } # [doc = "Bit 3 - Flush"]
# [inline (always)]
# [must_use]
pub fn flush (& mut self) -> FLUSH_W < 3 > { FLUSH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Master Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mctrlb](index.html) module"]
pub struct MCTRLB_SPEC ; impl crate :: RegisterSpec for MCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mctrlb::R](R) reader structure"]
impl crate :: Readable for MCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mctrlb::W](W) writer structure"]
impl crate :: Writable for MCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCTRLB to value 0"]
impl crate :: Resettable for MCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MDATA (rw) register accessor: an alias for `Reg<MDATA_SPEC>`"]
pub type MDATA = crate :: Reg < mdata :: MDATA_SPEC > ; # [doc = "Master Data"]
pub mod mdata { # [doc = "Register `MDATA` reader"]
pub struct R (crate :: R < MDATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MDATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MDATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MDATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `MDATA` writer"]
pub struct W (crate :: W < MDATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MDATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MDATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MDATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Master Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mdata](index.html) module"]
pub struct MDATA_SPEC ; impl crate :: RegisterSpec for MDATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mdata::R](R) reader structure"]
impl crate :: Readable for MDATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mdata::W](W) writer structure"]
impl crate :: Writable for MDATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MDATA to value 0"]
impl crate :: Resettable for MDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MSTATUS (rw) register accessor: an alias for `Reg<MSTATUS_SPEC>`"]
pub type MSTATUS = crate :: Reg < mstatus :: MSTATUS_SPEC > ; # [doc = "Master Status"]
pub mod mstatus { # [doc = "Register `MSTATUS` reader"]
pub struct R (crate :: R < MSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `MSTATUS` writer"]
pub struct W (crate :: W < MSTATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MSTATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MSTATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `BUSSTATE` reader - Bus State"]
pub type BUSSTATE_R = crate :: FieldReader < u8 , BUSSTATE_A > ; # [doc = "Bus State\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BUSSTATE_A { # [doc = "0: Unknown Bus State"]
UNKNOWN = 0 , # [doc = "1: Bus is Idle"]
IDLE = 1 , # [doc = "2: This Module Controls The Bus"]
OWNER = 2 , # [doc = "3: The Bus is Busy"]
BUSY = 3 , } impl From < BUSSTATE_A > for u8 { # [inline (always)]
fn from (variant : BUSSTATE_A) -> Self { variant as _ } } impl BUSSTATE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BUSSTATE_A { match self . bits { 0 => BUSSTATE_A :: UNKNOWN , 1 => BUSSTATE_A :: IDLE , 2 => BUSSTATE_A :: OWNER , 3 => BUSSTATE_A :: BUSY , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `UNKNOWN`"]
# [inline (always)]
pub fn is_unknown (& self) -> bool { * self == BUSSTATE_A :: UNKNOWN } # [doc = "Checks if the value of the field is `IDLE`"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == BUSSTATE_A :: IDLE } # [doc = "Checks if the value of the field is `OWNER`"]
# [inline (always)]
pub fn is_owner (& self) -> bool { * self == BUSSTATE_A :: OWNER } # [doc = "Checks if the value of the field is `BUSY`"]
# [inline (always)]
pub fn is_busy (& self) -> bool { * self == BUSSTATE_A :: BUSY } } # [doc = "Field `BUSSTATE` writer - Bus State"]
pub type BUSSTATE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , MSTATUS_SPEC , u8 , BUSSTATE_A , 2 , O > ; impl < 'a , const O : u8 > BUSSTATE_W < 'a , O > { # [doc = "Unknown Bus State"]
# [inline (always)]
pub fn unknown (self) -> & 'a mut W { self . variant (BUSSTATE_A :: UNKNOWN) } # [doc = "Bus is Idle"]
# [inline (always)]
pub fn idle (self) -> & 'a mut W { self . variant (BUSSTATE_A :: IDLE) } # [doc = "This Module Controls The Bus"]
# [inline (always)]
pub fn owner (self) -> & 'a mut W { self . variant (BUSSTATE_A :: OWNER) } # [doc = "The Bus is Busy"]
# [inline (always)]
pub fn busy (self) -> & 'a mut W { self . variant (BUSSTATE_A :: BUSY) } } # [doc = "Field `BUSERR` reader - Bus Error"]
pub type BUSERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSERR` writer - Bus Error"]
pub type BUSERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; # [doc = "Field `ARBLOST` reader - Arbitration Lost"]
pub type ARBLOST_R = crate :: BitReader < bool > ; # [doc = "Field `ARBLOST` writer - Arbitration Lost"]
pub type ARBLOST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; # [doc = "Field `RXACK` reader - Received Acknowledge"]
pub type RXACK_R = crate :: BitReader < bool > ; # [doc = "Field `CLKHOLD` reader - Clock Hold"]
pub type CLKHOLD_R = crate :: BitReader < bool > ; # [doc = "Field `CLKHOLD` writer - Clock Hold"]
pub type CLKHOLD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; # [doc = "Field `WIF` reader - Write Interrupt Flag"]
pub type WIF_R = crate :: BitReader < bool > ; # [doc = "Field `WIF` writer - Write Interrupt Flag"]
pub type WIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; # [doc = "Field `RIF` reader - Read Interrupt Flag"]
pub type RIF_R = crate :: BitReader < bool > ; # [doc = "Field `RIF` writer - Read Interrupt Flag"]
pub type RIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MSTATUS_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Bus State"]
# [inline (always)]
pub fn busstate (& self) -> BUSSTATE_R { BUSSTATE_R :: new (self . bits & 3) } # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
pub fn buserr (& self) -> BUSERR_R { BUSERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Arbitration Lost"]
# [inline (always)]
pub fn arblost (& self) -> ARBLOST_R { ARBLOST_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Received Acknowledge"]
# [inline (always)]
pub fn rxack (& self) -> RXACK_R { RXACK_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Clock Hold"]
# [inline (always)]
pub fn clkhold (& self) -> CLKHOLD_R { CLKHOLD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Write Interrupt Flag"]
# [inline (always)]
pub fn wif (& self) -> WIF_R { WIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Read Interrupt Flag"]
# [inline (always)]
pub fn rif (& self) -> RIF_R { RIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Bus State"]
# [inline (always)]
# [must_use]
pub fn busstate (& mut self) -> BUSSTATE_W < 0 > { BUSSTATE_W :: new (self) } # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
# [must_use]
pub fn buserr (& mut self) -> BUSERR_W < 2 > { BUSERR_W :: new (self) } # [doc = "Bit 3 - Arbitration Lost"]
# [inline (always)]
# [must_use]
pub fn arblost (& mut self) -> ARBLOST_W < 3 > { ARBLOST_W :: new (self) } # [doc = "Bit 5 - Clock Hold"]
# [inline (always)]
# [must_use]
pub fn clkhold (& mut self) -> CLKHOLD_W < 5 > { CLKHOLD_W :: new (self) } # [doc = "Bit 6 - Write Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn wif (& mut self) -> WIF_W < 6 > { WIF_W :: new (self) } # [doc = "Bit 7 - Read Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rif (& mut self) -> RIF_W < 7 > { RIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Master Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mstatus](index.html) module"]
pub struct MSTATUS_SPEC ; impl crate :: RegisterSpec for MSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mstatus::R](R) reader structure"]
impl crate :: Readable for MSTATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mstatus::W](W) writer structure"]
impl crate :: Writable for MSTATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MSTATUS to value 0"]
impl crate :: Resettable for MSTATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SADDR (rw) register accessor: an alias for `Reg<SADDR_SPEC>`"]
pub type SADDR = crate :: Reg < saddr :: SADDR_SPEC > ; # [doc = "Slave Address"]
pub mod saddr { # [doc = "Register `SADDR` reader"]
pub struct R (crate :: R < SADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SADDR` writer"]
pub struct W (crate :: W < SADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SADDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Slave Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [saddr](index.html) module"]
pub struct SADDR_SPEC ; impl crate :: RegisterSpec for SADDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [saddr::R](R) reader structure"]
impl crate :: Readable for SADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [saddr::W](W) writer structure"]
impl crate :: Writable for SADDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SADDR to value 0"]
impl crate :: Resettable for SADDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SADDRMASK (rw) register accessor: an alias for `Reg<SADDRMASK_SPEC>`"]
pub type SADDRMASK = crate :: Reg < saddrmask :: SADDRMASK_SPEC > ; # [doc = "Slave Address Mask"]
pub mod saddrmask { # [doc = "Register `SADDRMASK` reader"]
pub struct R (crate :: R < SADDRMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SADDRMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SADDRMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SADDRMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `SADDRMASK` writer"]
pub struct W (crate :: W < SADDRMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SADDRMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SADDRMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SADDRMASK_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDREN` reader - Address Enable"]
pub type ADDREN_R = crate :: BitReader < bool > ; # [doc = "Field `ADDREN` writer - Address Enable"]
pub type ADDREN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SADDRMASK_SPEC , bool , O > ; # [doc = "Field `ADDRMASK` reader - Address Mask"]
pub type ADDRMASK_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ADDRMASK` writer - Address Mask"]
pub type ADDRMASK_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SADDRMASK_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bit 0 - Address Enable"]
# [inline (always)]
pub fn addren (& self) -> ADDREN_R { ADDREN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:7 - Address Mask"]
# [inline (always)]
pub fn addrmask (& self) -> ADDRMASK_R { ADDRMASK_R :: new ((self . bits >> 1) & 0x7f) } } impl W { # [doc = "Bit 0 - Address Enable"]
# [inline (always)]
# [must_use]
pub fn addren (& mut self) -> ADDREN_W < 0 > { ADDREN_W :: new (self) } # [doc = "Bits 1:7 - Address Mask"]
# [inline (always)]
# [must_use]
pub fn addrmask (& mut self) -> ADDRMASK_W < 1 > { ADDRMASK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Address Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [saddrmask](index.html) module"]
pub struct SADDRMASK_SPEC ; impl crate :: RegisterSpec for SADDRMASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [saddrmask::R](R) reader structure"]
impl crate :: Readable for SADDRMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [saddrmask::W](W) writer structure"]
impl crate :: Writable for SADDRMASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SADDRMASK to value 0"]
impl crate :: Resettable for SADDRMASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCTRLA (rw) register accessor: an alias for `Reg<SCTRLA_SPEC>`"]
pub type SCTRLA = crate :: Reg < sctrla :: SCTRLA_SPEC > ; # [doc = "Slave Control A"]
pub mod sctrla { # [doc = "Register `SCTRLA` reader"]
pub struct R (crate :: R < SCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCTRLA` writer"]
pub struct W (crate :: W < SCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable TWI Slave"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable TWI Slave"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `SMEN` reader - Smart Mode Enable"]
pub type SMEN_R = crate :: BitReader < bool > ; # [doc = "Field `SMEN` writer - Smart Mode Enable"]
pub type SMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `PMEN` reader - Promiscuous Mode Enable"]
pub type PMEN_R = crate :: BitReader < bool > ; # [doc = "Field `PMEN` writer - Promiscuous Mode Enable"]
pub type PMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `PIEN` reader - Stop Interrupt Enable"]
pub type PIEN_R = crate :: BitReader < bool > ; # [doc = "Field `PIEN` writer - Stop Interrupt Enable"]
pub type PIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `APIEN` reader - Address/Stop Interrupt Enable"]
pub type APIEN_R = crate :: BitReader < bool > ; # [doc = "Field `APIEN` writer - Address/Stop Interrupt Enable"]
pub type APIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; # [doc = "Field `DIEN` reader - Data Interrupt Enable"]
pub type DIEN_R = crate :: BitReader < bool > ; # [doc = "Field `DIEN` writer - Data Interrupt Enable"]
pub type DIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable TWI Slave"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Smart Mode Enable"]
# [inline (always)]
pub fn smen (& self) -> SMEN_R { SMEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Promiscuous Mode Enable"]
# [inline (always)]
pub fn pmen (& self) -> PMEN_R { PMEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 5 - Stop Interrupt Enable"]
# [inline (always)]
pub fn pien (& self) -> PIEN_R { PIEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Address/Stop Interrupt Enable"]
# [inline (always)]
pub fn apien (& self) -> APIEN_R { APIEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Data Interrupt Enable"]
# [inline (always)]
pub fn dien (& self) -> DIEN_R { DIEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable TWI Slave"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Smart Mode Enable"]
# [inline (always)]
# [must_use]
pub fn smen (& mut self) -> SMEN_W < 1 > { SMEN_W :: new (self) } # [doc = "Bit 2 - Promiscuous Mode Enable"]
# [inline (always)]
# [must_use]
pub fn pmen (& mut self) -> PMEN_W < 2 > { PMEN_W :: new (self) } # [doc = "Bit 5 - Stop Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn pien (& mut self) -> PIEN_W < 5 > { PIEN_W :: new (self) } # [doc = "Bit 6 - Address/Stop Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn apien (& mut self) -> APIEN_W < 6 > { APIEN_W :: new (self) } # [doc = "Bit 7 - Data Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dien (& mut self) -> DIEN_W < 7 > { DIEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sctrla](index.html) module"]
pub struct SCTRLA_SPEC ; impl crate :: RegisterSpec for SCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sctrla::R](R) reader structure"]
impl crate :: Readable for SCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sctrla::W](W) writer structure"]
impl crate :: Writable for SCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTRLA to value 0"]
impl crate :: Resettable for SCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SCTRLB (rw) register accessor: an alias for `Reg<SCTRLB_SPEC>`"]
pub type SCTRLB = crate :: Reg < sctrlb :: SCTRLB_SPEC > ; # [doc = "Slave Control B"]
pub mod sctrlb { # [doc = "Register `SCTRLB` reader"]
pub struct R (crate :: R < SCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCTRLB` writer"]
pub struct W (crate :: W < SCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCMD` reader - Command"]
pub type SCMD_R = crate :: FieldReader < u8 , SCMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SCMD_A { # [doc = "0: No Action"]
NOACT = 0 , # [doc = "2: Used To Complete a Transaction"]
COMPTRANS = 2 , # [doc = "3: Used in Response to Address/Data Interrupt"]
RESPONSE = 3 , } impl From < SCMD_A > for u8 { # [inline (always)]
fn from (variant : SCMD_A) -> Self { variant as _ } } impl SCMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SCMD_A > { match self . bits { 0 => Some (SCMD_A :: NOACT) , 2 => Some (SCMD_A :: COMPTRANS) , 3 => Some (SCMD_A :: RESPONSE) , _ => None , } } # [doc = "Checks if the value of the field is `NOACT`"]
# [inline (always)]
pub fn is_noact (& self) -> bool { * self == SCMD_A :: NOACT } # [doc = "Checks if the value of the field is `COMPTRANS`"]
# [inline (always)]
pub fn is_comptrans (& self) -> bool { * self == SCMD_A :: COMPTRANS } # [doc = "Checks if the value of the field is `RESPONSE`"]
# [inline (always)]
pub fn is_response (& self) -> bool { * self == SCMD_A :: RESPONSE } } # [doc = "Field `SCMD` writer - Command"]
pub type SCMD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , SCTRLB_SPEC , u8 , SCMD_A , 2 , O > ; impl < 'a , const O : u8 > SCMD_W < 'a , O > { # [doc = "No Action"]
# [inline (always)]
pub fn noact (self) -> & 'a mut W { self . variant (SCMD_A :: NOACT) } # [doc = "Used To Complete a Transaction"]
# [inline (always)]
pub fn comptrans (self) -> & 'a mut W { self . variant (SCMD_A :: COMPTRANS) } # [doc = "Used in Response to Address/Data Interrupt"]
# [inline (always)]
pub fn response (self) -> & 'a mut W { self . variant (SCMD_A :: RESPONSE) } } # [doc = "Field `ACKACT` reader - Acknowledge Action"]
pub type ACKACT_R = crate :: BitReader < ACKACT_A > ; # [doc = "Acknowledge Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ACKACT_A { # [doc = "0: Send ACK"]
ACK = 0 , # [doc = "1: Send NACK"]
NACK = 1 , } impl From < ACKACT_A > for bool { # [inline (always)]
fn from (variant : ACKACT_A) -> Self { variant as u8 != 0 } } impl ACKACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACKACT_A { match self . bits { false => ACKACT_A :: ACK , true => ACKACT_A :: NACK , } } # [doc = "Checks if the value of the field is `ACK`"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == ACKACT_A :: ACK } # [doc = "Checks if the value of the field is `NACK`"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == ACKACT_A :: NACK } } # [doc = "Field `ACKACT` writer - Acknowledge Action"]
pub type ACKACT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SCTRLB_SPEC , ACKACT_A , O > ; impl < 'a , const O : u8 > ACKACT_W < 'a , O > { # [doc = "Send ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut W { self . variant (ACKACT_A :: ACK) } # [doc = "Send NACK"]
# [inline (always)]
pub fn nack (self) -> & 'a mut W { self . variant (ACKACT_A :: NACK) } } impl R { # [doc = "Bits 0:1 - Command"]
# [inline (always)]
pub fn scmd (& self) -> SCMD_R { SCMD_R :: new (self . bits & 3) } # [doc = "Bit 2 - Acknowledge Action"]
# [inline (always)]
pub fn ackact (& self) -> ACKACT_R { ACKACT_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Command"]
# [inline (always)]
# [must_use]
pub fn scmd (& mut self) -> SCMD_W < 0 > { SCMD_W :: new (self) } # [doc = "Bit 2 - Acknowledge Action"]
# [inline (always)]
# [must_use]
pub fn ackact (& mut self) -> ACKACT_W < 2 > { ACKACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sctrlb](index.html) module"]
pub struct SCTRLB_SPEC ; impl crate :: RegisterSpec for SCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sctrlb::R](R) reader structure"]
impl crate :: Readable for SCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sctrlb::W](W) writer structure"]
impl crate :: Writable for SCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SCTRLB to value 0"]
impl crate :: Resettable for SCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SDATA (rw) register accessor: an alias for `Reg<SDATA_SPEC>`"]
pub type SDATA = crate :: Reg < sdata :: SDATA_SPEC > ; # [doc = "Slave Data"]
pub mod sdata { # [doc = "Register `SDATA` reader"]
pub struct R (crate :: R < SDATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SDATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SDATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SDATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `SDATA` writer"]
pub struct W (crate :: W < SDATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SDATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SDATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SDATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Slave Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sdata](index.html) module"]
pub struct SDATA_SPEC ; impl crate :: RegisterSpec for SDATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sdata::R](R) reader structure"]
impl crate :: Readable for SDATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sdata::W](W) writer structure"]
impl crate :: Writable for SDATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SDATA to value 0"]
impl crate :: Resettable for SDATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SSTATUS (rw) register accessor: an alias for `Reg<SSTATUS_SPEC>`"]
pub type SSTATUS = crate :: Reg < sstatus :: SSTATUS_SPEC > ; # [doc = "Slave Status"]
pub mod sstatus { # [doc = "Register `SSTATUS` reader"]
pub struct R (crate :: R < SSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `SSTATUS` writer"]
pub struct W (crate :: W < SSTATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SSTATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SSTATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `AP` reader - Slave Address or Stop"]
pub type AP_R = crate :: BitReader < AP_A > ; # [doc = "Slave Address or Stop\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AP_A { # [doc = "0: Stop condition generated APIF"]
STOP = 0 , # [doc = "1: Address detection generated APIF"]
ADR = 1 , } impl From < AP_A > for bool { # [inline (always)]
fn from (variant : AP_A) -> Self { variant as u8 != 0 } } impl AP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> AP_A { match self . bits { false => AP_A :: STOP , true => AP_A :: ADR , } } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == AP_A :: STOP } # [doc = "Checks if the value of the field is `ADR`"]
# [inline (always)]
pub fn is_adr (& self) -> bool { * self == AP_A :: ADR } } # [doc = "Field `DIR` reader - Read/Write Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSERR` reader - Bus Error"]
pub type BUSERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSERR` writer - Bus Error"]
pub type BUSERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SSTATUS_SPEC , bool , O > ; # [doc = "Field `COLL` reader - Collision"]
pub type COLL_R = crate :: BitReader < bool > ; # [doc = "Field `COLL` writer - Collision"]
pub type COLL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SSTATUS_SPEC , bool , O > ; # [doc = "Field `RXACK` reader - Received Acknowledge"]
pub type RXACK_R = crate :: BitReader < bool > ; # [doc = "Field `CLKHOLD` reader - Clock Hold"]
pub type CLKHOLD_R = crate :: BitReader < bool > ; # [doc = "Field `APIF` reader - Address/Stop Interrupt Flag"]
pub type APIF_R = crate :: BitReader < bool > ; # [doc = "Field `APIF` writer - Address/Stop Interrupt Flag"]
pub type APIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SSTATUS_SPEC , bool , O > ; # [doc = "Field `DIF` reader - Data Interrupt Flag"]
pub type DIF_R = crate :: BitReader < bool > ; # [doc = "Field `DIF` writer - Data Interrupt Flag"]
pub type DIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SSTATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Slave Address or Stop"]
# [inline (always)]
pub fn ap (& self) -> AP_R { AP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Read/Write Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
pub fn buserr (& self) -> BUSERR_R { BUSERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Collision"]
# [inline (always)]
pub fn coll (& self) -> COLL_R { COLL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Received Acknowledge"]
# [inline (always)]
pub fn rxack (& self) -> RXACK_R { RXACK_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Clock Hold"]
# [inline (always)]
pub fn clkhold (& self) -> CLKHOLD_R { CLKHOLD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Address/Stop Interrupt Flag"]
# [inline (always)]
pub fn apif (& self) -> APIF_R { APIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Data Interrupt Flag"]
# [inline (always)]
pub fn dif (& self) -> DIF_R { DIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
# [must_use]
pub fn buserr (& mut self) -> BUSERR_W < 2 > { BUSERR_W :: new (self) } # [doc = "Bit 3 - Collision"]
# [inline (always)]
# [must_use]
pub fn coll (& mut self) -> COLL_W < 3 > { COLL_W :: new (self) } # [doc = "Bit 6 - Address/Stop Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn apif (& mut self) -> APIF_W < 6 > { APIF_W :: new (self) } # [doc = "Bit 7 - Data Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn dif (& mut self) -> DIF_W < 7 > { DIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Slave Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sstatus](index.html) module"]
pub struct SSTATUS_SPEC ; impl crate :: RegisterSpec for SSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sstatus::R](R) reader structure"]
impl crate :: Readable for SSTATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sstatus::W](W) writer structure"]
impl crate :: Writable for SSTATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SSTATUS to value 0"]
impl crate :: Resettable for SSTATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub struct USART0 { _marker : PhantomData < * const () > } unsafe impl Send for USART0 { } impl USART0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart0 :: RegisterBlock = 0x0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart0 :: RegisterBlock { Self :: PTR } } impl Deref for USART0 { type Target = usart0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART0") . finish () } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub mod usart0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Receive Data Low Byte"]
pub rxdatal : RXDATAL , # [doc = "0x01 - Receive Data High Byte"]
pub rxdatah : RXDATAH , # [doc = "0x02 - Transmit Data Low Byte"]
pub txdatal : TXDATAL , # [doc = "0x03 - Transmit Data High Byte"]
pub txdatah : TXDATAH , # [doc = "0x04 - Status"]
pub status : STATUS , # [doc = "0x05 - Control A"]
pub ctrla : CTRLA , # [doc = "0x06 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x07 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x08 - Baud Rate"]
pub baud : BAUD , # [doc = "0x0a - Control D"]
pub ctrld : CTRLD , # [doc = "0x0b - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x0c - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x0d - IRCOM Transmitter Pulse Length Control"]
pub txplctrl : TXPLCTRL , # [doc = "0x0e - IRCOM Receiver Pulse Length Control"]
pub rxplctrl : RXPLCTRL , } # [doc = "BAUD (rw) register accessor: an alias for `Reg<BAUD_SPEC>`"]
pub type BAUD = crate :: Reg < baud :: BAUD_SPEC > ; # [doc = "Baud Rate"]
pub mod baud { # [doc = "Register `BAUD` reader"]
pub struct R (crate :: R < BAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD` writer"]
pub struct W (crate :: W < BAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud](index.html) module"]
pub struct BAUD_SPEC ; impl crate :: RegisterSpec for BAUD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud::R](R) reader structure"]
impl crate :: Readable for BAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud::W](W) writer structure"]
impl crate :: Writable for BAUD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUD to value 0"]
impl crate :: Resettable for BAUD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RS485` reader - RS485 Mode internal transmitter"]
pub type RS485_R = crate :: FieldReader < u8 , RS485_A > ; # [doc = "RS485 Mode internal transmitter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RS485_A { # [doc = "0: RS485 Mode disabled"]
OFF = 0 , # [doc = "1: RS485 Mode External drive"]
EXT = 1 , # [doc = "2: RS485 Mode Internal drive"]
INT = 2 , } impl From < RS485_A > for u8 { # [inline (always)]
fn from (variant : RS485_A) -> Self { variant as _ } } impl RS485_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RS485_A > { match self . bits { 0 => Some (RS485_A :: OFF) , 1 => Some (RS485_A :: EXT) , 2 => Some (RS485_A :: INT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RS485_A :: OFF } # [doc = "Checks if the value of the field is `EXT`"]
# [inline (always)]
pub fn is_ext (& self) -> bool { * self == RS485_A :: EXT } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == RS485_A :: INT } } # [doc = "Field `RS485` writer - RS485 Mode internal transmitter"]
pub type RS485_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , RS485_A , 2 , O > ; impl < 'a , const O : u8 > RS485_W < 'a , O > { # [doc = "RS485 Mode disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RS485_A :: OFF) } # [doc = "RS485 Mode External drive"]
# [inline (always)]
pub fn ext (self) -> & 'a mut W { self . variant (RS485_A :: EXT) } # [doc = "RS485 Mode Internal drive"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (RS485_A :: INT) } } # [doc = "Field `ABEIE` reader - Auto-baud Error Interrupt Enable"]
pub type ABEIE_R = crate :: BitReader < bool > ; # [doc = "Field `ABEIE` writer - Auto-baud Error Interrupt Enable"]
pub type ABEIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `LBME` reader - Loop-back Mode Enable"]
pub type LBME_R = crate :: BitReader < bool > ; # [doc = "Field `LBME` writer - Loop-back Mode Enable"]
pub type LBME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXSIE` reader - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXSIE` writer - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DREIE` reader - Data Register Empty Interrupt Enable"]
pub type DREIE_R = crate :: BitReader < bool > ; # [doc = "Field `DREIE` writer - Data Register Empty Interrupt Enable"]
pub type DREIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `TXCIE` reader - Transmit Complete Interrupt Enable"]
pub type TXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE` writer - Transmit Complete Interrupt Enable"]
pub type TXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXCIE` reader - Receive Complete Interrupt Enable"]
pub type RXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE` writer - Receive Complete Interrupt Enable"]
pub type RXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
pub fn rs485 (& self) -> RS485_R { RS485_R :: new (self . bits & 3) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
pub fn abeie (& self) -> ABEIE_R { ABEIE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
pub fn lbme (& self) -> LBME_R { LBME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
pub fn rxsie (& self) -> RXSIE_R { RXSIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dreie (& self) -> DREIE_R { DREIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie (& self) -> TXCIE_R { TXCIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie (& self) -> RXCIE_R { RXCIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
# [must_use]
pub fn rs485 (& mut self) -> RS485_W < 0 > { RS485_W :: new (self) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn abeie (& mut self) -> ABEIE_W < 2 > { ABEIE_W :: new (self) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
# [must_use]
pub fn lbme (& mut self) -> LBME_W < 3 > { LBME_W :: new (self) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxsie (& mut self) -> RXSIE_W < 4 > { RXSIE_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dreie (& mut self) -> DREIE_W < 5 > { DREIE_W :: new (self) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie (& mut self) -> TXCIE_W < 6 > { TXCIE_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie (& mut self) -> RXCIE_W < 7 > { RXCIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXMODE` reader - Receiver Mode"]
pub type RXMODE_R = crate :: FieldReader < u8 , RXMODE_A > ; # [doc = "Receiver Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXMODE_A { # [doc = "0: Normal mode"]
NORMAL = 0 , # [doc = "1: CLK2x mode"]
CLK2X = 1 , # [doc = "2: Generic autobaud mode"]
GENAUTO = 2 , # [doc = "3: LIN constrained autobaud mode"]
LINAUTO = 3 , } impl From < RXMODE_A > for u8 { # [inline (always)]
fn from (variant : RXMODE_A) -> Self { variant as _ } } impl RXMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXMODE_A { match self . bits { 0 => RXMODE_A :: NORMAL , 1 => RXMODE_A :: CLK2X , 2 => RXMODE_A :: GENAUTO , 3 => RXMODE_A :: LINAUTO , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == RXMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `CLK2X`"]
# [inline (always)]
pub fn is_clk2x (& self) -> bool { * self == RXMODE_A :: CLK2X } # [doc = "Checks if the value of the field is `GENAUTO`"]
# [inline (always)]
pub fn is_genauto (& self) -> bool { * self == RXMODE_A :: GENAUTO } # [doc = "Checks if the value of the field is `LINAUTO`"]
# [inline (always)]
pub fn is_linauto (& self) -> bool { * self == RXMODE_A :: LINAUTO } } # [doc = "Field `RXMODE` writer - Receiver Mode"]
pub type RXMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , RXMODE_A , 2 , O > ; impl < 'a , const O : u8 > RXMODE_W < 'a , O > { # [doc = "Normal mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (RXMODE_A :: NORMAL) } # [doc = "CLK2x mode"]
# [inline (always)]
pub fn clk2x (self) -> & 'a mut W { self . variant (RXMODE_A :: CLK2X) } # [doc = "Generic autobaud mode"]
# [inline (always)]
pub fn genauto (self) -> & 'a mut W { self . variant (RXMODE_A :: GENAUTO) } # [doc = "LIN constrained autobaud mode"]
# [inline (always)]
pub fn linauto (self) -> & 'a mut W { self . variant (RXMODE_A :: LINAUTO) } } # [doc = "Field `ODME` reader - Open Drain Mode Enable"]
pub type ODME_R = crate :: BitReader < bool > ; # [doc = "Field `ODME` writer - Open Drain Mode Enable"]
pub type ODME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `SFDEN` reader - Start Frame Detection Enable"]
pub type SFDEN_R = crate :: BitReader < bool > ; # [doc = "Field `SFDEN` writer - Start Frame Detection Enable"]
pub type SFDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Reciever enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Reciever enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
pub fn rxmode (& self) -> RXMODE_R { RXMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
pub fn odme (& self) -> ODME_R { ODME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
pub fn sfden (& self) -> SFDEN_R { SFDEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 0 > { MPCM_W :: new (self) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
# [must_use]
pub fn rxmode (& mut self) -> RXMODE_W < 1 > { RXMODE_W :: new (self) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
# [must_use]
pub fn odme (& mut self) -> ODME_W < 3 > { ODME_W :: new (self) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
# [must_use]
pub fn sfden (& mut self) -> SFDEN_W < 4 > { SFDEN_W :: new (self) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 6 > { TXEN_W :: new (self) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 7 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `NORMAL_CHSIZE` reader - Character Size"]
pub type NORMAL_CHSIZE_R = crate :: FieldReader < u8 , NORMAL_CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "6: Character size: 9 bit read low byte first"]
_9BITL = 6 , # [doc = "7: Character size: 9 bit read high byte first"]
_9BITH = 7 , } impl From < NORMAL_CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_CHSIZE_A) -> Self { variant as _ } } impl NORMAL_CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NORMAL_CHSIZE_A > { match self . bits { 0 => Some (NORMAL_CHSIZE_A :: _5BIT) , 1 => Some (NORMAL_CHSIZE_A :: _6BIT) , 2 => Some (NORMAL_CHSIZE_A :: _7BIT) , 3 => Some (NORMAL_CHSIZE_A :: _8BIT) , 6 => Some (NORMAL_CHSIZE_A :: _9BITL) , 7 => Some (NORMAL_CHSIZE_A :: _9BITH) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BITL`"]
# [inline (always)]
pub fn is_9bitl (& self) -> bool { * self == NORMAL_CHSIZE_A :: _9BITL } # [doc = "Checks if the value of the field is `_9BITH`"]
# [inline (always)]
pub fn is_9bith (& self) -> bool { * self == NORMAL_CHSIZE_A :: _9BITH } } # [doc = "Field `NORMAL_CHSIZE` writer - Character Size"]
pub type NORMAL_CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > NORMAL_CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit read low byte first"]
# [inline (always)]
pub fn _9bitl (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _9BITL) } # [doc = "Character size: 9 bit read high byte first"]
# [inline (always)]
pub fn _9bith (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _9BITH) } } # [doc = "Field `MSPI_UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type MSPI_UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `MSPI_UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type MSPI_UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `MSPI_UDORD` reader - SPI Master Mode, Data Order"]
pub type MSPI_UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `MSPI_UDORD` writer - SPI Master Mode, Data Order"]
pub type MSPI_UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `NORMAL_SBMODE` reader - Stop Bit Mode"]
pub type NORMAL_SBMODE_R = crate :: BitReader < NORMAL_SBMODE_A > ; # [doc = "Stop Bit Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum NORMAL_SBMODE_A { # [doc = "0: 1 stop bit"]
_1BIT = 0 , # [doc = "1: 2 stop bits"]
_2BIT = 1 , } impl From < NORMAL_SBMODE_A > for bool { # [inline (always)]
fn from (variant : NORMAL_SBMODE_A) -> Self { variant as u8 != 0 } } impl NORMAL_SBMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NORMAL_SBMODE_A { match self . bits { false => NORMAL_SBMODE_A :: _1BIT , true => NORMAL_SBMODE_A :: _2BIT , } } # [doc = "Checks if the value of the field is `_1BIT`"]
# [inline (always)]
pub fn is_1bit (& self) -> bool { * self == NORMAL_SBMODE_A :: _1BIT } # [doc = "Checks if the value of the field is `_2BIT`"]
# [inline (always)]
pub fn is_2bit (& self) -> bool { * self == NORMAL_SBMODE_A :: _2BIT } } # [doc = "Field `NORMAL_SBMODE` writer - Stop Bit Mode"]
pub type NORMAL_SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , NORMAL_SBMODE_A , O > ; impl < 'a , const O : u8 > NORMAL_SBMODE_W < 'a , O > { # [doc = "1 stop bit"]
# [inline (always)]
pub fn _1bit (self) -> & 'a mut W { self . variant (NORMAL_SBMODE_A :: _1BIT) } # [doc = "2 stop bits"]
# [inline (always)]
pub fn _2bit (self) -> & 'a mut W { self . variant (NORMAL_SBMODE_A :: _2BIT) } } # [doc = "Field `NORMAL_PMODE` reader - Parity Mode"]
pub type NORMAL_PMODE_R = crate :: FieldReader < u8 , NORMAL_PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < NORMAL_PMODE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_PMODE_A) -> Self { variant as _ } } impl NORMAL_PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NORMAL_PMODE_A > { match self . bits { 0 => Some (NORMAL_PMODE_A :: DISABLED) , 2 => Some (NORMAL_PMODE_A :: EVEN) , 3 => Some (NORMAL_PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == NORMAL_PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == NORMAL_PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == NORMAL_PMODE_A :: ODD } } # [doc = "Field `NORMAL_PMODE` writer - Parity Mode"]
pub type NORMAL_PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_PMODE_A , 2 , O > ; impl < 'a , const O : u8 > NORMAL_PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: ODD) } } # [doc = "Field `MSPI_CMODE` reader - Communication Mode"]
pub type MSPI_CMODE_R = crate :: FieldReader < u8 , MSPI_CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MSPI_CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < MSPI_CMODE_A > for u8 { # [inline (always)]
fn from (variant : MSPI_CMODE_A) -> Self { variant as _ } } impl MSPI_CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MSPI_CMODE_A { match self . bits { 0 => MSPI_CMODE_A :: ASYNCHRONOUS , 1 => MSPI_CMODE_A :: SYNCHRONOUS , 2 => MSPI_CMODE_A :: IRCOM , 3 => MSPI_CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == MSPI_CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == MSPI_CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == MSPI_CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == MSPI_CMODE_A :: MSPI } } # [doc = "Field `MSPI_CMODE` writer - Communication Mode"]
pub type MSPI_CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , MSPI_CMODE_A , 2 , O > ; impl < 'a , const O : u8 > MSPI_CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: IRCOM) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: MSPI) } } # [doc = "Field `NORMAL_CMODE` reader - Communication Mode"]
pub type NORMAL_CMODE_R = crate :: FieldReader < u8 , NORMAL_CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < NORMAL_CMODE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_CMODE_A) -> Self { variant as _ } } impl NORMAL_CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NORMAL_CMODE_A { match self . bits { 0 => NORMAL_CMODE_A :: ASYNCHRONOUS , 1 => NORMAL_CMODE_A :: SYNCHRONOUS , 2 => NORMAL_CMODE_A :: IRCOM , 3 => NORMAL_CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == NORMAL_CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == NORMAL_CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == NORMAL_CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == NORMAL_CMODE_A :: MSPI } } # [doc = "Field `NORMAL_CMODE` writer - Communication Mode"]
pub type NORMAL_CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_CMODE_A , 2 , O > ; impl < 'a , const O : u8 > NORMAL_CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: IRCOM) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn normal_chsize (& self) -> NORMAL_CHSIZE_R { NORMAL_CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn mspi_ucpha (& self) -> MSPI_UCPHA_R { MSPI_UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn mspi_udord (& self) -> MSPI_UDORD_R { MSPI_UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn normal_sbmode (& self) -> NORMAL_SBMODE_R { NORMAL_SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn normal_pmode (& self) -> NORMAL_PMODE_R { NORMAL_PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn mspi_cmode (& self) -> MSPI_CMODE_R { MSPI_CMODE_R :: new ((self . bits >> 6) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn normal_cmode (& self) -> NORMAL_CMODE_R { NORMAL_CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn normal_chsize (& mut self) -> NORMAL_CHSIZE_W < 0 > { NORMAL_CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn mspi_ucpha (& mut self) -> MSPI_UCPHA_W < 1 > { MSPI_UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn mspi_udord (& mut self) -> MSPI_UDORD_W < 2 > { MSPI_UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn normal_sbmode (& mut self) -> NORMAL_SBMODE_W < 3 > { NORMAL_SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn normal_pmode (& mut self) -> NORMAL_PMODE_W < 4 > { NORMAL_PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mspi_cmode (& mut self) -> MSPI_CMODE_W < 6 > { MSPI_CMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn normal_cmode (& mut self) -> NORMAL_CMODE_W < 6 > { NORMAL_CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `ABW` reader - Auto Baud Window"]
pub type ABW_R = crate :: FieldReader < u8 , ABW_A > ; # [doc = "Auto Baud Window\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ABW_A { # [doc = "0: 18% tolerance"]
WDW0 = 0 , # [doc = "1: 15% tolerance"]
WDW1 = 1 , # [doc = "2: 21% tolerance"]
WDW2 = 2 , # [doc = "3: 25% tolerance"]
WDW3 = 3 , } impl From < ABW_A > for u8 { # [inline (always)]
fn from (variant : ABW_A) -> Self { variant as _ } } impl ABW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ABW_A { match self . bits { 0 => ABW_A :: WDW0 , 1 => ABW_A :: WDW1 , 2 => ABW_A :: WDW2 , 3 => ABW_A :: WDW3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `WDW0`"]
# [inline (always)]
pub fn is_wdw0 (& self) -> bool { * self == ABW_A :: WDW0 } # [doc = "Checks if the value of the field is `WDW1`"]
# [inline (always)]
pub fn is_wdw1 (& self) -> bool { * self == ABW_A :: WDW1 } # [doc = "Checks if the value of the field is `WDW2`"]
# [inline (always)]
pub fn is_wdw2 (& self) -> bool { * self == ABW_A :: WDW2 } # [doc = "Checks if the value of the field is `WDW3`"]
# [inline (always)]
pub fn is_wdw3 (& self) -> bool { * self == ABW_A :: WDW3 } } # [doc = "Field `ABW` writer - Auto Baud Window"]
pub type ABW_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLD_SPEC , u8 , ABW_A , 2 , O > ; impl < 'a , const O : u8 > ABW_W < 'a , O > { # [doc = "18% tolerance"]
# [inline (always)]
pub fn wdw0 (self) -> & 'a mut W { self . variant (ABW_A :: WDW0) } # [doc = "15% tolerance"]
# [inline (always)]
pub fn wdw1 (self) -> & 'a mut W { self . variant (ABW_A :: WDW1) } # [doc = "21% tolerance"]
# [inline (always)]
pub fn wdw2 (self) -> & 'a mut W { self . variant (ABW_A :: WDW2) } # [doc = "25% tolerance"]
# [inline (always)]
pub fn wdw3 (self) -> & 'a mut W { self . variant (ABW_A :: WDW3) } } impl R { # [doc = "Bits 6:7 - Auto Baud Window"]
# [inline (always)]
pub fn abw (& self) -> ABW_R { ABW_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 6:7 - Auto Baud Window"]
# [inline (always)]
# [must_use]
pub fn abw (& mut self) -> ABW_W < 6 > { ABW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; # [doc = "Field `ABMBP` reader - Autobaud majority voter bypass"]
pub type ABMBP_R = crate :: BitReader < bool > ; # [doc = "Field `ABMBP` writer - Autobaud majority voter bypass"]
pub type ABMBP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - Autobaud majority voter bypass"]
# [inline (always)]
pub fn abmbp (& self) -> ABMBP_R { ABMBP_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Bit 7 - Autobaud majority voter bypass"]
# [inline (always)]
# [must_use]
pub fn abmbp (& mut self) -> ABMBP_W < 7 > { ABMBP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `IREI` reader - IrDA Event Input Enable"]
pub type IREI_R = crate :: BitReader < bool > ; # [doc = "Field `IREI` writer - IrDA Event Input Enable"]
pub type IREI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
pub fn irei (& self) -> IREI_R { IREI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn irei (& mut self) -> IREI_W < 0 > { IREI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAH (r) register accessor: an alias for `Reg<RXDATAH_SPEC>`"]
pub type RXDATAH = crate :: Reg < rxdatah :: RXDATAH_SPEC > ; # [doc = "Receive Data High Byte"]
pub mod rxdatah { # [doc = "Register `RXDATAH` reader"]
pub struct R (crate :: R < RXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA8` reader - Receiver Data Register"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Receiver Data Register"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Receive Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatah](index.html) module"]
pub struct RXDATAH_SPEC ; impl crate :: RegisterSpec for RXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatah::R](R) reader structure"]
impl crate :: Readable for RXDATAH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAH to value 0"]
impl crate :: Resettable for RXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAL (r) register accessor: an alias for `Reg<RXDATAL_SPEC>`"]
pub type RXDATAL = crate :: Reg < rxdatal :: RXDATAL_SPEC > ; # [doc = "Receive Data Low Byte"]
pub mod rxdatal { # [doc = "Register `RXDATAL` reader"]
pub struct R (crate :: R < RXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA` reader - RX Data"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - RX Data"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } # [doc = "Receive Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatal](index.html) module"]
pub struct RXDATAL_SPEC ; impl crate :: RegisterSpec for RXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatal::R](R) reader structure"]
impl crate :: Readable for RXDATAL_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAL to value 0"]
impl crate :: Resettable for RXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXPLCTRL (rw) register accessor: an alias for `Reg<RXPLCTRL_SPEC>`"]
pub type RXPLCTRL = crate :: Reg < rxplctrl :: RXPLCTRL_SPEC > ; # [doc = "IRCOM Receiver Pulse Length Control"]
pub mod rxplctrl { # [doc = "Register `RXPLCTRL` reader"]
pub struct R (crate :: R < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXPLCTRL` writer"]
pub struct W (crate :: W < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXPL` reader - Receiver Pulse Lenght"]
pub type RXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RXPL` writer - Receiver Pulse Lenght"]
pub type RXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , RXPLCTRL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
pub fn rxpl (& self) -> RXPL_R { RXPL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
# [must_use]
pub fn rxpl (& mut self) -> RXPL_W < 0 > { RXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "IRCOM Receiver Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxplctrl](index.html) module"]
pub struct RXPLCTRL_SPEC ; impl crate :: RegisterSpec for RXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxplctrl::R](R) reader structure"]
impl crate :: Readable for RXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxplctrl::W](W) writer structure"]
impl crate :: Writable for RXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXPLCTRL to value 0"]
impl crate :: Resettable for RXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WFB` reader - Wait For Break"]
pub type WFB_R = crate :: BitReader < bool > ; # [doc = "Field `WFB` writer - Wait For Break"]
pub type WFB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BDF` reader - Break Detected Flag"]
pub type BDF_R = crate :: BitReader < bool > ; # [doc = "Field `BDF` writer - Break Detected Flag"]
pub type BDF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `ISFIF` reader - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_R = crate :: BitReader < bool > ; # [doc = "Field `ISFIF` writer - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXSIF` reader - Receive Start Interrupt"]
pub type RXSIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
pub fn wfb (& self) -> WFB_R { WFB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
pub fn bdf (& self) -> BDF_R { BDF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
pub fn isfif (& self) -> ISFIF_R { ISFIF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receive Start Interrupt"]
# [inline (always)]
pub fn rxsif (& self) -> RXSIF_R { RXSIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
# [must_use]
pub fn wfb (& mut self) -> WFB_W < 0 > { WFB_W :: new (self) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
# [must_use]
pub fn bdf (& mut self) -> BDF_W < 1 > { BDF_W :: new (self) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn isfif (& mut self) -> ISFIF_W < 3 > { ISFIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAH (rw) register accessor: an alias for `Reg<TXDATAH_SPEC>`"]
pub type TXDATAH = crate :: Reg < txdatah :: TXDATAH_SPEC > ; # [doc = "Transmit Data High Byte"]
pub mod txdatah { # [doc = "Register `TXDATAH` reader"]
pub struct R (crate :: R < TXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAH` writer"]
pub struct W (crate :: W < TXDATAH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAH_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA8` reader - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `DATA8` writer - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TXDATAH_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
# [must_use]
pub fn data8 (& mut self) -> DATA8_W < 0 > { DATA8_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transmit Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatah](index.html) module"]
pub struct TXDATAH_SPEC ; impl crate :: RegisterSpec for TXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatah::R](R) reader structure"]
impl crate :: Readable for TXDATAH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatah::W](W) writer structure"]
impl crate :: Writable for TXDATAH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAH to value 0"]
impl crate :: Resettable for TXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAL (rw) register accessor: an alias for `Reg<TXDATAL_SPEC>`"]
pub type TXDATAL = crate :: Reg < txdatal :: TXDATAL_SPEC > ; # [doc = "Transmit Data Low Byte"]
pub mod txdatal { # [doc = "Register `TXDATAL` reader"]
pub struct R (crate :: R < TXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAL` writer"]
pub struct W (crate :: W < TXDATAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Transmit Data Register"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DATA` writer - Transmit Data Register"]
pub type DATA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXDATAL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
# [must_use]
pub fn data (& mut self) -> DATA_W < 0 > { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transmit Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatal](index.html) module"]
pub struct TXDATAL_SPEC ; impl crate :: RegisterSpec for TXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatal::R](R) reader structure"]
impl crate :: Readable for TXDATAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatal::W](W) writer structure"]
impl crate :: Writable for TXDATAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAL to value 0"]
impl crate :: Resettable for TXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXPLCTRL (rw) register accessor: an alias for `Reg<TXPLCTRL_SPEC>`"]
pub type TXPLCTRL = crate :: Reg < txplctrl :: TXPLCTRL_SPEC > ; # [doc = "IRCOM Transmitter Pulse Length Control"]
pub mod txplctrl { # [doc = "Register `TXPLCTRL` reader"]
pub struct R (crate :: R < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXPLCTRL` writer"]
pub struct W (crate :: W < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXPL` reader - Transmit pulse length"]
pub type TXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TXPL` writer - Transmit pulse length"]
pub type TXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXPLCTRL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
pub fn txpl (& self) -> TXPL_R { TXPL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
# [must_use]
pub fn txpl (& mut self) -> TXPL_W < 0 > { TXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "IRCOM Transmitter Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txplctrl](index.html) module"]
pub struct TXPLCTRL_SPEC ; impl crate :: RegisterSpec for TXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txplctrl::R](R) reader structure"]
impl crate :: Readable for TXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txplctrl::W](W) writer structure"]
impl crate :: Writable for TXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXPLCTRL to value 0"]
impl crate :: Resettable for TXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub struct USART1 { _marker : PhantomData < * const () > } unsafe impl Send for USART1 { } impl USART1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart1 :: RegisterBlock = 0x0820 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart1 :: RegisterBlock { Self :: PTR } } impl Deref for USART1 { type Target = usart1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART1") . finish () } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub mod usart1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Receive Data Low Byte"]
pub rxdatal : RXDATAL , # [doc = "0x01 - Receive Data High Byte"]
pub rxdatah : RXDATAH , # [doc = "0x02 - Transmit Data Low Byte"]
pub txdatal : TXDATAL , # [doc = "0x03 - Transmit Data High Byte"]
pub txdatah : TXDATAH , # [doc = "0x04 - Status"]
pub status : STATUS , # [doc = "0x05 - Control A"]
pub ctrla : CTRLA , # [doc = "0x06 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x07 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x08 - Baud Rate"]
pub baud : BAUD , # [doc = "0x0a - Control D"]
pub ctrld : CTRLD , # [doc = "0x0b - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x0c - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x0d - IRCOM Transmitter Pulse Length Control"]
pub txplctrl : TXPLCTRL , # [doc = "0x0e - IRCOM Receiver Pulse Length Control"]
pub rxplctrl : RXPLCTRL , } # [doc = "BAUD (rw) register accessor: an alias for `Reg<BAUD_SPEC>`"]
pub type BAUD = crate :: Reg < baud :: BAUD_SPEC > ; # [doc = "Baud Rate"]
pub mod baud { # [doc = "Register `BAUD` reader"]
pub struct R (crate :: R < BAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD` writer"]
pub struct W (crate :: W < BAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud](index.html) module"]
pub struct BAUD_SPEC ; impl crate :: RegisterSpec for BAUD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud::R](R) reader structure"]
impl crate :: Readable for BAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud::W](W) writer structure"]
impl crate :: Writable for BAUD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUD to value 0"]
impl crate :: Resettable for BAUD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RS485` reader - RS485 Mode internal transmitter"]
pub type RS485_R = crate :: FieldReader < u8 , RS485_A > ; # [doc = "RS485 Mode internal transmitter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RS485_A { # [doc = "0: RS485 Mode disabled"]
OFF = 0 , # [doc = "1: RS485 Mode External drive"]
EXT = 1 , # [doc = "2: RS485 Mode Internal drive"]
INT = 2 , } impl From < RS485_A > for u8 { # [inline (always)]
fn from (variant : RS485_A) -> Self { variant as _ } } impl RS485_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RS485_A > { match self . bits { 0 => Some (RS485_A :: OFF) , 1 => Some (RS485_A :: EXT) , 2 => Some (RS485_A :: INT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RS485_A :: OFF } # [doc = "Checks if the value of the field is `EXT`"]
# [inline (always)]
pub fn is_ext (& self) -> bool { * self == RS485_A :: EXT } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == RS485_A :: INT } } # [doc = "Field `RS485` writer - RS485 Mode internal transmitter"]
pub type RS485_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , RS485_A , 2 , O > ; impl < 'a , const O : u8 > RS485_W < 'a , O > { # [doc = "RS485 Mode disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RS485_A :: OFF) } # [doc = "RS485 Mode External drive"]
# [inline (always)]
pub fn ext (self) -> & 'a mut W { self . variant (RS485_A :: EXT) } # [doc = "RS485 Mode Internal drive"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (RS485_A :: INT) } } # [doc = "Field `ABEIE` reader - Auto-baud Error Interrupt Enable"]
pub type ABEIE_R = crate :: BitReader < bool > ; # [doc = "Field `ABEIE` writer - Auto-baud Error Interrupt Enable"]
pub type ABEIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `LBME` reader - Loop-back Mode Enable"]
pub type LBME_R = crate :: BitReader < bool > ; # [doc = "Field `LBME` writer - Loop-back Mode Enable"]
pub type LBME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXSIE` reader - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXSIE` writer - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DREIE` reader - Data Register Empty Interrupt Enable"]
pub type DREIE_R = crate :: BitReader < bool > ; # [doc = "Field `DREIE` writer - Data Register Empty Interrupt Enable"]
pub type DREIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `TXCIE` reader - Transmit Complete Interrupt Enable"]
pub type TXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE` writer - Transmit Complete Interrupt Enable"]
pub type TXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXCIE` reader - Receive Complete Interrupt Enable"]
pub type RXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE` writer - Receive Complete Interrupt Enable"]
pub type RXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
pub fn rs485 (& self) -> RS485_R { RS485_R :: new (self . bits & 3) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
pub fn abeie (& self) -> ABEIE_R { ABEIE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
pub fn lbme (& self) -> LBME_R { LBME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
pub fn rxsie (& self) -> RXSIE_R { RXSIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dreie (& self) -> DREIE_R { DREIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie (& self) -> TXCIE_R { TXCIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie (& self) -> RXCIE_R { RXCIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
# [must_use]
pub fn rs485 (& mut self) -> RS485_W < 0 > { RS485_W :: new (self) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn abeie (& mut self) -> ABEIE_W < 2 > { ABEIE_W :: new (self) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
# [must_use]
pub fn lbme (& mut self) -> LBME_W < 3 > { LBME_W :: new (self) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxsie (& mut self) -> RXSIE_W < 4 > { RXSIE_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dreie (& mut self) -> DREIE_W < 5 > { DREIE_W :: new (self) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie (& mut self) -> TXCIE_W < 6 > { TXCIE_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie (& mut self) -> RXCIE_W < 7 > { RXCIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXMODE` reader - Receiver Mode"]
pub type RXMODE_R = crate :: FieldReader < u8 , RXMODE_A > ; # [doc = "Receiver Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXMODE_A { # [doc = "0: Normal mode"]
NORMAL = 0 , # [doc = "1: CLK2x mode"]
CLK2X = 1 , # [doc = "2: Generic autobaud mode"]
GENAUTO = 2 , # [doc = "3: LIN constrained autobaud mode"]
LINAUTO = 3 , } impl From < RXMODE_A > for u8 { # [inline (always)]
fn from (variant : RXMODE_A) -> Self { variant as _ } } impl RXMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXMODE_A { match self . bits { 0 => RXMODE_A :: NORMAL , 1 => RXMODE_A :: CLK2X , 2 => RXMODE_A :: GENAUTO , 3 => RXMODE_A :: LINAUTO , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == RXMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `CLK2X`"]
# [inline (always)]
pub fn is_clk2x (& self) -> bool { * self == RXMODE_A :: CLK2X } # [doc = "Checks if the value of the field is `GENAUTO`"]
# [inline (always)]
pub fn is_genauto (& self) -> bool { * self == RXMODE_A :: GENAUTO } # [doc = "Checks if the value of the field is `LINAUTO`"]
# [inline (always)]
pub fn is_linauto (& self) -> bool { * self == RXMODE_A :: LINAUTO } } # [doc = "Field `RXMODE` writer - Receiver Mode"]
pub type RXMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , RXMODE_A , 2 , O > ; impl < 'a , const O : u8 > RXMODE_W < 'a , O > { # [doc = "Normal mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (RXMODE_A :: NORMAL) } # [doc = "CLK2x mode"]
# [inline (always)]
pub fn clk2x (self) -> & 'a mut W { self . variant (RXMODE_A :: CLK2X) } # [doc = "Generic autobaud mode"]
# [inline (always)]
pub fn genauto (self) -> & 'a mut W { self . variant (RXMODE_A :: GENAUTO) } # [doc = "LIN constrained autobaud mode"]
# [inline (always)]
pub fn linauto (self) -> & 'a mut W { self . variant (RXMODE_A :: LINAUTO) } } # [doc = "Field `ODME` reader - Open Drain Mode Enable"]
pub type ODME_R = crate :: BitReader < bool > ; # [doc = "Field `ODME` writer - Open Drain Mode Enable"]
pub type ODME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `SFDEN` reader - Start Frame Detection Enable"]
pub type SFDEN_R = crate :: BitReader < bool > ; # [doc = "Field `SFDEN` writer - Start Frame Detection Enable"]
pub type SFDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Reciever enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Reciever enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
pub fn rxmode (& self) -> RXMODE_R { RXMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
pub fn odme (& self) -> ODME_R { ODME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
pub fn sfden (& self) -> SFDEN_R { SFDEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 0 > { MPCM_W :: new (self) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
# [must_use]
pub fn rxmode (& mut self) -> RXMODE_W < 1 > { RXMODE_W :: new (self) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
# [must_use]
pub fn odme (& mut self) -> ODME_W < 3 > { ODME_W :: new (self) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
# [must_use]
pub fn sfden (& mut self) -> SFDEN_W < 4 > { SFDEN_W :: new (self) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 6 > { TXEN_W :: new (self) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 7 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `NORMAL_CHSIZE` reader - Character Size"]
pub type NORMAL_CHSIZE_R = crate :: FieldReader < u8 , NORMAL_CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "6: Character size: 9 bit read low byte first"]
_9BITL = 6 , # [doc = "7: Character size: 9 bit read high byte first"]
_9BITH = 7 , } impl From < NORMAL_CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_CHSIZE_A) -> Self { variant as _ } } impl NORMAL_CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NORMAL_CHSIZE_A > { match self . bits { 0 => Some (NORMAL_CHSIZE_A :: _5BIT) , 1 => Some (NORMAL_CHSIZE_A :: _6BIT) , 2 => Some (NORMAL_CHSIZE_A :: _7BIT) , 3 => Some (NORMAL_CHSIZE_A :: _8BIT) , 6 => Some (NORMAL_CHSIZE_A :: _9BITL) , 7 => Some (NORMAL_CHSIZE_A :: _9BITH) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BITL`"]
# [inline (always)]
pub fn is_9bitl (& self) -> bool { * self == NORMAL_CHSIZE_A :: _9BITL } # [doc = "Checks if the value of the field is `_9BITH`"]
# [inline (always)]
pub fn is_9bith (& self) -> bool { * self == NORMAL_CHSIZE_A :: _9BITH } } # [doc = "Field `NORMAL_CHSIZE` writer - Character Size"]
pub type NORMAL_CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > NORMAL_CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit read low byte first"]
# [inline (always)]
pub fn _9bitl (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _9BITL) } # [doc = "Character size: 9 bit read high byte first"]
# [inline (always)]
pub fn _9bith (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _9BITH) } } # [doc = "Field `MSPI_UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type MSPI_UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `MSPI_UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type MSPI_UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `MSPI_UDORD` reader - SPI Master Mode, Data Order"]
pub type MSPI_UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `MSPI_UDORD` writer - SPI Master Mode, Data Order"]
pub type MSPI_UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `NORMAL_SBMODE` reader - Stop Bit Mode"]
pub type NORMAL_SBMODE_R = crate :: BitReader < NORMAL_SBMODE_A > ; # [doc = "Stop Bit Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum NORMAL_SBMODE_A { # [doc = "0: 1 stop bit"]
_1BIT = 0 , # [doc = "1: 2 stop bits"]
_2BIT = 1 , } impl From < NORMAL_SBMODE_A > for bool { # [inline (always)]
fn from (variant : NORMAL_SBMODE_A) -> Self { variant as u8 != 0 } } impl NORMAL_SBMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NORMAL_SBMODE_A { match self . bits { false => NORMAL_SBMODE_A :: _1BIT , true => NORMAL_SBMODE_A :: _2BIT , } } # [doc = "Checks if the value of the field is `_1BIT`"]
# [inline (always)]
pub fn is_1bit (& self) -> bool { * self == NORMAL_SBMODE_A :: _1BIT } # [doc = "Checks if the value of the field is `_2BIT`"]
# [inline (always)]
pub fn is_2bit (& self) -> bool { * self == NORMAL_SBMODE_A :: _2BIT } } # [doc = "Field `NORMAL_SBMODE` writer - Stop Bit Mode"]
pub type NORMAL_SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , NORMAL_SBMODE_A , O > ; impl < 'a , const O : u8 > NORMAL_SBMODE_W < 'a , O > { # [doc = "1 stop bit"]
# [inline (always)]
pub fn _1bit (self) -> & 'a mut W { self . variant (NORMAL_SBMODE_A :: _1BIT) } # [doc = "2 stop bits"]
# [inline (always)]
pub fn _2bit (self) -> & 'a mut W { self . variant (NORMAL_SBMODE_A :: _2BIT) } } # [doc = "Field `NORMAL_PMODE` reader - Parity Mode"]
pub type NORMAL_PMODE_R = crate :: FieldReader < u8 , NORMAL_PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < NORMAL_PMODE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_PMODE_A) -> Self { variant as _ } } impl NORMAL_PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NORMAL_PMODE_A > { match self . bits { 0 => Some (NORMAL_PMODE_A :: DISABLED) , 2 => Some (NORMAL_PMODE_A :: EVEN) , 3 => Some (NORMAL_PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == NORMAL_PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == NORMAL_PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == NORMAL_PMODE_A :: ODD } } # [doc = "Field `NORMAL_PMODE` writer - Parity Mode"]
pub type NORMAL_PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_PMODE_A , 2 , O > ; impl < 'a , const O : u8 > NORMAL_PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: ODD) } } # [doc = "Field `MSPI_CMODE` reader - Communication Mode"]
pub type MSPI_CMODE_R = crate :: FieldReader < u8 , MSPI_CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MSPI_CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < MSPI_CMODE_A > for u8 { # [inline (always)]
fn from (variant : MSPI_CMODE_A) -> Self { variant as _ } } impl MSPI_CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MSPI_CMODE_A { match self . bits { 0 => MSPI_CMODE_A :: ASYNCHRONOUS , 1 => MSPI_CMODE_A :: SYNCHRONOUS , 2 => MSPI_CMODE_A :: IRCOM , 3 => MSPI_CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == MSPI_CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == MSPI_CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == MSPI_CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == MSPI_CMODE_A :: MSPI } } # [doc = "Field `MSPI_CMODE` writer - Communication Mode"]
pub type MSPI_CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , MSPI_CMODE_A , 2 , O > ; impl < 'a , const O : u8 > MSPI_CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: IRCOM) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: MSPI) } } # [doc = "Field `NORMAL_CMODE` reader - Communication Mode"]
pub type NORMAL_CMODE_R = crate :: FieldReader < u8 , NORMAL_CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < NORMAL_CMODE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_CMODE_A) -> Self { variant as _ } } impl NORMAL_CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NORMAL_CMODE_A { match self . bits { 0 => NORMAL_CMODE_A :: ASYNCHRONOUS , 1 => NORMAL_CMODE_A :: SYNCHRONOUS , 2 => NORMAL_CMODE_A :: IRCOM , 3 => NORMAL_CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == NORMAL_CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == NORMAL_CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == NORMAL_CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == NORMAL_CMODE_A :: MSPI } } # [doc = "Field `NORMAL_CMODE` writer - Communication Mode"]
pub type NORMAL_CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_CMODE_A , 2 , O > ; impl < 'a , const O : u8 > NORMAL_CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: IRCOM) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn normal_chsize (& self) -> NORMAL_CHSIZE_R { NORMAL_CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn mspi_ucpha (& self) -> MSPI_UCPHA_R { MSPI_UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn mspi_udord (& self) -> MSPI_UDORD_R { MSPI_UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn normal_sbmode (& self) -> NORMAL_SBMODE_R { NORMAL_SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn normal_pmode (& self) -> NORMAL_PMODE_R { NORMAL_PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn mspi_cmode (& self) -> MSPI_CMODE_R { MSPI_CMODE_R :: new ((self . bits >> 6) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn normal_cmode (& self) -> NORMAL_CMODE_R { NORMAL_CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn normal_chsize (& mut self) -> NORMAL_CHSIZE_W < 0 > { NORMAL_CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn mspi_ucpha (& mut self) -> MSPI_UCPHA_W < 1 > { MSPI_UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn mspi_udord (& mut self) -> MSPI_UDORD_W < 2 > { MSPI_UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn normal_sbmode (& mut self) -> NORMAL_SBMODE_W < 3 > { NORMAL_SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn normal_pmode (& mut self) -> NORMAL_PMODE_W < 4 > { NORMAL_PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mspi_cmode (& mut self) -> MSPI_CMODE_W < 6 > { MSPI_CMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn normal_cmode (& mut self) -> NORMAL_CMODE_W < 6 > { NORMAL_CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `ABW` reader - Auto Baud Window"]
pub type ABW_R = crate :: FieldReader < u8 , ABW_A > ; # [doc = "Auto Baud Window\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ABW_A { # [doc = "0: 18% tolerance"]
WDW0 = 0 , # [doc = "1: 15% tolerance"]
WDW1 = 1 , # [doc = "2: 21% tolerance"]
WDW2 = 2 , # [doc = "3: 25% tolerance"]
WDW3 = 3 , } impl From < ABW_A > for u8 { # [inline (always)]
fn from (variant : ABW_A) -> Self { variant as _ } } impl ABW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ABW_A { match self . bits { 0 => ABW_A :: WDW0 , 1 => ABW_A :: WDW1 , 2 => ABW_A :: WDW2 , 3 => ABW_A :: WDW3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `WDW0`"]
# [inline (always)]
pub fn is_wdw0 (& self) -> bool { * self == ABW_A :: WDW0 } # [doc = "Checks if the value of the field is `WDW1`"]
# [inline (always)]
pub fn is_wdw1 (& self) -> bool { * self == ABW_A :: WDW1 } # [doc = "Checks if the value of the field is `WDW2`"]
# [inline (always)]
pub fn is_wdw2 (& self) -> bool { * self == ABW_A :: WDW2 } # [doc = "Checks if the value of the field is `WDW3`"]
# [inline (always)]
pub fn is_wdw3 (& self) -> bool { * self == ABW_A :: WDW3 } } # [doc = "Field `ABW` writer - Auto Baud Window"]
pub type ABW_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLD_SPEC , u8 , ABW_A , 2 , O > ; impl < 'a , const O : u8 > ABW_W < 'a , O > { # [doc = "18% tolerance"]
# [inline (always)]
pub fn wdw0 (self) -> & 'a mut W { self . variant (ABW_A :: WDW0) } # [doc = "15% tolerance"]
# [inline (always)]
pub fn wdw1 (self) -> & 'a mut W { self . variant (ABW_A :: WDW1) } # [doc = "21% tolerance"]
# [inline (always)]
pub fn wdw2 (self) -> & 'a mut W { self . variant (ABW_A :: WDW2) } # [doc = "25% tolerance"]
# [inline (always)]
pub fn wdw3 (self) -> & 'a mut W { self . variant (ABW_A :: WDW3) } } impl R { # [doc = "Bits 6:7 - Auto Baud Window"]
# [inline (always)]
pub fn abw (& self) -> ABW_R { ABW_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 6:7 - Auto Baud Window"]
# [inline (always)]
# [must_use]
pub fn abw (& mut self) -> ABW_W < 6 > { ABW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; # [doc = "Field `ABMBP` reader - Autobaud majority voter bypass"]
pub type ABMBP_R = crate :: BitReader < bool > ; # [doc = "Field `ABMBP` writer - Autobaud majority voter bypass"]
pub type ABMBP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - Autobaud majority voter bypass"]
# [inline (always)]
pub fn abmbp (& self) -> ABMBP_R { ABMBP_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Bit 7 - Autobaud majority voter bypass"]
# [inline (always)]
# [must_use]
pub fn abmbp (& mut self) -> ABMBP_W < 7 > { ABMBP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `IREI` reader - IrDA Event Input Enable"]
pub type IREI_R = crate :: BitReader < bool > ; # [doc = "Field `IREI` writer - IrDA Event Input Enable"]
pub type IREI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
pub fn irei (& self) -> IREI_R { IREI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn irei (& mut self) -> IREI_W < 0 > { IREI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAH (r) register accessor: an alias for `Reg<RXDATAH_SPEC>`"]
pub type RXDATAH = crate :: Reg < rxdatah :: RXDATAH_SPEC > ; # [doc = "Receive Data High Byte"]
pub mod rxdatah { # [doc = "Register `RXDATAH` reader"]
pub struct R (crate :: R < RXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA8` reader - Receiver Data Register"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Receiver Data Register"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Receive Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatah](index.html) module"]
pub struct RXDATAH_SPEC ; impl crate :: RegisterSpec for RXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatah::R](R) reader structure"]
impl crate :: Readable for RXDATAH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAH to value 0"]
impl crate :: Resettable for RXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAL (r) register accessor: an alias for `Reg<RXDATAL_SPEC>`"]
pub type RXDATAL = crate :: Reg < rxdatal :: RXDATAL_SPEC > ; # [doc = "Receive Data Low Byte"]
pub mod rxdatal { # [doc = "Register `RXDATAL` reader"]
pub struct R (crate :: R < RXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA` reader - RX Data"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - RX Data"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } # [doc = "Receive Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatal](index.html) module"]
pub struct RXDATAL_SPEC ; impl crate :: RegisterSpec for RXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatal::R](R) reader structure"]
impl crate :: Readable for RXDATAL_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAL to value 0"]
impl crate :: Resettable for RXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXPLCTRL (rw) register accessor: an alias for `Reg<RXPLCTRL_SPEC>`"]
pub type RXPLCTRL = crate :: Reg < rxplctrl :: RXPLCTRL_SPEC > ; # [doc = "IRCOM Receiver Pulse Length Control"]
pub mod rxplctrl { # [doc = "Register `RXPLCTRL` reader"]
pub struct R (crate :: R < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXPLCTRL` writer"]
pub struct W (crate :: W < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXPL` reader - Receiver Pulse Lenght"]
pub type RXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RXPL` writer - Receiver Pulse Lenght"]
pub type RXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , RXPLCTRL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
pub fn rxpl (& self) -> RXPL_R { RXPL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
# [must_use]
pub fn rxpl (& mut self) -> RXPL_W < 0 > { RXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "IRCOM Receiver Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxplctrl](index.html) module"]
pub struct RXPLCTRL_SPEC ; impl crate :: RegisterSpec for RXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxplctrl::R](R) reader structure"]
impl crate :: Readable for RXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxplctrl::W](W) writer structure"]
impl crate :: Writable for RXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXPLCTRL to value 0"]
impl crate :: Resettable for RXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WFB` reader - Wait For Break"]
pub type WFB_R = crate :: BitReader < bool > ; # [doc = "Field `WFB` writer - Wait For Break"]
pub type WFB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BDF` reader - Break Detected Flag"]
pub type BDF_R = crate :: BitReader < bool > ; # [doc = "Field `BDF` writer - Break Detected Flag"]
pub type BDF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `ISFIF` reader - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_R = crate :: BitReader < bool > ; # [doc = "Field `ISFIF` writer - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXSIF` reader - Receive Start Interrupt"]
pub type RXSIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
pub fn wfb (& self) -> WFB_R { WFB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
pub fn bdf (& self) -> BDF_R { BDF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
pub fn isfif (& self) -> ISFIF_R { ISFIF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receive Start Interrupt"]
# [inline (always)]
pub fn rxsif (& self) -> RXSIF_R { RXSIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
# [must_use]
pub fn wfb (& mut self) -> WFB_W < 0 > { WFB_W :: new (self) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
# [must_use]
pub fn bdf (& mut self) -> BDF_W < 1 > { BDF_W :: new (self) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn isfif (& mut self) -> ISFIF_W < 3 > { ISFIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAH (rw) register accessor: an alias for `Reg<TXDATAH_SPEC>`"]
pub type TXDATAH = crate :: Reg < txdatah :: TXDATAH_SPEC > ; # [doc = "Transmit Data High Byte"]
pub mod txdatah { # [doc = "Register `TXDATAH` reader"]
pub struct R (crate :: R < TXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAH` writer"]
pub struct W (crate :: W < TXDATAH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAH_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA8` reader - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `DATA8` writer - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TXDATAH_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
# [must_use]
pub fn data8 (& mut self) -> DATA8_W < 0 > { DATA8_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transmit Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatah](index.html) module"]
pub struct TXDATAH_SPEC ; impl crate :: RegisterSpec for TXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatah::R](R) reader structure"]
impl crate :: Readable for TXDATAH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatah::W](W) writer structure"]
impl crate :: Writable for TXDATAH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAH to value 0"]
impl crate :: Resettable for TXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAL (rw) register accessor: an alias for `Reg<TXDATAL_SPEC>`"]
pub type TXDATAL = crate :: Reg < txdatal :: TXDATAL_SPEC > ; # [doc = "Transmit Data Low Byte"]
pub mod txdatal { # [doc = "Register `TXDATAL` reader"]
pub struct R (crate :: R < TXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAL` writer"]
pub struct W (crate :: W < TXDATAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Transmit Data Register"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DATA` writer - Transmit Data Register"]
pub type DATA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXDATAL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
# [must_use]
pub fn data (& mut self) -> DATA_W < 0 > { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transmit Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatal](index.html) module"]
pub struct TXDATAL_SPEC ; impl crate :: RegisterSpec for TXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatal::R](R) reader structure"]
impl crate :: Readable for TXDATAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatal::W](W) writer structure"]
impl crate :: Writable for TXDATAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAL to value 0"]
impl crate :: Resettable for TXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXPLCTRL (rw) register accessor: an alias for `Reg<TXPLCTRL_SPEC>`"]
pub type TXPLCTRL = crate :: Reg < txplctrl :: TXPLCTRL_SPEC > ; # [doc = "IRCOM Transmitter Pulse Length Control"]
pub mod txplctrl { # [doc = "Register `TXPLCTRL` reader"]
pub struct R (crate :: R < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXPLCTRL` writer"]
pub struct W (crate :: W < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXPL` reader - Transmit pulse length"]
pub type TXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TXPL` writer - Transmit pulse length"]
pub type TXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXPLCTRL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
pub fn txpl (& self) -> TXPL_R { TXPL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
# [must_use]
pub fn txpl (& mut self) -> TXPL_W < 0 > { TXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "IRCOM Transmitter Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txplctrl](index.html) module"]
pub struct TXPLCTRL_SPEC ; impl crate :: RegisterSpec for TXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txplctrl::R](R) reader structure"]
impl crate :: Readable for TXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txplctrl::W](W) writer structure"]
impl crate :: Writable for TXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXPLCTRL to value 0"]
impl crate :: Resettable for TXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub struct USART2 { _marker : PhantomData < * const () > } unsafe impl Send for USART2 { } impl USART2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart2 :: RegisterBlock = 0x0840 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart2 :: RegisterBlock { Self :: PTR } } impl Deref for USART2 { type Target = usart2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART2") . finish () } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub mod usart2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Receive Data Low Byte"]
pub rxdatal : RXDATAL , # [doc = "0x01 - Receive Data High Byte"]
pub rxdatah : RXDATAH , # [doc = "0x02 - Transmit Data Low Byte"]
pub txdatal : TXDATAL , # [doc = "0x03 - Transmit Data High Byte"]
pub txdatah : TXDATAH , # [doc = "0x04 - Status"]
pub status : STATUS , # [doc = "0x05 - Control A"]
pub ctrla : CTRLA , # [doc = "0x06 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x07 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x08 - Baud Rate"]
pub baud : BAUD , # [doc = "0x0a - Control D"]
pub ctrld : CTRLD , # [doc = "0x0b - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x0c - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x0d - IRCOM Transmitter Pulse Length Control"]
pub txplctrl : TXPLCTRL , # [doc = "0x0e - IRCOM Receiver Pulse Length Control"]
pub rxplctrl : RXPLCTRL , } # [doc = "BAUD (rw) register accessor: an alias for `Reg<BAUD_SPEC>`"]
pub type BAUD = crate :: Reg < baud :: BAUD_SPEC > ; # [doc = "Baud Rate"]
pub mod baud { # [doc = "Register `BAUD` reader"]
pub struct R (crate :: R < BAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD` writer"]
pub struct W (crate :: W < BAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud](index.html) module"]
pub struct BAUD_SPEC ; impl crate :: RegisterSpec for BAUD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud::R](R) reader structure"]
impl crate :: Readable for BAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud::W](W) writer structure"]
impl crate :: Writable for BAUD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUD to value 0"]
impl crate :: Resettable for BAUD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RS485` reader - RS485 Mode internal transmitter"]
pub type RS485_R = crate :: FieldReader < u8 , RS485_A > ; # [doc = "RS485 Mode internal transmitter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RS485_A { # [doc = "0: RS485 Mode disabled"]
OFF = 0 , # [doc = "1: RS485 Mode External drive"]
EXT = 1 , # [doc = "2: RS485 Mode Internal drive"]
INT = 2 , } impl From < RS485_A > for u8 { # [inline (always)]
fn from (variant : RS485_A) -> Self { variant as _ } } impl RS485_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RS485_A > { match self . bits { 0 => Some (RS485_A :: OFF) , 1 => Some (RS485_A :: EXT) , 2 => Some (RS485_A :: INT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RS485_A :: OFF } # [doc = "Checks if the value of the field is `EXT`"]
# [inline (always)]
pub fn is_ext (& self) -> bool { * self == RS485_A :: EXT } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == RS485_A :: INT } } # [doc = "Field `RS485` writer - RS485 Mode internal transmitter"]
pub type RS485_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , RS485_A , 2 , O > ; impl < 'a , const O : u8 > RS485_W < 'a , O > { # [doc = "RS485 Mode disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RS485_A :: OFF) } # [doc = "RS485 Mode External drive"]
# [inline (always)]
pub fn ext (self) -> & 'a mut W { self . variant (RS485_A :: EXT) } # [doc = "RS485 Mode Internal drive"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (RS485_A :: INT) } } # [doc = "Field `ABEIE` reader - Auto-baud Error Interrupt Enable"]
pub type ABEIE_R = crate :: BitReader < bool > ; # [doc = "Field `ABEIE` writer - Auto-baud Error Interrupt Enable"]
pub type ABEIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `LBME` reader - Loop-back Mode Enable"]
pub type LBME_R = crate :: BitReader < bool > ; # [doc = "Field `LBME` writer - Loop-back Mode Enable"]
pub type LBME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXSIE` reader - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXSIE` writer - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DREIE` reader - Data Register Empty Interrupt Enable"]
pub type DREIE_R = crate :: BitReader < bool > ; # [doc = "Field `DREIE` writer - Data Register Empty Interrupt Enable"]
pub type DREIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `TXCIE` reader - Transmit Complete Interrupt Enable"]
pub type TXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE` writer - Transmit Complete Interrupt Enable"]
pub type TXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXCIE` reader - Receive Complete Interrupt Enable"]
pub type RXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE` writer - Receive Complete Interrupt Enable"]
pub type RXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
pub fn rs485 (& self) -> RS485_R { RS485_R :: new (self . bits & 3) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
pub fn abeie (& self) -> ABEIE_R { ABEIE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
pub fn lbme (& self) -> LBME_R { LBME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
pub fn rxsie (& self) -> RXSIE_R { RXSIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dreie (& self) -> DREIE_R { DREIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie (& self) -> TXCIE_R { TXCIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie (& self) -> RXCIE_R { RXCIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
# [must_use]
pub fn rs485 (& mut self) -> RS485_W < 0 > { RS485_W :: new (self) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn abeie (& mut self) -> ABEIE_W < 2 > { ABEIE_W :: new (self) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
# [must_use]
pub fn lbme (& mut self) -> LBME_W < 3 > { LBME_W :: new (self) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxsie (& mut self) -> RXSIE_W < 4 > { RXSIE_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dreie (& mut self) -> DREIE_W < 5 > { DREIE_W :: new (self) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie (& mut self) -> TXCIE_W < 6 > { TXCIE_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie (& mut self) -> RXCIE_W < 7 > { RXCIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXMODE` reader - Receiver Mode"]
pub type RXMODE_R = crate :: FieldReader < u8 , RXMODE_A > ; # [doc = "Receiver Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXMODE_A { # [doc = "0: Normal mode"]
NORMAL = 0 , # [doc = "1: CLK2x mode"]
CLK2X = 1 , # [doc = "2: Generic autobaud mode"]
GENAUTO = 2 , # [doc = "3: LIN constrained autobaud mode"]
LINAUTO = 3 , } impl From < RXMODE_A > for u8 { # [inline (always)]
fn from (variant : RXMODE_A) -> Self { variant as _ } } impl RXMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXMODE_A { match self . bits { 0 => RXMODE_A :: NORMAL , 1 => RXMODE_A :: CLK2X , 2 => RXMODE_A :: GENAUTO , 3 => RXMODE_A :: LINAUTO , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == RXMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `CLK2X`"]
# [inline (always)]
pub fn is_clk2x (& self) -> bool { * self == RXMODE_A :: CLK2X } # [doc = "Checks if the value of the field is `GENAUTO`"]
# [inline (always)]
pub fn is_genauto (& self) -> bool { * self == RXMODE_A :: GENAUTO } # [doc = "Checks if the value of the field is `LINAUTO`"]
# [inline (always)]
pub fn is_linauto (& self) -> bool { * self == RXMODE_A :: LINAUTO } } # [doc = "Field `RXMODE` writer - Receiver Mode"]
pub type RXMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , RXMODE_A , 2 , O > ; impl < 'a , const O : u8 > RXMODE_W < 'a , O > { # [doc = "Normal mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (RXMODE_A :: NORMAL) } # [doc = "CLK2x mode"]
# [inline (always)]
pub fn clk2x (self) -> & 'a mut W { self . variant (RXMODE_A :: CLK2X) } # [doc = "Generic autobaud mode"]
# [inline (always)]
pub fn genauto (self) -> & 'a mut W { self . variant (RXMODE_A :: GENAUTO) } # [doc = "LIN constrained autobaud mode"]
# [inline (always)]
pub fn linauto (self) -> & 'a mut W { self . variant (RXMODE_A :: LINAUTO) } } # [doc = "Field `ODME` reader - Open Drain Mode Enable"]
pub type ODME_R = crate :: BitReader < bool > ; # [doc = "Field `ODME` writer - Open Drain Mode Enable"]
pub type ODME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `SFDEN` reader - Start Frame Detection Enable"]
pub type SFDEN_R = crate :: BitReader < bool > ; # [doc = "Field `SFDEN` writer - Start Frame Detection Enable"]
pub type SFDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Reciever enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Reciever enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
pub fn rxmode (& self) -> RXMODE_R { RXMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
pub fn odme (& self) -> ODME_R { ODME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
pub fn sfden (& self) -> SFDEN_R { SFDEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 0 > { MPCM_W :: new (self) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
# [must_use]
pub fn rxmode (& mut self) -> RXMODE_W < 1 > { RXMODE_W :: new (self) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
# [must_use]
pub fn odme (& mut self) -> ODME_W < 3 > { ODME_W :: new (self) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
# [must_use]
pub fn sfden (& mut self) -> SFDEN_W < 4 > { SFDEN_W :: new (self) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 6 > { TXEN_W :: new (self) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 7 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `NORMAL_CHSIZE` reader - Character Size"]
pub type NORMAL_CHSIZE_R = crate :: FieldReader < u8 , NORMAL_CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "6: Character size: 9 bit read low byte first"]
_9BITL = 6 , # [doc = "7: Character size: 9 bit read high byte first"]
_9BITH = 7 , } impl From < NORMAL_CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_CHSIZE_A) -> Self { variant as _ } } impl NORMAL_CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NORMAL_CHSIZE_A > { match self . bits { 0 => Some (NORMAL_CHSIZE_A :: _5BIT) , 1 => Some (NORMAL_CHSIZE_A :: _6BIT) , 2 => Some (NORMAL_CHSIZE_A :: _7BIT) , 3 => Some (NORMAL_CHSIZE_A :: _8BIT) , 6 => Some (NORMAL_CHSIZE_A :: _9BITL) , 7 => Some (NORMAL_CHSIZE_A :: _9BITH) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BITL`"]
# [inline (always)]
pub fn is_9bitl (& self) -> bool { * self == NORMAL_CHSIZE_A :: _9BITL } # [doc = "Checks if the value of the field is `_9BITH`"]
# [inline (always)]
pub fn is_9bith (& self) -> bool { * self == NORMAL_CHSIZE_A :: _9BITH } } # [doc = "Field `NORMAL_CHSIZE` writer - Character Size"]
pub type NORMAL_CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > NORMAL_CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit read low byte first"]
# [inline (always)]
pub fn _9bitl (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _9BITL) } # [doc = "Character size: 9 bit read high byte first"]
# [inline (always)]
pub fn _9bith (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _9BITH) } } # [doc = "Field `MSPI_UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type MSPI_UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `MSPI_UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type MSPI_UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `MSPI_UDORD` reader - SPI Master Mode, Data Order"]
pub type MSPI_UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `MSPI_UDORD` writer - SPI Master Mode, Data Order"]
pub type MSPI_UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `NORMAL_SBMODE` reader - Stop Bit Mode"]
pub type NORMAL_SBMODE_R = crate :: BitReader < NORMAL_SBMODE_A > ; # [doc = "Stop Bit Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum NORMAL_SBMODE_A { # [doc = "0: 1 stop bit"]
_1BIT = 0 , # [doc = "1: 2 stop bits"]
_2BIT = 1 , } impl From < NORMAL_SBMODE_A > for bool { # [inline (always)]
fn from (variant : NORMAL_SBMODE_A) -> Self { variant as u8 != 0 } } impl NORMAL_SBMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NORMAL_SBMODE_A { match self . bits { false => NORMAL_SBMODE_A :: _1BIT , true => NORMAL_SBMODE_A :: _2BIT , } } # [doc = "Checks if the value of the field is `_1BIT`"]
# [inline (always)]
pub fn is_1bit (& self) -> bool { * self == NORMAL_SBMODE_A :: _1BIT } # [doc = "Checks if the value of the field is `_2BIT`"]
# [inline (always)]
pub fn is_2bit (& self) -> bool { * self == NORMAL_SBMODE_A :: _2BIT } } # [doc = "Field `NORMAL_SBMODE` writer - Stop Bit Mode"]
pub type NORMAL_SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , NORMAL_SBMODE_A , O > ; impl < 'a , const O : u8 > NORMAL_SBMODE_W < 'a , O > { # [doc = "1 stop bit"]
# [inline (always)]
pub fn _1bit (self) -> & 'a mut W { self . variant (NORMAL_SBMODE_A :: _1BIT) } # [doc = "2 stop bits"]
# [inline (always)]
pub fn _2bit (self) -> & 'a mut W { self . variant (NORMAL_SBMODE_A :: _2BIT) } } # [doc = "Field `NORMAL_PMODE` reader - Parity Mode"]
pub type NORMAL_PMODE_R = crate :: FieldReader < u8 , NORMAL_PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < NORMAL_PMODE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_PMODE_A) -> Self { variant as _ } } impl NORMAL_PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NORMAL_PMODE_A > { match self . bits { 0 => Some (NORMAL_PMODE_A :: DISABLED) , 2 => Some (NORMAL_PMODE_A :: EVEN) , 3 => Some (NORMAL_PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == NORMAL_PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == NORMAL_PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == NORMAL_PMODE_A :: ODD } } # [doc = "Field `NORMAL_PMODE` writer - Parity Mode"]
pub type NORMAL_PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_PMODE_A , 2 , O > ; impl < 'a , const O : u8 > NORMAL_PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: ODD) } } # [doc = "Field `MSPI_CMODE` reader - Communication Mode"]
pub type MSPI_CMODE_R = crate :: FieldReader < u8 , MSPI_CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MSPI_CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < MSPI_CMODE_A > for u8 { # [inline (always)]
fn from (variant : MSPI_CMODE_A) -> Self { variant as _ } } impl MSPI_CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MSPI_CMODE_A { match self . bits { 0 => MSPI_CMODE_A :: ASYNCHRONOUS , 1 => MSPI_CMODE_A :: SYNCHRONOUS , 2 => MSPI_CMODE_A :: IRCOM , 3 => MSPI_CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == MSPI_CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == MSPI_CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == MSPI_CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == MSPI_CMODE_A :: MSPI } } # [doc = "Field `MSPI_CMODE` writer - Communication Mode"]
pub type MSPI_CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , MSPI_CMODE_A , 2 , O > ; impl < 'a , const O : u8 > MSPI_CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: IRCOM) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: MSPI) } } # [doc = "Field `NORMAL_CMODE` reader - Communication Mode"]
pub type NORMAL_CMODE_R = crate :: FieldReader < u8 , NORMAL_CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < NORMAL_CMODE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_CMODE_A) -> Self { variant as _ } } impl NORMAL_CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NORMAL_CMODE_A { match self . bits { 0 => NORMAL_CMODE_A :: ASYNCHRONOUS , 1 => NORMAL_CMODE_A :: SYNCHRONOUS , 2 => NORMAL_CMODE_A :: IRCOM , 3 => NORMAL_CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == NORMAL_CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == NORMAL_CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == NORMAL_CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == NORMAL_CMODE_A :: MSPI } } # [doc = "Field `NORMAL_CMODE` writer - Communication Mode"]
pub type NORMAL_CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_CMODE_A , 2 , O > ; impl < 'a , const O : u8 > NORMAL_CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: IRCOM) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn normal_chsize (& self) -> NORMAL_CHSIZE_R { NORMAL_CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn mspi_ucpha (& self) -> MSPI_UCPHA_R { MSPI_UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn mspi_udord (& self) -> MSPI_UDORD_R { MSPI_UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn normal_sbmode (& self) -> NORMAL_SBMODE_R { NORMAL_SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn normal_pmode (& self) -> NORMAL_PMODE_R { NORMAL_PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn mspi_cmode (& self) -> MSPI_CMODE_R { MSPI_CMODE_R :: new ((self . bits >> 6) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn normal_cmode (& self) -> NORMAL_CMODE_R { NORMAL_CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn normal_chsize (& mut self) -> NORMAL_CHSIZE_W < 0 > { NORMAL_CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn mspi_ucpha (& mut self) -> MSPI_UCPHA_W < 1 > { MSPI_UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn mspi_udord (& mut self) -> MSPI_UDORD_W < 2 > { MSPI_UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn normal_sbmode (& mut self) -> NORMAL_SBMODE_W < 3 > { NORMAL_SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn normal_pmode (& mut self) -> NORMAL_PMODE_W < 4 > { NORMAL_PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mspi_cmode (& mut self) -> MSPI_CMODE_W < 6 > { MSPI_CMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn normal_cmode (& mut self) -> NORMAL_CMODE_W < 6 > { NORMAL_CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `ABW` reader - Auto Baud Window"]
pub type ABW_R = crate :: FieldReader < u8 , ABW_A > ; # [doc = "Auto Baud Window\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ABW_A { # [doc = "0: 18% tolerance"]
WDW0 = 0 , # [doc = "1: 15% tolerance"]
WDW1 = 1 , # [doc = "2: 21% tolerance"]
WDW2 = 2 , # [doc = "3: 25% tolerance"]
WDW3 = 3 , } impl From < ABW_A > for u8 { # [inline (always)]
fn from (variant : ABW_A) -> Self { variant as _ } } impl ABW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ABW_A { match self . bits { 0 => ABW_A :: WDW0 , 1 => ABW_A :: WDW1 , 2 => ABW_A :: WDW2 , 3 => ABW_A :: WDW3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `WDW0`"]
# [inline (always)]
pub fn is_wdw0 (& self) -> bool { * self == ABW_A :: WDW0 } # [doc = "Checks if the value of the field is `WDW1`"]
# [inline (always)]
pub fn is_wdw1 (& self) -> bool { * self == ABW_A :: WDW1 } # [doc = "Checks if the value of the field is `WDW2`"]
# [inline (always)]
pub fn is_wdw2 (& self) -> bool { * self == ABW_A :: WDW2 } # [doc = "Checks if the value of the field is `WDW3`"]
# [inline (always)]
pub fn is_wdw3 (& self) -> bool { * self == ABW_A :: WDW3 } } # [doc = "Field `ABW` writer - Auto Baud Window"]
pub type ABW_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLD_SPEC , u8 , ABW_A , 2 , O > ; impl < 'a , const O : u8 > ABW_W < 'a , O > { # [doc = "18% tolerance"]
# [inline (always)]
pub fn wdw0 (self) -> & 'a mut W { self . variant (ABW_A :: WDW0) } # [doc = "15% tolerance"]
# [inline (always)]
pub fn wdw1 (self) -> & 'a mut W { self . variant (ABW_A :: WDW1) } # [doc = "21% tolerance"]
# [inline (always)]
pub fn wdw2 (self) -> & 'a mut W { self . variant (ABW_A :: WDW2) } # [doc = "25% tolerance"]
# [inline (always)]
pub fn wdw3 (self) -> & 'a mut W { self . variant (ABW_A :: WDW3) } } impl R { # [doc = "Bits 6:7 - Auto Baud Window"]
# [inline (always)]
pub fn abw (& self) -> ABW_R { ABW_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 6:7 - Auto Baud Window"]
# [inline (always)]
# [must_use]
pub fn abw (& mut self) -> ABW_W < 6 > { ABW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; # [doc = "Field `ABMBP` reader - Autobaud majority voter bypass"]
pub type ABMBP_R = crate :: BitReader < bool > ; # [doc = "Field `ABMBP` writer - Autobaud majority voter bypass"]
pub type ABMBP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - Autobaud majority voter bypass"]
# [inline (always)]
pub fn abmbp (& self) -> ABMBP_R { ABMBP_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Bit 7 - Autobaud majority voter bypass"]
# [inline (always)]
# [must_use]
pub fn abmbp (& mut self) -> ABMBP_W < 7 > { ABMBP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `IREI` reader - IrDA Event Input Enable"]
pub type IREI_R = crate :: BitReader < bool > ; # [doc = "Field `IREI` writer - IrDA Event Input Enable"]
pub type IREI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
pub fn irei (& self) -> IREI_R { IREI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn irei (& mut self) -> IREI_W < 0 > { IREI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAH (r) register accessor: an alias for `Reg<RXDATAH_SPEC>`"]
pub type RXDATAH = crate :: Reg < rxdatah :: RXDATAH_SPEC > ; # [doc = "Receive Data High Byte"]
pub mod rxdatah { # [doc = "Register `RXDATAH` reader"]
pub struct R (crate :: R < RXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA8` reader - Receiver Data Register"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Receiver Data Register"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Receive Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatah](index.html) module"]
pub struct RXDATAH_SPEC ; impl crate :: RegisterSpec for RXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatah::R](R) reader structure"]
impl crate :: Readable for RXDATAH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAH to value 0"]
impl crate :: Resettable for RXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAL (r) register accessor: an alias for `Reg<RXDATAL_SPEC>`"]
pub type RXDATAL = crate :: Reg < rxdatal :: RXDATAL_SPEC > ; # [doc = "Receive Data Low Byte"]
pub mod rxdatal { # [doc = "Register `RXDATAL` reader"]
pub struct R (crate :: R < RXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA` reader - RX Data"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - RX Data"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } # [doc = "Receive Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatal](index.html) module"]
pub struct RXDATAL_SPEC ; impl crate :: RegisterSpec for RXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatal::R](R) reader structure"]
impl crate :: Readable for RXDATAL_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAL to value 0"]
impl crate :: Resettable for RXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXPLCTRL (rw) register accessor: an alias for `Reg<RXPLCTRL_SPEC>`"]
pub type RXPLCTRL = crate :: Reg < rxplctrl :: RXPLCTRL_SPEC > ; # [doc = "IRCOM Receiver Pulse Length Control"]
pub mod rxplctrl { # [doc = "Register `RXPLCTRL` reader"]
pub struct R (crate :: R < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXPLCTRL` writer"]
pub struct W (crate :: W < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXPL` reader - Receiver Pulse Lenght"]
pub type RXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RXPL` writer - Receiver Pulse Lenght"]
pub type RXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , RXPLCTRL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
pub fn rxpl (& self) -> RXPL_R { RXPL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
# [must_use]
pub fn rxpl (& mut self) -> RXPL_W < 0 > { RXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "IRCOM Receiver Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxplctrl](index.html) module"]
pub struct RXPLCTRL_SPEC ; impl crate :: RegisterSpec for RXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxplctrl::R](R) reader structure"]
impl crate :: Readable for RXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxplctrl::W](W) writer structure"]
impl crate :: Writable for RXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXPLCTRL to value 0"]
impl crate :: Resettable for RXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WFB` reader - Wait For Break"]
pub type WFB_R = crate :: BitReader < bool > ; # [doc = "Field `WFB` writer - Wait For Break"]
pub type WFB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BDF` reader - Break Detected Flag"]
pub type BDF_R = crate :: BitReader < bool > ; # [doc = "Field `BDF` writer - Break Detected Flag"]
pub type BDF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `ISFIF` reader - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_R = crate :: BitReader < bool > ; # [doc = "Field `ISFIF` writer - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXSIF` reader - Receive Start Interrupt"]
pub type RXSIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
pub fn wfb (& self) -> WFB_R { WFB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
pub fn bdf (& self) -> BDF_R { BDF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
pub fn isfif (& self) -> ISFIF_R { ISFIF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receive Start Interrupt"]
# [inline (always)]
pub fn rxsif (& self) -> RXSIF_R { RXSIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
# [must_use]
pub fn wfb (& mut self) -> WFB_W < 0 > { WFB_W :: new (self) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
# [must_use]
pub fn bdf (& mut self) -> BDF_W < 1 > { BDF_W :: new (self) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn isfif (& mut self) -> ISFIF_W < 3 > { ISFIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAH (rw) register accessor: an alias for `Reg<TXDATAH_SPEC>`"]
pub type TXDATAH = crate :: Reg < txdatah :: TXDATAH_SPEC > ; # [doc = "Transmit Data High Byte"]
pub mod txdatah { # [doc = "Register `TXDATAH` reader"]
pub struct R (crate :: R < TXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAH` writer"]
pub struct W (crate :: W < TXDATAH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAH_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA8` reader - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `DATA8` writer - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TXDATAH_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
# [must_use]
pub fn data8 (& mut self) -> DATA8_W < 0 > { DATA8_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transmit Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatah](index.html) module"]
pub struct TXDATAH_SPEC ; impl crate :: RegisterSpec for TXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatah::R](R) reader structure"]
impl crate :: Readable for TXDATAH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatah::W](W) writer structure"]
impl crate :: Writable for TXDATAH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAH to value 0"]
impl crate :: Resettable for TXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAL (rw) register accessor: an alias for `Reg<TXDATAL_SPEC>`"]
pub type TXDATAL = crate :: Reg < txdatal :: TXDATAL_SPEC > ; # [doc = "Transmit Data Low Byte"]
pub mod txdatal { # [doc = "Register `TXDATAL` reader"]
pub struct R (crate :: R < TXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAL` writer"]
pub struct W (crate :: W < TXDATAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Transmit Data Register"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DATA` writer - Transmit Data Register"]
pub type DATA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXDATAL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
# [must_use]
pub fn data (& mut self) -> DATA_W < 0 > { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transmit Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatal](index.html) module"]
pub struct TXDATAL_SPEC ; impl crate :: RegisterSpec for TXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatal::R](R) reader structure"]
impl crate :: Readable for TXDATAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatal::W](W) writer structure"]
impl crate :: Writable for TXDATAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAL to value 0"]
impl crate :: Resettable for TXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXPLCTRL (rw) register accessor: an alias for `Reg<TXPLCTRL_SPEC>`"]
pub type TXPLCTRL = crate :: Reg < txplctrl :: TXPLCTRL_SPEC > ; # [doc = "IRCOM Transmitter Pulse Length Control"]
pub mod txplctrl { # [doc = "Register `TXPLCTRL` reader"]
pub struct R (crate :: R < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXPLCTRL` writer"]
pub struct W (crate :: W < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXPL` reader - Transmit pulse length"]
pub type TXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TXPL` writer - Transmit pulse length"]
pub type TXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXPLCTRL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
pub fn txpl (& self) -> TXPL_R { TXPL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
# [must_use]
pub fn txpl (& mut self) -> TXPL_W < 0 > { TXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "IRCOM Transmitter Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txplctrl](index.html) module"]
pub struct TXPLCTRL_SPEC ; impl crate :: RegisterSpec for TXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txplctrl::R](R) reader structure"]
impl crate :: Readable for TXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txplctrl::W](W) writer structure"]
impl crate :: Writable for TXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXPLCTRL to value 0"]
impl crate :: Resettable for TXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub struct USART3 { _marker : PhantomData < * const () > } unsafe impl Send for USART3 { } impl USART3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart3 :: RegisterBlock = 0x0860 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart3 :: RegisterBlock { Self :: PTR } } impl Deref for USART3 { type Target = usart3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART3") . finish () } } # [doc = "Universal Synchronous and Asynchronous Receiver and Transmitter"]
pub mod usart3 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Receive Data Low Byte"]
pub rxdatal : RXDATAL , # [doc = "0x01 - Receive Data High Byte"]
pub rxdatah : RXDATAH , # [doc = "0x02 - Transmit Data Low Byte"]
pub txdatal : TXDATAL , # [doc = "0x03 - Transmit Data High Byte"]
pub txdatah : TXDATAH , # [doc = "0x04 - Status"]
pub status : STATUS , # [doc = "0x05 - Control A"]
pub ctrla : CTRLA , # [doc = "0x06 - Control B"]
pub ctrlb : CTRLB , # [doc = "0x07 - Control C"]
pub ctrlc : CTRLC , # [doc = "0x08 - Baud Rate"]
pub baud : BAUD , # [doc = "0x0a - Control D"]
pub ctrld : CTRLD , # [doc = "0x0b - Debug Control"]
pub dbgctrl : DBGCTRL , # [doc = "0x0c - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x0d - IRCOM Transmitter Pulse Length Control"]
pub txplctrl : TXPLCTRL , # [doc = "0x0e - IRCOM Receiver Pulse Length Control"]
pub rxplctrl : RXPLCTRL , } # [doc = "BAUD (rw) register accessor: an alias for `Reg<BAUD_SPEC>`"]
pub type BAUD = crate :: Reg < baud :: BAUD_SPEC > ; # [doc = "Baud Rate"]
pub mod baud { # [doc = "Register `BAUD` reader"]
pub struct R (crate :: R < BAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD` writer"]
pub struct W (crate :: W < BAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud](index.html) module"]
pub struct BAUD_SPEC ; impl crate :: RegisterSpec for BAUD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud::R](R) reader structure"]
impl crate :: Readable for BAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud::W](W) writer structure"]
impl crate :: Writable for BAUD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUD to value 0"]
impl crate :: Resettable for BAUD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `RS485` reader - RS485 Mode internal transmitter"]
pub type RS485_R = crate :: FieldReader < u8 , RS485_A > ; # [doc = "RS485 Mode internal transmitter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RS485_A { # [doc = "0: RS485 Mode disabled"]
OFF = 0 , # [doc = "1: RS485 Mode External drive"]
EXT = 1 , # [doc = "2: RS485 Mode Internal drive"]
INT = 2 , } impl From < RS485_A > for u8 { # [inline (always)]
fn from (variant : RS485_A) -> Self { variant as _ } } impl RS485_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RS485_A > { match self . bits { 0 => Some (RS485_A :: OFF) , 1 => Some (RS485_A :: EXT) , 2 => Some (RS485_A :: INT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RS485_A :: OFF } # [doc = "Checks if the value of the field is `EXT`"]
# [inline (always)]
pub fn is_ext (& self) -> bool { * self == RS485_A :: EXT } # [doc = "Checks if the value of the field is `INT`"]
# [inline (always)]
pub fn is_int (& self) -> bool { * self == RS485_A :: INT } } # [doc = "Field `RS485` writer - RS485 Mode internal transmitter"]
pub type RS485_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , RS485_A , 2 , O > ; impl < 'a , const O : u8 > RS485_W < 'a , O > { # [doc = "RS485 Mode disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RS485_A :: OFF) } # [doc = "RS485 Mode External drive"]
# [inline (always)]
pub fn ext (self) -> & 'a mut W { self . variant (RS485_A :: EXT) } # [doc = "RS485 Mode Internal drive"]
# [inline (always)]
pub fn int (self) -> & 'a mut W { self . variant (RS485_A :: INT) } } # [doc = "Field `ABEIE` reader - Auto-baud Error Interrupt Enable"]
pub type ABEIE_R = crate :: BitReader < bool > ; # [doc = "Field `ABEIE` writer - Auto-baud Error Interrupt Enable"]
pub type ABEIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `LBME` reader - Loop-back Mode Enable"]
pub type LBME_R = crate :: BitReader < bool > ; # [doc = "Field `LBME` writer - Loop-back Mode Enable"]
pub type LBME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXSIE` reader - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXSIE` writer - Receiver Start Frame Interrupt Enable"]
pub type RXSIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DREIE` reader - Data Register Empty Interrupt Enable"]
pub type DREIE_R = crate :: BitReader < bool > ; # [doc = "Field `DREIE` writer - Data Register Empty Interrupt Enable"]
pub type DREIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `TXCIE` reader - Transmit Complete Interrupt Enable"]
pub type TXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE` writer - Transmit Complete Interrupt Enable"]
pub type TXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `RXCIE` reader - Receive Complete Interrupt Enable"]
pub type RXCIE_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE` writer - Receive Complete Interrupt Enable"]
pub type RXCIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
pub fn rs485 (& self) -> RS485_R { RS485_R :: new (self . bits & 3) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
pub fn abeie (& self) -> ABEIE_R { ABEIE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
pub fn lbme (& self) -> LBME_R { LBME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
pub fn rxsie (& self) -> RXSIE_R { RXSIE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dreie (& self) -> DREIE_R { DREIE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie (& self) -> TXCIE_R { TXCIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie (& self) -> RXCIE_R { RXCIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - RS485 Mode internal transmitter"]
# [inline (always)]
# [must_use]
pub fn rs485 (& mut self) -> RS485_W < 0 > { RS485_W :: new (self) } # [doc = "Bit 2 - Auto-baud Error Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn abeie (& mut self) -> ABEIE_W < 2 > { ABEIE_W :: new (self) } # [doc = "Bit 3 - Loop-back Mode Enable"]
# [inline (always)]
# [must_use]
pub fn lbme (& mut self) -> LBME_W < 3 > { LBME_W :: new (self) } # [doc = "Bit 4 - Receiver Start Frame Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxsie (& mut self) -> RXSIE_W < 4 > { RXSIE_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn dreie (& mut self) -> DREIE_W < 5 > { DREIE_W :: new (self) } # [doc = "Bit 6 - Transmit Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie (& mut self) -> TXCIE_W < 6 > { TXCIE_W :: new (self) } # [doc = "Bit 7 - Receive Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie (& mut self) -> RXCIE_W < 7 > { RXCIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXMODE` reader - Receiver Mode"]
pub type RXMODE_R = crate :: FieldReader < u8 , RXMODE_A > ; # [doc = "Receiver Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXMODE_A { # [doc = "0: Normal mode"]
NORMAL = 0 , # [doc = "1: CLK2x mode"]
CLK2X = 1 , # [doc = "2: Generic autobaud mode"]
GENAUTO = 2 , # [doc = "3: LIN constrained autobaud mode"]
LINAUTO = 3 , } impl From < RXMODE_A > for u8 { # [inline (always)]
fn from (variant : RXMODE_A) -> Self { variant as _ } } impl RXMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXMODE_A { match self . bits { 0 => RXMODE_A :: NORMAL , 1 => RXMODE_A :: CLK2X , 2 => RXMODE_A :: GENAUTO , 3 => RXMODE_A :: LINAUTO , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == RXMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `CLK2X`"]
# [inline (always)]
pub fn is_clk2x (& self) -> bool { * self == RXMODE_A :: CLK2X } # [doc = "Checks if the value of the field is `GENAUTO`"]
# [inline (always)]
pub fn is_genauto (& self) -> bool { * self == RXMODE_A :: GENAUTO } # [doc = "Checks if the value of the field is `LINAUTO`"]
# [inline (always)]
pub fn is_linauto (& self) -> bool { * self == RXMODE_A :: LINAUTO } } # [doc = "Field `RXMODE` writer - Receiver Mode"]
pub type RXMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , RXMODE_A , 2 , O > ; impl < 'a , const O : u8 > RXMODE_W < 'a , O > { # [doc = "Normal mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (RXMODE_A :: NORMAL) } # [doc = "CLK2x mode"]
# [inline (always)]
pub fn clk2x (self) -> & 'a mut W { self . variant (RXMODE_A :: CLK2X) } # [doc = "Generic autobaud mode"]
# [inline (always)]
pub fn genauto (self) -> & 'a mut W { self . variant (RXMODE_A :: GENAUTO) } # [doc = "LIN constrained autobaud mode"]
# [inline (always)]
pub fn linauto (self) -> & 'a mut W { self . variant (RXMODE_A :: LINAUTO) } } # [doc = "Field `ODME` reader - Open Drain Mode Enable"]
pub type ODME_R = crate :: BitReader < bool > ; # [doc = "Field `ODME` writer - Open Drain Mode Enable"]
pub type ODME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `SFDEN` reader - Start Frame Detection Enable"]
pub type SFDEN_R = crate :: BitReader < bool > ; # [doc = "Field `SFDEN` writer - Start Frame Detection Enable"]
pub type SFDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Reciever enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Reciever enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
pub fn rxmode (& self) -> RXMODE_R { RXMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
pub fn odme (& self) -> ODME_R { ODME_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
pub fn sfden (& self) -> SFDEN_R { SFDEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 0 > { MPCM_W :: new (self) } # [doc = "Bits 1:2 - Receiver Mode"]
# [inline (always)]
# [must_use]
pub fn rxmode (& mut self) -> RXMODE_W < 1 > { RXMODE_W :: new (self) } # [doc = "Bit 3 - Open Drain Mode Enable"]
# [inline (always)]
# [must_use]
pub fn odme (& mut self) -> ODME_W < 3 > { ODME_W :: new (self) } # [doc = "Bit 4 - Start Frame Detection Enable"]
# [inline (always)]
# [must_use]
pub fn sfden (& mut self) -> SFDEN_W < 4 > { SFDEN_W :: new (self) } # [doc = "Bit 6 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 6 > { TXEN_W :: new (self) } # [doc = "Bit 7 - Reciever enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 7 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `NORMAL_CHSIZE` reader - Character Size"]
pub type NORMAL_CHSIZE_R = crate :: FieldReader < u8 , NORMAL_CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "6: Character size: 9 bit read low byte first"]
_9BITL = 6 , # [doc = "7: Character size: 9 bit read high byte first"]
_9BITH = 7 , } impl From < NORMAL_CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_CHSIZE_A) -> Self { variant as _ } } impl NORMAL_CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NORMAL_CHSIZE_A > { match self . bits { 0 => Some (NORMAL_CHSIZE_A :: _5BIT) , 1 => Some (NORMAL_CHSIZE_A :: _6BIT) , 2 => Some (NORMAL_CHSIZE_A :: _7BIT) , 3 => Some (NORMAL_CHSIZE_A :: _8BIT) , 6 => Some (NORMAL_CHSIZE_A :: _9BITL) , 7 => Some (NORMAL_CHSIZE_A :: _9BITH) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == NORMAL_CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BITL`"]
# [inline (always)]
pub fn is_9bitl (& self) -> bool { * self == NORMAL_CHSIZE_A :: _9BITL } # [doc = "Checks if the value of the field is `_9BITH`"]
# [inline (always)]
pub fn is_9bith (& self) -> bool { * self == NORMAL_CHSIZE_A :: _9BITH } } # [doc = "Field `NORMAL_CHSIZE` writer - Character Size"]
pub type NORMAL_CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > NORMAL_CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit read low byte first"]
# [inline (always)]
pub fn _9bitl (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _9BITL) } # [doc = "Character size: 9 bit read high byte first"]
# [inline (always)]
pub fn _9bith (self) -> & 'a mut W { self . variant (NORMAL_CHSIZE_A :: _9BITH) } } # [doc = "Field `MSPI_UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type MSPI_UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `MSPI_UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type MSPI_UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `MSPI_UDORD` reader - SPI Master Mode, Data Order"]
pub type MSPI_UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `MSPI_UDORD` writer - SPI Master Mode, Data Order"]
pub type MSPI_UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `NORMAL_SBMODE` reader - Stop Bit Mode"]
pub type NORMAL_SBMODE_R = crate :: BitReader < NORMAL_SBMODE_A > ; # [doc = "Stop Bit Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum NORMAL_SBMODE_A { # [doc = "0: 1 stop bit"]
_1BIT = 0 , # [doc = "1: 2 stop bits"]
_2BIT = 1 , } impl From < NORMAL_SBMODE_A > for bool { # [inline (always)]
fn from (variant : NORMAL_SBMODE_A) -> Self { variant as u8 != 0 } } impl NORMAL_SBMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NORMAL_SBMODE_A { match self . bits { false => NORMAL_SBMODE_A :: _1BIT , true => NORMAL_SBMODE_A :: _2BIT , } } # [doc = "Checks if the value of the field is `_1BIT`"]
# [inline (always)]
pub fn is_1bit (& self) -> bool { * self == NORMAL_SBMODE_A :: _1BIT } # [doc = "Checks if the value of the field is `_2BIT`"]
# [inline (always)]
pub fn is_2bit (& self) -> bool { * self == NORMAL_SBMODE_A :: _2BIT } } # [doc = "Field `NORMAL_SBMODE` writer - Stop Bit Mode"]
pub type NORMAL_SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , NORMAL_SBMODE_A , O > ; impl < 'a , const O : u8 > NORMAL_SBMODE_W < 'a , O > { # [doc = "1 stop bit"]
# [inline (always)]
pub fn _1bit (self) -> & 'a mut W { self . variant (NORMAL_SBMODE_A :: _1BIT) } # [doc = "2 stop bits"]
# [inline (always)]
pub fn _2bit (self) -> & 'a mut W { self . variant (NORMAL_SBMODE_A :: _2BIT) } } # [doc = "Field `NORMAL_PMODE` reader - Parity Mode"]
pub type NORMAL_PMODE_R = crate :: FieldReader < u8 , NORMAL_PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < NORMAL_PMODE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_PMODE_A) -> Self { variant as _ } } impl NORMAL_PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NORMAL_PMODE_A > { match self . bits { 0 => Some (NORMAL_PMODE_A :: DISABLED) , 2 => Some (NORMAL_PMODE_A :: EVEN) , 3 => Some (NORMAL_PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == NORMAL_PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == NORMAL_PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == NORMAL_PMODE_A :: ODD } } # [doc = "Field `NORMAL_PMODE` writer - Parity Mode"]
pub type NORMAL_PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_PMODE_A , 2 , O > ; impl < 'a , const O : u8 > NORMAL_PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (NORMAL_PMODE_A :: ODD) } } # [doc = "Field `MSPI_CMODE` reader - Communication Mode"]
pub type MSPI_CMODE_R = crate :: FieldReader < u8 , MSPI_CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MSPI_CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < MSPI_CMODE_A > for u8 { # [inline (always)]
fn from (variant : MSPI_CMODE_A) -> Self { variant as _ } } impl MSPI_CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MSPI_CMODE_A { match self . bits { 0 => MSPI_CMODE_A :: ASYNCHRONOUS , 1 => MSPI_CMODE_A :: SYNCHRONOUS , 2 => MSPI_CMODE_A :: IRCOM , 3 => MSPI_CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == MSPI_CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == MSPI_CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == MSPI_CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == MSPI_CMODE_A :: MSPI } } # [doc = "Field `MSPI_CMODE` writer - Communication Mode"]
pub type MSPI_CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , MSPI_CMODE_A , 2 , O > ; impl < 'a , const O : u8 > MSPI_CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: IRCOM) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (MSPI_CMODE_A :: MSPI) } } # [doc = "Field `NORMAL_CMODE` reader - Communication Mode"]
pub type NORMAL_CMODE_R = crate :: FieldReader < u8 , NORMAL_CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum NORMAL_CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: Infrared Communication"]
IRCOM = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < NORMAL_CMODE_A > for u8 { # [inline (always)]
fn from (variant : NORMAL_CMODE_A) -> Self { variant as _ } } impl NORMAL_CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> NORMAL_CMODE_A { match self . bits { 0 => NORMAL_CMODE_A :: ASYNCHRONOUS , 1 => NORMAL_CMODE_A :: SYNCHRONOUS , 2 => NORMAL_CMODE_A :: IRCOM , 3 => NORMAL_CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == NORMAL_CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == NORMAL_CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRCOM`"]
# [inline (always)]
pub fn is_ircom (& self) -> bool { * self == NORMAL_CMODE_A :: IRCOM } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == NORMAL_CMODE_A :: MSPI } } # [doc = "Field `NORMAL_CMODE` writer - Communication Mode"]
pub type NORMAL_CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , NORMAL_CMODE_A , 2 , O > ; impl < 'a , const O : u8 > NORMAL_CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: SYNCHRONOUS) } # [doc = "Infrared Communication"]
# [inline (always)]
pub fn ircom (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: IRCOM) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (NORMAL_CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn normal_chsize (& self) -> NORMAL_CHSIZE_R { NORMAL_CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn mspi_ucpha (& self) -> MSPI_UCPHA_R { MSPI_UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn mspi_udord (& self) -> MSPI_UDORD_R { MSPI_UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn normal_sbmode (& self) -> NORMAL_SBMODE_R { NORMAL_SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn normal_pmode (& self) -> NORMAL_PMODE_R { NORMAL_PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn mspi_cmode (& self) -> MSPI_CMODE_R { MSPI_CMODE_R :: new ((self . bits >> 6) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn normal_cmode (& self) -> NORMAL_CMODE_R { NORMAL_CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn normal_chsize (& mut self) -> NORMAL_CHSIZE_W < 0 > { NORMAL_CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn mspi_ucpha (& mut self) -> MSPI_UCPHA_W < 1 > { MSPI_UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn mspi_udord (& mut self) -> MSPI_UDORD_W < 2 > { MSPI_UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn normal_sbmode (& mut self) -> NORMAL_SBMODE_W < 3 > { NORMAL_SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn normal_pmode (& mut self) -> NORMAL_PMODE_W < 4 > { NORMAL_PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mspi_cmode (& mut self) -> MSPI_CMODE_W < 6 > { MSPI_CMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn normal_cmode (& mut self) -> NORMAL_CMODE_W < 6 > { NORMAL_CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `ABW` reader - Auto Baud Window"]
pub type ABW_R = crate :: FieldReader < u8 , ABW_A > ; # [doc = "Auto Baud Window\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ABW_A { # [doc = "0: 18% tolerance"]
WDW0 = 0 , # [doc = "1: 15% tolerance"]
WDW1 = 1 , # [doc = "2: 21% tolerance"]
WDW2 = 2 , # [doc = "3: 25% tolerance"]
WDW3 = 3 , } impl From < ABW_A > for u8 { # [inline (always)]
fn from (variant : ABW_A) -> Self { variant as _ } } impl ABW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ABW_A { match self . bits { 0 => ABW_A :: WDW0 , 1 => ABW_A :: WDW1 , 2 => ABW_A :: WDW2 , 3 => ABW_A :: WDW3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `WDW0`"]
# [inline (always)]
pub fn is_wdw0 (& self) -> bool { * self == ABW_A :: WDW0 } # [doc = "Checks if the value of the field is `WDW1`"]
# [inline (always)]
pub fn is_wdw1 (& self) -> bool { * self == ABW_A :: WDW1 } # [doc = "Checks if the value of the field is `WDW2`"]
# [inline (always)]
pub fn is_wdw2 (& self) -> bool { * self == ABW_A :: WDW2 } # [doc = "Checks if the value of the field is `WDW3`"]
# [inline (always)]
pub fn is_wdw3 (& self) -> bool { * self == ABW_A :: WDW3 } } # [doc = "Field `ABW` writer - Auto Baud Window"]
pub type ABW_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLD_SPEC , u8 , ABW_A , 2 , O > ; impl < 'a , const O : u8 > ABW_W < 'a , O > { # [doc = "18% tolerance"]
# [inline (always)]
pub fn wdw0 (self) -> & 'a mut W { self . variant (ABW_A :: WDW0) } # [doc = "15% tolerance"]
# [inline (always)]
pub fn wdw1 (self) -> & 'a mut W { self . variant (ABW_A :: WDW1) } # [doc = "21% tolerance"]
# [inline (always)]
pub fn wdw2 (self) -> & 'a mut W { self . variant (ABW_A :: WDW2) } # [doc = "25% tolerance"]
# [inline (always)]
pub fn wdw3 (self) -> & 'a mut W { self . variant (ABW_A :: WDW3) } } impl R { # [doc = "Bits 6:7 - Auto Baud Window"]
# [inline (always)]
pub fn abw (& self) -> ABW_R { ABW_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 6:7 - Auto Baud Window"]
# [inline (always)]
# [must_use]
pub fn abw (& mut self) -> ABW_W < 6 > { ABW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DBGCTRL (rw) register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; # [doc = "Field `ABMBP` reader - Autobaud majority voter bypass"]
pub type ABMBP_R = crate :: BitReader < bool > ; # [doc = "Field `ABMBP` writer - Autobaud majority voter bypass"]
pub type ABMBP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - Autobaud majority voter bypass"]
# [inline (always)]
pub fn abmbp (& self) -> ABMBP_R { ABMBP_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
# [must_use]
pub fn dbgrun (& mut self) -> DBGRUN_W < 0 > { DBGRUN_W :: new (self) } # [doc = "Bit 7 - Autobaud majority voter bypass"]
# [inline (always)]
# [must_use]
pub fn abmbp (& mut self) -> ABMBP_W < 7 > { ABMBP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `IREI` reader - IrDA Event Input Enable"]
pub type IREI_R = crate :: BitReader < bool > ; # [doc = "Field `IREI` writer - IrDA Event Input Enable"]
pub type IREI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
pub fn irei (& self) -> IREI_R { IREI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - IrDA Event Input Enable"]
# [inline (always)]
# [must_use]
pub fn irei (& mut self) -> IREI_W < 0 > { IREI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAH (r) register accessor: an alias for `Reg<RXDATAH_SPEC>`"]
pub type RXDATAH = crate :: Reg < rxdatah :: RXDATAH_SPEC > ; # [doc = "Receive Data High Byte"]
pub mod rxdatah { # [doc = "Register `RXDATAH` reader"]
pub struct R (crate :: R < RXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA8` reader - Receiver Data Register"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Receiver Data Register"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Receive Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatah](index.html) module"]
pub struct RXDATAH_SPEC ; impl crate :: RegisterSpec for RXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatah::R](R) reader structure"]
impl crate :: Readable for RXDATAH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAH to value 0"]
impl crate :: Resettable for RXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXDATAL (r) register accessor: an alias for `Reg<RXDATAL_SPEC>`"]
pub type RXDATAL = crate :: Reg < rxdatal :: RXDATAL_SPEC > ; # [doc = "Receive Data Low Byte"]
pub mod rxdatal { # [doc = "Register `RXDATAL` reader"]
pub struct R (crate :: R < RXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Field `DATA` reader - RX Data"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - RX Data"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } # [doc = "Receive Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdatal](index.html) module"]
pub struct RXDATAL_SPEC ; impl crate :: RegisterSpec for RXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxdatal::R](R) reader structure"]
impl crate :: Readable for RXDATAL_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RXDATAL to value 0"]
impl crate :: Resettable for RXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXPLCTRL (rw) register accessor: an alias for `Reg<RXPLCTRL_SPEC>`"]
pub type RXPLCTRL = crate :: Reg < rxplctrl :: RXPLCTRL_SPEC > ; # [doc = "IRCOM Receiver Pulse Length Control"]
pub mod rxplctrl { # [doc = "Register `RXPLCTRL` reader"]
pub struct R (crate :: R < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXPLCTRL` writer"]
pub struct W (crate :: W < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXPL` reader - Receiver Pulse Lenght"]
pub type RXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RXPL` writer - Receiver Pulse Lenght"]
pub type RXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , RXPLCTRL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
pub fn rxpl (& self) -> RXPL_R { RXPL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Receiver Pulse Lenght"]
# [inline (always)]
# [must_use]
pub fn rxpl (& mut self) -> RXPL_W < 0 > { RXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "IRCOM Receiver Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxplctrl](index.html) module"]
pub struct RXPLCTRL_SPEC ; impl crate :: RegisterSpec for RXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxplctrl::R](R) reader structure"]
impl crate :: Readable for RXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxplctrl::W](W) writer structure"]
impl crate :: Writable for RXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXPLCTRL to value 0"]
impl crate :: Resettable for RXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WFB` reader - Wait For Break"]
pub type WFB_R = crate :: BitReader < bool > ; # [doc = "Field `WFB` writer - Wait For Break"]
pub type WFB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BDF` reader - Break Detected Flag"]
pub type BDF_R = crate :: BitReader < bool > ; # [doc = "Field `BDF` writer - Break Detected Flag"]
pub type BDF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `ISFIF` reader - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_R = crate :: BitReader < bool > ; # [doc = "Field `ISFIF` writer - Inconsistent Sync Field Interrupt Flag"]
pub type ISFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXSIF` reader - Receive Start Interrupt"]
pub type RXSIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Complete Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
pub fn wfb (& self) -> WFB_R { WFB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
pub fn bdf (& self) -> BDF_R { BDF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
pub fn isfif (& self) -> ISFIF_R { ISFIF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receive Start Interrupt"]
# [inline (always)]
pub fn rxsif (& self) -> RXSIF_R { RXSIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Complete Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Wait For Break"]
# [inline (always)]
# [must_use]
pub fn wfb (& mut self) -> WFB_W < 0 > { WFB_W :: new (self) } # [doc = "Bit 1 - Break Detected Flag"]
# [inline (always)]
# [must_use]
pub fn bdf (& mut self) -> BDF_W < 1 > { BDF_W :: new (self) } # [doc = "Bit 3 - Inconsistent Sync Field Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn isfif (& mut self) -> ISFIF_W < 3 > { ISFIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAH (rw) register accessor: an alias for `Reg<TXDATAH_SPEC>`"]
pub type TXDATAH = crate :: Reg < txdatah :: TXDATAH_SPEC > ; # [doc = "Transmit Data High Byte"]
pub mod txdatah { # [doc = "Register `TXDATAH` reader"]
pub struct R (crate :: R < TXDATAH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAH_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAH` writer"]
pub struct W (crate :: W < TXDATAH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAH_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA8` reader - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_R = crate :: BitReader < bool > ; # [doc = "Field `DATA8` writer - Transmit Data Register (CHSIZE=9bit)"]
pub type DATA8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TXDATAH_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
pub fn data8 (& self) -> DATA8_R { DATA8_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit Data Register (CHSIZE=9bit)"]
# [inline (always)]
# [must_use]
pub fn data8 (& mut self) -> DATA8_W < 0 > { DATA8_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transmit Data High Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatah](index.html) module"]
pub struct TXDATAH_SPEC ; impl crate :: RegisterSpec for TXDATAH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatah::R](R) reader structure"]
impl crate :: Readable for TXDATAH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatah::W](W) writer structure"]
impl crate :: Writable for TXDATAH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAH to value 0"]
impl crate :: Resettable for TXDATAH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXDATAL (rw) register accessor: an alias for `Reg<TXDATAL_SPEC>`"]
pub type TXDATAL = crate :: Reg < txdatal :: TXDATAL_SPEC > ; # [doc = "Transmit Data Low Byte"]
pub mod txdatal { # [doc = "Register `TXDATAL` reader"]
pub struct R (crate :: R < TXDATAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXDATAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXDATAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXDATAL` writer"]
pub struct W (crate :: W < TXDATAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXDATAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXDATAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXDATAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Transmit Data Register"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DATA` writer - Transmit Data Register"]
pub type DATA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXDATAL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit Data Register"]
# [inline (always)]
# [must_use]
pub fn data (& mut self) -> DATA_W < 0 > { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Transmit Data Low Byte\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdatal](index.html) module"]
pub struct TXDATAL_SPEC ; impl crate :: RegisterSpec for TXDATAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txdatal::R](R) reader structure"]
impl crate :: Readable for TXDATAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txdatal::W](W) writer structure"]
impl crate :: Writable for TXDATAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXDATAL to value 0"]
impl crate :: Resettable for TXDATAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXPLCTRL (rw) register accessor: an alias for `Reg<TXPLCTRL_SPEC>`"]
pub type TXPLCTRL = crate :: Reg < txplctrl :: TXPLCTRL_SPEC > ; # [doc = "IRCOM Transmitter Pulse Length Control"]
pub mod txplctrl { # [doc = "Register `TXPLCTRL` reader"]
pub struct R (crate :: R < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXPLCTRL` writer"]
pub struct W (crate :: W < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXPLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXPL` reader - Transmit pulse length"]
pub type TXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TXPL` writer - Transmit pulse length"]
pub type TXPL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TXPLCTRL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
pub fn txpl (& self) -> TXPL_R { TXPL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Transmit pulse length"]
# [inline (always)]
# [must_use]
pub fn txpl (& mut self) -> TXPL_W < 0 > { TXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "IRCOM Transmitter Pulse Length Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txplctrl](index.html) module"]
pub struct TXPLCTRL_SPEC ; impl crate :: RegisterSpec for TXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txplctrl::R](R) reader structure"]
impl crate :: Readable for TXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txplctrl::W](W) writer structure"]
impl crate :: Writable for TXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXPLCTRL to value 0"]
impl crate :: Resettable for TXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "User Row"]
pub struct USERROW { _marker : PhantomData < * const () > } unsafe impl Send for USERROW { } impl USERROW { # [doc = r"Pointer to the register block"]
pub const PTR : * const userrow :: RegisterBlock = 0x1300 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const userrow :: RegisterBlock { Self :: PTR } } impl Deref for USERROW { type Target = userrow :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USERROW { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USERROW") . finish () } } # [doc = "User Row"]
pub mod userrow { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - User Row Byte 0"]
pub userrow0 : USERROW0 , # [doc = "0x01 - User Row Byte 1"]
pub userrow1 : USERROW1 , # [doc = "0x02 - User Row Byte 2"]
pub userrow2 : USERROW2 , # [doc = "0x03 - User Row Byte 3"]
pub userrow3 : USERROW3 , # [doc = "0x04 - User Row Byte 4"]
pub userrow4 : USERROW4 , # [doc = "0x05 - User Row Byte 5"]
pub userrow5 : USERROW5 , # [doc = "0x06 - User Row Byte 6"]
pub userrow6 : USERROW6 , # [doc = "0x07 - User Row Byte 7"]
pub userrow7 : USERROW7 , # [doc = "0x08 - User Row Byte 8"]
pub userrow8 : USERROW8 , # [doc = "0x09 - User Row Byte 9"]
pub userrow9 : USERROW9 , # [doc = "0x0a - User Row Byte 10"]
pub userrow10 : USERROW10 , # [doc = "0x0b - User Row Byte 11"]
pub userrow11 : USERROW11 , # [doc = "0x0c - User Row Byte 12"]
pub userrow12 : USERROW12 , # [doc = "0x0d - User Row Byte 13"]
pub userrow13 : USERROW13 , # [doc = "0x0e - User Row Byte 14"]
pub userrow14 : USERROW14 , # [doc = "0x0f - User Row Byte 15"]
pub userrow15 : USERROW15 , # [doc = "0x10 - User Row Byte 16"]
pub userrow16 : USERROW16 , # [doc = "0x11 - User Row Byte 17"]
pub userrow17 : USERROW17 , # [doc = "0x12 - User Row Byte 18"]
pub userrow18 : USERROW18 , # [doc = "0x13 - User Row Byte 19"]
pub userrow19 : USERROW19 , # [doc = "0x14 - User Row Byte 20"]
pub userrow20 : USERROW20 , # [doc = "0x15 - User Row Byte 21"]
pub userrow21 : USERROW21 , # [doc = "0x16 - User Row Byte 22"]
pub userrow22 : USERROW22 , # [doc = "0x17 - User Row Byte 23"]
pub userrow23 : USERROW23 , # [doc = "0x18 - User Row Byte 24"]
pub userrow24 : USERROW24 , # [doc = "0x19 - User Row Byte 25"]
pub userrow25 : USERROW25 , # [doc = "0x1a - User Row Byte 26"]
pub userrow26 : USERROW26 , # [doc = "0x1b - User Row Byte 27"]
pub userrow27 : USERROW27 , # [doc = "0x1c - User Row Byte 28"]
pub userrow28 : USERROW28 , # [doc = "0x1d - User Row Byte 29"]
pub userrow29 : USERROW29 , # [doc = "0x1e - User Row Byte 30"]
pub userrow30 : USERROW30 , # [doc = "0x1f - User Row Byte 31"]
pub userrow31 : USERROW31 , # [doc = "0x20 - User Row Byte 32"]
pub userrow32 : USERROW32 , # [doc = "0x21 - User Row Byte 33"]
pub userrow33 : USERROW33 , # [doc = "0x22 - User Row Byte 34"]
pub userrow34 : USERROW34 , # [doc = "0x23 - User Row Byte 35"]
pub userrow35 : USERROW35 , # [doc = "0x24 - User Row Byte 36"]
pub userrow36 : USERROW36 , # [doc = "0x25 - User Row Byte 37"]
pub userrow37 : USERROW37 , # [doc = "0x26 - User Row Byte 38"]
pub userrow38 : USERROW38 , # [doc = "0x27 - User Row Byte 39"]
pub userrow39 : USERROW39 , # [doc = "0x28 - User Row Byte 40"]
pub userrow40 : USERROW40 , # [doc = "0x29 - User Row Byte 41"]
pub userrow41 : USERROW41 , # [doc = "0x2a - User Row Byte 42"]
pub userrow42 : USERROW42 , # [doc = "0x2b - User Row Byte 43"]
pub userrow43 : USERROW43 , # [doc = "0x2c - User Row Byte 44"]
pub userrow44 : USERROW44 , # [doc = "0x2d - User Row Byte 45"]
pub userrow45 : USERROW45 , # [doc = "0x2e - User Row Byte 46"]
pub userrow46 : USERROW46 , # [doc = "0x2f - User Row Byte 47"]
pub userrow47 : USERROW47 , # [doc = "0x30 - User Row Byte 48"]
pub userrow48 : USERROW48 , # [doc = "0x31 - User Row Byte 49"]
pub userrow49 : USERROW49 , # [doc = "0x32 - User Row Byte 50"]
pub userrow50 : USERROW50 , # [doc = "0x33 - User Row Byte 51"]
pub userrow51 : USERROW51 , # [doc = "0x34 - User Row Byte 52"]
pub userrow52 : USERROW52 , # [doc = "0x35 - User Row Byte 53"]
pub userrow53 : USERROW53 , # [doc = "0x36 - User Row Byte 54"]
pub userrow54 : USERROW54 , # [doc = "0x37 - User Row Byte 55"]
pub userrow55 : USERROW55 , # [doc = "0x38 - User Row Byte 56"]
pub userrow56 : USERROW56 , # [doc = "0x39 - User Row Byte 57"]
pub userrow57 : USERROW57 , # [doc = "0x3a - User Row Byte 58"]
pub userrow58 : USERROW58 , # [doc = "0x3b - User Row Byte 59"]
pub userrow59 : USERROW59 , # [doc = "0x3c - User Row Byte 60"]
pub userrow60 : USERROW60 , # [doc = "0x3d - User Row Byte 61"]
pub userrow61 : USERROW61 , # [doc = "0x3e - User Row Byte 62"]
pub userrow62 : USERROW62 , # [doc = "0x3f - User Row Byte 63"]
pub userrow63 : USERROW63 , } # [doc = "USERROW0 (rw) register accessor: an alias for `Reg<USERROW0_SPEC>`"]
pub type USERROW0 = crate :: Reg < userrow0 :: USERROW0_SPEC > ; # [doc = "User Row Byte 0"]
pub mod userrow0 { # [doc = "Register `USERROW0` reader"]
pub struct R (crate :: R < USERROW0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW0_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW0` writer"]
pub struct W (crate :: W < USERROW0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow0](index.html) module"]
pub struct USERROW0_SPEC ; impl crate :: RegisterSpec for USERROW0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow0::R](R) reader structure"]
impl crate :: Readable for USERROW0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow0::W](W) writer structure"]
impl crate :: Writable for USERROW0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW0 to value 0"]
impl crate :: Resettable for USERROW0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW1 (rw) register accessor: an alias for `Reg<USERROW1_SPEC>`"]
pub type USERROW1 = crate :: Reg < userrow1 :: USERROW1_SPEC > ; # [doc = "User Row Byte 1"]
pub mod userrow1 { # [doc = "Register `USERROW1` reader"]
pub struct R (crate :: R < USERROW1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW1_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW1` writer"]
pub struct W (crate :: W < USERROW1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow1](index.html) module"]
pub struct USERROW1_SPEC ; impl crate :: RegisterSpec for USERROW1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow1::R](R) reader structure"]
impl crate :: Readable for USERROW1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow1::W](W) writer structure"]
impl crate :: Writable for USERROW1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW1 to value 0"]
impl crate :: Resettable for USERROW1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW10 (rw) register accessor: an alias for `Reg<USERROW10_SPEC>`"]
pub type USERROW10 = crate :: Reg < userrow10 :: USERROW10_SPEC > ; # [doc = "User Row Byte 10"]
pub mod userrow10 { # [doc = "Register `USERROW10` reader"]
pub struct R (crate :: R < USERROW10_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW10_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW10_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW10_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW10` writer"]
pub struct W (crate :: W < USERROW10_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW10_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW10_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW10_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 10\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow10](index.html) module"]
pub struct USERROW10_SPEC ; impl crate :: RegisterSpec for USERROW10_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow10::R](R) reader structure"]
impl crate :: Readable for USERROW10_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow10::W](W) writer structure"]
impl crate :: Writable for USERROW10_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW10 to value 0"]
impl crate :: Resettable for USERROW10_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW11 (rw) register accessor: an alias for `Reg<USERROW11_SPEC>`"]
pub type USERROW11 = crate :: Reg < userrow11 :: USERROW11_SPEC > ; # [doc = "User Row Byte 11"]
pub mod userrow11 { # [doc = "Register `USERROW11` reader"]
pub struct R (crate :: R < USERROW11_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW11_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW11_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW11_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW11` writer"]
pub struct W (crate :: W < USERROW11_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW11_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW11_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW11_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 11\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow11](index.html) module"]
pub struct USERROW11_SPEC ; impl crate :: RegisterSpec for USERROW11_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow11::R](R) reader structure"]
impl crate :: Readable for USERROW11_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow11::W](W) writer structure"]
impl crate :: Writable for USERROW11_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW11 to value 0"]
impl crate :: Resettable for USERROW11_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW12 (rw) register accessor: an alias for `Reg<USERROW12_SPEC>`"]
pub type USERROW12 = crate :: Reg < userrow12 :: USERROW12_SPEC > ; # [doc = "User Row Byte 12"]
pub mod userrow12 { # [doc = "Register `USERROW12` reader"]
pub struct R (crate :: R < USERROW12_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW12_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW12_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW12_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW12` writer"]
pub struct W (crate :: W < USERROW12_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW12_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW12_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW12_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 12\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow12](index.html) module"]
pub struct USERROW12_SPEC ; impl crate :: RegisterSpec for USERROW12_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow12::R](R) reader structure"]
impl crate :: Readable for USERROW12_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow12::W](W) writer structure"]
impl crate :: Writable for USERROW12_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW12 to value 0"]
impl crate :: Resettable for USERROW12_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW13 (rw) register accessor: an alias for `Reg<USERROW13_SPEC>`"]
pub type USERROW13 = crate :: Reg < userrow13 :: USERROW13_SPEC > ; # [doc = "User Row Byte 13"]
pub mod userrow13 { # [doc = "Register `USERROW13` reader"]
pub struct R (crate :: R < USERROW13_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW13_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW13_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW13_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW13` writer"]
pub struct W (crate :: W < USERROW13_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW13_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW13_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW13_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 13\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow13](index.html) module"]
pub struct USERROW13_SPEC ; impl crate :: RegisterSpec for USERROW13_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow13::R](R) reader structure"]
impl crate :: Readable for USERROW13_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow13::W](W) writer structure"]
impl crate :: Writable for USERROW13_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW13 to value 0"]
impl crate :: Resettable for USERROW13_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW14 (rw) register accessor: an alias for `Reg<USERROW14_SPEC>`"]
pub type USERROW14 = crate :: Reg < userrow14 :: USERROW14_SPEC > ; # [doc = "User Row Byte 14"]
pub mod userrow14 { # [doc = "Register `USERROW14` reader"]
pub struct R (crate :: R < USERROW14_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW14_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW14_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW14_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW14` writer"]
pub struct W (crate :: W < USERROW14_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW14_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW14_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW14_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 14\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow14](index.html) module"]
pub struct USERROW14_SPEC ; impl crate :: RegisterSpec for USERROW14_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow14::R](R) reader structure"]
impl crate :: Readable for USERROW14_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow14::W](W) writer structure"]
impl crate :: Writable for USERROW14_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW14 to value 0"]
impl crate :: Resettable for USERROW14_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW15 (rw) register accessor: an alias for `Reg<USERROW15_SPEC>`"]
pub type USERROW15 = crate :: Reg < userrow15 :: USERROW15_SPEC > ; # [doc = "User Row Byte 15"]
pub mod userrow15 { # [doc = "Register `USERROW15` reader"]
pub struct R (crate :: R < USERROW15_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW15_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW15_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW15_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW15` writer"]
pub struct W (crate :: W < USERROW15_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW15_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW15_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW15_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 15\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow15](index.html) module"]
pub struct USERROW15_SPEC ; impl crate :: RegisterSpec for USERROW15_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow15::R](R) reader structure"]
impl crate :: Readable for USERROW15_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow15::W](W) writer structure"]
impl crate :: Writable for USERROW15_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW15 to value 0"]
impl crate :: Resettable for USERROW15_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW16 (rw) register accessor: an alias for `Reg<USERROW16_SPEC>`"]
pub type USERROW16 = crate :: Reg < userrow16 :: USERROW16_SPEC > ; # [doc = "User Row Byte 16"]
pub mod userrow16 { # [doc = "Register `USERROW16` reader"]
pub struct R (crate :: R < USERROW16_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW16_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW16_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW16_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW16` writer"]
pub struct W (crate :: W < USERROW16_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW16_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW16_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW16_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 16\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow16](index.html) module"]
pub struct USERROW16_SPEC ; impl crate :: RegisterSpec for USERROW16_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow16::R](R) reader structure"]
impl crate :: Readable for USERROW16_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow16::W](W) writer structure"]
impl crate :: Writable for USERROW16_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW16 to value 0"]
impl crate :: Resettable for USERROW16_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW17 (rw) register accessor: an alias for `Reg<USERROW17_SPEC>`"]
pub type USERROW17 = crate :: Reg < userrow17 :: USERROW17_SPEC > ; # [doc = "User Row Byte 17"]
pub mod userrow17 { # [doc = "Register `USERROW17` reader"]
pub struct R (crate :: R < USERROW17_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW17_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW17_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW17_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW17` writer"]
pub struct W (crate :: W < USERROW17_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW17_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW17_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW17_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 17\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow17](index.html) module"]
pub struct USERROW17_SPEC ; impl crate :: RegisterSpec for USERROW17_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow17::R](R) reader structure"]
impl crate :: Readable for USERROW17_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow17::W](W) writer structure"]
impl crate :: Writable for USERROW17_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW17 to value 0"]
impl crate :: Resettable for USERROW17_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW18 (rw) register accessor: an alias for `Reg<USERROW18_SPEC>`"]
pub type USERROW18 = crate :: Reg < userrow18 :: USERROW18_SPEC > ; # [doc = "User Row Byte 18"]
pub mod userrow18 { # [doc = "Register `USERROW18` reader"]
pub struct R (crate :: R < USERROW18_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW18_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW18_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW18_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW18` writer"]
pub struct W (crate :: W < USERROW18_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW18_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW18_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW18_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 18\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow18](index.html) module"]
pub struct USERROW18_SPEC ; impl crate :: RegisterSpec for USERROW18_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow18::R](R) reader structure"]
impl crate :: Readable for USERROW18_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow18::W](W) writer structure"]
impl crate :: Writable for USERROW18_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW18 to value 0"]
impl crate :: Resettable for USERROW18_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW19 (rw) register accessor: an alias for `Reg<USERROW19_SPEC>`"]
pub type USERROW19 = crate :: Reg < userrow19 :: USERROW19_SPEC > ; # [doc = "User Row Byte 19"]
pub mod userrow19 { # [doc = "Register `USERROW19` reader"]
pub struct R (crate :: R < USERROW19_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW19_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW19_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW19_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW19` writer"]
pub struct W (crate :: W < USERROW19_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW19_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW19_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW19_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 19\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow19](index.html) module"]
pub struct USERROW19_SPEC ; impl crate :: RegisterSpec for USERROW19_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow19::R](R) reader structure"]
impl crate :: Readable for USERROW19_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow19::W](W) writer structure"]
impl crate :: Writable for USERROW19_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW19 to value 0"]
impl crate :: Resettable for USERROW19_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW2 (rw) register accessor: an alias for `Reg<USERROW2_SPEC>`"]
pub type USERROW2 = crate :: Reg < userrow2 :: USERROW2_SPEC > ; # [doc = "User Row Byte 2"]
pub mod userrow2 { # [doc = "Register `USERROW2` reader"]
pub struct R (crate :: R < USERROW2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW2_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW2` writer"]
pub struct W (crate :: W < USERROW2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow2](index.html) module"]
pub struct USERROW2_SPEC ; impl crate :: RegisterSpec for USERROW2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow2::R](R) reader structure"]
impl crate :: Readable for USERROW2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow2::W](W) writer structure"]
impl crate :: Writable for USERROW2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW2 to value 0"]
impl crate :: Resettable for USERROW2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW20 (rw) register accessor: an alias for `Reg<USERROW20_SPEC>`"]
pub type USERROW20 = crate :: Reg < userrow20 :: USERROW20_SPEC > ; # [doc = "User Row Byte 20"]
pub mod userrow20 { # [doc = "Register `USERROW20` reader"]
pub struct R (crate :: R < USERROW20_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW20_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW20_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW20_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW20` writer"]
pub struct W (crate :: W < USERROW20_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW20_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW20_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW20_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 20\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow20](index.html) module"]
pub struct USERROW20_SPEC ; impl crate :: RegisterSpec for USERROW20_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow20::R](R) reader structure"]
impl crate :: Readable for USERROW20_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow20::W](W) writer structure"]
impl crate :: Writable for USERROW20_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW20 to value 0"]
impl crate :: Resettable for USERROW20_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW21 (rw) register accessor: an alias for `Reg<USERROW21_SPEC>`"]
pub type USERROW21 = crate :: Reg < userrow21 :: USERROW21_SPEC > ; # [doc = "User Row Byte 21"]
pub mod userrow21 { # [doc = "Register `USERROW21` reader"]
pub struct R (crate :: R < USERROW21_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW21_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW21_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW21_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW21` writer"]
pub struct W (crate :: W < USERROW21_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW21_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW21_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW21_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 21\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow21](index.html) module"]
pub struct USERROW21_SPEC ; impl crate :: RegisterSpec for USERROW21_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow21::R](R) reader structure"]
impl crate :: Readable for USERROW21_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow21::W](W) writer structure"]
impl crate :: Writable for USERROW21_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW21 to value 0"]
impl crate :: Resettable for USERROW21_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW22 (rw) register accessor: an alias for `Reg<USERROW22_SPEC>`"]
pub type USERROW22 = crate :: Reg < userrow22 :: USERROW22_SPEC > ; # [doc = "User Row Byte 22"]
pub mod userrow22 { # [doc = "Register `USERROW22` reader"]
pub struct R (crate :: R < USERROW22_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW22_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW22_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW22_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW22` writer"]
pub struct W (crate :: W < USERROW22_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW22_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW22_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW22_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 22\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow22](index.html) module"]
pub struct USERROW22_SPEC ; impl crate :: RegisterSpec for USERROW22_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow22::R](R) reader structure"]
impl crate :: Readable for USERROW22_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow22::W](W) writer structure"]
impl crate :: Writable for USERROW22_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW22 to value 0"]
impl crate :: Resettable for USERROW22_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW23 (rw) register accessor: an alias for `Reg<USERROW23_SPEC>`"]
pub type USERROW23 = crate :: Reg < userrow23 :: USERROW23_SPEC > ; # [doc = "User Row Byte 23"]
pub mod userrow23 { # [doc = "Register `USERROW23` reader"]
pub struct R (crate :: R < USERROW23_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW23_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW23_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW23_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW23` writer"]
pub struct W (crate :: W < USERROW23_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW23_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW23_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW23_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 23\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow23](index.html) module"]
pub struct USERROW23_SPEC ; impl crate :: RegisterSpec for USERROW23_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow23::R](R) reader structure"]
impl crate :: Readable for USERROW23_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow23::W](W) writer structure"]
impl crate :: Writable for USERROW23_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW23 to value 0"]
impl crate :: Resettable for USERROW23_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW24 (rw) register accessor: an alias for `Reg<USERROW24_SPEC>`"]
pub type USERROW24 = crate :: Reg < userrow24 :: USERROW24_SPEC > ; # [doc = "User Row Byte 24"]
pub mod userrow24 { # [doc = "Register `USERROW24` reader"]
pub struct R (crate :: R < USERROW24_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW24_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW24_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW24_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW24` writer"]
pub struct W (crate :: W < USERROW24_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW24_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW24_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW24_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 24\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow24](index.html) module"]
pub struct USERROW24_SPEC ; impl crate :: RegisterSpec for USERROW24_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow24::R](R) reader structure"]
impl crate :: Readable for USERROW24_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow24::W](W) writer structure"]
impl crate :: Writable for USERROW24_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW24 to value 0"]
impl crate :: Resettable for USERROW24_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW25 (rw) register accessor: an alias for `Reg<USERROW25_SPEC>`"]
pub type USERROW25 = crate :: Reg < userrow25 :: USERROW25_SPEC > ; # [doc = "User Row Byte 25"]
pub mod userrow25 { # [doc = "Register `USERROW25` reader"]
pub struct R (crate :: R < USERROW25_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW25_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW25_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW25_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW25` writer"]
pub struct W (crate :: W < USERROW25_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW25_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW25_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW25_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 25\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow25](index.html) module"]
pub struct USERROW25_SPEC ; impl crate :: RegisterSpec for USERROW25_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow25::R](R) reader structure"]
impl crate :: Readable for USERROW25_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow25::W](W) writer structure"]
impl crate :: Writable for USERROW25_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW25 to value 0"]
impl crate :: Resettable for USERROW25_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW26 (rw) register accessor: an alias for `Reg<USERROW26_SPEC>`"]
pub type USERROW26 = crate :: Reg < userrow26 :: USERROW26_SPEC > ; # [doc = "User Row Byte 26"]
pub mod userrow26 { # [doc = "Register `USERROW26` reader"]
pub struct R (crate :: R < USERROW26_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW26_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW26_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW26_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW26` writer"]
pub struct W (crate :: W < USERROW26_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW26_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW26_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW26_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 26\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow26](index.html) module"]
pub struct USERROW26_SPEC ; impl crate :: RegisterSpec for USERROW26_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow26::R](R) reader structure"]
impl crate :: Readable for USERROW26_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow26::W](W) writer structure"]
impl crate :: Writable for USERROW26_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW26 to value 0"]
impl crate :: Resettable for USERROW26_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW27 (rw) register accessor: an alias for `Reg<USERROW27_SPEC>`"]
pub type USERROW27 = crate :: Reg < userrow27 :: USERROW27_SPEC > ; # [doc = "User Row Byte 27"]
pub mod userrow27 { # [doc = "Register `USERROW27` reader"]
pub struct R (crate :: R < USERROW27_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW27_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW27_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW27_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW27` writer"]
pub struct W (crate :: W < USERROW27_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW27_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW27_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW27_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 27\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow27](index.html) module"]
pub struct USERROW27_SPEC ; impl crate :: RegisterSpec for USERROW27_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow27::R](R) reader structure"]
impl crate :: Readable for USERROW27_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow27::W](W) writer structure"]
impl crate :: Writable for USERROW27_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW27 to value 0"]
impl crate :: Resettable for USERROW27_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW28 (rw) register accessor: an alias for `Reg<USERROW28_SPEC>`"]
pub type USERROW28 = crate :: Reg < userrow28 :: USERROW28_SPEC > ; # [doc = "User Row Byte 28"]
pub mod userrow28 { # [doc = "Register `USERROW28` reader"]
pub struct R (crate :: R < USERROW28_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW28_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW28_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW28_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW28` writer"]
pub struct W (crate :: W < USERROW28_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW28_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW28_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW28_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 28\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow28](index.html) module"]
pub struct USERROW28_SPEC ; impl crate :: RegisterSpec for USERROW28_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow28::R](R) reader structure"]
impl crate :: Readable for USERROW28_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow28::W](W) writer structure"]
impl crate :: Writable for USERROW28_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW28 to value 0"]
impl crate :: Resettable for USERROW28_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW29 (rw) register accessor: an alias for `Reg<USERROW29_SPEC>`"]
pub type USERROW29 = crate :: Reg < userrow29 :: USERROW29_SPEC > ; # [doc = "User Row Byte 29"]
pub mod userrow29 { # [doc = "Register `USERROW29` reader"]
pub struct R (crate :: R < USERROW29_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW29_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW29_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW29_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW29` writer"]
pub struct W (crate :: W < USERROW29_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW29_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW29_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW29_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 29\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow29](index.html) module"]
pub struct USERROW29_SPEC ; impl crate :: RegisterSpec for USERROW29_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow29::R](R) reader structure"]
impl crate :: Readable for USERROW29_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow29::W](W) writer structure"]
impl crate :: Writable for USERROW29_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW29 to value 0"]
impl crate :: Resettable for USERROW29_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW3 (rw) register accessor: an alias for `Reg<USERROW3_SPEC>`"]
pub type USERROW3 = crate :: Reg < userrow3 :: USERROW3_SPEC > ; # [doc = "User Row Byte 3"]
pub mod userrow3 { # [doc = "Register `USERROW3` reader"]
pub struct R (crate :: R < USERROW3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW3_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW3` writer"]
pub struct W (crate :: W < USERROW3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow3](index.html) module"]
pub struct USERROW3_SPEC ; impl crate :: RegisterSpec for USERROW3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow3::R](R) reader structure"]
impl crate :: Readable for USERROW3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow3::W](W) writer structure"]
impl crate :: Writable for USERROW3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW3 to value 0"]
impl crate :: Resettable for USERROW3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW30 (rw) register accessor: an alias for `Reg<USERROW30_SPEC>`"]
pub type USERROW30 = crate :: Reg < userrow30 :: USERROW30_SPEC > ; # [doc = "User Row Byte 30"]
pub mod userrow30 { # [doc = "Register `USERROW30` reader"]
pub struct R (crate :: R < USERROW30_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW30_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW30_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW30_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW30` writer"]
pub struct W (crate :: W < USERROW30_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW30_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW30_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW30_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 30\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow30](index.html) module"]
pub struct USERROW30_SPEC ; impl crate :: RegisterSpec for USERROW30_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow30::R](R) reader structure"]
impl crate :: Readable for USERROW30_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow30::W](W) writer structure"]
impl crate :: Writable for USERROW30_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW30 to value 0"]
impl crate :: Resettable for USERROW30_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW31 (rw) register accessor: an alias for `Reg<USERROW31_SPEC>`"]
pub type USERROW31 = crate :: Reg < userrow31 :: USERROW31_SPEC > ; # [doc = "User Row Byte 31"]
pub mod userrow31 { # [doc = "Register `USERROW31` reader"]
pub struct R (crate :: R < USERROW31_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW31_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW31_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW31_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW31` writer"]
pub struct W (crate :: W < USERROW31_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW31_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW31_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW31_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 31\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow31](index.html) module"]
pub struct USERROW31_SPEC ; impl crate :: RegisterSpec for USERROW31_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow31::R](R) reader structure"]
impl crate :: Readable for USERROW31_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow31::W](W) writer structure"]
impl crate :: Writable for USERROW31_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW31 to value 0"]
impl crate :: Resettable for USERROW31_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW32 (rw) register accessor: an alias for `Reg<USERROW32_SPEC>`"]
pub type USERROW32 = crate :: Reg < userrow32 :: USERROW32_SPEC > ; # [doc = "User Row Byte 32"]
pub mod userrow32 { # [doc = "Register `USERROW32` reader"]
pub struct R (crate :: R < USERROW32_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW32_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW32_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW32_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW32` writer"]
pub struct W (crate :: W < USERROW32_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW32_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW32_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW32_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 32\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow32](index.html) module"]
pub struct USERROW32_SPEC ; impl crate :: RegisterSpec for USERROW32_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow32::R](R) reader structure"]
impl crate :: Readable for USERROW32_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow32::W](W) writer structure"]
impl crate :: Writable for USERROW32_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW32 to value 0"]
impl crate :: Resettable for USERROW32_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW33 (rw) register accessor: an alias for `Reg<USERROW33_SPEC>`"]
pub type USERROW33 = crate :: Reg < userrow33 :: USERROW33_SPEC > ; # [doc = "User Row Byte 33"]
pub mod userrow33 { # [doc = "Register `USERROW33` reader"]
pub struct R (crate :: R < USERROW33_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW33_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW33_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW33_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW33` writer"]
pub struct W (crate :: W < USERROW33_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW33_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW33_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW33_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 33\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow33](index.html) module"]
pub struct USERROW33_SPEC ; impl crate :: RegisterSpec for USERROW33_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow33::R](R) reader structure"]
impl crate :: Readable for USERROW33_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow33::W](W) writer structure"]
impl crate :: Writable for USERROW33_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW33 to value 0"]
impl crate :: Resettable for USERROW33_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW34 (rw) register accessor: an alias for `Reg<USERROW34_SPEC>`"]
pub type USERROW34 = crate :: Reg < userrow34 :: USERROW34_SPEC > ; # [doc = "User Row Byte 34"]
pub mod userrow34 { # [doc = "Register `USERROW34` reader"]
pub struct R (crate :: R < USERROW34_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW34_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW34_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW34_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW34` writer"]
pub struct W (crate :: W < USERROW34_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW34_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW34_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW34_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 34\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow34](index.html) module"]
pub struct USERROW34_SPEC ; impl crate :: RegisterSpec for USERROW34_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow34::R](R) reader structure"]
impl crate :: Readable for USERROW34_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow34::W](W) writer structure"]
impl crate :: Writable for USERROW34_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW34 to value 0"]
impl crate :: Resettable for USERROW34_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW35 (rw) register accessor: an alias for `Reg<USERROW35_SPEC>`"]
pub type USERROW35 = crate :: Reg < userrow35 :: USERROW35_SPEC > ; # [doc = "User Row Byte 35"]
pub mod userrow35 { # [doc = "Register `USERROW35` reader"]
pub struct R (crate :: R < USERROW35_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW35_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW35_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW35_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW35` writer"]
pub struct W (crate :: W < USERROW35_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW35_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW35_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW35_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 35\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow35](index.html) module"]
pub struct USERROW35_SPEC ; impl crate :: RegisterSpec for USERROW35_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow35::R](R) reader structure"]
impl crate :: Readable for USERROW35_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow35::W](W) writer structure"]
impl crate :: Writable for USERROW35_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW35 to value 0"]
impl crate :: Resettable for USERROW35_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW36 (rw) register accessor: an alias for `Reg<USERROW36_SPEC>`"]
pub type USERROW36 = crate :: Reg < userrow36 :: USERROW36_SPEC > ; # [doc = "User Row Byte 36"]
pub mod userrow36 { # [doc = "Register `USERROW36` reader"]
pub struct R (crate :: R < USERROW36_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW36_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW36_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW36_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW36` writer"]
pub struct W (crate :: W < USERROW36_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW36_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW36_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW36_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 36\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow36](index.html) module"]
pub struct USERROW36_SPEC ; impl crate :: RegisterSpec for USERROW36_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow36::R](R) reader structure"]
impl crate :: Readable for USERROW36_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow36::W](W) writer structure"]
impl crate :: Writable for USERROW36_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW36 to value 0"]
impl crate :: Resettable for USERROW36_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW37 (rw) register accessor: an alias for `Reg<USERROW37_SPEC>`"]
pub type USERROW37 = crate :: Reg < userrow37 :: USERROW37_SPEC > ; # [doc = "User Row Byte 37"]
pub mod userrow37 { # [doc = "Register `USERROW37` reader"]
pub struct R (crate :: R < USERROW37_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW37_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW37_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW37_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW37` writer"]
pub struct W (crate :: W < USERROW37_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW37_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW37_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW37_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 37\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow37](index.html) module"]
pub struct USERROW37_SPEC ; impl crate :: RegisterSpec for USERROW37_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow37::R](R) reader structure"]
impl crate :: Readable for USERROW37_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow37::W](W) writer structure"]
impl crate :: Writable for USERROW37_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW37 to value 0"]
impl crate :: Resettable for USERROW37_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW38 (rw) register accessor: an alias for `Reg<USERROW38_SPEC>`"]
pub type USERROW38 = crate :: Reg < userrow38 :: USERROW38_SPEC > ; # [doc = "User Row Byte 38"]
pub mod userrow38 { # [doc = "Register `USERROW38` reader"]
pub struct R (crate :: R < USERROW38_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW38_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW38_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW38_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW38` writer"]
pub struct W (crate :: W < USERROW38_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW38_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW38_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW38_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 38\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow38](index.html) module"]
pub struct USERROW38_SPEC ; impl crate :: RegisterSpec for USERROW38_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow38::R](R) reader structure"]
impl crate :: Readable for USERROW38_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow38::W](W) writer structure"]
impl crate :: Writable for USERROW38_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW38 to value 0"]
impl crate :: Resettable for USERROW38_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW39 (rw) register accessor: an alias for `Reg<USERROW39_SPEC>`"]
pub type USERROW39 = crate :: Reg < userrow39 :: USERROW39_SPEC > ; # [doc = "User Row Byte 39"]
pub mod userrow39 { # [doc = "Register `USERROW39` reader"]
pub struct R (crate :: R < USERROW39_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW39_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW39_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW39_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW39` writer"]
pub struct W (crate :: W < USERROW39_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW39_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW39_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW39_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 39\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow39](index.html) module"]
pub struct USERROW39_SPEC ; impl crate :: RegisterSpec for USERROW39_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow39::R](R) reader structure"]
impl crate :: Readable for USERROW39_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow39::W](W) writer structure"]
impl crate :: Writable for USERROW39_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW39 to value 0"]
impl crate :: Resettable for USERROW39_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW4 (rw) register accessor: an alias for `Reg<USERROW4_SPEC>`"]
pub type USERROW4 = crate :: Reg < userrow4 :: USERROW4_SPEC > ; # [doc = "User Row Byte 4"]
pub mod userrow4 { # [doc = "Register `USERROW4` reader"]
pub struct R (crate :: R < USERROW4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW4_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW4` writer"]
pub struct W (crate :: W < USERROW4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW4_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow4](index.html) module"]
pub struct USERROW4_SPEC ; impl crate :: RegisterSpec for USERROW4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow4::R](R) reader structure"]
impl crate :: Readable for USERROW4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow4::W](W) writer structure"]
impl crate :: Writable for USERROW4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW4 to value 0"]
impl crate :: Resettable for USERROW4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW40 (rw) register accessor: an alias for `Reg<USERROW40_SPEC>`"]
pub type USERROW40 = crate :: Reg < userrow40 :: USERROW40_SPEC > ; # [doc = "User Row Byte 40"]
pub mod userrow40 { # [doc = "Register `USERROW40` reader"]
pub struct R (crate :: R < USERROW40_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW40_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW40_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW40_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW40` writer"]
pub struct W (crate :: W < USERROW40_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW40_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW40_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW40_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 40\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow40](index.html) module"]
pub struct USERROW40_SPEC ; impl crate :: RegisterSpec for USERROW40_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow40::R](R) reader structure"]
impl crate :: Readable for USERROW40_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow40::W](W) writer structure"]
impl crate :: Writable for USERROW40_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW40 to value 0"]
impl crate :: Resettable for USERROW40_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW41 (rw) register accessor: an alias for `Reg<USERROW41_SPEC>`"]
pub type USERROW41 = crate :: Reg < userrow41 :: USERROW41_SPEC > ; # [doc = "User Row Byte 41"]
pub mod userrow41 { # [doc = "Register `USERROW41` reader"]
pub struct R (crate :: R < USERROW41_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW41_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW41_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW41_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW41` writer"]
pub struct W (crate :: W < USERROW41_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW41_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW41_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW41_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 41\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow41](index.html) module"]
pub struct USERROW41_SPEC ; impl crate :: RegisterSpec for USERROW41_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow41::R](R) reader structure"]
impl crate :: Readable for USERROW41_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow41::W](W) writer structure"]
impl crate :: Writable for USERROW41_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW41 to value 0"]
impl crate :: Resettable for USERROW41_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW42 (rw) register accessor: an alias for `Reg<USERROW42_SPEC>`"]
pub type USERROW42 = crate :: Reg < userrow42 :: USERROW42_SPEC > ; # [doc = "User Row Byte 42"]
pub mod userrow42 { # [doc = "Register `USERROW42` reader"]
pub struct R (crate :: R < USERROW42_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW42_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW42_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW42_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW42` writer"]
pub struct W (crate :: W < USERROW42_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW42_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW42_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW42_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 42\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow42](index.html) module"]
pub struct USERROW42_SPEC ; impl crate :: RegisterSpec for USERROW42_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow42::R](R) reader structure"]
impl crate :: Readable for USERROW42_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow42::W](W) writer structure"]
impl crate :: Writable for USERROW42_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW42 to value 0"]
impl crate :: Resettable for USERROW42_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW43 (rw) register accessor: an alias for `Reg<USERROW43_SPEC>`"]
pub type USERROW43 = crate :: Reg < userrow43 :: USERROW43_SPEC > ; # [doc = "User Row Byte 43"]
pub mod userrow43 { # [doc = "Register `USERROW43` reader"]
pub struct R (crate :: R < USERROW43_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW43_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW43_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW43_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW43` writer"]
pub struct W (crate :: W < USERROW43_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW43_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW43_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW43_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 43\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow43](index.html) module"]
pub struct USERROW43_SPEC ; impl crate :: RegisterSpec for USERROW43_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow43::R](R) reader structure"]
impl crate :: Readable for USERROW43_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow43::W](W) writer structure"]
impl crate :: Writable for USERROW43_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW43 to value 0"]
impl crate :: Resettable for USERROW43_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW44 (rw) register accessor: an alias for `Reg<USERROW44_SPEC>`"]
pub type USERROW44 = crate :: Reg < userrow44 :: USERROW44_SPEC > ; # [doc = "User Row Byte 44"]
pub mod userrow44 { # [doc = "Register `USERROW44` reader"]
pub struct R (crate :: R < USERROW44_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW44_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW44_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW44_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW44` writer"]
pub struct W (crate :: W < USERROW44_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW44_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW44_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW44_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 44\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow44](index.html) module"]
pub struct USERROW44_SPEC ; impl crate :: RegisterSpec for USERROW44_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow44::R](R) reader structure"]
impl crate :: Readable for USERROW44_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow44::W](W) writer structure"]
impl crate :: Writable for USERROW44_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW44 to value 0"]
impl crate :: Resettable for USERROW44_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW45 (rw) register accessor: an alias for `Reg<USERROW45_SPEC>`"]
pub type USERROW45 = crate :: Reg < userrow45 :: USERROW45_SPEC > ; # [doc = "User Row Byte 45"]
pub mod userrow45 { # [doc = "Register `USERROW45` reader"]
pub struct R (crate :: R < USERROW45_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW45_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW45_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW45_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW45` writer"]
pub struct W (crate :: W < USERROW45_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW45_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW45_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW45_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 45\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow45](index.html) module"]
pub struct USERROW45_SPEC ; impl crate :: RegisterSpec for USERROW45_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow45::R](R) reader structure"]
impl crate :: Readable for USERROW45_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow45::W](W) writer structure"]
impl crate :: Writable for USERROW45_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW45 to value 0"]
impl crate :: Resettable for USERROW45_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW46 (rw) register accessor: an alias for `Reg<USERROW46_SPEC>`"]
pub type USERROW46 = crate :: Reg < userrow46 :: USERROW46_SPEC > ; # [doc = "User Row Byte 46"]
pub mod userrow46 { # [doc = "Register `USERROW46` reader"]
pub struct R (crate :: R < USERROW46_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW46_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW46_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW46_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW46` writer"]
pub struct W (crate :: W < USERROW46_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW46_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW46_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW46_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 46\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow46](index.html) module"]
pub struct USERROW46_SPEC ; impl crate :: RegisterSpec for USERROW46_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow46::R](R) reader structure"]
impl crate :: Readable for USERROW46_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow46::W](W) writer structure"]
impl crate :: Writable for USERROW46_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW46 to value 0"]
impl crate :: Resettable for USERROW46_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW47 (rw) register accessor: an alias for `Reg<USERROW47_SPEC>`"]
pub type USERROW47 = crate :: Reg < userrow47 :: USERROW47_SPEC > ; # [doc = "User Row Byte 47"]
pub mod userrow47 { # [doc = "Register `USERROW47` reader"]
pub struct R (crate :: R < USERROW47_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW47_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW47_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW47_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW47` writer"]
pub struct W (crate :: W < USERROW47_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW47_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW47_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW47_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 47\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow47](index.html) module"]
pub struct USERROW47_SPEC ; impl crate :: RegisterSpec for USERROW47_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow47::R](R) reader structure"]
impl crate :: Readable for USERROW47_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow47::W](W) writer structure"]
impl crate :: Writable for USERROW47_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW47 to value 0"]
impl crate :: Resettable for USERROW47_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW48 (rw) register accessor: an alias for `Reg<USERROW48_SPEC>`"]
pub type USERROW48 = crate :: Reg < userrow48 :: USERROW48_SPEC > ; # [doc = "User Row Byte 48"]
pub mod userrow48 { # [doc = "Register `USERROW48` reader"]
pub struct R (crate :: R < USERROW48_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW48_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW48_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW48_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW48` writer"]
pub struct W (crate :: W < USERROW48_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW48_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW48_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW48_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 48\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow48](index.html) module"]
pub struct USERROW48_SPEC ; impl crate :: RegisterSpec for USERROW48_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow48::R](R) reader structure"]
impl crate :: Readable for USERROW48_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow48::W](W) writer structure"]
impl crate :: Writable for USERROW48_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW48 to value 0"]
impl crate :: Resettable for USERROW48_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW49 (rw) register accessor: an alias for `Reg<USERROW49_SPEC>`"]
pub type USERROW49 = crate :: Reg < userrow49 :: USERROW49_SPEC > ; # [doc = "User Row Byte 49"]
pub mod userrow49 { # [doc = "Register `USERROW49` reader"]
pub struct R (crate :: R < USERROW49_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW49_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW49_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW49_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW49` writer"]
pub struct W (crate :: W < USERROW49_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW49_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW49_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW49_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 49\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow49](index.html) module"]
pub struct USERROW49_SPEC ; impl crate :: RegisterSpec for USERROW49_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow49::R](R) reader structure"]
impl crate :: Readable for USERROW49_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow49::W](W) writer structure"]
impl crate :: Writable for USERROW49_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW49 to value 0"]
impl crate :: Resettable for USERROW49_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW5 (rw) register accessor: an alias for `Reg<USERROW5_SPEC>`"]
pub type USERROW5 = crate :: Reg < userrow5 :: USERROW5_SPEC > ; # [doc = "User Row Byte 5"]
pub mod userrow5 { # [doc = "Register `USERROW5` reader"]
pub struct R (crate :: R < USERROW5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW5_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW5` writer"]
pub struct W (crate :: W < USERROW5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW5_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow5](index.html) module"]
pub struct USERROW5_SPEC ; impl crate :: RegisterSpec for USERROW5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow5::R](R) reader structure"]
impl crate :: Readable for USERROW5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow5::W](W) writer structure"]
impl crate :: Writable for USERROW5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW5 to value 0"]
impl crate :: Resettable for USERROW5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW50 (rw) register accessor: an alias for `Reg<USERROW50_SPEC>`"]
pub type USERROW50 = crate :: Reg < userrow50 :: USERROW50_SPEC > ; # [doc = "User Row Byte 50"]
pub mod userrow50 { # [doc = "Register `USERROW50` reader"]
pub struct R (crate :: R < USERROW50_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW50_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW50_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW50_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW50` writer"]
pub struct W (crate :: W < USERROW50_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW50_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW50_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW50_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 50\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow50](index.html) module"]
pub struct USERROW50_SPEC ; impl crate :: RegisterSpec for USERROW50_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow50::R](R) reader structure"]
impl crate :: Readable for USERROW50_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow50::W](W) writer structure"]
impl crate :: Writable for USERROW50_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW50 to value 0"]
impl crate :: Resettable for USERROW50_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW51 (rw) register accessor: an alias for `Reg<USERROW51_SPEC>`"]
pub type USERROW51 = crate :: Reg < userrow51 :: USERROW51_SPEC > ; # [doc = "User Row Byte 51"]
pub mod userrow51 { # [doc = "Register `USERROW51` reader"]
pub struct R (crate :: R < USERROW51_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW51_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW51_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW51_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW51` writer"]
pub struct W (crate :: W < USERROW51_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW51_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW51_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW51_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 51\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow51](index.html) module"]
pub struct USERROW51_SPEC ; impl crate :: RegisterSpec for USERROW51_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow51::R](R) reader structure"]
impl crate :: Readable for USERROW51_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow51::W](W) writer structure"]
impl crate :: Writable for USERROW51_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW51 to value 0"]
impl crate :: Resettable for USERROW51_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW52 (rw) register accessor: an alias for `Reg<USERROW52_SPEC>`"]
pub type USERROW52 = crate :: Reg < userrow52 :: USERROW52_SPEC > ; # [doc = "User Row Byte 52"]
pub mod userrow52 { # [doc = "Register `USERROW52` reader"]
pub struct R (crate :: R < USERROW52_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW52_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW52_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW52_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW52` writer"]
pub struct W (crate :: W < USERROW52_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW52_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW52_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW52_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 52\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow52](index.html) module"]
pub struct USERROW52_SPEC ; impl crate :: RegisterSpec for USERROW52_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow52::R](R) reader structure"]
impl crate :: Readable for USERROW52_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow52::W](W) writer structure"]
impl crate :: Writable for USERROW52_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW52 to value 0"]
impl crate :: Resettable for USERROW52_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW53 (rw) register accessor: an alias for `Reg<USERROW53_SPEC>`"]
pub type USERROW53 = crate :: Reg < userrow53 :: USERROW53_SPEC > ; # [doc = "User Row Byte 53"]
pub mod userrow53 { # [doc = "Register `USERROW53` reader"]
pub struct R (crate :: R < USERROW53_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW53_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW53_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW53_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW53` writer"]
pub struct W (crate :: W < USERROW53_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW53_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW53_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW53_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 53\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow53](index.html) module"]
pub struct USERROW53_SPEC ; impl crate :: RegisterSpec for USERROW53_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow53::R](R) reader structure"]
impl crate :: Readable for USERROW53_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow53::W](W) writer structure"]
impl crate :: Writable for USERROW53_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW53 to value 0"]
impl crate :: Resettable for USERROW53_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW54 (rw) register accessor: an alias for `Reg<USERROW54_SPEC>`"]
pub type USERROW54 = crate :: Reg < userrow54 :: USERROW54_SPEC > ; # [doc = "User Row Byte 54"]
pub mod userrow54 { # [doc = "Register `USERROW54` reader"]
pub struct R (crate :: R < USERROW54_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW54_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW54_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW54_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW54` writer"]
pub struct W (crate :: W < USERROW54_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW54_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW54_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW54_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 54\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow54](index.html) module"]
pub struct USERROW54_SPEC ; impl crate :: RegisterSpec for USERROW54_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow54::R](R) reader structure"]
impl crate :: Readable for USERROW54_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow54::W](W) writer structure"]
impl crate :: Writable for USERROW54_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW54 to value 0"]
impl crate :: Resettable for USERROW54_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW55 (rw) register accessor: an alias for `Reg<USERROW55_SPEC>`"]
pub type USERROW55 = crate :: Reg < userrow55 :: USERROW55_SPEC > ; # [doc = "User Row Byte 55"]
pub mod userrow55 { # [doc = "Register `USERROW55` reader"]
pub struct R (crate :: R < USERROW55_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW55_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW55_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW55_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW55` writer"]
pub struct W (crate :: W < USERROW55_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW55_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW55_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW55_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 55\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow55](index.html) module"]
pub struct USERROW55_SPEC ; impl crate :: RegisterSpec for USERROW55_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow55::R](R) reader structure"]
impl crate :: Readable for USERROW55_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow55::W](W) writer structure"]
impl crate :: Writable for USERROW55_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW55 to value 0"]
impl crate :: Resettable for USERROW55_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW56 (rw) register accessor: an alias for `Reg<USERROW56_SPEC>`"]
pub type USERROW56 = crate :: Reg < userrow56 :: USERROW56_SPEC > ; # [doc = "User Row Byte 56"]
pub mod userrow56 { # [doc = "Register `USERROW56` reader"]
pub struct R (crate :: R < USERROW56_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW56_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW56_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW56_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW56` writer"]
pub struct W (crate :: W < USERROW56_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW56_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW56_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW56_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 56\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow56](index.html) module"]
pub struct USERROW56_SPEC ; impl crate :: RegisterSpec for USERROW56_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow56::R](R) reader structure"]
impl crate :: Readable for USERROW56_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow56::W](W) writer structure"]
impl crate :: Writable for USERROW56_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW56 to value 0"]
impl crate :: Resettable for USERROW56_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW57 (rw) register accessor: an alias for `Reg<USERROW57_SPEC>`"]
pub type USERROW57 = crate :: Reg < userrow57 :: USERROW57_SPEC > ; # [doc = "User Row Byte 57"]
pub mod userrow57 { # [doc = "Register `USERROW57` reader"]
pub struct R (crate :: R < USERROW57_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW57_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW57_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW57_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW57` writer"]
pub struct W (crate :: W < USERROW57_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW57_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW57_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW57_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 57\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow57](index.html) module"]
pub struct USERROW57_SPEC ; impl crate :: RegisterSpec for USERROW57_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow57::R](R) reader structure"]
impl crate :: Readable for USERROW57_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow57::W](W) writer structure"]
impl crate :: Writable for USERROW57_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW57 to value 0"]
impl crate :: Resettable for USERROW57_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW58 (rw) register accessor: an alias for `Reg<USERROW58_SPEC>`"]
pub type USERROW58 = crate :: Reg < userrow58 :: USERROW58_SPEC > ; # [doc = "User Row Byte 58"]
pub mod userrow58 { # [doc = "Register `USERROW58` reader"]
pub struct R (crate :: R < USERROW58_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW58_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW58_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW58_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW58` writer"]
pub struct W (crate :: W < USERROW58_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW58_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW58_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW58_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 58\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow58](index.html) module"]
pub struct USERROW58_SPEC ; impl crate :: RegisterSpec for USERROW58_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow58::R](R) reader structure"]
impl crate :: Readable for USERROW58_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow58::W](W) writer structure"]
impl crate :: Writable for USERROW58_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW58 to value 0"]
impl crate :: Resettable for USERROW58_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW59 (rw) register accessor: an alias for `Reg<USERROW59_SPEC>`"]
pub type USERROW59 = crate :: Reg < userrow59 :: USERROW59_SPEC > ; # [doc = "User Row Byte 59"]
pub mod userrow59 { # [doc = "Register `USERROW59` reader"]
pub struct R (crate :: R < USERROW59_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW59_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW59_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW59_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW59` writer"]
pub struct W (crate :: W < USERROW59_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW59_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW59_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW59_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 59\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow59](index.html) module"]
pub struct USERROW59_SPEC ; impl crate :: RegisterSpec for USERROW59_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow59::R](R) reader structure"]
impl crate :: Readable for USERROW59_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow59::W](W) writer structure"]
impl crate :: Writable for USERROW59_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW59 to value 0"]
impl crate :: Resettable for USERROW59_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW6 (rw) register accessor: an alias for `Reg<USERROW6_SPEC>`"]
pub type USERROW6 = crate :: Reg < userrow6 :: USERROW6_SPEC > ; # [doc = "User Row Byte 6"]
pub mod userrow6 { # [doc = "Register `USERROW6` reader"]
pub struct R (crate :: R < USERROW6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW6_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW6` writer"]
pub struct W (crate :: W < USERROW6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW6_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow6](index.html) module"]
pub struct USERROW6_SPEC ; impl crate :: RegisterSpec for USERROW6_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow6::R](R) reader structure"]
impl crate :: Readable for USERROW6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow6::W](W) writer structure"]
impl crate :: Writable for USERROW6_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW6 to value 0"]
impl crate :: Resettable for USERROW6_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW60 (rw) register accessor: an alias for `Reg<USERROW60_SPEC>`"]
pub type USERROW60 = crate :: Reg < userrow60 :: USERROW60_SPEC > ; # [doc = "User Row Byte 60"]
pub mod userrow60 { # [doc = "Register `USERROW60` reader"]
pub struct R (crate :: R < USERROW60_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW60_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW60_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW60_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW60` writer"]
pub struct W (crate :: W < USERROW60_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW60_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW60_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW60_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 60\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow60](index.html) module"]
pub struct USERROW60_SPEC ; impl crate :: RegisterSpec for USERROW60_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow60::R](R) reader structure"]
impl crate :: Readable for USERROW60_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow60::W](W) writer structure"]
impl crate :: Writable for USERROW60_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW60 to value 0"]
impl crate :: Resettable for USERROW60_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW61 (rw) register accessor: an alias for `Reg<USERROW61_SPEC>`"]
pub type USERROW61 = crate :: Reg < userrow61 :: USERROW61_SPEC > ; # [doc = "User Row Byte 61"]
pub mod userrow61 { # [doc = "Register `USERROW61` reader"]
pub struct R (crate :: R < USERROW61_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW61_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW61_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW61_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW61` writer"]
pub struct W (crate :: W < USERROW61_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW61_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW61_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW61_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 61\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow61](index.html) module"]
pub struct USERROW61_SPEC ; impl crate :: RegisterSpec for USERROW61_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow61::R](R) reader structure"]
impl crate :: Readable for USERROW61_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow61::W](W) writer structure"]
impl crate :: Writable for USERROW61_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW61 to value 0"]
impl crate :: Resettable for USERROW61_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW62 (rw) register accessor: an alias for `Reg<USERROW62_SPEC>`"]
pub type USERROW62 = crate :: Reg < userrow62 :: USERROW62_SPEC > ; # [doc = "User Row Byte 62"]
pub mod userrow62 { # [doc = "Register `USERROW62` reader"]
pub struct R (crate :: R < USERROW62_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW62_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW62_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW62_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW62` writer"]
pub struct W (crate :: W < USERROW62_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW62_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW62_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW62_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 62\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow62](index.html) module"]
pub struct USERROW62_SPEC ; impl crate :: RegisterSpec for USERROW62_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow62::R](R) reader structure"]
impl crate :: Readable for USERROW62_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow62::W](W) writer structure"]
impl crate :: Writable for USERROW62_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW62 to value 0"]
impl crate :: Resettable for USERROW62_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW63 (rw) register accessor: an alias for `Reg<USERROW63_SPEC>`"]
pub type USERROW63 = crate :: Reg < userrow63 :: USERROW63_SPEC > ; # [doc = "User Row Byte 63"]
pub mod userrow63 { # [doc = "Register `USERROW63` reader"]
pub struct R (crate :: R < USERROW63_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW63_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW63_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW63_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW63` writer"]
pub struct W (crate :: W < USERROW63_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW63_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW63_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW63_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 63\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow63](index.html) module"]
pub struct USERROW63_SPEC ; impl crate :: RegisterSpec for USERROW63_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow63::R](R) reader structure"]
impl crate :: Readable for USERROW63_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow63::W](W) writer structure"]
impl crate :: Writable for USERROW63_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW63 to value 0"]
impl crate :: Resettable for USERROW63_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW7 (rw) register accessor: an alias for `Reg<USERROW7_SPEC>`"]
pub type USERROW7 = crate :: Reg < userrow7 :: USERROW7_SPEC > ; # [doc = "User Row Byte 7"]
pub mod userrow7 { # [doc = "Register `USERROW7` reader"]
pub struct R (crate :: R < USERROW7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW7_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW7` writer"]
pub struct W (crate :: W < USERROW7_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW7_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW7_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 7\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow7](index.html) module"]
pub struct USERROW7_SPEC ; impl crate :: RegisterSpec for USERROW7_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow7::R](R) reader structure"]
impl crate :: Readable for USERROW7_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow7::W](W) writer structure"]
impl crate :: Writable for USERROW7_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW7 to value 0"]
impl crate :: Resettable for USERROW7_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW8 (rw) register accessor: an alias for `Reg<USERROW8_SPEC>`"]
pub type USERROW8 = crate :: Reg < userrow8 :: USERROW8_SPEC > ; # [doc = "User Row Byte 8"]
pub mod userrow8 { # [doc = "Register `USERROW8` reader"]
pub struct R (crate :: R < USERROW8_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW8_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW8_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW8` writer"]
pub struct W (crate :: W < USERROW8_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW8_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW8_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 8\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow8](index.html) module"]
pub struct USERROW8_SPEC ; impl crate :: RegisterSpec for USERROW8_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow8::R](R) reader structure"]
impl crate :: Readable for USERROW8_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow8::W](W) writer structure"]
impl crate :: Writable for USERROW8_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW8 to value 0"]
impl crate :: Resettable for USERROW8_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "USERROW9 (rw) register accessor: an alias for `Reg<USERROW9_SPEC>`"]
pub type USERROW9 = crate :: Reg < userrow9 :: USERROW9_SPEC > ; # [doc = "User Row Byte 9"]
pub mod userrow9 { # [doc = "Register `USERROW9` reader"]
pub struct R (crate :: R < USERROW9_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USERROW9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USERROW9_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USERROW9_SPEC >) -> Self { R (reader) } } # [doc = "Register `USERROW9` writer"]
pub struct W (crate :: W < USERROW9_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USERROW9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USERROW9_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USERROW9_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "User Row Byte 9\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [userrow9](index.html) module"]
pub struct USERROW9_SPEC ; impl crate :: RegisterSpec for USERROW9_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [userrow9::R](R) reader structure"]
impl crate :: Readable for USERROW9_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [userrow9::W](W) writer structure"]
impl crate :: Writable for USERROW9_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets USERROW9 to value 0"]
impl crate :: Resettable for USERROW9_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTA { _marker : PhantomData < * const () > } unsafe impl Send for VPORTA { } impl VPORTA { # [doc = r"Pointer to the register block"]
pub const PTR : * const vporta :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vporta :: RegisterBlock { Self :: PTR } } impl Deref for VPORTA { type Target = vporta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTA") . finish () } } # [doc = "Virtual Ports"]
pub mod vporta { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTB { _marker : PhantomData < * const () > } unsafe impl Send for VPORTB { } impl VPORTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const vportb :: RegisterBlock = 0x04 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vportb :: RegisterBlock { Self :: PTR } } impl Deref for VPORTB { type Target = vportb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTB") . finish () } } # [doc = "Virtual Ports"]
pub mod vportb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTC { _marker : PhantomData < * const () > } unsafe impl Send for VPORTC { } impl VPORTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const vportc :: RegisterBlock = 0x08 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vportc :: RegisterBlock { Self :: PTR } } impl Deref for VPORTC { type Target = vportc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTC") . finish () } } # [doc = "Virtual Ports"]
pub mod vportc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTD { _marker : PhantomData < * const () > } unsafe impl Send for VPORTD { } impl VPORTD { # [doc = r"Pointer to the register block"]
pub const PTR : * const vportd :: RegisterBlock = 0x0c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vportd :: RegisterBlock { Self :: PTR } } impl Deref for VPORTD { type Target = vportd :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTD") . finish () } } # [doc = "Virtual Ports"]
pub mod vportd { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTE { _marker : PhantomData < * const () > } unsafe impl Send for VPORTE { } impl VPORTE { # [doc = r"Pointer to the register block"]
pub const PTR : * const vporte :: RegisterBlock = 0x10 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vporte :: RegisterBlock { Self :: PTR } } impl Deref for VPORTE { type Target = vporte :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTE") . finish () } } # [doc = "Virtual Ports"]
pub mod vporte { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Virtual Ports"]
pub struct VPORTF { _marker : PhantomData < * const () > } unsafe impl Send for VPORTF { } impl VPORTF { # [doc = r"Pointer to the register block"]
pub const PTR : * const vportf :: RegisterBlock = 0x14 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vportf :: RegisterBlock { Self :: PTR } } impl Deref for VPORTF { type Target = vportf :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORTF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORTF") . finish () } } # [doc = "Virtual Ports"]
pub mod vportf { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : DIR , # [doc = "0x01 - Output Value"]
pub out : OUT , # [doc = "0x02 - Input Value"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Input Value"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Input Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - Pin Interrupt"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - Pin Interrupt"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTFLAGS_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Interrupt"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Output Value"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Voltage reference"]
pub struct VREF { _marker : PhantomData < * const () > } unsafe impl Send for VREF { } impl VREF { # [doc = r"Pointer to the register block"]
pub const PTR : * const vref :: RegisterBlock = 0xa0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vref :: RegisterBlock { Self :: PTR } } impl Deref for VREF { type Target = vref :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VREF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VREF") . finish () } } # [doc = "Voltage reference"]
pub mod vref { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control B"]
pub ctrlb : CTRLB , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `AC0REFSEL` reader - AC0 reference select"]
pub type AC0REFSEL_R = crate :: FieldReader < u8 , AC0REFSEL_A > ; # [doc = "AC0 reference select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum AC0REFSEL_A { # [doc = "0: Voltage reference at 0.55V"]
_0V55 = 0 , # [doc = "1: Voltage reference at 1.1V"]
_1V1 = 1 , # [doc = "2: Voltage reference at 2.5V"]
_2V5 = 2 , # [doc = "3: Voltage reference at 4.34V"]
_4V34 = 3 , # [doc = "4: Voltage reference at 1.5V"]
_1V5 = 4 , # [doc = "7: AVDD"]
AVDD = 7 , } impl From < AC0REFSEL_A > for u8 { # [inline (always)]
fn from (variant : AC0REFSEL_A) -> Self { variant as _ } } impl AC0REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < AC0REFSEL_A > { match self . bits { 0 => Some (AC0REFSEL_A :: _0V55) , 1 => Some (AC0REFSEL_A :: _1V1) , 2 => Some (AC0REFSEL_A :: _2V5) , 3 => Some (AC0REFSEL_A :: _4V34) , 4 => Some (AC0REFSEL_A :: _1V5) , 7 => Some (AC0REFSEL_A :: AVDD) , _ => None , } } # [doc = "Checks if the value of the field is `_0V55`"]
# [inline (always)]
pub fn is_0v55 (& self) -> bool { * self == AC0REFSEL_A :: _0V55 } # [doc = "Checks if the value of the field is `_1V1`"]
# [inline (always)]
pub fn is_1v1 (& self) -> bool { * self == AC0REFSEL_A :: _1V1 } # [doc = "Checks if the value of the field is `_2V5`"]
# [inline (always)]
pub fn is_2v5 (& self) -> bool { * self == AC0REFSEL_A :: _2V5 } # [doc = "Checks if the value of the field is `_4V34`"]
# [inline (always)]
pub fn is_4v34 (& self) -> bool { * self == AC0REFSEL_A :: _4V34 } # [doc = "Checks if the value of the field is `_1V5`"]
# [inline (always)]
pub fn is_1v5 (& self) -> bool { * self == AC0REFSEL_A :: _1V5 } # [doc = "Checks if the value of the field is `AVDD`"]
# [inline (always)]
pub fn is_avdd (& self) -> bool { * self == AC0REFSEL_A :: AVDD } } # [doc = "Field `AC0REFSEL` writer - AC0 reference select"]
pub type AC0REFSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , AC0REFSEL_A , 3 , O > ; impl < 'a , const O : u8 > AC0REFSEL_W < 'a , O > { # [doc = "Voltage reference at 0.55V"]
# [inline (always)]
pub fn _0v55 (self) -> & 'a mut W { self . variant (AC0REFSEL_A :: _0V55) } # [doc = "Voltage reference at 1.1V"]
# [inline (always)]
pub fn _1v1 (self) -> & 'a mut W { self . variant (AC0REFSEL_A :: _1V1) } # [doc = "Voltage reference at 2.5V"]
# [inline (always)]
pub fn _2v5 (self) -> & 'a mut W { self . variant (AC0REFSEL_A :: _2V5) } # [doc = "Voltage reference at 4.34V"]
# [inline (always)]
pub fn _4v34 (self) -> & 'a mut W { self . variant (AC0REFSEL_A :: _4V34) } # [doc = "Voltage reference at 1.5V"]
# [inline (always)]
pub fn _1v5 (self) -> & 'a mut W { self . variant (AC0REFSEL_A :: _1V5) } # [doc = "AVDD"]
# [inline (always)]
pub fn avdd (self) -> & 'a mut W { self . variant (AC0REFSEL_A :: AVDD) } } # [doc = "Field `ADC0REFSEL` reader - ADC0 reference select"]
pub type ADC0REFSEL_R = crate :: FieldReader < u8 , ADC0REFSEL_A > ; # [doc = "ADC0 reference select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ADC0REFSEL_A { # [doc = "0: Voltage reference at 0.55V"]
_0V55 = 0 , # [doc = "1: Voltage reference at 1.1V"]
_1V1 = 1 , # [doc = "2: Voltage reference at 2.5V"]
_2V5 = 2 , # [doc = "3: Voltage reference at 4.34V"]
_4V34 = 3 , # [doc = "4: Voltage reference at 1.5V"]
_1V5 = 4 , } impl From < ADC0REFSEL_A > for u8 { # [inline (always)]
fn from (variant : ADC0REFSEL_A) -> Self { variant as _ } } impl ADC0REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ADC0REFSEL_A > { match self . bits { 0 => Some (ADC0REFSEL_A :: _0V55) , 1 => Some (ADC0REFSEL_A :: _1V1) , 2 => Some (ADC0REFSEL_A :: _2V5) , 3 => Some (ADC0REFSEL_A :: _4V34) , 4 => Some (ADC0REFSEL_A :: _1V5) , _ => None , } } # [doc = "Checks if the value of the field is `_0V55`"]
# [inline (always)]
pub fn is_0v55 (& self) -> bool { * self == ADC0REFSEL_A :: _0V55 } # [doc = "Checks if the value of the field is `_1V1`"]
# [inline (always)]
pub fn is_1v1 (& self) -> bool { * self == ADC0REFSEL_A :: _1V1 } # [doc = "Checks if the value of the field is `_2V5`"]
# [inline (always)]
pub fn is_2v5 (& self) -> bool { * self == ADC0REFSEL_A :: _2V5 } # [doc = "Checks if the value of the field is `_4V34`"]
# [inline (always)]
pub fn is_4v34 (& self) -> bool { * self == ADC0REFSEL_A :: _4V34 } # [doc = "Checks if the value of the field is `_1V5`"]
# [inline (always)]
pub fn is_1v5 (& self) -> bool { * self == ADC0REFSEL_A :: _1V5 } } # [doc = "Field `ADC0REFSEL` writer - ADC0 reference select"]
pub type ADC0REFSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , ADC0REFSEL_A , 3 , O > ; impl < 'a , const O : u8 > ADC0REFSEL_W < 'a , O > { # [doc = "Voltage reference at 0.55V"]
# [inline (always)]
pub fn _0v55 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _0V55) } # [doc = "Voltage reference at 1.1V"]
# [inline (always)]
pub fn _1v1 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _1V1) } # [doc = "Voltage reference at 2.5V"]
# [inline (always)]
pub fn _2v5 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _2V5) } # [doc = "Voltage reference at 4.34V"]
# [inline (always)]
pub fn _4v34 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _4V34) } # [doc = "Voltage reference at 1.5V"]
# [inline (always)]
pub fn _1v5 (self) -> & 'a mut W { self . variant (ADC0REFSEL_A :: _1V5) } } impl R { # [doc = "Bits 0:2 - AC0 reference select"]
# [inline (always)]
pub fn ac0refsel (& self) -> AC0REFSEL_R { AC0REFSEL_R :: new (self . bits & 7) } # [doc = "Bits 4:6 - ADC0 reference select"]
# [inline (always)]
pub fn adc0refsel (& self) -> ADC0REFSEL_R { ADC0REFSEL_R :: new ((self . bits >> 4) & 7) } } impl W { # [doc = "Bits 0:2 - AC0 reference select"]
# [inline (always)]
# [must_use]
pub fn ac0refsel (& mut self) -> AC0REFSEL_W < 0 > { AC0REFSEL_W :: new (self) } # [doc = "Bits 4:6 - ADC0 reference select"]
# [inline (always)]
# [must_use]
pub fn adc0refsel (& mut self) -> ADC0REFSEL_W < 4 > { ADC0REFSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `AC0REFEN` reader - AC0 DACREF reference enable"]
pub type AC0REFEN_R = crate :: BitReader < bool > ; # [doc = "Field `AC0REFEN` writer - AC0 DACREF reference enable"]
pub type AC0REFEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `ADC0REFEN` reader - ADC0 reference enable"]
pub type ADC0REFEN_R = crate :: BitReader < bool > ; # [doc = "Field `ADC0REFEN` writer - ADC0 reference enable"]
pub type ADC0REFEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - AC0 DACREF reference enable"]
# [inline (always)]
pub fn ac0refen (& self) -> AC0REFEN_R { AC0REFEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC0 reference enable"]
# [inline (always)]
pub fn adc0refen (& self) -> ADC0REFEN_R { ADC0REFEN_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - AC0 DACREF reference enable"]
# [inline (always)]
# [must_use]
pub fn ac0refen (& mut self) -> AC0REFEN_W < 0 > { AC0REFEN_W :: new (self) } # [doc = "Bit 1 - ADC0 reference enable"]
# [inline (always)]
# [must_use]
pub fn adc0refen (& mut self) -> ADC0REFEN_W < 1 > { ADC0REFEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Watch-Dog Timer"]
pub struct WDT { _marker : PhantomData < * const () > } unsafe impl Send for WDT { } impl WDT { # [doc = r"Pointer to the register block"]
pub const PTR : * const wdt :: RegisterBlock = 0x0100 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wdt :: RegisterBlock { Self :: PTR } } impl Deref for WDT { type Target = wdt :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WDT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WDT") . finish () } } # [doc = "Watch-Dog Timer"]
pub mod wdt { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : CTRLA , # [doc = "0x01 - Status"]
pub status : STATUS , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERIOD` reader - Period"]
pub type PERIOD_R = crate :: FieldReader < u8 , PERIOD_A > ; # [doc = "Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PERIOD_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: 8 cycles (8ms)"]
_8CLK = 1 , # [doc = "2: 16 cycles (16ms)"]
_16CLK = 2 , # [doc = "3: 32 cycles (32ms)"]
_32CLK = 3 , # [doc = "4: 64 cycles (64ms)"]
_64CLK = 4 , # [doc = "5: 128 cycles (0.128s)"]
_128CLK = 5 , # [doc = "6: 256 cycles (0.256s)"]
_256CLK = 6 , # [doc = "7: 512 cycles (0.512s)"]
_512CLK = 7 , # [doc = "8: 1K cycles (1.0s)"]
_1KCLK = 8 , # [doc = "9: 2K cycles (2.0s)"]
_2KCLK = 9 , # [doc = "10: 4K cycles (4.1s)"]
_4KCLK = 10 , # [doc = "11: 8K cycles (8.2s)"]
_8KCLK = 11 , } impl From < PERIOD_A > for u8 { # [inline (always)]
fn from (variant : PERIOD_A) -> Self { variant as _ } } impl PERIOD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PERIOD_A > { match self . bits { 0 => Some (PERIOD_A :: OFF) , 1 => Some (PERIOD_A :: _8CLK) , 2 => Some (PERIOD_A :: _16CLK) , 3 => Some (PERIOD_A :: _32CLK) , 4 => Some (PERIOD_A :: _64CLK) , 5 => Some (PERIOD_A :: _128CLK) , 6 => Some (PERIOD_A :: _256CLK) , 7 => Some (PERIOD_A :: _512CLK) , 8 => Some (PERIOD_A :: _1KCLK) , 9 => Some (PERIOD_A :: _2KCLK) , 10 => Some (PERIOD_A :: _4KCLK) , 11 => Some (PERIOD_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == PERIOD_A :: OFF } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == PERIOD_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == PERIOD_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == PERIOD_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == PERIOD_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == PERIOD_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == PERIOD_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == PERIOD_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == PERIOD_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == PERIOD_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == PERIOD_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == PERIOD_A :: _8KCLK } } # [doc = "Field `PERIOD` writer - Period"]
pub type PERIOD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , PERIOD_A , 4 , O > ; impl < 'a , const O : u8 > PERIOD_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (PERIOD_A :: OFF) } # [doc = "8 cycles (8ms)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _8CLK) } # [doc = "16 cycles (16ms)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _16CLK) } # [doc = "32 cycles (32ms)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _32CLK) } # [doc = "64 cycles (64ms)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _64CLK) } # [doc = "128 cycles (0.128s)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _128CLK) } # [doc = "256 cycles (0.256s)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _256CLK) } # [doc = "512 cycles (0.512s)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (PERIOD_A :: _512CLK) } # [doc = "1K cycles (1.0s)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _1KCLK) } # [doc = "2K cycles (2.0s)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _2KCLK) } # [doc = "4K cycles (4.1s)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _4KCLK) } # [doc = "8K cycles (8.2s)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (PERIOD_A :: _8KCLK) } } # [doc = "Field `WINDOW` reader - Window"]
pub type WINDOW_R = crate :: FieldReader < u8 , WINDOW_A > ; # [doc = "Window\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINDOW_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "1: 8 cycles (8ms)"]
_8CLK = 1 , # [doc = "2: 16 cycles (16ms)"]
_16CLK = 2 , # [doc = "3: 32 cycles (32ms)"]
_32CLK = 3 , # [doc = "4: 64 cycles (64ms)"]
_64CLK = 4 , # [doc = "5: 128 cycles (0.128s)"]
_128CLK = 5 , # [doc = "6: 256 cycles (0.256s)"]
_256CLK = 6 , # [doc = "7: 512 cycles (0.512s)"]
_512CLK = 7 , # [doc = "8: 1K cycles (1.0s)"]
_1KCLK = 8 , # [doc = "9: 2K cycles (2.0s)"]
_2KCLK = 9 , # [doc = "10: 4K cycles (4.1s)"]
_4KCLK = 10 , # [doc = "11: 8K cycles (8.2s)"]
_8KCLK = 11 , } impl From < WINDOW_A > for u8 { # [inline (always)]
fn from (variant : WINDOW_A) -> Self { variant as _ } } impl WINDOW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WINDOW_A > { match self . bits { 0 => Some (WINDOW_A :: OFF) , 1 => Some (WINDOW_A :: _8CLK) , 2 => Some (WINDOW_A :: _16CLK) , 3 => Some (WINDOW_A :: _32CLK) , 4 => Some (WINDOW_A :: _64CLK) , 5 => Some (WINDOW_A :: _128CLK) , 6 => Some (WINDOW_A :: _256CLK) , 7 => Some (WINDOW_A :: _512CLK) , 8 => Some (WINDOW_A :: _1KCLK) , 9 => Some (WINDOW_A :: _2KCLK) , 10 => Some (WINDOW_A :: _4KCLK) , 11 => Some (WINDOW_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == WINDOW_A :: OFF } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == WINDOW_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == WINDOW_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == WINDOW_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == WINDOW_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == WINDOW_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == WINDOW_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == WINDOW_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == WINDOW_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == WINDOW_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == WINDOW_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == WINDOW_A :: _8KCLK } } # [doc = "Field `WINDOW` writer - Window"]
pub type WINDOW_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLA_SPEC , u8 , WINDOW_A , 4 , O > ; impl < 'a , const O : u8 > WINDOW_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (WINDOW_A :: OFF) } # [doc = "8 cycles (8ms)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _8CLK) } # [doc = "16 cycles (16ms)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _16CLK) } # [doc = "32 cycles (32ms)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _32CLK) } # [doc = "64 cycles (64ms)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _64CLK) } # [doc = "128 cycles (0.128s)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _128CLK) } # [doc = "256 cycles (0.256s)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _256CLK) } # [doc = "512 cycles (0.512s)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (WINDOW_A :: _512CLK) } # [doc = "1K cycles (1.0s)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _1KCLK) } # [doc = "2K cycles (2.0s)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _2KCLK) } # [doc = "4K cycles (4.1s)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _4KCLK) } # [doc = "8K cycles (8.2s)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (WINDOW_A :: _8KCLK) } } impl R { # [doc = "Bits 0:3 - Period"]
# [inline (always)]
pub fn period (& self) -> PERIOD_R { PERIOD_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Window"]
# [inline (always)]
pub fn window (& self) -> WINDOW_R { WINDOW_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Period"]
# [inline (always)]
# [must_use]
pub fn period (& mut self) -> PERIOD_W < 0 > { PERIOD_W :: new (self) } # [doc = "Bits 4:7 - Window"]
# [inline (always)]
# [must_use]
pub fn window (& mut self) -> WINDOW_W < 4 > { WINDOW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCBUSY` reader - Syncronization busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `LOCK` reader - Lock enable"]
pub type LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `LOCK` writer - Lock enable"]
pub type LOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Syncronization busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - Lock enable"]
# [inline (always)]
pub fn lock (& self) -> LOCK_R { LOCK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 7 - Lock enable"]
# [inline (always)]
# [must_use]
pub fn lock (& mut self) -> LOCK_W < 7 > { LOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "AC0"]
pub AC0 : AC0 , # [doc = "ADC0"]
pub ADC0 : ADC0 , # [doc = "BOD"]
pub BOD : BOD , # [doc = "CCL"]
pub CCL : CCL , # [doc = "CLKCTRL"]
pub CLKCTRL : CLKCTRL , # [doc = "CPU"]
pub CPU : CPU , # [doc = "CPUINT"]
pub CPUINT : CPUINT , # [doc = "CRCSCAN"]
pub CRCSCAN : CRCSCAN , # [doc = "EVSYS"]
pub EVSYS : EVSYS , # [doc = "FUSE"]
pub FUSE : FUSE , # [doc = "GPIO"]
pub GPIO : GPIO , # [doc = "LOCKBIT"]
pub LOCKBIT : LOCKBIT , # [doc = "NVMCTRL"]
pub NVMCTRL : NVMCTRL , # [doc = "PORTA"]
pub PORTA : PORTA , # [doc = "PORTB"]
pub PORTB : PORTB , # [doc = "PORTC"]
pub PORTC : PORTC , # [doc = "PORTD"]
pub PORTD : PORTD , # [doc = "PORTE"]
pub PORTE : PORTE , # [doc = "PORTF"]
pub PORTF : PORTF , # [doc = "PORTMUX"]
pub PORTMUX : PORTMUX , # [doc = "RSTCTRL"]
pub RSTCTRL : RSTCTRL , # [doc = "RTC"]
pub RTC : RTC , # [doc = "SIGROW"]
pub SIGROW : SIGROW , # [doc = "SLPCTRL"]
pub SLPCTRL : SLPCTRL , # [doc = "SPI0"]
pub SPI0 : SPI0 , # [doc = "SYSCFG"]
pub SYSCFG : SYSCFG , # [doc = "TCA0"]
pub TCA0 : TCA0 , # [doc = "TCB0"]
pub TCB0 : TCB0 , # [doc = "TCB1"]
pub TCB1 : TCB1 , # [doc = "TCB2"]
pub TCB2 : TCB2 , # [doc = "TCB3"]
pub TCB3 : TCB3 , # [doc = "TWI0"]
pub TWI0 : TWI0 , # [doc = "USART0"]
pub USART0 : USART0 , # [doc = "USART1"]
pub USART1 : USART1 , # [doc = "USART2"]
pub USART2 : USART2 , # [doc = "USART3"]
pub USART3 : USART3 , # [doc = "USERROW"]
pub USERROW : USERROW , # [doc = "VPORTA"]
pub VPORTA : VPORTA , # [doc = "VPORTB"]
pub VPORTB : VPORTB , # [doc = "VPORTC"]
pub VPORTC : VPORTC , # [doc = "VPORTD"]
pub VPORTD : VPORTD , # [doc = "VPORTE"]
pub VPORTE : VPORTE , # [doc = "VPORTF"]
pub VPORTF : VPORTF , # [doc = "VREF"]
pub VREF : VREF , # [doc = "WDT"]
pub WDT : WDT , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { AC0 : AC0 { _marker : PhantomData } , ADC0 : ADC0 { _marker : PhantomData } , BOD : BOD { _marker : PhantomData } , CCL : CCL { _marker : PhantomData } , CLKCTRL : CLKCTRL { _marker : PhantomData } , CPU : CPU { _marker : PhantomData } , CPUINT : CPUINT { _marker : PhantomData } , CRCSCAN : CRCSCAN { _marker : PhantomData } , EVSYS : EVSYS { _marker : PhantomData } , FUSE : FUSE { _marker : PhantomData } , GPIO : GPIO { _marker : PhantomData } , LOCKBIT : LOCKBIT { _marker : PhantomData } , NVMCTRL : NVMCTRL { _marker : PhantomData } , PORTA : PORTA { _marker : PhantomData } , PORTB : PORTB { _marker : PhantomData } , PORTC : PORTC { _marker : PhantomData } , PORTD : PORTD { _marker : PhantomData } , PORTE : PORTE { _marker : PhantomData } , PORTF : PORTF { _marker : PhantomData } , PORTMUX : PORTMUX { _marker : PhantomData } , RSTCTRL : RSTCTRL { _marker : PhantomData } , RTC : RTC { _marker : PhantomData } , SIGROW : SIGROW { _marker : PhantomData } , SLPCTRL : SLPCTRL { _marker : PhantomData } , SPI0 : SPI0 { _marker : PhantomData } , SYSCFG : SYSCFG { _marker : PhantomData } , TCA0 : TCA0 { _marker : PhantomData } , TCB0 : TCB0 { _marker : PhantomData } , TCB1 : TCB1 { _marker : PhantomData } , TCB2 : TCB2 { _marker : PhantomData } , TCB3 : TCB3 { _marker : PhantomData } , TWI0 : TWI0 { _marker : PhantomData } , USART0 : USART0 { _marker : PhantomData } , USART1 : USART1 { _marker : PhantomData } , USART2 : USART2 { _marker : PhantomData } , USART3 : USART3 { _marker : PhantomData } , USERROW : USERROW { _marker : PhantomData } , VPORTA : VPORTA { _marker : PhantomData } , VPORTB : VPORTB { _marker : PhantomData } , VPORTC : VPORTC { _marker : PhantomData } , VPORTD : VPORTD { _marker : PhantomData } , VPORTE : VPORTE { _marker : PhantomData } , VPORTF : VPORTF { _marker : PhantomData } , VREF : VREF { _marker : PhantomData } , WDT : WDT { _marker : PhantomData } , } } }