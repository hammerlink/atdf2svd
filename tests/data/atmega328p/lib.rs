# ! [doc = "Peripheral access API for ATMEGA328P microcontrollers (generated using svd2rust v0.28.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS : u8 = 4 ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."]
type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."]
type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Read datasheet or reference manual to find what values are allowed to pass."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc (hidden)]
pub struct FieldReaderRaw < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , FI > FieldReaderRaw < U , FI > where U : Copy , { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitReaderRaw < T > { pub (crate) bits : bool , _reg : marker :: PhantomData < T > , } impl < FI > BitReaderRaw < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < U , FI > = FieldReaderRaw < U , FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI > = BitReaderRaw < FI > ; impl < U , FI > FieldReader < U , FI > where U : Copy , { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , FI > PartialEq < FI > for FieldReader < U , FI > where U : PartialEq , FI : Copy , U : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& U :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc (hidden)]
pub struct FieldWriterRaw < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (N , FI , Safety) > , } impl < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > FieldWriterRaw < 'a , U , REG , N , FI , Safety , WI , O > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitWriterRaw < 'a , U , REG , FI , M , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , U , REG , FI , M , const O : u8 > BitWriterRaw < 'a , U , REG , FI , M , O > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Unsafe , WI , O > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Safe , WI , O > ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , U , REG , FI , const O : u8 > = BitWriterRaw <'a , U , REG , FI , $ mwv , O >; impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; } } ; } macro_rules ! impl_bit_proxy { ($ writer : ident) => { impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, U : RawReg , bool : From < FI >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w . bits |= (U :: from (value) & U :: one ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { unsafe { self . bits (N :: from (variant)) } } } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { self . bits (N :: from (variant)) } } impl_bit_proxy ! (BitWriter) ; impl_bit_proxy ! (BitWriter1S) ; impl_bit_proxy ! (BitWriter0C) ; impl_bit_proxy ! (BitWriter1C) ; impl_bit_proxy ! (BitWriter0S) ; impl_bit_proxy ! (BitWriter1T) ; impl_bit_proxy ! (BitWriter0T) ; impl < 'a , U , REG , FI , const OF : u8 > BitWriter < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } } # [doc (hidden)]
pub mod interrupt { # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "0 - External Pin, Power-on Reset, Brown-out Reset and Watchdog Reset"]
RESET = 0 , # [doc = "1 - External Interrupt Request 0"]
INT0 = 1 , # [doc = "2 - External Interrupt Request 1"]
INT1 = 2 , # [doc = "3 - Pin Change Interrupt Request 0"]
PCINT0 = 3 , # [doc = "4 - Pin Change Interrupt Request 1"]
PCINT1 = 4 , # [doc = "5 - Pin Change Interrupt Request 2"]
PCINT2 = 5 , # [doc = "6 - Watchdog Time-out Interrupt"]
WDT = 6 , # [doc = "7 - Timer/Counter2 Compare Match A"]
TIMER2_COMPA = 7 , # [doc = "8 - Timer/Counter2 Compare Match B"]
TIMER2_COMPB = 8 , # [doc = "9 - Timer/Counter2 Overflow"]
TIMER2_OVF = 9 , # [doc = "10 - Timer/Counter1 Capture Event"]
TIMER1_CAPT = 10 , # [doc = "11 - Timer/Counter1 Compare Match A"]
TIMER1_COMPA = 11 , # [doc = "12 - Timer/Counter1 Compare Match B"]
TIMER1_COMPB = 12 , # [doc = "13 - Timer/Counter1 Overflow"]
TIMER1_OVF = 13 , # [doc = "14 - TimerCounter0 Compare Match A"]
TIMER0_COMPA = 14 , # [doc = "15 - TimerCounter0 Compare Match B"]
TIMER0_COMPB = 15 , # [doc = "16 - Timer/Couner0 Overflow"]
TIMER0_OVF = 16 , # [doc = "17 - SPI Serial Transfer Complete"]
SPI_STC = 17 , # [doc = "18 - USART Rx Complete"]
USART_RX = 18 , # [doc = "19 - USART, Data Register Empty"]
USART_UDRE = 19 , # [doc = "20 - USART Tx Complete"]
USART_TX = 20 , # [doc = "21 - ADC Conversion Complete"]
ADC = 21 , # [doc = "22 - EEPROM Ready"]
EE_READY = 22 , # [doc = "23 - Analog Comparator"]
ANALOG_COMP = 23 , # [doc = "24 - Two-wire Serial Interface"]
TWI = 24 , # [doc = "25 - Store Program Memory Read"]
SPM_READY = 25 , } # [doc = r" TryFromInterruptError"]
# [derive (Debug , Copy , Clone)]
pub struct TryFromInterruptError (()) ; impl Interrupt { # [doc = r" Attempt to convert a given value into an `Interrupt`"]
# [inline]
pub fn try_from (value : u8) -> Result < Self , TryFromInterruptError > { match value { 0 => Ok (Interrupt :: RESET) , 1 => Ok (Interrupt :: INT0) , 2 => Ok (Interrupt :: INT1) , 3 => Ok (Interrupt :: PCINT0) , 4 => Ok (Interrupt :: PCINT1) , 5 => Ok (Interrupt :: PCINT2) , 6 => Ok (Interrupt :: WDT) , 7 => Ok (Interrupt :: TIMER2_COMPA) , 8 => Ok (Interrupt :: TIMER2_COMPB) , 9 => Ok (Interrupt :: TIMER2_OVF) , 10 => Ok (Interrupt :: TIMER1_CAPT) , 11 => Ok (Interrupt :: TIMER1_COMPA) , 12 => Ok (Interrupt :: TIMER1_COMPB) , 13 => Ok (Interrupt :: TIMER1_OVF) , 14 => Ok (Interrupt :: TIMER0_COMPA) , 15 => Ok (Interrupt :: TIMER0_COMPB) , 16 => Ok (Interrupt :: TIMER0_OVF) , 17 => Ok (Interrupt :: SPI_STC) , 18 => Ok (Interrupt :: USART_RX) , 19 => Ok (Interrupt :: USART_UDRE) , 20 => Ok (Interrupt :: USART_TX) , 21 => Ok (Interrupt :: ADC) , 22 => Ok (Interrupt :: EE_READY) , 23 => Ok (Interrupt :: ANALOG_COMP) , 24 => Ok (Interrupt :: TWI) , 25 => Ok (Interrupt :: SPM_READY) , _ => Err (TryFromInterruptError (())) , } } } } pub use self :: interrupt :: Interrupt ; # [doc = "Analog Comparator"]
pub struct AC { _marker : PhantomData < * const () > } unsafe impl Send for AC { } impl AC { # [doc = r"Pointer to the register block"]
pub const PTR : * const ac :: RegisterBlock = 0x50 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ac :: RegisterBlock { Self :: PTR } } impl Deref for AC { type Target = ac :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for AC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AC") . finish () } } # [doc = "Analog Comparator"]
pub mod ac { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Analog Comparator Control And Status Register"]
pub acsr : ACSR , _reserved1 : [u8 ; 0x2e]
, # [doc = "0x2f - Digital Input Disable Register 1"]
pub didr1 : DIDR1 , } # [doc = "ACSR (rw) register accessor: an alias for `Reg<ACSR_SPEC>`"]
pub type ACSR = crate :: Reg < acsr :: ACSR_SPEC > ; # [doc = "Analog Comparator Control And Status Register"]
pub mod acsr { # [doc = "Register `ACSR` reader"]
pub struct R (crate :: R < ACSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ACSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ACSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ACSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ACSR` writer"]
pub struct W (crate :: W < ACSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ACSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ACSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ACSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ACIS` reader - Analog Comparator Interrupt Mode Select bits"]
pub type ACIS_R = crate :: FieldReader < u8 , ACIS_A > ; # [doc = "Analog Comparator Interrupt Mode Select bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ACIS_A { # [doc = "0: Interrupt on Toggle"]
VAL_0X00 = 0 , # [doc = "1: Reserved"]
VAL_0X01 = 1 , # [doc = "2: Interrupt on Falling Edge"]
VAL_0X02 = 2 , # [doc = "3: Interrupt on Rising Edge"]
VAL_0X03 = 3 , } impl From < ACIS_A > for u8 { # [inline (always)]
fn from (variant : ACIS_A) -> Self { variant as _ } } impl ACIS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ACIS_A { match self . bits { 0 => ACIS_A :: VAL_0X00 , 1 => ACIS_A :: VAL_0X01 , 2 => ACIS_A :: VAL_0X02 , 3 => ACIS_A :: VAL_0X03 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == ACIS_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == ACIS_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == ACIS_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == ACIS_A :: VAL_0X03 } } # [doc = "Field `ACIS` writer - Analog Comparator Interrupt Mode Select bits"]
pub type ACIS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ACSR_SPEC , u8 , ACIS_A , 2 , O > ; impl < 'a , const O : u8 > ACIS_W < 'a , O > { # [doc = "Interrupt on Toggle"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (ACIS_A :: VAL_0X00) } # [doc = "Reserved"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (ACIS_A :: VAL_0X01) } # [doc = "Interrupt on Falling Edge"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (ACIS_A :: VAL_0X02) } # [doc = "Interrupt on Rising Edge"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (ACIS_A :: VAL_0X03) } } # [doc = "Field `ACIC` reader - Analog Comparator Input Capture Enable"]
pub type ACIC_R = crate :: BitReader < bool > ; # [doc = "Field `ACIC` writer - Analog Comparator Input Capture Enable"]
pub type ACIC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACIE` reader - Analog Comparator Interrupt Enable"]
pub type ACIE_R = crate :: BitReader < bool > ; # [doc = "Field `ACIE` writer - Analog Comparator Interrupt Enable"]
pub type ACIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACI` reader - Analog Comparator Interrupt Flag"]
pub type ACI_R = crate :: BitReader < bool > ; # [doc = "Field `ACI` writer - Analog Comparator Interrupt Flag"]
pub type ACI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACO` reader - Analog Compare Output"]
pub type ACO_R = crate :: BitReader < bool > ; # [doc = "Field `ACO` writer - Analog Compare Output"]
pub type ACO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACBG` reader - Analog Comparator Bandgap Select"]
pub type ACBG_R = crate :: BitReader < bool > ; # [doc = "Field `ACBG` writer - Analog Comparator Bandgap Select"]
pub type ACBG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; # [doc = "Field `ACD` reader - Analog Comparator Disable"]
pub type ACD_R = crate :: BitReader < bool > ; # [doc = "Field `ACD` writer - Analog Comparator Disable"]
pub type ACD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ACSR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Analog Comparator Interrupt Mode Select bits"]
# [inline (always)]
pub fn acis (& self) -> ACIS_R { ACIS_R :: new (self . bits & 3) } # [doc = "Bit 2 - Analog Comparator Input Capture Enable"]
# [inline (always)]
pub fn acic (& self) -> ACIC_R { ACIC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Analog Comparator Interrupt Enable"]
# [inline (always)]
pub fn acie (& self) -> ACIE_R { ACIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Analog Comparator Interrupt Flag"]
# [inline (always)]
pub fn aci (& self) -> ACI_R { ACI_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Analog Compare Output"]
# [inline (always)]
pub fn aco (& self) -> ACO_R { ACO_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Analog Comparator Bandgap Select"]
# [inline (always)]
pub fn acbg (& self) -> ACBG_R { ACBG_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Analog Comparator Disable"]
# [inline (always)]
pub fn acd (& self) -> ACD_R { ACD_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Analog Comparator Interrupt Mode Select bits"]
# [inline (always)]
# [must_use]
pub fn acis (& mut self) -> ACIS_W < 0 > { ACIS_W :: new (self) } # [doc = "Bit 2 - Analog Comparator Input Capture Enable"]
# [inline (always)]
# [must_use]
pub fn acic (& mut self) -> ACIC_W < 2 > { ACIC_W :: new (self) } # [doc = "Bit 3 - Analog Comparator Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn acie (& mut self) -> ACIE_W < 3 > { ACIE_W :: new (self) } # [doc = "Bit 4 - Analog Comparator Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn aci (& mut self) -> ACI_W < 4 > { ACI_W :: new (self) } # [doc = "Bit 5 - Analog Compare Output"]
# [inline (always)]
# [must_use]
pub fn aco (& mut self) -> ACO_W < 5 > { ACO_W :: new (self) } # [doc = "Bit 6 - Analog Comparator Bandgap Select"]
# [inline (always)]
# [must_use]
pub fn acbg (& mut self) -> ACBG_W < 6 > { ACBG_W :: new (self) } # [doc = "Bit 7 - Analog Comparator Disable"]
# [inline (always)]
# [must_use]
pub fn acd (& mut self) -> ACD_W < 7 > { ACD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator Control And Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [acsr](index.html) module"]
pub struct ACSR_SPEC ; impl crate :: RegisterSpec for ACSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [acsr::R](R) reader structure"]
impl crate :: Readable for ACSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [acsr::W](W) writer structure"]
impl crate :: Writable for ACSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ACSR to value 0"]
impl crate :: Resettable for ACSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIDR1 (rw) register accessor: an alias for `Reg<DIDR1_SPEC>`"]
pub type DIDR1 = crate :: Reg < didr1 :: DIDR1_SPEC > ; # [doc = "Digital Input Disable Register 1"]
pub mod didr1 { # [doc = "Register `DIDR1` reader"]
pub struct R (crate :: R < DIDR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIDR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIDR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIDR1` writer"]
pub struct W (crate :: W < DIDR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIDR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIDR1_SPEC >) -> Self { W (writer) } } # [doc = "Field `AIN0D` reader - AIN0 Digital Input Disable"]
pub type AIN0D_R = crate :: BitReader < bool > ; # [doc = "Field `AIN0D` writer - AIN0 Digital Input Disable"]
pub type AIN0D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR1_SPEC , bool , O > ; # [doc = "Field `AIN1D` reader - AIN1 Digital Input Disable"]
pub type AIN1D_R = crate :: BitReader < bool > ; # [doc = "Field `AIN1D` writer - AIN1 Digital Input Disable"]
pub type AIN1D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - AIN0 Digital Input Disable"]
# [inline (always)]
pub fn ain0d (& self) -> AIN0D_R { AIN0D_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - AIN1 Digital Input Disable"]
# [inline (always)]
pub fn ain1d (& self) -> AIN1D_R { AIN1D_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - AIN0 Digital Input Disable"]
# [inline (always)]
# [must_use]
pub fn ain0d (& mut self) -> AIN0D_W < 0 > { AIN0D_W :: new (self) } # [doc = "Bit 1 - AIN1 Digital Input Disable"]
# [inline (always)]
# [must_use]
pub fn ain1d (& mut self) -> AIN1D_W < 1 > { AIN1D_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Digital Input Disable Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [didr1](index.html) module"]
pub struct DIDR1_SPEC ; impl crate :: RegisterSpec for DIDR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [didr1::R](R) reader structure"]
impl crate :: Readable for DIDR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [didr1::W](W) writer structure"]
impl crate :: Writable for DIDR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIDR1 to value 0"]
impl crate :: Resettable for DIDR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Analog-to-Digital Converter"]
pub struct ADC { _marker : PhantomData < * const () > } unsafe impl Send for ADC { } impl ADC { # [doc = r"Pointer to the register block"]
pub const PTR : * const adc :: RegisterBlock = 0x78 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adc :: RegisterBlock { Self :: PTR } } impl Deref for ADC { type Target = adc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC") . finish () } } # [doc = "Analog-to-Digital Converter"]
pub mod adc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - ADC Data Register Bytes"]
pub adc : ADC , # [doc = "0x02 - The ADC Control and Status register A"]
pub adcsra : ADCSRA , # [doc = "0x03 - The ADC Control and Status register B"]
pub adcsrb : ADCSRB , # [doc = "0x04 - The ADC multiplexer Selection Register"]
pub admux : ADMUX , _reserved4 : [u8 ; 0x01]
, # [doc = "0x06 - Digital Input Disable Register"]
pub didr0 : DIDR0 , } # [doc = "ADC (rw) register accessor: an alias for `Reg<ADC_SPEC>`"]
pub type ADC = crate :: Reg < adc :: ADC_SPEC > ; # [doc = "ADC Data Register Bytes"]
pub mod adc { # [doc = "Register `ADC` reader"]
pub struct R (crate :: R < ADC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADC_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADC` writer"]
pub struct W (crate :: W < ADC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "ADC Data Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adc](index.html) module"]
pub struct ADC_SPEC ; impl crate :: RegisterSpec for ADC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [adc::R](R) reader structure"]
impl crate :: Readable for ADC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adc::W](W) writer structure"]
impl crate :: Writable for ADC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADC to value 0"]
impl crate :: Resettable for ADC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCSRA (rw) register accessor: an alias for `Reg<ADCSRA_SPEC>`"]
pub type ADCSRA = crate :: Reg < adcsra :: ADCSRA_SPEC > ; # [doc = "The ADC Control and Status register A"]
pub mod adcsra { # [doc = "Register `ADCSRA` reader"]
pub struct R (crate :: R < ADCSRA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCSRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCSRA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCSRA_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCSRA` writer"]
pub struct W (crate :: W < ADCSRA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCSRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCSRA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCSRA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADPS` reader - ADC Prescaler Select Bits"]
pub type ADPS_R = crate :: FieldReader < u8 , ADPS_A > ; # [doc = "ADC Prescaler Select Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ADPS_A { # [doc = "0: 2"]
VAL_0X00 = 0 , # [doc = "1: 2"]
VAL_0X01 = 1 , # [doc = "2: 4"]
VAL_0X02 = 2 , # [doc = "3: 8"]
VAL_0X03 = 3 , # [doc = "4: 16"]
VAL_0X04 = 4 , # [doc = "5: 32"]
VAL_0X05 = 5 , # [doc = "6: 64"]
VAL_0X06 = 6 , # [doc = "7: 128"]
VAL_0X07 = 7 , } impl From < ADPS_A > for u8 { # [inline (always)]
fn from (variant : ADPS_A) -> Self { variant as _ } } impl ADPS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADPS_A { match self . bits { 0 => ADPS_A :: VAL_0X00 , 1 => ADPS_A :: VAL_0X01 , 2 => ADPS_A :: VAL_0X02 , 3 => ADPS_A :: VAL_0X03 , 4 => ADPS_A :: VAL_0X04 , 5 => ADPS_A :: VAL_0X05 , 6 => ADPS_A :: VAL_0X06 , 7 => ADPS_A :: VAL_0X07 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == ADPS_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == ADPS_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == ADPS_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == ADPS_A :: VAL_0X03 } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == ADPS_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == ADPS_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `VAL_0X06`"]
# [inline (always)]
pub fn is_val_0x06 (& self) -> bool { * self == ADPS_A :: VAL_0X06 } # [doc = "Checks if the value of the field is `VAL_0X07`"]
# [inline (always)]
pub fn is_val_0x07 (& self) -> bool { * self == ADPS_A :: VAL_0X07 } } # [doc = "Field `ADPS` writer - ADC Prescaler Select Bits"]
pub type ADPS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ADCSRA_SPEC , u8 , ADPS_A , 3 , O > ; impl < 'a , const O : u8 > ADPS_W < 'a , O > { # [doc = "2"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (ADPS_A :: VAL_0X00) } # [doc = "2"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (ADPS_A :: VAL_0X01) } # [doc = "4"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (ADPS_A :: VAL_0X02) } # [doc = "8"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (ADPS_A :: VAL_0X03) } # [doc = "16"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (ADPS_A :: VAL_0X04) } # [doc = "32"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (ADPS_A :: VAL_0X05) } # [doc = "64"]
# [inline (always)]
pub fn val_0x06 (self) -> & 'a mut W { self . variant (ADPS_A :: VAL_0X06) } # [doc = "128"]
# [inline (always)]
pub fn val_0x07 (self) -> & 'a mut W { self . variant (ADPS_A :: VAL_0X07) } } # [doc = "Field `ADIE` reader - ADC Interrupt Enable"]
pub type ADIE_R = crate :: BitReader < bool > ; # [doc = "Field `ADIE` writer - ADC Interrupt Enable"]
pub type ADIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; # [doc = "Field `ADIF` reader - ADC Interrupt Flag"]
pub type ADIF_R = crate :: BitReader < bool > ; # [doc = "Field `ADIF` writer - ADC Interrupt Flag"]
pub type ADIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; # [doc = "Field `ADATE` reader - ADC Auto Trigger Enable"]
pub type ADATE_R = crate :: BitReader < bool > ; # [doc = "Field `ADATE` writer - ADC Auto Trigger Enable"]
pub type ADATE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; # [doc = "Field `ADSC` reader - ADC Start Conversion"]
pub type ADSC_R = crate :: BitReader < bool > ; # [doc = "Field `ADSC` writer - ADC Start Conversion"]
pub type ADSC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; # [doc = "Field `ADEN` reader - ADC Enable"]
pub type ADEN_R = crate :: BitReader < bool > ; # [doc = "Field `ADEN` writer - ADC Enable"]
pub type ADEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - ADC Prescaler Select Bits"]
# [inline (always)]
pub fn adps (& self) -> ADPS_R { ADPS_R :: new (self . bits & 7) } # [doc = "Bit 3 - ADC Interrupt Enable"]
# [inline (always)]
pub fn adie (& self) -> ADIE_R { ADIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - ADC Interrupt Flag"]
# [inline (always)]
pub fn adif (& self) -> ADIF_R { ADIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - ADC Auto Trigger Enable"]
# [inline (always)]
pub fn adate (& self) -> ADATE_R { ADATE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - ADC Start Conversion"]
# [inline (always)]
pub fn adsc (& self) -> ADSC_R { ADSC_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - ADC Enable"]
# [inline (always)]
pub fn aden (& self) -> ADEN_R { ADEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - ADC Prescaler Select Bits"]
# [inline (always)]
# [must_use]
pub fn adps (& mut self) -> ADPS_W < 0 > { ADPS_W :: new (self) } # [doc = "Bit 3 - ADC Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn adie (& mut self) -> ADIE_W < 3 > { ADIE_W :: new (self) } # [doc = "Bit 4 - ADC Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn adif (& mut self) -> ADIF_W < 4 > { ADIF_W :: new (self) } # [doc = "Bit 5 - ADC Auto Trigger Enable"]
# [inline (always)]
# [must_use]
pub fn adate (& mut self) -> ADATE_W < 5 > { ADATE_W :: new (self) } # [doc = "Bit 6 - ADC Start Conversion"]
# [inline (always)]
# [must_use]
pub fn adsc (& mut self) -> ADSC_W < 6 > { ADSC_W :: new (self) } # [doc = "Bit 7 - ADC Enable"]
# [inline (always)]
# [must_use]
pub fn aden (& mut self) -> ADEN_W < 7 > { ADEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The ADC Control and Status register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcsra](index.html) module"]
pub struct ADCSRA_SPEC ; impl crate :: RegisterSpec for ADCSRA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcsra::R](R) reader structure"]
impl crate :: Readable for ADCSRA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcsra::W](W) writer structure"]
impl crate :: Writable for ADCSRA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCSRA to value 0"]
impl crate :: Resettable for ADCSRA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCSRB (rw) register accessor: an alias for `Reg<ADCSRB_SPEC>`"]
pub type ADCSRB = crate :: Reg < adcsrb :: ADCSRB_SPEC > ; # [doc = "The ADC Control and Status register B"]
pub mod adcsrb { # [doc = "Register `ADCSRB` reader"]
pub struct R (crate :: R < ADCSRB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCSRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCSRB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCSRB_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCSRB` writer"]
pub struct W (crate :: W < ADCSRB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCSRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCSRB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCSRB_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADTS` reader - ADC Auto Trigger Source bits"]
pub type ADTS_R = crate :: FieldReader < u8 , ADTS_A > ; # [doc = "ADC Auto Trigger Source bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ADTS_A { # [doc = "0: Free Running mode"]
VAL_0X00 = 0 , # [doc = "1: Analog Comparator"]
VAL_0X01 = 1 , # [doc = "2: External Interrupt Request 0"]
VAL_0X02 = 2 , # [doc = "3: Timer/Counter0 Compare Match A"]
VAL_0X03 = 3 , # [doc = "4: Timer/Counter0 Overflow"]
VAL_0X04 = 4 , # [doc = "5: Timer/Counter1 Compare Match B"]
VAL_0X05 = 5 , # [doc = "6: Timer/Counter1 Overflow"]
VAL_0X06 = 6 , # [doc = "7: Timer/Counter1 Capture Event"]
VAL_0X07 = 7 , } impl From < ADTS_A > for u8 { # [inline (always)]
fn from (variant : ADTS_A) -> Self { variant as _ } } impl ADTS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ADTS_A { match self . bits { 0 => ADTS_A :: VAL_0X00 , 1 => ADTS_A :: VAL_0X01 , 2 => ADTS_A :: VAL_0X02 , 3 => ADTS_A :: VAL_0X03 , 4 => ADTS_A :: VAL_0X04 , 5 => ADTS_A :: VAL_0X05 , 6 => ADTS_A :: VAL_0X06 , 7 => ADTS_A :: VAL_0X07 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == ADTS_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == ADTS_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == ADTS_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == ADTS_A :: VAL_0X03 } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == ADTS_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == ADTS_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `VAL_0X06`"]
# [inline (always)]
pub fn is_val_0x06 (& self) -> bool { * self == ADTS_A :: VAL_0X06 } # [doc = "Checks if the value of the field is `VAL_0X07`"]
# [inline (always)]
pub fn is_val_0x07 (& self) -> bool { * self == ADTS_A :: VAL_0X07 } } # [doc = "Field `ADTS` writer - ADC Auto Trigger Source bits"]
pub type ADTS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ADCSRB_SPEC , u8 , ADTS_A , 3 , O > ; impl < 'a , const O : u8 > ADTS_W < 'a , O > { # [doc = "Free Running mode"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (ADTS_A :: VAL_0X00) } # [doc = "Analog Comparator"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (ADTS_A :: VAL_0X01) } # [doc = "External Interrupt Request 0"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (ADTS_A :: VAL_0X02) } # [doc = "Timer/Counter0 Compare Match A"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (ADTS_A :: VAL_0X03) } # [doc = "Timer/Counter0 Overflow"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (ADTS_A :: VAL_0X04) } # [doc = "Timer/Counter1 Compare Match B"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (ADTS_A :: VAL_0X05) } # [doc = "Timer/Counter1 Overflow"]
# [inline (always)]
pub fn val_0x06 (self) -> & 'a mut W { self . variant (ADTS_A :: VAL_0X06) } # [doc = "Timer/Counter1 Capture Event"]
# [inline (always)]
pub fn val_0x07 (self) -> & 'a mut W { self . variant (ADTS_A :: VAL_0X07) } } # [doc = "Field `ACME` reader - No Description."]
pub type ACME_R = crate :: BitReader < bool > ; # [doc = "Field `ACME` writer - No Description."]
pub type ACME_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADCSRB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - ADC Auto Trigger Source bits"]
# [inline (always)]
pub fn adts (& self) -> ADTS_R { ADTS_R :: new (self . bits & 7) } # [doc = "Bit 6 - No Description."]
# [inline (always)]
pub fn acme (& self) -> ACME_R { ACME_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - ADC Auto Trigger Source bits"]
# [inline (always)]
# [must_use]
pub fn adts (& mut self) -> ADTS_W < 0 > { ADTS_W :: new (self) } # [doc = "Bit 6 - No Description."]
# [inline (always)]
# [must_use]
pub fn acme (& mut self) -> ACME_W < 6 > { ACME_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The ADC Control and Status register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcsrb](index.html) module"]
pub struct ADCSRB_SPEC ; impl crate :: RegisterSpec for ADCSRB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcsrb::R](R) reader structure"]
impl crate :: Readable for ADCSRB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcsrb::W](W) writer structure"]
impl crate :: Writable for ADCSRB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCSRB to value 0"]
impl crate :: Resettable for ADCSRB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADMUX (rw) register accessor: an alias for `Reg<ADMUX_SPEC>`"]
pub type ADMUX = crate :: Reg < admux :: ADMUX_SPEC > ; # [doc = "The ADC multiplexer Selection Register"]
pub mod admux { # [doc = "Register `ADMUX` reader"]
pub struct R (crate :: R < ADMUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADMUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADMUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADMUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADMUX` writer"]
pub struct W (crate :: W < ADMUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADMUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADMUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADMUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUX` reader - Analog Channel Selection Bits"]
pub type MUX_R = crate :: FieldReader < u8 , MUX_A > ; # [doc = "Analog Channel Selection Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUX_A { # [doc = "0: ADC Single Ended Input pin 0"]
ADC0 = 0 , # [doc = "1: ADC Single Ended Input pin 1"]
ADC1 = 1 , # [doc = "2: ADC Single Ended Input pin 2"]
ADC2 = 2 , # [doc = "3: ADC Single Ended Input pin 3"]
ADC3 = 3 , # [doc = "4: ADC Single Ended Input pin 4"]
ADC4 = 4 , # [doc = "5: ADC Single Ended Input pin 5"]
ADC5 = 5 , # [doc = "6: ADC Single Ended Input pin 6"]
ADC6 = 6 , # [doc = "7: ADC Single Ended Input pin 7"]
ADC7 = 7 , # [doc = "8: Temperature sensor"]
TEMPSENS = 8 , # [doc = "14: Internal Reference (VBG)"]
ADC_VBG = 14 , # [doc = "15: 0V (GND)"]
ADC_GND = 15 , } impl From < MUX_A > for u8 { # [inline (always)]
fn from (variant : MUX_A) -> Self { variant as _ } } impl MUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MUX_A > { match self . bits { 0 => Some (MUX_A :: ADC0) , 1 => Some (MUX_A :: ADC1) , 2 => Some (MUX_A :: ADC2) , 3 => Some (MUX_A :: ADC3) , 4 => Some (MUX_A :: ADC4) , 5 => Some (MUX_A :: ADC5) , 6 => Some (MUX_A :: ADC6) , 7 => Some (MUX_A :: ADC7) , 8 => Some (MUX_A :: TEMPSENS) , 14 => Some (MUX_A :: ADC_VBG) , 15 => Some (MUX_A :: ADC_GND) , _ => None , } } # [doc = "Checks if the value of the field is `ADC0`"]
# [inline (always)]
pub fn is_adc0 (& self) -> bool { * self == MUX_A :: ADC0 } # [doc = "Checks if the value of the field is `ADC1`"]
# [inline (always)]
pub fn is_adc1 (& self) -> bool { * self == MUX_A :: ADC1 } # [doc = "Checks if the value of the field is `ADC2`"]
# [inline (always)]
pub fn is_adc2 (& self) -> bool { * self == MUX_A :: ADC2 } # [doc = "Checks if the value of the field is `ADC3`"]
# [inline (always)]
pub fn is_adc3 (& self) -> bool { * self == MUX_A :: ADC3 } # [doc = "Checks if the value of the field is `ADC4`"]
# [inline (always)]
pub fn is_adc4 (& self) -> bool { * self == MUX_A :: ADC4 } # [doc = "Checks if the value of the field is `ADC5`"]
# [inline (always)]
pub fn is_adc5 (& self) -> bool { * self == MUX_A :: ADC5 } # [doc = "Checks if the value of the field is `ADC6`"]
# [inline (always)]
pub fn is_adc6 (& self) -> bool { * self == MUX_A :: ADC6 } # [doc = "Checks if the value of the field is `ADC7`"]
# [inline (always)]
pub fn is_adc7 (& self) -> bool { * self == MUX_A :: ADC7 } # [doc = "Checks if the value of the field is `TEMPSENS`"]
# [inline (always)]
pub fn is_tempsens (& self) -> bool { * self == MUX_A :: TEMPSENS } # [doc = "Checks if the value of the field is `ADC_VBG`"]
# [inline (always)]
pub fn is_adc_vbg (& self) -> bool { * self == MUX_A :: ADC_VBG } # [doc = "Checks if the value of the field is `ADC_GND`"]
# [inline (always)]
pub fn is_adc_gnd (& self) -> bool { * self == MUX_A :: ADC_GND } } # [doc = "Field `MUX` writer - Analog Channel Selection Bits"]
pub type MUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , ADMUX_SPEC , u8 , MUX_A , 4 , O > ; impl < 'a , const O : u8 > MUX_W < 'a , O > { # [doc = "ADC Single Ended Input pin 0"]
# [inline (always)]
pub fn adc0 (self) -> & 'a mut W { self . variant (MUX_A :: ADC0) } # [doc = "ADC Single Ended Input pin 1"]
# [inline (always)]
pub fn adc1 (self) -> & 'a mut W { self . variant (MUX_A :: ADC1) } # [doc = "ADC Single Ended Input pin 2"]
# [inline (always)]
pub fn adc2 (self) -> & 'a mut W { self . variant (MUX_A :: ADC2) } # [doc = "ADC Single Ended Input pin 3"]
# [inline (always)]
pub fn adc3 (self) -> & 'a mut W { self . variant (MUX_A :: ADC3) } # [doc = "ADC Single Ended Input pin 4"]
# [inline (always)]
pub fn adc4 (self) -> & 'a mut W { self . variant (MUX_A :: ADC4) } # [doc = "ADC Single Ended Input pin 5"]
# [inline (always)]
pub fn adc5 (self) -> & 'a mut W { self . variant (MUX_A :: ADC5) } # [doc = "ADC Single Ended Input pin 6"]
# [inline (always)]
pub fn adc6 (self) -> & 'a mut W { self . variant (MUX_A :: ADC6) } # [doc = "ADC Single Ended Input pin 7"]
# [inline (always)]
pub fn adc7 (self) -> & 'a mut W { self . variant (MUX_A :: ADC7) } # [doc = "Temperature sensor"]
# [inline (always)]
pub fn tempsens (self) -> & 'a mut W { self . variant (MUX_A :: TEMPSENS) } # [doc = "Internal Reference (VBG)"]
# [inline (always)]
pub fn adc_vbg (self) -> & 'a mut W { self . variant (MUX_A :: ADC_VBG) } # [doc = "0V (GND)"]
# [inline (always)]
pub fn adc_gnd (self) -> & 'a mut W { self . variant (MUX_A :: ADC_GND) } } # [doc = "Field `ADLAR` reader - Left Adjust Result"]
pub type ADLAR_R = crate :: BitReader < bool > ; # [doc = "Field `ADLAR` writer - Left Adjust Result"]
pub type ADLAR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ADMUX_SPEC , bool , O > ; # [doc = "Field `REFS` reader - Reference Selection Bits"]
pub type REFS_R = crate :: FieldReader < u8 , REFS_A > ; # [doc = "Reference Selection Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFS_A { # [doc = "0: AREF, Internal Vref turned off"]
VAL_0X00 = 0 , # [doc = "1: AVCC with external capacitor at AREF pin"]
VAL_0X01 = 1 , # [doc = "2: Reserved"]
VAL_0X02 = 2 , # [doc = "3: Internal 1.1V Voltage Reference with external capacitor at AREF pin"]
VAL_0X03 = 3 , } impl From < REFS_A > for u8 { # [inline (always)]
fn from (variant : REFS_A) -> Self { variant as _ } } impl REFS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> REFS_A { match self . bits { 0 => REFS_A :: VAL_0X00 , 1 => REFS_A :: VAL_0X01 , 2 => REFS_A :: VAL_0X02 , 3 => REFS_A :: VAL_0X03 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == REFS_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == REFS_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == REFS_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == REFS_A :: VAL_0X03 } } # [doc = "Field `REFS` writer - Reference Selection Bits"]
pub type REFS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , ADMUX_SPEC , u8 , REFS_A , 2 , O > ; impl < 'a , const O : u8 > REFS_W < 'a , O > { # [doc = "AREF, Internal Vref turned off"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (REFS_A :: VAL_0X00) } # [doc = "AVCC with external capacitor at AREF pin"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (REFS_A :: VAL_0X01) } # [doc = "Reserved"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (REFS_A :: VAL_0X02) } # [doc = "Internal 1.1V Voltage Reference with external capacitor at AREF pin"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (REFS_A :: VAL_0X03) } } impl R { # [doc = "Bits 0:3 - Analog Channel Selection Bits"]
# [inline (always)]
pub fn mux (& self) -> MUX_R { MUX_R :: new (self . bits & 0x0f) } # [doc = "Bit 5 - Left Adjust Result"]
# [inline (always)]
pub fn adlar (& self) -> ADLAR_R { ADLAR_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Reference Selection Bits"]
# [inline (always)]
pub fn refs (& self) -> REFS_R { REFS_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:3 - Analog Channel Selection Bits"]
# [inline (always)]
# [must_use]
pub fn mux (& mut self) -> MUX_W < 0 > { MUX_W :: new (self) } # [doc = "Bit 5 - Left Adjust Result"]
# [inline (always)]
# [must_use]
pub fn adlar (& mut self) -> ADLAR_W < 5 > { ADLAR_W :: new (self) } # [doc = "Bits 6:7 - Reference Selection Bits"]
# [inline (always)]
# [must_use]
pub fn refs (& mut self) -> REFS_W < 6 > { REFS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "The ADC multiplexer Selection Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [admux](index.html) module"]
pub struct ADMUX_SPEC ; impl crate :: RegisterSpec for ADMUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [admux::R](R) reader structure"]
impl crate :: Readable for ADMUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [admux::W](W) writer structure"]
impl crate :: Writable for ADMUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADMUX to value 0"]
impl crate :: Resettable for ADMUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIDR0 (rw) register accessor: an alias for `Reg<DIDR0_SPEC>`"]
pub type DIDR0 = crate :: Reg < didr0 :: DIDR0_SPEC > ; # [doc = "Digital Input Disable Register"]
pub mod didr0 { # [doc = "Register `DIDR0` reader"]
pub struct R (crate :: R < DIDR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIDR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIDR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIDR0` writer"]
pub struct W (crate :: W < DIDR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIDR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIDR0_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADC0D` reader - No Description."]
pub type ADC0D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC0D` writer - No Description."]
pub type ADC0D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC1D` reader - No Description."]
pub type ADC1D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC1D` writer - No Description."]
pub type ADC1D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC2D` reader - No Description."]
pub type ADC2D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC2D` writer - No Description."]
pub type ADC2D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC3D` reader - No Description."]
pub type ADC3D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC3D` writer - No Description."]
pub type ADC3D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC4D` reader - No Description."]
pub type ADC4D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC4D` writer - No Description."]
pub type ADC4D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; # [doc = "Field `ADC5D` reader - No Description."]
pub type ADC5D_R = crate :: BitReader < bool > ; # [doc = "Field `ADC5D` writer - No Description."]
pub type ADC5D_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DIDR0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - No Description."]
# [inline (always)]
pub fn adc0d (& self) -> ADC0D_R { ADC0D_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - No Description."]
# [inline (always)]
pub fn adc1d (& self) -> ADC1D_R { ADC1D_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - No Description."]
# [inline (always)]
pub fn adc2d (& self) -> ADC2D_R { ADC2D_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - No Description."]
# [inline (always)]
pub fn adc3d (& self) -> ADC3D_R { ADC3D_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - No Description."]
# [inline (always)]
pub fn adc4d (& self) -> ADC4D_R { ADC4D_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - No Description."]
# [inline (always)]
pub fn adc5d (& self) -> ADC5D_R { ADC5D_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - No Description."]
# [inline (always)]
# [must_use]
pub fn adc0d (& mut self) -> ADC0D_W < 0 > { ADC0D_W :: new (self) } # [doc = "Bit 1 - No Description."]
# [inline (always)]
# [must_use]
pub fn adc1d (& mut self) -> ADC1D_W < 1 > { ADC1D_W :: new (self) } # [doc = "Bit 2 - No Description."]
# [inline (always)]
# [must_use]
pub fn adc2d (& mut self) -> ADC2D_W < 2 > { ADC2D_W :: new (self) } # [doc = "Bit 3 - No Description."]
# [inline (always)]
# [must_use]
pub fn adc3d (& mut self) -> ADC3D_W < 3 > { ADC3D_W :: new (self) } # [doc = "Bit 4 - No Description."]
# [inline (always)]
# [must_use]
pub fn adc4d (& mut self) -> ADC4D_W < 4 > { ADC4D_W :: new (self) } # [doc = "Bit 5 - No Description."]
# [inline (always)]
# [must_use]
pub fn adc5d (& mut self) -> ADC5D_W < 5 > { ADC5D_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Digital Input Disable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [didr0](index.html) module"]
pub struct DIDR0_SPEC ; impl crate :: RegisterSpec for DIDR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [didr0::R](R) reader structure"]
impl crate :: Readable for DIDR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [didr0::W](W) writer structure"]
impl crate :: Writable for DIDR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIDR0 to value 0"]
impl crate :: Resettable for DIDR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "CPU Registers"]
pub struct CPU { _marker : PhantomData < * const () > } unsafe impl Send for CPU { } impl CPU { # [doc = r"Pointer to the register block"]
pub const PTR : * const cpu :: RegisterBlock = 0x3e as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const cpu :: RegisterBlock { Self :: PTR } } impl Deref for CPU { type Target = cpu :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CPU { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CPU") . finish () } } # [doc = "CPU Registers"]
pub mod cpu { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - General Purpose I/O Register 0"]
pub gpior0 : GPIOR0 , _reserved1 : [u8 ; 0x0b]
, # [doc = "0x0c - General Purpose I/O Register 1"]
pub gpior1 : GPIOR1 , # [doc = "0x0d - General Purpose I/O Register 2"]
pub gpior2 : GPIOR2 , _reserved3 : [u8 ; 0x07]
, # [doc = "0x15 - Sleep Mode Control Register"]
pub smcr : SMCR , # [doc = "0x16 - MCU Status Register"]
pub mcusr : MCUSR , # [doc = "0x17 - MCU Control Register"]
pub mcucr : MCUCR , _reserved6 : [u8 ; 0x01]
, # [doc = "0x19 - Store Program Memory Control and Status Register"]
pub spmcsr : SPMCSR , _reserved7 : [u8 ; 0x09]
, # [doc = "0x23 - Clock Prescale Register"]
pub clkpr : CLKPR , _reserved8 : [u8 ; 0x02]
, # [doc = "0x26 - Power Reduction Register"]
pub prr : PRR , _reserved9 : [u8 ; 0x01]
, # [doc = "0x28 - Oscillator Calibration Value"]
pub osccal : OSCCAL , } # [doc = "CLKPR (rw) register accessor: an alias for `Reg<CLKPR_SPEC>`"]
pub type CLKPR = crate :: Reg < clkpr :: CLKPR_SPEC > ; # [doc = "Clock Prescale Register"]
pub mod clkpr { # [doc = "Register `CLKPR` reader"]
pub struct R (crate :: R < CLKPR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKPR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKPR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKPR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKPR` writer"]
pub struct W (crate :: W < CLKPR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKPR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKPR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKPR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKPS` reader - Clock Prescaler Select Bits"]
pub type CLKPS_R = crate :: FieldReader < u8 , CLKPS_A > ; # [doc = "Clock Prescaler Select Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKPS_A { # [doc = "0: 1"]
VAL_0X00 = 0 , # [doc = "1: 2"]
VAL_0X01 = 1 , # [doc = "2: 4"]
VAL_0X02 = 2 , # [doc = "3: 8"]
VAL_0X03 = 3 , # [doc = "4: 16"]
VAL_0X04 = 4 , # [doc = "5: 32"]
VAL_0X05 = 5 , # [doc = "6: 64"]
VAL_0X06 = 6 , # [doc = "7: 128"]
VAL_0X07 = 7 , # [doc = "8: 256"]
VAL_0X08 = 8 , } impl From < CLKPS_A > for u8 { # [inline (always)]
fn from (variant : CLKPS_A) -> Self { variant as _ } } impl CLKPS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CLKPS_A > { match self . bits { 0 => Some (CLKPS_A :: VAL_0X00) , 1 => Some (CLKPS_A :: VAL_0X01) , 2 => Some (CLKPS_A :: VAL_0X02) , 3 => Some (CLKPS_A :: VAL_0X03) , 4 => Some (CLKPS_A :: VAL_0X04) , 5 => Some (CLKPS_A :: VAL_0X05) , 6 => Some (CLKPS_A :: VAL_0X06) , 7 => Some (CLKPS_A :: VAL_0X07) , 8 => Some (CLKPS_A :: VAL_0X08) , _ => None , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == CLKPS_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == CLKPS_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == CLKPS_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == CLKPS_A :: VAL_0X03 } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == CLKPS_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == CLKPS_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `VAL_0X06`"]
# [inline (always)]
pub fn is_val_0x06 (& self) -> bool { * self == CLKPS_A :: VAL_0X06 } # [doc = "Checks if the value of the field is `VAL_0X07`"]
# [inline (always)]
pub fn is_val_0x07 (& self) -> bool { * self == CLKPS_A :: VAL_0X07 } # [doc = "Checks if the value of the field is `VAL_0X08`"]
# [inline (always)]
pub fn is_val_0x08 (& self) -> bool { * self == CLKPS_A :: VAL_0X08 } } # [doc = "Field `CLKPS` writer - Clock Prescaler Select Bits"]
pub type CLKPS_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CLKPR_SPEC , u8 , CLKPS_A , 4 , O > ; impl < 'a , const O : u8 > CLKPS_W < 'a , O > { # [doc = "1"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X00) } # [doc = "2"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X01) } # [doc = "4"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X02) } # [doc = "8"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X03) } # [doc = "16"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X04) } # [doc = "32"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X05) } # [doc = "64"]
# [inline (always)]
pub fn val_0x06 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X06) } # [doc = "128"]
# [inline (always)]
pub fn val_0x07 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X07) } # [doc = "256"]
# [inline (always)]
pub fn val_0x08 (self) -> & 'a mut W { self . variant (CLKPS_A :: VAL_0X08) } } # [doc = "Field `CLKPCE` reader - Clock Prescaler Change Enable"]
pub type CLKPCE_R = crate :: BitReader < bool > ; # [doc = "Field `CLKPCE` writer - Clock Prescaler Change Enable"]
pub type CLKPCE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CLKPR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:3 - Clock Prescaler Select Bits"]
# [inline (always)]
pub fn clkps (& self) -> CLKPS_R { CLKPS_R :: new (self . bits & 0x0f) } # [doc = "Bit 7 - Clock Prescaler Change Enable"]
# [inline (always)]
pub fn clkpce (& self) -> CLKPCE_R { CLKPCE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Clock Prescaler Select Bits"]
# [inline (always)]
# [must_use]
pub fn clkps (& mut self) -> CLKPS_W < 0 > { CLKPS_W :: new (self) } # [doc = "Bit 7 - Clock Prescaler Change Enable"]
# [inline (always)]
# [must_use]
pub fn clkpce (& mut self) -> CLKPCE_W < 7 > { CLKPCE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Prescale Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clkpr](index.html) module"]
pub struct CLKPR_SPEC ; impl crate :: RegisterSpec for CLKPR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [clkpr::R](R) reader structure"]
impl crate :: Readable for CLKPR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clkpr::W](W) writer structure"]
impl crate :: Writable for CLKPR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CLKPR to value 0"]
impl crate :: Resettable for CLKPR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR0 (rw) register accessor: an alias for `Reg<GPIOR0_SPEC>`"]
pub type GPIOR0 = crate :: Reg < gpior0 :: GPIOR0_SPEC > ; # [doc = "General Purpose I/O Register 0"]
pub mod gpior0 { # [doc = "Register `GPIOR0` reader"]
pub struct R (crate :: R < GPIOR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR0` writer"]
pub struct W (crate :: W < GPIOR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose I/O Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior0](index.html) module"]
pub struct GPIOR0_SPEC ; impl crate :: RegisterSpec for GPIOR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior0::R](R) reader structure"]
impl crate :: Readable for GPIOR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior0::W](W) writer structure"]
impl crate :: Writable for GPIOR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR0 to value 0"]
impl crate :: Resettable for GPIOR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR1 (rw) register accessor: an alias for `Reg<GPIOR1_SPEC>`"]
pub type GPIOR1 = crate :: Reg < gpior1 :: GPIOR1_SPEC > ; # [doc = "General Purpose I/O Register 1"]
pub mod gpior1 { # [doc = "Register `GPIOR1` reader"]
pub struct R (crate :: R < GPIOR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR1` writer"]
pub struct W (crate :: W < GPIOR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose I/O Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior1](index.html) module"]
pub struct GPIOR1_SPEC ; impl crate :: RegisterSpec for GPIOR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior1::R](R) reader structure"]
impl crate :: Readable for GPIOR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior1::W](W) writer structure"]
impl crate :: Writable for GPIOR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR1 to value 0"]
impl crate :: Resettable for GPIOR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR2 (rw) register accessor: an alias for `Reg<GPIOR2_SPEC>`"]
pub type GPIOR2 = crate :: Reg < gpior2 :: GPIOR2_SPEC > ; # [doc = "General Purpose I/O Register 2"]
pub mod gpior2 { # [doc = "Register `GPIOR2` reader"]
pub struct R (crate :: R < GPIOR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR2` writer"]
pub struct W (crate :: W < GPIOR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose I/O Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior2](index.html) module"]
pub struct GPIOR2_SPEC ; impl crate :: RegisterSpec for GPIOR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior2::R](R) reader structure"]
impl crate :: Readable for GPIOR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior2::W](W) writer structure"]
impl crate :: Writable for GPIOR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR2 to value 0"]
impl crate :: Resettable for GPIOR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCUCR (rw) register accessor: an alias for `Reg<MCUCR_SPEC>`"]
pub type MCUCR = crate :: Reg < mcucr :: MCUCR_SPEC > ; # [doc = "MCU Control Register"]
pub mod mcucr { # [doc = "Register `MCUCR` reader"]
pub struct R (crate :: R < MCUCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCUCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCUCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCUCR` writer"]
pub struct W (crate :: W < MCUCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCUCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCUCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `IVCE` reader - No Description."]
pub type IVCE_R = crate :: BitReader < bool > ; # [doc = "Field `IVCE` writer - No Description."]
pub type IVCE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; # [doc = "Field `IVSEL` reader - No Description."]
pub type IVSEL_R = crate :: BitReader < bool > ; # [doc = "Field `IVSEL` writer - No Description."]
pub type IVSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; # [doc = "Field `PUD` reader - No Description."]
pub type PUD_R = crate :: BitReader < bool > ; # [doc = "Field `PUD` writer - No Description."]
pub type PUD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; # [doc = "Field `BODSE` reader - BOD Sleep Enable"]
pub type BODSE_R = crate :: BitReader < bool > ; # [doc = "Field `BODSE` writer - BOD Sleep Enable"]
pub type BODSE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; # [doc = "Field `BODS` reader - BOD Sleep"]
pub type BODS_R = crate :: BitReader < bool > ; # [doc = "Field `BODS` writer - BOD Sleep"]
pub type BODS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - No Description."]
# [inline (always)]
pub fn ivce (& self) -> IVCE_R { IVCE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - No Description."]
# [inline (always)]
pub fn ivsel (& self) -> IVSEL_R { IVSEL_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - No Description."]
# [inline (always)]
pub fn pud (& self) -> PUD_R { PUD_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - BOD Sleep Enable"]
# [inline (always)]
pub fn bodse (& self) -> BODSE_R { BODSE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - BOD Sleep"]
# [inline (always)]
pub fn bods (& self) -> BODS_R { BODS_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - No Description."]
# [inline (always)]
# [must_use]
pub fn ivce (& mut self) -> IVCE_W < 0 > { IVCE_W :: new (self) } # [doc = "Bit 1 - No Description."]
# [inline (always)]
# [must_use]
pub fn ivsel (& mut self) -> IVSEL_W < 1 > { IVSEL_W :: new (self) } # [doc = "Bit 4 - No Description."]
# [inline (always)]
# [must_use]
pub fn pud (& mut self) -> PUD_W < 4 > { PUD_W :: new (self) } # [doc = "Bit 5 - BOD Sleep Enable"]
# [inline (always)]
# [must_use]
pub fn bodse (& mut self) -> BODSE_W < 5 > { BODSE_W :: new (self) } # [doc = "Bit 6 - BOD Sleep"]
# [inline (always)]
# [must_use]
pub fn bods (& mut self) -> BODS_W < 6 > { BODS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCU Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcucr](index.html) module"]
pub struct MCUCR_SPEC ; impl crate :: RegisterSpec for MCUCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mcucr::R](R) reader structure"]
impl crate :: Readable for MCUCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mcucr::W](W) writer structure"]
impl crate :: Writable for MCUCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCUCR to value 0"]
impl crate :: Resettable for MCUCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCUSR (rw) register accessor: an alias for `Reg<MCUSR_SPEC>`"]
pub type MCUSR = crate :: Reg < mcusr :: MCUSR_SPEC > ; # [doc = "MCU Status Register"]
pub mod mcusr { # [doc = "Register `MCUSR` reader"]
pub struct R (crate :: R < MCUSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCUSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCUSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCUSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCUSR` writer"]
pub struct W (crate :: W < MCUSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCUSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCUSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCUSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PORF` reader - Power-on reset flag"]
pub type PORF_R = crate :: BitReader < bool > ; # [doc = "Field `PORF` writer - Power-on reset flag"]
pub type PORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; # [doc = "Field `EXTRF` reader - External Reset Flag"]
pub type EXTRF_R = crate :: BitReader < bool > ; # [doc = "Field `EXTRF` writer - External Reset Flag"]
pub type EXTRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; # [doc = "Field `BORF` reader - Brown-out Reset Flag"]
pub type BORF_R = crate :: BitReader < bool > ; # [doc = "Field `BORF` writer - Brown-out Reset Flag"]
pub type BORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; # [doc = "Field `WDRF` reader - Watchdog Reset Flag"]
pub type WDRF_R = crate :: BitReader < bool > ; # [doc = "Field `WDRF` writer - Watchdog Reset Flag"]
pub type WDRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUSR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Power-on reset flag"]
# [inline (always)]
pub fn porf (& self) -> PORF_R { PORF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Reset Flag"]
# [inline (always)]
pub fn extrf (& self) -> EXTRF_R { EXTRF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Brown-out Reset Flag"]
# [inline (always)]
pub fn borf (& self) -> BORF_R { BORF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Watchdog Reset Flag"]
# [inline (always)]
pub fn wdrf (& self) -> WDRF_R { WDRF_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Power-on reset flag"]
# [inline (always)]
# [must_use]
pub fn porf (& mut self) -> PORF_W < 0 > { PORF_W :: new (self) } # [doc = "Bit 1 - External Reset Flag"]
# [inline (always)]
# [must_use]
pub fn extrf (& mut self) -> EXTRF_W < 1 > { EXTRF_W :: new (self) } # [doc = "Bit 2 - Brown-out Reset Flag"]
# [inline (always)]
# [must_use]
pub fn borf (& mut self) -> BORF_W < 2 > { BORF_W :: new (self) } # [doc = "Bit 3 - Watchdog Reset Flag"]
# [inline (always)]
# [must_use]
pub fn wdrf (& mut self) -> WDRF_W < 3 > { WDRF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCU Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcusr](index.html) module"]
pub struct MCUSR_SPEC ; impl crate :: RegisterSpec for MCUSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mcusr::R](R) reader structure"]
impl crate :: Readable for MCUSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mcusr::W](W) writer structure"]
impl crate :: Writable for MCUSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCUSR to value 0"]
impl crate :: Resettable for MCUSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OSCCAL (rw) register accessor: an alias for `Reg<OSCCAL_SPEC>`"]
pub type OSCCAL = crate :: Reg < osccal :: OSCCAL_SPEC > ; # [doc = "Oscillator Calibration Value"]
pub mod osccal { # [doc = "Register `OSCCAL` reader"]
pub struct R (crate :: R < OSCCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSCCAL` writer"]
pub struct W (crate :: W < OSCCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSCCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSCCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSCCAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OSCCAL` reader - Oscillator Calibration"]
pub type OSCCAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `OSCCAL` writer - Oscillator Calibration"]
pub type OSCCAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OSCCAL_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Oscillator Calibration"]
# [inline (always)]
pub fn osccal (& self) -> OSCCAL_R { OSCCAL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Oscillator Calibration"]
# [inline (always)]
# [must_use]
pub fn osccal (& mut self) -> OSCCAL_W < 0 > { OSCCAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Oscillator Calibration Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osccal](index.html) module"]
pub struct OSCCAL_SPEC ; impl crate :: RegisterSpec for OSCCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osccal::R](R) reader structure"]
impl crate :: Readable for OSCCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osccal::W](W) writer structure"]
impl crate :: Writable for OSCCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OSCCAL to value 0"]
impl crate :: Resettable for OSCCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRR (rw) register accessor: an alias for `Reg<PRR_SPEC>`"]
pub type PRR = crate :: Reg < prr :: PRR_SPEC > ; # [doc = "Power Reduction Register"]
pub mod prr { # [doc = "Register `PRR` reader"]
pub struct R (crate :: R < PRR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRR_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRR` writer"]
pub struct W (crate :: W < PRR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRADC` reader - Power Reduction ADC"]
pub type PRADC_R = crate :: BitReader < bool > ; # [doc = "Field `PRADC` writer - Power Reduction ADC"]
pub type PRADC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR_SPEC , bool , O > ; # [doc = "Field `PRUSART0` reader - Power Reduction USART"]
pub type PRUSART0_R = crate :: BitReader < bool > ; # [doc = "Field `PRUSART0` writer - Power Reduction USART"]
pub type PRUSART0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR_SPEC , bool , O > ; # [doc = "Field `PRSPI` reader - Power Reduction Serial Peripheral Interface"]
pub type PRSPI_R = crate :: BitReader < bool > ; # [doc = "Field `PRSPI` writer - Power Reduction Serial Peripheral Interface"]
pub type PRSPI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR_SPEC , bool , O > ; # [doc = "Field `PRTIM1` reader - Power Reduction Timer/Counter1"]
pub type PRTIM1_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM1` writer - Power Reduction Timer/Counter1"]
pub type PRTIM1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR_SPEC , bool , O > ; # [doc = "Field `PRTIM0` reader - Power Reduction Timer/Counter0"]
pub type PRTIM0_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM0` writer - Power Reduction Timer/Counter0"]
pub type PRTIM0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR_SPEC , bool , O > ; # [doc = "Field `PRTIM2` reader - Power Reduction Timer/Counter2"]
pub type PRTIM2_R = crate :: BitReader < bool > ; # [doc = "Field `PRTIM2` writer - Power Reduction Timer/Counter2"]
pub type PRTIM2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR_SPEC , bool , O > ; # [doc = "Field `PRTWI` reader - Power Reduction TWI"]
pub type PRTWI_R = crate :: BitReader < bool > ; # [doc = "Field `PRTWI` writer - Power Reduction TWI"]
pub type PRTWI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Power Reduction ADC"]
# [inline (always)]
pub fn pradc (& self) -> PRADC_R { PRADC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Power Reduction USART"]
# [inline (always)]
pub fn prusart0 (& self) -> PRUSART0_R { PRUSART0_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Power Reduction Serial Peripheral Interface"]
# [inline (always)]
pub fn prspi (& self) -> PRSPI_R { PRSPI_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Power Reduction Timer/Counter1"]
# [inline (always)]
pub fn prtim1 (& self) -> PRTIM1_R { PRTIM1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Power Reduction Timer/Counter0"]
# [inline (always)]
pub fn prtim0 (& self) -> PRTIM0_R { PRTIM0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Power Reduction Timer/Counter2"]
# [inline (always)]
pub fn prtim2 (& self) -> PRTIM2_R { PRTIM2_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Power Reduction TWI"]
# [inline (always)]
pub fn prtwi (& self) -> PRTWI_R { PRTWI_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Power Reduction ADC"]
# [inline (always)]
# [must_use]
pub fn pradc (& mut self) -> PRADC_W < 0 > { PRADC_W :: new (self) } # [doc = "Bit 1 - Power Reduction USART"]
# [inline (always)]
# [must_use]
pub fn prusart0 (& mut self) -> PRUSART0_W < 1 > { PRUSART0_W :: new (self) } # [doc = "Bit 2 - Power Reduction Serial Peripheral Interface"]
# [inline (always)]
# [must_use]
pub fn prspi (& mut self) -> PRSPI_W < 2 > { PRSPI_W :: new (self) } # [doc = "Bit 3 - Power Reduction Timer/Counter1"]
# [inline (always)]
# [must_use]
pub fn prtim1 (& mut self) -> PRTIM1_W < 3 > { PRTIM1_W :: new (self) } # [doc = "Bit 5 - Power Reduction Timer/Counter0"]
# [inline (always)]
# [must_use]
pub fn prtim0 (& mut self) -> PRTIM0_W < 5 > { PRTIM0_W :: new (self) } # [doc = "Bit 6 - Power Reduction Timer/Counter2"]
# [inline (always)]
# [must_use]
pub fn prtim2 (& mut self) -> PRTIM2_W < 6 > { PRTIM2_W :: new (self) } # [doc = "Bit 7 - Power Reduction TWI"]
# [inline (always)]
# [must_use]
pub fn prtwi (& mut self) -> PRTWI_W < 7 > { PRTWI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prr](index.html) module"]
pub struct PRR_SPEC ; impl crate :: RegisterSpec for PRR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prr::R](R) reader structure"]
impl crate :: Readable for PRR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prr::W](W) writer structure"]
impl crate :: Writable for PRR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRR to value 0"]
impl crate :: Resettable for PRR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SMCR (rw) register accessor: an alias for `Reg<SMCR_SPEC>`"]
pub type SMCR = crate :: Reg < smcr :: SMCR_SPEC > ; # [doc = "Sleep Mode Control Register"]
pub mod smcr { # [doc = "Register `SMCR` reader"]
pub struct R (crate :: R < SMCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SMCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SMCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SMCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SMCR` writer"]
pub struct W (crate :: W < SMCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SMCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SMCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SMCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SE` reader - Sleep Enable"]
pub type SE_R = crate :: BitReader < bool > ; # [doc = "Field `SE` writer - Sleep Enable"]
pub type SE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SMCR_SPEC , bool , O > ; # [doc = "Field `SM` reader - Sleep Mode Select Bits"]
pub type SM_R = crate :: FieldReader < u8 , SM_A > ; # [doc = "Sleep Mode Select Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SM_A { # [doc = "0: Idle"]
IDLE = 0 , # [doc = "1: ADC Noise Reduction (If Available)"]
ADC = 1 , # [doc = "2: Power Down"]
PDOWN = 2 , # [doc = "3: Power Save"]
PSAVE = 3 , # [doc = "4: Reserved"]
VAL_0X04 = 4 , # [doc = "5: Reserved"]
VAL_0X05 = 5 , # [doc = "6: Standby"]
STDBY = 6 , # [doc = "7: Extended Standby"]
ESTDBY = 7 , } impl From < SM_A > for u8 { # [inline (always)]
fn from (variant : SM_A) -> Self { variant as _ } } impl SM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SM_A { match self . bits { 0 => SM_A :: IDLE , 1 => SM_A :: ADC , 2 => SM_A :: PDOWN , 3 => SM_A :: PSAVE , 4 => SM_A :: VAL_0X04 , 5 => SM_A :: VAL_0X05 , 6 => SM_A :: STDBY , 7 => SM_A :: ESTDBY , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `IDLE`"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == SM_A :: IDLE } # [doc = "Checks if the value of the field is `ADC`"]
# [inline (always)]
pub fn is_adc (& self) -> bool { * self == SM_A :: ADC } # [doc = "Checks if the value of the field is `PDOWN`"]
# [inline (always)]
pub fn is_pdown (& self) -> bool { * self == SM_A :: PDOWN } # [doc = "Checks if the value of the field is `PSAVE`"]
# [inline (always)]
pub fn is_psave (& self) -> bool { * self == SM_A :: PSAVE } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == SM_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == SM_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `STDBY`"]
# [inline (always)]
pub fn is_stdby (& self) -> bool { * self == SM_A :: STDBY } # [doc = "Checks if the value of the field is `ESTDBY`"]
# [inline (always)]
pub fn is_estdby (& self) -> bool { * self == SM_A :: ESTDBY } } # [doc = "Field `SM` writer - Sleep Mode Select Bits"]
pub type SM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SMCR_SPEC , u8 , SM_A , 3 , O > ; impl < 'a , const O : u8 > SM_W < 'a , O > { # [doc = "Idle"]
# [inline (always)]
pub fn idle (self) -> & 'a mut W { self . variant (SM_A :: IDLE) } # [doc = "ADC Noise Reduction (If Available)"]
# [inline (always)]
pub fn adc (self) -> & 'a mut W { self . variant (SM_A :: ADC) } # [doc = "Power Down"]
# [inline (always)]
pub fn pdown (self) -> & 'a mut W { self . variant (SM_A :: PDOWN) } # [doc = "Power Save"]
# [inline (always)]
pub fn psave (self) -> & 'a mut W { self . variant (SM_A :: PSAVE) } # [doc = "Reserved"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (SM_A :: VAL_0X04) } # [doc = "Reserved"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (SM_A :: VAL_0X05) } # [doc = "Standby"]
# [inline (always)]
pub fn stdby (self) -> & 'a mut W { self . variant (SM_A :: STDBY) } # [doc = "Extended Standby"]
# [inline (always)]
pub fn estdby (self) -> & 'a mut W { self . variant (SM_A :: ESTDBY) } } impl R { # [doc = "Bit 0 - Sleep Enable"]
# [inline (always)]
pub fn se (& self) -> SE_R { SE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Sleep Mode Select Bits"]
# [inline (always)]
pub fn sm (& self) -> SM_R { SM_R :: new ((self . bits >> 1) & 7) } } impl W { # [doc = "Bit 0 - Sleep Enable"]
# [inline (always)]
# [must_use]
pub fn se (& mut self) -> SE_W < 0 > { SE_W :: new (self) } # [doc = "Bits 1:3 - Sleep Mode Select Bits"]
# [inline (always)]
# [must_use]
pub fn sm (& mut self) -> SM_W < 1 > { SM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sleep Mode Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [smcr](index.html) module"]
pub struct SMCR_SPEC ; impl crate :: RegisterSpec for SMCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [smcr::R](R) reader structure"]
impl crate :: Readable for SMCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [smcr::W](W) writer structure"]
impl crate :: Writable for SMCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SMCR to value 0"]
impl crate :: Resettable for SMCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPMCSR (rw) register accessor: an alias for `Reg<SPMCSR_SPEC>`"]
pub type SPMCSR = crate :: Reg < spmcsr :: SPMCSR_SPEC > ; # [doc = "Store Program Memory Control and Status Register"]
pub mod spmcsr { # [doc = "Register `SPMCSR` reader"]
pub struct R (crate :: R < SPMCSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPMCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPMCSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPMCSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPMCSR` writer"]
pub struct W (crate :: W < SPMCSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPMCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPMCSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPMCSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPMEN` reader - Store Program Memory"]
pub type SPMEN_R = crate :: BitReader < bool > ; # [doc = "Field `SPMEN` writer - Store Program Memory"]
pub type SPMEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `PGERS` reader - Page Erase"]
pub type PGERS_R = crate :: BitReader < bool > ; # [doc = "Field `PGERS` writer - Page Erase"]
pub type PGERS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `PGWRT` reader - Page Write"]
pub type PGWRT_R = crate :: BitReader < bool > ; # [doc = "Field `PGWRT` writer - Page Write"]
pub type PGWRT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `BLBSET` reader - Boot Lock Bit Set"]
pub type BLBSET_R = crate :: BitReader < bool > ; # [doc = "Field `BLBSET` writer - Boot Lock Bit Set"]
pub type BLBSET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `RWWSRE` reader - Read-While-Write section read enable"]
pub type RWWSRE_R = crate :: BitReader < bool > ; # [doc = "Field `RWWSRE` writer - Read-While-Write section read enable"]
pub type RWWSRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `SIGRD` reader - Signature Row Read"]
pub type SIGRD_R = crate :: BitReader < bool > ; # [doc = "Field `SIGRD` writer - Signature Row Read"]
pub type SIGRD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `RWWSB` reader - Read-While-Write Section Busy"]
pub type RWWSB_R = crate :: BitReader < bool > ; # [doc = "Field `RWWSB` writer - Read-While-Write Section Busy"]
pub type RWWSB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; # [doc = "Field `SPMIE` reader - SPM Interrupt Enable"]
pub type SPMIE_R = crate :: BitReader < bool > ; # [doc = "Field `SPMIE` writer - SPM Interrupt Enable"]
pub type SPMIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPMCSR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Store Program Memory"]
# [inline (always)]
pub fn spmen (& self) -> SPMEN_R { SPMEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Page Erase"]
# [inline (always)]
pub fn pgers (& self) -> PGERS_R { PGERS_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Page Write"]
# [inline (always)]
pub fn pgwrt (& self) -> PGWRT_R { PGWRT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Boot Lock Bit Set"]
# [inline (always)]
pub fn blbset (& self) -> BLBSET_R { BLBSET_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Read-While-Write section read enable"]
# [inline (always)]
pub fn rwwsre (& self) -> RWWSRE_R { RWWSRE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Signature Row Read"]
# [inline (always)]
pub fn sigrd (& self) -> SIGRD_R { SIGRD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Read-While-Write Section Busy"]
# [inline (always)]
pub fn rwwsb (& self) -> RWWSB_R { RWWSB_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - SPM Interrupt Enable"]
# [inline (always)]
pub fn spmie (& self) -> SPMIE_R { SPMIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Store Program Memory"]
# [inline (always)]
# [must_use]
pub fn spmen (& mut self) -> SPMEN_W < 0 > { SPMEN_W :: new (self) } # [doc = "Bit 1 - Page Erase"]
# [inline (always)]
# [must_use]
pub fn pgers (& mut self) -> PGERS_W < 1 > { PGERS_W :: new (self) } # [doc = "Bit 2 - Page Write"]
# [inline (always)]
# [must_use]
pub fn pgwrt (& mut self) -> PGWRT_W < 2 > { PGWRT_W :: new (self) } # [doc = "Bit 3 - Boot Lock Bit Set"]
# [inline (always)]
# [must_use]
pub fn blbset (& mut self) -> BLBSET_W < 3 > { BLBSET_W :: new (self) } # [doc = "Bit 4 - Read-While-Write section read enable"]
# [inline (always)]
# [must_use]
pub fn rwwsre (& mut self) -> RWWSRE_W < 4 > { RWWSRE_W :: new (self) } # [doc = "Bit 5 - Signature Row Read"]
# [inline (always)]
# [must_use]
pub fn sigrd (& mut self) -> SIGRD_W < 5 > { SIGRD_W :: new (self) } # [doc = "Bit 6 - Read-While-Write Section Busy"]
# [inline (always)]
# [must_use]
pub fn rwwsb (& mut self) -> RWWSB_W < 6 > { RWWSB_W :: new (self) } # [doc = "Bit 7 - SPM Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn spmie (& mut self) -> SPMIE_W < 7 > { SPMIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Store Program Memory Control and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spmcsr](index.html) module"]
pub struct SPMCSR_SPEC ; impl crate :: RegisterSpec for SPMCSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spmcsr::R](R) reader structure"]
impl crate :: Readable for SPMCSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spmcsr::W](W) writer structure"]
impl crate :: Writable for SPMCSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPMCSR to value 0"]
impl crate :: Resettable for SPMCSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "EEPROM"]
pub struct EEPROM { _marker : PhantomData < * const () > } unsafe impl Send for EEPROM { } impl EEPROM { # [doc = r"Pointer to the register block"]
pub const PTR : * const eeprom :: RegisterBlock = 0x3f as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const eeprom :: RegisterBlock { Self :: PTR } } impl Deref for EEPROM { type Target = eeprom :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EEPROM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EEPROM") . finish () } } # [doc = "EEPROM"]
pub mod eeprom { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - EEPROM Control Register"]
pub eecr : EECR , # [doc = "0x01 - EEPROM Data Register"]
pub eedr : EEDR , # [doc = "0x02 - EEPROM Address Register Bytes"]
pub eear : EEAR , } # [doc = "EEAR (rw) register accessor: an alias for `Reg<EEAR_SPEC>`"]
pub type EEAR = crate :: Reg < eear :: EEAR_SPEC > ; # [doc = "EEPROM Address Register Bytes"]
pub mod eear { # [doc = "Register `EEAR` reader"]
pub struct R (crate :: R < EEAR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EEAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EEAR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EEAR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EEAR` writer"]
pub struct W (crate :: W < EEAR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EEAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EEAR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EEAR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "EEPROM Address Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eear](index.html) module"]
pub struct EEAR_SPEC ; impl crate :: RegisterSpec for EEAR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [eear::R](R) reader structure"]
impl crate :: Readable for EEAR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eear::W](W) writer structure"]
impl crate :: Writable for EEAR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EEAR to value 0"]
impl crate :: Resettable for EEAR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EECR (rw) register accessor: an alias for `Reg<EECR_SPEC>`"]
pub type EECR = crate :: Reg < eecr :: EECR_SPEC > ; # [doc = "EEPROM Control Register"]
pub mod eecr { # [doc = "Register `EECR` reader"]
pub struct R (crate :: R < EECR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EECR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EECR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EECR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EECR` writer"]
pub struct W (crate :: W < EECR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EECR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EECR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EECR_SPEC >) -> Self { W (writer) } } # [doc = "Field `EERE` reader - EEPROM Read Enable"]
pub type EERE_R = crate :: BitReader < bool > ; # [doc = "Field `EERE` writer - EEPROM Read Enable"]
pub type EERE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EECR_SPEC , bool , O > ; # [doc = "Field `EEPE` reader - EEPROM Write Enable"]
pub type EEPE_R = crate :: BitReader < bool > ; # [doc = "Field `EEPE` writer - EEPROM Write Enable"]
pub type EEPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EECR_SPEC , bool , O > ; # [doc = "Field `EEMPE` reader - EEPROM Master Write Enable"]
pub type EEMPE_R = crate :: BitReader < bool > ; # [doc = "Field `EEMPE` writer - EEPROM Master Write Enable"]
pub type EEMPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EECR_SPEC , bool , O > ; # [doc = "Field `EERIE` reader - EEPROM Ready Interrupt Enable"]
pub type EERIE_R = crate :: BitReader < bool > ; # [doc = "Field `EERIE` writer - EEPROM Ready Interrupt Enable"]
pub type EERIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EECR_SPEC , bool , O > ; # [doc = "Field `EEPM` reader - EEPROM Programming Mode Bits"]
pub type EEPM_R = crate :: FieldReader < u8 , EEPM_A > ; # [doc = "EEPROM Programming Mode Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EEPM_A { # [doc = "0: Erase and Write in one operation"]
VAL_0X00 = 0 , # [doc = "1: Erase Only"]
VAL_0X01 = 1 , # [doc = "2: Write Only"]
VAL_0X02 = 2 , } impl From < EEPM_A > for u8 { # [inline (always)]
fn from (variant : EEPM_A) -> Self { variant as _ } } impl EEPM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EEPM_A > { match self . bits { 0 => Some (EEPM_A :: VAL_0X00) , 1 => Some (EEPM_A :: VAL_0X01) , 2 => Some (EEPM_A :: VAL_0X02) , _ => None , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == EEPM_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == EEPM_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == EEPM_A :: VAL_0X02 } } # [doc = "Field `EEPM` writer - EEPROM Programming Mode Bits"]
pub type EEPM_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , EECR_SPEC , u8 , EEPM_A , 2 , O > ; impl < 'a , const O : u8 > EEPM_W < 'a , O > { # [doc = "Erase and Write in one operation"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (EEPM_A :: VAL_0X00) } # [doc = "Erase Only"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (EEPM_A :: VAL_0X01) } # [doc = "Write Only"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (EEPM_A :: VAL_0X02) } } impl R { # [doc = "Bit 0 - EEPROM Read Enable"]
# [inline (always)]
pub fn eere (& self) -> EERE_R { EERE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EEPROM Write Enable"]
# [inline (always)]
pub fn eepe (& self) -> EEPE_R { EEPE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - EEPROM Master Write Enable"]
# [inline (always)]
pub fn eempe (& self) -> EEMPE_R { EEMPE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - EEPROM Ready Interrupt Enable"]
# [inline (always)]
pub fn eerie (& self) -> EERIE_R { EERIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - EEPROM Programming Mode Bits"]
# [inline (always)]
pub fn eepm (& self) -> EEPM_R { EEPM_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bit 0 - EEPROM Read Enable"]
# [inline (always)]
# [must_use]
pub fn eere (& mut self) -> EERE_W < 0 > { EERE_W :: new (self) } # [doc = "Bit 1 - EEPROM Write Enable"]
# [inline (always)]
# [must_use]
pub fn eepe (& mut self) -> EEPE_W < 1 > { EEPE_W :: new (self) } # [doc = "Bit 2 - EEPROM Master Write Enable"]
# [inline (always)]
# [must_use]
pub fn eempe (& mut self) -> EEMPE_W < 2 > { EEMPE_W :: new (self) } # [doc = "Bit 3 - EEPROM Ready Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn eerie (& mut self) -> EERIE_W < 3 > { EERIE_W :: new (self) } # [doc = "Bits 4:5 - EEPROM Programming Mode Bits"]
# [inline (always)]
# [must_use]
pub fn eepm (& mut self) -> EEPM_W < 4 > { EEPM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "EEPROM Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eecr](index.html) module"]
pub struct EECR_SPEC ; impl crate :: RegisterSpec for EECR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eecr::R](R) reader structure"]
impl crate :: Readable for EECR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eecr::W](W) writer structure"]
impl crate :: Writable for EECR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EECR to value 0"]
impl crate :: Resettable for EECR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EEDR (rw) register accessor: an alias for `Reg<EEDR_SPEC>`"]
pub type EEDR = crate :: Reg < eedr :: EEDR_SPEC > ; # [doc = "EEPROM Data Register"]
pub mod eedr { # [doc = "Register `EEDR` reader"]
pub struct R (crate :: R < EEDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EEDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EEDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EEDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EEDR` writer"]
pub struct W (crate :: W < EEDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EEDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EEDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EEDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "EEPROM Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eedr](index.html) module"]
pub struct EEDR_SPEC ; impl crate :: RegisterSpec for EEDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eedr::R](R) reader structure"]
impl crate :: Readable for EEDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eedr::W](W) writer structure"]
impl crate :: Writable for EEDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EEDR to value 0"]
impl crate :: Resettable for EEDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "External Interrupts"]
pub struct EXINT { _marker : PhantomData < * const () > } unsafe impl Send for EXINT { } impl EXINT { # [doc = r"Pointer to the register block"]
pub const PTR : * const exint :: RegisterBlock = 0x3b as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const exint :: RegisterBlock { Self :: PTR } } impl Deref for EXINT { type Target = exint :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EXINT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EXINT") . finish () } } # [doc = "External Interrupts"]
pub mod exint { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Pin Change Interrupt Flag Register"]
pub pcifr : PCIFR , # [doc = "0x01 - External Interrupt Flag Register"]
pub eifr : EIFR , # [doc = "0x02 - External Interrupt Mask Register"]
pub eimsk : EIMSK , _reserved3 : [u8 ; 0x2a]
, # [doc = "0x2d - Pin Change Interrupt Control Register"]
pub pcicr : PCICR , # [doc = "0x2e - External Interrupt Control Register"]
pub eicra : EICRA , _reserved5 : [u8 ; 0x01]
, # [doc = "0x30 - Pin Change Mask Register 0"]
pub pcmsk0 : PCMSK0 , # [doc = "0x31 - Pin Change Mask Register 1"]
pub pcmsk1 : PCMSK1 , # [doc = "0x32 - Pin Change Mask Register 2"]
pub pcmsk2 : PCMSK2 , } # [doc = "EICRA (rw) register accessor: an alias for `Reg<EICRA_SPEC>`"]
pub type EICRA = crate :: Reg < eicra :: EICRA_SPEC > ; # [doc = "External Interrupt Control Register"]
pub mod eicra { # [doc = "Register `EICRA` reader"]
pub struct R (crate :: R < EICRA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EICRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EICRA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EICRA_SPEC >) -> Self { R (reader) } } # [doc = "Register `EICRA` writer"]
pub struct W (crate :: W < EICRA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EICRA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EICRA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EICRA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC0` reader - External Interrupt Sense Control 0 Bits"]
pub type ISC0_R = crate :: FieldReader < u8 , ISC0_A > ; # [doc = "External Interrupt Sense Control 0 Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC0_A { # [doc = "0: Low Level of INTX"]
VAL_0X00 = 0 , # [doc = "1: Any Logical Change of INTX"]
VAL_0X01 = 1 , # [doc = "2: Falling Edge of INTX"]
VAL_0X02 = 2 , # [doc = "3: Rising Edge of INTX"]
VAL_0X03 = 3 , } impl From < ISC0_A > for u8 { # [inline (always)]
fn from (variant : ISC0_A) -> Self { variant as _ } } impl ISC0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC0_A { match self . bits { 0 => ISC0_A :: VAL_0X00 , 1 => ISC0_A :: VAL_0X01 , 2 => ISC0_A :: VAL_0X02 , 3 => ISC0_A :: VAL_0X03 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == ISC0_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == ISC0_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == ISC0_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == ISC0_A :: VAL_0X03 } } # [doc = "Field `ISC0` writer - External Interrupt Sense Control 0 Bits"]
pub type ISC0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRA_SPEC , u8 , ISC0_A , 2 , O > ; impl < 'a , const O : u8 > ISC0_W < 'a , O > { # [doc = "Low Level of INTX"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (ISC0_A :: VAL_0X00) } # [doc = "Any Logical Change of INTX"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (ISC0_A :: VAL_0X01) } # [doc = "Falling Edge of INTX"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (ISC0_A :: VAL_0X02) } # [doc = "Rising Edge of INTX"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (ISC0_A :: VAL_0X03) } } # [doc = "Field `ISC1` reader - External Interrupt Sense Control 1 Bits"]
pub type ISC1_R = crate :: FieldReader < u8 , ISC1_A > ; # [doc = "External Interrupt Sense Control 1 Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC1_A { # [doc = "0: Low Level of INTX"]
VAL_0X00 = 0 , # [doc = "1: Any Logical Change of INTX"]
VAL_0X01 = 1 , # [doc = "2: Falling Edge of INTX"]
VAL_0X02 = 2 , # [doc = "3: Rising Edge of INTX"]
VAL_0X03 = 3 , } impl From < ISC1_A > for u8 { # [inline (always)]
fn from (variant : ISC1_A) -> Self { variant as _ } } impl ISC1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ISC1_A { match self . bits { 0 => ISC1_A :: VAL_0X00 , 1 => ISC1_A :: VAL_0X01 , 2 => ISC1_A :: VAL_0X02 , 3 => ISC1_A :: VAL_0X03 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == ISC1_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == ISC1_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == ISC1_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == ISC1_A :: VAL_0X03 } } # [doc = "Field `ISC1` writer - External Interrupt Sense Control 1 Bits"]
pub type ISC1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EICRA_SPEC , u8 , ISC1_A , 2 , O > ; impl < 'a , const O : u8 > ISC1_W < 'a , O > { # [doc = "Low Level of INTX"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (ISC1_A :: VAL_0X00) } # [doc = "Any Logical Change of INTX"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (ISC1_A :: VAL_0X01) } # [doc = "Falling Edge of INTX"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (ISC1_A :: VAL_0X02) } # [doc = "Rising Edge of INTX"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (ISC1_A :: VAL_0X03) } } impl R { # [doc = "Bits 0:1 - External Interrupt Sense Control 0 Bits"]
# [inline (always)]
pub fn isc0 (& self) -> ISC0_R { ISC0_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - External Interrupt Sense Control 1 Bits"]
# [inline (always)]
pub fn isc1 (& self) -> ISC1_R { ISC1_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - External Interrupt Sense Control 0 Bits"]
# [inline (always)]
# [must_use]
pub fn isc0 (& mut self) -> ISC0_W < 0 > { ISC0_W :: new (self) } # [doc = "Bits 2:3 - External Interrupt Sense Control 1 Bits"]
# [inline (always)]
# [must_use]
pub fn isc1 (& mut self) -> ISC1_W < 2 > { ISC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eicra](index.html) module"]
pub struct EICRA_SPEC ; impl crate :: RegisterSpec for EICRA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eicra::R](R) reader structure"]
impl crate :: Readable for EICRA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eicra::W](W) writer structure"]
impl crate :: Writable for EICRA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EICRA to value 0"]
impl crate :: Resettable for EICRA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EIFR (rw) register accessor: an alias for `Reg<EIFR_SPEC>`"]
pub type EIFR = crate :: Reg < eifr :: EIFR_SPEC > ; # [doc = "External Interrupt Flag Register"]
pub mod eifr { # [doc = "Register `EIFR` reader"]
pub struct R (crate :: R < EIFR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EIFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EIFR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EIFR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EIFR` writer"]
pub struct W (crate :: W < EIFR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EIFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EIFR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EIFR_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTF` reader - External Interrupt Flags"]
pub type INTF_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INTF` writer - External Interrupt Flags"]
pub type INTF_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EIFR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bits 0:1 - External Interrupt Flags"]
# [inline (always)]
pub fn intf (& self) -> INTF_R { INTF_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - External Interrupt Flags"]
# [inline (always)]
# [must_use]
pub fn intf (& mut self) -> INTF_W < 0 > { INTF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eifr](index.html) module"]
pub struct EIFR_SPEC ; impl crate :: RegisterSpec for EIFR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eifr::R](R) reader structure"]
impl crate :: Readable for EIFR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eifr::W](W) writer structure"]
impl crate :: Writable for EIFR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EIFR to value 0"]
impl crate :: Resettable for EIFR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EIMSK (rw) register accessor: an alias for `Reg<EIMSK_SPEC>`"]
pub type EIMSK = crate :: Reg < eimsk :: EIMSK_SPEC > ; # [doc = "External Interrupt Mask Register"]
pub mod eimsk { # [doc = "Register `EIMSK` reader"]
pub struct R (crate :: R < EIMSK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EIMSK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EIMSK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EIMSK_SPEC >) -> Self { R (reader) } } # [doc = "Register `EIMSK` writer"]
pub struct W (crate :: W < EIMSK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EIMSK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EIMSK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EIMSK_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT` reader - External Interrupt Request 1 Enable"]
pub type INT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INT` writer - External Interrupt Request 1 Enable"]
pub type INT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EIMSK_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bits 0:1 - External Interrupt Request 1 Enable"]
# [inline (always)]
pub fn int (& self) -> INT_R { INT_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - External Interrupt Request 1 Enable"]
# [inline (always)]
# [must_use]
pub fn int (& mut self) -> INT_W < 0 > { INT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eimsk](index.html) module"]
pub struct EIMSK_SPEC ; impl crate :: RegisterSpec for EIMSK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eimsk::R](R) reader structure"]
impl crate :: Readable for EIMSK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eimsk::W](W) writer structure"]
impl crate :: Writable for EIMSK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EIMSK to value 0"]
impl crate :: Resettable for EIMSK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCICR (rw) register accessor: an alias for `Reg<PCICR_SPEC>`"]
pub type PCICR = crate :: Reg < pcicr :: PCICR_SPEC > ; # [doc = "Pin Change Interrupt Control Register"]
pub mod pcicr { # [doc = "Register `PCICR` reader"]
pub struct R (crate :: R < PCICR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCICR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCICR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCICR_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCICR` writer"]
pub struct W (crate :: W < PCICR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCICR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCICR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCICR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCIE` reader - Pin Change Interrupt Enables"]
pub type PCIE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCIE` writer - Pin Change Interrupt Enables"]
pub type PCIE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCICR_SPEC , u8 , u8 , 3 , O > ; impl R { # [doc = "Bits 0:2 - Pin Change Interrupt Enables"]
# [inline (always)]
pub fn pcie (& self) -> PCIE_R { PCIE_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Pin Change Interrupt Enables"]
# [inline (always)]
# [must_use]
pub fn pcie (& mut self) -> PCIE_W < 0 > { PCIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin Change Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcicr](index.html) module"]
pub struct PCICR_SPEC ; impl crate :: RegisterSpec for PCICR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcicr::R](R) reader structure"]
impl crate :: Readable for PCICR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcicr::W](W) writer structure"]
impl crate :: Writable for PCICR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCICR to value 0"]
impl crate :: Resettable for PCICR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCIFR (rw) register accessor: an alias for `Reg<PCIFR_SPEC>`"]
pub type PCIFR = crate :: Reg < pcifr :: PCIFR_SPEC > ; # [doc = "Pin Change Interrupt Flag Register"]
pub mod pcifr { # [doc = "Register `PCIFR` reader"]
pub struct R (crate :: R < PCIFR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCIFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCIFR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCIFR_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCIFR` writer"]
pub struct W (crate :: W < PCIFR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCIFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCIFR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCIFR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCIF` reader - Pin Change Interrupt Flags"]
pub type PCIF_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCIF` writer - Pin Change Interrupt Flags"]
pub type PCIF_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCIFR_SPEC , u8 , u8 , 3 , O > ; impl R { # [doc = "Bits 0:2 - Pin Change Interrupt Flags"]
# [inline (always)]
pub fn pcif (& self) -> PCIF_R { PCIF_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Pin Change Interrupt Flags"]
# [inline (always)]
# [must_use]
pub fn pcif (& mut self) -> PCIF_W < 0 > { PCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin Change Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcifr](index.html) module"]
pub struct PCIFR_SPEC ; impl crate :: RegisterSpec for PCIFR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcifr::R](R) reader structure"]
impl crate :: Readable for PCIFR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcifr::W](W) writer structure"]
impl crate :: Writable for PCIFR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCIFR to value 0"]
impl crate :: Resettable for PCIFR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCMSK0 (rw) register accessor: an alias for `Reg<PCMSK0_SPEC>`"]
pub type PCMSK0 = crate :: Reg < pcmsk0 :: PCMSK0_SPEC > ; # [doc = "Pin Change Mask Register 0"]
pub mod pcmsk0 { # [doc = "Register `PCMSK0` reader"]
pub struct R (crate :: R < PCMSK0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCMSK0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCMSK0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCMSK0_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCMSK0` writer"]
pub struct W (crate :: W < PCMSK0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCMSK0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCMSK0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCMSK0_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCINT` reader - Pin Change Enable Masks"]
pub type PCINT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCINT` writer - Pin Change Enable Masks"]
pub type PCINT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCMSK0_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Change Enable Masks"]
# [inline (always)]
pub fn pcint (& self) -> PCINT_R { PCINT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Change Enable Masks"]
# [inline (always)]
# [must_use]
pub fn pcint (& mut self) -> PCINT_W < 0 > { PCINT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Pin Change Mask Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcmsk0](index.html) module"]
pub struct PCMSK0_SPEC ; impl crate :: RegisterSpec for PCMSK0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcmsk0::R](R) reader structure"]
impl crate :: Readable for PCMSK0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcmsk0::W](W) writer structure"]
impl crate :: Writable for PCMSK0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCMSK0 to value 0"]
impl crate :: Resettable for PCMSK0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCMSK1 (rw) register accessor: an alias for `Reg<PCMSK1_SPEC>`"]
pub type PCMSK1 = crate :: Reg < pcmsk1 :: PCMSK1_SPEC > ; # [doc = "Pin Change Mask Register 1"]
pub mod pcmsk1 { # [doc = "Register `PCMSK1` reader"]
pub struct R (crate :: R < PCMSK1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCMSK1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCMSK1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCMSK1_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCMSK1` writer"]
pub struct W (crate :: W < PCMSK1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCMSK1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCMSK1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCMSK1_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCINT` reader - Pin Change Enable Masks"]
pub type PCINT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCINT` writer - Pin Change Enable Masks"]
pub type PCINT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCMSK1_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Pin Change Enable Masks"]
# [inline (always)]
pub fn pcint (& self) -> PCINT_R { PCINT_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Pin Change Enable Masks"]
# [inline (always)]
# [must_use]
pub fn pcint (& mut self) -> PCINT_W < 0 > { PCINT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin Change Mask Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcmsk1](index.html) module"]
pub struct PCMSK1_SPEC ; impl crate :: RegisterSpec for PCMSK1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcmsk1::R](R) reader structure"]
impl crate :: Readable for PCMSK1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcmsk1::W](W) writer structure"]
impl crate :: Writable for PCMSK1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCMSK1 to value 0"]
impl crate :: Resettable for PCMSK1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PCMSK2 (rw) register accessor: an alias for `Reg<PCMSK2_SPEC>`"]
pub type PCMSK2 = crate :: Reg < pcmsk2 :: PCMSK2_SPEC > ; # [doc = "Pin Change Mask Register 2"]
pub mod pcmsk2 { # [doc = "Register `PCMSK2` reader"]
pub struct R (crate :: R < PCMSK2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCMSK2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCMSK2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCMSK2_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCMSK2` writer"]
pub struct W (crate :: W < PCMSK2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCMSK2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCMSK2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCMSK2_SPEC >) -> Self { W (writer) } } # [doc = "Field `PCINT` reader - Pin Change Enable Masks"]
pub type PCINT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PCINT` writer - Pin Change Enable Masks"]
pub type PCINT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PCMSK2_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Pin Change Enable Masks"]
# [inline (always)]
pub fn pcint (& self) -> PCINT_R { PCINT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Pin Change Enable Masks"]
# [inline (always)]
# [must_use]
pub fn pcint (& mut self) -> PCINT_W < 0 > { PCINT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Pin Change Mask Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcmsk2](index.html) module"]
pub struct PCMSK2_SPEC ; impl crate :: RegisterSpec for PCMSK2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcmsk2::R](R) reader structure"]
impl crate :: Readable for PCMSK2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcmsk2::W](W) writer structure"]
impl crate :: Writable for PCMSK2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PCMSK2 to value 0"]
impl crate :: Resettable for PCMSK2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Fuses"]
pub struct FUSE { _marker : PhantomData < * const () > } unsafe impl Send for FUSE { } impl FUSE { # [doc = r"Pointer to the register block"]
pub const PTR : * const fuse :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const fuse :: RegisterBlock { Self :: PTR } } impl Deref for FUSE { type Target = fuse :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FUSE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FUSE") . finish () } } # [doc = "Fuses"]
pub mod fuse { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - No Description."]
pub low : LOW , # [doc = "0x01 - No Description."]
pub high : HIGH , # [doc = "0x02 - No Description."]
pub extended : EXTENDED , } # [doc = "EXTENDED (rw) register accessor: an alias for `Reg<EXTENDED_SPEC>`"]
pub type EXTENDED = crate :: Reg < extended :: EXTENDED_SPEC > ; # [doc = "No Description."]
pub mod extended { # [doc = "Register `EXTENDED` reader"]
pub struct R (crate :: R < EXTENDED_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EXTENDED_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EXTENDED_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EXTENDED_SPEC >) -> Self { R (reader) } } # [doc = "Register `EXTENDED` writer"]
pub struct W (crate :: W < EXTENDED_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EXTENDED_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EXTENDED_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EXTENDED_SPEC >) -> Self { W (writer) } } # [doc = "Field `BODLEVEL` reader - Brown-out Detector trigger level"]
pub type BODLEVEL_R = crate :: FieldReader < u8 , BODLEVEL_A > ; # [doc = "Brown-out Detector trigger level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BODLEVEL_A { # [doc = "4: Brown-out detection at VCC=4.3 V"]
_4V3 = 4 , # [doc = "5: Brown-out detection at VCC=2.7 V"]
_2V7 = 5 , # [doc = "6: Brown-out detection at VCC=1.8 V"]
_1V8 = 6 , # [doc = "7: Brown-out detection disabled"]
DISABLED = 7 , } impl From < BODLEVEL_A > for u8 { # [inline (always)]
fn from (variant : BODLEVEL_A) -> Self { variant as _ } } impl BODLEVEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < BODLEVEL_A > { match self . bits { 4 => Some (BODLEVEL_A :: _4V3) , 5 => Some (BODLEVEL_A :: _2V7) , 6 => Some (BODLEVEL_A :: _1V8) , 7 => Some (BODLEVEL_A :: DISABLED) , _ => None , } } # [doc = "Checks if the value of the field is `_4V3`"]
# [inline (always)]
pub fn is_4v3 (& self) -> bool { * self == BODLEVEL_A :: _4V3 } # [doc = "Checks if the value of the field is `_2V7`"]
# [inline (always)]
pub fn is_2v7 (& self) -> bool { * self == BODLEVEL_A :: _2V7 } # [doc = "Checks if the value of the field is `_1V8`"]
# [inline (always)]
pub fn is_1v8 (& self) -> bool { * self == BODLEVEL_A :: _1V8 } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == BODLEVEL_A :: DISABLED } } # [doc = "Field `BODLEVEL` writer - Brown-out Detector trigger level"]
pub type BODLEVEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , EXTENDED_SPEC , u8 , BODLEVEL_A , 3 , O > ; impl < 'a , const O : u8 > BODLEVEL_W < 'a , O > { # [doc = "Brown-out detection at VCC=4.3 V"]
# [inline (always)]
pub fn _4v3 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _4V3) } # [doc = "Brown-out detection at VCC=2.7 V"]
# [inline (always)]
pub fn _2v7 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V7) } # [doc = "Brown-out detection at VCC=1.8 V"]
# [inline (always)]
pub fn _1v8 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _1V8) } # [doc = "Brown-out detection disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (BODLEVEL_A :: DISABLED) } } impl R { # [doc = "Bits 0:2 - Brown-out Detector trigger level"]
# [inline (always)]
pub fn bodlevel (& self) -> BODLEVEL_R { BODLEVEL_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Brown-out Detector trigger level"]
# [inline (always)]
# [must_use]
pub fn bodlevel (& mut self) -> BODLEVEL_W < 0 > { BODLEVEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "No Description.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [extended](index.html) module"]
pub struct EXTENDED_SPEC ; impl crate :: RegisterSpec for EXTENDED_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [extended::R](R) reader structure"]
impl crate :: Readable for EXTENDED_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [extended::W](W) writer structure"]
impl crate :: Writable for EXTENDED_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EXTENDED to value 0"]
impl crate :: Resettable for EXTENDED_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "HIGH (rw) register accessor: an alias for `Reg<HIGH_SPEC>`"]
pub type HIGH = crate :: Reg < high :: HIGH_SPEC > ; # [doc = "No Description."]
pub mod high { # [doc = "Register `HIGH` reader"]
pub struct R (crate :: R < HIGH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < HIGH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < HIGH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < HIGH_SPEC >) -> Self { R (reader) } } # [doc = "Register `HIGH` writer"]
pub struct W (crate :: W < HIGH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < HIGH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < HIGH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < HIGH_SPEC >) -> Self { W (writer) } } # [doc = "Field `BOOTRST` reader - Boot Reset vector Enabled"]
pub type BOOTRST_R = crate :: BitReader < bool > ; # [doc = "Field `BOOTRST` writer - Boot Reset vector Enabled"]
pub type BOOTRST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `BOOTSZ` reader - Select boot size"]
pub type BOOTSZ_R = crate :: FieldReader < u8 , BOOTSZ_A > ; # [doc = "Select boot size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BOOTSZ_A { # [doc = "0: Boot Flash size=2048 words start address=$3800"]
_2048W_3800 = 0 , # [doc = "1: Boot Flash size=1024 words start address=$3C00"]
_1024W_3C00 = 1 , # [doc = "2: Boot Flash size=512 words start address=$3E00"]
_512W_3E00 = 2 , # [doc = "3: Boot Flash size=256 words start address=$3F00"]
_256W_3F00 = 3 , } impl From < BOOTSZ_A > for u8 { # [inline (always)]
fn from (variant : BOOTSZ_A) -> Self { variant as _ } } impl BOOTSZ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BOOTSZ_A { match self . bits { 0 => BOOTSZ_A :: _2048W_3800 , 1 => BOOTSZ_A :: _1024W_3C00 , 2 => BOOTSZ_A :: _512W_3E00 , 3 => BOOTSZ_A :: _256W_3F00 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_2048W_3800`"]
# [inline (always)]
pub fn is_2048w_3800 (& self) -> bool { * self == BOOTSZ_A :: _2048W_3800 } # [doc = "Checks if the value of the field is `_1024W_3C00`"]
# [inline (always)]
pub fn is_1024w_3c00 (& self) -> bool { * self == BOOTSZ_A :: _1024W_3C00 } # [doc = "Checks if the value of the field is `_512W_3E00`"]
# [inline (always)]
pub fn is_512w_3e00 (& self) -> bool { * self == BOOTSZ_A :: _512W_3E00 } # [doc = "Checks if the value of the field is `_256W_3F00`"]
# [inline (always)]
pub fn is_256w_3f00 (& self) -> bool { * self == BOOTSZ_A :: _256W_3F00 } } # [doc = "Field `BOOTSZ` writer - Select boot size"]
pub type BOOTSZ_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , HIGH_SPEC , u8 , BOOTSZ_A , 2 , O > ; impl < 'a , const O : u8 > BOOTSZ_W < 'a , O > { # [doc = "Boot Flash size=2048 words start address=$3800"]
# [inline (always)]
pub fn _2048w_3800 (self) -> & 'a mut W { self . variant (BOOTSZ_A :: _2048W_3800) } # [doc = "Boot Flash size=1024 words start address=$3C00"]
# [inline (always)]
pub fn _1024w_3c00 (self) -> & 'a mut W { self . variant (BOOTSZ_A :: _1024W_3C00) } # [doc = "Boot Flash size=512 words start address=$3E00"]
# [inline (always)]
pub fn _512w_3e00 (self) -> & 'a mut W { self . variant (BOOTSZ_A :: _512W_3E00) } # [doc = "Boot Flash size=256 words start address=$3F00"]
# [inline (always)]
pub fn _256w_3f00 (self) -> & 'a mut W { self . variant (BOOTSZ_A :: _256W_3F00) } } # [doc = "Field `EESAVE` reader - Preserve EEPROM through the Chip Erase cycle"]
pub type EESAVE_R = crate :: BitReader < bool > ; # [doc = "Field `EESAVE` writer - Preserve EEPROM through the Chip Erase cycle"]
pub type EESAVE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `WDTON` reader - Watch-dog Timer always on"]
pub type WDTON_R = crate :: BitReader < bool > ; # [doc = "Field `WDTON` writer - Watch-dog Timer always on"]
pub type WDTON_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `SPIEN` reader - Serial program downloading (SPI) enabled"]
pub type SPIEN_R = crate :: BitReader < bool > ; # [doc = "Field `SPIEN` writer - Serial program downloading (SPI) enabled"]
pub type SPIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `DWEN` reader - Debug Wire enable"]
pub type DWEN_R = crate :: BitReader < bool > ; # [doc = "Field `DWEN` writer - Debug Wire enable"]
pub type DWEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; # [doc = "Field `RSTDISBL` reader - Reset Disabled (Enable PC6 as i/o pin)"]
pub type RSTDISBL_R = crate :: BitReader < bool > ; # [doc = "Field `RSTDISBL` writer - Reset Disabled (Enable PC6 as i/o pin)"]
pub type RSTDISBL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , HIGH_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Boot Reset vector Enabled"]
# [inline (always)]
pub fn bootrst (& self) -> BOOTRST_R { BOOTRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Select boot size"]
# [inline (always)]
pub fn bootsz (& self) -> BOOTSZ_R { BOOTSZ_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Preserve EEPROM through the Chip Erase cycle"]
# [inline (always)]
pub fn eesave (& self) -> EESAVE_R { EESAVE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Watch-dog Timer always on"]
# [inline (always)]
pub fn wdton (& self) -> WDTON_R { WDTON_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Serial program downloading (SPI) enabled"]
# [inline (always)]
pub fn spien (& self) -> SPIEN_R { SPIEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Debug Wire enable"]
# [inline (always)]
pub fn dwen (& self) -> DWEN_R { DWEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Reset Disabled (Enable PC6 as i/o pin)"]
# [inline (always)]
pub fn rstdisbl (& self) -> RSTDISBL_R { RSTDISBL_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Boot Reset vector Enabled"]
# [inline (always)]
# [must_use]
pub fn bootrst (& mut self) -> BOOTRST_W < 0 > { BOOTRST_W :: new (self) } # [doc = "Bits 1:2 - Select boot size"]
# [inline (always)]
# [must_use]
pub fn bootsz (& mut self) -> BOOTSZ_W < 1 > { BOOTSZ_W :: new (self) } # [doc = "Bit 3 - Preserve EEPROM through the Chip Erase cycle"]
# [inline (always)]
# [must_use]
pub fn eesave (& mut self) -> EESAVE_W < 3 > { EESAVE_W :: new (self) } # [doc = "Bit 4 - Watch-dog Timer always on"]
# [inline (always)]
# [must_use]
pub fn wdton (& mut self) -> WDTON_W < 4 > { WDTON_W :: new (self) } # [doc = "Bit 5 - Serial program downloading (SPI) enabled"]
# [inline (always)]
# [must_use]
pub fn spien (& mut self) -> SPIEN_W < 5 > { SPIEN_W :: new (self) } # [doc = "Bit 6 - Debug Wire enable"]
# [inline (always)]
# [must_use]
pub fn dwen (& mut self) -> DWEN_W < 6 > { DWEN_W :: new (self) } # [doc = "Bit 7 - Reset Disabled (Enable PC6 as i/o pin)"]
# [inline (always)]
# [must_use]
pub fn rstdisbl (& mut self) -> RSTDISBL_W < 7 > { RSTDISBL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "No Description.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [high](index.html) module"]
pub struct HIGH_SPEC ; impl crate :: RegisterSpec for HIGH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [high::R](R) reader structure"]
impl crate :: Readable for HIGH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [high::W](W) writer structure"]
impl crate :: Writable for HIGH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets HIGH to value 0"]
impl crate :: Resettable for HIGH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOW (rw) register accessor: an alias for `Reg<LOW_SPEC>`"]
pub type LOW = crate :: Reg < low :: LOW_SPEC > ; # [doc = "No Description."]
pub mod low { # [doc = "Register `LOW` reader"]
pub struct R (crate :: R < LOW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOW_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOW` writer"]
pub struct W (crate :: W < LOW_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOW_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOW_SPEC >) -> Self { W (writer) } } # [doc = "Field `SUT_CKSEL` reader - Select Clock Source"]
pub type SUT_CKSEL_R = crate :: FieldReader < u8 , SUT_CKSEL_A > ; # [doc = "Select Clock Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SUT_CKSEL_A { # [doc = "0: Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms"]
EXTCLK_6CK_14CK_0MS = 0 , # [doc = "2: Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms"]
INTRCOSC_8MHZ_6CK_14CK_0MS = 2 , # [doc = "3: Int. RC Osc. 128kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms"]
INTRCOSC_128KHZ_6CK_14CK_0MS = 3 , # [doc = "4: Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1K CK/14 CK + 0 ms"]
EXTLOFXTAL_1KCK_14CK_0MS = 4 , # [doc = "5: Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 32K CK/14 CK + 0 ms"]
EXTLOFXTAL_32KCK_14CK_0MS = 5 , # [doc = "6: Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
EXTFSXTAL_258CK_14CK_4MS1 = 6 , # [doc = "7: Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
EXTFSXTAL_1KCK_14CK_65MS = 7 , # [doc = "8: Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_4MS1 = 8 , # [doc = "9: Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_65MS = 9 , # [doc = "10: Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
EXTXOSC_0MHZ9_3MHZ_258CK_14CK_4MS1 = 10 , # [doc = "11: Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_65MS = 11 , # [doc = "12: Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
EXTXOSC_3MHZ_8MHZ_258CK_14CK_4MS1 = 12 , # [doc = "13: Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
EXTXOSC_3MHZ_8MHZ_1KCK_14CK_65MS = 13 , # [doc = "14: Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
EXTXOSC_8MHZ_XX_258CK_14CK_4MS1 = 14 , # [doc = "15: Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
EXTXOSC_8MHZ_XX_1KCK_14CK_65MS = 15 , # [doc = "16: Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4.1 ms"]
EXTCLK_6CK_14CK_4MS1 = 16 , # [doc = "18: Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4.1 ms"]
INTRCOSC_8MHZ_6CK_14CK_4MS1 = 18 , # [doc = "19: Int. RC Osc. 128kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4.1 ms"]
INTRCOSC_128KHZ_6CK_14CK_4MS1 = 19 , # [doc = "20: Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1K CK/14 CK + 4.1 ms"]
EXTLOFXTAL_1KCK_14CK_4MS1 = 20 , # [doc = "21: Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 32K CK/14 CK + 4.1 ms"]
EXTLOFXTAL_32KCK_14CK_4MS1 = 21 , # [doc = "22: Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
EXTFSXTAL_258CK_14CK_65MS = 22 , # [doc = "23: Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
EXTFSXTAL_16KCK_14CK_0MS = 23 , # [doc = "24: Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_65MS = 24 , # [doc = "25: Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_0MS = 25 , # [doc = "26: Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
EXTXOSC_0MHZ9_3MHZ_258CK_14CK_65MS = 26 , # [doc = "27: Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_0MS = 27 , # [doc = "28: Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
EXTXOSC_3MHZ_8MHZ_258CK_14CK_65MS = 28 , # [doc = "29: Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
EXTXOSC_3MHZ_8MHZ_16KCK_14CK_0MS = 29 , # [doc = "30: Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
EXTXOSC_8MHZ_XX_258CK_14CK_65MS = 30 , # [doc = "31: Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
EXTXOSC_8MHZ_XX_16KCK_14CK_0MS = 31 , # [doc = "32: Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 65 ms"]
EXTCLK_6CK_14CK_65MS = 32 , # [doc = "34: Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 65 ms"]
INTRCOSC_8MHZ_6CK_14CK_65MS = 34 , # [doc = "35: Int. RC Osc. 128kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 65 ms"]
INTRCOSC_128KHZ_6CK_14CK_65MS = 35 , # [doc = "36: Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1K CK/14 CK + 65 ms"]
EXTLOFXTAL_1KCK_14CK_65MS = 36 , # [doc = "37: Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 32K CK/14 CK + 65 ms"]
EXTLOFXTAL_32KCK_14CK_65MS = 37 , # [doc = "38: Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
EXTFSXTAL_1KCK_14CK_0MS = 38 , # [doc = "39: Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
EXTFSXTAL_16KCK_14CK_4MS1 = 39 , # [doc = "40: Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_0MS = 40 , # [doc = "41: Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_4MS1 = 41 , # [doc = "42: Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_0MS = 42 , # [doc = "43: Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_4MS1 = 43 , # [doc = "44: Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
EXTXOSC_3MHZ_8MHZ_1KCK_14CK_0MS = 44 , # [doc = "45: Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
EXTXOSC_3MHZ_8MHZ_16KCK_14CK_4MS1 = 45 , # [doc = "46: Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
EXTXOSC_8MHZ_XX_1KCK_14CK_0MS = 46 , # [doc = "47: Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
EXTXOSC_8MHZ_XX_16KCK_14CK_4MS1 = 47 , # [doc = "54: Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
EXTFSXTAL_1KCK_14CK_4MS1 = 54 , # [doc = "55: Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
EXTFSXTAL_16KCK_14CK_65MS = 55 , # [doc = "56: Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_4MS1 = 56 , # [doc = "57: Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_65MS = 57 , # [doc = "58: Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_4MS1 = 58 , # [doc = "59: Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_65MS = 59 , # [doc = "60: Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
EXTXOSC_3MHZ_8MHZ_1KCK_14CK_4MS1 = 60 , # [doc = "61: Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
EXTXOSC_3MHZ_8MHZ_16KCK_14CK_65MS = 61 , # [doc = "62: Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
EXTXOSC_8MHZ_XX_1KCK_14CK_4MS1 = 62 , # [doc = "63: Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
EXTXOSC_8MHZ_XX_16KCK_14CK_65MS = 63 , } impl From < SUT_CKSEL_A > for u8 { # [inline (always)]
fn from (variant : SUT_CKSEL_A) -> Self { variant as _ } } impl SUT_CKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SUT_CKSEL_A > { match self . bits { 0 => Some (SUT_CKSEL_A :: EXTCLK_6CK_14CK_0MS) , 2 => Some (SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_0MS) , 3 => Some (SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_0MS) , 4 => Some (SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_0MS) , 5 => Some (SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_0MS) , 6 => Some (SUT_CKSEL_A :: EXTFSXTAL_258CK_14CK_4MS1) , 7 => Some (SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_65MS) , 8 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_4MS1) , 9 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_65MS) , 10 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_258CK_14CK_4MS1) , 11 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_65MS) , 12 => Some (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_258CK_14CK_4MS1) , 13 => Some (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_65MS) , 14 => Some (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_258CK_14CK_4MS1) , 15 => Some (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_65MS) , 16 => Some (SUT_CKSEL_A :: EXTCLK_6CK_14CK_4MS1) , 18 => Some (SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_4MS1) , 19 => Some (SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_4MS1) , 20 => Some (SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_4MS1) , 21 => Some (SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_4MS1) , 22 => Some (SUT_CKSEL_A :: EXTFSXTAL_258CK_14CK_65MS) , 23 => Some (SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_0MS) , 24 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_65MS) , 25 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_0MS) , 26 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_258CK_14CK_65MS) , 27 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_0MS) , 28 => Some (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_258CK_14CK_65MS) , 29 => Some (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_0MS) , 30 => Some (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_258CK_14CK_65MS) , 31 => Some (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_0MS) , 32 => Some (SUT_CKSEL_A :: EXTCLK_6CK_14CK_65MS) , 34 => Some (SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_65MS) , 35 => Some (SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_65MS) , 36 => Some (SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_65MS) , 37 => Some (SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_65MS) , 38 => Some (SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_0MS) , 39 => Some (SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_4MS1) , 40 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_0MS) , 41 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_4MS1) , 42 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_0MS) , 43 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_4MS1) , 44 => Some (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_0MS) , 45 => Some (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_4MS1) , 46 => Some (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_0MS) , 47 => Some (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_4MS1) , 54 => Some (SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_4MS1) , 55 => Some (SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_65MS) , 56 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_4MS1) , 57 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_65MS) , 58 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_4MS1) , 59 => Some (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_65MS) , 60 => Some (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_4MS1) , 61 => Some (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_65MS) , 62 => Some (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_4MS1) , 63 => Some (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_65MS) , _ => None , } } # [doc = "Checks if the value of the field is `EXTCLK_6CK_14CK_0MS`"]
# [inline (always)]
pub fn is_extclk_6ck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTCLK_6CK_14CK_0MS } # [doc = "Checks if the value of the field is `INTRCOSC_8MHZ_6CK_14CK_0MS`"]
# [inline (always)]
pub fn is_intrcosc_8mhz_6ck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_0MS } # [doc = "Checks if the value of the field is `INTRCOSC_128KHZ_6CK_14CK_0MS`"]
# [inline (always)]
pub fn is_intrcosc_128khz_6ck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTLOFXTAL_1KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extlofxtal_1kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTLOFXTAL_32KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extlofxtal_32kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTFSXTAL_258CK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extfsxtal_258ck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTFSXTAL_258CK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTFSXTAL_1KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extfsxtal_1kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_0mhz4_0mhz9_258ck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz4_0mhz9_1kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ9_3MHZ_258CK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_0mhz9_3mhz_258ck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_258CK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz9_3mhz_1kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_3MHZ_8MHZ_258CK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_3mhz_8mhz_258ck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_258CK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_3MHZ_8MHZ_1KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_3mhz_8mhz_1kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_8MHZ_XX_258CK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_8mhz_xx_258ck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_258CK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_8MHZ_XX_1KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_8mhz_xx_1kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTCLK_6CK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extclk_6ck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTCLK_6CK_14CK_4MS1 } # [doc = "Checks if the value of the field is `INTRCOSC_8MHZ_6CK_14CK_4MS1`"]
# [inline (always)]
pub fn is_intrcosc_8mhz_6ck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_4MS1 } # [doc = "Checks if the value of the field is `INTRCOSC_128KHZ_6CK_14CK_4MS1`"]
# [inline (always)]
pub fn is_intrcosc_128khz_6ck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTLOFXTAL_1KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extlofxtal_1kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTLOFXTAL_32KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extlofxtal_32kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTFSXTAL_258CK_14CK_65MS`"]
# [inline (always)]
pub fn is_extfsxtal_258ck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTFSXTAL_258CK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTFSXTAL_16KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extfsxtal_16kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz4_0mhz9_258ck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz4_0mhz9_16kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ9_3MHZ_258CK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz9_3mhz_258ck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_258CK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz9_3mhz_16kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTXOSC_3MHZ_8MHZ_258CK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_3mhz_8mhz_258ck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_258CK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_3MHZ_8MHZ_16KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extxosc_3mhz_8mhz_16kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTXOSC_8MHZ_XX_258CK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_8mhz_xx_258ck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_258CK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_8MHZ_XX_16KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extxosc_8mhz_xx_16kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTCLK_6CK_14CK_65MS`"]
# [inline (always)]
pub fn is_extclk_6ck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTCLK_6CK_14CK_65MS } # [doc = "Checks if the value of the field is `INTRCOSC_8MHZ_6CK_14CK_65MS`"]
# [inline (always)]
pub fn is_intrcosc_8mhz_6ck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_65MS } # [doc = "Checks if the value of the field is `INTRCOSC_128KHZ_6CK_14CK_65MS`"]
# [inline (always)]
pub fn is_intrcosc_128khz_6ck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTLOFXTAL_1KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extlofxtal_1kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTLOFXTAL_32KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extlofxtal_32kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTFSXTAL_1KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extfsxtal_1kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTFSXTAL_16KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extfsxtal_16kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz4_0mhz9_1kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_0mhz4_0mhz9_16kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz9_3mhz_1kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_0mhz9_3mhz_16kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_3MHZ_8MHZ_1KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extxosc_3mhz_8mhz_1kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTXOSC_3MHZ_8MHZ_16KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_3mhz_8mhz_16kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_8MHZ_XX_1KCK_14CK_0MS`"]
# [inline (always)]
pub fn is_extxosc_8mhz_xx_1kck_14ck_0ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_0MS } # [doc = "Checks if the value of the field is `EXTXOSC_8MHZ_XX_16KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_8mhz_xx_16kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTFSXTAL_1KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extfsxtal_1kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTFSXTAL_16KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extfsxtal_16kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_0mhz4_0mhz9_1kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz4_0mhz9_16kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_0mhz9_3mhz_1kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_0mhz9_3mhz_16kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_3MHZ_8MHZ_1KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_3mhz_8mhz_1kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_3MHZ_8MHZ_16KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_3mhz_8mhz_16kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_65MS } # [doc = "Checks if the value of the field is `EXTXOSC_8MHZ_XX_1KCK_14CK_4MS1`"]
# [inline (always)]
pub fn is_extxosc_8mhz_xx_1kck_14ck_4ms1 (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_4MS1 } # [doc = "Checks if the value of the field is `EXTXOSC_8MHZ_XX_16KCK_14CK_65MS`"]
# [inline (always)]
pub fn is_extxosc_8mhz_xx_16kck_14ck_65ms (& self) -> bool { * self == SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_65MS } } # [doc = "Field `SUT_CKSEL` writer - Select Clock Source"]
pub type SUT_CKSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LOW_SPEC , u8 , SUT_CKSEL_A , 6 , O > ; impl < 'a , const O : u8 > SUT_CKSEL_W < 'a , O > { # [doc = "Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms"]
# [inline (always)]
pub fn extclk_6ck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTCLK_6CK_14CK_0MS) } # [doc = "Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms"]
# [inline (always)]
pub fn intrcosc_8mhz_6ck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_0MS) } # [doc = "Int. RC Osc. 128kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 0 ms"]
# [inline (always)]
pub fn intrcosc_128khz_6ck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_0MS) } # [doc = "Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1K CK/14 CK + 0 ms"]
# [inline (always)]
pub fn extlofxtal_1kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_0MS) } # [doc = "Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 32K CK/14 CK + 0 ms"]
# [inline (always)]
pub fn extlofxtal_32kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_0MS) } # [doc = "Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extfsxtal_258ck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTFSXTAL_258CK_14CK_4MS1) } # [doc = "Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
# [inline (always)]
pub fn extfsxtal_1kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_0mhz4_0mhz9_258ck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_0mhz4_0mhz9_1kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_0mhz9_3mhz_258ck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_258CK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_0mhz9_3mhz_1kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_3mhz_8mhz_258ck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_258CK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_3mhz_8mhz_1kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_8mhz_xx_258ck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_258CK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_8mhz_xx_1kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_65MS) } # [doc = "Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extclk_6ck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTCLK_6CK_14CK_4MS1) } # [doc = "Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn intrcosc_8mhz_6ck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_4MS1) } # [doc = "Int. RC Osc. 128kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn intrcosc_128khz_6ck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_4MS1) } # [doc = "Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1K CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extlofxtal_1kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_4MS1) } # [doc = "Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 32K CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extlofxtal_32kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_4MS1) } # [doc = "Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extfsxtal_258ck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTFSXTAL_258CK_14CK_65MS) } # [doc = "Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
# [inline (always)]
pub fn extfsxtal_16kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_0MS) } # [doc = "Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_0mhz4_0mhz9_258ck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_258CK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
# [inline (always)]
pub fn extxosc_0mhz4_0mhz9_16kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_0MS) } # [doc = "Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_0mhz9_3mhz_258ck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_258CK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
# [inline (always)]
pub fn extxosc_0mhz9_3mhz_16kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_0MS) } # [doc = "Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_3mhz_8mhz_258ck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_258CK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
# [inline (always)]
pub fn extxosc_3mhz_8mhz_16kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_0MS) } # [doc = "Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 258 CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_8mhz_xx_258ck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_258CK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 0 ms"]
# [inline (always)]
pub fn extxosc_8mhz_xx_16kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_0MS) } # [doc = "Ext. Clock; Start-up time PWRDWN/RESET: 6 CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extclk_6ck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTCLK_6CK_14CK_65MS) } # [doc = "Int. RC Osc. 8 MHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 65 ms"]
# [inline (always)]
pub fn intrcosc_8mhz_6ck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: INTRCOSC_8MHZ_6CK_14CK_65MS) } # [doc = "Int. RC Osc. 128kHz; Start-up time PWRDWN/RESET: 6 CK/14 CK + 65 ms"]
# [inline (always)]
pub fn intrcosc_128khz_6ck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: INTRCOSC_128KHZ_6CK_14CK_65MS) } # [doc = "Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 1K CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extlofxtal_1kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTLOFXTAL_1KCK_14CK_65MS) } # [doc = "Ext. Low-Freq. Crystal; Start-up time PWRDWN/RESET: 32K CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extlofxtal_32kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTLOFXTAL_32KCK_14CK_65MS) } # [doc = "Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
# [inline (always)]
pub fn extfsxtal_1kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_0MS) } # [doc = "Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extfsxtal_16kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
# [inline (always)]
pub fn extxosc_0mhz4_0mhz9_1kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_0MS) } # [doc = "Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_0mhz4_0mhz9_16kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
# [inline (always)]
pub fn extxosc_0mhz9_3mhz_1kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_0MS) } # [doc = "Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_0mhz9_3mhz_16kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
# [inline (always)]
pub fn extxosc_3mhz_8mhz_1kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_0MS) } # [doc = "Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_3mhz_8mhz_16kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 0 ms"]
# [inline (always)]
pub fn extxosc_8mhz_xx_1kck_14ck_0ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_0MS) } # [doc = "Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_8mhz_xx_16kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_4MS1) } # [doc = "Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
# [inline (always)]
pub fn extfsxtal_1kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTFSXTAL_1KCK_14CK_4MS1) } # [doc = "Ext. Full-swing Crystal; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extfsxtal_16kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTFSXTAL_16KCK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_0mhz4_0mhz9_1kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_1KCK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 0.4-0.9 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_0mhz4_0mhz9_16kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ4_0MHZ9_16KCK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_0mhz9_3mhz_1kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_1KCK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 0.9-3.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_0mhz9_3mhz_16kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_0MHZ9_3MHZ_16KCK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_3mhz_8mhz_1kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_1KCK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 3.0-8.0 MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_3mhz_8mhz_16kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_3MHZ_8MHZ_16KCK_14CK_65MS) } # [doc = "Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 1K CK /14 CK + 4.1 ms"]
# [inline (always)]
pub fn extxosc_8mhz_xx_1kck_14ck_4ms1 (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_1KCK_14CK_4MS1) } # [doc = "Ext. Crystal Osc. 8.0- MHz; Start-up time PWRDWN/RESET: 16K CK/14 CK + 65 ms"]
# [inline (always)]
pub fn extxosc_8mhz_xx_16kck_14ck_65ms (self) -> & 'a mut W { self . variant (SUT_CKSEL_A :: EXTXOSC_8MHZ_XX_16KCK_14CK_65MS) } } # [doc = "Field `CKOUT` reader - Clock output on PORTB0"]
pub type CKOUT_R = crate :: BitReader < bool > ; # [doc = "Field `CKOUT` writer - Clock output on PORTB0"]
pub type CKOUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LOW_SPEC , bool , O > ; # [doc = "Field `CKDIV8` reader - Divide clock by 8 internally"]
pub type CKDIV8_R = crate :: BitReader < bool > ; # [doc = "Field `CKDIV8` writer - Divide clock by 8 internally"]
pub type CKDIV8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LOW_SPEC , bool , O > ; impl R { # [doc = "Bits 0:5 - Select Clock Source"]
# [inline (always)]
pub fn sut_cksel (& self) -> SUT_CKSEL_R { SUT_CKSEL_R :: new (self . bits & 0x3f) } # [doc = "Bit 6 - Clock output on PORTB0"]
# [inline (always)]
pub fn ckout (& self) -> CKOUT_R { CKOUT_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Divide clock by 8 internally"]
# [inline (always)]
pub fn ckdiv8 (& self) -> CKDIV8_R { CKDIV8_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - Select Clock Source"]
# [inline (always)]
# [must_use]
pub fn sut_cksel (& mut self) -> SUT_CKSEL_W < 0 > { SUT_CKSEL_W :: new (self) } # [doc = "Bit 6 - Clock output on PORTB0"]
# [inline (always)]
# [must_use]
pub fn ckout (& mut self) -> CKOUT_W < 6 > { CKOUT_W :: new (self) } # [doc = "Bit 7 - Divide clock by 8 internally"]
# [inline (always)]
# [must_use]
pub fn ckdiv8 (& mut self) -> CKDIV8_W < 7 > { CKDIV8_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "No Description.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [low](index.html) module"]
pub struct LOW_SPEC ; impl crate :: RegisterSpec for LOW_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [low::R](R) reader structure"]
impl crate :: Readable for LOW_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [low::W](W) writer structure"]
impl crate :: Writable for LOW_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOW to value 0"]
impl crate :: Resettable for LOW_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Lockbits"]
pub struct LOCKBIT { _marker : PhantomData < * const () > } unsafe impl Send for LOCKBIT { } impl LOCKBIT { # [doc = r"Pointer to the register block"]
pub const PTR : * const lockbit :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const lockbit :: RegisterBlock { Self :: PTR } } impl Deref for LOCKBIT { type Target = lockbit :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for LOCKBIT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("LOCKBIT") . finish () } } # [doc = "Lockbits"]
pub mod lockbit { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - No Description."]
pub lockbit : LOCKBIT , } # [doc = "LOCKBIT (rw) register accessor: an alias for `Reg<LOCKBIT_SPEC>`"]
pub type LOCKBIT = crate :: Reg < lockbit :: LOCKBIT_SPEC > ; # [doc = "No Description."]
pub mod lockbit { # [doc = "Register `LOCKBIT` reader"]
pub struct R (crate :: R < LOCKBIT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKBIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKBIT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKBIT_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCKBIT` writer"]
pub struct W (crate :: W < LOCKBIT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCKBIT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCKBIT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCKBIT_SPEC >) -> Self { W (writer) } } # [doc = "Field `LB` reader - Memory Lock"]
pub type LB_R = crate :: FieldReader < u8 , LB_A > ; # [doc = "Memory Lock\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LB_A { # [doc = "0: Further programming and verification disabled"]
PROG_VER_DISABLED = 0 , # [doc = "2: Further programming disabled"]
PROG_DISABLED = 2 , # [doc = "3: No memory lock features enabled"]
NO_LOCK = 3 , } impl From < LB_A > for u8 { # [inline (always)]
fn from (variant : LB_A) -> Self { variant as _ } } impl LB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LB_A > { match self . bits { 0 => Some (LB_A :: PROG_VER_DISABLED) , 2 => Some (LB_A :: PROG_DISABLED) , 3 => Some (LB_A :: NO_LOCK) , _ => None , } } # [doc = "Checks if the value of the field is `PROG_VER_DISABLED`"]
# [inline (always)]
pub fn is_prog_ver_disabled (& self) -> bool { * self == LB_A :: PROG_VER_DISABLED } # [doc = "Checks if the value of the field is `PROG_DISABLED`"]
# [inline (always)]
pub fn is_prog_disabled (& self) -> bool { * self == LB_A :: PROG_DISABLED } # [doc = "Checks if the value of the field is `NO_LOCK`"]
# [inline (always)]
pub fn is_no_lock (& self) -> bool { * self == LB_A :: NO_LOCK } } # [doc = "Field `LB` writer - Memory Lock"]
pub type LB_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LOCKBIT_SPEC , u8 , LB_A , 2 , O > ; impl < 'a , const O : u8 > LB_W < 'a , O > { # [doc = "Further programming and verification disabled"]
# [inline (always)]
pub fn prog_ver_disabled (self) -> & 'a mut W { self . variant (LB_A :: PROG_VER_DISABLED) } # [doc = "Further programming disabled"]
# [inline (always)]
pub fn prog_disabled (self) -> & 'a mut W { self . variant (LB_A :: PROG_DISABLED) } # [doc = "No memory lock features enabled"]
# [inline (always)]
pub fn no_lock (self) -> & 'a mut W { self . variant (LB_A :: NO_LOCK) } } # [doc = "Field `BLB0` reader - Boot Loader Protection Mode"]
pub type BLB0_R = crate :: FieldReader < u8 , BLB0_A > ; # [doc = "Boot Loader Protection Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLB0_A { # [doc = "0: LPM and SPM prohibited in Application Section"]
LPM_SPM_DISABLE = 0 , # [doc = "1: LPM prohibited in Application Section"]
LPM_DISABLE = 1 , # [doc = "2: SPM prohibited in Application Section"]
SPM_DISABLE = 2 , # [doc = "3: No lock on SPM and LPM in Application Section"]
NO_LOCK = 3 , } impl From < BLB0_A > for u8 { # [inline (always)]
fn from (variant : BLB0_A) -> Self { variant as _ } } impl BLB0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLB0_A { match self . bits { 0 => BLB0_A :: LPM_SPM_DISABLE , 1 => BLB0_A :: LPM_DISABLE , 2 => BLB0_A :: SPM_DISABLE , 3 => BLB0_A :: NO_LOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `LPM_SPM_DISABLE`"]
# [inline (always)]
pub fn is_lpm_spm_disable (& self) -> bool { * self == BLB0_A :: LPM_SPM_DISABLE } # [doc = "Checks if the value of the field is `LPM_DISABLE`"]
# [inline (always)]
pub fn is_lpm_disable (& self) -> bool { * self == BLB0_A :: LPM_DISABLE } # [doc = "Checks if the value of the field is `SPM_DISABLE`"]
# [inline (always)]
pub fn is_spm_disable (& self) -> bool { * self == BLB0_A :: SPM_DISABLE } # [doc = "Checks if the value of the field is `NO_LOCK`"]
# [inline (always)]
pub fn is_no_lock (& self) -> bool { * self == BLB0_A :: NO_LOCK } } # [doc = "Field `BLB0` writer - Boot Loader Protection Mode"]
pub type BLB0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBIT_SPEC , u8 , BLB0_A , 2 , O > ; impl < 'a , const O : u8 > BLB0_W < 'a , O > { # [doc = "LPM and SPM prohibited in Application Section"]
# [inline (always)]
pub fn lpm_spm_disable (self) -> & 'a mut W { self . variant (BLB0_A :: LPM_SPM_DISABLE) } # [doc = "LPM prohibited in Application Section"]
# [inline (always)]
pub fn lpm_disable (self) -> & 'a mut W { self . variant (BLB0_A :: LPM_DISABLE) } # [doc = "SPM prohibited in Application Section"]
# [inline (always)]
pub fn spm_disable (self) -> & 'a mut W { self . variant (BLB0_A :: SPM_DISABLE) } # [doc = "No lock on SPM and LPM in Application Section"]
# [inline (always)]
pub fn no_lock (self) -> & 'a mut W { self . variant (BLB0_A :: NO_LOCK) } } # [doc = "Field `BLB1` reader - Boot Loader Protection Mode"]
pub type BLB1_R = crate :: FieldReader < u8 , BLB1_A > ; # [doc = "Boot Loader Protection Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLB1_A { # [doc = "0: LPM and SPM prohibited in Boot Section"]
LPM_SPM_DISABLE = 0 , # [doc = "1: LPM prohibited in Boot Section"]
LPM_DISABLE = 1 , # [doc = "2: SPM prohibited in Boot Section"]
SPM_DISABLE = 2 , # [doc = "3: No lock on SPM and LPM in Boot Section"]
NO_LOCK = 3 , } impl From < BLB1_A > for u8 { # [inline (always)]
fn from (variant : BLB1_A) -> Self { variant as _ } } impl BLB1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLB1_A { match self . bits { 0 => BLB1_A :: LPM_SPM_DISABLE , 1 => BLB1_A :: LPM_DISABLE , 2 => BLB1_A :: SPM_DISABLE , 3 => BLB1_A :: NO_LOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `LPM_SPM_DISABLE`"]
# [inline (always)]
pub fn is_lpm_spm_disable (& self) -> bool { * self == BLB1_A :: LPM_SPM_DISABLE } # [doc = "Checks if the value of the field is `LPM_DISABLE`"]
# [inline (always)]
pub fn is_lpm_disable (& self) -> bool { * self == BLB1_A :: LPM_DISABLE } # [doc = "Checks if the value of the field is `SPM_DISABLE`"]
# [inline (always)]
pub fn is_spm_disable (& self) -> bool { * self == BLB1_A :: SPM_DISABLE } # [doc = "Checks if the value of the field is `NO_LOCK`"]
# [inline (always)]
pub fn is_no_lock (& self) -> bool { * self == BLB1_A :: NO_LOCK } } # [doc = "Field `BLB1` writer - Boot Loader Protection Mode"]
pub type BLB1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBIT_SPEC , u8 , BLB1_A , 2 , O > ; impl < 'a , const O : u8 > BLB1_W < 'a , O > { # [doc = "LPM and SPM prohibited in Boot Section"]
# [inline (always)]
pub fn lpm_spm_disable (self) -> & 'a mut W { self . variant (BLB1_A :: LPM_SPM_DISABLE) } # [doc = "LPM prohibited in Boot Section"]
# [inline (always)]
pub fn lpm_disable (self) -> & 'a mut W { self . variant (BLB1_A :: LPM_DISABLE) } # [doc = "SPM prohibited in Boot Section"]
# [inline (always)]
pub fn spm_disable (self) -> & 'a mut W { self . variant (BLB1_A :: SPM_DISABLE) } # [doc = "No lock on SPM and LPM in Boot Section"]
# [inline (always)]
pub fn no_lock (self) -> & 'a mut W { self . variant (BLB1_A :: NO_LOCK) } } impl R { # [doc = "Bits 0:1 - Memory Lock"]
# [inline (always)]
pub fn lb (& self) -> LB_R { LB_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Boot Loader Protection Mode"]
# [inline (always)]
pub fn blb0 (& self) -> BLB0_R { BLB0_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Boot Loader Protection Mode"]
# [inline (always)]
pub fn blb1 (& self) -> BLB1_R { BLB1_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Memory Lock"]
# [inline (always)]
# [must_use]
pub fn lb (& mut self) -> LB_W < 0 > { LB_W :: new (self) } # [doc = "Bits 2:3 - Boot Loader Protection Mode"]
# [inline (always)]
# [must_use]
pub fn blb0 (& mut self) -> BLB0_W < 2 > { BLB0_W :: new (self) } # [doc = "Bits 4:5 - Boot Loader Protection Mode"]
# [inline (always)]
# [must_use]
pub fn blb1 (& mut self) -> BLB1_W < 4 > { BLB1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "No Description.\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockbit](index.html) module"]
pub struct LOCKBIT_SPEC ; impl crate :: RegisterSpec for LOCKBIT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lockbit::R](R) reader structure"]
impl crate :: Readable for LOCKBIT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lockbit::W](W) writer structure"]
impl crate :: Writable for LOCKBIT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOCKBIT to value 0"]
impl crate :: Resettable for LOCKBIT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTB { _marker : PhantomData < * const () > } unsafe impl Send for PORTB { } impl PORTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const portb :: RegisterBlock = 0x23 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portb :: RegisterBlock { Self :: PTR } } impl Deref for PORTB { type Target = portb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTB") . finish () } } # [doc = "I/O Port"]
pub mod portb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port B Input Pins"]
pub pinb : PINB , # [doc = "0x01 - Port B Data Direction Register"]
pub ddrb : DDRB , # [doc = "0x02 - Port B Data Register"]
pub portb : PORTB , } # [doc = "DDRB (rw) register accessor: an alias for `Reg<DDRB_SPEC>`"]
pub type DDRB = crate :: Reg < ddrb :: DDRB_SPEC > ; # [doc = "Port B Data Direction Register"]
pub mod ddrb { # [doc = "Register `DDRB` reader"]
pub struct R (crate :: R < DDRB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRB_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRB` writer"]
pub struct W (crate :: W < DDRB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRB_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRB_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRB_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRB_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRB_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRB_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRB_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRB_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port B Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddrb](index.html) module"]
pub struct DDRB_SPEC ; impl crate :: RegisterSpec for DDRB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddrb::R](R) reader structure"]
impl crate :: Readable for DDRB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddrb::W](W) writer structure"]
impl crate :: Writable for DDRB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRB to value 0"]
impl crate :: Resettable for DDRB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PINB (rw) register accessor: an alias for `Reg<PINB_SPEC>`"]
pub type PINB = crate :: Reg < pinb :: PINB_SPEC > ; # [doc = "Port B Input Pins"]
pub mod pinb { # [doc = "Register `PINB` reader"]
pub struct R (crate :: R < PINB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINB_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINB` writer"]
pub struct W (crate :: W < PINB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINB_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINB_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINB_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINB_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINB_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINB_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINB_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINB_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port B Input Pins\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pinb](index.html) module"]
pub struct PINB_SPEC ; impl crate :: RegisterSpec for PINB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pinb::R](R) reader structure"]
impl crate :: Readable for PINB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pinb::W](W) writer structure"]
impl crate :: Writable for PINB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PINB to value 0"]
impl crate :: Resettable for PINB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTB (rw) register accessor: an alias for `Reg<PORTB_SPEC>`"]
pub type PORTB = crate :: Reg < portb :: PORTB_SPEC > ; # [doc = "Port B Data Register"]
pub mod portb { # [doc = "Register `PORTB` reader"]
pub struct R (crate :: R < PORTB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTB_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTB` writer"]
pub struct W (crate :: W < PORTB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTB_SPEC >) -> Self { W (writer) } } # [doc = "Field `PB0` reader - Pin B0"]
pub type PB0_R = crate :: BitReader < bool > ; # [doc = "Field `PB0` writer - Pin B0"]
pub type PB0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTB_SPEC , bool , O > ; # [doc = "Field `PB1` reader - Pin B1"]
pub type PB1_R = crate :: BitReader < bool > ; # [doc = "Field `PB1` writer - Pin B1"]
pub type PB1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTB_SPEC , bool , O > ; # [doc = "Field `PB2` reader - Pin B2"]
pub type PB2_R = crate :: BitReader < bool > ; # [doc = "Field `PB2` writer - Pin B2"]
pub type PB2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTB_SPEC , bool , O > ; # [doc = "Field `PB3` reader - Pin B3"]
pub type PB3_R = crate :: BitReader < bool > ; # [doc = "Field `PB3` writer - Pin B3"]
pub type PB3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTB_SPEC , bool , O > ; # [doc = "Field `PB4` reader - Pin B4"]
pub type PB4_R = crate :: BitReader < bool > ; # [doc = "Field `PB4` writer - Pin B4"]
pub type PB4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTB_SPEC , bool , O > ; # [doc = "Field `PB5` reader - Pin B5"]
pub type PB5_R = crate :: BitReader < bool > ; # [doc = "Field `PB5` writer - Pin B5"]
pub type PB5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTB_SPEC , bool , O > ; # [doc = "Field `PB6` reader - Pin B6"]
pub type PB6_R = crate :: BitReader < bool > ; # [doc = "Field `PB6` writer - Pin B6"]
pub type PB6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTB_SPEC , bool , O > ; # [doc = "Field `PB7` reader - Pin B7"]
pub type PB7_R = crate :: BitReader < bool > ; # [doc = "Field `PB7` writer - Pin B7"]
pub type PB7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
pub fn pb0 (& self) -> PB0_R { PB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
pub fn pb1 (& self) -> PB1_R { PB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
pub fn pb2 (& self) -> PB2_R { PB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
pub fn pb3 (& self) -> PB3_R { PB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
pub fn pb4 (& self) -> PB4_R { PB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
pub fn pb5 (& self) -> PB5_R { PB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
pub fn pb6 (& self) -> PB6_R { PB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
pub fn pb7 (& self) -> PB7_R { PB7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin B0"]
# [inline (always)]
# [must_use]
pub fn pb0 (& mut self) -> PB0_W < 0 > { PB0_W :: new (self) } # [doc = "Bit 1 - Pin B1"]
# [inline (always)]
# [must_use]
pub fn pb1 (& mut self) -> PB1_W < 1 > { PB1_W :: new (self) } # [doc = "Bit 2 - Pin B2"]
# [inline (always)]
# [must_use]
pub fn pb2 (& mut self) -> PB2_W < 2 > { PB2_W :: new (self) } # [doc = "Bit 3 - Pin B3"]
# [inline (always)]
# [must_use]
pub fn pb3 (& mut self) -> PB3_W < 3 > { PB3_W :: new (self) } # [doc = "Bit 4 - Pin B4"]
# [inline (always)]
# [must_use]
pub fn pb4 (& mut self) -> PB4_W < 4 > { PB4_W :: new (self) } # [doc = "Bit 5 - Pin B5"]
# [inline (always)]
# [must_use]
pub fn pb5 (& mut self) -> PB5_W < 5 > { PB5_W :: new (self) } # [doc = "Bit 6 - Pin B6"]
# [inline (always)]
# [must_use]
pub fn pb6 (& mut self) -> PB6_W < 6 > { PB6_W :: new (self) } # [doc = "Bit 7 - Pin B7"]
# [inline (always)]
# [must_use]
pub fn pb7 (& mut self) -> PB7_W < 7 > { PB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port B Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portb](index.html) module"]
pub struct PORTB_SPEC ; impl crate :: RegisterSpec for PORTB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portb::R](R) reader structure"]
impl crate :: Readable for PORTB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portb::W](W) writer structure"]
impl crate :: Writable for PORTB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTB to value 0"]
impl crate :: Resettable for PORTB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTC { _marker : PhantomData < * const () > } unsafe impl Send for PORTC { } impl PORTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const portc :: RegisterBlock = 0x26 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portc :: RegisterBlock { Self :: PTR } } impl Deref for PORTC { type Target = portc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTC") . finish () } } # [doc = "I/O Port"]
pub mod portc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port C Input Pins"]
pub pinc : PINC , # [doc = "0x01 - Port C Data Direction Register"]
pub ddrc : DDRC , # [doc = "0x02 - Port C Data Register"]
pub portc : PORTC , } # [doc = "DDRC (rw) register accessor: an alias for `Reg<DDRC_SPEC>`"]
pub type DDRC = crate :: Reg < ddrc :: DDRC_SPEC > ; # [doc = "Port C Data Direction Register"]
pub mod ddrc { # [doc = "Register `DDRC` reader"]
pub struct R (crate :: R < DDRC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRC_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRC` writer"]
pub struct W (crate :: W < DDRC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRC_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRC_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRC_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRC_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRC_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRC_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRC_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port C Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddrc](index.html) module"]
pub struct DDRC_SPEC ; impl crate :: RegisterSpec for DDRC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddrc::R](R) reader structure"]
impl crate :: Readable for DDRC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddrc::W](W) writer structure"]
impl crate :: Writable for DDRC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRC to value 0"]
impl crate :: Resettable for DDRC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PINC (rw) register accessor: an alias for `Reg<PINC_SPEC>`"]
pub type PINC = crate :: Reg < pinc :: PINC_SPEC > ; # [doc = "Port C Input Pins"]
pub mod pinc { # [doc = "Register `PINC` reader"]
pub struct R (crate :: R < PINC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINC_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINC` writer"]
pub struct W (crate :: W < PINC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINC_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINC_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINC_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINC_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINC_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINC_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINC_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PINC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port C Input Pins\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pinc](index.html) module"]
pub struct PINC_SPEC ; impl crate :: RegisterSpec for PINC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pinc::R](R) reader structure"]
impl crate :: Readable for PINC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pinc::W](W) writer structure"]
impl crate :: Writable for PINC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PINC to value 0"]
impl crate :: Resettable for PINC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTC (rw) register accessor: an alias for `Reg<PORTC_SPEC>`"]
pub type PORTC = crate :: Reg < portc :: PORTC_SPEC > ; # [doc = "Port C Data Register"]
pub mod portc { # [doc = "Register `PORTC` reader"]
pub struct R (crate :: R < PORTC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTC_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTC` writer"]
pub struct W (crate :: W < PORTC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTC_SPEC >) -> Self { W (writer) } } # [doc = "Field `PC0` reader - Pin C0"]
pub type PC0_R = crate :: BitReader < bool > ; # [doc = "Field `PC0` writer - Pin C0"]
pub type PC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTC_SPEC , bool , O > ; # [doc = "Field `PC1` reader - Pin C1"]
pub type PC1_R = crate :: BitReader < bool > ; # [doc = "Field `PC1` writer - Pin C1"]
pub type PC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTC_SPEC , bool , O > ; # [doc = "Field `PC2` reader - Pin C2"]
pub type PC2_R = crate :: BitReader < bool > ; # [doc = "Field `PC2` writer - Pin C2"]
pub type PC2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTC_SPEC , bool , O > ; # [doc = "Field `PC3` reader - Pin C3"]
pub type PC3_R = crate :: BitReader < bool > ; # [doc = "Field `PC3` writer - Pin C3"]
pub type PC3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTC_SPEC , bool , O > ; # [doc = "Field `PC4` reader - Pin C4"]
pub type PC4_R = crate :: BitReader < bool > ; # [doc = "Field `PC4` writer - Pin C4"]
pub type PC4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTC_SPEC , bool , O > ; # [doc = "Field `PC5` reader - Pin C5"]
pub type PC5_R = crate :: BitReader < bool > ; # [doc = "Field `PC5` writer - Pin C5"]
pub type PC5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTC_SPEC , bool , O > ; # [doc = "Field `PC6` reader - Pin C6"]
pub type PC6_R = crate :: BitReader < bool > ; # [doc = "Field `PC6` writer - Pin C6"]
pub type PC6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
pub fn pc0 (& self) -> PC0_R { PC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
pub fn pc1 (& self) -> PC1_R { PC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
pub fn pc2 (& self) -> PC2_R { PC2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
pub fn pc3 (& self) -> PC3_R { PC3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
pub fn pc4 (& self) -> PC4_R { PC4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
pub fn pc5 (& self) -> PC5_R { PC5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
pub fn pc6 (& self) -> PC6_R { PC6_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin C0"]
# [inline (always)]
# [must_use]
pub fn pc0 (& mut self) -> PC0_W < 0 > { PC0_W :: new (self) } # [doc = "Bit 1 - Pin C1"]
# [inline (always)]
# [must_use]
pub fn pc1 (& mut self) -> PC1_W < 1 > { PC1_W :: new (self) } # [doc = "Bit 2 - Pin C2"]
# [inline (always)]
# [must_use]
pub fn pc2 (& mut self) -> PC2_W < 2 > { PC2_W :: new (self) } # [doc = "Bit 3 - Pin C3"]
# [inline (always)]
# [must_use]
pub fn pc3 (& mut self) -> PC3_W < 3 > { PC3_W :: new (self) } # [doc = "Bit 4 - Pin C4"]
# [inline (always)]
# [must_use]
pub fn pc4 (& mut self) -> PC4_W < 4 > { PC4_W :: new (self) } # [doc = "Bit 5 - Pin C5"]
# [inline (always)]
# [must_use]
pub fn pc5 (& mut self) -> PC5_W < 5 > { PC5_W :: new (self) } # [doc = "Bit 6 - Pin C6"]
# [inline (always)]
# [must_use]
pub fn pc6 (& mut self) -> PC6_W < 6 > { PC6_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port C Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portc](index.html) module"]
pub struct PORTC_SPEC ; impl crate :: RegisterSpec for PORTC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portc::R](R) reader structure"]
impl crate :: Readable for PORTC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portc::W](W) writer structure"]
impl crate :: Writable for PORTC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTC to value 0"]
impl crate :: Resettable for PORTC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "I/O Port"]
pub struct PORTD { _marker : PhantomData < * const () > } unsafe impl Send for PORTD { } impl PORTD { # [doc = r"Pointer to the register block"]
pub const PTR : * const portd :: RegisterBlock = 0x29 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portd :: RegisterBlock { Self :: PTR } } impl Deref for PORTD { type Target = portd :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTD") . finish () } } # [doc = "I/O Port"]
pub mod portd { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Port D Input Pins"]
pub pind : PIND , # [doc = "0x01 - Port D Data Direction Register"]
pub ddrd : DDRD , # [doc = "0x02 - Port D Data Register"]
pub portd : PORTD , } # [doc = "DDRD (rw) register accessor: an alias for `Reg<DDRD_SPEC>`"]
pub type DDRD = crate :: Reg < ddrd :: DDRD_SPEC > ; # [doc = "Port D Data Direction Register"]
pub mod ddrd { # [doc = "Register `DDRD` reader"]
pub struct R (crate :: R < DDRD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DDRD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DDRD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DDRD_SPEC >) -> Self { R (reader) } } # [doc = "Register `DDRD` writer"]
pub struct W (crate :: W < DDRD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DDRD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DDRD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DDRD_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRD_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRD_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRD_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRD_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRD_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRD_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRD_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DDRD_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port D Data Direction Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ddrd](index.html) module"]
pub struct DDRD_SPEC ; impl crate :: RegisterSpec for DDRD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ddrd::R](R) reader structure"]
impl crate :: Readable for DDRD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ddrd::W](W) writer structure"]
impl crate :: Writable for DDRD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DDRD to value 0"]
impl crate :: Resettable for DDRD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIND (rw) register accessor: an alias for `Reg<PIND_SPEC>`"]
pub type PIND = crate :: Reg < pind :: PIND_SPEC > ; # [doc = "Port D Input Pins"]
pub mod pind { # [doc = "Register `PIND` reader"]
pub struct R (crate :: R < PIND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIND_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIND` writer"]
pub struct W (crate :: W < PIND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIND_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIND_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIND_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIND_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIND_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIND_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIND_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIND_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIND_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port D Input Pins\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pind](index.html) module"]
pub struct PIND_SPEC ; impl crate :: RegisterSpec for PIND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pind::R](R) reader structure"]
impl crate :: Readable for PIND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pind::W](W) writer structure"]
impl crate :: Writable for PIND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIND to value 0"]
impl crate :: Resettable for PIND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PORTD (rw) register accessor: an alias for `Reg<PORTD_SPEC>`"]
pub type PORTD = crate :: Reg < portd :: PORTD_SPEC > ; # [doc = "Port D Data Register"]
pub mod portd { # [doc = "Register `PORTD` reader"]
pub struct R (crate :: R < PORTD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PORTD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PORTD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PORTD_SPEC >) -> Self { R (reader) } } # [doc = "Register `PORTD` writer"]
pub struct W (crate :: W < PORTD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PORTD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PORTD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PORTD_SPEC >) -> Self { W (writer) } } # [doc = "Field `PD0` reader - Pin D0"]
pub type PD0_R = crate :: BitReader < bool > ; # [doc = "Field `PD0` writer - Pin D0"]
pub type PD0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTD_SPEC , bool , O > ; # [doc = "Field `PD1` reader - Pin D1"]
pub type PD1_R = crate :: BitReader < bool > ; # [doc = "Field `PD1` writer - Pin D1"]
pub type PD1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTD_SPEC , bool , O > ; # [doc = "Field `PD2` reader - Pin D2"]
pub type PD2_R = crate :: BitReader < bool > ; # [doc = "Field `PD2` writer - Pin D2"]
pub type PD2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTD_SPEC , bool , O > ; # [doc = "Field `PD3` reader - Pin D3"]
pub type PD3_R = crate :: BitReader < bool > ; # [doc = "Field `PD3` writer - Pin D3"]
pub type PD3_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTD_SPEC , bool , O > ; # [doc = "Field `PD4` reader - Pin D4"]
pub type PD4_R = crate :: BitReader < bool > ; # [doc = "Field `PD4` writer - Pin D4"]
pub type PD4_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTD_SPEC , bool , O > ; # [doc = "Field `PD5` reader - Pin D5"]
pub type PD5_R = crate :: BitReader < bool > ; # [doc = "Field `PD5` writer - Pin D5"]
pub type PD5_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTD_SPEC , bool , O > ; # [doc = "Field `PD6` reader - Pin D6"]
pub type PD6_R = crate :: BitReader < bool > ; # [doc = "Field `PD6` writer - Pin D6"]
pub type PD6_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTD_SPEC , bool , O > ; # [doc = "Field `PD7` reader - Pin D7"]
pub type PD7_R = crate :: BitReader < bool > ; # [doc = "Field `PD7` writer - Pin D7"]
pub type PD7_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PORTD_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
pub fn pd0 (& self) -> PD0_R { PD0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
pub fn pd1 (& self) -> PD1_R { PD1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
pub fn pd2 (& self) -> PD2_R { PD2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
pub fn pd3 (& self) -> PD3_R { PD3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
pub fn pd4 (& self) -> PD4_R { PD4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
pub fn pd5 (& self) -> PD5_R { PD5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
pub fn pd6 (& self) -> PD6_R { PD6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
pub fn pd7 (& self) -> PD7_R { PD7_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pin D0"]
# [inline (always)]
# [must_use]
pub fn pd0 (& mut self) -> PD0_W < 0 > { PD0_W :: new (self) } # [doc = "Bit 1 - Pin D1"]
# [inline (always)]
# [must_use]
pub fn pd1 (& mut self) -> PD1_W < 1 > { PD1_W :: new (self) } # [doc = "Bit 2 - Pin D2"]
# [inline (always)]
# [must_use]
pub fn pd2 (& mut self) -> PD2_W < 2 > { PD2_W :: new (self) } # [doc = "Bit 3 - Pin D3"]
# [inline (always)]
# [must_use]
pub fn pd3 (& mut self) -> PD3_W < 3 > { PD3_W :: new (self) } # [doc = "Bit 4 - Pin D4"]
# [inline (always)]
# [must_use]
pub fn pd4 (& mut self) -> PD4_W < 4 > { PD4_W :: new (self) } # [doc = "Bit 5 - Pin D5"]
# [inline (always)]
# [must_use]
pub fn pd5 (& mut self) -> PD5_W < 5 > { PD5_W :: new (self) } # [doc = "Bit 6 - Pin D6"]
# [inline (always)]
# [must_use]
pub fn pd6 (& mut self) -> PD6_W < 6 > { PD6_W :: new (self) } # [doc = "Bit 7 - Pin D7"]
# [inline (always)]
# [must_use]
pub fn pd7 (& mut self) -> PD7_W < 7 > { PD7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Port D Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [portd](index.html) module"]
pub struct PORTD_SPEC ; impl crate :: RegisterSpec for PORTD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [portd::R](R) reader structure"]
impl crate :: Readable for PORTD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [portd::W](W) writer structure"]
impl crate :: Writable for PORTD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PORTD to value 0"]
impl crate :: Resettable for PORTD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct SPI { _marker : PhantomData < * const () > } unsafe impl Send for SPI { } impl SPI { # [doc = r"Pointer to the register block"]
pub const PTR : * const spi :: RegisterBlock = 0x4c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spi :: RegisterBlock { Self :: PTR } } impl Deref for SPI { type Target = spi :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPI { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPI") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod spi { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - SPI Control Register"]
pub spcr : SPCR , # [doc = "0x01 - SPI Status Register"]
pub spsr : SPSR , # [doc = "0x02 - SPI Data Register"]
pub spdr : SPDR , } # [doc = "SPCR (rw) register accessor: an alias for `Reg<SPCR_SPEC>`"]
pub type SPCR = crate :: Reg < spcr :: SPCR_SPEC > ; # [doc = "SPI Control Register"]
pub mod spcr { # [doc = "Register `SPCR` reader"]
pub struct R (crate :: R < SPCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPCR` writer"]
pub struct W (crate :: W < SPCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPR` reader - SPI Clock Rate Selects"]
pub type SPR_R = crate :: FieldReader < u8 , SPR_A > ; # [doc = "SPI Clock Rate Selects\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SPR_A { # [doc = "0: fosc/4"]
VAL_0X00 = 0 , # [doc = "1: fosc/16"]
VAL_0X01 = 1 , # [doc = "2: fosc/64"]
VAL_0X02 = 2 , # [doc = "3: fosc/128"]
VAL_0X03 = 3 , } impl From < SPR_A > for u8 { # [inline (always)]
fn from (variant : SPR_A) -> Self { variant as _ } } impl SPR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SPR_A { match self . bits { 0 => SPR_A :: VAL_0X00 , 1 => SPR_A :: VAL_0X01 , 2 => SPR_A :: VAL_0X02 , 3 => SPR_A :: VAL_0X03 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == SPR_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == SPR_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == SPR_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == SPR_A :: VAL_0X03 } } # [doc = "Field `SPR` writer - SPI Clock Rate Selects"]
pub type SPR_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SPCR_SPEC , u8 , SPR_A , 2 , O > ; impl < 'a , const O : u8 > SPR_W < 'a , O > { # [doc = "fosc/4"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (SPR_A :: VAL_0X00) } # [doc = "fosc/16"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (SPR_A :: VAL_0X01) } # [doc = "fosc/64"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (SPR_A :: VAL_0X02) } # [doc = "fosc/128"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (SPR_A :: VAL_0X03) } } # [doc = "Field `CPHA` reader - Clock Phase"]
pub type CPHA_R = crate :: BitReader < bool > ; # [doc = "Field `CPHA` writer - Clock Phase"]
pub type CPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; # [doc = "Field `CPOL` reader - Clock polarity"]
pub type CPOL_R = crate :: BitReader < bool > ; # [doc = "Field `CPOL` writer - Clock polarity"]
pub type CPOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; # [doc = "Field `MSTR` reader - Master/Slave Select"]
pub type MSTR_R = crate :: BitReader < bool > ; # [doc = "Field `MSTR` writer - Master/Slave Select"]
pub type MSTR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; # [doc = "Field `DORD` reader - Data Order"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order"]
pub type DORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; # [doc = "Field `SPE` reader - SPI Enable"]
pub type SPE_R = crate :: BitReader < bool > ; # [doc = "Field `SPE` writer - SPI Enable"]
pub type SPE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; # [doc = "Field `SPIE` reader - SPI Interrupt Enable"]
pub type SPIE_R = crate :: BitReader < bool > ; # [doc = "Field `SPIE` writer - SPI Interrupt Enable"]
pub type SPIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPCR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - SPI Clock Rate Selects"]
# [inline (always)]
pub fn spr (& self) -> SPR_R { SPR_R :: new (self . bits & 3) } # [doc = "Bit 2 - Clock Phase"]
# [inline (always)]
pub fn cpha (& self) -> CPHA_R { CPHA_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Clock polarity"]
# [inline (always)]
pub fn cpol (& self) -> CPOL_R { CPOL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Master/Slave Select"]
# [inline (always)]
pub fn mstr (& self) -> MSTR_R { MSTR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Order"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - SPI Enable"]
# [inline (always)]
pub fn spe (& self) -> SPE_R { SPE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - SPI Interrupt Enable"]
# [inline (always)]
pub fn spie (& self) -> SPIE_R { SPIE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - SPI Clock Rate Selects"]
# [inline (always)]
# [must_use]
pub fn spr (& mut self) -> SPR_W < 0 > { SPR_W :: new (self) } # [doc = "Bit 2 - Clock Phase"]
# [inline (always)]
# [must_use]
pub fn cpha (& mut self) -> CPHA_W < 2 > { CPHA_W :: new (self) } # [doc = "Bit 3 - Clock polarity"]
# [inline (always)]
# [must_use]
pub fn cpol (& mut self) -> CPOL_W < 3 > { CPOL_W :: new (self) } # [doc = "Bit 4 - Master/Slave Select"]
# [inline (always)]
# [must_use]
pub fn mstr (& mut self) -> MSTR_W < 4 > { MSTR_W :: new (self) } # [doc = "Bit 5 - Data Order"]
# [inline (always)]
# [must_use]
pub fn dord (& mut self) -> DORD_W < 5 > { DORD_W :: new (self) } # [doc = "Bit 6 - SPI Enable"]
# [inline (always)]
# [must_use]
pub fn spe (& mut self) -> SPE_W < 6 > { SPE_W :: new (self) } # [doc = "Bit 7 - SPI Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn spie (& mut self) -> SPIE_W < 7 > { SPIE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spcr](index.html) module"]
pub struct SPCR_SPEC ; impl crate :: RegisterSpec for SPCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spcr::R](R) reader structure"]
impl crate :: Readable for SPCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spcr::W](W) writer structure"]
impl crate :: Writable for SPCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPCR to value 0"]
impl crate :: Resettable for SPCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPDR (rw) register accessor: an alias for `Reg<SPDR_SPEC>`"]
pub type SPDR = crate :: Reg < spdr :: SPDR_SPEC > ; # [doc = "SPI Data Register"]
pub mod spdr { # [doc = "Register `SPDR` reader"]
pub struct R (crate :: R < SPDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPDR` writer"]
pub struct W (crate :: W < SPDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "SPI Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spdr](index.html) module"]
pub struct SPDR_SPEC ; impl crate :: RegisterSpec for SPDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spdr::R](R) reader structure"]
impl crate :: Readable for SPDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spdr::W](W) writer structure"]
impl crate :: Writable for SPDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPDR to value 0"]
impl crate :: Resettable for SPDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPSR (rw) register accessor: an alias for `Reg<SPSR_SPEC>`"]
pub type SPSR = crate :: Reg < spsr :: SPSR_SPEC > ; # [doc = "SPI Status Register"]
pub mod spsr { # [doc = "Register `SPSR` reader"]
pub struct R (crate :: R < SPSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPSR` writer"]
pub struct W (crate :: W < SPSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPI2X` reader - Double SPI Speed Bit"]
pub type SPI2X_R = crate :: BitReader < bool > ; # [doc = "Field `SPI2X` writer - Double SPI Speed Bit"]
pub type SPI2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPSR_SPEC , bool , O > ; # [doc = "Field `WCOL` reader - Write Collision Flag"]
pub type WCOL_R = crate :: BitReader < bool > ; # [doc = "Field `WCOL` writer - Write Collision Flag"]
pub type WCOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPSR_SPEC , bool , O > ; # [doc = "Field `SPIF` reader - SPI Interrupt Flag"]
pub type SPIF_R = crate :: BitReader < bool > ; # [doc = "Field `SPIF` writer - SPI Interrupt Flag"]
pub type SPIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SPSR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Double SPI Speed Bit"]
# [inline (always)]
pub fn spi2x (& self) -> SPI2X_R { SPI2X_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Write Collision Flag"]
# [inline (always)]
pub fn wcol (& self) -> WCOL_R { WCOL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - SPI Interrupt Flag"]
# [inline (always)]
pub fn spif (& self) -> SPIF_R { SPIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Double SPI Speed Bit"]
# [inline (always)]
# [must_use]
pub fn spi2x (& mut self) -> SPI2X_W < 0 > { SPI2X_W :: new (self) } # [doc = "Bit 6 - Write Collision Flag"]
# [inline (always)]
# [must_use]
pub fn wcol (& mut self) -> WCOL_W < 6 > { WCOL_W :: new (self) } # [doc = "Bit 7 - SPI Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn spif (& mut self) -> SPIF_W < 7 > { SPIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spsr](index.html) module"]
pub struct SPSR_SPEC ; impl crate :: RegisterSpec for SPSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spsr::R](R) reader structure"]
impl crate :: Readable for SPSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spsr::W](W) writer structure"]
impl crate :: Writable for SPSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPSR to value 0"]
impl crate :: Resettable for SPSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 8-bit"]
pub struct TC0 { _marker : PhantomData < * const () > } unsafe impl Send for TC0 { } impl TC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc0 :: RegisterBlock = 0x35 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc0 :: RegisterBlock { Self :: PTR } } impl Deref for TC0 { type Target = tc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC0") . finish () } } # [doc = "Timer/Counter, 8-bit"]
pub mod tc0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter0 Interrupt Flag register"]
pub tifr0 : TIFR0 , _reserved1 : [u8 ; 0x0d]
, # [doc = "0x0e - General Timer/Counter Control Register"]
pub gtccr : GTCCR , # [doc = "0x0f - Timer/Counter Control Register A"]
pub tccr0a : TCCR0A , # [doc = "0x10 - Timer/Counter Control Register B"]
pub tccr0b : TCCR0B , # [doc = "0x11 - Timer/Counter0"]
pub tcnt0 : TCNT0 , # [doc = "0x12 - Timer/Counter0 Output Compare Register"]
pub ocr0a : OCR0A , # [doc = "0x13 - Timer/Counter0 Output Compare Register"]
pub ocr0b : OCR0B , _reserved7 : [u8 ; 0x25]
, # [doc = "0x39 - Timer/Counter0 Interrupt Mask Register"]
pub timsk0 : TIMSK0 , } # [doc = "GTCCR (rw) register accessor: an alias for `Reg<GTCCR_SPEC>`"]
pub type GTCCR = crate :: Reg < gtccr :: GTCCR_SPEC > ; # [doc = "General Timer/Counter Control Register"]
pub mod gtccr { # [doc = "Register `GTCCR` reader"]
pub struct R (crate :: R < GTCCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GTCCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GTCCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `GTCCR` writer"]
pub struct W (crate :: W < GTCCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GTCCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GTCCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PSRSYNC` reader - Prescaler Reset Timer/Counter1 and Timer/Counter0"]
pub type PSRSYNC_R = crate :: BitReader < bool > ; # [doc = "Field `PSRSYNC` writer - Prescaler Reset Timer/Counter1 and Timer/Counter0"]
pub type PSRSYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; # [doc = "Field `TSM` reader - Timer/Counter Synchronization Mode"]
pub type TSM_R = crate :: BitReader < bool > ; # [doc = "Field `TSM` writer - Timer/Counter Synchronization Mode"]
pub type TSM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Prescaler Reset Timer/Counter1 and Timer/Counter0"]
# [inline (always)]
pub fn psrsync (& self) -> PSRSYNC_R { PSRSYNC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
pub fn tsm (& self) -> TSM_R { TSM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Prescaler Reset Timer/Counter1 and Timer/Counter0"]
# [inline (always)]
# [must_use]
pub fn psrsync (& mut self) -> PSRSYNC_W < 0 > { PSRSYNC_W :: new (self) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
# [must_use]
pub fn tsm (& mut self) -> TSM_W < 7 > { TSM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Timer/Counter Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gtccr](index.html) module"]
pub struct GTCCR_SPEC ; impl crate :: RegisterSpec for GTCCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gtccr::R](R) reader structure"]
impl crate :: Readable for GTCCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gtccr::W](W) writer structure"]
impl crate :: Writable for GTCCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GTCCR to value 0"]
impl crate :: Resettable for GTCCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR0A (rw) register accessor: an alias for `Reg<OCR0A_SPEC>`"]
pub type OCR0A = crate :: Reg < ocr0a :: OCR0A_SPEC > ; # [doc = "Timer/Counter0 Output Compare Register"]
pub mod ocr0a { # [doc = "Register `OCR0A` reader"]
pub struct R (crate :: R < OCR0A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR0A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR0A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR0A` writer"]
pub struct W (crate :: W < OCR0A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR0A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR0A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter0 Output Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr0a](index.html) module"]
pub struct OCR0A_SPEC ; impl crate :: RegisterSpec for OCR0A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocr0a::R](R) reader structure"]
impl crate :: Readable for OCR0A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr0a::W](W) writer structure"]
impl crate :: Writable for OCR0A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR0A to value 0"]
impl crate :: Resettable for OCR0A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR0B (rw) register accessor: an alias for `Reg<OCR0B_SPEC>`"]
pub type OCR0B = crate :: Reg < ocr0b :: OCR0B_SPEC > ; # [doc = "Timer/Counter0 Output Compare Register"]
pub mod ocr0b { # [doc = "Register `OCR0B` reader"]
pub struct R (crate :: R < OCR0B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR0B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR0B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR0B` writer"]
pub struct W (crate :: W < OCR0B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR0B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR0B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter0 Output Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr0b](index.html) module"]
pub struct OCR0B_SPEC ; impl crate :: RegisterSpec for OCR0B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocr0b::R](R) reader structure"]
impl crate :: Readable for OCR0B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr0b::W](W) writer structure"]
impl crate :: Writable for OCR0B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR0B to value 0"]
impl crate :: Resettable for OCR0B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR0A (rw) register accessor: an alias for `Reg<TCCR0A_SPEC>`"]
pub type TCCR0A = crate :: Reg < tccr0a :: TCCR0A_SPEC > ; # [doc = "Timer/Counter Control Register A"]
pub mod tccr0a { # [doc = "Register `TCCR0A` reader"]
pub struct R (crate :: R < TCCR0A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR0A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR0A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR0A` writer"]
pub struct W (crate :: W < TCCR0A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR0A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR0A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM0` reader - Waveform Generation Mode"]
pub type WGM0_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `WGM0` writer - Waveform Generation Mode"]
pub type WGM0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0A_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `COM0B` reader - Compare Output Mode, Fast PWm"]
pub type COM0B_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `COM0B` writer - Compare Output Mode, Fast PWm"]
pub type COM0B_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0A_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `COM0A` reader - Compare Output Mode, Phase Correct PWM Mode"]
pub type COM0A_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `COM0A` writer - Compare Output Mode, Phase Correct PWM Mode"]
pub type COM0A_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0A_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm0 (& self) -> WGM0_R { WGM0_R :: new (self . bits & 3) } # [doc = "Bits 4:5 - Compare Output Mode, Fast PWm"]
# [inline (always)]
pub fn com0b (& self) -> COM0B_R { COM0B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Output Mode, Phase Correct PWM Mode"]
# [inline (always)]
pub fn com0a (& self) -> COM0A_R { COM0A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm0 (& mut self) -> WGM0_W < 0 > { WGM0_W :: new (self) } # [doc = "Bits 4:5 - Compare Output Mode, Fast PWm"]
# [inline (always)]
# [must_use]
pub fn com0b (& mut self) -> COM0B_W < 4 > { COM0B_W :: new (self) } # [doc = "Bits 6:7 - Compare Output Mode, Phase Correct PWM Mode"]
# [inline (always)]
# [must_use]
pub fn com0a (& mut self) -> COM0A_W < 6 > { COM0A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr0a](index.html) module"]
pub struct TCCR0A_SPEC ; impl crate :: RegisterSpec for TCCR0A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr0a::R](R) reader structure"]
impl crate :: Readable for TCCR0A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr0a::W](W) writer structure"]
impl crate :: Writable for TCCR0A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR0A to value 0"]
impl crate :: Resettable for TCCR0A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR0B (rw) register accessor: an alias for `Reg<TCCR0B_SPEC>`"]
pub type TCCR0B = crate :: Reg < tccr0b :: TCCR0B_SPEC > ; # [doc = "Timer/Counter Control Register B"]
pub mod tccr0b { # [doc = "Register `TCCR0B` reader"]
pub struct R (crate :: R < TCCR0B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR0B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR0B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR0B` writer"]
pub struct W (crate :: W < TCCR0B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR0B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR0B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS0` reader - Clock Select"]
pub type CS0_R = crate :: FieldReader < u8 , CS0_A > ; # [doc = "Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS0_A { # [doc = "0: No Clock Source (Stopped)"]
VAL_0X00 = 0 , # [doc = "1: Running, No Prescaling"]
VAL_0X01 = 1 , # [doc = "2: Running, CLK/8"]
VAL_0X02 = 2 , # [doc = "3: Running, CLK/64"]
VAL_0X03 = 3 , # [doc = "4: Running, CLK/256"]
VAL_0X04 = 4 , # [doc = "5: Running, CLK/1024"]
VAL_0X05 = 5 , # [doc = "6: Running, ExtClk Tx Falling Edge"]
VAL_0X06 = 6 , # [doc = "7: Running, ExtClk Tx Rising Edge"]
VAL_0X07 = 7 , } impl From < CS0_A > for u8 { # [inline (always)]
fn from (variant : CS0_A) -> Self { variant as _ } } impl CS0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CS0_A { match self . bits { 0 => CS0_A :: VAL_0X00 , 1 => CS0_A :: VAL_0X01 , 2 => CS0_A :: VAL_0X02 , 3 => CS0_A :: VAL_0X03 , 4 => CS0_A :: VAL_0X04 , 5 => CS0_A :: VAL_0X05 , 6 => CS0_A :: VAL_0X06 , 7 => CS0_A :: VAL_0X07 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == CS0_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == CS0_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == CS0_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == CS0_A :: VAL_0X03 } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == CS0_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == CS0_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `VAL_0X06`"]
# [inline (always)]
pub fn is_val_0x06 (& self) -> bool { * self == CS0_A :: VAL_0X06 } # [doc = "Checks if the value of the field is `VAL_0X07`"]
# [inline (always)]
pub fn is_val_0x07 (& self) -> bool { * self == CS0_A :: VAL_0X07 } } # [doc = "Field `CS0` writer - Clock Select"]
pub type CS0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR0B_SPEC , u8 , CS0_A , 3 , O > ; impl < 'a , const O : u8 > CS0_W < 'a , O > { # [doc = "No Clock Source (Stopped)"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (CS0_A :: VAL_0X00) } # [doc = "Running, No Prescaling"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (CS0_A :: VAL_0X01) } # [doc = "Running, CLK/8"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (CS0_A :: VAL_0X02) } # [doc = "Running, CLK/64"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (CS0_A :: VAL_0X03) } # [doc = "Running, CLK/256"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (CS0_A :: VAL_0X04) } # [doc = "Running, CLK/1024"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (CS0_A :: VAL_0X05) } # [doc = "Running, ExtClk Tx Falling Edge"]
# [inline (always)]
pub fn val_0x06 (self) -> & 'a mut W { self . variant (CS0_A :: VAL_0X06) } # [doc = "Running, ExtClk Tx Rising Edge"]
# [inline (always)]
pub fn val_0x07 (self) -> & 'a mut W { self . variant (CS0_A :: VAL_0X07) } } # [doc = "Field `WGM02` reader - No Description."]
pub type WGM02_R = crate :: BitReader < bool > ; # [doc = "Field `WGM02` writer - No Description."]
pub type WGM02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR0B_SPEC , bool , O > ; # [doc = "Field `FOC0B` reader - Force Output Compare B"]
pub type FOC0B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC0B` writer - Force Output Compare B"]
pub type FOC0B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR0B_SPEC , bool , O > ; # [doc = "Field `FOC0A` reader - Force Output Compare A"]
pub type FOC0A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC0A` writer - Force Output Compare A"]
pub type FOC0A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR0B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
pub fn cs0 (& self) -> CS0_R { CS0_R :: new (self . bits & 7) } # [doc = "Bit 3 - No Description."]
# [inline (always)]
pub fn wgm02 (& self) -> WGM02_R { WGM02_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 6 - Force Output Compare B"]
# [inline (always)]
pub fn foc0b (& self) -> FOC0B_R { FOC0B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Force Output Compare A"]
# [inline (always)]
pub fn foc0a (& self) -> FOC0A_R { FOC0A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Select"]
# [inline (always)]
# [must_use]
pub fn cs0 (& mut self) -> CS0_W < 0 > { CS0_W :: new (self) } # [doc = "Bit 3 - No Description."]
# [inline (always)]
# [must_use]
pub fn wgm02 (& mut self) -> WGM02_W < 3 > { WGM02_W :: new (self) } # [doc = "Bit 6 - Force Output Compare B"]
# [inline (always)]
# [must_use]
pub fn foc0b (& mut self) -> FOC0B_W < 6 > { FOC0B_W :: new (self) } # [doc = "Bit 7 - Force Output Compare A"]
# [inline (always)]
# [must_use]
pub fn foc0a (& mut self) -> FOC0A_W < 7 > { FOC0A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr0b](index.html) module"]
pub struct TCCR0B_SPEC ; impl crate :: RegisterSpec for TCCR0B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr0b::R](R) reader structure"]
impl crate :: Readable for TCCR0B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr0b::W](W) writer structure"]
impl crate :: Writable for TCCR0B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR0B to value 0"]
impl crate :: Resettable for TCCR0B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT0 (rw) register accessor: an alias for `Reg<TCNT0_SPEC>`"]
pub type TCNT0 = crate :: Reg < tcnt0 :: TCNT0_SPEC > ; # [doc = "Timer/Counter0"]
pub mod tcnt0 { # [doc = "Register `TCNT0` reader"]
pub struct R (crate :: R < TCNT0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT0` writer"]
pub struct W (crate :: W < TCNT0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt0](index.html) module"]
pub struct TCNT0_SPEC ; impl crate :: RegisterSpec for TCNT0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tcnt0::R](R) reader structure"]
impl crate :: Readable for TCNT0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt0::W](W) writer structure"]
impl crate :: Writable for TCNT0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT0 to value 0"]
impl crate :: Resettable for TCNT0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR0 (rw) register accessor: an alias for `Reg<TIFR0_SPEC>`"]
pub type TIFR0 = crate :: Reg < tifr0 :: TIFR0_SPEC > ; # [doc = "Timer/Counter0 Interrupt Flag register"]
pub mod tifr0 { # [doc = "Register `TIFR0` reader"]
pub struct R (crate :: R < TIFR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR0` writer"]
pub struct W (crate :: W < TIFR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR0_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV0` reader - Timer/Counter0 Overflow Flag"]
pub type TOV0_R = crate :: BitReader < bool > ; # [doc = "Field `TOV0` writer - Timer/Counter0 Overflow Flag"]
pub type TOV0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR0_SPEC , bool , O > ; # [doc = "Field `OCF0A` reader - Timer/Counter0 Output Compare Flag 0A"]
pub type OCF0A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF0A` writer - Timer/Counter0 Output Compare Flag 0A"]
pub type OCF0A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR0_SPEC , bool , O > ; # [doc = "Field `OCF0B` reader - Timer/Counter0 Output Compare Flag 0B"]
pub type OCF0B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF0B` writer - Timer/Counter0 Output Compare Flag 0B"]
pub type OCF0B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter0 Overflow Flag"]
# [inline (always)]
pub fn tov0 (& self) -> TOV0_R { TOV0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter0 Output Compare Flag 0A"]
# [inline (always)]
pub fn ocf0a (& self) -> OCF0A_R { OCF0A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter0 Output Compare Flag 0B"]
# [inline (always)]
pub fn ocf0b (& self) -> OCF0B_R { OCF0B_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter0 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov0 (& mut self) -> TOV0_W < 0 > { TOV0_W :: new (self) } # [doc = "Bit 1 - Timer/Counter0 Output Compare Flag 0A"]
# [inline (always)]
# [must_use]
pub fn ocf0a (& mut self) -> OCF0A_W < 1 > { OCF0A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter0 Output Compare Flag 0B"]
# [inline (always)]
# [must_use]
pub fn ocf0b (& mut self) -> OCF0B_W < 2 > { OCF0B_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter0 Interrupt Flag register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr0](index.html) module"]
pub struct TIFR0_SPEC ; impl crate :: RegisterSpec for TIFR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr0::R](R) reader structure"]
impl crate :: Readable for TIFR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr0::W](W) writer structure"]
impl crate :: Writable for TIFR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR0 to value 0"]
impl crate :: Resettable for TIFR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK0 (rw) register accessor: an alias for `Reg<TIMSK0_SPEC>`"]
pub type TIMSK0 = crate :: Reg < timsk0 :: TIMSK0_SPEC > ; # [doc = "Timer/Counter0 Interrupt Mask Register"]
pub mod timsk0 { # [doc = "Register `TIMSK0` reader"]
pub struct R (crate :: R < TIMSK0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK0` writer"]
pub struct W (crate :: W < TIMSK0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK0_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE0` reader - Timer/Counter0 Overflow Interrupt Enable"]
pub type TOIE0_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE0` writer - Timer/Counter0 Overflow Interrupt Enable"]
pub type TOIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK0_SPEC , bool , O > ; # [doc = "Field `OCIE0A` reader - Timer/Counter0 Output Compare Match A Interrupt Enable"]
pub type OCIE0A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE0A` writer - Timer/Counter0 Output Compare Match A Interrupt Enable"]
pub type OCIE0A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK0_SPEC , bool , O > ; # [doc = "Field `OCIE0B` reader - Timer/Counter0 Output Compare Match B Interrupt Enable"]
pub type OCIE0B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE0B` writer - Timer/Counter0 Output Compare Match B Interrupt Enable"]
pub type OCIE0B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK0_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter0 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie0 (& self) -> TOIE0_R { TOIE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter0 Output Compare Match A Interrupt Enable"]
# [inline (always)]
pub fn ocie0a (& self) -> OCIE0A_R { OCIE0A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter0 Output Compare Match B Interrupt Enable"]
# [inline (always)]
pub fn ocie0b (& self) -> OCIE0B_R { OCIE0B_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter0 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie0 (& mut self) -> TOIE0_W < 0 > { TOIE0_W :: new (self) } # [doc = "Bit 1 - Timer/Counter0 Output Compare Match A Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie0a (& mut self) -> OCIE0A_W < 1 > { OCIE0A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter0 Output Compare Match B Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie0b (& mut self) -> OCIE0B_W < 2 > { OCIE0B_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter0 Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk0](index.html) module"]
pub struct TIMSK0_SPEC ; impl crate :: RegisterSpec for TIMSK0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk0::R](R) reader structure"]
impl crate :: Readable for TIMSK0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk0::W](W) writer structure"]
impl crate :: Writable for TIMSK0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK0 to value 0"]
impl crate :: Resettable for TIMSK0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 16-bit"]
pub struct TC1 { _marker : PhantomData < * const () > } unsafe impl Send for TC1 { } impl TC1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc1 :: RegisterBlock = 0x36 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc1 :: RegisterBlock { Self :: PTR } } impl Deref for TC1 { type Target = tc1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC1") . finish () } } # [doc = "Timer/Counter, 16-bit"]
pub mod tc1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter Interrupt Flag register"]
pub tifr1 : TIFR1 , _reserved1 : [u8 ; 0x0c]
, # [doc = "0x0d - General Timer/Counter Control Register"]
pub gtccr : GTCCR , _reserved2 : [u8 ; 0x2b]
, # [doc = "0x39 - Timer/Counter Interrupt Mask Register"]
pub timsk1 : TIMSK1 , _reserved3 : [u8 ; 0x10]
, # [doc = "0x4a - Timer/Counter1 Control Register A"]
pub tccr1a : TCCR1A , # [doc = "0x4b - Timer/Counter1 Control Register B"]
pub tccr1b : TCCR1B , # [doc = "0x4c - Timer/Counter1 Control Register C"]
pub tccr1c : TCCR1C , _reserved6 : [u8 ; 0x01]
, # [doc = "0x4e - Timer/Counter1 Bytes"]
pub tcnt1 : TCNT1 , # [doc = "0x50 - Timer/Counter1 Input Capture Register Bytes"]
pub icr1 : ICR1 , # [doc = "0x52 - Timer/Counter1 Output Compare Register Bytes"]
pub ocr1a : OCR1A , # [doc = "0x54 - Timer/Counter1 Output Compare Register Bytes"]
pub ocr1b : OCR1B , } # [doc = "GTCCR (rw) register accessor: an alias for `Reg<GTCCR_SPEC>`"]
pub type GTCCR = crate :: Reg < gtccr :: GTCCR_SPEC > ; # [doc = "General Timer/Counter Control Register"]
pub mod gtccr { # [doc = "Register `GTCCR` reader"]
pub struct R (crate :: R < GTCCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GTCCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GTCCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `GTCCR` writer"]
pub struct W (crate :: W < GTCCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GTCCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GTCCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PSRSYNC` reader - Prescaler Reset Timer/Counter1 and Timer/Counter0"]
pub type PSRSYNC_R = crate :: BitReader < bool > ; # [doc = "Field `PSRSYNC` writer - Prescaler Reset Timer/Counter1 and Timer/Counter0"]
pub type PSRSYNC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; # [doc = "Field `TSM` reader - Timer/Counter Synchronization Mode"]
pub type TSM_R = crate :: BitReader < bool > ; # [doc = "Field `TSM` writer - Timer/Counter Synchronization Mode"]
pub type TSM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Prescaler Reset Timer/Counter1 and Timer/Counter0"]
# [inline (always)]
pub fn psrsync (& self) -> PSRSYNC_R { PSRSYNC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
pub fn tsm (& self) -> TSM_R { TSM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Prescaler Reset Timer/Counter1 and Timer/Counter0"]
# [inline (always)]
# [must_use]
pub fn psrsync (& mut self) -> PSRSYNC_W < 0 > { PSRSYNC_W :: new (self) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
# [must_use]
pub fn tsm (& mut self) -> TSM_W < 7 > { TSM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Timer/Counter Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gtccr](index.html) module"]
pub struct GTCCR_SPEC ; impl crate :: RegisterSpec for GTCCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gtccr::R](R) reader structure"]
impl crate :: Readable for GTCCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gtccr::W](W) writer structure"]
impl crate :: Writable for GTCCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GTCCR to value 0"]
impl crate :: Resettable for GTCCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ICR1 (rw) register accessor: an alias for `Reg<ICR1_SPEC>`"]
pub type ICR1 = crate :: Reg < icr1 :: ICR1_SPEC > ; # [doc = "Timer/Counter1 Input Capture Register Bytes"]
pub mod icr1 { # [doc = "Register `ICR1` reader"]
pub struct R (crate :: R < ICR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ICR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ICR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ICR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `ICR1` writer"]
pub struct W (crate :: W < ICR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ICR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ICR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ICR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Input Capture Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr1](index.html) module"]
pub struct ICR1_SPEC ; impl crate :: RegisterSpec for ICR1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [icr1::R](R) reader structure"]
impl crate :: Readable for ICR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [icr1::W](W) writer structure"]
impl crate :: Writable for ICR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ICR1 to value 0"]
impl crate :: Resettable for ICR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR1A (rw) register accessor: an alias for `Reg<OCR1A_SPEC>`"]
pub type OCR1A = crate :: Reg < ocr1a :: OCR1A_SPEC > ; # [doc = "Timer/Counter1 Output Compare Register Bytes"]
pub mod ocr1a { # [doc = "Register `OCR1A` reader"]
pub struct R (crate :: R < OCR1A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR1A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR1A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR1A` writer"]
pub struct W (crate :: W < OCR1A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR1A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR1A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Output Compare Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr1a](index.html) module"]
pub struct OCR1A_SPEC ; impl crate :: RegisterSpec for OCR1A_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr1a::R](R) reader structure"]
impl crate :: Readable for OCR1A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr1a::W](W) writer structure"]
impl crate :: Writable for OCR1A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR1A to value 0"]
impl crate :: Resettable for OCR1A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR1B (rw) register accessor: an alias for `Reg<OCR1B_SPEC>`"]
pub type OCR1B = crate :: Reg < ocr1b :: OCR1B_SPEC > ; # [doc = "Timer/Counter1 Output Compare Register Bytes"]
pub mod ocr1b { # [doc = "Register `OCR1B` reader"]
pub struct R (crate :: R < OCR1B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR1B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR1B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR1B` writer"]
pub struct W (crate :: W < OCR1B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR1B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR1B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Output Compare Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr1b](index.html) module"]
pub struct OCR1B_SPEC ; impl crate :: RegisterSpec for OCR1B_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ocr1b::R](R) reader structure"]
impl crate :: Readable for OCR1B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr1b::W](W) writer structure"]
impl crate :: Writable for OCR1B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR1B to value 0"]
impl crate :: Resettable for OCR1B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR1A (rw) register accessor: an alias for `Reg<TCCR1A_SPEC>`"]
pub type TCCR1A = crate :: Reg < tccr1a :: TCCR1A_SPEC > ; # [doc = "Timer/Counter1 Control Register A"]
pub mod tccr1a { # [doc = "Register `TCCR1A` reader"]
pub struct R (crate :: R < TCCR1A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR1A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR1A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR1A` writer"]
pub struct W (crate :: W < TCCR1A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR1A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR1A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR1A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM1` reader - Waveform Generation Mode"]
pub type WGM1_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `WGM1` writer - Waveform Generation Mode"]
pub type WGM1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1A_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `COM1B` reader - Compare Output Mode 1B, bits"]
pub type COM1B_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `COM1B` writer - Compare Output Mode 1B, bits"]
pub type COM1B_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1A_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `COM1A` reader - Compare Output Mode 1A, bits"]
pub type COM1A_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `COM1A` writer - Compare Output Mode 1A, bits"]
pub type COM1A_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1A_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm1 (& self) -> WGM1_R { WGM1_R :: new (self . bits & 3) } # [doc = "Bits 4:5 - Compare Output Mode 1B, bits"]
# [inline (always)]
pub fn com1b (& self) -> COM1B_R { COM1B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Output Mode 1A, bits"]
# [inline (always)]
pub fn com1a (& self) -> COM1A_R { COM1A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm1 (& mut self) -> WGM1_W < 0 > { WGM1_W :: new (self) } # [doc = "Bits 4:5 - Compare Output Mode 1B, bits"]
# [inline (always)]
# [must_use]
pub fn com1b (& mut self) -> COM1B_W < 4 > { COM1B_W :: new (self) } # [doc = "Bits 6:7 - Compare Output Mode 1A, bits"]
# [inline (always)]
# [must_use]
pub fn com1a (& mut self) -> COM1A_W < 6 > { COM1A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter1 Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr1a](index.html) module"]
pub struct TCCR1A_SPEC ; impl crate :: RegisterSpec for TCCR1A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr1a::R](R) reader structure"]
impl crate :: Readable for TCCR1A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr1a::W](W) writer structure"]
impl crate :: Writable for TCCR1A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR1A to value 0"]
impl crate :: Resettable for TCCR1A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR1B (rw) register accessor: an alias for `Reg<TCCR1B_SPEC>`"]
pub type TCCR1B = crate :: Reg < tccr1b :: TCCR1B_SPEC > ; # [doc = "Timer/Counter1 Control Register B"]
pub mod tccr1b { # [doc = "Register `TCCR1B` reader"]
pub struct R (crate :: R < TCCR1B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR1B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR1B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR1B` writer"]
pub struct W (crate :: W < TCCR1B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR1B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR1B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR1B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS1` reader - Prescaler source of Timer/Counter 1"]
pub type CS1_R = crate :: FieldReader < u8 , CS1_A > ; # [doc = "Prescaler source of Timer/Counter 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS1_A { # [doc = "0: No Clock Source (Stopped)"]
VAL_0X00 = 0 , # [doc = "1: Running, No Prescaling"]
VAL_0X01 = 1 , # [doc = "2: Running, CLK/8"]
VAL_0X02 = 2 , # [doc = "3: Running, CLK/64"]
VAL_0X03 = 3 , # [doc = "4: Running, CLK/256"]
VAL_0X04 = 4 , # [doc = "5: Running, CLK/1024"]
VAL_0X05 = 5 , # [doc = "6: Running, ExtClk Tx Falling Edge"]
VAL_0X06 = 6 , # [doc = "7: Running, ExtClk Tx Rising Edge"]
VAL_0X07 = 7 , } impl From < CS1_A > for u8 { # [inline (always)]
fn from (variant : CS1_A) -> Self { variant as _ } } impl CS1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CS1_A { match self . bits { 0 => CS1_A :: VAL_0X00 , 1 => CS1_A :: VAL_0X01 , 2 => CS1_A :: VAL_0X02 , 3 => CS1_A :: VAL_0X03 , 4 => CS1_A :: VAL_0X04 , 5 => CS1_A :: VAL_0X05 , 6 => CS1_A :: VAL_0X06 , 7 => CS1_A :: VAL_0X07 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == CS1_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == CS1_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == CS1_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == CS1_A :: VAL_0X03 } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == CS1_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == CS1_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `VAL_0X06`"]
# [inline (always)]
pub fn is_val_0x06 (& self) -> bool { * self == CS1_A :: VAL_0X06 } # [doc = "Checks if the value of the field is `VAL_0X07`"]
# [inline (always)]
pub fn is_val_0x07 (& self) -> bool { * self == CS1_A :: VAL_0X07 } } # [doc = "Field `CS1` writer - Prescaler source of Timer/Counter 1"]
pub type CS1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1B_SPEC , u8 , CS1_A , 3 , O > ; impl < 'a , const O : u8 > CS1_W < 'a , O > { # [doc = "No Clock Source (Stopped)"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (CS1_A :: VAL_0X00) } # [doc = "Running, No Prescaling"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (CS1_A :: VAL_0X01) } # [doc = "Running, CLK/8"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (CS1_A :: VAL_0X02) } # [doc = "Running, CLK/64"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (CS1_A :: VAL_0X03) } # [doc = "Running, CLK/256"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (CS1_A :: VAL_0X04) } # [doc = "Running, CLK/1024"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (CS1_A :: VAL_0X05) } # [doc = "Running, ExtClk Tx Falling Edge"]
# [inline (always)]
pub fn val_0x06 (self) -> & 'a mut W { self . variant (CS1_A :: VAL_0X06) } # [doc = "Running, ExtClk Tx Rising Edge"]
# [inline (always)]
pub fn val_0x07 (self) -> & 'a mut W { self . variant (CS1_A :: VAL_0X07) } } # [doc = "Field `WGM1` reader - Waveform Generation Mode"]
pub type WGM1_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `WGM1` writer - Waveform Generation Mode"]
pub type WGM1_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR1B_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `ICES1` reader - Input Capture 1 Edge Select"]
pub type ICES1_R = crate :: BitReader < bool > ; # [doc = "Field `ICES1` writer - Input Capture 1 Edge Select"]
pub type ICES1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1B_SPEC , bool , O > ; # [doc = "Field `ICNC1` reader - Input Capture 1 Noise Canceler"]
pub type ICNC1_R = crate :: BitReader < bool > ; # [doc = "Field `ICNC1` writer - Input Capture 1 Noise Canceler"]
pub type ICNC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Prescaler source of Timer/Counter 1"]
# [inline (always)]
pub fn cs1 (& self) -> CS1_R { CS1_R :: new (self . bits & 7) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm1 (& self) -> WGM1_R { WGM1_R :: new ((self . bits >> 3) & 3) } # [doc = "Bit 6 - Input Capture 1 Edge Select"]
# [inline (always)]
pub fn ices1 (& self) -> ICES1_R { ICES1_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Input Capture 1 Noise Canceler"]
# [inline (always)]
pub fn icnc1 (& self) -> ICNC1_R { ICNC1_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Prescaler source of Timer/Counter 1"]
# [inline (always)]
# [must_use]
pub fn cs1 (& mut self) -> CS1_W < 0 > { CS1_W :: new (self) } # [doc = "Bits 3:4 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm1 (& mut self) -> WGM1_W < 3 > { WGM1_W :: new (self) } # [doc = "Bit 6 - Input Capture 1 Edge Select"]
# [inline (always)]
# [must_use]
pub fn ices1 (& mut self) -> ICES1_W < 6 > { ICES1_W :: new (self) } # [doc = "Bit 7 - Input Capture 1 Noise Canceler"]
# [inline (always)]
# [must_use]
pub fn icnc1 (& mut self) -> ICNC1_W < 7 > { ICNC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter1 Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr1b](index.html) module"]
pub struct TCCR1B_SPEC ; impl crate :: RegisterSpec for TCCR1B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr1b::R](R) reader structure"]
impl crate :: Readable for TCCR1B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr1b::W](W) writer structure"]
impl crate :: Writable for TCCR1B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR1B to value 0"]
impl crate :: Resettable for TCCR1B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR1C (rw) register accessor: an alias for `Reg<TCCR1C_SPEC>`"]
pub type TCCR1C = crate :: Reg < tccr1c :: TCCR1C_SPEC > ; # [doc = "Timer/Counter1 Control Register C"]
pub mod tccr1c { # [doc = "Register `TCCR1C` reader"]
pub struct R (crate :: R < TCCR1C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR1C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR1C_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR1C` writer"]
pub struct W (crate :: W < TCCR1C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR1C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR1C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR1C_SPEC >) -> Self { W (writer) } } # [doc = "Field `FOC1B` reader - No Description."]
pub type FOC1B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC1B` writer - No Description."]
pub type FOC1B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1C_SPEC , bool , O > ; # [doc = "Field `FOC1A` reader - No Description."]
pub type FOC1A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC1A` writer - No Description."]
pub type FOC1A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR1C_SPEC , bool , O > ; impl R { # [doc = "Bit 6 - No Description."]
# [inline (always)]
pub fn foc1b (& self) -> FOC1B_R { FOC1B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - No Description."]
# [inline (always)]
pub fn foc1a (& self) -> FOC1A_R { FOC1A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 6 - No Description."]
# [inline (always)]
# [must_use]
pub fn foc1b (& mut self) -> FOC1B_W < 6 > { FOC1B_W :: new (self) } # [doc = "Bit 7 - No Description."]
# [inline (always)]
# [must_use]
pub fn foc1a (& mut self) -> FOC1A_W < 7 > { FOC1A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter1 Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr1c](index.html) module"]
pub struct TCCR1C_SPEC ; impl crate :: RegisterSpec for TCCR1C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr1c::R](R) reader structure"]
impl crate :: Readable for TCCR1C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr1c::W](W) writer structure"]
impl crate :: Writable for TCCR1C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR1C to value 0"]
impl crate :: Resettable for TCCR1C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT1 (rw) register accessor: an alias for `Reg<TCNT1_SPEC>`"]
pub type TCNT1 = crate :: Reg < tcnt1 :: TCNT1_SPEC > ; # [doc = "Timer/Counter1 Bytes"]
pub mod tcnt1 { # [doc = "Register `TCNT1` reader"]
pub struct R (crate :: R < TCNT1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT1` writer"]
pub struct W (crate :: W < TCNT1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter1 Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt1](index.html) module"]
pub struct TCNT1_SPEC ; impl crate :: RegisterSpec for TCNT1_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [tcnt1::R](R) reader structure"]
impl crate :: Readable for TCNT1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt1::W](W) writer structure"]
impl crate :: Writable for TCNT1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT1 to value 0"]
impl crate :: Resettable for TCNT1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR1 (rw) register accessor: an alias for `Reg<TIFR1_SPEC>`"]
pub type TIFR1 = crate :: Reg < tifr1 :: TIFR1_SPEC > ; # [doc = "Timer/Counter Interrupt Flag register"]
pub mod tifr1 { # [doc = "Register `TIFR1` reader"]
pub struct R (crate :: R < TIFR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR1` writer"]
pub struct W (crate :: W < TIFR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR1_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV1` reader - Timer/Counter1 Overflow Flag"]
pub type TOV1_R = crate :: BitReader < bool > ; # [doc = "Field `TOV1` writer - Timer/Counter1 Overflow Flag"]
pub type TOV1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; # [doc = "Field `OCF1A` reader - Output Compare Flag 1A"]
pub type OCF1A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF1A` writer - Output Compare Flag 1A"]
pub type OCF1A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; # [doc = "Field `OCF1B` reader - Output Compare Flag 1B"]
pub type OCF1B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF1B` writer - Output Compare Flag 1B"]
pub type OCF1B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; # [doc = "Field `ICF1` reader - Input Capture Flag 1"]
pub type ICF1_R = crate :: BitReader < bool > ; # [doc = "Field `ICF1` writer - Input Capture Flag 1"]
pub type ICF1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter1 Overflow Flag"]
# [inline (always)]
pub fn tov1 (& self) -> TOV1_R { TOV1_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Output Compare Flag 1A"]
# [inline (always)]
pub fn ocf1a (& self) -> OCF1A_R { OCF1A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Output Compare Flag 1B"]
# [inline (always)]
pub fn ocf1b (& self) -> OCF1B_R { OCF1B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 5 - Input Capture Flag 1"]
# [inline (always)]
pub fn icf1 (& self) -> ICF1_R { ICF1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter1 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov1 (& mut self) -> TOV1_W < 0 > { TOV1_W :: new (self) } # [doc = "Bit 1 - Output Compare Flag 1A"]
# [inline (always)]
# [must_use]
pub fn ocf1a (& mut self) -> OCF1A_W < 1 > { OCF1A_W :: new (self) } # [doc = "Bit 2 - Output Compare Flag 1B"]
# [inline (always)]
# [must_use]
pub fn ocf1b (& mut self) -> OCF1B_W < 2 > { OCF1B_W :: new (self) } # [doc = "Bit 5 - Input Capture Flag 1"]
# [inline (always)]
# [must_use]
pub fn icf1 (& mut self) -> ICF1_W < 5 > { ICF1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter Interrupt Flag register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr1](index.html) module"]
pub struct TIFR1_SPEC ; impl crate :: RegisterSpec for TIFR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr1::R](R) reader structure"]
impl crate :: Readable for TIFR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr1::W](W) writer structure"]
impl crate :: Writable for TIFR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR1 to value 0"]
impl crate :: Resettable for TIFR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK1 (rw) register accessor: an alias for `Reg<TIMSK1_SPEC>`"]
pub type TIMSK1 = crate :: Reg < timsk1 :: TIMSK1_SPEC > ; # [doc = "Timer/Counter Interrupt Mask Register"]
pub mod timsk1 { # [doc = "Register `TIMSK1` reader"]
pub struct R (crate :: R < TIMSK1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK1` writer"]
pub struct W (crate :: W < TIMSK1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK1_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE1` reader - Timer/Counter1 Overflow Interrupt Enable"]
pub type TOIE1_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE1` writer - Timer/Counter1 Overflow Interrupt Enable"]
pub type TOIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; # [doc = "Field `OCIE1A` reader - Timer/Counter1 Output CompareA Match Interrupt Enable"]
pub type OCIE1A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE1A` writer - Timer/Counter1 Output CompareA Match Interrupt Enable"]
pub type OCIE1A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; # [doc = "Field `OCIE1B` reader - Timer/Counter1 Output CompareB Match Interrupt Enable"]
pub type OCIE1B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE1B` writer - Timer/Counter1 Output CompareB Match Interrupt Enable"]
pub type OCIE1B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; # [doc = "Field `ICIE1` reader - Timer/Counter1 Input Capture Interrupt Enable"]
pub type ICIE1_R = crate :: BitReader < bool > ; # [doc = "Field `ICIE1` writer - Timer/Counter1 Input Capture Interrupt Enable"]
pub type ICIE1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter1 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie1 (& self) -> TOIE1_R { TOIE1_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter1 Output CompareA Match Interrupt Enable"]
# [inline (always)]
pub fn ocie1a (& self) -> OCIE1A_R { OCIE1A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter1 Output CompareB Match Interrupt Enable"]
# [inline (always)]
pub fn ocie1b (& self) -> OCIE1B_R { OCIE1B_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 5 - Timer/Counter1 Input Capture Interrupt Enable"]
# [inline (always)]
pub fn icie1 (& self) -> ICIE1_R { ICIE1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter1 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie1 (& mut self) -> TOIE1_W < 0 > { TOIE1_W :: new (self) } # [doc = "Bit 1 - Timer/Counter1 Output CompareA Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie1a (& mut self) -> OCIE1A_W < 1 > { OCIE1A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter1 Output CompareB Match Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie1b (& mut self) -> OCIE1B_W < 2 > { OCIE1B_W :: new (self) } # [doc = "Bit 5 - Timer/Counter1 Input Capture Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn icie1 (& mut self) -> ICIE1_W < 5 > { ICIE1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk1](index.html) module"]
pub struct TIMSK1_SPEC ; impl crate :: RegisterSpec for TIMSK1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk1::R](R) reader structure"]
impl crate :: Readable for TIMSK1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk1::W](W) writer structure"]
impl crate :: Writable for TIMSK1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK1 to value 0"]
impl crate :: Resettable for TIMSK1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Timer/Counter, 8-bit Async"]
pub struct TC2 { _marker : PhantomData < * const () > } unsafe impl Send for TC2 { } impl TC2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc2 :: RegisterBlock = 0x37 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc2 :: RegisterBlock { Self :: PTR } } impl Deref for TC2 { type Target = tc2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC2") . finish () } } # [doc = "Timer/Counter, 8-bit Async"]
pub mod tc2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Timer/Counter Interrupt Flag Register"]
pub tifr2 : TIFR2 , _reserved1 : [u8 ; 0x0b]
, # [doc = "0x0c - General Timer Counter Control register"]
pub gtccr : GTCCR , _reserved2 : [u8 ; 0x2c]
, # [doc = "0x39 - Timer/Counter Interrupt Mask register"]
pub timsk2 : TIMSK2 , _reserved3 : [u8 ; 0x3f]
, # [doc = "0x79 - Timer/Counter2 Control Register A"]
pub tccr2a : TCCR2A , # [doc = "0x7a - Timer/Counter2 Control Register B"]
pub tccr2b : TCCR2B , # [doc = "0x7b - Timer/Counter2"]
pub tcnt2 : TCNT2 , # [doc = "0x7c - Timer/Counter2 Output Compare Register A"]
pub ocr2a : OCR2A , # [doc = "0x7d - Timer/Counter2 Output Compare Register B"]
pub ocr2b : OCR2B , _reserved8 : [u8 ; 0x01]
, # [doc = "0x7f - Asynchronous Status Register"]
pub assr : ASSR , } # [doc = "ASSR (rw) register accessor: an alias for `Reg<ASSR_SPEC>`"]
pub type ASSR = crate :: Reg < assr :: ASSR_SPEC > ; # [doc = "Asynchronous Status Register"]
pub mod assr { # [doc = "Register `ASSR` reader"]
pub struct R (crate :: R < ASSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ASSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ASSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ASSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ASSR` writer"]
pub struct W (crate :: W < ASSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ASSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ASSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ASSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TCR2BUB` reader - Timer/Counter Control Register2 Update Busy"]
pub type TCR2BUB_R = crate :: BitReader < bool > ; # [doc = "Field `TCR2BUB` writer - Timer/Counter Control Register2 Update Busy"]
pub type TCR2BUB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `TCR2AUB` reader - Timer/Counter Control Register2 Update Busy"]
pub type TCR2AUB_R = crate :: BitReader < bool > ; # [doc = "Field `TCR2AUB` writer - Timer/Counter Control Register2 Update Busy"]
pub type TCR2AUB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `OCR2BUB` reader - Output Compare Register 2 Update Busy"]
pub type OCR2BUB_R = crate :: BitReader < bool > ; # [doc = "Field `OCR2BUB` writer - Output Compare Register 2 Update Busy"]
pub type OCR2BUB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `OCR2AUB` reader - Output Compare Register2 Update Busy"]
pub type OCR2AUB_R = crate :: BitReader < bool > ; # [doc = "Field `OCR2AUB` writer - Output Compare Register2 Update Busy"]
pub type OCR2AUB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `TCN2UB` reader - Timer/Counter2 Update Busy"]
pub type TCN2UB_R = crate :: BitReader < bool > ; # [doc = "Field `TCN2UB` writer - Timer/Counter2 Update Busy"]
pub type TCN2UB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `AS2` reader - Asynchronous Timer/Counter2"]
pub type AS2_R = crate :: BitReader < bool > ; # [doc = "Field `AS2` writer - Asynchronous Timer/Counter2"]
pub type AS2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; # [doc = "Field `EXCLK` reader - Enable External Clock Input"]
pub type EXCLK_R = crate :: BitReader < bool > ; # [doc = "Field `EXCLK` writer - Enable External Clock Input"]
pub type EXCLK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , ASSR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter Control Register2 Update Busy"]
# [inline (always)]
pub fn tcr2bub (& self) -> TCR2BUB_R { TCR2BUB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter Control Register2 Update Busy"]
# [inline (always)]
pub fn tcr2aub (& self) -> TCR2AUB_R { TCR2AUB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Output Compare Register 2 Update Busy"]
# [inline (always)]
pub fn ocr2bub (& self) -> OCR2BUB_R { OCR2BUB_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Output Compare Register2 Update Busy"]
# [inline (always)]
pub fn ocr2aub (& self) -> OCR2AUB_R { OCR2AUB_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Timer/Counter2 Update Busy"]
# [inline (always)]
pub fn tcn2ub (& self) -> TCN2UB_R { TCN2UB_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Asynchronous Timer/Counter2"]
# [inline (always)]
pub fn as2 (& self) -> AS2_R { AS2_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Enable External Clock Input"]
# [inline (always)]
pub fn exclk (& self) -> EXCLK_R { EXCLK_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter Control Register2 Update Busy"]
# [inline (always)]
# [must_use]
pub fn tcr2bub (& mut self) -> TCR2BUB_W < 0 > { TCR2BUB_W :: new (self) } # [doc = "Bit 1 - Timer/Counter Control Register2 Update Busy"]
# [inline (always)]
# [must_use]
pub fn tcr2aub (& mut self) -> TCR2AUB_W < 1 > { TCR2AUB_W :: new (self) } # [doc = "Bit 2 - Output Compare Register 2 Update Busy"]
# [inline (always)]
# [must_use]
pub fn ocr2bub (& mut self) -> OCR2BUB_W < 2 > { OCR2BUB_W :: new (self) } # [doc = "Bit 3 - Output Compare Register2 Update Busy"]
# [inline (always)]
# [must_use]
pub fn ocr2aub (& mut self) -> OCR2AUB_W < 3 > { OCR2AUB_W :: new (self) } # [doc = "Bit 4 - Timer/Counter2 Update Busy"]
# [inline (always)]
# [must_use]
pub fn tcn2ub (& mut self) -> TCN2UB_W < 4 > { TCN2UB_W :: new (self) } # [doc = "Bit 5 - Asynchronous Timer/Counter2"]
# [inline (always)]
# [must_use]
pub fn as2 (& mut self) -> AS2_W < 5 > { AS2_W :: new (self) } # [doc = "Bit 6 - Enable External Clock Input"]
# [inline (always)]
# [must_use]
pub fn exclk (& mut self) -> EXCLK_W < 6 > { EXCLK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Asynchronous Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [assr](index.html) module"]
pub struct ASSR_SPEC ; impl crate :: RegisterSpec for ASSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [assr::R](R) reader structure"]
impl crate :: Readable for ASSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [assr::W](W) writer structure"]
impl crate :: Writable for ASSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ASSR to value 0"]
impl crate :: Resettable for ASSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GTCCR (rw) register accessor: an alias for `Reg<GTCCR_SPEC>`"]
pub type GTCCR = crate :: Reg < gtccr :: GTCCR_SPEC > ; # [doc = "General Timer Counter Control register"]
pub mod gtccr { # [doc = "Register `GTCCR` reader"]
pub struct R (crate :: R < GTCCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GTCCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GTCCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `GTCCR` writer"]
pub struct W (crate :: W < GTCCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GTCCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GTCCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GTCCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PSRASY` reader - Prescaler Reset Timer/Counter2"]
pub type PSRASY_R = crate :: BitReader < bool > ; # [doc = "Field `PSRASY` writer - Prescaler Reset Timer/Counter2"]
pub type PSRASY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; # [doc = "Field `TSM` reader - Timer/Counter Synchronization Mode"]
pub type TSM_R = crate :: BitReader < bool > ; # [doc = "Field `TSM` writer - Timer/Counter Synchronization Mode"]
pub type TSM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , GTCCR_SPEC , bool , O > ; impl R { # [doc = "Bit 1 - Prescaler Reset Timer/Counter2"]
# [inline (always)]
pub fn psrasy (& self) -> PSRASY_R { PSRASY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
pub fn tsm (& self) -> TSM_R { TSM_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 1 - Prescaler Reset Timer/Counter2"]
# [inline (always)]
# [must_use]
pub fn psrasy (& mut self) -> PSRASY_W < 1 > { PSRASY_W :: new (self) } # [doc = "Bit 7 - Timer/Counter Synchronization Mode"]
# [inline (always)]
# [must_use]
pub fn tsm (& mut self) -> TSM_W < 7 > { TSM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Timer Counter Control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gtccr](index.html) module"]
pub struct GTCCR_SPEC ; impl crate :: RegisterSpec for GTCCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gtccr::R](R) reader structure"]
impl crate :: Readable for GTCCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gtccr::W](W) writer structure"]
impl crate :: Writable for GTCCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GTCCR to value 0"]
impl crate :: Resettable for GTCCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR2A (rw) register accessor: an alias for `Reg<OCR2A_SPEC>`"]
pub type OCR2A = crate :: Reg < ocr2a :: OCR2A_SPEC > ; # [doc = "Timer/Counter2 Output Compare Register A"]
pub mod ocr2a { # [doc = "Register `OCR2A` reader"]
pub struct R (crate :: R < OCR2A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR2A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR2A_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR2A` writer"]
pub struct W (crate :: W < OCR2A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR2A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR2A_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter2 Output Compare Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr2a](index.html) module"]
pub struct OCR2A_SPEC ; impl crate :: RegisterSpec for OCR2A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocr2a::R](R) reader structure"]
impl crate :: Readable for OCR2A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr2a::W](W) writer structure"]
impl crate :: Writable for OCR2A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR2A to value 0"]
impl crate :: Resettable for OCR2A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCR2B (rw) register accessor: an alias for `Reg<OCR2B_SPEC>`"]
pub type OCR2B = crate :: Reg < ocr2b :: OCR2B_SPEC > ; # [doc = "Timer/Counter2 Output Compare Register B"]
pub mod ocr2b { # [doc = "Register `OCR2B` reader"]
pub struct R (crate :: R < OCR2B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCR2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCR2B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCR2B_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCR2B` writer"]
pub struct W (crate :: W < OCR2B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCR2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCR2B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCR2B_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter2 Output Compare Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocr2b](index.html) module"]
pub struct OCR2B_SPEC ; impl crate :: RegisterSpec for OCR2B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocr2b::R](R) reader structure"]
impl crate :: Readable for OCR2B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocr2b::W](W) writer structure"]
impl crate :: Writable for OCR2B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCR2B to value 0"]
impl crate :: Resettable for OCR2B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR2A (rw) register accessor: an alias for `Reg<TCCR2A_SPEC>`"]
pub type TCCR2A = crate :: Reg < tccr2a :: TCCR2A_SPEC > ; # [doc = "Timer/Counter2 Control Register A"]
pub mod tccr2a { # [doc = "Register `TCCR2A` reader"]
pub struct R (crate :: R < TCCR2A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR2A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR2A_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR2A` writer"]
pub struct W (crate :: W < TCCR2A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR2A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR2A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR2A_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGM2` reader - Waveform Genration Mode"]
pub type WGM2_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `WGM2` writer - Waveform Genration Mode"]
pub type WGM2_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2A_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `COM2B` reader - Compare Output Mode bits"]
pub type COM2B_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `COM2B` writer - Compare Output Mode bits"]
pub type COM2B_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2A_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `COM2A` reader - Compare Output Mode bits"]
pub type COM2A_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `COM2A` writer - Compare Output Mode bits"]
pub type COM2A_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2A_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bits 0:1 - Waveform Genration Mode"]
# [inline (always)]
pub fn wgm2 (& self) -> WGM2_R { WGM2_R :: new (self . bits & 3) } # [doc = "Bits 4:5 - Compare Output Mode bits"]
# [inline (always)]
pub fn com2b (& self) -> COM2B_R { COM2B_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare Output Mode bits"]
# [inline (always)]
pub fn com2a (& self) -> COM2A_R { COM2A_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Waveform Genration Mode"]
# [inline (always)]
# [must_use]
pub fn wgm2 (& mut self) -> WGM2_W < 0 > { WGM2_W :: new (self) } # [doc = "Bits 4:5 - Compare Output Mode bits"]
# [inline (always)]
# [must_use]
pub fn com2b (& mut self) -> COM2B_W < 4 > { COM2B_W :: new (self) } # [doc = "Bits 6:7 - Compare Output Mode bits"]
# [inline (always)]
# [must_use]
pub fn com2a (& mut self) -> COM2A_W < 6 > { COM2A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter2 Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr2a](index.html) module"]
pub struct TCCR2A_SPEC ; impl crate :: RegisterSpec for TCCR2A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr2a::R](R) reader structure"]
impl crate :: Readable for TCCR2A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr2a::W](W) writer structure"]
impl crate :: Writable for TCCR2A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR2A to value 0"]
impl crate :: Resettable for TCCR2A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCCR2B (rw) register accessor: an alias for `Reg<TCCR2B_SPEC>`"]
pub type TCCR2B = crate :: Reg < tccr2b :: TCCR2B_SPEC > ; # [doc = "Timer/Counter2 Control Register B"]
pub mod tccr2b { # [doc = "Register `TCCR2B` reader"]
pub struct R (crate :: R < TCCR2B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCCR2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCCR2B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCCR2B_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCCR2B` writer"]
pub struct W (crate :: W < TCCR2B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCCR2B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCCR2B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCCR2B_SPEC >) -> Self { W (writer) } } # [doc = "Field `CS2` reader - Clock Select bits"]
pub type CS2_R = crate :: FieldReader < u8 , CS2_A > ; # [doc = "Clock Select bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CS2_A { # [doc = "0: No Clock Source (Stopped)"]
VAL_0X00 = 0 , # [doc = "1: Running, No Prescaling"]
VAL_0X01 = 1 , # [doc = "2: Running, CLK/8"]
VAL_0X02 = 2 , # [doc = "3: Running, CLK/32"]
VAL_0X03 = 3 , # [doc = "4: Running, CLK/64"]
VAL_0X04 = 4 , # [doc = "5: Running, CLK/128"]
VAL_0X05 = 5 , # [doc = "6: Running, CLK/256"]
VAL_0X06 = 6 , # [doc = "7: Running, CLK/1024"]
VAL_0X07 = 7 , } impl From < CS2_A > for u8 { # [inline (always)]
fn from (variant : CS2_A) -> Self { variant as _ } } impl CS2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CS2_A { match self . bits { 0 => CS2_A :: VAL_0X00 , 1 => CS2_A :: VAL_0X01 , 2 => CS2_A :: VAL_0X02 , 3 => CS2_A :: VAL_0X03 , 4 => CS2_A :: VAL_0X04 , 5 => CS2_A :: VAL_0X05 , 6 => CS2_A :: VAL_0X06 , 7 => CS2_A :: VAL_0X07 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == CS2_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == CS2_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == CS2_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == CS2_A :: VAL_0X03 } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == CS2_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == CS2_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `VAL_0X06`"]
# [inline (always)]
pub fn is_val_0x06 (& self) -> bool { * self == CS2_A :: VAL_0X06 } # [doc = "Checks if the value of the field is `VAL_0X07`"]
# [inline (always)]
pub fn is_val_0x07 (& self) -> bool { * self == CS2_A :: VAL_0X07 } } # [doc = "Field `CS2` writer - Clock Select bits"]
pub type CS2_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TCCR2B_SPEC , u8 , CS2_A , 3 , O > ; impl < 'a , const O : u8 > CS2_W < 'a , O > { # [doc = "No Clock Source (Stopped)"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (CS2_A :: VAL_0X00) } # [doc = "Running, No Prescaling"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (CS2_A :: VAL_0X01) } # [doc = "Running, CLK/8"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (CS2_A :: VAL_0X02) } # [doc = "Running, CLK/32"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (CS2_A :: VAL_0X03) } # [doc = "Running, CLK/64"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (CS2_A :: VAL_0X04) } # [doc = "Running, CLK/128"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (CS2_A :: VAL_0X05) } # [doc = "Running, CLK/256"]
# [inline (always)]
pub fn val_0x06 (self) -> & 'a mut W { self . variant (CS2_A :: VAL_0X06) } # [doc = "Running, CLK/1024"]
# [inline (always)]
pub fn val_0x07 (self) -> & 'a mut W { self . variant (CS2_A :: VAL_0X07) } } # [doc = "Field `WGM22` reader - Waveform Generation Mode"]
pub type WGM22_R = crate :: BitReader < bool > ; # [doc = "Field `WGM22` writer - Waveform Generation Mode"]
pub type WGM22_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR2B_SPEC , bool , O > ; # [doc = "Field `FOC2B` reader - Force Output Compare B"]
pub type FOC2B_R = crate :: BitReader < bool > ; # [doc = "Field `FOC2B` writer - Force Output Compare B"]
pub type FOC2B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR2B_SPEC , bool , O > ; # [doc = "Field `FOC2A` reader - Force Output Compare A"]
pub type FOC2A_R = crate :: BitReader < bool > ; # [doc = "Field `FOC2A` writer - Force Output Compare A"]
pub type FOC2A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TCCR2B_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Clock Select bits"]
# [inline (always)]
pub fn cs2 (& self) -> CS2_R { CS2_R :: new (self . bits & 7) } # [doc = "Bit 3 - Waveform Generation Mode"]
# [inline (always)]
pub fn wgm22 (& self) -> WGM22_R { WGM22_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 6 - Force Output Compare B"]
# [inline (always)]
pub fn foc2b (& self) -> FOC2B_R { FOC2B_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Force Output Compare A"]
# [inline (always)]
pub fn foc2a (& self) -> FOC2A_R { FOC2A_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Clock Select bits"]
# [inline (always)]
# [must_use]
pub fn cs2 (& mut self) -> CS2_W < 0 > { CS2_W :: new (self) } # [doc = "Bit 3 - Waveform Generation Mode"]
# [inline (always)]
# [must_use]
pub fn wgm22 (& mut self) -> WGM22_W < 3 > { WGM22_W :: new (self) } # [doc = "Bit 6 - Force Output Compare B"]
# [inline (always)]
# [must_use]
pub fn foc2b (& mut self) -> FOC2B_W < 6 > { FOC2B_W :: new (self) } # [doc = "Bit 7 - Force Output Compare A"]
# [inline (always)]
# [must_use]
pub fn foc2a (& mut self) -> FOC2A_W < 7 > { FOC2A_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter2 Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tccr2b](index.html) module"]
pub struct TCCR2B_SPEC ; impl crate :: RegisterSpec for TCCR2B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tccr2b::R](R) reader structure"]
impl crate :: Readable for TCCR2B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tccr2b::W](W) writer structure"]
impl crate :: Writable for TCCR2B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCCR2B to value 0"]
impl crate :: Resettable for TCCR2B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TCNT2 (rw) register accessor: an alias for `Reg<TCNT2_SPEC>`"]
pub type TCNT2 = crate :: Reg < tcnt2 :: TCNT2_SPEC > ; # [doc = "Timer/Counter2"]
pub mod tcnt2 { # [doc = "Register `TCNT2` reader"]
pub struct R (crate :: R < TCNT2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TCNT2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TCNT2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TCNT2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TCNT2` writer"]
pub struct W (crate :: W < TCNT2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TCNT2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TCNT2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TCNT2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Timer/Counter2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcnt2](index.html) module"]
pub struct TCNT2_SPEC ; impl crate :: RegisterSpec for TCNT2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tcnt2::R](R) reader structure"]
impl crate :: Readable for TCNT2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tcnt2::W](W) writer structure"]
impl crate :: Writable for TCNT2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TCNT2 to value 0"]
impl crate :: Resettable for TCNT2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIFR2 (rw) register accessor: an alias for `Reg<TIFR2_SPEC>`"]
pub type TIFR2 = crate :: Reg < tifr2 :: TIFR2_SPEC > ; # [doc = "Timer/Counter Interrupt Flag Register"]
pub mod tifr2 { # [doc = "Register `TIFR2` reader"]
pub struct R (crate :: R < TIFR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIFR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIFR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIFR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIFR2` writer"]
pub struct W (crate :: W < TIFR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIFR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIFR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIFR2_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOV2` reader - Timer/Counter2 Overflow Flag"]
pub type TOV2_R = crate :: BitReader < bool > ; # [doc = "Field `TOV2` writer - Timer/Counter2 Overflow Flag"]
pub type TOV2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR2_SPEC , bool , O > ; # [doc = "Field `OCF2A` reader - Output Compare Flag 2A"]
pub type OCF2A_R = crate :: BitReader < bool > ; # [doc = "Field `OCF2A` writer - Output Compare Flag 2A"]
pub type OCF2A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR2_SPEC , bool , O > ; # [doc = "Field `OCF2B` reader - Output Compare Flag 2B"]
pub type OCF2B_R = crate :: BitReader < bool > ; # [doc = "Field `OCF2B` writer - Output Compare Flag 2B"]
pub type OCF2B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIFR2_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter2 Overflow Flag"]
# [inline (always)]
pub fn tov2 (& self) -> TOV2_R { TOV2_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Output Compare Flag 2A"]
# [inline (always)]
pub fn ocf2a (& self) -> OCF2A_R { OCF2A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Output Compare Flag 2B"]
# [inline (always)]
pub fn ocf2b (& self) -> OCF2B_R { OCF2B_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter2 Overflow Flag"]
# [inline (always)]
# [must_use]
pub fn tov2 (& mut self) -> TOV2_W < 0 > { TOV2_W :: new (self) } # [doc = "Bit 1 - Output Compare Flag 2A"]
# [inline (always)]
# [must_use]
pub fn ocf2a (& mut self) -> OCF2A_W < 1 > { OCF2A_W :: new (self) } # [doc = "Bit 2 - Output Compare Flag 2B"]
# [inline (always)]
# [must_use]
pub fn ocf2b (& mut self) -> OCF2B_W < 2 > { OCF2B_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tifr2](index.html) module"]
pub struct TIFR2_SPEC ; impl crate :: RegisterSpec for TIFR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tifr2::R](R) reader structure"]
impl crate :: Readable for TIFR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tifr2::W](W) writer structure"]
impl crate :: Writable for TIFR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIFR2 to value 0"]
impl crate :: Resettable for TIFR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMSK2 (rw) register accessor: an alias for `Reg<TIMSK2_SPEC>`"]
pub type TIMSK2 = crate :: Reg < timsk2 :: TIMSK2_SPEC > ; # [doc = "Timer/Counter Interrupt Mask register"]
pub mod timsk2 { # [doc = "Register `TIMSK2` reader"]
pub struct R (crate :: R < TIMSK2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMSK2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMSK2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMSK2_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMSK2` writer"]
pub struct W (crate :: W < TIMSK2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMSK2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMSK2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMSK2_SPEC >) -> Self { W (writer) } } # [doc = "Field `TOIE2` reader - Timer/Counter2 Overflow Interrupt Enable"]
pub type TOIE2_R = crate :: BitReader < bool > ; # [doc = "Field `TOIE2` writer - Timer/Counter2 Overflow Interrupt Enable"]
pub type TOIE2_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK2_SPEC , bool , O > ; # [doc = "Field `OCIE2A` reader - Timer/Counter2 Output Compare Match A Interrupt Enable"]
pub type OCIE2A_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE2A` writer - Timer/Counter2 Output Compare Match A Interrupt Enable"]
pub type OCIE2A_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK2_SPEC , bool , O > ; # [doc = "Field `OCIE2B` reader - Timer/Counter2 Output Compare Match B Interrupt Enable"]
pub type OCIE2B_R = crate :: BitReader < bool > ; # [doc = "Field `OCIE2B` writer - Timer/Counter2 Output Compare Match B Interrupt Enable"]
pub type OCIE2B_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TIMSK2_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Timer/Counter2 Overflow Interrupt Enable"]
# [inline (always)]
pub fn toie2 (& self) -> TOIE2_R { TOIE2_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Timer/Counter2 Output Compare Match A Interrupt Enable"]
# [inline (always)]
pub fn ocie2a (& self) -> OCIE2A_R { OCIE2A_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Timer/Counter2 Output Compare Match B Interrupt Enable"]
# [inline (always)]
pub fn ocie2b (& self) -> OCIE2B_R { OCIE2B_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Timer/Counter2 Overflow Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn toie2 (& mut self) -> TOIE2_W < 0 > { TOIE2_W :: new (self) } # [doc = "Bit 1 - Timer/Counter2 Output Compare Match A Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie2a (& mut self) -> OCIE2A_W < 1 > { OCIE2A_W :: new (self) } # [doc = "Bit 2 - Timer/Counter2 Output Compare Match B Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn ocie2b (& mut self) -> OCIE2B_W < 2 > { OCIE2B_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timer/Counter Interrupt Mask register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timsk2](index.html) module"]
pub struct TIMSK2_SPEC ; impl crate :: RegisterSpec for TIMSK2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timsk2::R](R) reader structure"]
impl crate :: Readable for TIMSK2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timsk2::W](W) writer structure"]
impl crate :: Writable for TIMSK2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMSK2 to value 0"]
impl crate :: Resettable for TIMSK2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Two Wire Serial Interface"]
pub struct TWI { _marker : PhantomData < * const () > } unsafe impl Send for TWI { } impl TWI { # [doc = r"Pointer to the register block"]
pub const PTR : * const twi :: RegisterBlock = 0xb8 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const twi :: RegisterBlock { Self :: PTR } } impl Deref for TWI { type Target = twi :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TWI { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TWI") . finish () } } # [doc = "Two Wire Serial Interface"]
pub mod twi { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - TWI Bit Rate register"]
pub twbr : TWBR , # [doc = "0x01 - TWI Status Register"]
pub twsr : TWSR , # [doc = "0x02 - TWI (Slave) Address register"]
pub twar : TWAR , # [doc = "0x03 - TWI Data register"]
pub twdr : TWDR , # [doc = "0x04 - TWI Control Register"]
pub twcr : TWCR , # [doc = "0x05 - TWI (Slave) Address Mask Register"]
pub twamr : TWAMR , } # [doc = "TWAMR (rw) register accessor: an alias for `Reg<TWAMR_SPEC>`"]
pub type TWAMR = crate :: Reg < twamr :: TWAMR_SPEC > ; # [doc = "TWI (Slave) Address Mask Register"]
pub mod twamr { # [doc = "Register `TWAMR` reader"]
pub struct R (crate :: R < TWAMR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWAMR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWAMR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWAMR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWAMR` writer"]
pub struct W (crate :: W < TWAMR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWAMR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWAMR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWAMR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TWAM` reader - No Description."]
pub type TWAM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TWAM` writer - No Description."]
pub type TWAM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWAMR_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 1:7 - No Description."]
# [inline (always)]
pub fn twam (& self) -> TWAM_R { TWAM_R :: new ((self . bits >> 1) & 0x7f) } } impl W { # [doc = "Bits 1:7 - No Description."]
# [inline (always)]
# [must_use]
pub fn twam (& mut self) -> TWAM_W < 1 > { TWAM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI (Slave) Address Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twamr](index.html) module"]
pub struct TWAMR_SPEC ; impl crate :: RegisterSpec for TWAMR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twamr::R](R) reader structure"]
impl crate :: Readable for TWAMR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twamr::W](W) writer structure"]
impl crate :: Writable for TWAMR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWAMR to value 0"]
impl crate :: Resettable for TWAMR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWAR (rw) register accessor: an alias for `Reg<TWAR_SPEC>`"]
pub type TWAR = crate :: Reg < twar :: TWAR_SPEC > ; # [doc = "TWI (Slave) Address register"]
pub mod twar { # [doc = "Register `TWAR` reader"]
pub struct R (crate :: R < TWAR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWAR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWAR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWAR` writer"]
pub struct W (crate :: W < TWAR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWAR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWAR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TWGCE` reader - TWI General Call Recognition Enable Bit"]
pub type TWGCE_R = crate :: BitReader < bool > ; # [doc = "Field `TWGCE` writer - TWI General Call Recognition Enable Bit"]
pub type TWGCE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWAR_SPEC , bool , O > ; # [doc = "Field `TWA` reader - TWI (Slave) Address register Bits"]
pub type TWA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TWA` writer - TWI (Slave) Address register Bits"]
pub type TWA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWAR_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bit 0 - TWI General Call Recognition Enable Bit"]
# [inline (always)]
pub fn twgce (& self) -> TWGCE_R { TWGCE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:7 - TWI (Slave) Address register Bits"]
# [inline (always)]
pub fn twa (& self) -> TWA_R { TWA_R :: new ((self . bits >> 1) & 0x7f) } } impl W { # [doc = "Bit 0 - TWI General Call Recognition Enable Bit"]
# [inline (always)]
# [must_use]
pub fn twgce (& mut self) -> TWGCE_W < 0 > { TWGCE_W :: new (self) } # [doc = "Bits 1:7 - TWI (Slave) Address register Bits"]
# [inline (always)]
# [must_use]
pub fn twa (& mut self) -> TWA_W < 1 > { TWA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI (Slave) Address register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twar](index.html) module"]
pub struct TWAR_SPEC ; impl crate :: RegisterSpec for TWAR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twar::R](R) reader structure"]
impl crate :: Readable for TWAR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twar::W](W) writer structure"]
impl crate :: Writable for TWAR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWAR to value 0"]
impl crate :: Resettable for TWAR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWBR (rw) register accessor: an alias for `Reg<TWBR_SPEC>`"]
pub type TWBR = crate :: Reg < twbr :: TWBR_SPEC > ; # [doc = "TWI Bit Rate register"]
pub mod twbr { # [doc = "Register `TWBR` reader"]
pub struct R (crate :: R < TWBR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWBR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWBR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWBR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWBR` writer"]
pub struct W (crate :: W < TWBR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWBR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWBR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWBR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "TWI Bit Rate register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twbr](index.html) module"]
pub struct TWBR_SPEC ; impl crate :: RegisterSpec for TWBR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twbr::R](R) reader structure"]
impl crate :: Readable for TWBR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twbr::W](W) writer structure"]
impl crate :: Writable for TWBR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWBR to value 0"]
impl crate :: Resettable for TWBR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWCR (rw) register accessor: an alias for `Reg<TWCR_SPEC>`"]
pub type TWCR = crate :: Reg < twcr :: TWCR_SPEC > ; # [doc = "TWI Control Register"]
pub mod twcr { # [doc = "Register `TWCR` reader"]
pub struct R (crate :: R < TWCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWCR` writer"]
pub struct W (crate :: W < TWCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TWIE` reader - TWI Interrupt Enable"]
pub type TWIE_R = crate :: BitReader < bool > ; # [doc = "Field `TWIE` writer - TWI Interrupt Enable"]
pub type TWIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWEN` reader - TWI Enable Bit"]
pub type TWEN_R = crate :: BitReader < bool > ; # [doc = "Field `TWEN` writer - TWI Enable Bit"]
pub type TWEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWWC` reader - TWI Write Collition Flag"]
pub type TWWC_R = crate :: BitReader < bool > ; # [doc = "Field `TWWC` writer - TWI Write Collition Flag"]
pub type TWWC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWSTO` reader - TWI Stop Condition Bit"]
pub type TWSTO_R = crate :: BitReader < bool > ; # [doc = "Field `TWSTO` writer - TWI Stop Condition Bit"]
pub type TWSTO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWSTA` reader - TWI Start Condition Bit"]
pub type TWSTA_R = crate :: BitReader < bool > ; # [doc = "Field `TWSTA` writer - TWI Start Condition Bit"]
pub type TWSTA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWEA` reader - TWI Enable Acknowledge Bit"]
pub type TWEA_R = crate :: BitReader < bool > ; # [doc = "Field `TWEA` writer - TWI Enable Acknowledge Bit"]
pub type TWEA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; # [doc = "Field `TWINT` reader - TWI Interrupt Flag"]
pub type TWINT_R = crate :: BitReader < bool > ; # [doc = "Field `TWINT` writer - TWI Interrupt Flag"]
pub type TWINT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , TWCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - TWI Interrupt Enable"]
# [inline (always)]
pub fn twie (& self) -> TWIE_R { TWIE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - TWI Enable Bit"]
# [inline (always)]
pub fn twen (& self) -> TWEN_R { TWEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - TWI Write Collition Flag"]
# [inline (always)]
pub fn twwc (& self) -> TWWC_R { TWWC_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - TWI Stop Condition Bit"]
# [inline (always)]
pub fn twsto (& self) -> TWSTO_R { TWSTO_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - TWI Start Condition Bit"]
# [inline (always)]
pub fn twsta (& self) -> TWSTA_R { TWSTA_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TWI Enable Acknowledge Bit"]
# [inline (always)]
pub fn twea (& self) -> TWEA_R { TWEA_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - TWI Interrupt Flag"]
# [inline (always)]
pub fn twint (& self) -> TWINT_R { TWINT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - TWI Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn twie (& mut self) -> TWIE_W < 0 > { TWIE_W :: new (self) } # [doc = "Bit 2 - TWI Enable Bit"]
# [inline (always)]
# [must_use]
pub fn twen (& mut self) -> TWEN_W < 2 > { TWEN_W :: new (self) } # [doc = "Bit 3 - TWI Write Collition Flag"]
# [inline (always)]
# [must_use]
pub fn twwc (& mut self) -> TWWC_W < 3 > { TWWC_W :: new (self) } # [doc = "Bit 4 - TWI Stop Condition Bit"]
# [inline (always)]
# [must_use]
pub fn twsto (& mut self) -> TWSTO_W < 4 > { TWSTO_W :: new (self) } # [doc = "Bit 5 - TWI Start Condition Bit"]
# [inline (always)]
# [must_use]
pub fn twsta (& mut self) -> TWSTA_W < 5 > { TWSTA_W :: new (self) } # [doc = "Bit 6 - TWI Enable Acknowledge Bit"]
# [inline (always)]
# [must_use]
pub fn twea (& mut self) -> TWEA_W < 6 > { TWEA_W :: new (self) } # [doc = "Bit 7 - TWI Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn twint (& mut self) -> TWINT_W < 7 > { TWINT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twcr](index.html) module"]
pub struct TWCR_SPEC ; impl crate :: RegisterSpec for TWCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twcr::R](R) reader structure"]
impl crate :: Readable for TWCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twcr::W](W) writer structure"]
impl crate :: Writable for TWCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWCR to value 0"]
impl crate :: Resettable for TWCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWDR (rw) register accessor: an alias for `Reg<TWDR_SPEC>`"]
pub type TWDR = crate :: Reg < twdr :: TWDR_SPEC > ; # [doc = "TWI Data register"]
pub mod twdr { # [doc = "Register `TWDR` reader"]
pub struct R (crate :: R < TWDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWDR` writer"]
pub struct W (crate :: W < TWDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWDR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "TWI Data register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twdr](index.html) module"]
pub struct TWDR_SPEC ; impl crate :: RegisterSpec for TWDR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twdr::R](R) reader structure"]
impl crate :: Readable for TWDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twdr::W](W) writer structure"]
impl crate :: Writable for TWDR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWDR to value 0"]
impl crate :: Resettable for TWDR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TWSR (rw) register accessor: an alias for `Reg<TWSR_SPEC>`"]
pub type TWSR = crate :: Reg < twsr :: TWSR_SPEC > ; # [doc = "TWI Status Register"]
pub mod twsr { # [doc = "Register `TWSR` reader"]
pub struct R (crate :: R < TWSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TWSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TWSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TWSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `TWSR` writer"]
pub struct W (crate :: W < TWSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TWSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TWSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TWSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TWPS` reader - TWI Prescaler"]
pub type TWPS_R = crate :: FieldReader < u8 , TWPS_A > ; # [doc = "TWI Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TWPS_A { # [doc = "0: 1"]
VAL_0X00 = 0 , # [doc = "1: 4"]
VAL_0X01 = 1 , # [doc = "2: 16"]
VAL_0X02 = 2 , # [doc = "3: 64"]
VAL_0X03 = 3 , } impl From < TWPS_A > for u8 { # [inline (always)]
fn from (variant : TWPS_A) -> Self { variant as _ } } impl TWPS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TWPS_A { match self . bits { 0 => TWPS_A :: VAL_0X00 , 1 => TWPS_A :: VAL_0X01 , 2 => TWPS_A :: VAL_0X02 , 3 => TWPS_A :: VAL_0X03 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == TWPS_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == TWPS_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == TWPS_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == TWPS_A :: VAL_0X03 } } # [doc = "Field `TWPS` writer - TWI Prescaler"]
pub type TWPS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWSR_SPEC , u8 , TWPS_A , 2 , O > ; impl < 'a , const O : u8 > TWPS_W < 'a , O > { # [doc = "1"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (TWPS_A :: VAL_0X00) } # [doc = "4"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (TWPS_A :: VAL_0X01) } # [doc = "16"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (TWPS_A :: VAL_0X02) } # [doc = "64"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (TWPS_A :: VAL_0X03) } } # [doc = "Field `TWS` reader - TWI Status"]
pub type TWS_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TWS` writer - TWI Status"]
pub type TWS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TWSR_SPEC , u8 , u8 , 5 , O > ; impl R { # [doc = "Bits 0:1 - TWI Prescaler"]
# [inline (always)]
pub fn twps (& self) -> TWPS_R { TWPS_R :: new (self . bits & 3) } # [doc = "Bits 3:7 - TWI Status"]
# [inline (always)]
pub fn tws (& self) -> TWS_R { TWS_R :: new ((self . bits >> 3) & 0x1f) } } impl W { # [doc = "Bits 0:1 - TWI Prescaler"]
# [inline (always)]
# [must_use]
pub fn twps (& mut self) -> TWPS_W < 0 > { TWPS_W :: new (self) } # [doc = "Bits 3:7 - TWI Status"]
# [inline (always)]
# [must_use]
pub fn tws (& mut self) -> TWS_W < 3 > { TWS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [twsr](index.html) module"]
pub struct TWSR_SPEC ; impl crate :: RegisterSpec for TWSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [twsr::R](R) reader structure"]
impl crate :: Readable for TWSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [twsr::W](W) writer structure"]
impl crate :: Writable for TWSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TWSR to value 0"]
impl crate :: Resettable for TWSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "USART"]
pub struct USART0 { _marker : PhantomData < * const () > } unsafe impl Send for USART0 { } impl USART0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart0 :: RegisterBlock = 0xc0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart0 :: RegisterBlock { Self :: PTR } } impl Deref for USART0 { type Target = usart0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USART0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USART0") . finish () } } # [doc = "USART"]
pub mod usart0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - USART Control and Status Register A"]
pub ucsr0a : UCSR0A , # [doc = "0x01 - USART Control and Status Register B"]
pub ucsr0b : UCSR0B , # [doc = "0x02 - USART Control and Status Register C"]
pub ucsr0c : UCSR0C , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - USART Baud Rate Register Bytes"]
pub ubrr0 : UBRR0 , # [doc = "0x06 - USART I/O Data Register"]
pub udr0 : UDR0 , } # [doc = "UBRR0 (rw) register accessor: an alias for `Reg<UBRR0_SPEC>`"]
pub type UBRR0 = crate :: Reg < ubrr0 :: UBRR0_SPEC > ; # [doc = "USART Baud Rate Register Bytes"]
pub mod ubrr0 { # [doc = "Register `UBRR0` reader"]
pub struct R (crate :: R < UBRR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UBRR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UBRR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UBRR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UBRR0` writer"]
pub struct W (crate :: W < UBRR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UBRR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UBRR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UBRR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "USART Baud Rate Register Bytes\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ubrr0](index.html) module"]
pub struct UBRR0_SPEC ; impl crate :: RegisterSpec for UBRR0_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ubrr0::R](R) reader structure"]
impl crate :: Readable for UBRR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ubrr0::W](W) writer structure"]
impl crate :: Writable for UBRR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UBRR0 to value 0"]
impl crate :: Resettable for UBRR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR0A (rw) register accessor: an alias for `Reg<UCSR0A_SPEC>`"]
pub type UCSR0A = crate :: Reg < ucsr0a :: UCSR0A_SPEC > ; # [doc = "USART Control and Status Register A"]
pub mod ucsr0a { # [doc = "Register `UCSR0A` reader"]
pub struct R (crate :: R < UCSR0A_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0A_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0A_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0A` writer"]
pub struct W (crate :: W < UCSR0A_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0A_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0A_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0A_SPEC >) -> Self { W (writer) } } # [doc = "Field `MPCM0` reader - Multi-processor Communication Mode"]
pub type MPCM0_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM0` writer - Multi-processor Communication Mode"]
pub type MPCM0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `U2X0` reader - Double the USART transmission speed"]
pub type U2X0_R = crate :: BitReader < bool > ; # [doc = "Field `U2X0` writer - Double the USART transmission speed"]
pub type U2X0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `UPE0` reader - Parity Error"]
pub type UPE0_R = crate :: BitReader < bool > ; # [doc = "Field `UPE0` writer - Parity Error"]
pub type UPE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `DOR0` reader - Data overRun"]
pub type DOR0_R = crate :: BitReader < bool > ; # [doc = "Field `DOR0` writer - Data overRun"]
pub type DOR0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `FE0` reader - Framing Error"]
pub type FE0_R = crate :: BitReader < bool > ; # [doc = "Field `FE0` writer - Framing Error"]
pub type FE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `UDRE0` reader - USART Data Register Empty"]
pub type UDRE0_R = crate :: BitReader < bool > ; # [doc = "Field `UDRE0` writer - USART Data Register Empty"]
pub type UDRE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `TXC0` reader - USART Transmitt Complete"]
pub type TXC0_R = crate :: BitReader < bool > ; # [doc = "Field `TXC0` writer - USART Transmitt Complete"]
pub type TXC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; # [doc = "Field `RXC0` reader - USART Receive Complete"]
pub type RXC0_R = crate :: BitReader < bool > ; # [doc = "Field `RXC0` writer - USART Receive Complete"]
pub type RXC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0A_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm0 (& self) -> MPCM0_R { MPCM0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Double the USART transmission speed"]
# [inline (always)]
pub fn u2x0 (& self) -> U2X0_R { U2X0_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn upe0 (& self) -> UPE0_R { UPE0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Data overRun"]
# [inline (always)]
pub fn dor0 (& self) -> DOR0_R { DOR0_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Framing Error"]
# [inline (always)]
pub fn fe0 (& self) -> FE0_R { FE0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
pub fn udre0 (& self) -> UDRE0_R { UDRE0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USART Transmitt Complete"]
# [inline (always)]
pub fn txc0 (& self) -> TXC0_R { TXC0_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
pub fn rxc0 (& self) -> RXC0_R { RXC0_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm0 (& mut self) -> MPCM0_W < 0 > { MPCM0_W :: new (self) } # [doc = "Bit 1 - Double the USART transmission speed"]
# [inline (always)]
# [must_use]
pub fn u2x0 (& mut self) -> U2X0_W < 1 > { U2X0_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn upe0 (& mut self) -> UPE0_W < 2 > { UPE0_W :: new (self) } # [doc = "Bit 3 - Data overRun"]
# [inline (always)]
# [must_use]
pub fn dor0 (& mut self) -> DOR0_W < 3 > { DOR0_W :: new (self) } # [doc = "Bit 4 - Framing Error"]
# [inline (always)]
# [must_use]
pub fn fe0 (& mut self) -> FE0_W < 4 > { FE0_W :: new (self) } # [doc = "Bit 5 - USART Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn udre0 (& mut self) -> UDRE0_W < 5 > { UDRE0_W :: new (self) } # [doc = "Bit 6 - USART Transmitt Complete"]
# [inline (always)]
# [must_use]
pub fn txc0 (& mut self) -> TXC0_W < 6 > { TXC0_W :: new (self) } # [doc = "Bit 7 - USART Receive Complete"]
# [inline (always)]
# [must_use]
pub fn rxc0 (& mut self) -> RXC0_W < 7 > { RXC0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Control and Status Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0a](index.html) module"]
pub struct UCSR0A_SPEC ; impl crate :: RegisterSpec for UCSR0A_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0a::R](R) reader structure"]
impl crate :: Readable for UCSR0A_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0a::W](W) writer structure"]
impl crate :: Writable for UCSR0A_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0A to value 0"]
impl crate :: Resettable for UCSR0A_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR0B (rw) register accessor: an alias for `Reg<UCSR0B_SPEC>`"]
pub type UCSR0B = crate :: Reg < ucsr0b :: UCSR0B_SPEC > ; # [doc = "USART Control and Status Register B"]
pub mod ucsr0b { # [doc = "Register `UCSR0B` reader"]
pub struct R (crate :: R < UCSR0B_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0B_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0B_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0B` writer"]
pub struct W (crate :: W < UCSR0B_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0B_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0B_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0B_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB80` reader - Transmit Data Bit 8"]
pub type TXB80_R = crate :: BitReader < bool > ; # [doc = "Field `TXB80` writer - Transmit Data Bit 8"]
pub type TXB80_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `RXB80` reader - Receive Data Bit 8"]
pub type RXB80_R = crate :: BitReader < bool > ; # [doc = "Field `RXB80` writer - Receive Data Bit 8"]
pub type RXB80_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `UCSZ02` reader - Character Size"]
pub type UCSZ02_R = crate :: BitReader < bool > ; # [doc = "Field `UCSZ02` writer - Character Size"]
pub type UCSZ02_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `TXEN0` reader - Transmitter Enable"]
pub type TXEN0_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN0` writer - Transmitter Enable"]
pub type TXEN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `RXEN0` reader - Receiver Enable"]
pub type RXEN0_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN0` writer - Receiver Enable"]
pub type RXEN0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `UDRIE0` reader - USART Data register Empty Interrupt Enable"]
pub type UDRIE0_R = crate :: BitReader < bool > ; # [doc = "Field `UDRIE0` writer - USART Data register Empty Interrupt Enable"]
pub type UDRIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `TXCIE0` reader - TX Complete Interrupt Enable"]
pub type TXCIE0_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIE0` writer - TX Complete Interrupt Enable"]
pub type TXCIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; # [doc = "Field `RXCIE0` reader - RX Complete Interrupt Enable"]
pub type RXCIE0_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIE0` writer - RX Complete Interrupt Enable"]
pub type RXCIE0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0B_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit Data Bit 8"]
# [inline (always)]
pub fn txb80 (& self) -> TXB80_R { TXB80_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Receive Data Bit 8"]
# [inline (always)]
pub fn rxb80 (& self) -> RXB80_R { RXB80_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Character Size"]
# [inline (always)]
pub fn ucsz02 (& self) -> UCSZ02_R { UCSZ02_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen0 (& self) -> TXEN0_R { TXEN0_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen0 (& self) -> RXEN0_R { RXEN0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USART Data register Empty Interrupt Enable"]
# [inline (always)]
pub fn udrie0 (& self) -> UDRIE0_R { UDRIE0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
pub fn txcie0 (& self) -> TXCIE0_R { TXCIE0_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
pub fn rxcie0 (& self) -> RXCIE0_R { RXCIE0_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit Data Bit 8"]
# [inline (always)]
# [must_use]
pub fn txb80 (& mut self) -> TXB80_W < 0 > { TXB80_W :: new (self) } # [doc = "Bit 1 - Receive Data Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb80 (& mut self) -> RXB80_W < 1 > { RXB80_W :: new (self) } # [doc = "Bit 2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn ucsz02 (& mut self) -> UCSZ02_W < 2 > { UCSZ02_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen0 (& mut self) -> TXEN0_W < 3 > { TXEN0_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen0 (& mut self) -> RXEN0_W < 4 > { RXEN0_W :: new (self) } # [doc = "Bit 5 - USART Data register Empty Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn udrie0 (& mut self) -> UDRIE0_W < 5 > { UDRIE0_W :: new (self) } # [doc = "Bit 6 - TX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn txcie0 (& mut self) -> TXCIE0_W < 6 > { TXCIE0_W :: new (self) } # [doc = "Bit 7 - RX Complete Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn rxcie0 (& mut self) -> RXCIE0_W < 7 > { RXCIE0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Control and Status Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0b](index.html) module"]
pub struct UCSR0B_SPEC ; impl crate :: RegisterSpec for UCSR0B_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0b::R](R) reader structure"]
impl crate :: Readable for UCSR0B_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0b::W](W) writer structure"]
impl crate :: Writable for UCSR0B_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0B to value 0"]
impl crate :: Resettable for UCSR0B_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UCSR0C (rw) register accessor: an alias for `Reg<UCSR0C_SPEC>`"]
pub type UCSR0C = crate :: Reg < ucsr0c :: UCSR0C_SPEC > ; # [doc = "USART Control and Status Register C"]
pub mod ucsr0c { # [doc = "Register `UCSR0C` reader"]
pub struct R (crate :: R < UCSR0C_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UCSR0C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UCSR0C_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UCSR0C_SPEC >) -> Self { R (reader) } } # [doc = "Register `UCSR0C` writer"]
pub struct W (crate :: W < UCSR0C_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UCSR0C_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UCSR0C_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UCSR0C_SPEC >) -> Self { W (writer) } } # [doc = "Field `UCPOL0` reader - Clock Polarity"]
pub type UCPOL0_R = crate :: BitReader < bool > ; # [doc = "Field `UCPOL0` writer - Clock Polarity"]
pub type UCPOL0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0C_SPEC , bool , O > ; # [doc = "Field `UCSZ0` reader - Character Size"]
pub type UCSZ0_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `UCSZ0` writer - Character Size"]
pub type UCSZ0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , UCSR0C_SPEC , u8 , u8 , 2 , O > ; # [doc = "Field `USBS0` reader - Stop Bit Select"]
pub type USBS0_R = crate :: BitReader < USBS0_A > ; # [doc = "Stop Bit Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum USBS0_A { # [doc = "0: 1-bit"]
VAL_0X00 = 0 , # [doc = "1: 2-bit"]
VAL_0X01 = 1 , } impl From < USBS0_A > for bool { # [inline (always)]
fn from (variant : USBS0_A) -> Self { variant as u8 != 0 } } impl USBS0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> USBS0_A { match self . bits { false => USBS0_A :: VAL_0X00 , true => USBS0_A :: VAL_0X01 , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == USBS0_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == USBS0_A :: VAL_0X01 } } # [doc = "Field `USBS0` writer - Stop Bit Select"]
pub type USBS0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , UCSR0C_SPEC , USBS0_A , O > ; impl < 'a , const O : u8 > USBS0_W < 'a , O > { # [doc = "1-bit"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (USBS0_A :: VAL_0X00) } # [doc = "2-bit"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (USBS0_A :: VAL_0X01) } } # [doc = "Field `UPM0` reader - Parity Mode Bits"]
pub type UPM0_R = crate :: FieldReader < u8 , UPM0_A > ; # [doc = "Parity Mode Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum UPM0_A { # [doc = "0: Disabled"]
VAL_0X00 = 0 , # [doc = "1: Reserved"]
VAL_0X01 = 1 , # [doc = "2: Enabled, Even Parity"]
VAL_0X02 = 2 , # [doc = "3: Enabled, Odd Parity"]
VAL_0X03 = 3 , } impl From < UPM0_A > for u8 { # [inline (always)]
fn from (variant : UPM0_A) -> Self { variant as _ } } impl UPM0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> UPM0_A { match self . bits { 0 => UPM0_A :: VAL_0X00 , 1 => UPM0_A :: VAL_0X01 , 2 => UPM0_A :: VAL_0X02 , 3 => UPM0_A :: VAL_0X03 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == UPM0_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == UPM0_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == UPM0_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == UPM0_A :: VAL_0X03 } } # [doc = "Field `UPM0` writer - Parity Mode Bits"]
pub type UPM0_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , UCSR0C_SPEC , u8 , UPM0_A , 2 , O > ; impl < 'a , const O : u8 > UPM0_W < 'a , O > { # [doc = "Disabled"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (UPM0_A :: VAL_0X00) } # [doc = "Reserved"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (UPM0_A :: VAL_0X01) } # [doc = "Enabled, Even Parity"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (UPM0_A :: VAL_0X02) } # [doc = "Enabled, Odd Parity"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (UPM0_A :: VAL_0X03) } } # [doc = "Field `UMSEL0` reader - USART Mode Select"]
pub type UMSEL0_R = crate :: FieldReader < u8 , UMSEL0_A > ; # [doc = "USART Mode Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum UMSEL0_A { # [doc = "0: Asynchronous USART"]
VAL_0X00 = 0 , # [doc = "1: Synchronous USART"]
VAL_0X01 = 1 , # [doc = "3: Master SPI"]
VAL_0X03 = 3 , } impl From < UMSEL0_A > for u8 { # [inline (always)]
fn from (variant : UMSEL0_A) -> Self { variant as _ } } impl UMSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < UMSEL0_A > { match self . bits { 0 => Some (UMSEL0_A :: VAL_0X00) , 1 => Some (UMSEL0_A :: VAL_0X01) , 3 => Some (UMSEL0_A :: VAL_0X03) , _ => None , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == UMSEL0_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == UMSEL0_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == UMSEL0_A :: VAL_0X03 } } # [doc = "Field `UMSEL0` writer - USART Mode Select"]
pub type UMSEL0_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , UCSR0C_SPEC , u8 , UMSEL0_A , 2 , O > ; impl < 'a , const O : u8 > UMSEL0_W < 'a , O > { # [doc = "Asynchronous USART"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (UMSEL0_A :: VAL_0X00) } # [doc = "Synchronous USART"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (UMSEL0_A :: VAL_0X01) } # [doc = "Master SPI"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (UMSEL0_A :: VAL_0X03) } } impl R { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
pub fn ucpol0 (& self) -> UCPOL0_R { UCPOL0_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Character Size"]
# [inline (always)]
pub fn ucsz0 (& self) -> UCSZ0_R { UCSZ0_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Stop Bit Select"]
# [inline (always)]
pub fn usbs0 (& self) -> USBS0_R { USBS0_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode Bits"]
# [inline (always)]
pub fn upm0 (& self) -> UPM0_R { UPM0_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - USART Mode Select"]
# [inline (always)]
pub fn umsel0 (& self) -> UMSEL0_R { UMSEL0_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Clock Polarity"]
# [inline (always)]
# [must_use]
pub fn ucpol0 (& mut self) -> UCPOL0_W < 0 > { UCPOL0_W :: new (self) } # [doc = "Bits 1:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn ucsz0 (& mut self) -> UCSZ0_W < 1 > { UCSZ0_W :: new (self) } # [doc = "Bit 3 - Stop Bit Select"]
# [inline (always)]
# [must_use]
pub fn usbs0 (& mut self) -> USBS0_W < 3 > { USBS0_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode Bits"]
# [inline (always)]
# [must_use]
pub fn upm0 (& mut self) -> UPM0_W < 4 > { UPM0_W :: new (self) } # [doc = "Bits 6:7 - USART Mode Select"]
# [inline (always)]
# [must_use]
pub fn umsel0 (& mut self) -> UMSEL0_W < 6 > { UMSEL0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Control and Status Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucsr0c](index.html) module"]
pub struct UCSR0C_SPEC ; impl crate :: RegisterSpec for UCSR0C_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ucsr0c::R](R) reader structure"]
impl crate :: Readable for UCSR0C_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ucsr0c::W](W) writer structure"]
impl crate :: Writable for UCSR0C_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UCSR0C to value 0"]
impl crate :: Resettable for UCSR0C_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "UDR0 (rw) register accessor: an alias for `Reg<UDR0_SPEC>`"]
pub type UDR0 = crate :: Reg < udr0 :: UDR0_SPEC > ; # [doc = "USART I/O Data Register"]
pub mod udr0 { # [doc = "Register `UDR0` reader"]
pub struct R (crate :: R < UDR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < UDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < UDR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < UDR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `UDR0` writer"]
pub struct W (crate :: W < UDR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < UDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < UDR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < UDR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "USART I/O Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [udr0](index.html) module"]
pub struct UDR0_SPEC ; impl crate :: RegisterSpec for UDR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [udr0::R](R) reader structure"]
impl crate :: Readable for UDR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [udr0::W](W) writer structure"]
impl crate :: Writable for UDR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets UDR0 to value 0"]
impl crate :: Resettable for UDR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Watchdog Timer"]
pub struct WDT { _marker : PhantomData < * const () > } unsafe impl Send for WDT { } impl WDT { # [doc = r"Pointer to the register block"]
pub const PTR : * const wdt :: RegisterBlock = 0x60 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wdt :: RegisterBlock { Self :: PTR } } impl Deref for WDT { type Target = wdt :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WDT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WDT") . finish () } } # [doc = "Watchdog Timer"]
pub mod wdt { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Watchdog Timer Control Register"]
pub wdtcsr : WDTCSR , } # [doc = "WDTCSR (rw) register accessor: an alias for `Reg<WDTCSR_SPEC>`"]
pub type WDTCSR = crate :: Reg < wdtcsr :: WDTCSR_SPEC > ; # [doc = "Watchdog Timer Control Register"]
pub mod wdtcsr { # [doc = "Register `WDTCSR` reader"]
pub struct R (crate :: R < WDTCSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WDTCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WDTCSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WDTCSR_SPEC >) -> Self { R (reader) } } # [doc = "Register `WDTCSR` writer"]
pub struct W (crate :: W < WDTCSR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WDTCSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WDTCSR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WDTCSR_SPEC >) -> Self { W (writer) } } # [doc = "Field `WDP` reader - Watchdog Timer Prescaler Bits"]
pub type WDP_R = crate :: FieldReader < u8 , WDP_A > ; # [doc = "Watchdog Timer Prescaler Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WDP_A { # [doc = "0: Oscillator Cycles 2K"]
VAL_0X00 = 0 , # [doc = "1: Oscillator Cycles 4K"]
VAL_0X01 = 1 , # [doc = "2: Oscillator Cycles 8K"]
VAL_0X02 = 2 , # [doc = "3: Oscillator Cycles 16K"]
VAL_0X03 = 3 , # [doc = "4: Oscillator Cycles 32K"]
VAL_0X04 = 4 , # [doc = "5: Oscillator Cycles 64K"]
VAL_0X05 = 5 , # [doc = "6: Oscillator Cycles 128K"]
VAL_0X06 = 6 , # [doc = "7: Oscillator Cycles 256K"]
VAL_0X07 = 7 , } impl From < WDP_A > for u8 { # [inline (always)]
fn from (variant : WDP_A) -> Self { variant as _ } } impl WDP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WDP_A > { match self . bits { 0 => Some (WDP_A :: VAL_0X00) , 1 => Some (WDP_A :: VAL_0X01) , 2 => Some (WDP_A :: VAL_0X02) , 3 => Some (WDP_A :: VAL_0X03) , 4 => Some (WDP_A :: VAL_0X04) , 5 => Some (WDP_A :: VAL_0X05) , 6 => Some (WDP_A :: VAL_0X06) , 7 => Some (WDP_A :: VAL_0X07) , _ => None , } } # [doc = "Checks if the value of the field is `VAL_0X00`"]
# [inline (always)]
pub fn is_val_0x00 (& self) -> bool { * self == WDP_A :: VAL_0X00 } # [doc = "Checks if the value of the field is `VAL_0X01`"]
# [inline (always)]
pub fn is_val_0x01 (& self) -> bool { * self == WDP_A :: VAL_0X01 } # [doc = "Checks if the value of the field is `VAL_0X02`"]
# [inline (always)]
pub fn is_val_0x02 (& self) -> bool { * self == WDP_A :: VAL_0X02 } # [doc = "Checks if the value of the field is `VAL_0X03`"]
# [inline (always)]
pub fn is_val_0x03 (& self) -> bool { * self == WDP_A :: VAL_0X03 } # [doc = "Checks if the value of the field is `VAL_0X04`"]
# [inline (always)]
pub fn is_val_0x04 (& self) -> bool { * self == WDP_A :: VAL_0X04 } # [doc = "Checks if the value of the field is `VAL_0X05`"]
# [inline (always)]
pub fn is_val_0x05 (& self) -> bool { * self == WDP_A :: VAL_0X05 } # [doc = "Checks if the value of the field is `VAL_0X06`"]
# [inline (always)]
pub fn is_val_0x06 (& self) -> bool { * self == WDP_A :: VAL_0X06 } # [doc = "Checks if the value of the field is `VAL_0X07`"]
# [inline (always)]
pub fn is_val_0x07 (& self) -> bool { * self == WDP_A :: VAL_0X07 } } # [doc = "Field `WDP` writer - Watchdog Timer Prescaler Bits"]
pub type WDP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , WDTCSR_SPEC , u8 , WDP_A , 6 , O > ; impl < 'a , const O : u8 > WDP_W < 'a , O > { # [doc = "Oscillator Cycles 2K"]
# [inline (always)]
pub fn val_0x00 (self) -> & 'a mut W { self . variant (WDP_A :: VAL_0X00) } # [doc = "Oscillator Cycles 4K"]
# [inline (always)]
pub fn val_0x01 (self) -> & 'a mut W { self . variant (WDP_A :: VAL_0X01) } # [doc = "Oscillator Cycles 8K"]
# [inline (always)]
pub fn val_0x02 (self) -> & 'a mut W { self . variant (WDP_A :: VAL_0X02) } # [doc = "Oscillator Cycles 16K"]
# [inline (always)]
pub fn val_0x03 (self) -> & 'a mut W { self . variant (WDP_A :: VAL_0X03) } # [doc = "Oscillator Cycles 32K"]
# [inline (always)]
pub fn val_0x04 (self) -> & 'a mut W { self . variant (WDP_A :: VAL_0X04) } # [doc = "Oscillator Cycles 64K"]
# [inline (always)]
pub fn val_0x05 (self) -> & 'a mut W { self . variant (WDP_A :: VAL_0X05) } # [doc = "Oscillator Cycles 128K"]
# [inline (always)]
pub fn val_0x06 (self) -> & 'a mut W { self . variant (WDP_A :: VAL_0X06) } # [doc = "Oscillator Cycles 256K"]
# [inline (always)]
pub fn val_0x07 (self) -> & 'a mut W { self . variant (WDP_A :: VAL_0X07) } } # [doc = "Field `WDE` reader - Watch Dog Enable"]
pub type WDE_R = crate :: BitReader < bool > ; # [doc = "Field `WDE` writer - Watch Dog Enable"]
pub type WDE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WDTCSR_SPEC , bool , O > ; # [doc = "Field `WDCE` reader - Watchdog Change Enable"]
pub type WDCE_R = crate :: BitReader < bool > ; # [doc = "Field `WDCE` writer - Watchdog Change Enable"]
pub type WDCE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WDTCSR_SPEC , bool , O > ; # [doc = "Field `WDIE` reader - Watchdog Timeout Interrupt Enable"]
pub type WDIE_R = crate :: BitReader < bool > ; # [doc = "Field `WDIE` writer - Watchdog Timeout Interrupt Enable"]
pub type WDIE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WDTCSR_SPEC , bool , O > ; # [doc = "Field `WDIF` reader - Watchdog Timeout Interrupt Flag"]
pub type WDIF_R = crate :: BitReader < bool > ; # [doc = "Field `WDIF` writer - Watchdog Timeout Interrupt Flag"]
pub type WDIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WDTCSR_SPEC , bool , O > ; impl R { # [doc = "Bits 0:5 - Watchdog Timer Prescaler Bits"]
# [inline (always)]
pub fn wdp (& self) -> WDP_R { WDP_R :: new (self . bits & 0x3f) } # [doc = "Bit 3 - Watch Dog Enable"]
# [inline (always)]
pub fn wde (& self) -> WDE_R { WDE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Watchdog Change Enable"]
# [inline (always)]
pub fn wdce (& self) -> WDCE_R { WDCE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Watchdog Timeout Interrupt Enable"]
# [inline (always)]
pub fn wdie (& self) -> WDIE_R { WDIE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Watchdog Timeout Interrupt Flag"]
# [inline (always)]
pub fn wdif (& self) -> WDIF_R { WDIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - Watchdog Timer Prescaler Bits"]
# [inline (always)]
# [must_use]
pub fn wdp (& mut self) -> WDP_W < 0 > { WDP_W :: new (self) } # [doc = "Bit 3 - Watch Dog Enable"]
# [inline (always)]
# [must_use]
pub fn wde (& mut self) -> WDE_W < 3 > { WDE_W :: new (self) } # [doc = "Bit 4 - Watchdog Change Enable"]
# [inline (always)]
# [must_use]
pub fn wdce (& mut self) -> WDCE_W < 4 > { WDCE_W :: new (self) } # [doc = "Bit 6 - Watchdog Timeout Interrupt Enable"]
# [inline (always)]
# [must_use]
pub fn wdie (& mut self) -> WDIE_W < 6 > { WDIE_W :: new (self) } # [doc = "Bit 7 - Watchdog Timeout Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn wdif (& mut self) -> WDIF_W < 7 > { WDIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Watchdog Timer Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wdtcsr](index.html) module"]
pub struct WDTCSR_SPEC ; impl crate :: RegisterSpec for WDTCSR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [wdtcsr::R](R) reader structure"]
impl crate :: Readable for WDTCSR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wdtcsr::W](W) writer structure"]
impl crate :: Writable for WDTCSR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WDTCSR to value 0"]
impl crate :: Resettable for WDTCSR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "AC"]
pub AC : AC , # [doc = "ADC"]
pub ADC : ADC , # [doc = "CPU"]
pub CPU : CPU , # [doc = "EEPROM"]
pub EEPROM : EEPROM , # [doc = "EXINT"]
pub EXINT : EXINT , # [doc = "FUSE"]
pub FUSE : FUSE , # [doc = "LOCKBIT"]
pub LOCKBIT : LOCKBIT , # [doc = "PORTB"]
pub PORTB : PORTB , # [doc = "PORTC"]
pub PORTC : PORTC , # [doc = "PORTD"]
pub PORTD : PORTD , # [doc = "SPI"]
pub SPI : SPI , # [doc = "TC0"]
pub TC0 : TC0 , # [doc = "TC1"]
pub TC1 : TC1 , # [doc = "TC2"]
pub TC2 : TC2 , # [doc = "TWI"]
pub TWI : TWI , # [doc = "USART0"]
pub USART0 : USART0 , # [doc = "WDT"]
pub WDT : WDT , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { AC : AC { _marker : PhantomData } , ADC : ADC { _marker : PhantomData } , CPU : CPU { _marker : PhantomData } , EEPROM : EEPROM { _marker : PhantomData } , EXINT : EXINT { _marker : PhantomData } , FUSE : FUSE { _marker : PhantomData } , LOCKBIT : LOCKBIT { _marker : PhantomData } , PORTB : PORTB { _marker : PhantomData } , PORTC : PORTC { _marker : PhantomData } , PORTD : PORTD { _marker : PhantomData } , SPI : SPI { _marker : PhantomData } , TC0 : TC0 { _marker : PhantomData } , TC1 : TC1 { _marker : PhantomData } , TC2 : TC2 { _marker : PhantomData } , TWI : TWI { _marker : PhantomData } , USART0 : USART0 { _marker : PhantomData } , WDT : WDT { _marker : PhantomData } , } } }