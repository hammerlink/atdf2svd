# ! [doc = "Peripheral access API for ATXMEGA128A1 microcontrollers (generated using svd2rust v0.28.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS : u8 = 4 ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."]
type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."]
type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > , { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > , { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Read datasheet or reference manual to find what values are allowed to pass."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc (hidden)]
pub struct FieldReaderRaw < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , FI > FieldReaderRaw < U , FI > where U : Copy , { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitReaderRaw < T > { pub (crate) bits : bool , _reg : marker :: PhantomData < T > , } impl < FI > BitReaderRaw < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < U , FI > = FieldReaderRaw < U , FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI > = BitReaderRaw < FI > ; impl < U , FI > FieldReader < U , FI > where U : Copy , { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , FI > PartialEq < FI > for FieldReader < U , FI > where U : PartialEq , FI : Copy , U : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& U :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc (hidden)]
pub struct FieldWriterRaw < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (N , FI , Safety) > , } impl < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > FieldWriterRaw < 'a , U , REG , N , FI , Safety , WI , O > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitWriterRaw < 'a , U , REG , FI , M , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , U , REG , FI , M , const O : u8 > BitWriterRaw < 'a , U , REG , FI , M , O > where REG : Writable + RegisterSpec < Ux = U > , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Unsafe , WI , O > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Safe , WI , O > ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , N : From < FI > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , U , REG , FI , const O : u8 > = BitWriterRaw <'a , U , REG , FI , $ mwv , O >; impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; } } ; } macro_rules ! impl_bit_proxy { ($ writer : ident) => { impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, U : RawReg , bool : From < FI >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w . bits |= (U :: from (value) & U :: one ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { unsafe { self . bits (N :: from (variant)) } } } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg + From < N > , N : From < FI > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : N) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: mask :: < WI > () << OF) ; self . w . bits |= (U :: from (value) & U :: mask :: < WI > ()) << OF ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut REG :: Writer { self . bits (N :: from (variant)) } } impl_bit_proxy ! (BitWriter) ; impl_bit_proxy ! (BitWriter1S) ; impl_bit_proxy ! (BitWriter0C) ; impl_bit_proxy ! (BitWriter1C) ; impl_bit_proxy ! (BitWriter0S) ; impl_bit_proxy ! (BitWriter1T) ; impl_bit_proxy ! (BitWriter0T) ; impl < 'a , U , REG , FI , const OF : u8 > BitWriter < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1C < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0S < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter1T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits |= U :: one () << OF ; self . w } } impl < 'a , U , REG , FI , const OF : u8 > BitWriter0T < 'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U > , U : RawReg , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut REG :: Writer { self . w . bits &= ! (U :: one () << OF) ; self . w } } } # [doc = "Analog Comparator"]
pub struct ACA { _marker : PhantomData < * const () > } unsafe impl Send for ACA { } impl ACA { # [doc = r"Pointer to the register block"]
pub const PTR : * const aca :: RegisterBlock = 0x0380 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const aca :: RegisterBlock { Self :: PTR } } impl Deref for ACA { type Target = aca :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ACA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ACA") . finish () } } # [doc = "Analog Comparator"]
pub mod aca { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Analog Comparator 0 Control"]
pub ac0ctrl : AC0CTRL , # [doc = "0x01 - Analog Comparator 1 Control"]
pub ac1ctrl : AC1CTRL , # [doc = "0x02 - Analog Comparator 0 MUX Control"]
pub ac0muxctrl : AC0MUXCTRL , # [doc = "0x03 - Analog Comparator 1 MUX Control"]
pub ac1muxctrl : AC1MUXCTRL , # [doc = "0x04 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x05 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x06 - Window Mode Control"]
pub winctrl : WINCTRL , # [doc = "0x07 - Status"]
pub status : STATUS , } # [doc = "AC0CTRL (rw) register accessor: an alias for `Reg<AC0CTRL_SPEC>`"]
pub type AC0CTRL = crate :: Reg < ac0ctrl :: AC0CTRL_SPEC > ; # [doc = "Analog Comparator 0 Control"]
pub mod ac0ctrl { # [doc = "Register `AC0CTRL` reader"]
pub struct R (crate :: R < AC0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AC0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AC0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AC0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AC0CTRL` writer"]
pub struct W (crate :: W < AC0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AC0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AC0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AC0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AC0CTRL_SPEC , bool , O > ; # [doc = "Field `HYSMODE` reader - Hysteresis Mode"]
pub type HYSMODE_R = crate :: FieldReader < u8 , HYSMODE_A > ; # [doc = "Hysteresis Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HYSMODE_A { # [doc = "0: No hysteresis"]
NO = 0 , # [doc = "1: Small hysteresis"]
SMALL = 1 , # [doc = "2: Large hysteresis"]
LARGE = 2 , } impl From < HYSMODE_A > for u8 { # [inline (always)]
fn from (variant : HYSMODE_A) -> Self { variant as _ } } impl HYSMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < HYSMODE_A > { match self . bits { 0 => Some (HYSMODE_A :: NO) , 1 => Some (HYSMODE_A :: SMALL) , 2 => Some (HYSMODE_A :: LARGE) , _ => None , } } # [doc = "Checks if the value of the field is `NO`"]
# [inline (always)]
pub fn is_no (& self) -> bool { * self == HYSMODE_A :: NO } # [doc = "Checks if the value of the field is `SMALL`"]
# [inline (always)]
pub fn is_small (& self) -> bool { * self == HYSMODE_A :: SMALL } # [doc = "Checks if the value of the field is `LARGE`"]
# [inline (always)]
pub fn is_large (& self) -> bool { * self == HYSMODE_A :: LARGE } } # [doc = "Field `HYSMODE` writer - Hysteresis Mode"]
pub type HYSMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , AC0CTRL_SPEC , u8 , HYSMODE_A , 2 , O > ; impl < 'a , const O : u8 > HYSMODE_W < 'a , O > { # [doc = "No hysteresis"]
# [inline (always)]
pub fn no (self) -> & 'a mut W { self . variant (HYSMODE_A :: NO) } # [doc = "Small hysteresis"]
# [inline (always)]
pub fn small (self) -> & 'a mut W { self . variant (HYSMODE_A :: SMALL) } # [doc = "Large hysteresis"]
# [inline (always)]
pub fn large (self) -> & 'a mut W { self . variant (HYSMODE_A :: LARGE) } } # [doc = "Field `HSMODE` reader - High-speed Mode"]
pub type HSMODE_R = crate :: BitReader < bool > ; # [doc = "Field `HSMODE` writer - High-speed Mode"]
pub type HSMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AC0CTRL_SPEC , bool , O > ; # [doc = "Field `INTLVL` reader - Interrupt Level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt disabled"]
OFF = 0 , # [doc = "1: Low level"]
LO = 1 , # [doc = "2: Medium level"]
MED = 2 , # [doc = "3: High level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt Level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC0CTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } # [doc = "Field `INTMODE` reader - Interrupt Mode"]
pub type INTMODE_R = crate :: FieldReader < u8 , INTMODE_A > ; # [doc = "Interrupt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE_A { # [doc = "0: Interrupt on both edges"]
BOTHEDGES = 0 , # [doc = "2: Interrupt on falling edge"]
FALLING = 2 , # [doc = "3: Interrupt on rising edge"]
RISING = 3 , } impl From < INTMODE_A > for u8 { # [inline (always)]
fn from (variant : INTMODE_A) -> Self { variant as _ } } impl INTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INTMODE_A > { match self . bits { 0 => Some (INTMODE_A :: BOTHEDGES) , 2 => Some (INTMODE_A :: FALLING) , 3 => Some (INTMODE_A :: RISING) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == INTMODE_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTMODE_A :: FALLING } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTMODE_A :: RISING } } # [doc = "Field `INTMODE` writer - Interrupt Mode"]
pub type INTMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , AC0CTRL_SPEC , u8 , INTMODE_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE_W < 'a , O > { # [doc = "Interrupt on both edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (INTMODE_A :: BOTHEDGES) } # [doc = "Interrupt on falling edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTMODE_A :: FALLING) } # [doc = "Interrupt on rising edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTMODE_A :: RISING) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
pub fn hysmode (& self) -> HYSMODE_R { HYSMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - High-speed Mode"]
# [inline (always)]
pub fn hsmode (& self) -> HSMODE_R { HSMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Interrupt Level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Interrupt Mode"]
# [inline (always)]
pub fn intmode (& self) -> INTMODE_R { INTMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
# [must_use]
pub fn hysmode (& mut self) -> HYSMODE_W < 1 > { HYSMODE_W :: new (self) } # [doc = "Bit 3 - High-speed Mode"]
# [inline (always)]
# [must_use]
pub fn hsmode (& mut self) -> HSMODE_W < 3 > { HSMODE_W :: new (self) } # [doc = "Bits 4:5 - Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 4 > { INTLVL_W :: new (self) } # [doc = "Bits 6:7 - Interrupt Mode"]
# [inline (always)]
# [must_use]
pub fn intmode (& mut self) -> INTMODE_W < 6 > { INTMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ac0ctrl](index.html) module"]
pub struct AC0CTRL_SPEC ; impl crate :: RegisterSpec for AC0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ac0ctrl::R](R) reader structure"]
impl crate :: Readable for AC0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ac0ctrl::W](W) writer structure"]
impl crate :: Writable for AC0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AC0CTRL to value 0"]
impl crate :: Resettable for AC0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AC0MUXCTRL (rw) register accessor: an alias for `Reg<AC0MUXCTRL_SPEC>`"]
pub type AC0MUXCTRL = crate :: Reg < ac0muxctrl :: AC0MUXCTRL_SPEC > ; # [doc = "Analog Comparator 0 MUX Control"]
pub mod ac0muxctrl { # [doc = "Register `AC0MUXCTRL` reader"]
pub struct R (crate :: R < AC0MUXCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AC0MUXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AC0MUXCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AC0MUXCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AC0MUXCTRL` writer"]
pub struct W (crate :: W < AC0MUXCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AC0MUXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AC0MUXCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AC0MUXCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUXNEG` reader - MUX Negative Input"]
pub type MUXNEG_R = crate :: FieldReader < u8 , MUXNEG_A > ; # [doc = "MUX Negative Input\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXNEG_A { # [doc = "0: Pin 0"]
PIN0 = 0 , # [doc = "1: Pin 1"]
PIN1 = 1 , # [doc = "2: Pin 3"]
PIN3 = 2 , # [doc = "3: Pin 5"]
PIN5 = 3 , # [doc = "4: Pin 7"]
PIN7 = 4 , # [doc = "5: DAC output"]
DAC = 5 , # [doc = "6: Bandgap Reference"]
BANDGAP = 6 , # [doc = "7: Internal voltage scaler"]
SCALER = 7 , } impl From < MUXNEG_A > for u8 { # [inline (always)]
fn from (variant : MUXNEG_A) -> Self { variant as _ } } impl MUXNEG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXNEG_A { match self . bits { 0 => MUXNEG_A :: PIN0 , 1 => MUXNEG_A :: PIN1 , 2 => MUXNEG_A :: PIN3 , 3 => MUXNEG_A :: PIN5 , 4 => MUXNEG_A :: PIN7 , 5 => MUXNEG_A :: DAC , 6 => MUXNEG_A :: BANDGAP , 7 => MUXNEG_A :: SCALER , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXNEG_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXNEG_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXNEG_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXNEG_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN7`"]
# [inline (always)]
pub fn is_pin7 (& self) -> bool { * self == MUXNEG_A :: PIN7 } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXNEG_A :: DAC } # [doc = "Checks if the value of the field is `BANDGAP`"]
# [inline (always)]
pub fn is_bandgap (& self) -> bool { * self == MUXNEG_A :: BANDGAP } # [doc = "Checks if the value of the field is `SCALER`"]
# [inline (always)]
pub fn is_scaler (& self) -> bool { * self == MUXNEG_A :: SCALER } } # [doc = "Field `MUXNEG` writer - MUX Negative Input"]
pub type MUXNEG_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC0MUXCTRL_SPEC , u8 , MUXNEG_A , 3 , O > ; impl < 'a , const O : u8 > MUXNEG_W < 'a , O > { # [doc = "Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN0) } # [doc = "Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN1) } # [doc = "Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN3) } # [doc = "Pin 5"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN5) } # [doc = "Pin 7"]
# [inline (always)]
pub fn pin7 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN7) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXNEG_A :: DAC) } # [doc = "Bandgap Reference"]
# [inline (always)]
pub fn bandgap (self) -> & 'a mut W { self . variant (MUXNEG_A :: BANDGAP) } # [doc = "Internal voltage scaler"]
# [inline (always)]
pub fn scaler (self) -> & 'a mut W { self . variant (MUXNEG_A :: SCALER) } } # [doc = "Field `MUXPOS` reader - MUX Positive Input"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; # [doc = "MUX Positive Input\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: Pin 0"]
PIN0 = 0 , # [doc = "1: Pin 1"]
PIN1 = 1 , # [doc = "2: Pin 2"]
PIN2 = 2 , # [doc = "3: Pin 3"]
PIN3 = 3 , # [doc = "4: Pin 4"]
PIN4 = 4 , # [doc = "5: Pin 5"]
PIN5 = 5 , # [doc = "6: Pin 6"]
PIN6 = 6 , # [doc = "7: DAC output"]
DAC = 7 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXPOS_A { match self . bits { 0 => MUXPOS_A :: PIN0 , 1 => MUXPOS_A :: PIN1 , 2 => MUXPOS_A :: PIN2 , 3 => MUXPOS_A :: PIN3 , 4 => MUXPOS_A :: PIN4 , 5 => MUXPOS_A :: PIN5 , 6 => MUXPOS_A :: PIN6 , 7 => MUXPOS_A :: DAC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXPOS_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXPOS_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXPOS_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXPOS_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN4`"]
# [inline (always)]
pub fn is_pin4 (& self) -> bool { * self == MUXPOS_A :: PIN4 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXPOS_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN6`"]
# [inline (always)]
pub fn is_pin6 (& self) -> bool { * self == MUXPOS_A :: PIN6 } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXPOS_A :: DAC } } # [doc = "Field `MUXPOS` writer - MUX Positive Input"]
pub type MUXPOS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC0MUXCTRL_SPEC , u8 , MUXPOS_A , 3 , O > ; impl < 'a , const O : u8 > MUXPOS_W < 'a , O > { # [doc = "Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN0) } # [doc = "Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN1) } # [doc = "Pin 2"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN2) } # [doc = "Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN3) } # [doc = "Pin 4"]
# [inline (always)]
pub fn pin4 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN4) } # [doc = "Pin 5"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN5) } # [doc = "Pin 6"]
# [inline (always)]
pub fn pin6 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN6) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXPOS_A :: DAC) } } impl R { # [doc = "Bits 0:2 - MUX Negative Input"]
# [inline (always)]
pub fn muxneg (& self) -> MUXNEG_R { MUXNEG_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - MUX Positive Input"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new ((self . bits >> 3) & 7) } } impl W { # [doc = "Bits 0:2 - MUX Negative Input"]
# [inline (always)]
# [must_use]
pub fn muxneg (& mut self) -> MUXNEG_W < 0 > { MUXNEG_W :: new (self) } # [doc = "Bits 3:5 - MUX Positive Input"]
# [inline (always)]
# [must_use]
pub fn muxpos (& mut self) -> MUXPOS_W < 3 > { MUXPOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator 0 MUX Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ac0muxctrl](index.html) module"]
pub struct AC0MUXCTRL_SPEC ; impl crate :: RegisterSpec for AC0MUXCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ac0muxctrl::R](R) reader structure"]
impl crate :: Readable for AC0MUXCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ac0muxctrl::W](W) writer structure"]
impl crate :: Writable for AC0MUXCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AC0MUXCTRL to value 0"]
impl crate :: Resettable for AC0MUXCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AC1CTRL (rw) register accessor: an alias for `Reg<AC1CTRL_SPEC>`"]
pub type AC1CTRL = crate :: Reg < ac1ctrl :: AC1CTRL_SPEC > ; # [doc = "Analog Comparator 1 Control"]
pub mod ac1ctrl { # [doc = "Register `AC1CTRL` reader"]
pub struct R (crate :: R < AC1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AC1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AC1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AC1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AC1CTRL` writer"]
pub struct W (crate :: W < AC1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AC1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AC1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AC1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AC1CTRL_SPEC , bool , O > ; # [doc = "Field `HYSMODE` reader - Hysteresis Mode"]
pub type HYSMODE_R = crate :: FieldReader < u8 , HYSMODE_A > ; # [doc = "Hysteresis Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HYSMODE_A { # [doc = "0: No hysteresis"]
NO = 0 , # [doc = "1: Small hysteresis"]
SMALL = 1 , # [doc = "2: Large hysteresis"]
LARGE = 2 , } impl From < HYSMODE_A > for u8 { # [inline (always)]
fn from (variant : HYSMODE_A) -> Self { variant as _ } } impl HYSMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < HYSMODE_A > { match self . bits { 0 => Some (HYSMODE_A :: NO) , 1 => Some (HYSMODE_A :: SMALL) , 2 => Some (HYSMODE_A :: LARGE) , _ => None , } } # [doc = "Checks if the value of the field is `NO`"]
# [inline (always)]
pub fn is_no (& self) -> bool { * self == HYSMODE_A :: NO } # [doc = "Checks if the value of the field is `SMALL`"]
# [inline (always)]
pub fn is_small (& self) -> bool { * self == HYSMODE_A :: SMALL } # [doc = "Checks if the value of the field is `LARGE`"]
# [inline (always)]
pub fn is_large (& self) -> bool { * self == HYSMODE_A :: LARGE } } # [doc = "Field `HYSMODE` writer - Hysteresis Mode"]
pub type HYSMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , AC1CTRL_SPEC , u8 , HYSMODE_A , 2 , O > ; impl < 'a , const O : u8 > HYSMODE_W < 'a , O > { # [doc = "No hysteresis"]
# [inline (always)]
pub fn no (self) -> & 'a mut W { self . variant (HYSMODE_A :: NO) } # [doc = "Small hysteresis"]
# [inline (always)]
pub fn small (self) -> & 'a mut W { self . variant (HYSMODE_A :: SMALL) } # [doc = "Large hysteresis"]
# [inline (always)]
pub fn large (self) -> & 'a mut W { self . variant (HYSMODE_A :: LARGE) } } # [doc = "Field `HSMODE` reader - High-speed Mode"]
pub type HSMODE_R = crate :: BitReader < bool > ; # [doc = "Field `HSMODE` writer - High-speed Mode"]
pub type HSMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AC1CTRL_SPEC , bool , O > ; # [doc = "Field `INTLVL` reader - Interrupt Level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt disabled"]
OFF = 0 , # [doc = "1: Low level"]
LO = 1 , # [doc = "2: Medium level"]
MED = 2 , # [doc = "3: High level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt Level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC1CTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } # [doc = "Field `INTMODE` reader - Interrupt Mode"]
pub type INTMODE_R = crate :: FieldReader < u8 , INTMODE_A > ; # [doc = "Interrupt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE_A { # [doc = "0: Interrupt on both edges"]
BOTHEDGES = 0 , # [doc = "2: Interrupt on falling edge"]
FALLING = 2 , # [doc = "3: Interrupt on rising edge"]
RISING = 3 , } impl From < INTMODE_A > for u8 { # [inline (always)]
fn from (variant : INTMODE_A) -> Self { variant as _ } } impl INTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INTMODE_A > { match self . bits { 0 => Some (INTMODE_A :: BOTHEDGES) , 2 => Some (INTMODE_A :: FALLING) , 3 => Some (INTMODE_A :: RISING) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == INTMODE_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTMODE_A :: FALLING } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTMODE_A :: RISING } } # [doc = "Field `INTMODE` writer - Interrupt Mode"]
pub type INTMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , AC1CTRL_SPEC , u8 , INTMODE_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE_W < 'a , O > { # [doc = "Interrupt on both edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (INTMODE_A :: BOTHEDGES) } # [doc = "Interrupt on falling edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTMODE_A :: FALLING) } # [doc = "Interrupt on rising edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTMODE_A :: RISING) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
pub fn hysmode (& self) -> HYSMODE_R { HYSMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - High-speed Mode"]
# [inline (always)]
pub fn hsmode (& self) -> HSMODE_R { HSMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Interrupt Level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Interrupt Mode"]
# [inline (always)]
pub fn intmode (& self) -> INTMODE_R { INTMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
# [must_use]
pub fn hysmode (& mut self) -> HYSMODE_W < 1 > { HYSMODE_W :: new (self) } # [doc = "Bit 3 - High-speed Mode"]
# [inline (always)]
# [must_use]
pub fn hsmode (& mut self) -> HSMODE_W < 3 > { HSMODE_W :: new (self) } # [doc = "Bits 4:5 - Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 4 > { INTLVL_W :: new (self) } # [doc = "Bits 6:7 - Interrupt Mode"]
# [inline (always)]
# [must_use]
pub fn intmode (& mut self) -> INTMODE_W < 6 > { INTMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ac1ctrl](index.html) module"]
pub struct AC1CTRL_SPEC ; impl crate :: RegisterSpec for AC1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ac1ctrl::R](R) reader structure"]
impl crate :: Readable for AC1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ac1ctrl::W](W) writer structure"]
impl crate :: Writable for AC1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AC1CTRL to value 0"]
impl crate :: Resettable for AC1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AC1MUXCTRL (rw) register accessor: an alias for `Reg<AC1MUXCTRL_SPEC>`"]
pub type AC1MUXCTRL = crate :: Reg < ac1muxctrl :: AC1MUXCTRL_SPEC > ; # [doc = "Analog Comparator 1 MUX Control"]
pub mod ac1muxctrl { # [doc = "Register `AC1MUXCTRL` reader"]
pub struct R (crate :: R < AC1MUXCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AC1MUXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AC1MUXCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AC1MUXCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AC1MUXCTRL` writer"]
pub struct W (crate :: W < AC1MUXCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AC1MUXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AC1MUXCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AC1MUXCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUXNEG` reader - MUX Negative Input"]
pub type MUXNEG_R = crate :: FieldReader < u8 , MUXNEG_A > ; # [doc = "MUX Negative Input\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXNEG_A { # [doc = "0: Pin 0"]
PIN0 = 0 , # [doc = "1: Pin 1"]
PIN1 = 1 , # [doc = "2: Pin 3"]
PIN3 = 2 , # [doc = "3: Pin 5"]
PIN5 = 3 , # [doc = "4: Pin 7"]
PIN7 = 4 , # [doc = "5: DAC output"]
DAC = 5 , # [doc = "6: Bandgap Reference"]
BANDGAP = 6 , # [doc = "7: Internal voltage scaler"]
SCALER = 7 , } impl From < MUXNEG_A > for u8 { # [inline (always)]
fn from (variant : MUXNEG_A) -> Self { variant as _ } } impl MUXNEG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXNEG_A { match self . bits { 0 => MUXNEG_A :: PIN0 , 1 => MUXNEG_A :: PIN1 , 2 => MUXNEG_A :: PIN3 , 3 => MUXNEG_A :: PIN5 , 4 => MUXNEG_A :: PIN7 , 5 => MUXNEG_A :: DAC , 6 => MUXNEG_A :: BANDGAP , 7 => MUXNEG_A :: SCALER , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXNEG_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXNEG_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXNEG_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXNEG_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN7`"]
# [inline (always)]
pub fn is_pin7 (& self) -> bool { * self == MUXNEG_A :: PIN7 } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXNEG_A :: DAC } # [doc = "Checks if the value of the field is `BANDGAP`"]
# [inline (always)]
pub fn is_bandgap (& self) -> bool { * self == MUXNEG_A :: BANDGAP } # [doc = "Checks if the value of the field is `SCALER`"]
# [inline (always)]
pub fn is_scaler (& self) -> bool { * self == MUXNEG_A :: SCALER } } # [doc = "Field `MUXNEG` writer - MUX Negative Input"]
pub type MUXNEG_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC1MUXCTRL_SPEC , u8 , MUXNEG_A , 3 , O > ; impl < 'a , const O : u8 > MUXNEG_W < 'a , O > { # [doc = "Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN0) } # [doc = "Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN1) } # [doc = "Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN3) } # [doc = "Pin 5"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN5) } # [doc = "Pin 7"]
# [inline (always)]
pub fn pin7 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN7) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXNEG_A :: DAC) } # [doc = "Bandgap Reference"]
# [inline (always)]
pub fn bandgap (self) -> & 'a mut W { self . variant (MUXNEG_A :: BANDGAP) } # [doc = "Internal voltage scaler"]
# [inline (always)]
pub fn scaler (self) -> & 'a mut W { self . variant (MUXNEG_A :: SCALER) } } # [doc = "Field `MUXPOS` reader - MUX Positive Input"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; # [doc = "MUX Positive Input\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: Pin 0"]
PIN0 = 0 , # [doc = "1: Pin 1"]
PIN1 = 1 , # [doc = "2: Pin 2"]
PIN2 = 2 , # [doc = "3: Pin 3"]
PIN3 = 3 , # [doc = "4: Pin 4"]
PIN4 = 4 , # [doc = "5: Pin 5"]
PIN5 = 5 , # [doc = "6: Pin 6"]
PIN6 = 6 , # [doc = "7: DAC output"]
DAC = 7 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXPOS_A { match self . bits { 0 => MUXPOS_A :: PIN0 , 1 => MUXPOS_A :: PIN1 , 2 => MUXPOS_A :: PIN2 , 3 => MUXPOS_A :: PIN3 , 4 => MUXPOS_A :: PIN4 , 5 => MUXPOS_A :: PIN5 , 6 => MUXPOS_A :: PIN6 , 7 => MUXPOS_A :: DAC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXPOS_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXPOS_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXPOS_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXPOS_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN4`"]
# [inline (always)]
pub fn is_pin4 (& self) -> bool { * self == MUXPOS_A :: PIN4 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXPOS_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN6`"]
# [inline (always)]
pub fn is_pin6 (& self) -> bool { * self == MUXPOS_A :: PIN6 } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXPOS_A :: DAC } } # [doc = "Field `MUXPOS` writer - MUX Positive Input"]
pub type MUXPOS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC1MUXCTRL_SPEC , u8 , MUXPOS_A , 3 , O > ; impl < 'a , const O : u8 > MUXPOS_W < 'a , O > { # [doc = "Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN0) } # [doc = "Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN1) } # [doc = "Pin 2"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN2) } # [doc = "Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN3) } # [doc = "Pin 4"]
# [inline (always)]
pub fn pin4 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN4) } # [doc = "Pin 5"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN5) } # [doc = "Pin 6"]
# [inline (always)]
pub fn pin6 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN6) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXPOS_A :: DAC) } } impl R { # [doc = "Bits 0:2 - MUX Negative Input"]
# [inline (always)]
pub fn muxneg (& self) -> MUXNEG_R { MUXNEG_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - MUX Positive Input"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new ((self . bits >> 3) & 7) } } impl W { # [doc = "Bits 0:2 - MUX Negative Input"]
# [inline (always)]
# [must_use]
pub fn muxneg (& mut self) -> MUXNEG_W < 0 > { MUXNEG_W :: new (self) } # [doc = "Bits 3:5 - MUX Positive Input"]
# [inline (always)]
# [must_use]
pub fn muxpos (& mut self) -> MUXPOS_W < 3 > { MUXPOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator 1 MUX Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ac1muxctrl](index.html) module"]
pub struct AC1MUXCTRL_SPEC ; impl crate :: RegisterSpec for AC1MUXCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ac1muxctrl::R](R) reader structure"]
impl crate :: Readable for AC1MUXCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ac1muxctrl::W](W) writer structure"]
impl crate :: Writable for AC1MUXCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AC1MUXCTRL to value 0"]
impl crate :: Resettable for AC1MUXCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `AC0OUT` reader - Analog Comparator 0 Output Enable"]
pub type AC0OUT_R = crate :: BitReader < bool > ; # [doc = "Field `AC0OUT` writer - Analog Comparator 0 Output Enable"]
pub type AC0OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Analog Comparator 0 Output Enable"]
# [inline (always)]
pub fn ac0out (& self) -> AC0OUT_R { AC0OUT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Analog Comparator 0 Output Enable"]
# [inline (always)]
# [must_use]
pub fn ac0out (& mut self) -> AC0OUT_W < 0 > { AC0OUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCALEFAC` reader - VCC Voltage Scaler Factor"]
pub type SCALEFAC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCALEFAC` writer - VCC Voltage Scaler Factor"]
pub type SCALEFAC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , u8 , 6 , O > ; impl R { # [doc = "Bits 0:5 - VCC Voltage Scaler Factor"]
# [inline (always)]
pub fn scalefac (& self) -> SCALEFAC_R { SCALEFAC_R :: new (self . bits & 0x3f) } } impl W { # [doc = "Bits 0:5 - VCC Voltage Scaler Factor"]
# [inline (always)]
# [must_use]
pub fn scalefac (& mut self) -> SCALEFAC_W < 0 > { SCALEFAC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `AC0IF` reader - Analog Comparator 0 Interrupt Flag"]
pub type AC0IF_R = crate :: BitReader < bool > ; # [doc = "Field `AC0IF` writer - Analog Comparator 0 Interrupt Flag"]
pub type AC0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `AC1IF` reader - Analog Comparator 1 Interrupt Flag"]
pub type AC1IF_R = crate :: BitReader < bool > ; # [doc = "Field `AC1IF` writer - Analog Comparator 1 Interrupt Flag"]
pub type AC1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `WIF` reader - Window Mode Interrupt Flag"]
pub type WIF_R = crate :: BitReader < bool > ; # [doc = "Field `WIF` writer - Window Mode Interrupt Flag"]
pub type WIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `AC0STATE` reader - Analog Comparator 0 State"]
pub type AC0STATE_R = crate :: BitReader < bool > ; # [doc = "Field `AC0STATE` writer - Analog Comparator 0 State"]
pub type AC0STATE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `AC1STATE` reader - Analog Comparator 1 State"]
pub type AC1STATE_R = crate :: BitReader < bool > ; # [doc = "Field `AC1STATE` writer - Analog Comparator 1 State"]
pub type AC1STATE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `WSTATE` reader - Window Mode State"]
pub type WSTATE_R = crate :: FieldReader < u8 , WSTATE_A > ; # [doc = "Window Mode State\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WSTATE_A { # [doc = "0: Signal above window"]
ABOVE = 0 , # [doc = "1: Signal inside window"]
INSIDE = 1 , # [doc = "2: Signal below window"]
BELOW = 2 , } impl From < WSTATE_A > for u8 { # [inline (always)]
fn from (variant : WSTATE_A) -> Self { variant as _ } } impl WSTATE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WSTATE_A > { match self . bits { 0 => Some (WSTATE_A :: ABOVE) , 1 => Some (WSTATE_A :: INSIDE) , 2 => Some (WSTATE_A :: BELOW) , _ => None , } } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WSTATE_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WSTATE_A :: INSIDE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WSTATE_A :: BELOW } } # [doc = "Field `WSTATE` writer - Window Mode State"]
pub type WSTATE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , STATUS_SPEC , u8 , WSTATE_A , 2 , O > ; impl < 'a , const O : u8 > WSTATE_W < 'a , O > { # [doc = "Signal above window"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (WSTATE_A :: ABOVE) } # [doc = "Signal inside window"]
# [inline (always)]
pub fn inside (self) -> & 'a mut W { self . variant (WSTATE_A :: INSIDE) } # [doc = "Signal below window"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (WSTATE_A :: BELOW) } } impl R { # [doc = "Bit 0 - Analog Comparator 0 Interrupt Flag"]
# [inline (always)]
pub fn ac0if (& self) -> AC0IF_R { AC0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Analog Comparator 1 Interrupt Flag"]
# [inline (always)]
pub fn ac1if (& self) -> AC1IF_R { AC1IF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Window Mode Interrupt Flag"]
# [inline (always)]
pub fn wif (& self) -> WIF_R { WIF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Analog Comparator 0 State"]
# [inline (always)]
pub fn ac0state (& self) -> AC0STATE_R { AC0STATE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Analog Comparator 1 State"]
# [inline (always)]
pub fn ac1state (& self) -> AC1STATE_R { AC1STATE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Window Mode State"]
# [inline (always)]
pub fn wstate (& self) -> WSTATE_R { WSTATE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Analog Comparator 0 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ac0if (& mut self) -> AC0IF_W < 0 > { AC0IF_W :: new (self) } # [doc = "Bit 1 - Analog Comparator 1 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ac1if (& mut self) -> AC1IF_W < 1 > { AC1IF_W :: new (self) } # [doc = "Bit 2 - Window Mode Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn wif (& mut self) -> WIF_W < 2 > { WIF_W :: new (self) } # [doc = "Bit 4 - Analog Comparator 0 State"]
# [inline (always)]
# [must_use]
pub fn ac0state (& mut self) -> AC0STATE_W < 4 > { AC0STATE_W :: new (self) } # [doc = "Bit 5 - Analog Comparator 1 State"]
# [inline (always)]
# [must_use]
pub fn ac1state (& mut self) -> AC1STATE_W < 5 > { AC1STATE_W :: new (self) } # [doc = "Bits 6:7 - Window Mode State"]
# [inline (always)]
# [must_use]
pub fn wstate (& mut self) -> WSTATE_W < 6 > { WSTATE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WINCTRL (rw) register accessor: an alias for `Reg<WINCTRL_SPEC>`"]
pub type WINCTRL = crate :: Reg < winctrl :: WINCTRL_SPEC > ; # [doc = "Window Mode Control"]
pub mod winctrl { # [doc = "Register `WINCTRL` reader"]
pub struct R (crate :: R < WINCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINCTRL` writer"]
pub struct W (crate :: W < WINCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `WINTLVL` reader - Window Interrupt Level"]
pub type WINTLVL_R = crate :: FieldReader < u8 , WINTLVL_A > ; # [doc = "Window Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINTLVL_A { # [doc = "0: Interrupt disabled"]
OFF = 0 , # [doc = "1: Low priority"]
LO = 1 , # [doc = "2: Medium priority"]
MED = 2 , # [doc = "3: High priority"]
HI = 3 , } impl From < WINTLVL_A > for u8 { # [inline (always)]
fn from (variant : WINTLVL_A) -> Self { variant as _ } } impl WINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WINTLVL_A { match self . bits { 0 => WINTLVL_A :: OFF , 1 => WINTLVL_A :: LO , 2 => WINTLVL_A :: MED , 3 => WINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == WINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == WINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == WINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == WINTLVL_A :: HI } } # [doc = "Field `WINTLVL` writer - Window Interrupt Level"]
pub type WINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , WINCTRL_SPEC , u8 , WINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > WINTLVL_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (WINTLVL_A :: OFF) } # [doc = "Low priority"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (WINTLVL_A :: LO) } # [doc = "Medium priority"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (WINTLVL_A :: MED) } # [doc = "High priority"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (WINTLVL_A :: HI) } } # [doc = "Field `WINTMODE` reader - Window Interrupt Mode"]
pub type WINTMODE_R = crate :: FieldReader < u8 , WINTMODE_A > ; # [doc = "Window Interrupt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINTMODE_A { # [doc = "0: Interrupt on above window"]
ABOVE = 0 , # [doc = "1: Interrupt on inside window"]
INSIDE = 1 , # [doc = "2: Interrupt on below window"]
BELOW = 2 , # [doc = "3: Interrupt on outside window"]
OUTSIDE = 3 , } impl From < WINTMODE_A > for u8 { # [inline (always)]
fn from (variant : WINTMODE_A) -> Self { variant as _ } } impl WINTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WINTMODE_A { match self . bits { 0 => WINTMODE_A :: ABOVE , 1 => WINTMODE_A :: INSIDE , 2 => WINTMODE_A :: BELOW , 3 => WINTMODE_A :: OUTSIDE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WINTMODE_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WINTMODE_A :: INSIDE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WINTMODE_A :: BELOW } # [doc = "Checks if the value of the field is `OUTSIDE`"]
# [inline (always)]
pub fn is_outside (& self) -> bool { * self == WINTMODE_A :: OUTSIDE } } # [doc = "Field `WINTMODE` writer - Window Interrupt Mode"]
pub type WINTMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , WINCTRL_SPEC , u8 , WINTMODE_A , 2 , O > ; impl < 'a , const O : u8 > WINTMODE_W < 'a , O > { # [doc = "Interrupt on above window"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (WINTMODE_A :: ABOVE) } # [doc = "Interrupt on inside window"]
# [inline (always)]
pub fn inside (self) -> & 'a mut W { self . variant (WINTMODE_A :: INSIDE) } # [doc = "Interrupt on below window"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (WINTMODE_A :: BELOW) } # [doc = "Interrupt on outside window"]
# [inline (always)]
pub fn outside (self) -> & 'a mut W { self . variant (WINTMODE_A :: OUTSIDE) } } # [doc = "Field `WEN` reader - Window Mode Enable"]
pub type WEN_R = crate :: BitReader < bool > ; # [doc = "Field `WEN` writer - Window Mode Enable"]
pub type WEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WINCTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Window Interrupt Level"]
# [inline (always)]
pub fn wintlvl (& self) -> WINTLVL_R { WINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Window Interrupt Mode"]
# [inline (always)]
pub fn wintmode (& self) -> WINTMODE_R { WINTMODE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Window Mode Enable"]
# [inline (always)]
pub fn wen (& self) -> WEN_R { WEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Window Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn wintlvl (& mut self) -> WINTLVL_W < 0 > { WINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Window Interrupt Mode"]
# [inline (always)]
# [must_use]
pub fn wintmode (& mut self) -> WINTMODE_W < 2 > { WINTMODE_W :: new (self) } # [doc = "Bit 4 - Window Mode Enable"]
# [inline (always)]
# [must_use]
pub fn wen (& mut self) -> WEN_W < 4 > { WEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Window Mode Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winctrl](index.html) module"]
pub struct WINCTRL_SPEC ; impl crate :: RegisterSpec for WINCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [winctrl::R](R) reader structure"]
impl crate :: Readable for WINCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winctrl::W](W) writer structure"]
impl crate :: Writable for WINCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WINCTRL to value 0"]
impl crate :: Resettable for WINCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Analog Comparator"]
pub struct ACB { _marker : PhantomData < * const () > } unsafe impl Send for ACB { } impl ACB { # [doc = r"Pointer to the register block"]
pub const PTR : * const acb :: RegisterBlock = 0x0390 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const acb :: RegisterBlock { Self :: PTR } } impl Deref for ACB { type Target = acb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ACB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ACB") . finish () } } # [doc = "Analog Comparator"]
pub mod acb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Analog Comparator 0 Control"]
pub ac0ctrl : AC0CTRL , # [doc = "0x01 - Analog Comparator 1 Control"]
pub ac1ctrl : AC1CTRL , # [doc = "0x02 - Analog Comparator 0 MUX Control"]
pub ac0muxctrl : AC0MUXCTRL , # [doc = "0x03 - Analog Comparator 1 MUX Control"]
pub ac1muxctrl : AC1MUXCTRL , # [doc = "0x04 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x05 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x06 - Window Mode Control"]
pub winctrl : WINCTRL , # [doc = "0x07 - Status"]
pub status : STATUS , } # [doc = "AC0CTRL (rw) register accessor: an alias for `Reg<AC0CTRL_SPEC>`"]
pub type AC0CTRL = crate :: Reg < ac0ctrl :: AC0CTRL_SPEC > ; # [doc = "Analog Comparator 0 Control"]
pub mod ac0ctrl { # [doc = "Register `AC0CTRL` reader"]
pub struct R (crate :: R < AC0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AC0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AC0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AC0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AC0CTRL` writer"]
pub struct W (crate :: W < AC0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AC0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AC0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AC0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AC0CTRL_SPEC , bool , O > ; # [doc = "Field `HYSMODE` reader - Hysteresis Mode"]
pub type HYSMODE_R = crate :: FieldReader < u8 , HYSMODE_A > ; # [doc = "Hysteresis Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HYSMODE_A { # [doc = "0: No hysteresis"]
NO = 0 , # [doc = "1: Small hysteresis"]
SMALL = 1 , # [doc = "2: Large hysteresis"]
LARGE = 2 , } impl From < HYSMODE_A > for u8 { # [inline (always)]
fn from (variant : HYSMODE_A) -> Self { variant as _ } } impl HYSMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < HYSMODE_A > { match self . bits { 0 => Some (HYSMODE_A :: NO) , 1 => Some (HYSMODE_A :: SMALL) , 2 => Some (HYSMODE_A :: LARGE) , _ => None , } } # [doc = "Checks if the value of the field is `NO`"]
# [inline (always)]
pub fn is_no (& self) -> bool { * self == HYSMODE_A :: NO } # [doc = "Checks if the value of the field is `SMALL`"]
# [inline (always)]
pub fn is_small (& self) -> bool { * self == HYSMODE_A :: SMALL } # [doc = "Checks if the value of the field is `LARGE`"]
# [inline (always)]
pub fn is_large (& self) -> bool { * self == HYSMODE_A :: LARGE } } # [doc = "Field `HYSMODE` writer - Hysteresis Mode"]
pub type HYSMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , AC0CTRL_SPEC , u8 , HYSMODE_A , 2 , O > ; impl < 'a , const O : u8 > HYSMODE_W < 'a , O > { # [doc = "No hysteresis"]
# [inline (always)]
pub fn no (self) -> & 'a mut W { self . variant (HYSMODE_A :: NO) } # [doc = "Small hysteresis"]
# [inline (always)]
pub fn small (self) -> & 'a mut W { self . variant (HYSMODE_A :: SMALL) } # [doc = "Large hysteresis"]
# [inline (always)]
pub fn large (self) -> & 'a mut W { self . variant (HYSMODE_A :: LARGE) } } # [doc = "Field `HSMODE` reader - High-speed Mode"]
pub type HSMODE_R = crate :: BitReader < bool > ; # [doc = "Field `HSMODE` writer - High-speed Mode"]
pub type HSMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AC0CTRL_SPEC , bool , O > ; # [doc = "Field `INTLVL` reader - Interrupt Level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt disabled"]
OFF = 0 , # [doc = "1: Low level"]
LO = 1 , # [doc = "2: Medium level"]
MED = 2 , # [doc = "3: High level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt Level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC0CTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } # [doc = "Field `INTMODE` reader - Interrupt Mode"]
pub type INTMODE_R = crate :: FieldReader < u8 , INTMODE_A > ; # [doc = "Interrupt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE_A { # [doc = "0: Interrupt on both edges"]
BOTHEDGES = 0 , # [doc = "2: Interrupt on falling edge"]
FALLING = 2 , # [doc = "3: Interrupt on rising edge"]
RISING = 3 , } impl From < INTMODE_A > for u8 { # [inline (always)]
fn from (variant : INTMODE_A) -> Self { variant as _ } } impl INTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INTMODE_A > { match self . bits { 0 => Some (INTMODE_A :: BOTHEDGES) , 2 => Some (INTMODE_A :: FALLING) , 3 => Some (INTMODE_A :: RISING) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == INTMODE_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTMODE_A :: FALLING } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTMODE_A :: RISING } } # [doc = "Field `INTMODE` writer - Interrupt Mode"]
pub type INTMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , AC0CTRL_SPEC , u8 , INTMODE_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE_W < 'a , O > { # [doc = "Interrupt on both edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (INTMODE_A :: BOTHEDGES) } # [doc = "Interrupt on falling edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTMODE_A :: FALLING) } # [doc = "Interrupt on rising edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTMODE_A :: RISING) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
pub fn hysmode (& self) -> HYSMODE_R { HYSMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - High-speed Mode"]
# [inline (always)]
pub fn hsmode (& self) -> HSMODE_R { HSMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Interrupt Level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Interrupt Mode"]
# [inline (always)]
pub fn intmode (& self) -> INTMODE_R { INTMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
# [must_use]
pub fn hysmode (& mut self) -> HYSMODE_W < 1 > { HYSMODE_W :: new (self) } # [doc = "Bit 3 - High-speed Mode"]
# [inline (always)]
# [must_use]
pub fn hsmode (& mut self) -> HSMODE_W < 3 > { HSMODE_W :: new (self) } # [doc = "Bits 4:5 - Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 4 > { INTLVL_W :: new (self) } # [doc = "Bits 6:7 - Interrupt Mode"]
# [inline (always)]
# [must_use]
pub fn intmode (& mut self) -> INTMODE_W < 6 > { INTMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator 0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ac0ctrl](index.html) module"]
pub struct AC0CTRL_SPEC ; impl crate :: RegisterSpec for AC0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ac0ctrl::R](R) reader structure"]
impl crate :: Readable for AC0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ac0ctrl::W](W) writer structure"]
impl crate :: Writable for AC0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AC0CTRL to value 0"]
impl crate :: Resettable for AC0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AC0MUXCTRL (rw) register accessor: an alias for `Reg<AC0MUXCTRL_SPEC>`"]
pub type AC0MUXCTRL = crate :: Reg < ac0muxctrl :: AC0MUXCTRL_SPEC > ; # [doc = "Analog Comparator 0 MUX Control"]
pub mod ac0muxctrl { # [doc = "Register `AC0MUXCTRL` reader"]
pub struct R (crate :: R < AC0MUXCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AC0MUXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AC0MUXCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AC0MUXCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AC0MUXCTRL` writer"]
pub struct W (crate :: W < AC0MUXCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AC0MUXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AC0MUXCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AC0MUXCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUXNEG` reader - MUX Negative Input"]
pub type MUXNEG_R = crate :: FieldReader < u8 , MUXNEG_A > ; # [doc = "MUX Negative Input\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXNEG_A { # [doc = "0: Pin 0"]
PIN0 = 0 , # [doc = "1: Pin 1"]
PIN1 = 1 , # [doc = "2: Pin 3"]
PIN3 = 2 , # [doc = "3: Pin 5"]
PIN5 = 3 , # [doc = "4: Pin 7"]
PIN7 = 4 , # [doc = "5: DAC output"]
DAC = 5 , # [doc = "6: Bandgap Reference"]
BANDGAP = 6 , # [doc = "7: Internal voltage scaler"]
SCALER = 7 , } impl From < MUXNEG_A > for u8 { # [inline (always)]
fn from (variant : MUXNEG_A) -> Self { variant as _ } } impl MUXNEG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXNEG_A { match self . bits { 0 => MUXNEG_A :: PIN0 , 1 => MUXNEG_A :: PIN1 , 2 => MUXNEG_A :: PIN3 , 3 => MUXNEG_A :: PIN5 , 4 => MUXNEG_A :: PIN7 , 5 => MUXNEG_A :: DAC , 6 => MUXNEG_A :: BANDGAP , 7 => MUXNEG_A :: SCALER , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXNEG_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXNEG_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXNEG_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXNEG_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN7`"]
# [inline (always)]
pub fn is_pin7 (& self) -> bool { * self == MUXNEG_A :: PIN7 } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXNEG_A :: DAC } # [doc = "Checks if the value of the field is `BANDGAP`"]
# [inline (always)]
pub fn is_bandgap (& self) -> bool { * self == MUXNEG_A :: BANDGAP } # [doc = "Checks if the value of the field is `SCALER`"]
# [inline (always)]
pub fn is_scaler (& self) -> bool { * self == MUXNEG_A :: SCALER } } # [doc = "Field `MUXNEG` writer - MUX Negative Input"]
pub type MUXNEG_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC0MUXCTRL_SPEC , u8 , MUXNEG_A , 3 , O > ; impl < 'a , const O : u8 > MUXNEG_W < 'a , O > { # [doc = "Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN0) } # [doc = "Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN1) } # [doc = "Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN3) } # [doc = "Pin 5"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN5) } # [doc = "Pin 7"]
# [inline (always)]
pub fn pin7 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN7) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXNEG_A :: DAC) } # [doc = "Bandgap Reference"]
# [inline (always)]
pub fn bandgap (self) -> & 'a mut W { self . variant (MUXNEG_A :: BANDGAP) } # [doc = "Internal voltage scaler"]
# [inline (always)]
pub fn scaler (self) -> & 'a mut W { self . variant (MUXNEG_A :: SCALER) } } # [doc = "Field `MUXPOS` reader - MUX Positive Input"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; # [doc = "MUX Positive Input\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: Pin 0"]
PIN0 = 0 , # [doc = "1: Pin 1"]
PIN1 = 1 , # [doc = "2: Pin 2"]
PIN2 = 2 , # [doc = "3: Pin 3"]
PIN3 = 3 , # [doc = "4: Pin 4"]
PIN4 = 4 , # [doc = "5: Pin 5"]
PIN5 = 5 , # [doc = "6: Pin 6"]
PIN6 = 6 , # [doc = "7: DAC output"]
DAC = 7 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXPOS_A { match self . bits { 0 => MUXPOS_A :: PIN0 , 1 => MUXPOS_A :: PIN1 , 2 => MUXPOS_A :: PIN2 , 3 => MUXPOS_A :: PIN3 , 4 => MUXPOS_A :: PIN4 , 5 => MUXPOS_A :: PIN5 , 6 => MUXPOS_A :: PIN6 , 7 => MUXPOS_A :: DAC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXPOS_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXPOS_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXPOS_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXPOS_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN4`"]
# [inline (always)]
pub fn is_pin4 (& self) -> bool { * self == MUXPOS_A :: PIN4 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXPOS_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN6`"]
# [inline (always)]
pub fn is_pin6 (& self) -> bool { * self == MUXPOS_A :: PIN6 } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXPOS_A :: DAC } } # [doc = "Field `MUXPOS` writer - MUX Positive Input"]
pub type MUXPOS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC0MUXCTRL_SPEC , u8 , MUXPOS_A , 3 , O > ; impl < 'a , const O : u8 > MUXPOS_W < 'a , O > { # [doc = "Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN0) } # [doc = "Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN1) } # [doc = "Pin 2"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN2) } # [doc = "Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN3) } # [doc = "Pin 4"]
# [inline (always)]
pub fn pin4 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN4) } # [doc = "Pin 5"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN5) } # [doc = "Pin 6"]
# [inline (always)]
pub fn pin6 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN6) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXPOS_A :: DAC) } } impl R { # [doc = "Bits 0:2 - MUX Negative Input"]
# [inline (always)]
pub fn muxneg (& self) -> MUXNEG_R { MUXNEG_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - MUX Positive Input"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new ((self . bits >> 3) & 7) } } impl W { # [doc = "Bits 0:2 - MUX Negative Input"]
# [inline (always)]
# [must_use]
pub fn muxneg (& mut self) -> MUXNEG_W < 0 > { MUXNEG_W :: new (self) } # [doc = "Bits 3:5 - MUX Positive Input"]
# [inline (always)]
# [must_use]
pub fn muxpos (& mut self) -> MUXPOS_W < 3 > { MUXPOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator 0 MUX Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ac0muxctrl](index.html) module"]
pub struct AC0MUXCTRL_SPEC ; impl crate :: RegisterSpec for AC0MUXCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ac0muxctrl::R](R) reader structure"]
impl crate :: Readable for AC0MUXCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ac0muxctrl::W](W) writer structure"]
impl crate :: Writable for AC0MUXCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AC0MUXCTRL to value 0"]
impl crate :: Resettable for AC0MUXCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AC1CTRL (rw) register accessor: an alias for `Reg<AC1CTRL_SPEC>`"]
pub type AC1CTRL = crate :: Reg < ac1ctrl :: AC1CTRL_SPEC > ; # [doc = "Analog Comparator 1 Control"]
pub mod ac1ctrl { # [doc = "Register `AC1CTRL` reader"]
pub struct R (crate :: R < AC1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AC1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AC1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AC1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AC1CTRL` writer"]
pub struct W (crate :: W < AC1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AC1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AC1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AC1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AC1CTRL_SPEC , bool , O > ; # [doc = "Field `HYSMODE` reader - Hysteresis Mode"]
pub type HYSMODE_R = crate :: FieldReader < u8 , HYSMODE_A > ; # [doc = "Hysteresis Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HYSMODE_A { # [doc = "0: No hysteresis"]
NO = 0 , # [doc = "1: Small hysteresis"]
SMALL = 1 , # [doc = "2: Large hysteresis"]
LARGE = 2 , } impl From < HYSMODE_A > for u8 { # [inline (always)]
fn from (variant : HYSMODE_A) -> Self { variant as _ } } impl HYSMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < HYSMODE_A > { match self . bits { 0 => Some (HYSMODE_A :: NO) , 1 => Some (HYSMODE_A :: SMALL) , 2 => Some (HYSMODE_A :: LARGE) , _ => None , } } # [doc = "Checks if the value of the field is `NO`"]
# [inline (always)]
pub fn is_no (& self) -> bool { * self == HYSMODE_A :: NO } # [doc = "Checks if the value of the field is `SMALL`"]
# [inline (always)]
pub fn is_small (& self) -> bool { * self == HYSMODE_A :: SMALL } # [doc = "Checks if the value of the field is `LARGE`"]
# [inline (always)]
pub fn is_large (& self) -> bool { * self == HYSMODE_A :: LARGE } } # [doc = "Field `HYSMODE` writer - Hysteresis Mode"]
pub type HYSMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , AC1CTRL_SPEC , u8 , HYSMODE_A , 2 , O > ; impl < 'a , const O : u8 > HYSMODE_W < 'a , O > { # [doc = "No hysteresis"]
# [inline (always)]
pub fn no (self) -> & 'a mut W { self . variant (HYSMODE_A :: NO) } # [doc = "Small hysteresis"]
# [inline (always)]
pub fn small (self) -> & 'a mut W { self . variant (HYSMODE_A :: SMALL) } # [doc = "Large hysteresis"]
# [inline (always)]
pub fn large (self) -> & 'a mut W { self . variant (HYSMODE_A :: LARGE) } } # [doc = "Field `HSMODE` reader - High-speed Mode"]
pub type HSMODE_R = crate :: BitReader < bool > ; # [doc = "Field `HSMODE` writer - High-speed Mode"]
pub type HSMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AC1CTRL_SPEC , bool , O > ; # [doc = "Field `INTLVL` reader - Interrupt Level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt disabled"]
OFF = 0 , # [doc = "1: Low level"]
LO = 1 , # [doc = "2: Medium level"]
MED = 2 , # [doc = "3: High level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt Level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC1CTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } # [doc = "Field `INTMODE` reader - Interrupt Mode"]
pub type INTMODE_R = crate :: FieldReader < u8 , INTMODE_A > ; # [doc = "Interrupt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTMODE_A { # [doc = "0: Interrupt on both edges"]
BOTHEDGES = 0 , # [doc = "2: Interrupt on falling edge"]
FALLING = 2 , # [doc = "3: Interrupt on rising edge"]
RISING = 3 , } impl From < INTMODE_A > for u8 { # [inline (always)]
fn from (variant : INTMODE_A) -> Self { variant as _ } } impl INTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < INTMODE_A > { match self . bits { 0 => Some (INTMODE_A :: BOTHEDGES) , 2 => Some (INTMODE_A :: FALLING) , 3 => Some (INTMODE_A :: RISING) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == INTMODE_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTMODE_A :: FALLING } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTMODE_A :: RISING } } # [doc = "Field `INTMODE` writer - Interrupt Mode"]
pub type INTMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , AC1CTRL_SPEC , u8 , INTMODE_A , 2 , O > ; impl < 'a , const O : u8 > INTMODE_W < 'a , O > { # [doc = "Interrupt on both edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (INTMODE_A :: BOTHEDGES) } # [doc = "Interrupt on falling edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTMODE_A :: FALLING) } # [doc = "Interrupt on rising edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTMODE_A :: RISING) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
pub fn hysmode (& self) -> HYSMODE_R { HYSMODE_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - High-speed Mode"]
# [inline (always)]
pub fn hsmode (& self) -> HSMODE_R { HSMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Interrupt Level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Interrupt Mode"]
# [inline (always)]
pub fn intmode (& self) -> INTMODE_R { INTMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bits 1:2 - Hysteresis Mode"]
# [inline (always)]
# [must_use]
pub fn hysmode (& mut self) -> HYSMODE_W < 1 > { HYSMODE_W :: new (self) } # [doc = "Bit 3 - High-speed Mode"]
# [inline (always)]
# [must_use]
pub fn hsmode (& mut self) -> HSMODE_W < 3 > { HSMODE_W :: new (self) } # [doc = "Bits 4:5 - Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 4 > { INTLVL_W :: new (self) } # [doc = "Bits 6:7 - Interrupt Mode"]
# [inline (always)]
# [must_use]
pub fn intmode (& mut self) -> INTMODE_W < 6 > { INTMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator 1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ac1ctrl](index.html) module"]
pub struct AC1CTRL_SPEC ; impl crate :: RegisterSpec for AC1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ac1ctrl::R](R) reader structure"]
impl crate :: Readable for AC1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ac1ctrl::W](W) writer structure"]
impl crate :: Writable for AC1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AC1CTRL to value 0"]
impl crate :: Resettable for AC1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "AC1MUXCTRL (rw) register accessor: an alias for `Reg<AC1MUXCTRL_SPEC>`"]
pub type AC1MUXCTRL = crate :: Reg < ac1muxctrl :: AC1MUXCTRL_SPEC > ; # [doc = "Analog Comparator 1 MUX Control"]
pub mod ac1muxctrl { # [doc = "Register `AC1MUXCTRL` reader"]
pub struct R (crate :: R < AC1MUXCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AC1MUXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AC1MUXCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AC1MUXCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AC1MUXCTRL` writer"]
pub struct W (crate :: W < AC1MUXCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AC1MUXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AC1MUXCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AC1MUXCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUXNEG` reader - MUX Negative Input"]
pub type MUXNEG_R = crate :: FieldReader < u8 , MUXNEG_A > ; # [doc = "MUX Negative Input\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXNEG_A { # [doc = "0: Pin 0"]
PIN0 = 0 , # [doc = "1: Pin 1"]
PIN1 = 1 , # [doc = "2: Pin 3"]
PIN3 = 2 , # [doc = "3: Pin 5"]
PIN5 = 3 , # [doc = "4: Pin 7"]
PIN7 = 4 , # [doc = "5: DAC output"]
DAC = 5 , # [doc = "6: Bandgap Reference"]
BANDGAP = 6 , # [doc = "7: Internal voltage scaler"]
SCALER = 7 , } impl From < MUXNEG_A > for u8 { # [inline (always)]
fn from (variant : MUXNEG_A) -> Self { variant as _ } } impl MUXNEG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXNEG_A { match self . bits { 0 => MUXNEG_A :: PIN0 , 1 => MUXNEG_A :: PIN1 , 2 => MUXNEG_A :: PIN3 , 3 => MUXNEG_A :: PIN5 , 4 => MUXNEG_A :: PIN7 , 5 => MUXNEG_A :: DAC , 6 => MUXNEG_A :: BANDGAP , 7 => MUXNEG_A :: SCALER , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXNEG_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXNEG_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXNEG_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXNEG_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN7`"]
# [inline (always)]
pub fn is_pin7 (& self) -> bool { * self == MUXNEG_A :: PIN7 } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXNEG_A :: DAC } # [doc = "Checks if the value of the field is `BANDGAP`"]
# [inline (always)]
pub fn is_bandgap (& self) -> bool { * self == MUXNEG_A :: BANDGAP } # [doc = "Checks if the value of the field is `SCALER`"]
# [inline (always)]
pub fn is_scaler (& self) -> bool { * self == MUXNEG_A :: SCALER } } # [doc = "Field `MUXNEG` writer - MUX Negative Input"]
pub type MUXNEG_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC1MUXCTRL_SPEC , u8 , MUXNEG_A , 3 , O > ; impl < 'a , const O : u8 > MUXNEG_W < 'a , O > { # [doc = "Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN0) } # [doc = "Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN1) } # [doc = "Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN3) } # [doc = "Pin 5"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN5) } # [doc = "Pin 7"]
# [inline (always)]
pub fn pin7 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN7) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXNEG_A :: DAC) } # [doc = "Bandgap Reference"]
# [inline (always)]
pub fn bandgap (self) -> & 'a mut W { self . variant (MUXNEG_A :: BANDGAP) } # [doc = "Internal voltage scaler"]
# [inline (always)]
pub fn scaler (self) -> & 'a mut W { self . variant (MUXNEG_A :: SCALER) } } # [doc = "Field `MUXPOS` reader - MUX Positive Input"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; # [doc = "MUX Positive Input\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: Pin 0"]
PIN0 = 0 , # [doc = "1: Pin 1"]
PIN1 = 1 , # [doc = "2: Pin 2"]
PIN2 = 2 , # [doc = "3: Pin 3"]
PIN3 = 3 , # [doc = "4: Pin 4"]
PIN4 = 4 , # [doc = "5: Pin 5"]
PIN5 = 5 , # [doc = "6: Pin 6"]
PIN6 = 6 , # [doc = "7: DAC output"]
DAC = 7 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXPOS_A { match self . bits { 0 => MUXPOS_A :: PIN0 , 1 => MUXPOS_A :: PIN1 , 2 => MUXPOS_A :: PIN2 , 3 => MUXPOS_A :: PIN3 , 4 => MUXPOS_A :: PIN4 , 5 => MUXPOS_A :: PIN5 , 6 => MUXPOS_A :: PIN6 , 7 => MUXPOS_A :: DAC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXPOS_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXPOS_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXPOS_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXPOS_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN4`"]
# [inline (always)]
pub fn is_pin4 (& self) -> bool { * self == MUXPOS_A :: PIN4 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXPOS_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN6`"]
# [inline (always)]
pub fn is_pin6 (& self) -> bool { * self == MUXPOS_A :: PIN6 } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXPOS_A :: DAC } } # [doc = "Field `MUXPOS` writer - MUX Positive Input"]
pub type MUXPOS_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , AC1MUXCTRL_SPEC , u8 , MUXPOS_A , 3 , O > ; impl < 'a , const O : u8 > MUXPOS_W < 'a , O > { # [doc = "Pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN0) } # [doc = "Pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN1) } # [doc = "Pin 2"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN2) } # [doc = "Pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN3) } # [doc = "Pin 4"]
# [inline (always)]
pub fn pin4 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN4) } # [doc = "Pin 5"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN5) } # [doc = "Pin 6"]
# [inline (always)]
pub fn pin6 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN6) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXPOS_A :: DAC) } } impl R { # [doc = "Bits 0:2 - MUX Negative Input"]
# [inline (always)]
pub fn muxneg (& self) -> MUXNEG_R { MUXNEG_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - MUX Positive Input"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new ((self . bits >> 3) & 7) } } impl W { # [doc = "Bits 0:2 - MUX Negative Input"]
# [inline (always)]
# [must_use]
pub fn muxneg (& mut self) -> MUXNEG_W < 0 > { MUXNEG_W :: new (self) } # [doc = "Bits 3:5 - MUX Positive Input"]
# [inline (always)]
# [must_use]
pub fn muxpos (& mut self) -> MUXPOS_W < 3 > { MUXPOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Analog Comparator 1 MUX Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ac1muxctrl](index.html) module"]
pub struct AC1MUXCTRL_SPEC ; impl crate :: RegisterSpec for AC1MUXCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ac1muxctrl::R](R) reader structure"]
impl crate :: Readable for AC1MUXCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ac1muxctrl::W](W) writer structure"]
impl crate :: Writable for AC1MUXCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AC1MUXCTRL to value 0"]
impl crate :: Resettable for AC1MUXCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `AC0OUT` reader - Analog Comparator 0 Output Enable"]
pub type AC0OUT_R = crate :: BitReader < bool > ; # [doc = "Field `AC0OUT` writer - Analog Comparator 0 Output Enable"]
pub type AC0OUT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Analog Comparator 0 Output Enable"]
# [inline (always)]
pub fn ac0out (& self) -> AC0OUT_R { AC0OUT_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Analog Comparator 0 Output Enable"]
# [inline (always)]
# [must_use]
pub fn ac0out (& mut self) -> AC0OUT_W < 0 > { AC0OUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCALEFAC` reader - VCC Voltage Scaler Factor"]
pub type SCALEFAC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SCALEFAC` writer - VCC Voltage Scaler Factor"]
pub type SCALEFAC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLB_SPEC , u8 , u8 , 6 , O > ; impl R { # [doc = "Bits 0:5 - VCC Voltage Scaler Factor"]
# [inline (always)]
pub fn scalefac (& self) -> SCALEFAC_R { SCALEFAC_R :: new (self . bits & 0x3f) } } impl W { # [doc = "Bits 0:5 - VCC Voltage Scaler Factor"]
# [inline (always)]
# [must_use]
pub fn scalefac (& mut self) -> SCALEFAC_W < 0 > { SCALEFAC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `AC0IF` reader - Analog Comparator 0 Interrupt Flag"]
pub type AC0IF_R = crate :: BitReader < bool > ; # [doc = "Field `AC0IF` writer - Analog Comparator 0 Interrupt Flag"]
pub type AC0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `AC1IF` reader - Analog Comparator 1 Interrupt Flag"]
pub type AC1IF_R = crate :: BitReader < bool > ; # [doc = "Field `AC1IF` writer - Analog Comparator 1 Interrupt Flag"]
pub type AC1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `WIF` reader - Window Mode Interrupt Flag"]
pub type WIF_R = crate :: BitReader < bool > ; # [doc = "Field `WIF` writer - Window Mode Interrupt Flag"]
pub type WIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `AC0STATE` reader - Analog Comparator 0 State"]
pub type AC0STATE_R = crate :: BitReader < bool > ; # [doc = "Field `AC0STATE` writer - Analog Comparator 0 State"]
pub type AC0STATE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `AC1STATE` reader - Analog Comparator 1 State"]
pub type AC1STATE_R = crate :: BitReader < bool > ; # [doc = "Field `AC1STATE` writer - Analog Comparator 1 State"]
pub type AC1STATE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `WSTATE` reader - Window Mode State"]
pub type WSTATE_R = crate :: FieldReader < u8 , WSTATE_A > ; # [doc = "Window Mode State\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WSTATE_A { # [doc = "0: Signal above window"]
ABOVE = 0 , # [doc = "1: Signal inside window"]
INSIDE = 1 , # [doc = "2: Signal below window"]
BELOW = 2 , } impl From < WSTATE_A > for u8 { # [inline (always)]
fn from (variant : WSTATE_A) -> Self { variant as _ } } impl WSTATE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WSTATE_A > { match self . bits { 0 => Some (WSTATE_A :: ABOVE) , 1 => Some (WSTATE_A :: INSIDE) , 2 => Some (WSTATE_A :: BELOW) , _ => None , } } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WSTATE_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WSTATE_A :: INSIDE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WSTATE_A :: BELOW } } # [doc = "Field `WSTATE` writer - Window Mode State"]
pub type WSTATE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , STATUS_SPEC , u8 , WSTATE_A , 2 , O > ; impl < 'a , const O : u8 > WSTATE_W < 'a , O > { # [doc = "Signal above window"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (WSTATE_A :: ABOVE) } # [doc = "Signal inside window"]
# [inline (always)]
pub fn inside (self) -> & 'a mut W { self . variant (WSTATE_A :: INSIDE) } # [doc = "Signal below window"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (WSTATE_A :: BELOW) } } impl R { # [doc = "Bit 0 - Analog Comparator 0 Interrupt Flag"]
# [inline (always)]
pub fn ac0if (& self) -> AC0IF_R { AC0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Analog Comparator 1 Interrupt Flag"]
# [inline (always)]
pub fn ac1if (& self) -> AC1IF_R { AC1IF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Window Mode Interrupt Flag"]
# [inline (always)]
pub fn wif (& self) -> WIF_R { WIF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Analog Comparator 0 State"]
# [inline (always)]
pub fn ac0state (& self) -> AC0STATE_R { AC0STATE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Analog Comparator 1 State"]
# [inline (always)]
pub fn ac1state (& self) -> AC1STATE_R { AC1STATE_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Window Mode State"]
# [inline (always)]
pub fn wstate (& self) -> WSTATE_R { WSTATE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Analog Comparator 0 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ac0if (& mut self) -> AC0IF_W < 0 > { AC0IF_W :: new (self) } # [doc = "Bit 1 - Analog Comparator 1 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ac1if (& mut self) -> AC1IF_W < 1 > { AC1IF_W :: new (self) } # [doc = "Bit 2 - Window Mode Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn wif (& mut self) -> WIF_W < 2 > { WIF_W :: new (self) } # [doc = "Bit 4 - Analog Comparator 0 State"]
# [inline (always)]
# [must_use]
pub fn ac0state (& mut self) -> AC0STATE_W < 4 > { AC0STATE_W :: new (self) } # [doc = "Bit 5 - Analog Comparator 1 State"]
# [inline (always)]
# [must_use]
pub fn ac1state (& mut self) -> AC1STATE_W < 5 > { AC1STATE_W :: new (self) } # [doc = "Bits 6:7 - Window Mode State"]
# [inline (always)]
# [must_use]
pub fn wstate (& mut self) -> WSTATE_W < 6 > { WSTATE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WINCTRL (rw) register accessor: an alias for `Reg<WINCTRL_SPEC>`"]
pub type WINCTRL = crate :: Reg < winctrl :: WINCTRL_SPEC > ; # [doc = "Window Mode Control"]
pub mod winctrl { # [doc = "Register `WINCTRL` reader"]
pub struct R (crate :: R < WINCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINCTRL` writer"]
pub struct W (crate :: W < WINCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `WINTLVL` reader - Window Interrupt Level"]
pub type WINTLVL_R = crate :: FieldReader < u8 , WINTLVL_A > ; # [doc = "Window Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINTLVL_A { # [doc = "0: Interrupt disabled"]
OFF = 0 , # [doc = "1: Low priority"]
LO = 1 , # [doc = "2: Medium priority"]
MED = 2 , # [doc = "3: High priority"]
HI = 3 , } impl From < WINTLVL_A > for u8 { # [inline (always)]
fn from (variant : WINTLVL_A) -> Self { variant as _ } } impl WINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WINTLVL_A { match self . bits { 0 => WINTLVL_A :: OFF , 1 => WINTLVL_A :: LO , 2 => WINTLVL_A :: MED , 3 => WINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == WINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == WINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == WINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == WINTLVL_A :: HI } } # [doc = "Field `WINTLVL` writer - Window Interrupt Level"]
pub type WINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , WINCTRL_SPEC , u8 , WINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > WINTLVL_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (WINTLVL_A :: OFF) } # [doc = "Low priority"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (WINTLVL_A :: LO) } # [doc = "Medium priority"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (WINTLVL_A :: MED) } # [doc = "High priority"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (WINTLVL_A :: HI) } } # [doc = "Field `WINTMODE` reader - Window Interrupt Mode"]
pub type WINTMODE_R = crate :: FieldReader < u8 , WINTMODE_A > ; # [doc = "Window Interrupt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WINTMODE_A { # [doc = "0: Interrupt on above window"]
ABOVE = 0 , # [doc = "1: Interrupt on inside window"]
INSIDE = 1 , # [doc = "2: Interrupt on below window"]
BELOW = 2 , # [doc = "3: Interrupt on outside window"]
OUTSIDE = 3 , } impl From < WINTMODE_A > for u8 { # [inline (always)]
fn from (variant : WINTMODE_A) -> Self { variant as _ } } impl WINTMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WINTMODE_A { match self . bits { 0 => WINTMODE_A :: ABOVE , 1 => WINTMODE_A :: INSIDE , 2 => WINTMODE_A :: BELOW , 3 => WINTMODE_A :: OUTSIDE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WINTMODE_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WINTMODE_A :: INSIDE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WINTMODE_A :: BELOW } # [doc = "Checks if the value of the field is `OUTSIDE`"]
# [inline (always)]
pub fn is_outside (& self) -> bool { * self == WINTMODE_A :: OUTSIDE } } # [doc = "Field `WINTMODE` writer - Window Interrupt Mode"]
pub type WINTMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , WINCTRL_SPEC , u8 , WINTMODE_A , 2 , O > ; impl < 'a , const O : u8 > WINTMODE_W < 'a , O > { # [doc = "Interrupt on above window"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (WINTMODE_A :: ABOVE) } # [doc = "Interrupt on inside window"]
# [inline (always)]
pub fn inside (self) -> & 'a mut W { self . variant (WINTMODE_A :: INSIDE) } # [doc = "Interrupt on below window"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (WINTMODE_A :: BELOW) } # [doc = "Interrupt on outside window"]
# [inline (always)]
pub fn outside (self) -> & 'a mut W { self . variant (WINTMODE_A :: OUTSIDE) } } # [doc = "Field `WEN` reader - Window Mode Enable"]
pub type WEN_R = crate :: BitReader < bool > ; # [doc = "Field `WEN` writer - Window Mode Enable"]
pub type WEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WINCTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Window Interrupt Level"]
# [inline (always)]
pub fn wintlvl (& self) -> WINTLVL_R { WINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Window Interrupt Mode"]
# [inline (always)]
pub fn wintmode (& self) -> WINTMODE_R { WINTMODE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Window Mode Enable"]
# [inline (always)]
pub fn wen (& self) -> WEN_R { WEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Window Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn wintlvl (& mut self) -> WINTLVL_W < 0 > { WINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Window Interrupt Mode"]
# [inline (always)]
# [must_use]
pub fn wintmode (& mut self) -> WINTMODE_W < 2 > { WINTMODE_W :: new (self) } # [doc = "Bit 4 - Window Mode Enable"]
# [inline (always)]
# [must_use]
pub fn wen (& mut self) -> WEN_W < 4 > { WEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Window Mode Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winctrl](index.html) module"]
pub struct WINCTRL_SPEC ; impl crate :: RegisterSpec for WINCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [winctrl::R](R) reader structure"]
impl crate :: Readable for WINCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winctrl::W](W) writer structure"]
impl crate :: Writable for WINCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WINCTRL to value 0"]
impl crate :: Resettable for WINCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Analog/Digital Converter"]
pub struct ADCA { _marker : PhantomData < * const () > } unsafe impl Send for ADCA { } impl ADCA { # [doc = r"Pointer to the register block"]
pub const PTR : * const adca :: RegisterBlock = 0x0200 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adca :: RegisterBlock { Self :: PTR } } impl Deref for ADCA { type Target = adca :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADCA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADCA") . finish () } } # [doc = "Analog/Digital Converter"]
pub mod adca { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Reference Control"]
pub refctrl : REFCTRL , # [doc = "0x03 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x04 - Clock Prescaler"]
pub prescaler : PRESCALER , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x07 - Temporary register"]
pub temp : TEMP , _reserved7 : [u8 ; 0x04]
, # [doc = "0x0c - Calibration Value"]
pub cal : CAL , _reserved8 : [u8 ; 0x02]
, # [doc = "0x10 - Channel 0 Result"]
pub ch0res : CH0RES , # [doc = "0x12 - Channel 1 Result"]
pub ch1res : CH1RES , # [doc = "0x14 - Channel 2 Result"]
pub ch2res : CH2RES , # [doc = "0x16 - Channel 3 Result"]
pub ch3res : CH3RES , # [doc = "0x18 - Compare Value"]
pub cmp : CMP , } # [doc = "CAL (rw) register accessor: an alias for `Reg<CAL_SPEC>`"]
pub type CAL = crate :: Reg < cal :: CAL_SPEC > ; # [doc = "Calibration Value"]
pub mod cal { # [doc = "Register `CAL` reader"]
pub struct R (crate :: R < CAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CAL` writer"]
pub struct W (crate :: W < CAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CAL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Calibration Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cal](index.html) module"]
pub struct CAL_SPEC ; impl crate :: RegisterSpec for CAL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cal::R](R) reader structure"]
impl crate :: Readable for CAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cal::W](W) writer structure"]
impl crate :: Writable for CAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CAL to value 0"]
impl crate :: Resettable for CAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH0RES (rw) register accessor: an alias for `Reg<CH0RES_SPEC>`"]
pub type CH0RES = crate :: Reg < ch0res :: CH0RES_SPEC > ; # [doc = "Channel 0 Result"]
pub mod ch0res { # [doc = "Register `CH0RES` reader"]
pub struct R (crate :: R < CH0RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH0RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH0RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH0RES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH0RES` writer"]
pub struct W (crate :: W < CH0RES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH0RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH0RES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH0RES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 0 Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch0res](index.html) module"]
pub struct CH0RES_SPEC ; impl crate :: RegisterSpec for CH0RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch0res::R](R) reader structure"]
impl crate :: Readable for CH0RES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch0res::W](W) writer structure"]
impl crate :: Writable for CH0RES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH0RES to value 0"]
impl crate :: Resettable for CH0RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH1RES (rw) register accessor: an alias for `Reg<CH1RES_SPEC>`"]
pub type CH1RES = crate :: Reg < ch1res :: CH1RES_SPEC > ; # [doc = "Channel 1 Result"]
pub mod ch1res { # [doc = "Register `CH1RES` reader"]
pub struct R (crate :: R < CH1RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH1RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH1RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH1RES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH1RES` writer"]
pub struct W (crate :: W < CH1RES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH1RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH1RES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH1RES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 1 Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch1res](index.html) module"]
pub struct CH1RES_SPEC ; impl crate :: RegisterSpec for CH1RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch1res::R](R) reader structure"]
impl crate :: Readable for CH1RES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch1res::W](W) writer structure"]
impl crate :: Writable for CH1RES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH1RES to value 0"]
impl crate :: Resettable for CH1RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH2RES (rw) register accessor: an alias for `Reg<CH2RES_SPEC>`"]
pub type CH2RES = crate :: Reg < ch2res :: CH2RES_SPEC > ; # [doc = "Channel 2 Result"]
pub mod ch2res { # [doc = "Register `CH2RES` reader"]
pub struct R (crate :: R < CH2RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH2RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH2RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH2RES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH2RES` writer"]
pub struct W (crate :: W < CH2RES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH2RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH2RES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH2RES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 2 Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch2res](index.html) module"]
pub struct CH2RES_SPEC ; impl crate :: RegisterSpec for CH2RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch2res::R](R) reader structure"]
impl crate :: Readable for CH2RES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch2res::W](W) writer structure"]
impl crate :: Writable for CH2RES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH2RES to value 0"]
impl crate :: Resettable for CH2RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH3RES (rw) register accessor: an alias for `Reg<CH3RES_SPEC>`"]
pub type CH3RES = crate :: Reg < ch3res :: CH3RES_SPEC > ; # [doc = "Channel 3 Result"]
pub mod ch3res { # [doc = "Register `CH3RES` reader"]
pub struct R (crate :: R < CH3RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH3RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH3RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH3RES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH3RES` writer"]
pub struct W (crate :: W < CH3RES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH3RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH3RES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH3RES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 3 Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch3res](index.html) module"]
pub struct CH3RES_SPEC ; impl crate :: RegisterSpec for CH3RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch3res::R](R) reader structure"]
impl crate :: Readable for CH3RES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch3res::W](W) writer structure"]
impl crate :: Writable for CH3RES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH3RES to value 0"]
impl crate :: Resettable for CH3RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP (rw) register accessor: an alias for `Reg<CMP_SPEC>`"]
pub type CMP = crate :: Reg < cmp :: CMP_SPEC > ; # [doc = "Compare Value"]
pub mod cmp { # [doc = "Register `CMP` reader"]
pub struct R (crate :: R < CMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP` writer"]
pub struct W (crate :: W < CMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp](index.html) module"]
pub struct CMP_SPEC ; impl crate :: RegisterSpec for CMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp::R](R) reader structure"]
impl crate :: Readable for CMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp::W](W) writer structure"]
impl crate :: Writable for CMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP to value 0"]
impl crate :: Resettable for CMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable ADC"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable ADC"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `FLUSH` reader - Flush Pipeline"]
pub type FLUSH_R = crate :: BitReader < bool > ; # [doc = "Field `FLUSH` writer - Flush Pipeline"]
pub type FLUSH_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH0START` reader - Channel 0 Start Conversion"]
pub type CH0START_R = crate :: BitReader < bool > ; # [doc = "Field `CH0START` writer - Channel 0 Start Conversion"]
pub type CH0START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH1START` reader - Channel 1 Start Conversion"]
pub type CH1START_R = crate :: BitReader < bool > ; # [doc = "Field `CH1START` writer - Channel 1 Start Conversion"]
pub type CH1START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH2START` reader - Channel 2 Start Conversion"]
pub type CH2START_R = crate :: BitReader < bool > ; # [doc = "Field `CH2START` writer - Channel 2 Start Conversion"]
pub type CH2START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH3START` reader - Channel 3 Start Conversion"]
pub type CH3START_R = crate :: BitReader < bool > ; # [doc = "Field `CH3START` writer - Channel 3 Start Conversion"]
pub type CH3START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DMASEL` reader - DMA Selection"]
pub type DMASEL_R = crate :: FieldReader < u8 , DMASEL_A > ; # [doc = "DMA Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DMASEL_A { # [doc = "0: Combined DMA request OFF"]
OFF = 0 , # [doc = "1: ADC Channel 0 or 1"]
CH01 = 1 , # [doc = "2: ADC Channel 0 or 1 or 2"]
CH012 = 2 , # [doc = "3: ADC Channel 0 or 1 or 2 or 3"]
CH0123 = 3 , } impl From < DMASEL_A > for u8 { # [inline (always)]
fn from (variant : DMASEL_A) -> Self { variant as _ } } impl DMASEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DMASEL_A { match self . bits { 0 => DMASEL_A :: OFF , 1 => DMASEL_A :: CH01 , 2 => DMASEL_A :: CH012 , 3 => DMASEL_A :: CH0123 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DMASEL_A :: OFF } # [doc = "Checks if the value of the field is `CH01`"]
# [inline (always)]
pub fn is_ch01 (& self) -> bool { * self == DMASEL_A :: CH01 } # [doc = "Checks if the value of the field is `CH012`"]
# [inline (always)]
pub fn is_ch012 (& self) -> bool { * self == DMASEL_A :: CH012 } # [doc = "Checks if the value of the field is `CH0123`"]
# [inline (always)]
pub fn is_ch0123 (& self) -> bool { * self == DMASEL_A :: CH0123 } } # [doc = "Field `DMASEL` writer - DMA Selection"]
pub type DMASEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DMASEL_A , 2 , O > ; impl < 'a , const O : u8 > DMASEL_W < 'a , O > { # [doc = "Combined DMA request OFF"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DMASEL_A :: OFF) } # [doc = "ADC Channel 0 or 1"]
# [inline (always)]
pub fn ch01 (self) -> & 'a mut W { self . variant (DMASEL_A :: CH01) } # [doc = "ADC Channel 0 or 1 or 2"]
# [inline (always)]
pub fn ch012 (self) -> & 'a mut W { self . variant (DMASEL_A :: CH012) } # [doc = "ADC Channel 0 or 1 or 2 or 3"]
# [inline (always)]
pub fn ch0123 (self) -> & 'a mut W { self . variant (DMASEL_A :: CH0123) } } impl R { # [doc = "Bit 0 - Enable ADC"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Flush Pipeline"]
# [inline (always)]
pub fn flush (& self) -> FLUSH_R { FLUSH_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 0 Start Conversion"]
# [inline (always)]
pub fn ch0start (& self) -> CH0START_R { CH0START_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 1 Start Conversion"]
# [inline (always)]
pub fn ch1start (& self) -> CH1START_R { CH1START_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 2 Start Conversion"]
# [inline (always)]
pub fn ch2start (& self) -> CH2START_R { CH2START_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 3 Start Conversion"]
# [inline (always)]
pub fn ch3start (& self) -> CH3START_R { CH3START_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - DMA Selection"]
# [inline (always)]
pub fn dmasel (& self) -> DMASEL_R { DMASEL_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Enable ADC"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Flush Pipeline"]
# [inline (always)]
# [must_use]
pub fn flush (& mut self) -> FLUSH_W < 1 > { FLUSH_W :: new (self) } # [doc = "Bit 2 - Channel 0 Start Conversion"]
# [inline (always)]
# [must_use]
pub fn ch0start (& mut self) -> CH0START_W < 2 > { CH0START_W :: new (self) } # [doc = "Bit 3 - Channel 1 Start Conversion"]
# [inline (always)]
# [must_use]
pub fn ch1start (& mut self) -> CH1START_W < 3 > { CH1START_W :: new (self) } # [doc = "Bit 4 - Channel 2 Start Conversion"]
# [inline (always)]
# [must_use]
pub fn ch2start (& mut self) -> CH2START_W < 4 > { CH2START_W :: new (self) } # [doc = "Bit 5 - Channel 3 Start Conversion"]
# [inline (always)]
# [must_use]
pub fn ch3start (& mut self) -> CH3START_W < 5 > { CH3START_W :: new (self) } # [doc = "Bits 6:7 - DMA Selection"]
# [inline (always)]
# [must_use]
pub fn dmasel (& mut self) -> DMASEL_W < 6 > { DMASEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESOLUTION` reader - Result Resolution"]
pub type RESOLUTION_R = crate :: FieldReader < u8 , RESOLUTION_A > ; # [doc = "Result Resolution\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RESOLUTION_A { # [doc = "0: 12-bit right-adjusted result"]
_12BIT = 0 , # [doc = "2: 8-bit right-adjusted result"]
_8BIT = 2 , # [doc = "3: 12-bit left-adjusted result"]
LEFT12BIT = 3 , } impl From < RESOLUTION_A > for u8 { # [inline (always)]
fn from (variant : RESOLUTION_A) -> Self { variant as _ } } impl RESOLUTION_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RESOLUTION_A > { match self . bits { 0 => Some (RESOLUTION_A :: _12BIT) , 2 => Some (RESOLUTION_A :: _8BIT) , 3 => Some (RESOLUTION_A :: LEFT12BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_12BIT`"]
# [inline (always)]
pub fn is_12bit (& self) -> bool { * self == RESOLUTION_A :: _12BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == RESOLUTION_A :: _8BIT } # [doc = "Checks if the value of the field is `LEFT12BIT`"]
# [inline (always)]
pub fn is_left12bit (& self) -> bool { * self == RESOLUTION_A :: LEFT12BIT } } # [doc = "Field `RESOLUTION` writer - Result Resolution"]
pub type RESOLUTION_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , RESOLUTION_A , 2 , O > ; impl < 'a , const O : u8 > RESOLUTION_W < 'a , O > { # [doc = "12-bit right-adjusted result"]
# [inline (always)]
pub fn _12bit (self) -> & 'a mut W { self . variant (RESOLUTION_A :: _12BIT) } # [doc = "8-bit right-adjusted result"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (RESOLUTION_A :: _8BIT) } # [doc = "12-bit left-adjusted result"]
# [inline (always)]
pub fn left12bit (self) -> & 'a mut W { self . variant (RESOLUTION_A :: LEFT12BIT) } } # [doc = "Field `FREERUN` reader - Free Running Mode Enable"]
pub type FREERUN_R = crate :: BitReader < bool > ; # [doc = "Field `FREERUN` writer - Free Running Mode Enable"]
pub type FREERUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CONMODE` reader - Conversion Mode"]
pub type CONMODE_R = crate :: BitReader < bool > ; # [doc = "Field `CONMODE` writer - Conversion Mode"]
pub type CONMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 1:2 - Result Resolution"]
# [inline (always)]
pub fn resolution (& self) -> RESOLUTION_R { RESOLUTION_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Free Running Mode Enable"]
# [inline (always)]
pub fn freerun (& self) -> FREERUN_R { FREERUN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Conversion Mode"]
# [inline (always)]
pub fn conmode (& self) -> CONMODE_R { CONMODE_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bits 1:2 - Result Resolution"]
# [inline (always)]
# [must_use]
pub fn resolution (& mut self) -> RESOLUTION_W < 1 > { RESOLUTION_W :: new (self) } # [doc = "Bit 3 - Free Running Mode Enable"]
# [inline (always)]
# [must_use]
pub fn freerun (& mut self) -> FREERUN_W < 3 > { FREERUN_W :: new (self) } # [doc = "Bit 4 - Conversion Mode"]
# [inline (always)]
# [must_use]
pub fn conmode (& mut self) -> CONMODE_W < 4 > { CONMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVACT` reader - Event Action Select"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No event action"]
NONE = 0 , # [doc = "1: First event triggers channel 0"]
CH0 = 1 , # [doc = "2: First two events trigger channel 0,1"]
CH01 = 2 , # [doc = "3: First three events trigger channel 0,1,2"]
CH012 = 3 , # [doc = "4: Events trigger channel 0,1,2,3"]
CH0123 = 4 , # [doc = "5: First event triggers sweep"]
SWEEP = 5 , # [doc = "6: The ADC is flushed and restarted for accurate timing"]
SYNCSWEEP = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: NONE) , 1 => Some (EVACT_A :: CH0) , 2 => Some (EVACT_A :: CH01) , 3 => Some (EVACT_A :: CH012) , 4 => Some (EVACT_A :: CH0123) , 5 => Some (EVACT_A :: SWEEP) , 6 => Some (EVACT_A :: SYNCSWEEP) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == EVACT_A :: NONE } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVACT_A :: CH0 } # [doc = "Checks if the value of the field is `CH01`"]
# [inline (always)]
pub fn is_ch01 (& self) -> bool { * self == EVACT_A :: CH01 } # [doc = "Checks if the value of the field is `CH012`"]
# [inline (always)]
pub fn is_ch012 (& self) -> bool { * self == EVACT_A :: CH012 } # [doc = "Checks if the value of the field is `CH0123`"]
# [inline (always)]
pub fn is_ch0123 (& self) -> bool { * self == EVACT_A :: CH0123 } # [doc = "Checks if the value of the field is `SWEEP`"]
# [inline (always)]
pub fn is_sweep (& self) -> bool { * self == EVACT_A :: SWEEP } # [doc = "Checks if the value of the field is `SYNCSWEEP`"]
# [inline (always)]
pub fn is_syncsweep (& self) -> bool { * self == EVACT_A :: SYNCSWEEP } } # [doc = "Field `EVACT` writer - Event Action Select"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , EVCTRL_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No event action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (EVACT_A :: NONE) } # [doc = "First event triggers channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVACT_A :: CH0) } # [doc = "First two events trigger channel 0,1"]
# [inline (always)]
pub fn ch01 (self) -> & 'a mut W { self . variant (EVACT_A :: CH01) } # [doc = "First three events trigger channel 0,1,2"]
# [inline (always)]
pub fn ch012 (self) -> & 'a mut W { self . variant (EVACT_A :: CH012) } # [doc = "Events trigger channel 0,1,2,3"]
# [inline (always)]
pub fn ch0123 (self) -> & 'a mut W { self . variant (EVACT_A :: CH0123) } # [doc = "First event triggers sweep"]
# [inline (always)]
pub fn sweep (self) -> & 'a mut W { self . variant (EVACT_A :: SWEEP) } # [doc = "The ADC is flushed and restarted for accurate timing"]
# [inline (always)]
pub fn syncsweep (self) -> & 'a mut W { self . variant (EVACT_A :: SYNCSWEEP) } } # [doc = "Field `EVSEL` reader - Event Input Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Input Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: Event Channel 0,1,2,3"]
_0123 = 0 , # [doc = "1: Event Channel 1,2,3,4"]
_1234 = 1 , # [doc = "2: Event Channel 2,3,4,5"]
_2345 = 2 , # [doc = "3: Event Channel 3,4,5,6"]
_3456 = 3 , # [doc = "4: Event Channel 4,5,6,7"]
_4567 = 4 , # [doc = "5: Event Channel 5,6,7"]
_567 = 5 , # [doc = "6: Event Channel 6,7"]
_67 = 6 , # [doc = "7: Event Channel 7"]
_7 = 7 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EVSEL_A { match self . bits { 0 => EVSEL_A :: _0123 , 1 => EVSEL_A :: _1234 , 2 => EVSEL_A :: _2345 , 3 => EVSEL_A :: _3456 , 4 => EVSEL_A :: _4567 , 5 => EVSEL_A :: _567 , 6 => EVSEL_A :: _67 , 7 => EVSEL_A :: _7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0123`"]
# [inline (always)]
pub fn is_0123 (& self) -> bool { * self == EVSEL_A :: _0123 } # [doc = "Checks if the value of the field is `_1234`"]
# [inline (always)]
pub fn is_1234 (& self) -> bool { * self == EVSEL_A :: _1234 } # [doc = "Checks if the value of the field is `_2345`"]
# [inline (always)]
pub fn is_2345 (& self) -> bool { * self == EVSEL_A :: _2345 } # [doc = "Checks if the value of the field is `_3456`"]
# [inline (always)]
pub fn is_3456 (& self) -> bool { * self == EVSEL_A :: _3456 } # [doc = "Checks if the value of the field is `_4567`"]
# [inline (always)]
pub fn is_4567 (& self) -> bool { * self == EVSEL_A :: _4567 } # [doc = "Checks if the value of the field is `_567`"]
# [inline (always)]
pub fn is_567 (& self) -> bool { * self == EVSEL_A :: _567 } # [doc = "Checks if the value of the field is `_67`"]
# [inline (always)]
pub fn is_67 (& self) -> bool { * self == EVSEL_A :: _67 } # [doc = "Checks if the value of the field is `_7`"]
# [inline (always)]
pub fn is_7 (& self) -> bool { * self == EVSEL_A :: _7 } } # [doc = "Field `EVSEL` writer - Event Input Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EVCTRL_SPEC , u8 , EVSEL_A , 3 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "Event Channel 0,1,2,3"]
# [inline (always)]
pub fn _0123 (self) -> & 'a mut W { self . variant (EVSEL_A :: _0123) } # [doc = "Event Channel 1,2,3,4"]
# [inline (always)]
pub fn _1234 (self) -> & 'a mut W { self . variant (EVSEL_A :: _1234) } # [doc = "Event Channel 2,3,4,5"]
# [inline (always)]
pub fn _2345 (self) -> & 'a mut W { self . variant (EVSEL_A :: _2345) } # [doc = "Event Channel 3,4,5,6"]
# [inline (always)]
pub fn _3456 (self) -> & 'a mut W { self . variant (EVSEL_A :: _3456) } # [doc = "Event Channel 4,5,6,7"]
# [inline (always)]
pub fn _4567 (self) -> & 'a mut W { self . variant (EVSEL_A :: _4567) } # [doc = "Event Channel 5,6,7"]
# [inline (always)]
pub fn _567 (self) -> & 'a mut W { self . variant (EVSEL_A :: _567) } # [doc = "Event Channel 6,7"]
# [inline (always)]
pub fn _67 (self) -> & 'a mut W { self . variant (EVSEL_A :: _67) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn _7 (self) -> & 'a mut W { self . variant (EVSEL_A :: _7) } } # [doc = "Field `SWEEP` reader - Channel Sweep Selection"]
pub type SWEEP_R = crate :: FieldReader < u8 , SWEEP_A > ; # [doc = "Channel Sweep Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SWEEP_A { # [doc = "0: ADC Channel 0"]
_0 = 0 , # [doc = "1: ADC Channel 0,1"]
_01 = 1 , # [doc = "2: ADC Channel 0,1,2"]
_012 = 2 , # [doc = "3: ADC Channel 0,1,2,3"]
_0123 = 3 , } impl From < SWEEP_A > for u8 { # [inline (always)]
fn from (variant : SWEEP_A) -> Self { variant as _ } } impl SWEEP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SWEEP_A { match self . bits { 0 => SWEEP_A :: _0 , 1 => SWEEP_A :: _01 , 2 => SWEEP_A :: _012 , 3 => SWEEP_A :: _0123 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == SWEEP_A :: _0 } # [doc = "Checks if the value of the field is `_01`"]
# [inline (always)]
pub fn is_01 (& self) -> bool { * self == SWEEP_A :: _01 } # [doc = "Checks if the value of the field is `_012`"]
# [inline (always)]
pub fn is_012 (& self) -> bool { * self == SWEEP_A :: _012 } # [doc = "Checks if the value of the field is `_0123`"]
# [inline (always)]
pub fn is_0123 (& self) -> bool { * self == SWEEP_A :: _0123 } } # [doc = "Field `SWEEP` writer - Channel Sweep Selection"]
pub type SWEEP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EVCTRL_SPEC , u8 , SWEEP_A , 2 , O > ; impl < 'a , const O : u8 > SWEEP_W < 'a , O > { # [doc = "ADC Channel 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (SWEEP_A :: _0) } # [doc = "ADC Channel 0,1"]
# [inline (always)]
pub fn _01 (self) -> & 'a mut W { self . variant (SWEEP_A :: _01) } # [doc = "ADC Channel 0,1,2"]
# [inline (always)]
pub fn _012 (self) -> & 'a mut W { self . variant (SWEEP_A :: _012) } # [doc = "ADC Channel 0,1,2,3"]
# [inline (always)]
pub fn _0123 (self) -> & 'a mut W { self . variant (SWEEP_A :: _0123) } } impl R { # [doc = "Bits 0:2 - Event Action Select"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Event Input Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new ((self . bits >> 3) & 7) } # [doc = "Bits 6:7 - Channel Sweep Selection"]
# [inline (always)]
pub fn sweep (& self) -> SWEEP_R { SWEEP_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Event Action Select"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 0 > { EVACT_W :: new (self) } # [doc = "Bits 3:5 - Event Input Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 3 > { EVSEL_W :: new (self) } # [doc = "Bits 6:7 - Channel Sweep Selection"]
# [inline (always)]
# [must_use]
pub fn sweep (& mut self) -> SWEEP_W < 6 > { SWEEP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CH0IF` reader - Channel 0 Interrupt Flag"]
pub type CH0IF_R = crate :: BitReader < bool > ; # [doc = "Field `CH0IF` writer - Channel 0 Interrupt Flag"]
pub type CH0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH1IF` reader - Channel 1 Interrupt Flag"]
pub type CH1IF_R = crate :: BitReader < bool > ; # [doc = "Field `CH1IF` writer - Channel 1 Interrupt Flag"]
pub type CH1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH2IF` reader - Channel 2 Interrupt Flag"]
pub type CH2IF_R = crate :: BitReader < bool > ; # [doc = "Field `CH2IF` writer - Channel 2 Interrupt Flag"]
pub type CH2IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH3IF` reader - Channel 3 Interrupt Flag"]
pub type CH3IF_R = crate :: BitReader < bool > ; # [doc = "Field `CH3IF` writer - Channel 3 Interrupt Flag"]
pub type CH3IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Channel 0 Interrupt Flag"]
# [inline (always)]
pub fn ch0if (& self) -> CH0IF_R { CH0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Interrupt Flag"]
# [inline (always)]
pub fn ch1if (& self) -> CH1IF_R { CH1IF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Interrupt Flag"]
# [inline (always)]
pub fn ch2if (& self) -> CH2IF_R { CH2IF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Interrupt Flag"]
# [inline (always)]
pub fn ch3if (& self) -> CH3IF_R { CH3IF_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch0if (& mut self) -> CH0IF_W < 0 > { CH0IF_W :: new (self) } # [doc = "Bit 1 - Channel 1 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch1if (& mut self) -> CH1IF_W < 1 > { CH1IF_W :: new (self) } # [doc = "Bit 2 - Channel 2 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch2if (& mut self) -> CH2IF_W < 2 > { CH2IF_W :: new (self) } # [doc = "Bit 3 - Channel 3 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch3if (& mut self) -> CH3IF_W < 3 > { CH3IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRESCALER (rw) register accessor: an alias for `Reg<PRESCALER_SPEC>`"]
pub type PRESCALER = crate :: Reg < prescaler :: PRESCALER_SPEC > ; # [doc = "Clock Prescaler"]
pub mod prescaler { # [doc = "Register `PRESCALER` reader"]
pub struct R (crate :: R < PRESCALER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRESCALER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRESCALER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRESCALER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRESCALER` writer"]
pub struct W (crate :: W < PRESCALER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRESCALER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRESCALER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRESCALER_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESCALER` reader - Clock Prescaler Selection"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Clock Prescaler Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: Divide clock by 4"]
DIV4 = 0 , # [doc = "1: Divide clock by 8"]
DIV8 = 1 , # [doc = "2: Divide clock by 16"]
DIV16 = 2 , # [doc = "3: Divide clock by 32"]
DIV32 = 3 , # [doc = "4: Divide clock by 64"]
DIV64 = 4 , # [doc = "5: Divide clock by 128"]
DIV128 = 5 , # [doc = "6: Divide clock by 256"]
DIV256 = 6 , # [doc = "7: Divide clock by 512"]
DIV512 = 7 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV4 , 1 => PRESCALER_A :: DIV8 , 2 => PRESCALER_A :: DIV16 , 3 => PRESCALER_A :: DIV32 , 4 => PRESCALER_A :: DIV64 , 5 => PRESCALER_A :: DIV128 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV512 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESCALER_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PRESCALER_A :: DIV512 } } # [doc = "Field `PRESCALER` writer - Clock Prescaler Selection"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PRESCALER_SPEC , u8 , PRESCALER_A , 3 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "Divide clock by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "Divide clock by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "Divide clock by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "Divide clock by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32) } # [doc = "Divide clock by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "Divide clock by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } # [doc = "Divide clock by 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "Divide clock by 512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV512) } } impl R { # [doc = "Bits 0:2 - Clock Prescaler Selection"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Clock Prescaler Selection"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 0 > { PRESCALER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prescaler](index.html) module"]
pub struct PRESCALER_SPEC ; impl crate :: RegisterSpec for PRESCALER_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prescaler::R](R) reader structure"]
impl crate :: Readable for PRESCALER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prescaler::W](W) writer structure"]
impl crate :: Writable for PRESCALER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRESCALER to value 0"]
impl crate :: Resettable for PRESCALER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "REFCTRL (rw) register accessor: an alias for `Reg<REFCTRL_SPEC>`"]
pub type REFCTRL = crate :: Reg < refctrl :: REFCTRL_SPEC > ; # [doc = "Reference Control"]
pub mod refctrl { # [doc = "Register `REFCTRL` reader"]
pub struct R (crate :: R < REFCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < REFCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < REFCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < REFCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `REFCTRL` writer"]
pub struct W (crate :: W < REFCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < REFCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < REFCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < REFCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TEMPREF` reader - Temperature Reference Enable"]
pub type TEMPREF_R = crate :: BitReader < bool > ; # [doc = "Field `TEMPREF` writer - Temperature Reference Enable"]
pub type TEMPREF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , REFCTRL_SPEC , bool , O > ; # [doc = "Field `BANDGAP` reader - Bandgap enable"]
pub type BANDGAP_R = crate :: BitReader < bool > ; # [doc = "Field `BANDGAP` writer - Bandgap enable"]
pub type BANDGAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , REFCTRL_SPEC , bool , O > ; # [doc = "Field `REFSEL` reader - Reference Selection"]
pub type REFSEL_R = crate :: FieldReader < u8 , REFSEL_A > ; # [doc = "Reference Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFSEL_A { # [doc = "0: Internal 1V"]
INT1V = 0 , # [doc = "1: Internal VCC / 1.6V"]
INTVCC = 1 , # [doc = "2: External reference on PORT A"]
AREFA = 2 , # [doc = "3: External reference on PORT B"]
AREFB = 3 , } impl From < REFSEL_A > for u8 { # [inline (always)]
fn from (variant : REFSEL_A) -> Self { variant as _ } } impl REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> REFSEL_A { match self . bits { 0 => REFSEL_A :: INT1V , 1 => REFSEL_A :: INTVCC , 2 => REFSEL_A :: AREFA , 3 => REFSEL_A :: AREFB , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT1V`"]
# [inline (always)]
pub fn is_int1v (& self) -> bool { * self == REFSEL_A :: INT1V } # [doc = "Checks if the value of the field is `INTVCC`"]
# [inline (always)]
pub fn is_intvcc (& self) -> bool { * self == REFSEL_A :: INTVCC } # [doc = "Checks if the value of the field is `AREFA`"]
# [inline (always)]
pub fn is_arefa (& self) -> bool { * self == REFSEL_A :: AREFA } # [doc = "Checks if the value of the field is `AREFB`"]
# [inline (always)]
pub fn is_arefb (& self) -> bool { * self == REFSEL_A :: AREFB } } # [doc = "Field `REFSEL` writer - Reference Selection"]
pub type REFSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , REFCTRL_SPEC , u8 , REFSEL_A , 2 , O > ; impl < 'a , const O : u8 > REFSEL_W < 'a , O > { # [doc = "Internal 1V"]
# [inline (always)]
pub fn int1v (self) -> & 'a mut W { self . variant (REFSEL_A :: INT1V) } # [doc = "Internal VCC / 1.6V"]
# [inline (always)]
pub fn intvcc (self) -> & 'a mut W { self . variant (REFSEL_A :: INTVCC) } # [doc = "External reference on PORT A"]
# [inline (always)]
pub fn arefa (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFA) } # [doc = "External reference on PORT B"]
# [inline (always)]
pub fn arefb (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFB) } } impl R { # [doc = "Bit 0 - Temperature Reference Enable"]
# [inline (always)]
pub fn tempref (& self) -> TEMPREF_R { TEMPREF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Bandgap enable"]
# [inline (always)]
pub fn bandgap (& self) -> BANDGAP_R { BANDGAP_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 4:5 - Reference Selection"]
# [inline (always)]
pub fn refsel (& self) -> REFSEL_R { REFSEL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bit 0 - Temperature Reference Enable"]
# [inline (always)]
# [must_use]
pub fn tempref (& mut self) -> TEMPREF_W < 0 > { TEMPREF_W :: new (self) } # [doc = "Bit 1 - Bandgap enable"]
# [inline (always)]
# [must_use]
pub fn bandgap (& mut self) -> BANDGAP_W < 1 > { BANDGAP_W :: new (self) } # [doc = "Bits 4:5 - Reference Selection"]
# [inline (always)]
# [must_use]
pub fn refsel (& mut self) -> REFSEL_W < 4 > { REFSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Reference Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [refctrl](index.html) module"]
pub struct REFCTRL_SPEC ; impl crate :: RegisterSpec for REFCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [refctrl::R](R) reader structure"]
impl crate :: Readable for REFCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [refctrl::W](W) writer structure"]
impl crate :: Writable for REFCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets REFCTRL to value 0"]
impl crate :: Resettable for REFCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary register"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Analog/Digital Converter"]
pub struct ADCB { _marker : PhantomData < * const () > } unsafe impl Send for ADCB { } impl ADCB { # [doc = r"Pointer to the register block"]
pub const PTR : * const adcb :: RegisterBlock = 0x0240 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adcb :: RegisterBlock { Self :: PTR } } impl Deref for ADCB { type Target = adcb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADCB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADCB") . finish () } } # [doc = "Analog/Digital Converter"]
pub mod adcb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Reference Control"]
pub refctrl : REFCTRL , # [doc = "0x03 - Event Control"]
pub evctrl : EVCTRL , # [doc = "0x04 - Clock Prescaler"]
pub prescaler : PRESCALER , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x07 - Temporary register"]
pub temp : TEMP , _reserved7 : [u8 ; 0x04]
, # [doc = "0x0c - Calibration Value"]
pub cal : CAL , _reserved8 : [u8 ; 0x02]
, # [doc = "0x10 - Channel 0 Result"]
pub ch0res : CH0RES , # [doc = "0x12 - Channel 1 Result"]
pub ch1res : CH1RES , # [doc = "0x14 - Channel 2 Result"]
pub ch2res : CH2RES , # [doc = "0x16 - Channel 3 Result"]
pub ch3res : CH3RES , # [doc = "0x18 - Compare Value"]
pub cmp : CMP , } # [doc = "CAL (rw) register accessor: an alias for `Reg<CAL_SPEC>`"]
pub type CAL = crate :: Reg < cal :: CAL_SPEC > ; # [doc = "Calibration Value"]
pub mod cal { # [doc = "Register `CAL` reader"]
pub struct R (crate :: R < CAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CAL` writer"]
pub struct W (crate :: W < CAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CAL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Calibration Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cal](index.html) module"]
pub struct CAL_SPEC ; impl crate :: RegisterSpec for CAL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cal::R](R) reader structure"]
impl crate :: Readable for CAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cal::W](W) writer structure"]
impl crate :: Writable for CAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CAL to value 0"]
impl crate :: Resettable for CAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH0RES (rw) register accessor: an alias for `Reg<CH0RES_SPEC>`"]
pub type CH0RES = crate :: Reg < ch0res :: CH0RES_SPEC > ; # [doc = "Channel 0 Result"]
pub mod ch0res { # [doc = "Register `CH0RES` reader"]
pub struct R (crate :: R < CH0RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH0RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH0RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH0RES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH0RES` writer"]
pub struct W (crate :: W < CH0RES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH0RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH0RES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH0RES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 0 Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch0res](index.html) module"]
pub struct CH0RES_SPEC ; impl crate :: RegisterSpec for CH0RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch0res::R](R) reader structure"]
impl crate :: Readable for CH0RES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch0res::W](W) writer structure"]
impl crate :: Writable for CH0RES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH0RES to value 0"]
impl crate :: Resettable for CH0RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH1RES (rw) register accessor: an alias for `Reg<CH1RES_SPEC>`"]
pub type CH1RES = crate :: Reg < ch1res :: CH1RES_SPEC > ; # [doc = "Channel 1 Result"]
pub mod ch1res { # [doc = "Register `CH1RES` reader"]
pub struct R (crate :: R < CH1RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH1RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH1RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH1RES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH1RES` writer"]
pub struct W (crate :: W < CH1RES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH1RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH1RES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH1RES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 1 Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch1res](index.html) module"]
pub struct CH1RES_SPEC ; impl crate :: RegisterSpec for CH1RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch1res::R](R) reader structure"]
impl crate :: Readable for CH1RES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch1res::W](W) writer structure"]
impl crate :: Writable for CH1RES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH1RES to value 0"]
impl crate :: Resettable for CH1RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH2RES (rw) register accessor: an alias for `Reg<CH2RES_SPEC>`"]
pub type CH2RES = crate :: Reg < ch2res :: CH2RES_SPEC > ; # [doc = "Channel 2 Result"]
pub mod ch2res { # [doc = "Register `CH2RES` reader"]
pub struct R (crate :: R < CH2RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH2RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH2RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH2RES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH2RES` writer"]
pub struct W (crate :: W < CH2RES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH2RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH2RES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH2RES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 2 Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch2res](index.html) module"]
pub struct CH2RES_SPEC ; impl crate :: RegisterSpec for CH2RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch2res::R](R) reader structure"]
impl crate :: Readable for CH2RES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch2res::W](W) writer structure"]
impl crate :: Writable for CH2RES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH2RES to value 0"]
impl crate :: Resettable for CH2RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH3RES (rw) register accessor: an alias for `Reg<CH3RES_SPEC>`"]
pub type CH3RES = crate :: Reg < ch3res :: CH3RES_SPEC > ; # [doc = "Channel 3 Result"]
pub mod ch3res { # [doc = "Register `CH3RES` reader"]
pub struct R (crate :: R < CH3RES_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH3RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH3RES_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH3RES_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH3RES` writer"]
pub struct W (crate :: W < CH3RES_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH3RES_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH3RES_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH3RES_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 3 Result\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch3res](index.html) module"]
pub struct CH3RES_SPEC ; impl crate :: RegisterSpec for CH3RES_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch3res::R](R) reader structure"]
impl crate :: Readable for CH3RES_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch3res::W](W) writer structure"]
impl crate :: Writable for CH3RES_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH3RES to value 0"]
impl crate :: Resettable for CH3RES_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMP (rw) register accessor: an alias for `Reg<CMP_SPEC>`"]
pub type CMP = crate :: Reg < cmp :: CMP_SPEC > ; # [doc = "Compare Value"]
pub mod cmp { # [doc = "Register `CMP` reader"]
pub struct R (crate :: R < CMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMP` writer"]
pub struct W (crate :: W < CMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmp](index.html) module"]
pub struct CMP_SPEC ; impl crate :: RegisterSpec for CMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cmp::R](R) reader structure"]
impl crate :: Readable for CMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmp::W](W) writer structure"]
impl crate :: Writable for CMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMP to value 0"]
impl crate :: Resettable for CMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable ADC"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable ADC"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `FLUSH` reader - Flush Pipeline"]
pub type FLUSH_R = crate :: BitReader < bool > ; # [doc = "Field `FLUSH` writer - Flush Pipeline"]
pub type FLUSH_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH0START` reader - Channel 0 Start Conversion"]
pub type CH0START_R = crate :: BitReader < bool > ; # [doc = "Field `CH0START` writer - Channel 0 Start Conversion"]
pub type CH0START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH1START` reader - Channel 1 Start Conversion"]
pub type CH1START_R = crate :: BitReader < bool > ; # [doc = "Field `CH1START` writer - Channel 1 Start Conversion"]
pub type CH1START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH2START` reader - Channel 2 Start Conversion"]
pub type CH2START_R = crate :: BitReader < bool > ; # [doc = "Field `CH2START` writer - Channel 2 Start Conversion"]
pub type CH2START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH3START` reader - Channel 3 Start Conversion"]
pub type CH3START_R = crate :: BitReader < bool > ; # [doc = "Field `CH3START` writer - Channel 3 Start Conversion"]
pub type CH3START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `DMASEL` reader - DMA Selection"]
pub type DMASEL_R = crate :: FieldReader < u8 , DMASEL_A > ; # [doc = "DMA Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DMASEL_A { # [doc = "0: Combined DMA request OFF"]
OFF = 0 , # [doc = "1: ADC Channel 0 or 1"]
CH01 = 1 , # [doc = "2: ADC Channel 0 or 1 or 2"]
CH012 = 2 , # [doc = "3: ADC Channel 0 or 1 or 2 or 3"]
CH0123 = 3 , } impl From < DMASEL_A > for u8 { # [inline (always)]
fn from (variant : DMASEL_A) -> Self { variant as _ } } impl DMASEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DMASEL_A { match self . bits { 0 => DMASEL_A :: OFF , 1 => DMASEL_A :: CH01 , 2 => DMASEL_A :: CH012 , 3 => DMASEL_A :: CH0123 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DMASEL_A :: OFF } # [doc = "Checks if the value of the field is `CH01`"]
# [inline (always)]
pub fn is_ch01 (& self) -> bool { * self == DMASEL_A :: CH01 } # [doc = "Checks if the value of the field is `CH012`"]
# [inline (always)]
pub fn is_ch012 (& self) -> bool { * self == DMASEL_A :: CH012 } # [doc = "Checks if the value of the field is `CH0123`"]
# [inline (always)]
pub fn is_ch0123 (& self) -> bool { * self == DMASEL_A :: CH0123 } } # [doc = "Field `DMASEL` writer - DMA Selection"]
pub type DMASEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DMASEL_A , 2 , O > ; impl < 'a , const O : u8 > DMASEL_W < 'a , O > { # [doc = "Combined DMA request OFF"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DMASEL_A :: OFF) } # [doc = "ADC Channel 0 or 1"]
# [inline (always)]
pub fn ch01 (self) -> & 'a mut W { self . variant (DMASEL_A :: CH01) } # [doc = "ADC Channel 0 or 1 or 2"]
# [inline (always)]
pub fn ch012 (self) -> & 'a mut W { self . variant (DMASEL_A :: CH012) } # [doc = "ADC Channel 0 or 1 or 2 or 3"]
# [inline (always)]
pub fn ch0123 (self) -> & 'a mut W { self . variant (DMASEL_A :: CH0123) } } impl R { # [doc = "Bit 0 - Enable ADC"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Flush Pipeline"]
# [inline (always)]
pub fn flush (& self) -> FLUSH_R { FLUSH_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 0 Start Conversion"]
# [inline (always)]
pub fn ch0start (& self) -> CH0START_R { CH0START_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 1 Start Conversion"]
# [inline (always)]
pub fn ch1start (& self) -> CH1START_R { CH1START_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 2 Start Conversion"]
# [inline (always)]
pub fn ch2start (& self) -> CH2START_R { CH2START_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 3 Start Conversion"]
# [inline (always)]
pub fn ch3start (& self) -> CH3START_R { CH3START_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - DMA Selection"]
# [inline (always)]
pub fn dmasel (& self) -> DMASEL_R { DMASEL_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bit 0 - Enable ADC"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Flush Pipeline"]
# [inline (always)]
# [must_use]
pub fn flush (& mut self) -> FLUSH_W < 1 > { FLUSH_W :: new (self) } # [doc = "Bit 2 - Channel 0 Start Conversion"]
# [inline (always)]
# [must_use]
pub fn ch0start (& mut self) -> CH0START_W < 2 > { CH0START_W :: new (self) } # [doc = "Bit 3 - Channel 1 Start Conversion"]
# [inline (always)]
# [must_use]
pub fn ch1start (& mut self) -> CH1START_W < 3 > { CH1START_W :: new (self) } # [doc = "Bit 4 - Channel 2 Start Conversion"]
# [inline (always)]
# [must_use]
pub fn ch2start (& mut self) -> CH2START_W < 4 > { CH2START_W :: new (self) } # [doc = "Bit 5 - Channel 3 Start Conversion"]
# [inline (always)]
# [must_use]
pub fn ch3start (& mut self) -> CH3START_W < 5 > { CH3START_W :: new (self) } # [doc = "Bits 6:7 - DMA Selection"]
# [inline (always)]
# [must_use]
pub fn dmasel (& mut self) -> DMASEL_W < 6 > { DMASEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESOLUTION` reader - Result Resolution"]
pub type RESOLUTION_R = crate :: FieldReader < u8 , RESOLUTION_A > ; # [doc = "Result Resolution\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RESOLUTION_A { # [doc = "0: 12-bit right-adjusted result"]
_12BIT = 0 , # [doc = "2: 8-bit right-adjusted result"]
_8BIT = 2 , # [doc = "3: 12-bit left-adjusted result"]
LEFT12BIT = 3 , } impl From < RESOLUTION_A > for u8 { # [inline (always)]
fn from (variant : RESOLUTION_A) -> Self { variant as _ } } impl RESOLUTION_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RESOLUTION_A > { match self . bits { 0 => Some (RESOLUTION_A :: _12BIT) , 2 => Some (RESOLUTION_A :: _8BIT) , 3 => Some (RESOLUTION_A :: LEFT12BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_12BIT`"]
# [inline (always)]
pub fn is_12bit (& self) -> bool { * self == RESOLUTION_A :: _12BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == RESOLUTION_A :: _8BIT } # [doc = "Checks if the value of the field is `LEFT12BIT`"]
# [inline (always)]
pub fn is_left12bit (& self) -> bool { * self == RESOLUTION_A :: LEFT12BIT } } # [doc = "Field `RESOLUTION` writer - Result Resolution"]
pub type RESOLUTION_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , RESOLUTION_A , 2 , O > ; impl < 'a , const O : u8 > RESOLUTION_W < 'a , O > { # [doc = "12-bit right-adjusted result"]
# [inline (always)]
pub fn _12bit (self) -> & 'a mut W { self . variant (RESOLUTION_A :: _12BIT) } # [doc = "8-bit right-adjusted result"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (RESOLUTION_A :: _8BIT) } # [doc = "12-bit left-adjusted result"]
# [inline (always)]
pub fn left12bit (self) -> & 'a mut W { self . variant (RESOLUTION_A :: LEFT12BIT) } } # [doc = "Field `FREERUN` reader - Free Running Mode Enable"]
pub type FREERUN_R = crate :: BitReader < bool > ; # [doc = "Field `FREERUN` writer - Free Running Mode Enable"]
pub type FREERUN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CONMODE` reader - Conversion Mode"]
pub type CONMODE_R = crate :: BitReader < bool > ; # [doc = "Field `CONMODE` writer - Conversion Mode"]
pub type CONMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 1:2 - Result Resolution"]
# [inline (always)]
pub fn resolution (& self) -> RESOLUTION_R { RESOLUTION_R :: new ((self . bits >> 1) & 3) } # [doc = "Bit 3 - Free Running Mode Enable"]
# [inline (always)]
pub fn freerun (& self) -> FREERUN_R { FREERUN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Conversion Mode"]
# [inline (always)]
pub fn conmode (& self) -> CONMODE_R { CONMODE_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bits 1:2 - Result Resolution"]
# [inline (always)]
# [must_use]
pub fn resolution (& mut self) -> RESOLUTION_W < 1 > { RESOLUTION_W :: new (self) } # [doc = "Bit 3 - Free Running Mode Enable"]
# [inline (always)]
# [must_use]
pub fn freerun (& mut self) -> FREERUN_W < 3 > { FREERUN_W :: new (self) } # [doc = "Bit 4 - Conversion Mode"]
# [inline (always)]
# [must_use]
pub fn conmode (& mut self) -> CONMODE_W < 4 > { CONMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVACT` reader - Event Action Select"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No event action"]
NONE = 0 , # [doc = "1: First event triggers channel 0"]
CH0 = 1 , # [doc = "2: First two events trigger channel 0,1"]
CH01 = 2 , # [doc = "3: First three events trigger channel 0,1,2"]
CH012 = 3 , # [doc = "4: Events trigger channel 0,1,2,3"]
CH0123 = 4 , # [doc = "5: First event triggers sweep"]
SWEEP = 5 , # [doc = "6: The ADC is flushed and restarted for accurate timing"]
SYNCSWEEP = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: NONE) , 1 => Some (EVACT_A :: CH0) , 2 => Some (EVACT_A :: CH01) , 3 => Some (EVACT_A :: CH012) , 4 => Some (EVACT_A :: CH0123) , 5 => Some (EVACT_A :: SWEEP) , 6 => Some (EVACT_A :: SYNCSWEEP) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == EVACT_A :: NONE } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVACT_A :: CH0 } # [doc = "Checks if the value of the field is `CH01`"]
# [inline (always)]
pub fn is_ch01 (& self) -> bool { * self == EVACT_A :: CH01 } # [doc = "Checks if the value of the field is `CH012`"]
# [inline (always)]
pub fn is_ch012 (& self) -> bool { * self == EVACT_A :: CH012 } # [doc = "Checks if the value of the field is `CH0123`"]
# [inline (always)]
pub fn is_ch0123 (& self) -> bool { * self == EVACT_A :: CH0123 } # [doc = "Checks if the value of the field is `SWEEP`"]
# [inline (always)]
pub fn is_sweep (& self) -> bool { * self == EVACT_A :: SWEEP } # [doc = "Checks if the value of the field is `SYNCSWEEP`"]
# [inline (always)]
pub fn is_syncsweep (& self) -> bool { * self == EVACT_A :: SYNCSWEEP } } # [doc = "Field `EVACT` writer - Event Action Select"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , EVCTRL_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No event action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (EVACT_A :: NONE) } # [doc = "First event triggers channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVACT_A :: CH0) } # [doc = "First two events trigger channel 0,1"]
# [inline (always)]
pub fn ch01 (self) -> & 'a mut W { self . variant (EVACT_A :: CH01) } # [doc = "First three events trigger channel 0,1,2"]
# [inline (always)]
pub fn ch012 (self) -> & 'a mut W { self . variant (EVACT_A :: CH012) } # [doc = "Events trigger channel 0,1,2,3"]
# [inline (always)]
pub fn ch0123 (self) -> & 'a mut W { self . variant (EVACT_A :: CH0123) } # [doc = "First event triggers sweep"]
# [inline (always)]
pub fn sweep (self) -> & 'a mut W { self . variant (EVACT_A :: SWEEP) } # [doc = "The ADC is flushed and restarted for accurate timing"]
# [inline (always)]
pub fn syncsweep (self) -> & 'a mut W { self . variant (EVACT_A :: SYNCSWEEP) } } # [doc = "Field `EVSEL` reader - Event Input Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Input Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: Event Channel 0,1,2,3"]
_0123 = 0 , # [doc = "1: Event Channel 1,2,3,4"]
_1234 = 1 , # [doc = "2: Event Channel 2,3,4,5"]
_2345 = 2 , # [doc = "3: Event Channel 3,4,5,6"]
_3456 = 3 , # [doc = "4: Event Channel 4,5,6,7"]
_4567 = 4 , # [doc = "5: Event Channel 5,6,7"]
_567 = 5 , # [doc = "6: Event Channel 6,7"]
_67 = 6 , # [doc = "7: Event Channel 7"]
_7 = 7 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EVSEL_A { match self . bits { 0 => EVSEL_A :: _0123 , 1 => EVSEL_A :: _1234 , 2 => EVSEL_A :: _2345 , 3 => EVSEL_A :: _3456 , 4 => EVSEL_A :: _4567 , 5 => EVSEL_A :: _567 , 6 => EVSEL_A :: _67 , 7 => EVSEL_A :: _7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0123`"]
# [inline (always)]
pub fn is_0123 (& self) -> bool { * self == EVSEL_A :: _0123 } # [doc = "Checks if the value of the field is `_1234`"]
# [inline (always)]
pub fn is_1234 (& self) -> bool { * self == EVSEL_A :: _1234 } # [doc = "Checks if the value of the field is `_2345`"]
# [inline (always)]
pub fn is_2345 (& self) -> bool { * self == EVSEL_A :: _2345 } # [doc = "Checks if the value of the field is `_3456`"]
# [inline (always)]
pub fn is_3456 (& self) -> bool { * self == EVSEL_A :: _3456 } # [doc = "Checks if the value of the field is `_4567`"]
# [inline (always)]
pub fn is_4567 (& self) -> bool { * self == EVSEL_A :: _4567 } # [doc = "Checks if the value of the field is `_567`"]
# [inline (always)]
pub fn is_567 (& self) -> bool { * self == EVSEL_A :: _567 } # [doc = "Checks if the value of the field is `_67`"]
# [inline (always)]
pub fn is_67 (& self) -> bool { * self == EVSEL_A :: _67 } # [doc = "Checks if the value of the field is `_7`"]
# [inline (always)]
pub fn is_7 (& self) -> bool { * self == EVSEL_A :: _7 } } # [doc = "Field `EVSEL` writer - Event Input Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EVCTRL_SPEC , u8 , EVSEL_A , 3 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "Event Channel 0,1,2,3"]
# [inline (always)]
pub fn _0123 (self) -> & 'a mut W { self . variant (EVSEL_A :: _0123) } # [doc = "Event Channel 1,2,3,4"]
# [inline (always)]
pub fn _1234 (self) -> & 'a mut W { self . variant (EVSEL_A :: _1234) } # [doc = "Event Channel 2,3,4,5"]
# [inline (always)]
pub fn _2345 (self) -> & 'a mut W { self . variant (EVSEL_A :: _2345) } # [doc = "Event Channel 3,4,5,6"]
# [inline (always)]
pub fn _3456 (self) -> & 'a mut W { self . variant (EVSEL_A :: _3456) } # [doc = "Event Channel 4,5,6,7"]
# [inline (always)]
pub fn _4567 (self) -> & 'a mut W { self . variant (EVSEL_A :: _4567) } # [doc = "Event Channel 5,6,7"]
# [inline (always)]
pub fn _567 (self) -> & 'a mut W { self . variant (EVSEL_A :: _567) } # [doc = "Event Channel 6,7"]
# [inline (always)]
pub fn _67 (self) -> & 'a mut W { self . variant (EVSEL_A :: _67) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn _7 (self) -> & 'a mut W { self . variant (EVSEL_A :: _7) } } # [doc = "Field `SWEEP` reader - Channel Sweep Selection"]
pub type SWEEP_R = crate :: FieldReader < u8 , SWEEP_A > ; # [doc = "Channel Sweep Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SWEEP_A { # [doc = "0: ADC Channel 0"]
_0 = 0 , # [doc = "1: ADC Channel 0,1"]
_01 = 1 , # [doc = "2: ADC Channel 0,1,2"]
_012 = 2 , # [doc = "3: ADC Channel 0,1,2,3"]
_0123 = 3 , } impl From < SWEEP_A > for u8 { # [inline (always)]
fn from (variant : SWEEP_A) -> Self { variant as _ } } impl SWEEP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SWEEP_A { match self . bits { 0 => SWEEP_A :: _0 , 1 => SWEEP_A :: _01 , 2 => SWEEP_A :: _012 , 3 => SWEEP_A :: _0123 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == SWEEP_A :: _0 } # [doc = "Checks if the value of the field is `_01`"]
# [inline (always)]
pub fn is_01 (& self) -> bool { * self == SWEEP_A :: _01 } # [doc = "Checks if the value of the field is `_012`"]
# [inline (always)]
pub fn is_012 (& self) -> bool { * self == SWEEP_A :: _012 } # [doc = "Checks if the value of the field is `_0123`"]
# [inline (always)]
pub fn is_0123 (& self) -> bool { * self == SWEEP_A :: _0123 } } # [doc = "Field `SWEEP` writer - Channel Sweep Selection"]
pub type SWEEP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EVCTRL_SPEC , u8 , SWEEP_A , 2 , O > ; impl < 'a , const O : u8 > SWEEP_W < 'a , O > { # [doc = "ADC Channel 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (SWEEP_A :: _0) } # [doc = "ADC Channel 0,1"]
# [inline (always)]
pub fn _01 (self) -> & 'a mut W { self . variant (SWEEP_A :: _01) } # [doc = "ADC Channel 0,1,2"]
# [inline (always)]
pub fn _012 (self) -> & 'a mut W { self . variant (SWEEP_A :: _012) } # [doc = "ADC Channel 0,1,2,3"]
# [inline (always)]
pub fn _0123 (self) -> & 'a mut W { self . variant (SWEEP_A :: _0123) } } impl R { # [doc = "Bits 0:2 - Event Action Select"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Event Input Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new ((self . bits >> 3) & 7) } # [doc = "Bits 6:7 - Channel Sweep Selection"]
# [inline (always)]
pub fn sweep (& self) -> SWEEP_R { SWEEP_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Event Action Select"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 0 > { EVACT_W :: new (self) } # [doc = "Bits 3:5 - Event Input Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 3 > { EVSEL_W :: new (self) } # [doc = "Bits 6:7 - Channel Sweep Selection"]
# [inline (always)]
# [must_use]
pub fn sweep (& mut self) -> SWEEP_W < 6 > { SWEEP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CH0IF` reader - Channel 0 Interrupt Flag"]
pub type CH0IF_R = crate :: BitReader < bool > ; # [doc = "Field `CH0IF` writer - Channel 0 Interrupt Flag"]
pub type CH0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH1IF` reader - Channel 1 Interrupt Flag"]
pub type CH1IF_R = crate :: BitReader < bool > ; # [doc = "Field `CH1IF` writer - Channel 1 Interrupt Flag"]
pub type CH1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH2IF` reader - Channel 2 Interrupt Flag"]
pub type CH2IF_R = crate :: BitReader < bool > ; # [doc = "Field `CH2IF` writer - Channel 2 Interrupt Flag"]
pub type CH2IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH3IF` reader - Channel 3 Interrupt Flag"]
pub type CH3IF_R = crate :: BitReader < bool > ; # [doc = "Field `CH3IF` writer - Channel 3 Interrupt Flag"]
pub type CH3IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Channel 0 Interrupt Flag"]
# [inline (always)]
pub fn ch0if (& self) -> CH0IF_R { CH0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Interrupt Flag"]
# [inline (always)]
pub fn ch1if (& self) -> CH1IF_R { CH1IF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Interrupt Flag"]
# [inline (always)]
pub fn ch2if (& self) -> CH2IF_R { CH2IF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Interrupt Flag"]
# [inline (always)]
pub fn ch3if (& self) -> CH3IF_R { CH3IF_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch0if (& mut self) -> CH0IF_W < 0 > { CH0IF_W :: new (self) } # [doc = "Bit 1 - Channel 1 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch1if (& mut self) -> CH1IF_W < 1 > { CH1IF_W :: new (self) } # [doc = "Bit 2 - Channel 2 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch2if (& mut self) -> CH2IF_W < 2 > { CH2IF_W :: new (self) } # [doc = "Bit 3 - Channel 3 Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch3if (& mut self) -> CH3IF_W < 3 > { CH3IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRESCALER (rw) register accessor: an alias for `Reg<PRESCALER_SPEC>`"]
pub type PRESCALER = crate :: Reg < prescaler :: PRESCALER_SPEC > ; # [doc = "Clock Prescaler"]
pub mod prescaler { # [doc = "Register `PRESCALER` reader"]
pub struct R (crate :: R < PRESCALER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRESCALER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRESCALER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRESCALER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRESCALER` writer"]
pub struct W (crate :: W < PRESCALER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRESCALER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRESCALER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRESCALER_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESCALER` reader - Clock Prescaler Selection"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Clock Prescaler Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: Divide clock by 4"]
DIV4 = 0 , # [doc = "1: Divide clock by 8"]
DIV8 = 1 , # [doc = "2: Divide clock by 16"]
DIV16 = 2 , # [doc = "3: Divide clock by 32"]
DIV32 = 3 , # [doc = "4: Divide clock by 64"]
DIV64 = 4 , # [doc = "5: Divide clock by 128"]
DIV128 = 5 , # [doc = "6: Divide clock by 256"]
DIV256 = 6 , # [doc = "7: Divide clock by 512"]
DIV512 = 7 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV4 , 1 => PRESCALER_A :: DIV8 , 2 => PRESCALER_A :: DIV16 , 3 => PRESCALER_A :: DIV32 , 4 => PRESCALER_A :: DIV64 , 5 => PRESCALER_A :: DIV128 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV512 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESCALER_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PRESCALER_A :: DIV512 } } # [doc = "Field `PRESCALER` writer - Clock Prescaler Selection"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PRESCALER_SPEC , u8 , PRESCALER_A , 3 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "Divide clock by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "Divide clock by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "Divide clock by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "Divide clock by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32) } # [doc = "Divide clock by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "Divide clock by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } # [doc = "Divide clock by 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "Divide clock by 512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV512) } } impl R { # [doc = "Bits 0:2 - Clock Prescaler Selection"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Clock Prescaler Selection"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 0 > { PRESCALER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prescaler](index.html) module"]
pub struct PRESCALER_SPEC ; impl crate :: RegisterSpec for PRESCALER_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prescaler::R](R) reader structure"]
impl crate :: Readable for PRESCALER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prescaler::W](W) writer structure"]
impl crate :: Writable for PRESCALER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRESCALER to value 0"]
impl crate :: Resettable for PRESCALER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "REFCTRL (rw) register accessor: an alias for `Reg<REFCTRL_SPEC>`"]
pub type REFCTRL = crate :: Reg < refctrl :: REFCTRL_SPEC > ; # [doc = "Reference Control"]
pub mod refctrl { # [doc = "Register `REFCTRL` reader"]
pub struct R (crate :: R < REFCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < REFCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < REFCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < REFCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `REFCTRL` writer"]
pub struct W (crate :: W < REFCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < REFCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < REFCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < REFCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TEMPREF` reader - Temperature Reference Enable"]
pub type TEMPREF_R = crate :: BitReader < bool > ; # [doc = "Field `TEMPREF` writer - Temperature Reference Enable"]
pub type TEMPREF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , REFCTRL_SPEC , bool , O > ; # [doc = "Field `BANDGAP` reader - Bandgap enable"]
pub type BANDGAP_R = crate :: BitReader < bool > ; # [doc = "Field `BANDGAP` writer - Bandgap enable"]
pub type BANDGAP_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , REFCTRL_SPEC , bool , O > ; # [doc = "Field `REFSEL` reader - Reference Selection"]
pub type REFSEL_R = crate :: FieldReader < u8 , REFSEL_A > ; # [doc = "Reference Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFSEL_A { # [doc = "0: Internal 1V"]
INT1V = 0 , # [doc = "1: Internal VCC / 1.6V"]
INTVCC = 1 , # [doc = "2: External reference on PORT A"]
AREFA = 2 , # [doc = "3: External reference on PORT B"]
AREFB = 3 , } impl From < REFSEL_A > for u8 { # [inline (always)]
fn from (variant : REFSEL_A) -> Self { variant as _ } } impl REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> REFSEL_A { match self . bits { 0 => REFSEL_A :: INT1V , 1 => REFSEL_A :: INTVCC , 2 => REFSEL_A :: AREFA , 3 => REFSEL_A :: AREFB , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT1V`"]
# [inline (always)]
pub fn is_int1v (& self) -> bool { * self == REFSEL_A :: INT1V } # [doc = "Checks if the value of the field is `INTVCC`"]
# [inline (always)]
pub fn is_intvcc (& self) -> bool { * self == REFSEL_A :: INTVCC } # [doc = "Checks if the value of the field is `AREFA`"]
# [inline (always)]
pub fn is_arefa (& self) -> bool { * self == REFSEL_A :: AREFA } # [doc = "Checks if the value of the field is `AREFB`"]
# [inline (always)]
pub fn is_arefb (& self) -> bool { * self == REFSEL_A :: AREFB } } # [doc = "Field `REFSEL` writer - Reference Selection"]
pub type REFSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , REFCTRL_SPEC , u8 , REFSEL_A , 2 , O > ; impl < 'a , const O : u8 > REFSEL_W < 'a , O > { # [doc = "Internal 1V"]
# [inline (always)]
pub fn int1v (self) -> & 'a mut W { self . variant (REFSEL_A :: INT1V) } # [doc = "Internal VCC / 1.6V"]
# [inline (always)]
pub fn intvcc (self) -> & 'a mut W { self . variant (REFSEL_A :: INTVCC) } # [doc = "External reference on PORT A"]
# [inline (always)]
pub fn arefa (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFA) } # [doc = "External reference on PORT B"]
# [inline (always)]
pub fn arefb (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFB) } } impl R { # [doc = "Bit 0 - Temperature Reference Enable"]
# [inline (always)]
pub fn tempref (& self) -> TEMPREF_R { TEMPREF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Bandgap enable"]
# [inline (always)]
pub fn bandgap (& self) -> BANDGAP_R { BANDGAP_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 4:5 - Reference Selection"]
# [inline (always)]
pub fn refsel (& self) -> REFSEL_R { REFSEL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bit 0 - Temperature Reference Enable"]
# [inline (always)]
# [must_use]
pub fn tempref (& mut self) -> TEMPREF_W < 0 > { TEMPREF_W :: new (self) } # [doc = "Bit 1 - Bandgap enable"]
# [inline (always)]
# [must_use]
pub fn bandgap (& mut self) -> BANDGAP_W < 1 > { BANDGAP_W :: new (self) } # [doc = "Bits 4:5 - Reference Selection"]
# [inline (always)]
# [must_use]
pub fn refsel (& mut self) -> REFSEL_W < 4 > { REFSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Reference Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [refctrl](index.html) module"]
pub struct REFCTRL_SPEC ; impl crate :: RegisterSpec for REFCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [refctrl::R](R) reader structure"]
impl crate :: Readable for REFCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [refctrl::W](W) writer structure"]
impl crate :: Writable for REFCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets REFCTRL to value 0"]
impl crate :: Resettable for REFCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary register"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "AES Module"]
pub struct AES { _marker : PhantomData < * const () > } unsafe impl Send for AES { } impl AES { # [doc = r"Pointer to the register block"]
pub const PTR : * const aes :: RegisterBlock = 0xc0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const aes :: RegisterBlock { Self :: PTR } } impl Deref for AES { type Target = aes :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for AES { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AES") . finish () } } # [doc = "AES Module"]
pub mod aes { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - AES Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - AES Status Register"]
pub status : STATUS , # [doc = "0x02 - AES State Register"]
pub state : STATE , # [doc = "0x03 - AES Key Register"]
pub key : KEY , # [doc = "0x04 - AES Interrupt Control Register"]
pub intctrl : INTCTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "AES Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `XOR` reader - State XOR Load Enable"]
pub type XOR_R = crate :: BitReader < bool > ; # [doc = "Field `XOR` writer - State XOR Load Enable"]
pub type XOR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DECRYPT` reader - Decryption / Direction"]
pub type DECRYPT_R = crate :: BitReader < bool > ; # [doc = "Field `DECRYPT` writer - Decryption / Direction"]
pub type DECRYPT_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `RESET` reader - AES Software Reset"]
pub type RESET_R = crate :: BitReader < bool > ; # [doc = "Field `RESET` writer - AES Software Reset"]
pub type RESET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `AUTO` reader - Auto Start Trigger"]
pub type AUTO_R = crate :: BitReader < bool > ; # [doc = "Field `AUTO` writer - Auto Start Trigger"]
pub type AUTO_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `START` reader - Start/Run"]
pub type START_R = crate :: BitReader < bool > ; # [doc = "Field `START` writer - Start/Run"]
pub type START_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 2 - State XOR Load Enable"]
# [inline (always)]
pub fn xor (& self) -> XOR_R { XOR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Decryption / Direction"]
# [inline (always)]
pub fn decrypt (& self) -> DECRYPT_R { DECRYPT_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - AES Software Reset"]
# [inline (always)]
pub fn reset (& self) -> RESET_R { RESET_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Auto Start Trigger"]
# [inline (always)]
pub fn auto (& self) -> AUTO_R { AUTO_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Start/Run"]
# [inline (always)]
pub fn start (& self) -> START_R { START_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 2 - State XOR Load Enable"]
# [inline (always)]
# [must_use]
pub fn xor (& mut self) -> XOR_W < 2 > { XOR_W :: new (self) } # [doc = "Bit 4 - Decryption / Direction"]
# [inline (always)]
# [must_use]
pub fn decrypt (& mut self) -> DECRYPT_W < 4 > { DECRYPT_W :: new (self) } # [doc = "Bit 5 - AES Software Reset"]
# [inline (always)]
# [must_use]
pub fn reset (& mut self) -> RESET_W < 5 > { RESET_W :: new (self) } # [doc = "Bit 6 - Auto Start Trigger"]
# [inline (always)]
# [must_use]
pub fn auto (& mut self) -> AUTO_W < 6 > { AUTO_W :: new (self) } # [doc = "Bit 7 - Start/Run"]
# [inline (always)]
# [must_use]
pub fn start (& mut self) -> START_W < 7 > { START_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "AES Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "AES Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTLVL` reader - Interrupt level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 0 > { INTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "AES Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "KEY (rw) register accessor: an alias for `Reg<KEY_SPEC>`"]
pub type KEY = crate :: Reg < key :: KEY_SPEC > ; # [doc = "AES Key Register"]
pub mod key { # [doc = "Register `KEY` reader"]
pub struct R (crate :: R < KEY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < KEY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < KEY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < KEY_SPEC >) -> Self { R (reader) } } # [doc = "Register `KEY` writer"]
pub struct W (crate :: W < KEY_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < KEY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < KEY_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < KEY_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "AES Key Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key](index.html) module"]
pub struct KEY_SPEC ; impl crate :: RegisterSpec for KEY_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [key::R](R) reader structure"]
impl crate :: Readable for KEY_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [key::W](W) writer structure"]
impl crate :: Writable for KEY_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets KEY to value 0"]
impl crate :: Resettable for KEY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATE (rw) register accessor: an alias for `Reg<STATE_SPEC>`"]
pub type STATE = crate :: Reg < state :: STATE_SPEC > ; # [doc = "AES State Register"]
pub mod state { # [doc = "Register `STATE` reader"]
pub struct R (crate :: R < STATE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATE_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATE` writer"]
pub struct W (crate :: W < STATE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "AES State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [state](index.html) module"]
pub struct STATE_SPEC ; impl crate :: RegisterSpec for STATE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [state::R](R) reader structure"]
impl crate :: Readable for STATE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [state::W](W) writer structure"]
impl crate :: Writable for STATE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATE to value 0"]
impl crate :: Resettable for STATE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "AES Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SRIF` reader - State Ready Interrupt Flag"]
pub type SRIF_R = crate :: BitReader < bool > ; # [doc = "Field `SRIF` writer - State Ready Interrupt Flag"]
pub type SRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `ERROR` reader - AES Error"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - AES Error"]
pub type ERROR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - State Ready Interrupt Flag"]
# [inline (always)]
pub fn srif (& self) -> SRIF_R { SRIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 7 - AES Error"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - State Ready Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn srif (& mut self) -> SRIF_W < 0 > { SRIF_W :: new (self) } # [doc = "Bit 7 - AES Error"]
# [inline (always)]
# [must_use]
pub fn error (& mut self) -> ERROR_W < 7 > { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "AES Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct AWEXC { _marker : PhantomData < * const () > } unsafe impl Send for AWEXC { } impl AWEXC { # [doc = r"Pointer to the register block"]
pub const PTR : * const awexc :: RegisterBlock = 0x0880 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const awexc :: RegisterBlock { Self :: PTR } } impl Deref for AWEXC { type Target = awexc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for AWEXC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AWEXC") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod awexc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Fault Detection Event Mask"]
pub fdemask : FDEMASK , # [doc = "0x03 - Fault Detection Control Register"]
pub fdctrl : FDCTRL , # [doc = "0x04 - Status Register"]
pub status : STATUS , _reserved4 : [u8 ; 0x01]
, # [doc = "0x06 - Dead Time Both Sides"]
pub dtboth : DTBOTH , # [doc = "0x07 - Dead Time Both Sides Buffer"]
pub dtbothbuf : DTBOTHBUF , # [doc = "0x08 - Dead Time Low Side"]
pub dtls : DTLS , # [doc = "0x09 - Dead Time High Side"]
pub dths : DTHS , # [doc = "0x0a - Dead Time Low Side Buffer"]
pub dtlsbuf : DTLSBUF , # [doc = "0x0b - Dead Time High Side Buffer"]
pub dthsbuf : DTHSBUF , # [doc = "0x0c - Output Override Enable"]
pub outoven : OUTOVEN , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DTICCAEN` reader - Dead Time Insertion Compare Channel A Enable"]
pub type DTICCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `DTICCAEN` writer - Dead Time Insertion Compare Channel A Enable"]
pub type DTICCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DTICCBEN` reader - Dead Time Insertion Compare Channel B Enable"]
pub type DTICCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `DTICCBEN` writer - Dead Time Insertion Compare Channel B Enable"]
pub type DTICCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DTICCCEN` reader - Dead Time Insertion Compare Channel C Enable"]
pub type DTICCCEN_R = crate :: BitReader < bool > ; # [doc = "Field `DTICCCEN` writer - Dead Time Insertion Compare Channel C Enable"]
pub type DTICCCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DTICCDEN` reader - Dead Time Insertion Compare Channel D Enable"]
pub type DTICCDEN_R = crate :: BitReader < bool > ; # [doc = "Field `DTICCDEN` writer - Dead Time Insertion Compare Channel D Enable"]
pub type DTICCDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `CWCM` reader - Common Waveform Channel Mode"]
pub type CWCM_R = crate :: BitReader < bool > ; # [doc = "Field `CWCM` writer - Common Waveform Channel Mode"]
pub type CWCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `PGM` reader - Pattern Generation Mode"]
pub type PGM_R = crate :: BitReader < bool > ; # [doc = "Field `PGM` writer - Pattern Generation Mode"]
pub type PGM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Dead Time Insertion Compare Channel A Enable"]
# [inline (always)]
pub fn dticcaen (& self) -> DTICCAEN_R { DTICCAEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Dead Time Insertion Compare Channel B Enable"]
# [inline (always)]
pub fn dticcben (& self) -> DTICCBEN_R { DTICCBEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Dead Time Insertion Compare Channel C Enable"]
# [inline (always)]
pub fn dticccen (& self) -> DTICCCEN_R { DTICCCEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Dead Time Insertion Compare Channel D Enable"]
# [inline (always)]
pub fn dticcden (& self) -> DTICCDEN_R { DTICCDEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Common Waveform Channel Mode"]
# [inline (always)]
pub fn cwcm (& self) -> CWCM_R { CWCM_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pattern Generation Mode"]
# [inline (always)]
pub fn pgm (& self) -> PGM_R { PGM_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Dead Time Insertion Compare Channel A Enable"]
# [inline (always)]
# [must_use]
pub fn dticcaen (& mut self) -> DTICCAEN_W < 0 > { DTICCAEN_W :: new (self) } # [doc = "Bit 1 - Dead Time Insertion Compare Channel B Enable"]
# [inline (always)]
# [must_use]
pub fn dticcben (& mut self) -> DTICCBEN_W < 1 > { DTICCBEN_W :: new (self) } # [doc = "Bit 2 - Dead Time Insertion Compare Channel C Enable"]
# [inline (always)]
# [must_use]
pub fn dticccen (& mut self) -> DTICCCEN_W < 2 > { DTICCCEN_W :: new (self) } # [doc = "Bit 3 - Dead Time Insertion Compare Channel D Enable"]
# [inline (always)]
# [must_use]
pub fn dticcden (& mut self) -> DTICCDEN_W < 3 > { DTICCDEN_W :: new (self) } # [doc = "Bit 4 - Common Waveform Channel Mode"]
# [inline (always)]
# [must_use]
pub fn cwcm (& mut self) -> CWCM_W < 4 > { CWCM_W :: new (self) } # [doc = "Bit 5 - Pattern Generation Mode"]
# [inline (always)]
# [must_use]
pub fn pgm (& mut self) -> PGM_W < 5 > { PGM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTBOTH (rw) register accessor: an alias for `Reg<DTBOTH_SPEC>`"]
pub type DTBOTH = crate :: Reg < dtboth :: DTBOTH_SPEC > ; # [doc = "Dead Time Both Sides"]
pub mod dtboth { # [doc = "Register `DTBOTH` reader"]
pub struct R (crate :: R < DTBOTH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTBOTH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTBOTH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTBOTH_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTBOTH` writer"]
pub struct W (crate :: W < DTBOTH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTBOTH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTBOTH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTBOTH_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time Both Sides\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dtboth](index.html) module"]
pub struct DTBOTH_SPEC ; impl crate :: RegisterSpec for DTBOTH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dtboth::R](R) reader structure"]
impl crate :: Readable for DTBOTH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dtboth::W](W) writer structure"]
impl crate :: Writable for DTBOTH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTBOTH to value 0"]
impl crate :: Resettable for DTBOTH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTBOTHBUF (rw) register accessor: an alias for `Reg<DTBOTHBUF_SPEC>`"]
pub type DTBOTHBUF = crate :: Reg < dtbothbuf :: DTBOTHBUF_SPEC > ; # [doc = "Dead Time Both Sides Buffer"]
pub mod dtbothbuf { # [doc = "Register `DTBOTHBUF` reader"]
pub struct R (crate :: R < DTBOTHBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTBOTHBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTBOTHBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTBOTHBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTBOTHBUF` writer"]
pub struct W (crate :: W < DTBOTHBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTBOTHBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTBOTHBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTBOTHBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time Both Sides Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dtbothbuf](index.html) module"]
pub struct DTBOTHBUF_SPEC ; impl crate :: RegisterSpec for DTBOTHBUF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dtbothbuf::R](R) reader structure"]
impl crate :: Readable for DTBOTHBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dtbothbuf::W](W) writer structure"]
impl crate :: Writable for DTBOTHBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTBOTHBUF to value 0"]
impl crate :: Resettable for DTBOTHBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTHS (rw) register accessor: an alias for `Reg<DTHS_SPEC>`"]
pub type DTHS = crate :: Reg < dths :: DTHS_SPEC > ; # [doc = "Dead Time High Side"]
pub mod dths { # [doc = "Register `DTHS` reader"]
pub struct R (crate :: R < DTHS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTHS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTHS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTHS_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTHS` writer"]
pub struct W (crate :: W < DTHS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTHS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTHS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTHS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time High Side\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dths](index.html) module"]
pub struct DTHS_SPEC ; impl crate :: RegisterSpec for DTHS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dths::R](R) reader structure"]
impl crate :: Readable for DTHS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dths::W](W) writer structure"]
impl crate :: Writable for DTHS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTHS to value 0"]
impl crate :: Resettable for DTHS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTHSBUF (rw) register accessor: an alias for `Reg<DTHSBUF_SPEC>`"]
pub type DTHSBUF = crate :: Reg < dthsbuf :: DTHSBUF_SPEC > ; # [doc = "Dead Time High Side Buffer"]
pub mod dthsbuf { # [doc = "Register `DTHSBUF` reader"]
pub struct R (crate :: R < DTHSBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTHSBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTHSBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTHSBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTHSBUF` writer"]
pub struct W (crate :: W < DTHSBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTHSBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTHSBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTHSBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time High Side Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dthsbuf](index.html) module"]
pub struct DTHSBUF_SPEC ; impl crate :: RegisterSpec for DTHSBUF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dthsbuf::R](R) reader structure"]
impl crate :: Readable for DTHSBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dthsbuf::W](W) writer structure"]
impl crate :: Writable for DTHSBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTHSBUF to value 0"]
impl crate :: Resettable for DTHSBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTLS (rw) register accessor: an alias for `Reg<DTLS_SPEC>`"]
pub type DTLS = crate :: Reg < dtls :: DTLS_SPEC > ; # [doc = "Dead Time Low Side"]
pub mod dtls { # [doc = "Register `DTLS` reader"]
pub struct R (crate :: R < DTLS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTLS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTLS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTLS_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTLS` writer"]
pub struct W (crate :: W < DTLS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTLS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTLS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTLS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time Low Side\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dtls](index.html) module"]
pub struct DTLS_SPEC ; impl crate :: RegisterSpec for DTLS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dtls::R](R) reader structure"]
impl crate :: Readable for DTLS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dtls::W](W) writer structure"]
impl crate :: Writable for DTLS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTLS to value 0"]
impl crate :: Resettable for DTLS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTLSBUF (rw) register accessor: an alias for `Reg<DTLSBUF_SPEC>`"]
pub type DTLSBUF = crate :: Reg < dtlsbuf :: DTLSBUF_SPEC > ; # [doc = "Dead Time Low Side Buffer"]
pub mod dtlsbuf { # [doc = "Register `DTLSBUF` reader"]
pub struct R (crate :: R < DTLSBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTLSBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTLSBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTLSBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTLSBUF` writer"]
pub struct W (crate :: W < DTLSBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTLSBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTLSBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTLSBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time Low Side Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dtlsbuf](index.html) module"]
pub struct DTLSBUF_SPEC ; impl crate :: RegisterSpec for DTLSBUF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dtlsbuf::R](R) reader structure"]
impl crate :: Readable for DTLSBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dtlsbuf::W](W) writer structure"]
impl crate :: Writable for DTLSBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTLSBUF to value 0"]
impl crate :: Resettable for DTLSBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FDCTRL (rw) register accessor: an alias for `Reg<FDCTRL_SPEC>`"]
pub type FDCTRL = crate :: Reg < fdctrl :: FDCTRL_SPEC > ; # [doc = "Fault Detection Control Register"]
pub mod fdctrl { # [doc = "Register `FDCTRL` reader"]
pub struct R (crate :: R < FDCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FDCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FDCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FDCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `FDCTRL` writer"]
pub struct W (crate :: W < FDCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FDCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FDCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FDCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `FDACT` reader - Fault Detect Action"]
pub type FDACT_R = crate :: FieldReader < u8 , FDACT_A > ; # [doc = "Fault Detect Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FDACT_A { # [doc = "0: No Fault Protection"]
NONE = 0 , # [doc = "1: Clear Output Enable Bits"]
CLEAROE = 1 , # [doc = "3: Clear I/O Port Direction Bits"]
CLEARDIR = 3 , } impl From < FDACT_A > for u8 { # [inline (always)]
fn from (variant : FDACT_A) -> Self { variant as _ } } impl FDACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FDACT_A > { match self . bits { 0 => Some (FDACT_A :: NONE) , 1 => Some (FDACT_A :: CLEAROE) , 3 => Some (FDACT_A :: CLEARDIR) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == FDACT_A :: NONE } # [doc = "Checks if the value of the field is `CLEAROE`"]
# [inline (always)]
pub fn is_clearoe (& self) -> bool { * self == FDACT_A :: CLEAROE } # [doc = "Checks if the value of the field is `CLEARDIR`"]
# [inline (always)]
pub fn is_cleardir (& self) -> bool { * self == FDACT_A :: CLEARDIR } } # [doc = "Field `FDACT` writer - Fault Detect Action"]
pub type FDACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , FDCTRL_SPEC , u8 , FDACT_A , 2 , O > ; impl < 'a , const O : u8 > FDACT_W < 'a , O > { # [doc = "No Fault Protection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (FDACT_A :: NONE) } # [doc = "Clear Output Enable Bits"]
# [inline (always)]
pub fn clearoe (self) -> & 'a mut W { self . variant (FDACT_A :: CLEAROE) } # [doc = "Clear I/O Port Direction Bits"]
# [inline (always)]
pub fn cleardir (self) -> & 'a mut W { self . variant (FDACT_A :: CLEARDIR) } } # [doc = "Field `FDMODE` reader - Fault Detect Mode"]
pub type FDMODE_R = crate :: BitReader < bool > ; # [doc = "Field `FDMODE` writer - Fault Detect Mode"]
pub type FDMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FDCTRL_SPEC , bool , O > ; # [doc = "Field `FDDBD` reader - Fault Detect on Disable Break Disable"]
pub type FDDBD_R = crate :: BitReader < bool > ; # [doc = "Field `FDDBD` writer - Fault Detect on Disable Break Disable"]
pub type FDDBD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FDCTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Fault Detect Action"]
# [inline (always)]
pub fn fdact (& self) -> FDACT_R { FDACT_R :: new (self . bits & 3) } # [doc = "Bit 2 - Fault Detect Mode"]
# [inline (always)]
pub fn fdmode (& self) -> FDMODE_R { FDMODE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Fault Detect on Disable Break Disable"]
# [inline (always)]
pub fn fddbd (& self) -> FDDBD_R { FDDBD_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Fault Detect Action"]
# [inline (always)]
# [must_use]
pub fn fdact (& mut self) -> FDACT_W < 0 > { FDACT_W :: new (self) } # [doc = "Bit 2 - Fault Detect Mode"]
# [inline (always)]
# [must_use]
pub fn fdmode (& mut self) -> FDMODE_W < 2 > { FDMODE_W :: new (self) } # [doc = "Bit 4 - Fault Detect on Disable Break Disable"]
# [inline (always)]
# [must_use]
pub fn fddbd (& mut self) -> FDDBD_W < 4 > { FDDBD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Fault Detection Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fdctrl](index.html) module"]
pub struct FDCTRL_SPEC ; impl crate :: RegisterSpec for FDCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fdctrl::R](R) reader structure"]
impl crate :: Readable for FDCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fdctrl::W](W) writer structure"]
impl crate :: Writable for FDCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FDCTRL to value 0"]
impl crate :: Resettable for FDCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FDEMASK (rw) register accessor: an alias for `Reg<FDEMASK_SPEC>`"]
pub type FDEMASK = crate :: Reg < fdemask :: FDEMASK_SPEC > ; # [doc = "Fault Detection Event Mask"]
pub mod fdemask { # [doc = "Register `FDEMASK` reader"]
pub struct R (crate :: R < FDEMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FDEMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FDEMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FDEMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `FDEMASK` writer"]
pub struct W (crate :: W < FDEMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FDEMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FDEMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FDEMASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Fault Detection Event Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fdemask](index.html) module"]
pub struct FDEMASK_SPEC ; impl crate :: RegisterSpec for FDEMASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fdemask::R](R) reader structure"]
impl crate :: Readable for FDEMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fdemask::W](W) writer structure"]
impl crate :: Writable for FDEMASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FDEMASK to value 0"]
impl crate :: Resettable for FDEMASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTOVEN (rw) register accessor: an alias for `Reg<OUTOVEN_SPEC>`"]
pub type OUTOVEN = crate :: Reg < outoven :: OUTOVEN_SPEC > ; # [doc = "Output Override Enable"]
pub mod outoven { # [doc = "Register `OUTOVEN` reader"]
pub struct R (crate :: R < OUTOVEN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTOVEN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTOVEN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTOVEN_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTOVEN` writer"]
pub struct W (crate :: W < OUTOVEN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTOVEN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTOVEN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTOVEN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Override Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outoven](index.html) module"]
pub struct OUTOVEN_SPEC ; impl crate :: RegisterSpec for OUTOVEN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outoven::R](R) reader structure"]
impl crate :: Readable for OUTOVEN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outoven::W](W) writer structure"]
impl crate :: Writable for OUTOVEN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTOVEN to value 0"]
impl crate :: Resettable for OUTOVEN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `DTLSBUFV` reader - Dead Time Low Side Buffer Valid"]
pub type DTLSBUFV_R = crate :: BitReader < bool > ; # [doc = "Field `DTLSBUFV` writer - Dead Time Low Side Buffer Valid"]
pub type DTLSBUFV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DTHSBUFV` reader - Dead Time High Side Buffer Valid"]
pub type DTHSBUFV_R = crate :: BitReader < bool > ; # [doc = "Field `DTHSBUFV` writer - Dead Time High Side Buffer Valid"]
pub type DTHSBUFV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FDF` reader - Fault Detect Flag"]
pub type FDF_R = crate :: BitReader < bool > ; # [doc = "Field `FDF` writer - Fault Detect Flag"]
pub type FDF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Dead Time Low Side Buffer Valid"]
# [inline (always)]
pub fn dtlsbufv (& self) -> DTLSBUFV_R { DTLSBUFV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Dead Time High Side Buffer Valid"]
# [inline (always)]
pub fn dthsbufv (& self) -> DTHSBUFV_R { DTHSBUFV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Fault Detect Flag"]
# [inline (always)]
pub fn fdf (& self) -> FDF_R { FDF_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Dead Time Low Side Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn dtlsbufv (& mut self) -> DTLSBUFV_W < 0 > { DTLSBUFV_W :: new (self) } # [doc = "Bit 1 - Dead Time High Side Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn dthsbufv (& mut self) -> DTHSBUFV_W < 1 > { DTHSBUFV_W :: new (self) } # [doc = "Bit 2 - Fault Detect Flag"]
# [inline (always)]
# [must_use]
pub fn fdf (& mut self) -> FDF_W < 2 > { FDF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct AWEXE { _marker : PhantomData < * const () > } unsafe impl Send for AWEXE { } impl AWEXE { # [doc = r"Pointer to the register block"]
pub const PTR : * const awexe :: RegisterBlock = 0x0a80 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const awexe :: RegisterBlock { Self :: PTR } } impl Deref for AWEXE { type Target = awexe :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for AWEXE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AWEXE") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod awexe { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Fault Detection Event Mask"]
pub fdemask : FDEMASK , # [doc = "0x03 - Fault Detection Control Register"]
pub fdctrl : FDCTRL , # [doc = "0x04 - Status Register"]
pub status : STATUS , _reserved4 : [u8 ; 0x01]
, # [doc = "0x06 - Dead Time Both Sides"]
pub dtboth : DTBOTH , # [doc = "0x07 - Dead Time Both Sides Buffer"]
pub dtbothbuf : DTBOTHBUF , # [doc = "0x08 - Dead Time Low Side"]
pub dtls : DTLS , # [doc = "0x09 - Dead Time High Side"]
pub dths : DTHS , # [doc = "0x0a - Dead Time Low Side Buffer"]
pub dtlsbuf : DTLSBUF , # [doc = "0x0b - Dead Time High Side Buffer"]
pub dthsbuf : DTHSBUF , # [doc = "0x0c - Output Override Enable"]
pub outoven : OUTOVEN , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DTICCAEN` reader - Dead Time Insertion Compare Channel A Enable"]
pub type DTICCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `DTICCAEN` writer - Dead Time Insertion Compare Channel A Enable"]
pub type DTICCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DTICCBEN` reader - Dead Time Insertion Compare Channel B Enable"]
pub type DTICCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `DTICCBEN` writer - Dead Time Insertion Compare Channel B Enable"]
pub type DTICCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DTICCCEN` reader - Dead Time Insertion Compare Channel C Enable"]
pub type DTICCCEN_R = crate :: BitReader < bool > ; # [doc = "Field `DTICCCEN` writer - Dead Time Insertion Compare Channel C Enable"]
pub type DTICCCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DTICCDEN` reader - Dead Time Insertion Compare Channel D Enable"]
pub type DTICCDEN_R = crate :: BitReader < bool > ; # [doc = "Field `DTICCDEN` writer - Dead Time Insertion Compare Channel D Enable"]
pub type DTICCDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `CWCM` reader - Common Waveform Channel Mode"]
pub type CWCM_R = crate :: BitReader < bool > ; # [doc = "Field `CWCM` writer - Common Waveform Channel Mode"]
pub type CWCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `PGM` reader - Pattern Generation Mode"]
pub type PGM_R = crate :: BitReader < bool > ; # [doc = "Field `PGM` writer - Pattern Generation Mode"]
pub type PGM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Dead Time Insertion Compare Channel A Enable"]
# [inline (always)]
pub fn dticcaen (& self) -> DTICCAEN_R { DTICCAEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Dead Time Insertion Compare Channel B Enable"]
# [inline (always)]
pub fn dticcben (& self) -> DTICCBEN_R { DTICCBEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Dead Time Insertion Compare Channel C Enable"]
# [inline (always)]
pub fn dticccen (& self) -> DTICCCEN_R { DTICCCEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Dead Time Insertion Compare Channel D Enable"]
# [inline (always)]
pub fn dticcden (& self) -> DTICCDEN_R { DTICCDEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Common Waveform Channel Mode"]
# [inline (always)]
pub fn cwcm (& self) -> CWCM_R { CWCM_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pattern Generation Mode"]
# [inline (always)]
pub fn pgm (& self) -> PGM_R { PGM_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Dead Time Insertion Compare Channel A Enable"]
# [inline (always)]
# [must_use]
pub fn dticcaen (& mut self) -> DTICCAEN_W < 0 > { DTICCAEN_W :: new (self) } # [doc = "Bit 1 - Dead Time Insertion Compare Channel B Enable"]
# [inline (always)]
# [must_use]
pub fn dticcben (& mut self) -> DTICCBEN_W < 1 > { DTICCBEN_W :: new (self) } # [doc = "Bit 2 - Dead Time Insertion Compare Channel C Enable"]
# [inline (always)]
# [must_use]
pub fn dticccen (& mut self) -> DTICCCEN_W < 2 > { DTICCCEN_W :: new (self) } # [doc = "Bit 3 - Dead Time Insertion Compare Channel D Enable"]
# [inline (always)]
# [must_use]
pub fn dticcden (& mut self) -> DTICCDEN_W < 3 > { DTICCDEN_W :: new (self) } # [doc = "Bit 4 - Common Waveform Channel Mode"]
# [inline (always)]
# [must_use]
pub fn cwcm (& mut self) -> CWCM_W < 4 > { CWCM_W :: new (self) } # [doc = "Bit 5 - Pattern Generation Mode"]
# [inline (always)]
# [must_use]
pub fn pgm (& mut self) -> PGM_W < 5 > { PGM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTBOTH (rw) register accessor: an alias for `Reg<DTBOTH_SPEC>`"]
pub type DTBOTH = crate :: Reg < dtboth :: DTBOTH_SPEC > ; # [doc = "Dead Time Both Sides"]
pub mod dtboth { # [doc = "Register `DTBOTH` reader"]
pub struct R (crate :: R < DTBOTH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTBOTH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTBOTH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTBOTH_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTBOTH` writer"]
pub struct W (crate :: W < DTBOTH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTBOTH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTBOTH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTBOTH_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time Both Sides\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dtboth](index.html) module"]
pub struct DTBOTH_SPEC ; impl crate :: RegisterSpec for DTBOTH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dtboth::R](R) reader structure"]
impl crate :: Readable for DTBOTH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dtboth::W](W) writer structure"]
impl crate :: Writable for DTBOTH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTBOTH to value 0"]
impl crate :: Resettable for DTBOTH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTBOTHBUF (rw) register accessor: an alias for `Reg<DTBOTHBUF_SPEC>`"]
pub type DTBOTHBUF = crate :: Reg < dtbothbuf :: DTBOTHBUF_SPEC > ; # [doc = "Dead Time Both Sides Buffer"]
pub mod dtbothbuf { # [doc = "Register `DTBOTHBUF` reader"]
pub struct R (crate :: R < DTBOTHBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTBOTHBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTBOTHBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTBOTHBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTBOTHBUF` writer"]
pub struct W (crate :: W < DTBOTHBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTBOTHBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTBOTHBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTBOTHBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time Both Sides Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dtbothbuf](index.html) module"]
pub struct DTBOTHBUF_SPEC ; impl crate :: RegisterSpec for DTBOTHBUF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dtbothbuf::R](R) reader structure"]
impl crate :: Readable for DTBOTHBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dtbothbuf::W](W) writer structure"]
impl crate :: Writable for DTBOTHBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTBOTHBUF to value 0"]
impl crate :: Resettable for DTBOTHBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTHS (rw) register accessor: an alias for `Reg<DTHS_SPEC>`"]
pub type DTHS = crate :: Reg < dths :: DTHS_SPEC > ; # [doc = "Dead Time High Side"]
pub mod dths { # [doc = "Register `DTHS` reader"]
pub struct R (crate :: R < DTHS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTHS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTHS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTHS_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTHS` writer"]
pub struct W (crate :: W < DTHS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTHS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTHS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTHS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time High Side\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dths](index.html) module"]
pub struct DTHS_SPEC ; impl crate :: RegisterSpec for DTHS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dths::R](R) reader structure"]
impl crate :: Readable for DTHS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dths::W](W) writer structure"]
impl crate :: Writable for DTHS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTHS to value 0"]
impl crate :: Resettable for DTHS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTHSBUF (rw) register accessor: an alias for `Reg<DTHSBUF_SPEC>`"]
pub type DTHSBUF = crate :: Reg < dthsbuf :: DTHSBUF_SPEC > ; # [doc = "Dead Time High Side Buffer"]
pub mod dthsbuf { # [doc = "Register `DTHSBUF` reader"]
pub struct R (crate :: R < DTHSBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTHSBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTHSBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTHSBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTHSBUF` writer"]
pub struct W (crate :: W < DTHSBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTHSBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTHSBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTHSBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time High Side Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dthsbuf](index.html) module"]
pub struct DTHSBUF_SPEC ; impl crate :: RegisterSpec for DTHSBUF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dthsbuf::R](R) reader structure"]
impl crate :: Readable for DTHSBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dthsbuf::W](W) writer structure"]
impl crate :: Writable for DTHSBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTHSBUF to value 0"]
impl crate :: Resettable for DTHSBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTLS (rw) register accessor: an alias for `Reg<DTLS_SPEC>`"]
pub type DTLS = crate :: Reg < dtls :: DTLS_SPEC > ; # [doc = "Dead Time Low Side"]
pub mod dtls { # [doc = "Register `DTLS` reader"]
pub struct R (crate :: R < DTLS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTLS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTLS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTLS_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTLS` writer"]
pub struct W (crate :: W < DTLS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTLS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTLS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTLS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time Low Side\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dtls](index.html) module"]
pub struct DTLS_SPEC ; impl crate :: RegisterSpec for DTLS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dtls::R](R) reader structure"]
impl crate :: Readable for DTLS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dtls::W](W) writer structure"]
impl crate :: Writable for DTLS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTLS to value 0"]
impl crate :: Resettable for DTLS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DTLSBUF (rw) register accessor: an alias for `Reg<DTLSBUF_SPEC>`"]
pub type DTLSBUF = crate :: Reg < dtlsbuf :: DTLSBUF_SPEC > ; # [doc = "Dead Time Low Side Buffer"]
pub mod dtlsbuf { # [doc = "Register `DTLSBUF` reader"]
pub struct R (crate :: R < DTLSBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DTLSBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DTLSBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DTLSBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DTLSBUF` writer"]
pub struct W (crate :: W < DTLSBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DTLSBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DTLSBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DTLSBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Dead Time Low Side Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dtlsbuf](index.html) module"]
pub struct DTLSBUF_SPEC ; impl crate :: RegisterSpec for DTLSBUF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dtlsbuf::R](R) reader structure"]
impl crate :: Readable for DTLSBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dtlsbuf::W](W) writer structure"]
impl crate :: Writable for DTLSBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DTLSBUF to value 0"]
impl crate :: Resettable for DTLSBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FDCTRL (rw) register accessor: an alias for `Reg<FDCTRL_SPEC>`"]
pub type FDCTRL = crate :: Reg < fdctrl :: FDCTRL_SPEC > ; # [doc = "Fault Detection Control Register"]
pub mod fdctrl { # [doc = "Register `FDCTRL` reader"]
pub struct R (crate :: R < FDCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FDCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FDCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FDCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `FDCTRL` writer"]
pub struct W (crate :: W < FDCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FDCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FDCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FDCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `FDACT` reader - Fault Detect Action"]
pub type FDACT_R = crate :: FieldReader < u8 , FDACT_A > ; # [doc = "Fault Detect Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FDACT_A { # [doc = "0: No Fault Protection"]
NONE = 0 , # [doc = "1: Clear Output Enable Bits"]
CLEAROE = 1 , # [doc = "3: Clear I/O Port Direction Bits"]
CLEARDIR = 3 , } impl From < FDACT_A > for u8 { # [inline (always)]
fn from (variant : FDACT_A) -> Self { variant as _ } } impl FDACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FDACT_A > { match self . bits { 0 => Some (FDACT_A :: NONE) , 1 => Some (FDACT_A :: CLEAROE) , 3 => Some (FDACT_A :: CLEARDIR) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == FDACT_A :: NONE } # [doc = "Checks if the value of the field is `CLEAROE`"]
# [inline (always)]
pub fn is_clearoe (& self) -> bool { * self == FDACT_A :: CLEAROE } # [doc = "Checks if the value of the field is `CLEARDIR`"]
# [inline (always)]
pub fn is_cleardir (& self) -> bool { * self == FDACT_A :: CLEARDIR } } # [doc = "Field `FDACT` writer - Fault Detect Action"]
pub type FDACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , FDCTRL_SPEC , u8 , FDACT_A , 2 , O > ; impl < 'a , const O : u8 > FDACT_W < 'a , O > { # [doc = "No Fault Protection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (FDACT_A :: NONE) } # [doc = "Clear Output Enable Bits"]
# [inline (always)]
pub fn clearoe (self) -> & 'a mut W { self . variant (FDACT_A :: CLEAROE) } # [doc = "Clear I/O Port Direction Bits"]
# [inline (always)]
pub fn cleardir (self) -> & 'a mut W { self . variant (FDACT_A :: CLEARDIR) } } # [doc = "Field `FDMODE` reader - Fault Detect Mode"]
pub type FDMODE_R = crate :: BitReader < bool > ; # [doc = "Field `FDMODE` writer - Fault Detect Mode"]
pub type FDMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FDCTRL_SPEC , bool , O > ; # [doc = "Field `FDDBD` reader - Fault Detect on Disable Break Disable"]
pub type FDDBD_R = crate :: BitReader < bool > ; # [doc = "Field `FDDBD` writer - Fault Detect on Disable Break Disable"]
pub type FDDBD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FDCTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Fault Detect Action"]
# [inline (always)]
pub fn fdact (& self) -> FDACT_R { FDACT_R :: new (self . bits & 3) } # [doc = "Bit 2 - Fault Detect Mode"]
# [inline (always)]
pub fn fdmode (& self) -> FDMODE_R { FDMODE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Fault Detect on Disable Break Disable"]
# [inline (always)]
pub fn fddbd (& self) -> FDDBD_R { FDDBD_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Fault Detect Action"]
# [inline (always)]
# [must_use]
pub fn fdact (& mut self) -> FDACT_W < 0 > { FDACT_W :: new (self) } # [doc = "Bit 2 - Fault Detect Mode"]
# [inline (always)]
# [must_use]
pub fn fdmode (& mut self) -> FDMODE_W < 2 > { FDMODE_W :: new (self) } # [doc = "Bit 4 - Fault Detect on Disable Break Disable"]
# [inline (always)]
# [must_use]
pub fn fddbd (& mut self) -> FDDBD_W < 4 > { FDDBD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Fault Detection Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fdctrl](index.html) module"]
pub struct FDCTRL_SPEC ; impl crate :: RegisterSpec for FDCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fdctrl::R](R) reader structure"]
impl crate :: Readable for FDCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fdctrl::W](W) writer structure"]
impl crate :: Writable for FDCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FDCTRL to value 0"]
impl crate :: Resettable for FDCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FDEMASK (rw) register accessor: an alias for `Reg<FDEMASK_SPEC>`"]
pub type FDEMASK = crate :: Reg < fdemask :: FDEMASK_SPEC > ; # [doc = "Fault Detection Event Mask"]
pub mod fdemask { # [doc = "Register `FDEMASK` reader"]
pub struct R (crate :: R < FDEMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FDEMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FDEMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FDEMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `FDEMASK` writer"]
pub struct W (crate :: W < FDEMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FDEMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FDEMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FDEMASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Fault Detection Event Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fdemask](index.html) module"]
pub struct FDEMASK_SPEC ; impl crate :: RegisterSpec for FDEMASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fdemask::R](R) reader structure"]
impl crate :: Readable for FDEMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fdemask::W](W) writer structure"]
impl crate :: Writable for FDEMASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FDEMASK to value 0"]
impl crate :: Resettable for FDEMASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTOVEN (rw) register accessor: an alias for `Reg<OUTOVEN_SPEC>`"]
pub type OUTOVEN = crate :: Reg < outoven :: OUTOVEN_SPEC > ; # [doc = "Output Override Enable"]
pub mod outoven { # [doc = "Register `OUTOVEN` reader"]
pub struct R (crate :: R < OUTOVEN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTOVEN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTOVEN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTOVEN_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTOVEN` writer"]
pub struct W (crate :: W < OUTOVEN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTOVEN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTOVEN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTOVEN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Output Override Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outoven](index.html) module"]
pub struct OUTOVEN_SPEC ; impl crate :: RegisterSpec for OUTOVEN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outoven::R](R) reader structure"]
impl crate :: Readable for OUTOVEN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outoven::W](W) writer structure"]
impl crate :: Writable for OUTOVEN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTOVEN to value 0"]
impl crate :: Resettable for OUTOVEN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `DTLSBUFV` reader - Dead Time Low Side Buffer Valid"]
pub type DTLSBUFV_R = crate :: BitReader < bool > ; # [doc = "Field `DTLSBUFV` writer - Dead Time Low Side Buffer Valid"]
pub type DTLSBUFV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DTHSBUFV` reader - Dead Time High Side Buffer Valid"]
pub type DTHSBUFV_R = crate :: BitReader < bool > ; # [doc = "Field `DTHSBUFV` writer - Dead Time High Side Buffer Valid"]
pub type DTHSBUFV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FDF` reader - Fault Detect Flag"]
pub type FDF_R = crate :: BitReader < bool > ; # [doc = "Field `FDF` writer - Fault Detect Flag"]
pub type FDF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Dead Time Low Side Buffer Valid"]
# [inline (always)]
pub fn dtlsbufv (& self) -> DTLSBUFV_R { DTLSBUFV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Dead Time High Side Buffer Valid"]
# [inline (always)]
pub fn dthsbufv (& self) -> DTHSBUFV_R { DTHSBUFV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Fault Detect Flag"]
# [inline (always)]
pub fn fdf (& self) -> FDF_R { FDF_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Dead Time Low Side Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn dtlsbufv (& mut self) -> DTLSBUFV_W < 0 > { DTLSBUFV_W :: new (self) } # [doc = "Bit 1 - Dead Time High Side Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn dthsbufv (& mut self) -> DTHSBUFV_W < 1 > { DTHSBUFV_W :: new (self) } # [doc = "Bit 2 - Fault Detect Flag"]
# [inline (always)]
# [must_use]
pub fn fdf (& mut self) -> FDF_W < 2 > { FDF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Clock System"]
pub struct CLK { _marker : PhantomData < * const () > } unsafe impl Send for CLK { } impl CLK { # [doc = r"Pointer to the register block"]
pub const PTR : * const clk :: RegisterBlock = 0x40 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const clk :: RegisterBlock { Self :: PTR } } impl Deref for CLK { type Target = clk :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CLK { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CLK") . finish () } } # [doc = "Clock System"]
pub mod clk { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - Prescaler Control Register"]
pub psctrl : PSCTRL , # [doc = "0x02 - Lock register"]
pub lock : LOCK , # [doc = "0x03 - RTC Control Register"]
pub rtcctrl : RTCCTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SCLKSEL` reader - System Clock Selection"]
pub type SCLKSEL_R = crate :: FieldReader < u8 , SCLKSEL_A > ; # [doc = "System Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SCLKSEL_A { # [doc = "0: Internal 2MHz RC Oscillator"]
RC2M = 0 , # [doc = "1: Internal 32MHz RC Oscillator"]
RC32M = 1 , # [doc = "2: Internal 32kHz RC Oscillator"]
RC32K = 2 , # [doc = "3: External Crystal Oscillator or Clock"]
XOSC = 3 , # [doc = "4: Phase Locked Loop"]
PLL = 4 , } impl From < SCLKSEL_A > for u8 { # [inline (always)]
fn from (variant : SCLKSEL_A) -> Self { variant as _ } } impl SCLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SCLKSEL_A > { match self . bits { 0 => Some (SCLKSEL_A :: RC2M) , 1 => Some (SCLKSEL_A :: RC32M) , 2 => Some (SCLKSEL_A :: RC32K) , 3 => Some (SCLKSEL_A :: XOSC) , 4 => Some (SCLKSEL_A :: PLL) , _ => None , } } # [doc = "Checks if the value of the field is `RC2M`"]
# [inline (always)]
pub fn is_rc2m (& self) -> bool { * self == SCLKSEL_A :: RC2M } # [doc = "Checks if the value of the field is `RC32M`"]
# [inline (always)]
pub fn is_rc32m (& self) -> bool { * self == SCLKSEL_A :: RC32M } # [doc = "Checks if the value of the field is `RC32K`"]
# [inline (always)]
pub fn is_rc32k (& self) -> bool { * self == SCLKSEL_A :: RC32K } # [doc = "Checks if the value of the field is `XOSC`"]
# [inline (always)]
pub fn is_xosc (& self) -> bool { * self == SCLKSEL_A :: XOSC } # [doc = "Checks if the value of the field is `PLL`"]
# [inline (always)]
pub fn is_pll (& self) -> bool { * self == SCLKSEL_A :: PLL } } # [doc = "Field `SCLKSEL` writer - System Clock Selection"]
pub type SCLKSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRL_SPEC , u8 , SCLKSEL_A , 3 , O > ; impl < 'a , const O : u8 > SCLKSEL_W < 'a , O > { # [doc = "Internal 2MHz RC Oscillator"]
# [inline (always)]
pub fn rc2m (self) -> & 'a mut W { self . variant (SCLKSEL_A :: RC2M) } # [doc = "Internal 32MHz RC Oscillator"]
# [inline (always)]
pub fn rc32m (self) -> & 'a mut W { self . variant (SCLKSEL_A :: RC32M) } # [doc = "Internal 32kHz RC Oscillator"]
# [inline (always)]
pub fn rc32k (self) -> & 'a mut W { self . variant (SCLKSEL_A :: RC32K) } # [doc = "External Crystal Oscillator or Clock"]
# [inline (always)]
pub fn xosc (self) -> & 'a mut W { self . variant (SCLKSEL_A :: XOSC) } # [doc = "Phase Locked Loop"]
# [inline (always)]
pub fn pll (self) -> & 'a mut W { self . variant (SCLKSEL_A :: PLL) } } impl R { # [doc = "Bits 0:2 - System Clock Selection"]
# [inline (always)]
pub fn sclksel (& self) -> SCLKSEL_R { SCLKSEL_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - System Clock Selection"]
# [inline (always)]
# [must_use]
pub fn sclksel (& mut self) -> SCLKSEL_W < 0 > { SCLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOCK (rw) register accessor: an alias for `Reg<LOCK_SPEC>`"]
pub type LOCK = crate :: Reg < lock :: LOCK_SPEC > ; # [doc = "Lock register"]
pub mod lock { # [doc = "Register `LOCK` reader"]
pub struct R (crate :: R < LOCK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCK_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCK` writer"]
pub struct W (crate :: W < LOCK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCK_SPEC >) -> Self { W (writer) } } # [doc = "Field `LOCK` reader - Clock System Lock"]
pub type LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `LOCK` writer - Clock System Lock"]
pub type LOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , LOCK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Clock System Lock"]
# [inline (always)]
pub fn lock (& self) -> LOCK_R { LOCK_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Clock System Lock"]
# [inline (always)]
# [must_use]
pub fn lock (& mut self) -> LOCK_W < 0 > { LOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Lock register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lock](index.html) module"]
pub struct LOCK_SPEC ; impl crate :: RegisterSpec for LOCK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lock::R](R) reader structure"]
impl crate :: Readable for LOCK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lock::W](W) writer structure"]
impl crate :: Writable for LOCK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOCK to value 0"]
impl crate :: Resettable for LOCK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PSCTRL (rw) register accessor: an alias for `Reg<PSCTRL_SPEC>`"]
pub type PSCTRL = crate :: Reg < psctrl :: PSCTRL_SPEC > ; # [doc = "Prescaler Control Register"]
pub mod psctrl { # [doc = "Register `PSCTRL` reader"]
pub struct R (crate :: R < PSCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PSCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PSCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PSCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PSCTRL` writer"]
pub struct W (crate :: W < PSCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PSCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PSCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PSCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PSBCDIV` reader - Prescaler B and C Division factor"]
pub type PSBCDIV_R = crate :: FieldReader < u8 , PSBCDIV_A > ; # [doc = "Prescaler B and C Division factor\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PSBCDIV_A { # [doc = "0: Divide B by 1 and C by 1"]
_1_1 = 0 , # [doc = "1: Divide B by 1 and C by 2"]
_1_2 = 1 , # [doc = "2: Divide B by 4 and C by 1"]
_4_1 = 2 , # [doc = "3: Divide B by 2 and C by 2"]
_2_2 = 3 , } impl From < PSBCDIV_A > for u8 { # [inline (always)]
fn from (variant : PSBCDIV_A) -> Self { variant as _ } } impl PSBCDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PSBCDIV_A { match self . bits { 0 => PSBCDIV_A :: _1_1 , 1 => PSBCDIV_A :: _1_2 , 2 => PSBCDIV_A :: _4_1 , 3 => PSBCDIV_A :: _2_2 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1_1`"]
# [inline (always)]
pub fn is_1_1 (& self) -> bool { * self == PSBCDIV_A :: _1_1 } # [doc = "Checks if the value of the field is `_1_2`"]
# [inline (always)]
pub fn is_1_2 (& self) -> bool { * self == PSBCDIV_A :: _1_2 } # [doc = "Checks if the value of the field is `_4_1`"]
# [inline (always)]
pub fn is_4_1 (& self) -> bool { * self == PSBCDIV_A :: _4_1 } # [doc = "Checks if the value of the field is `_2_2`"]
# [inline (always)]
pub fn is_2_2 (& self) -> bool { * self == PSBCDIV_A :: _2_2 } } # [doc = "Field `PSBCDIV` writer - Prescaler B and C Division factor"]
pub type PSBCDIV_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PSCTRL_SPEC , u8 , PSBCDIV_A , 2 , O > ; impl < 'a , const O : u8 > PSBCDIV_W < 'a , O > { # [doc = "Divide B by 1 and C by 1"]
# [inline (always)]
pub fn _1_1 (self) -> & 'a mut W { self . variant (PSBCDIV_A :: _1_1) } # [doc = "Divide B by 1 and C by 2"]
# [inline (always)]
pub fn _1_2 (self) -> & 'a mut W { self . variant (PSBCDIV_A :: _1_2) } # [doc = "Divide B by 4 and C by 1"]
# [inline (always)]
pub fn _4_1 (self) -> & 'a mut W { self . variant (PSBCDIV_A :: _4_1) } # [doc = "Divide B by 2 and C by 2"]
# [inline (always)]
pub fn _2_2 (self) -> & 'a mut W { self . variant (PSBCDIV_A :: _2_2) } } # [doc = "Field `PSADIV` reader - Prescaler A Division Factor"]
pub type PSADIV_R = crate :: FieldReader < u8 , PSADIV_A > ; # [doc = "Prescaler A Division Factor\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PSADIV_A { # [doc = "0: Divide by 1"]
_1 = 0 , # [doc = "1: Divide by 2"]
_2 = 1 , # [doc = "3: Divide by 4"]
_4 = 3 , # [doc = "5: Divide by 8"]
_8 = 5 , # [doc = "7: Divide by 16"]
_16 = 7 , # [doc = "9: Divide by 32"]
_32 = 9 , # [doc = "11: Divide by 64"]
_64 = 11 , # [doc = "13: Divide by 128"]
_128 = 13 , # [doc = "15: Divide by 256"]
_256 = 15 , # [doc = "17: Divide by 512"]
_512 = 17 , } impl From < PSADIV_A > for u8 { # [inline (always)]
fn from (variant : PSADIV_A) -> Self { variant as _ } } impl PSADIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PSADIV_A > { match self . bits { 0 => Some (PSADIV_A :: _1) , 1 => Some (PSADIV_A :: _2) , 3 => Some (PSADIV_A :: _4) , 5 => Some (PSADIV_A :: _8) , 7 => Some (PSADIV_A :: _16) , 9 => Some (PSADIV_A :: _32) , 11 => Some (PSADIV_A :: _64) , 13 => Some (PSADIV_A :: _128) , 15 => Some (PSADIV_A :: _256) , 17 => Some (PSADIV_A :: _512) , _ => None , } } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == PSADIV_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == PSADIV_A :: _2 } # [doc = "Checks if the value of the field is `_4`"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == PSADIV_A :: _4 } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == PSADIV_A :: _8 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == PSADIV_A :: _16 } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == PSADIV_A :: _32 } # [doc = "Checks if the value of the field is `_64`"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == PSADIV_A :: _64 } # [doc = "Checks if the value of the field is `_128`"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == PSADIV_A :: _128 } # [doc = "Checks if the value of the field is `_256`"]
# [inline (always)]
pub fn is_256 (& self) -> bool { * self == PSADIV_A :: _256 } # [doc = "Checks if the value of the field is `_512`"]
# [inline (always)]
pub fn is_512 (& self) -> bool { * self == PSADIV_A :: _512 } } # [doc = "Field `PSADIV` writer - Prescaler A Division Factor"]
pub type PSADIV_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PSCTRL_SPEC , u8 , PSADIV_A , 5 , O > ; impl < 'a , const O : u8 > PSADIV_W < 'a , O > { # [doc = "Divide by 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (PSADIV_A :: _1) } # [doc = "Divide by 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (PSADIV_A :: _2) } # [doc = "Divide by 4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut W { self . variant (PSADIV_A :: _4) } # [doc = "Divide by 8"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut W { self . variant (PSADIV_A :: _8) } # [doc = "Divide by 16"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (PSADIV_A :: _16) } # [doc = "Divide by 32"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut W { self . variant (PSADIV_A :: _32) } # [doc = "Divide by 64"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut W { self . variant (PSADIV_A :: _64) } # [doc = "Divide by 128"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut W { self . variant (PSADIV_A :: _128) } # [doc = "Divide by 256"]
# [inline (always)]
pub fn _256 (self) -> & 'a mut W { self . variant (PSADIV_A :: _256) } # [doc = "Divide by 512"]
# [inline (always)]
pub fn _512 (self) -> & 'a mut W { self . variant (PSADIV_A :: _512) } } impl R { # [doc = "Bits 0:1 - Prescaler B and C Division factor"]
# [inline (always)]
pub fn psbcdiv (& self) -> PSBCDIV_R { PSBCDIV_R :: new (self . bits & 3) } # [doc = "Bits 2:6 - Prescaler A Division Factor"]
# [inline (always)]
pub fn psadiv (& self) -> PSADIV_R { PSADIV_R :: new ((self . bits >> 2) & 0x1f) } } impl W { # [doc = "Bits 0:1 - Prescaler B and C Division factor"]
# [inline (always)]
# [must_use]
pub fn psbcdiv (& mut self) -> PSBCDIV_W < 0 > { PSBCDIV_W :: new (self) } # [doc = "Bits 2:6 - Prescaler A Division Factor"]
# [inline (always)]
# [must_use]
pub fn psadiv (& mut self) -> PSADIV_W < 2 > { PSADIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Prescaler Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [psctrl](index.html) module"]
pub struct PSCTRL_SPEC ; impl crate :: RegisterSpec for PSCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [psctrl::R](R) reader structure"]
impl crate :: Readable for PSCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [psctrl::W](W) writer structure"]
impl crate :: Writable for PSCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PSCTRL to value 0"]
impl crate :: Resettable for PSCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RTCCTRL (rw) register accessor: an alias for `Reg<RTCCTRL_SPEC>`"]
pub type RTCCTRL = crate :: Reg < rtcctrl :: RTCCTRL_SPEC > ; # [doc = "RTC Control Register"]
pub mod rtcctrl { # [doc = "Register `RTCCTRL` reader"]
pub struct R (crate :: R < RTCCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RTCCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RTCCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RTCCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RTCCTRL` writer"]
pub struct W (crate :: W < RTCCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RTCCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RTCCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RTCCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RTCEN` reader - RTC Clock Source Enable"]
pub type RTCEN_R = crate :: BitReader < bool > ; # [doc = "Field `RTCEN` writer - RTC Clock Source Enable"]
pub type RTCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , RTCCTRL_SPEC , bool , O > ; # [doc = "Field `RTCSRC` reader - RTC Clock Source"]
pub type RTCSRC_R = crate :: FieldReader < u8 , RTCSRC_A > ; # [doc = "RTC Clock Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RTCSRC_A { # [doc = "0: 1kHz from internal 32kHz ULP"]
ULP = 0 , # [doc = "1: 1kHz from 32kHz crystal oscillator on TOSC"]
TOSC = 1 , # [doc = "2: 1kHz from internal 32kHz RC oscillator"]
RCOSC = 2 , # [doc = "5: 32kHz from 32kHz crystal oscillator on TOSC"]
TOSC32 = 5 , } impl From < RTCSRC_A > for u8 { # [inline (always)]
fn from (variant : RTCSRC_A) -> Self { variant as _ } } impl RTCSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RTCSRC_A > { match self . bits { 0 => Some (RTCSRC_A :: ULP) , 1 => Some (RTCSRC_A :: TOSC) , 2 => Some (RTCSRC_A :: RCOSC) , 5 => Some (RTCSRC_A :: TOSC32) , _ => None , } } # [doc = "Checks if the value of the field is `ULP`"]
# [inline (always)]
pub fn is_ulp (& self) -> bool { * self == RTCSRC_A :: ULP } # [doc = "Checks if the value of the field is `TOSC`"]
# [inline (always)]
pub fn is_tosc (& self) -> bool { * self == RTCSRC_A :: TOSC } # [doc = "Checks if the value of the field is `RCOSC`"]
# [inline (always)]
pub fn is_rcosc (& self) -> bool { * self == RTCSRC_A :: RCOSC } # [doc = "Checks if the value of the field is `TOSC32`"]
# [inline (always)]
pub fn is_tosc32 (& self) -> bool { * self == RTCSRC_A :: TOSC32 } } # [doc = "Field `RTCSRC` writer - RTC Clock Source"]
pub type RTCSRC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , RTCCTRL_SPEC , u8 , RTCSRC_A , 3 , O > ; impl < 'a , const O : u8 > RTCSRC_W < 'a , O > { # [doc = "1kHz from internal 32kHz ULP"]
# [inline (always)]
pub fn ulp (self) -> & 'a mut W { self . variant (RTCSRC_A :: ULP) } # [doc = "1kHz from 32kHz crystal oscillator on TOSC"]
# [inline (always)]
pub fn tosc (self) -> & 'a mut W { self . variant (RTCSRC_A :: TOSC) } # [doc = "1kHz from internal 32kHz RC oscillator"]
# [inline (always)]
pub fn rcosc (self) -> & 'a mut W { self . variant (RTCSRC_A :: RCOSC) } # [doc = "32kHz from 32kHz crystal oscillator on TOSC"]
# [inline (always)]
pub fn tosc32 (self) -> & 'a mut W { self . variant (RTCSRC_A :: TOSC32) } } impl R { # [doc = "Bit 0 - RTC Clock Source Enable"]
# [inline (always)]
pub fn rtcen (& self) -> RTCEN_R { RTCEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - RTC Clock Source"]
# [inline (always)]
pub fn rtcsrc (& self) -> RTCSRC_R { RTCSRC_R :: new ((self . bits >> 1) & 7) } } impl W { # [doc = "Bit 0 - RTC Clock Source Enable"]
# [inline (always)]
# [must_use]
pub fn rtcen (& mut self) -> RTCEN_W < 0 > { RTCEN_W :: new (self) } # [doc = "Bits 1:3 - RTC Clock Source"]
# [inline (always)]
# [must_use]
pub fn rtcsrc (& mut self) -> RTCSRC_W < 1 > { RTCSRC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "RTC Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtcctrl](index.html) module"]
pub struct RTCCTRL_SPEC ; impl crate :: RegisterSpec for RTCCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rtcctrl::R](R) reader structure"]
impl crate :: Readable for RTCCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rtcctrl::W](W) writer structure"]
impl crate :: Writable for RTCCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RTCCTRL to value 0"]
impl crate :: Resettable for RTCCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "CPU"]
pub struct CPU { _marker : PhantomData < * const () > } unsafe impl Send for CPU { } impl CPU { # [doc = r"Pointer to the register block"]
pub const PTR : * const cpu :: RegisterBlock = 0x34 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const cpu :: RegisterBlock { Self :: PTR } } impl Deref for CPU { type Target = cpu :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for CPU { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CPU") . finish () } } # [doc = "CPU"]
pub mod cpu { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Configuration Change Protection"]
pub ccp : CCP , _reserved1 : [u8 ; 0x03]
, # [doc = "0x04 - Ramp D"]
pub rampd : RAMPD , # [doc = "0x05 - Ramp X"]
pub rampx : RAMPX , # [doc = "0x06 - Ramp Y"]
pub rampy : RAMPY , # [doc = "0x07 - Ramp Z"]
pub rampz : RAMPZ , # [doc = "0x08 - Extended Indirect Jump"]
pub eind : EIND , # [doc = "0x09 - Stack Pointer Low"]
pub spl : SPL , # [doc = "0x0a - Stack Pointer High"]
pub sph : SPH , } # [doc = "CCP (rw) register accessor: an alias for `Reg<CCP_SPEC>`"]
pub type CCP = crate :: Reg < ccp :: CCP_SPEC > ; # [doc = "Configuration Change Protection"]
pub mod ccp { # [doc = "Register `CCP` reader"]
pub struct R (crate :: R < CCP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCP_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCP` writer"]
pub struct W (crate :: W < CCP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCP_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCP` reader - CCP signature"]
pub type CCP_R = crate :: FieldReader < u8 , CCP_A > ; # [doc = "CCP signature\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCP_A { # [doc = "157: SPM Instruction Protection"]
SPM = 157 , # [doc = "216: IO Register Protection"]
IOREG = 216 , } impl From < CCP_A > for u8 { # [inline (always)]
fn from (variant : CCP_A) -> Self { variant as _ } } impl CCP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CCP_A > { match self . bits { 157 => Some (CCP_A :: SPM) , 216 => Some (CCP_A :: IOREG) , _ => None , } } # [doc = "Checks if the value of the field is `SPM`"]
# [inline (always)]
pub fn is_spm (& self) -> bool { * self == CCP_A :: SPM } # [doc = "Checks if the value of the field is `IOREG`"]
# [inline (always)]
pub fn is_ioreg (& self) -> bool { * self == CCP_A :: IOREG } } # [doc = "Field `CCP` writer - CCP signature"]
pub type CCP_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CCP_SPEC , u8 , CCP_A , 8 , O > ; impl < 'a , const O : u8 > CCP_W < 'a , O > { # [doc = "SPM Instruction Protection"]
# [inline (always)]
pub fn spm (self) -> & 'a mut W { self . variant (CCP_A :: SPM) } # [doc = "IO Register Protection"]
# [inline (always)]
pub fn ioreg (self) -> & 'a mut W { self . variant (CCP_A :: IOREG) } } impl R { # [doc = "Bits 0:7 - CCP signature"]
# [inline (always)]
pub fn ccp (& self) -> CCP_R { CCP_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - CCP signature"]
# [inline (always)]
# [must_use]
pub fn ccp (& mut self) -> CCP_W < 0 > { CCP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Configuration Change Protection\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccp](index.html) module"]
pub struct CCP_SPEC ; impl crate :: RegisterSpec for CCP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ccp::R](R) reader structure"]
impl crate :: Readable for CCP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccp::W](W) writer structure"]
impl crate :: Writable for CCP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCP to value 0"]
impl crate :: Resettable for CCP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EIND (rw) register accessor: an alias for `Reg<EIND_SPEC>`"]
pub type EIND = crate :: Reg < eind :: EIND_SPEC > ; # [doc = "Extended Indirect Jump"]
pub mod eind { # [doc = "Register `EIND` reader"]
pub struct R (crate :: R < EIND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EIND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EIND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EIND_SPEC >) -> Self { R (reader) } } # [doc = "Register `EIND` writer"]
pub struct W (crate :: W < EIND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EIND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EIND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EIND_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Extended Indirect Jump\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eind](index.html) module"]
pub struct EIND_SPEC ; impl crate :: RegisterSpec for EIND_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [eind::R](R) reader structure"]
impl crate :: Readable for EIND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [eind::W](W) writer structure"]
impl crate :: Writable for EIND_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EIND to value 0"]
impl crate :: Resettable for EIND_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RAMPD (rw) register accessor: an alias for `Reg<RAMPD_SPEC>`"]
pub type RAMPD = crate :: Reg < rampd :: RAMPD_SPEC > ; # [doc = "Ramp D"]
pub mod rampd { # [doc = "Register `RAMPD` reader"]
pub struct R (crate :: R < RAMPD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAMPD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAMPD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAMPD_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAMPD` writer"]
pub struct W (crate :: W < RAMPD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAMPD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAMPD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAMPD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Ramp D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rampd](index.html) module"]
pub struct RAMPD_SPEC ; impl crate :: RegisterSpec for RAMPD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rampd::R](R) reader structure"]
impl crate :: Readable for RAMPD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rampd::W](W) writer structure"]
impl crate :: Writable for RAMPD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RAMPD to value 0"]
impl crate :: Resettable for RAMPD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RAMPX (rw) register accessor: an alias for `Reg<RAMPX_SPEC>`"]
pub type RAMPX = crate :: Reg < rampx :: RAMPX_SPEC > ; # [doc = "Ramp X"]
pub mod rampx { # [doc = "Register `RAMPX` reader"]
pub struct R (crate :: R < RAMPX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAMPX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAMPX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAMPX_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAMPX` writer"]
pub struct W (crate :: W < RAMPX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAMPX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAMPX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAMPX_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Ramp X\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rampx](index.html) module"]
pub struct RAMPX_SPEC ; impl crate :: RegisterSpec for RAMPX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rampx::R](R) reader structure"]
impl crate :: Readable for RAMPX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rampx::W](W) writer structure"]
impl crate :: Writable for RAMPX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RAMPX to value 0"]
impl crate :: Resettable for RAMPX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RAMPY (rw) register accessor: an alias for `Reg<RAMPY_SPEC>`"]
pub type RAMPY = crate :: Reg < rampy :: RAMPY_SPEC > ; # [doc = "Ramp Y"]
pub mod rampy { # [doc = "Register `RAMPY` reader"]
pub struct R (crate :: R < RAMPY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAMPY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAMPY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAMPY_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAMPY` writer"]
pub struct W (crate :: W < RAMPY_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAMPY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAMPY_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAMPY_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Ramp Y\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rampy](index.html) module"]
pub struct RAMPY_SPEC ; impl crate :: RegisterSpec for RAMPY_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rampy::R](R) reader structure"]
impl crate :: Readable for RAMPY_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rampy::W](W) writer structure"]
impl crate :: Writable for RAMPY_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RAMPY to value 0"]
impl crate :: Resettable for RAMPY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RAMPZ (rw) register accessor: an alias for `Reg<RAMPZ_SPEC>`"]
pub type RAMPZ = crate :: Reg < rampz :: RAMPZ_SPEC > ; # [doc = "Ramp Z"]
pub mod rampz { # [doc = "Register `RAMPZ` reader"]
pub struct R (crate :: R < RAMPZ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RAMPZ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RAMPZ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RAMPZ_SPEC >) -> Self { R (reader) } } # [doc = "Register `RAMPZ` writer"]
pub struct W (crate :: W < RAMPZ_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RAMPZ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RAMPZ_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RAMPZ_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Ramp Z\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rampz](index.html) module"]
pub struct RAMPZ_SPEC ; impl crate :: RegisterSpec for RAMPZ_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rampz::R](R) reader structure"]
impl crate :: Readable for RAMPZ_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rampz::W](W) writer structure"]
impl crate :: Writable for RAMPZ_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RAMPZ to value 0"]
impl crate :: Resettable for RAMPZ_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPH (rw) register accessor: an alias for `Reg<SPH_SPEC>`"]
pub type SPH = crate :: Reg < sph :: SPH_SPEC > ; # [doc = "Stack Pointer High"]
pub mod sph { # [doc = "Register `SPH` reader"]
pub struct R (crate :: R < SPH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPH_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPH` writer"]
pub struct W (crate :: W < SPH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPH_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Stack Pointer High\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sph](index.html) module"]
pub struct SPH_SPEC ; impl crate :: RegisterSpec for SPH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sph::R](R) reader structure"]
impl crate :: Readable for SPH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sph::W](W) writer structure"]
impl crate :: Writable for SPH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPH to value 0"]
impl crate :: Resettable for SPH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SPL (rw) register accessor: an alias for `Reg<SPL_SPEC>`"]
pub type SPL = crate :: Reg < spl :: SPL_SPEC > ; # [doc = "Stack Pointer Low"]
pub mod spl { # [doc = "Register `SPL` reader"]
pub struct R (crate :: R < SPL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SPL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SPL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SPL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SPL` writer"]
pub struct W (crate :: W < SPL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SPL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SPL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SPL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Stack Pointer Low\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spl](index.html) module"]
pub struct SPL_SPEC ; impl crate :: RegisterSpec for SPL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [spl::R](R) reader structure"]
impl crate :: Readable for SPL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [spl::W](W) writer structure"]
impl crate :: Writable for SPL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SPL to value 0"]
impl crate :: Resettable for SPL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Digital/Analog Converter"]
pub struct DACA { _marker : PhantomData < * const () > } unsafe impl Send for DACA { } impl DACA { # [doc = r"Pointer to the register block"]
pub const PTR : * const daca :: RegisterBlock = 0x0300 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const daca :: RegisterBlock { Self :: PTR } } impl Deref for DACA { type Target = daca :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DACA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DACA") . finish () } } # [doc = "Digital/Analog Converter"]
pub mod daca { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Event Input Control"]
pub evctrl : EVCTRL , # [doc = "0x04 - Timing Control"]
pub timctrl : TIMCTRL , # [doc = "0x05 - Status"]
pub status : STATUS , _reserved6 : [u8 ; 0x02]
, # [doc = "0x08 - Gain Calibration"]
pub gaincal : GAINCAL , # [doc = "0x09 - Offset Calibration"]
pub offsetcal : OFFSETCAL , _reserved8 : [u8 ; 0x0e]
, # [doc = "0x18 - Channel 0 Data"]
pub ch0data : CH0DATA , # [doc = "0x1a - Channel 1 Data"]
pub ch1data : CH1DATA , } # [doc = "CH0DATA (rw) register accessor: an alias for `Reg<CH0DATA_SPEC>`"]
pub type CH0DATA = crate :: Reg < ch0data :: CH0DATA_SPEC > ; # [doc = "Channel 0 Data"]
pub mod ch0data { # [doc = "Register `CH0DATA` reader"]
pub struct R (crate :: R < CH0DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH0DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH0DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH0DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH0DATA` writer"]
pub struct W (crate :: W < CH0DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH0DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH0DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH0DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 0 Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch0data](index.html) module"]
pub struct CH0DATA_SPEC ; impl crate :: RegisterSpec for CH0DATA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch0data::R](R) reader structure"]
impl crate :: Readable for CH0DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch0data::W](W) writer structure"]
impl crate :: Writable for CH0DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH0DATA to value 0"]
impl crate :: Resettable for CH0DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH1DATA (rw) register accessor: an alias for `Reg<CH1DATA_SPEC>`"]
pub type CH1DATA = crate :: Reg < ch1data :: CH1DATA_SPEC > ; # [doc = "Channel 1 Data"]
pub mod ch1data { # [doc = "Register `CH1DATA` reader"]
pub struct R (crate :: R < CH1DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH1DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH1DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH1DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH1DATA` writer"]
pub struct W (crate :: W < CH1DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH1DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH1DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH1DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 1 Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch1data](index.html) module"]
pub struct CH1DATA_SPEC ; impl crate :: RegisterSpec for CH1DATA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch1data::R](R) reader structure"]
impl crate :: Readable for CH1DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch1data::W](W) writer structure"]
impl crate :: Writable for CH1DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH1DATA to value 0"]
impl crate :: Resettable for CH1DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `LPMODE` reader - Low Power Mode"]
pub type LPMODE_R = crate :: BitReader < bool > ; # [doc = "Field `LPMODE` writer - Low Power Mode"]
pub type LPMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH0EN` reader - Channel 0 Output Enable"]
pub type CH0EN_R = crate :: BitReader < bool > ; # [doc = "Field `CH0EN` writer - Channel 0 Output Enable"]
pub type CH0EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH1EN` reader - Channel 1 Output Enable"]
pub type CH1EN_R = crate :: BitReader < bool > ; # [doc = "Field `CH1EN` writer - Channel 1 Output Enable"]
pub type CH1EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `IDOEN` reader - Internal Output Enable"]
pub type IDOEN_R = crate :: BitReader < bool > ; # [doc = "Field `IDOEN` writer - Internal Output Enable"]
pub type IDOEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Low Power Mode"]
# [inline (always)]
pub fn lpmode (& self) -> LPMODE_R { LPMODE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 0 Output Enable"]
# [inline (always)]
pub fn ch0en (& self) -> CH0EN_R { CH0EN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 1 Output Enable"]
# [inline (always)]
pub fn ch1en (& self) -> CH1EN_R { CH1EN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Internal Output Enable"]
# [inline (always)]
pub fn idoen (& self) -> IDOEN_R { IDOEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Low Power Mode"]
# [inline (always)]
# [must_use]
pub fn lpmode (& mut self) -> LPMODE_W < 1 > { LPMODE_W :: new (self) } # [doc = "Bit 2 - Channel 0 Output Enable"]
# [inline (always)]
# [must_use]
pub fn ch0en (& mut self) -> CH0EN_W < 2 > { CH0EN_W :: new (self) } # [doc = "Bit 3 - Channel 1 Output Enable"]
# [inline (always)]
# [must_use]
pub fn ch1en (& mut self) -> CH1EN_W < 3 > { CH1EN_W :: new (self) } # [doc = "Bit 4 - Internal Output Enable"]
# [inline (always)]
# [must_use]
pub fn idoen (& mut self) -> IDOEN_W < 4 > { IDOEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CH0TRIG` reader - Channel 0 Event Trig Enable"]
pub type CH0TRIG_R = crate :: BitReader < bool > ; # [doc = "Field `CH0TRIG` writer - Channel 0 Event Trig Enable"]
pub type CH0TRIG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CH1TRIG` reader - Channel 1 Event Trig Enable"]
pub type CH1TRIG_R = crate :: BitReader < bool > ; # [doc = "Field `CH1TRIG` writer - Channel 1 Event Trig Enable"]
pub type CH1TRIG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CHSEL` reader - Channel Select"]
pub type CHSEL_R = crate :: FieldReader < u8 , CHSEL_A > ; # [doc = "Channel Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSEL_A { # [doc = "0: Single channel operation (Channel A only)"]
SINGLE = 0 , # [doc = "2: Dual channel operation (S/H on both channels)"]
DUAL = 2 , } impl From < CHSEL_A > for u8 { # [inline (always)]
fn from (variant : CHSEL_A) -> Self { variant as _ } } impl CHSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSEL_A > { match self . bits { 0 => Some (CHSEL_A :: SINGLE) , 2 => Some (CHSEL_A :: DUAL) , _ => None , } } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == CHSEL_A :: SINGLE } # [doc = "Checks if the value of the field is `DUAL`"]
# [inline (always)]
pub fn is_dual (& self) -> bool { * self == CHSEL_A :: DUAL } } # [doc = "Field `CHSEL` writer - Channel Select"]
pub type CHSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , CHSEL_A , 2 , O > ; impl < 'a , const O : u8 > CHSEL_W < 'a , O > { # [doc = "Single channel operation (Channel A only)"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (CHSEL_A :: SINGLE) } # [doc = "Dual channel operation (S/H on both channels)"]
# [inline (always)]
pub fn dual (self) -> & 'a mut W { self . variant (CHSEL_A :: DUAL) } } impl R { # [doc = "Bit 0 - Channel 0 Event Trig Enable"]
# [inline (always)]
pub fn ch0trig (& self) -> CH0TRIG_R { CH0TRIG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Event Trig Enable"]
# [inline (always)]
pub fn ch1trig (& self) -> CH1TRIG_R { CH1TRIG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 5:6 - Channel Select"]
# [inline (always)]
pub fn chsel (& self) -> CHSEL_R { CHSEL_R :: new ((self . bits >> 5) & 3) } } impl W { # [doc = "Bit 0 - Channel 0 Event Trig Enable"]
# [inline (always)]
# [must_use]
pub fn ch0trig (& mut self) -> CH0TRIG_W < 0 > { CH0TRIG_W :: new (self) } # [doc = "Bit 1 - Channel 1 Event Trig Enable"]
# [inline (always)]
# [must_use]
pub fn ch1trig (& mut self) -> CH1TRIG_W < 1 > { CH1TRIG_W :: new (self) } # [doc = "Bits 5:6 - Channel Select"]
# [inline (always)]
# [must_use]
pub fn chsel (& mut self) -> CHSEL_W < 5 > { CHSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `LEFTADJ` reader - Left-adjust Result"]
pub type LEFTADJ_R = crate :: BitReader < bool > ; # [doc = "Field `LEFTADJ` writer - Left-adjust Result"]
pub type LEFTADJ_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `REFSEL` reader - Reference Select"]
pub type REFSEL_R = crate :: FieldReader < u8 , REFSEL_A > ; # [doc = "Reference Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFSEL_A { # [doc = "0: Internal 1V"]
INT1V = 0 , # [doc = "1: Analog supply voltage"]
AVCC = 1 , # [doc = "2: External reference on AREF on PORTA"]
AREFA = 2 , # [doc = "3: External reference on AREF on PORTB"]
AREFB = 3 , } impl From < REFSEL_A > for u8 { # [inline (always)]
fn from (variant : REFSEL_A) -> Self { variant as _ } } impl REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> REFSEL_A { match self . bits { 0 => REFSEL_A :: INT1V , 1 => REFSEL_A :: AVCC , 2 => REFSEL_A :: AREFA , 3 => REFSEL_A :: AREFB , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT1V`"]
# [inline (always)]
pub fn is_int1v (& self) -> bool { * self == REFSEL_A :: INT1V } # [doc = "Checks if the value of the field is `AVCC`"]
# [inline (always)]
pub fn is_avcc (& self) -> bool { * self == REFSEL_A :: AVCC } # [doc = "Checks if the value of the field is `AREFA`"]
# [inline (always)]
pub fn is_arefa (& self) -> bool { * self == REFSEL_A :: AREFA } # [doc = "Checks if the value of the field is `AREFB`"]
# [inline (always)]
pub fn is_arefb (& self) -> bool { * self == REFSEL_A :: AREFB } } # [doc = "Field `REFSEL` writer - Reference Select"]
pub type REFSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , REFSEL_A , 2 , O > ; impl < 'a , const O : u8 > REFSEL_W < 'a , O > { # [doc = "Internal 1V"]
# [inline (always)]
pub fn int1v (self) -> & 'a mut W { self . variant (REFSEL_A :: INT1V) } # [doc = "Analog supply voltage"]
# [inline (always)]
pub fn avcc (self) -> & 'a mut W { self . variant (REFSEL_A :: AVCC) } # [doc = "External reference on AREF on PORTA"]
# [inline (always)]
pub fn arefa (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFA) } # [doc = "External reference on AREF on PORTB"]
# [inline (always)]
pub fn arefb (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFB) } } impl R { # [doc = "Bit 0 - Left-adjust Result"]
# [inline (always)]
pub fn leftadj (& self) -> LEFTADJ_R { LEFTADJ_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 3:4 - Reference Select"]
# [inline (always)]
pub fn refsel (& self) -> REFSEL_R { REFSEL_R :: new ((self . bits >> 3) & 3) } } impl W { # [doc = "Bit 0 - Left-adjust Result"]
# [inline (always)]
# [must_use]
pub fn leftadj (& mut self) -> LEFTADJ_W < 0 > { LEFTADJ_W :: new (self) } # [doc = "Bits 3:4 - Reference Select"]
# [inline (always)]
# [must_use]
pub fn refsel (& mut self) -> REFSEL_W < 3 > { REFSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Input Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Input Selection"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Input Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: Event Channel 0"]
_0 = 0 , # [doc = "1: Event Channel 1"]
_1 = 1 , # [doc = "2: Event Channel 2"]
_2 = 2 , # [doc = "3: Event Channel 3"]
_3 = 3 , # [doc = "4: Event Channel 4"]
_4 = 4 , # [doc = "5: Event Channel 5"]
_5 = 5 , # [doc = "6: Event Channel 6"]
_6 = 6 , # [doc = "7: Event Channel 7"]
_7 = 7 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EVSEL_A { match self . bits { 0 => EVSEL_A :: _0 , 1 => EVSEL_A :: _1 , 2 => EVSEL_A :: _2 , 3 => EVSEL_A :: _3 , 4 => EVSEL_A :: _4 , 5 => EVSEL_A :: _5 , 6 => EVSEL_A :: _6 , 7 => EVSEL_A :: _7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == EVSEL_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == EVSEL_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == EVSEL_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == EVSEL_A :: _3 } # [doc = "Checks if the value of the field is `_4`"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == EVSEL_A :: _4 } # [doc = "Checks if the value of the field is `_5`"]
# [inline (always)]
pub fn is_5 (& self) -> bool { * self == EVSEL_A :: _5 } # [doc = "Checks if the value of the field is `_6`"]
# [inline (always)]
pub fn is_6 (& self) -> bool { * self == EVSEL_A :: _6 } # [doc = "Checks if the value of the field is `_7`"]
# [inline (always)]
pub fn is_7 (& self) -> bool { * self == EVSEL_A :: _7 } } # [doc = "Field `EVSEL` writer - Event Input Selection"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EVCTRL_SPEC , u8 , EVSEL_A , 3 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "Event Channel 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (EVSEL_A :: _0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (EVSEL_A :: _1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (EVSEL_A :: _2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (EVSEL_A :: _3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut W { self . variant (EVSEL_A :: _4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn _5 (self) -> & 'a mut W { self . variant (EVSEL_A :: _5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn _6 (self) -> & 'a mut W { self . variant (EVSEL_A :: _6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn _7 (self) -> & 'a mut W { self . variant (EVSEL_A :: _7) } } impl R { # [doc = "Bits 0:2 - Event Input Selection"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Event Input Selection"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Input Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GAINCAL (rw) register accessor: an alias for `Reg<GAINCAL_SPEC>`"]
pub type GAINCAL = crate :: Reg < gaincal :: GAINCAL_SPEC > ; # [doc = "Gain Calibration"]
pub mod gaincal { # [doc = "Register `GAINCAL` reader"]
pub struct R (crate :: R < GAINCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GAINCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GAINCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GAINCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `GAINCAL` writer"]
pub struct W (crate :: W < GAINCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GAINCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GAINCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GAINCAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `GAINCAL` reader - Gain Calibration"]
pub type GAINCAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `GAINCAL` writer - Gain Calibration"]
pub type GAINCAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , GAINCAL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Gain Calibration"]
# [inline (always)]
pub fn gaincal (& self) -> GAINCAL_R { GAINCAL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Gain Calibration"]
# [inline (always)]
# [must_use]
pub fn gaincal (& mut self) -> GAINCAL_W < 0 > { GAINCAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Gain Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gaincal](index.html) module"]
pub struct GAINCAL_SPEC ; impl crate :: RegisterSpec for GAINCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gaincal::R](R) reader structure"]
impl crate :: Readable for GAINCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gaincal::W](W) writer structure"]
impl crate :: Writable for GAINCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GAINCAL to value 0"]
impl crate :: Resettable for GAINCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OFFSETCAL (rw) register accessor: an alias for `Reg<OFFSETCAL_SPEC>`"]
pub type OFFSETCAL = crate :: Reg < offsetcal :: OFFSETCAL_SPEC > ; # [doc = "Offset Calibration"]
pub mod offsetcal { # [doc = "Register `OFFSETCAL` reader"]
pub struct R (crate :: R < OFFSETCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OFFSETCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OFFSETCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OFFSETCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OFFSETCAL` writer"]
pub struct W (crate :: W < OFFSETCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OFFSETCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OFFSETCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OFFSETCAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OFFSETCAL` reader - Offset Calibration"]
pub type OFFSETCAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `OFFSETCAL` writer - Offset Calibration"]
pub type OFFSETCAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OFFSETCAL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Offset Calibration"]
# [inline (always)]
pub fn offsetcal (& self) -> OFFSETCAL_R { OFFSETCAL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Offset Calibration"]
# [inline (always)]
# [must_use]
pub fn offsetcal (& mut self) -> OFFSETCAL_W < 0 > { OFFSETCAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Offset Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [offsetcal](index.html) module"]
pub struct OFFSETCAL_SPEC ; impl crate :: RegisterSpec for OFFSETCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [offsetcal::R](R) reader structure"]
impl crate :: Readable for OFFSETCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [offsetcal::W](W) writer structure"]
impl crate :: Writable for OFFSETCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OFFSETCAL to value 0"]
impl crate :: Resettable for OFFSETCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CH0DRE` reader - Channel 0 Data Register Empty"]
pub type CH0DRE_R = crate :: BitReader < bool > ; # [doc = "Field `CH0DRE` writer - Channel 0 Data Register Empty"]
pub type CH0DRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH1DRE` reader - Channel 1 Data Register Empty"]
pub type CH1DRE_R = crate :: BitReader < bool > ; # [doc = "Field `CH1DRE` writer - Channel 1 Data Register Empty"]
pub type CH1DRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Channel 0 Data Register Empty"]
# [inline (always)]
pub fn ch0dre (& self) -> CH0DRE_R { CH0DRE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Data Register Empty"]
# [inline (always)]
pub fn ch1dre (& self) -> CH1DRE_R { CH1DRE_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn ch0dre (& mut self) -> CH0DRE_W < 0 > { CH0DRE_W :: new (self) } # [doc = "Bit 1 - Channel 1 Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn ch1dre (& mut self) -> CH1DRE_W < 1 > { CH1DRE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMCTRL (rw) register accessor: an alias for `Reg<TIMCTRL_SPEC>`"]
pub type TIMCTRL = crate :: Reg < timctrl :: TIMCTRL_SPEC > ; # [doc = "Timing Control"]
pub mod timctrl { # [doc = "Register `TIMCTRL` reader"]
pub struct R (crate :: R < TIMCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMCTRL` writer"]
pub struct W (crate :: W < TIMCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `REFRESH` reader - Refresh Timing Control"]
pub type REFRESH_R = crate :: FieldReader < u8 , REFRESH_A > ; # [doc = "Refresh Timing Control\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFRESH_A { # [doc = "0: 16 CLK"]
_16CLK = 0 , # [doc = "1: 32 CLK"]
_32CLK = 1 , # [doc = "2: 64 CLK"]
_64CLK = 2 , # [doc = "3: 128 CLK"]
_128CLK = 3 , # [doc = "4: 256 CLK"]
_256CLK = 4 , # [doc = "5: 512 CLK"]
_512CLK = 5 , # [doc = "6: 1024 CLK"]
_1024CLK = 6 , # [doc = "7: 2048 CLK"]
_2048CLK = 7 , # [doc = "8: 4096 CLK"]
_4096CLK = 8 , # [doc = "9: 8192 CLK"]
_8192CLK = 9 , # [doc = "10: 16384 CLK"]
_16384CLK = 10 , # [doc = "11: 32768 CLK"]
_32768CLK = 11 , # [doc = "12: 65536 CLK"]
_65536CLK = 12 , # [doc = "15: Auto refresh OFF"]
OFF = 15 , } impl From < REFRESH_A > for u8 { # [inline (always)]
fn from (variant : REFRESH_A) -> Self { variant as _ } } impl REFRESH_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < REFRESH_A > { match self . bits { 0 => Some (REFRESH_A :: _16CLK) , 1 => Some (REFRESH_A :: _32CLK) , 2 => Some (REFRESH_A :: _64CLK) , 3 => Some (REFRESH_A :: _128CLK) , 4 => Some (REFRESH_A :: _256CLK) , 5 => Some (REFRESH_A :: _512CLK) , 6 => Some (REFRESH_A :: _1024CLK) , 7 => Some (REFRESH_A :: _2048CLK) , 8 => Some (REFRESH_A :: _4096CLK) , 9 => Some (REFRESH_A :: _8192CLK) , 10 => Some (REFRESH_A :: _16384CLK) , 11 => Some (REFRESH_A :: _32768CLK) , 12 => Some (REFRESH_A :: _65536CLK) , 15 => Some (REFRESH_A :: OFF) , _ => None , } } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == REFRESH_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == REFRESH_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == REFRESH_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == REFRESH_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == REFRESH_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == REFRESH_A :: _512CLK } # [doc = "Checks if the value of the field is `_1024CLK`"]
# [inline (always)]
pub fn is_1024clk (& self) -> bool { * self == REFRESH_A :: _1024CLK } # [doc = "Checks if the value of the field is `_2048CLK`"]
# [inline (always)]
pub fn is_2048clk (& self) -> bool { * self == REFRESH_A :: _2048CLK } # [doc = "Checks if the value of the field is `_4096CLK`"]
# [inline (always)]
pub fn is_4096clk (& self) -> bool { * self == REFRESH_A :: _4096CLK } # [doc = "Checks if the value of the field is `_8192CLK`"]
# [inline (always)]
pub fn is_8192clk (& self) -> bool { * self == REFRESH_A :: _8192CLK } # [doc = "Checks if the value of the field is `_16384CLK`"]
# [inline (always)]
pub fn is_16384clk (& self) -> bool { * self == REFRESH_A :: _16384CLK } # [doc = "Checks if the value of the field is `_32768CLK`"]
# [inline (always)]
pub fn is_32768clk (& self) -> bool { * self == REFRESH_A :: _32768CLK } # [doc = "Checks if the value of the field is `_65536CLK`"]
# [inline (always)]
pub fn is_65536clk (& self) -> bool { * self == REFRESH_A :: _65536CLK } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == REFRESH_A :: OFF } } # [doc = "Field `REFRESH` writer - Refresh Timing Control"]
pub type REFRESH_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TIMCTRL_SPEC , u8 , REFRESH_A , 4 , O > ; impl < 'a , const O : u8 > REFRESH_W < 'a , O > { # [doc = "16 CLK"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _16CLK) } # [doc = "32 CLK"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _32CLK) } # [doc = "64 CLK"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _64CLK) } # [doc = "128 CLK"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _128CLK) } # [doc = "256 CLK"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _256CLK) } # [doc = "512 CLK"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _512CLK) } # [doc = "1024 CLK"]
# [inline (always)]
pub fn _1024clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _1024CLK) } # [doc = "2048 CLK"]
# [inline (always)]
pub fn _2048clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _2048CLK) } # [doc = "4096 CLK"]
# [inline (always)]
pub fn _4096clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _4096CLK) } # [doc = "8192 CLK"]
# [inline (always)]
pub fn _8192clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _8192CLK) } # [doc = "16384 CLK"]
# [inline (always)]
pub fn _16384clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _16384CLK) } # [doc = "32768 CLK"]
# [inline (always)]
pub fn _32768clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _32768CLK) } # [doc = "65536 CLK"]
# [inline (always)]
pub fn _65536clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _65536CLK) } # [doc = "Auto refresh OFF"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (REFRESH_A :: OFF) } } # [doc = "Field `CONINTVAL` reader - Conversion Intercal"]
pub type CONINTVAL_R = crate :: FieldReader < u8 , CONINTVAL_A > ; # [doc = "Conversion Intercal\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CONINTVAL_A { # [doc = "0: 1 CLK / 2 CLK in S/H mode"]
_1CLK = 0 , # [doc = "1: 2 CLK / 3 CLK in S/H mode"]
_2CLK = 1 , # [doc = "2: 4 CLK / 6 CLK in S/H mode"]
_4CLK = 2 , # [doc = "3: 8 CLK / 12 CLK in S/H mode"]
_8CLK = 3 , # [doc = "4: 16 CLK / 24 CLK in S/H mode"]
_16CLK = 4 , # [doc = "5: 32 CLK / 48 CLK in S/H mode"]
_32CLK = 5 , # [doc = "6: 64 CLK / 96 CLK in S/H mode"]
_64CLK = 6 , # [doc = "7: 128 CLK / 192 CLK in S/H mode"]
_128CLK = 7 , } impl From < CONINTVAL_A > for u8 { # [inline (always)]
fn from (variant : CONINTVAL_A) -> Self { variant as _ } } impl CONINTVAL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CONINTVAL_A { match self . bits { 0 => CONINTVAL_A :: _1CLK , 1 => CONINTVAL_A :: _2CLK , 2 => CONINTVAL_A :: _4CLK , 3 => CONINTVAL_A :: _8CLK , 4 => CONINTVAL_A :: _16CLK , 5 => CONINTVAL_A :: _32CLK , 6 => CONINTVAL_A :: _64CLK , 7 => CONINTVAL_A :: _128CLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1CLK`"]
# [inline (always)]
pub fn is_1clk (& self) -> bool { * self == CONINTVAL_A :: _1CLK } # [doc = "Checks if the value of the field is `_2CLK`"]
# [inline (always)]
pub fn is_2clk (& self) -> bool { * self == CONINTVAL_A :: _2CLK } # [doc = "Checks if the value of the field is `_4CLK`"]
# [inline (always)]
pub fn is_4clk (& self) -> bool { * self == CONINTVAL_A :: _4CLK } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == CONINTVAL_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == CONINTVAL_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == CONINTVAL_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == CONINTVAL_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == CONINTVAL_A :: _128CLK } } # [doc = "Field `CONINTVAL` writer - Conversion Intercal"]
pub type CONINTVAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TIMCTRL_SPEC , u8 , CONINTVAL_A , 3 , O > ; impl < 'a , const O : u8 > CONINTVAL_W < 'a , O > { # [doc = "1 CLK / 2 CLK in S/H mode"]
# [inline (always)]
pub fn _1clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _1CLK) } # [doc = "2 CLK / 3 CLK in S/H mode"]
# [inline (always)]
pub fn _2clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _2CLK) } # [doc = "4 CLK / 6 CLK in S/H mode"]
# [inline (always)]
pub fn _4clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _4CLK) } # [doc = "8 CLK / 12 CLK in S/H mode"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _8CLK) } # [doc = "16 CLK / 24 CLK in S/H mode"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _16CLK) } # [doc = "32 CLK / 48 CLK in S/H mode"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _32CLK) } # [doc = "64 CLK / 96 CLK in S/H mode"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _64CLK) } # [doc = "128 CLK / 192 CLK in S/H mode"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _128CLK) } } impl R { # [doc = "Bits 0:3 - Refresh Timing Control"]
# [inline (always)]
pub fn refresh (& self) -> REFRESH_R { REFRESH_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:6 - Conversion Intercal"]
# [inline (always)]
pub fn conintval (& self) -> CONINTVAL_R { CONINTVAL_R :: new ((self . bits >> 4) & 7) } } impl W { # [doc = "Bits 0:3 - Refresh Timing Control"]
# [inline (always)]
# [must_use]
pub fn refresh (& mut self) -> REFRESH_W < 0 > { REFRESH_W :: new (self) } # [doc = "Bits 4:6 - Conversion Intercal"]
# [inline (always)]
# [must_use]
pub fn conintval (& mut self) -> CONINTVAL_W < 4 > { CONINTVAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timing Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timctrl](index.html) module"]
pub struct TIMCTRL_SPEC ; impl crate :: RegisterSpec for TIMCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timctrl::R](R) reader structure"]
impl crate :: Readable for TIMCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timctrl::W](W) writer structure"]
impl crate :: Writable for TIMCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMCTRL to value 0"]
impl crate :: Resettable for TIMCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Digital/Analog Converter"]
pub struct DACB { _marker : PhantomData < * const () > } unsafe impl Send for DACB { } impl DACB { # [doc = r"Pointer to the register block"]
pub const PTR : * const dacb :: RegisterBlock = 0x0320 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dacb :: RegisterBlock { Self :: PTR } } impl Deref for DACB { type Target = dacb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DACB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DACB") . finish () } } # [doc = "Digital/Analog Converter"]
pub mod dacb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Event Input Control"]
pub evctrl : EVCTRL , # [doc = "0x04 - Timing Control"]
pub timctrl : TIMCTRL , # [doc = "0x05 - Status"]
pub status : STATUS , _reserved6 : [u8 ; 0x02]
, # [doc = "0x08 - Gain Calibration"]
pub gaincal : GAINCAL , # [doc = "0x09 - Offset Calibration"]
pub offsetcal : OFFSETCAL , _reserved8 : [u8 ; 0x0e]
, # [doc = "0x18 - Channel 0 Data"]
pub ch0data : CH0DATA , # [doc = "0x1a - Channel 1 Data"]
pub ch1data : CH1DATA , } # [doc = "CH0DATA (rw) register accessor: an alias for `Reg<CH0DATA_SPEC>`"]
pub type CH0DATA = crate :: Reg < ch0data :: CH0DATA_SPEC > ; # [doc = "Channel 0 Data"]
pub mod ch0data { # [doc = "Register `CH0DATA` reader"]
pub struct R (crate :: R < CH0DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH0DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH0DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH0DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH0DATA` writer"]
pub struct W (crate :: W < CH0DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH0DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH0DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH0DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 0 Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch0data](index.html) module"]
pub struct CH0DATA_SPEC ; impl crate :: RegisterSpec for CH0DATA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch0data::R](R) reader structure"]
impl crate :: Readable for CH0DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch0data::W](W) writer structure"]
impl crate :: Writable for CH0DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH0DATA to value 0"]
impl crate :: Resettable for CH0DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH1DATA (rw) register accessor: an alias for `Reg<CH1DATA_SPEC>`"]
pub type CH1DATA = crate :: Reg < ch1data :: CH1DATA_SPEC > ; # [doc = "Channel 1 Data"]
pub mod ch1data { # [doc = "Register `CH1DATA` reader"]
pub struct R (crate :: R < CH1DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH1DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH1DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH1DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH1DATA` writer"]
pub struct W (crate :: W < CH1DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH1DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH1DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH1DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Channel 1 Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch1data](index.html) module"]
pub struct CH1DATA_SPEC ; impl crate :: RegisterSpec for CH1DATA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ch1data::R](R) reader structure"]
impl crate :: Readable for CH1DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch1data::W](W) writer structure"]
impl crate :: Writable for CH1DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH1DATA to value 0"]
impl crate :: Resettable for CH1DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `LPMODE` reader - Low Power Mode"]
pub type LPMODE_R = crate :: BitReader < bool > ; # [doc = "Field `LPMODE` writer - Low Power Mode"]
pub type LPMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH0EN` reader - Channel 0 Output Enable"]
pub type CH0EN_R = crate :: BitReader < bool > ; # [doc = "Field `CH0EN` writer - Channel 0 Output Enable"]
pub type CH0EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `CH1EN` reader - Channel 1 Output Enable"]
pub type CH1EN_R = crate :: BitReader < bool > ; # [doc = "Field `CH1EN` writer - Channel 1 Output Enable"]
pub type CH1EN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; # [doc = "Field `IDOEN` reader - Internal Output Enable"]
pub type IDOEN_R = crate :: BitReader < bool > ; # [doc = "Field `IDOEN` writer - Internal Output Enable"]
pub type IDOEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Low Power Mode"]
# [inline (always)]
pub fn lpmode (& self) -> LPMODE_R { LPMODE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 0 Output Enable"]
# [inline (always)]
pub fn ch0en (& self) -> CH0EN_R { CH0EN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 1 Output Enable"]
# [inline (always)]
pub fn ch1en (& self) -> CH1EN_R { CH1EN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Internal Output Enable"]
# [inline (always)]
pub fn idoen (& self) -> IDOEN_R { IDOEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Bit 1 - Low Power Mode"]
# [inline (always)]
# [must_use]
pub fn lpmode (& mut self) -> LPMODE_W < 1 > { LPMODE_W :: new (self) } # [doc = "Bit 2 - Channel 0 Output Enable"]
# [inline (always)]
# [must_use]
pub fn ch0en (& mut self) -> CH0EN_W < 2 > { CH0EN_W :: new (self) } # [doc = "Bit 3 - Channel 1 Output Enable"]
# [inline (always)]
# [must_use]
pub fn ch1en (& mut self) -> CH1EN_W < 3 > { CH1EN_W :: new (self) } # [doc = "Bit 4 - Internal Output Enable"]
# [inline (always)]
# [must_use]
pub fn idoen (& mut self) -> IDOEN_W < 4 > { IDOEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CH0TRIG` reader - Channel 0 Event Trig Enable"]
pub type CH0TRIG_R = crate :: BitReader < bool > ; # [doc = "Field `CH0TRIG` writer - Channel 0 Event Trig Enable"]
pub type CH0TRIG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CH1TRIG` reader - Channel 1 Event Trig Enable"]
pub type CH1TRIG_R = crate :: BitReader < bool > ; # [doc = "Field `CH1TRIG` writer - Channel 1 Event Trig Enable"]
pub type CH1TRIG_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CHSEL` reader - Channel Select"]
pub type CHSEL_R = crate :: FieldReader < u8 , CHSEL_A > ; # [doc = "Channel Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSEL_A { # [doc = "0: Single channel operation (Channel A only)"]
SINGLE = 0 , # [doc = "2: Dual channel operation (S/H on both channels)"]
DUAL = 2 , } impl From < CHSEL_A > for u8 { # [inline (always)]
fn from (variant : CHSEL_A) -> Self { variant as _ } } impl CHSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSEL_A > { match self . bits { 0 => Some (CHSEL_A :: SINGLE) , 2 => Some (CHSEL_A :: DUAL) , _ => None , } } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == CHSEL_A :: SINGLE } # [doc = "Checks if the value of the field is `DUAL`"]
# [inline (always)]
pub fn is_dual (& self) -> bool { * self == CHSEL_A :: DUAL } } # [doc = "Field `CHSEL` writer - Channel Select"]
pub type CHSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , CHSEL_A , 2 , O > ; impl < 'a , const O : u8 > CHSEL_W < 'a , O > { # [doc = "Single channel operation (Channel A only)"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (CHSEL_A :: SINGLE) } # [doc = "Dual channel operation (S/H on both channels)"]
# [inline (always)]
pub fn dual (self) -> & 'a mut W { self . variant (CHSEL_A :: DUAL) } } impl R { # [doc = "Bit 0 - Channel 0 Event Trig Enable"]
# [inline (always)]
pub fn ch0trig (& self) -> CH0TRIG_R { CH0TRIG_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Event Trig Enable"]
# [inline (always)]
pub fn ch1trig (& self) -> CH1TRIG_R { CH1TRIG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 5:6 - Channel Select"]
# [inline (always)]
pub fn chsel (& self) -> CHSEL_R { CHSEL_R :: new ((self . bits >> 5) & 3) } } impl W { # [doc = "Bit 0 - Channel 0 Event Trig Enable"]
# [inline (always)]
# [must_use]
pub fn ch0trig (& mut self) -> CH0TRIG_W < 0 > { CH0TRIG_W :: new (self) } # [doc = "Bit 1 - Channel 1 Event Trig Enable"]
# [inline (always)]
# [must_use]
pub fn ch1trig (& mut self) -> CH1TRIG_W < 1 > { CH1TRIG_W :: new (self) } # [doc = "Bits 5:6 - Channel Select"]
# [inline (always)]
# [must_use]
pub fn chsel (& mut self) -> CHSEL_W < 5 > { CHSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `LEFTADJ` reader - Left-adjust Result"]
pub type LEFTADJ_R = crate :: BitReader < bool > ; # [doc = "Field `LEFTADJ` writer - Left-adjust Result"]
pub type LEFTADJ_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `REFSEL` reader - Reference Select"]
pub type REFSEL_R = crate :: FieldReader < u8 , REFSEL_A > ; # [doc = "Reference Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFSEL_A { # [doc = "0: Internal 1V"]
INT1V = 0 , # [doc = "1: Analog supply voltage"]
AVCC = 1 , # [doc = "2: External reference on AREF on PORTA"]
AREFA = 2 , # [doc = "3: External reference on AREF on PORTB"]
AREFB = 3 , } impl From < REFSEL_A > for u8 { # [inline (always)]
fn from (variant : REFSEL_A) -> Self { variant as _ } } impl REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> REFSEL_A { match self . bits { 0 => REFSEL_A :: INT1V , 1 => REFSEL_A :: AVCC , 2 => REFSEL_A :: AREFA , 3 => REFSEL_A :: AREFB , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `INT1V`"]
# [inline (always)]
pub fn is_int1v (& self) -> bool { * self == REFSEL_A :: INT1V } # [doc = "Checks if the value of the field is `AVCC`"]
# [inline (always)]
pub fn is_avcc (& self) -> bool { * self == REFSEL_A :: AVCC } # [doc = "Checks if the value of the field is `AREFA`"]
# [inline (always)]
pub fn is_arefa (& self) -> bool { * self == REFSEL_A :: AREFA } # [doc = "Checks if the value of the field is `AREFB`"]
# [inline (always)]
pub fn is_arefb (& self) -> bool { * self == REFSEL_A :: AREFB } } # [doc = "Field `REFSEL` writer - Reference Select"]
pub type REFSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , REFSEL_A , 2 , O > ; impl < 'a , const O : u8 > REFSEL_W < 'a , O > { # [doc = "Internal 1V"]
# [inline (always)]
pub fn int1v (self) -> & 'a mut W { self . variant (REFSEL_A :: INT1V) } # [doc = "Analog supply voltage"]
# [inline (always)]
pub fn avcc (self) -> & 'a mut W { self . variant (REFSEL_A :: AVCC) } # [doc = "External reference on AREF on PORTA"]
# [inline (always)]
pub fn arefa (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFA) } # [doc = "External reference on AREF on PORTB"]
# [inline (always)]
pub fn arefb (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFB) } } impl R { # [doc = "Bit 0 - Left-adjust Result"]
# [inline (always)]
pub fn leftadj (& self) -> LEFTADJ_R { LEFTADJ_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 3:4 - Reference Select"]
# [inline (always)]
pub fn refsel (& self) -> REFSEL_R { REFSEL_R :: new ((self . bits >> 3) & 3) } } impl W { # [doc = "Bit 0 - Left-adjust Result"]
# [inline (always)]
# [must_use]
pub fn leftadj (& mut self) -> LEFTADJ_W < 0 > { LEFTADJ_W :: new (self) } # [doc = "Bits 3:4 - Reference Select"]
# [inline (always)]
# [must_use]
pub fn refsel (& mut self) -> REFSEL_W < 3 > { REFSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVCTRL (rw) register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Input Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Input Selection"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Input Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: Event Channel 0"]
_0 = 0 , # [doc = "1: Event Channel 1"]
_1 = 1 , # [doc = "2: Event Channel 2"]
_2 = 2 , # [doc = "3: Event Channel 3"]
_3 = 3 , # [doc = "4: Event Channel 4"]
_4 = 4 , # [doc = "5: Event Channel 5"]
_5 = 5 , # [doc = "6: Event Channel 6"]
_6 = 6 , # [doc = "7: Event Channel 7"]
_7 = 7 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EVSEL_A { match self . bits { 0 => EVSEL_A :: _0 , 1 => EVSEL_A :: _1 , 2 => EVSEL_A :: _2 , 3 => EVSEL_A :: _3 , 4 => EVSEL_A :: _4 , 5 => EVSEL_A :: _5 , 6 => EVSEL_A :: _6 , 7 => EVSEL_A :: _7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == EVSEL_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == EVSEL_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == EVSEL_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == EVSEL_A :: _3 } # [doc = "Checks if the value of the field is `_4`"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == EVSEL_A :: _4 } # [doc = "Checks if the value of the field is `_5`"]
# [inline (always)]
pub fn is_5 (& self) -> bool { * self == EVSEL_A :: _5 } # [doc = "Checks if the value of the field is `_6`"]
# [inline (always)]
pub fn is_6 (& self) -> bool { * self == EVSEL_A :: _6 } # [doc = "Checks if the value of the field is `_7`"]
# [inline (always)]
pub fn is_7 (& self) -> bool { * self == EVSEL_A :: _7 } } # [doc = "Field `EVSEL` writer - Event Input Selection"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , EVCTRL_SPEC , u8 , EVSEL_A , 3 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "Event Channel 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (EVSEL_A :: _0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (EVSEL_A :: _1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (EVSEL_A :: _2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (EVSEL_A :: _3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut W { self . variant (EVSEL_A :: _4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn _5 (self) -> & 'a mut W { self . variant (EVSEL_A :: _5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn _6 (self) -> & 'a mut W { self . variant (EVSEL_A :: _6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn _7 (self) -> & 'a mut W { self . variant (EVSEL_A :: _7) } } impl R { # [doc = "Bits 0:2 - Event Input Selection"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Event Input Selection"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Input Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GAINCAL (rw) register accessor: an alias for `Reg<GAINCAL_SPEC>`"]
pub type GAINCAL = crate :: Reg < gaincal :: GAINCAL_SPEC > ; # [doc = "Gain Calibration"]
pub mod gaincal { # [doc = "Register `GAINCAL` reader"]
pub struct R (crate :: R < GAINCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GAINCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GAINCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GAINCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `GAINCAL` writer"]
pub struct W (crate :: W < GAINCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GAINCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GAINCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GAINCAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `GAINCAL` reader - Gain Calibration"]
pub type GAINCAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `GAINCAL` writer - Gain Calibration"]
pub type GAINCAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , GAINCAL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Gain Calibration"]
# [inline (always)]
pub fn gaincal (& self) -> GAINCAL_R { GAINCAL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Gain Calibration"]
# [inline (always)]
# [must_use]
pub fn gaincal (& mut self) -> GAINCAL_W < 0 > { GAINCAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Gain Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gaincal](index.html) module"]
pub struct GAINCAL_SPEC ; impl crate :: RegisterSpec for GAINCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gaincal::R](R) reader structure"]
impl crate :: Readable for GAINCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gaincal::W](W) writer structure"]
impl crate :: Writable for GAINCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GAINCAL to value 0"]
impl crate :: Resettable for GAINCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OFFSETCAL (rw) register accessor: an alias for `Reg<OFFSETCAL_SPEC>`"]
pub type OFFSETCAL = crate :: Reg < offsetcal :: OFFSETCAL_SPEC > ; # [doc = "Offset Calibration"]
pub mod offsetcal { # [doc = "Register `OFFSETCAL` reader"]
pub struct R (crate :: R < OFFSETCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OFFSETCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OFFSETCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OFFSETCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OFFSETCAL` writer"]
pub struct W (crate :: W < OFFSETCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OFFSETCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OFFSETCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OFFSETCAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OFFSETCAL` reader - Offset Calibration"]
pub type OFFSETCAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `OFFSETCAL` writer - Offset Calibration"]
pub type OFFSETCAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OFFSETCAL_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - Offset Calibration"]
# [inline (always)]
pub fn offsetcal (& self) -> OFFSETCAL_R { OFFSETCAL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Offset Calibration"]
# [inline (always)]
# [must_use]
pub fn offsetcal (& mut self) -> OFFSETCAL_W < 0 > { OFFSETCAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Offset Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [offsetcal](index.html) module"]
pub struct OFFSETCAL_SPEC ; impl crate :: RegisterSpec for OFFSETCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [offsetcal::R](R) reader structure"]
impl crate :: Readable for OFFSETCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [offsetcal::W](W) writer structure"]
impl crate :: Writable for OFFSETCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OFFSETCAL to value 0"]
impl crate :: Resettable for OFFSETCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CH0DRE` reader - Channel 0 Data Register Empty"]
pub type CH0DRE_R = crate :: BitReader < bool > ; # [doc = "Field `CH0DRE` writer - Channel 0 Data Register Empty"]
pub type CH0DRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH1DRE` reader - Channel 1 Data Register Empty"]
pub type CH1DRE_R = crate :: BitReader < bool > ; # [doc = "Field `CH1DRE` writer - Channel 1 Data Register Empty"]
pub type CH1DRE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Channel 0 Data Register Empty"]
# [inline (always)]
pub fn ch0dre (& self) -> CH0DRE_R { CH0DRE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Data Register Empty"]
# [inline (always)]
pub fn ch1dre (& self) -> CH1DRE_R { CH1DRE_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn ch0dre (& mut self) -> CH0DRE_W < 0 > { CH0DRE_W :: new (self) } # [doc = "Bit 1 - Channel 1 Data Register Empty"]
# [inline (always)]
# [must_use]
pub fn ch1dre (& mut self) -> CH1DRE_W < 1 > { CH1DRE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TIMCTRL (rw) register accessor: an alias for `Reg<TIMCTRL_SPEC>`"]
pub type TIMCTRL = crate :: Reg < timctrl :: TIMCTRL_SPEC > ; # [doc = "Timing Control"]
pub mod timctrl { # [doc = "Register `TIMCTRL` reader"]
pub struct R (crate :: R < TIMCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TIMCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TIMCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TIMCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TIMCTRL` writer"]
pub struct W (crate :: W < TIMCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TIMCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TIMCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TIMCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `REFRESH` reader - Refresh Timing Control"]
pub type REFRESH_R = crate :: FieldReader < u8 , REFRESH_A > ; # [doc = "Refresh Timing Control\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum REFRESH_A { # [doc = "0: 16 CLK"]
_16CLK = 0 , # [doc = "1: 32 CLK"]
_32CLK = 1 , # [doc = "2: 64 CLK"]
_64CLK = 2 , # [doc = "3: 128 CLK"]
_128CLK = 3 , # [doc = "4: 256 CLK"]
_256CLK = 4 , # [doc = "5: 512 CLK"]
_512CLK = 5 , # [doc = "6: 1024 CLK"]
_1024CLK = 6 , # [doc = "7: 2048 CLK"]
_2048CLK = 7 , # [doc = "8: 4096 CLK"]
_4096CLK = 8 , # [doc = "9: 8192 CLK"]
_8192CLK = 9 , # [doc = "10: 16384 CLK"]
_16384CLK = 10 , # [doc = "11: 32768 CLK"]
_32768CLK = 11 , # [doc = "12: 65536 CLK"]
_65536CLK = 12 , # [doc = "15: Auto refresh OFF"]
OFF = 15 , } impl From < REFRESH_A > for u8 { # [inline (always)]
fn from (variant : REFRESH_A) -> Self { variant as _ } } impl REFRESH_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < REFRESH_A > { match self . bits { 0 => Some (REFRESH_A :: _16CLK) , 1 => Some (REFRESH_A :: _32CLK) , 2 => Some (REFRESH_A :: _64CLK) , 3 => Some (REFRESH_A :: _128CLK) , 4 => Some (REFRESH_A :: _256CLK) , 5 => Some (REFRESH_A :: _512CLK) , 6 => Some (REFRESH_A :: _1024CLK) , 7 => Some (REFRESH_A :: _2048CLK) , 8 => Some (REFRESH_A :: _4096CLK) , 9 => Some (REFRESH_A :: _8192CLK) , 10 => Some (REFRESH_A :: _16384CLK) , 11 => Some (REFRESH_A :: _32768CLK) , 12 => Some (REFRESH_A :: _65536CLK) , 15 => Some (REFRESH_A :: OFF) , _ => None , } } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == REFRESH_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == REFRESH_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == REFRESH_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == REFRESH_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == REFRESH_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == REFRESH_A :: _512CLK } # [doc = "Checks if the value of the field is `_1024CLK`"]
# [inline (always)]
pub fn is_1024clk (& self) -> bool { * self == REFRESH_A :: _1024CLK } # [doc = "Checks if the value of the field is `_2048CLK`"]
# [inline (always)]
pub fn is_2048clk (& self) -> bool { * self == REFRESH_A :: _2048CLK } # [doc = "Checks if the value of the field is `_4096CLK`"]
# [inline (always)]
pub fn is_4096clk (& self) -> bool { * self == REFRESH_A :: _4096CLK } # [doc = "Checks if the value of the field is `_8192CLK`"]
# [inline (always)]
pub fn is_8192clk (& self) -> bool { * self == REFRESH_A :: _8192CLK } # [doc = "Checks if the value of the field is `_16384CLK`"]
# [inline (always)]
pub fn is_16384clk (& self) -> bool { * self == REFRESH_A :: _16384CLK } # [doc = "Checks if the value of the field is `_32768CLK`"]
# [inline (always)]
pub fn is_32768clk (& self) -> bool { * self == REFRESH_A :: _32768CLK } # [doc = "Checks if the value of the field is `_65536CLK`"]
# [inline (always)]
pub fn is_65536clk (& self) -> bool { * self == REFRESH_A :: _65536CLK } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == REFRESH_A :: OFF } } # [doc = "Field `REFRESH` writer - Refresh Timing Control"]
pub type REFRESH_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , TIMCTRL_SPEC , u8 , REFRESH_A , 4 , O > ; impl < 'a , const O : u8 > REFRESH_W < 'a , O > { # [doc = "16 CLK"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _16CLK) } # [doc = "32 CLK"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _32CLK) } # [doc = "64 CLK"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _64CLK) } # [doc = "128 CLK"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _128CLK) } # [doc = "256 CLK"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _256CLK) } # [doc = "512 CLK"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _512CLK) } # [doc = "1024 CLK"]
# [inline (always)]
pub fn _1024clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _1024CLK) } # [doc = "2048 CLK"]
# [inline (always)]
pub fn _2048clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _2048CLK) } # [doc = "4096 CLK"]
# [inline (always)]
pub fn _4096clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _4096CLK) } # [doc = "8192 CLK"]
# [inline (always)]
pub fn _8192clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _8192CLK) } # [doc = "16384 CLK"]
# [inline (always)]
pub fn _16384clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _16384CLK) } # [doc = "32768 CLK"]
# [inline (always)]
pub fn _32768clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _32768CLK) } # [doc = "65536 CLK"]
# [inline (always)]
pub fn _65536clk (self) -> & 'a mut W { self . variant (REFRESH_A :: _65536CLK) } # [doc = "Auto refresh OFF"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (REFRESH_A :: OFF) } } # [doc = "Field `CONINTVAL` reader - Conversion Intercal"]
pub type CONINTVAL_R = crate :: FieldReader < u8 , CONINTVAL_A > ; # [doc = "Conversion Intercal\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CONINTVAL_A { # [doc = "0: 1 CLK / 2 CLK in S/H mode"]
_1CLK = 0 , # [doc = "1: 2 CLK / 3 CLK in S/H mode"]
_2CLK = 1 , # [doc = "2: 4 CLK / 6 CLK in S/H mode"]
_4CLK = 2 , # [doc = "3: 8 CLK / 12 CLK in S/H mode"]
_8CLK = 3 , # [doc = "4: 16 CLK / 24 CLK in S/H mode"]
_16CLK = 4 , # [doc = "5: 32 CLK / 48 CLK in S/H mode"]
_32CLK = 5 , # [doc = "6: 64 CLK / 96 CLK in S/H mode"]
_64CLK = 6 , # [doc = "7: 128 CLK / 192 CLK in S/H mode"]
_128CLK = 7 , } impl From < CONINTVAL_A > for u8 { # [inline (always)]
fn from (variant : CONINTVAL_A) -> Self { variant as _ } } impl CONINTVAL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CONINTVAL_A { match self . bits { 0 => CONINTVAL_A :: _1CLK , 1 => CONINTVAL_A :: _2CLK , 2 => CONINTVAL_A :: _4CLK , 3 => CONINTVAL_A :: _8CLK , 4 => CONINTVAL_A :: _16CLK , 5 => CONINTVAL_A :: _32CLK , 6 => CONINTVAL_A :: _64CLK , 7 => CONINTVAL_A :: _128CLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1CLK`"]
# [inline (always)]
pub fn is_1clk (& self) -> bool { * self == CONINTVAL_A :: _1CLK } # [doc = "Checks if the value of the field is `_2CLK`"]
# [inline (always)]
pub fn is_2clk (& self) -> bool { * self == CONINTVAL_A :: _2CLK } # [doc = "Checks if the value of the field is `_4CLK`"]
# [inline (always)]
pub fn is_4clk (& self) -> bool { * self == CONINTVAL_A :: _4CLK } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == CONINTVAL_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == CONINTVAL_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == CONINTVAL_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == CONINTVAL_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == CONINTVAL_A :: _128CLK } } # [doc = "Field `CONINTVAL` writer - Conversion Intercal"]
pub type CONINTVAL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , TIMCTRL_SPEC , u8 , CONINTVAL_A , 3 , O > ; impl < 'a , const O : u8 > CONINTVAL_W < 'a , O > { # [doc = "1 CLK / 2 CLK in S/H mode"]
# [inline (always)]
pub fn _1clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _1CLK) } # [doc = "2 CLK / 3 CLK in S/H mode"]
# [inline (always)]
pub fn _2clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _2CLK) } # [doc = "4 CLK / 6 CLK in S/H mode"]
# [inline (always)]
pub fn _4clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _4CLK) } # [doc = "8 CLK / 12 CLK in S/H mode"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _8CLK) } # [doc = "16 CLK / 24 CLK in S/H mode"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _16CLK) } # [doc = "32 CLK / 48 CLK in S/H mode"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _32CLK) } # [doc = "64 CLK / 96 CLK in S/H mode"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _64CLK) } # [doc = "128 CLK / 192 CLK in S/H mode"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (CONINTVAL_A :: _128CLK) } } impl R { # [doc = "Bits 0:3 - Refresh Timing Control"]
# [inline (always)]
pub fn refresh (& self) -> REFRESH_R { REFRESH_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:6 - Conversion Intercal"]
# [inline (always)]
pub fn conintval (& self) -> CONINTVAL_R { CONINTVAL_R :: new ((self . bits >> 4) & 7) } } impl W { # [doc = "Bits 0:3 - Refresh Timing Control"]
# [inline (always)]
# [must_use]
pub fn refresh (& mut self) -> REFRESH_W < 0 > { REFRESH_W :: new (self) } # [doc = "Bits 4:6 - Conversion Intercal"]
# [inline (always)]
# [must_use]
pub fn conintval (& mut self) -> CONINTVAL_W < 4 > { CONINTVAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Timing Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [timctrl](index.html) module"]
pub struct TIMCTRL_SPEC ; impl crate :: RegisterSpec for TIMCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [timctrl::R](R) reader structure"]
impl crate :: Readable for TIMCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [timctrl::W](W) writer structure"]
impl crate :: Writable for TIMCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TIMCTRL to value 0"]
impl crate :: Resettable for TIMCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "DFLL"]
pub struct DFLLRC2M { _marker : PhantomData < * const () > } unsafe impl Send for DFLLRC2M { } impl DFLLRC2M { # [doc = r"Pointer to the register block"]
pub const PTR : * const dfllrc2m :: RegisterBlock = 0x68 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dfllrc2m :: RegisterBlock { Self :: PTR } } impl Deref for DFLLRC2M { type Target = dfllrc2m :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DFLLRC2M { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DFLLRC2M") . finish () } } # [doc = "DFLL"]
pub mod dfllrc2m { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Calibration Register A"]
pub cala : CALA , # [doc = "0x03 - Calibration Register B"]
pub calb : CALB , # [doc = "0x04 - Oscillator Compare Register 0"]
pub comp0 : COMP0 , # [doc = "0x05 - Oscillator Compare Register 1"]
pub comp1 : COMP1 , # [doc = "0x06 - Oscillator Compare Register 2"]
pub comp2 : COMP2 , } # [doc = "CALA (rw) register accessor: an alias for `Reg<CALA_SPEC>`"]
pub type CALA = crate :: Reg < cala :: CALA_SPEC > ; # [doc = "Calibration Register A"]
pub mod cala { # [doc = "Register `CALA` reader"]
pub struct R (crate :: R < CALA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CALA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CALA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CALA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CALA` writer"]
pub struct W (crate :: W < CALA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CALA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CALA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CALA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CALL` reader - DFLL Calibration bits \\[6:0\\]"]
pub type CALL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CALL` writer - DFLL Calibration bits \\[6:0\\]"]
pub type CALL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CALA_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - DFLL Calibration bits \\[6:0\\]"]
# [inline (always)]
pub fn call (& self) -> CALL_R { CALL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - DFLL Calibration bits \\[6:0\\]"]
# [inline (always)]
# [must_use]
pub fn call (& mut self) -> CALL_W < 0 > { CALL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Calibration Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cala](index.html) module"]
pub struct CALA_SPEC ; impl crate :: RegisterSpec for CALA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [cala::R](R) reader structure"]
impl crate :: Readable for CALA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cala::W](W) writer structure"]
impl crate :: Writable for CALA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CALA to value 0"]
impl crate :: Resettable for CALA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CALB (rw) register accessor: an alias for `Reg<CALB_SPEC>`"]
pub type CALB = crate :: Reg < calb :: CALB_SPEC > ; # [doc = "Calibration Register B"]
pub mod calb { # [doc = "Register `CALB` reader"]
pub struct R (crate :: R < CALB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CALB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CALB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CALB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CALB` writer"]
pub struct W (crate :: W < CALB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CALB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CALB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CALB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CALH` reader - DFLL Calibration bits \\[12:7\\]"]
pub type CALH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CALH` writer - DFLL Calibration bits \\[12:7\\]"]
pub type CALH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CALB_SPEC , u8 , u8 , 6 , O > ; impl R { # [doc = "Bits 0:5 - DFLL Calibration bits \\[12:7\\]"]
# [inline (always)]
pub fn calh (& self) -> CALH_R { CALH_R :: new (self . bits & 0x3f) } } impl W { # [doc = "Bits 0:5 - DFLL Calibration bits \\[12:7\\]"]
# [inline (always)]
# [must_use]
pub fn calh (& mut self) -> CALH_W < 0 > { CALH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Calibration Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calb](index.html) module"]
pub struct CALB_SPEC ; impl crate :: RegisterSpec for CALB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [calb::R](R) reader structure"]
impl crate :: Readable for CALB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [calb::W](W) writer structure"]
impl crate :: Writable for CALB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CALB to value 0"]
impl crate :: Resettable for CALB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMP0 (rw) register accessor: an alias for `Reg<COMP0_SPEC>`"]
pub type COMP0 = crate :: Reg < comp0 :: COMP0_SPEC > ; # [doc = "Oscillator Compare Register 0"]
pub mod comp0 { # [doc = "Register `COMP0` reader"]
pub struct R (crate :: R < COMP0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP0_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP0` writer"]
pub struct W (crate :: W < COMP0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Oscillator Compare Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp0](index.html) module"]
pub struct COMP0_SPEC ; impl crate :: RegisterSpec for COMP0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [comp0::R](R) reader structure"]
impl crate :: Readable for COMP0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp0::W](W) writer structure"]
impl crate :: Writable for COMP0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMP0 to value 0"]
impl crate :: Resettable for COMP0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMP1 (rw) register accessor: an alias for `Reg<COMP1_SPEC>`"]
pub type COMP1 = crate :: Reg < comp1 :: COMP1_SPEC > ; # [doc = "Oscillator Compare Register 1"]
pub mod comp1 { # [doc = "Register `COMP1` reader"]
pub struct R (crate :: R < COMP1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP1_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP1` writer"]
pub struct W (crate :: W < COMP1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Oscillator Compare Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp1](index.html) module"]
pub struct COMP1_SPEC ; impl crate :: RegisterSpec for COMP1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [comp1::R](R) reader structure"]
impl crate :: Readable for COMP1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp1::W](W) writer structure"]
impl crate :: Writable for COMP1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMP1 to value 0"]
impl crate :: Resettable for COMP1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMP2 (rw) register accessor: an alias for `Reg<COMP2_SPEC>`"]
pub type COMP2 = crate :: Reg < comp2 :: COMP2_SPEC > ; # [doc = "Oscillator Compare Register 2"]
pub mod comp2 { # [doc = "Register `COMP2` reader"]
pub struct R (crate :: R < COMP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP2` writer"]
pub struct W (crate :: W < COMP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Oscillator Compare Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp2](index.html) module"]
pub struct COMP2_SPEC ; impl crate :: RegisterSpec for COMP2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [comp2::R](R) reader structure"]
impl crate :: Readable for COMP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp2::W](W) writer structure"]
impl crate :: Writable for COMP2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMP2 to value 0"]
impl crate :: Resettable for COMP2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - DFLL Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - DFLL Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - DFLL Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - DFLL Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "DFLL"]
pub struct DFLLRC32M { _marker : PhantomData < * const () > } unsafe impl Send for DFLLRC32M { } impl DFLLRC32M { # [doc = r"Pointer to the register block"]
pub const PTR : * const dfllrc32m :: RegisterBlock = 0x60 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dfllrc32m :: RegisterBlock { Self :: PTR } } impl Deref for DFLLRC32M { type Target = dfllrc32m :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DFLLRC32M { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DFLLRC32M") . finish () } } # [doc = "DFLL"]
pub mod dfllrc32m { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Calibration Register A"]
pub cala : CALA , # [doc = "0x03 - Calibration Register B"]
pub calb : CALB , # [doc = "0x04 - Oscillator Compare Register 0"]
pub comp0 : COMP0 , # [doc = "0x05 - Oscillator Compare Register 1"]
pub comp1 : COMP1 , # [doc = "0x06 - Oscillator Compare Register 2"]
pub comp2 : COMP2 , } # [doc = "CALA (rw) register accessor: an alias for `Reg<CALA_SPEC>`"]
pub type CALA = crate :: Reg < cala :: CALA_SPEC > ; # [doc = "Calibration Register A"]
pub mod cala { # [doc = "Register `CALA` reader"]
pub struct R (crate :: R < CALA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CALA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CALA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CALA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CALA` writer"]
pub struct W (crate :: W < CALA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CALA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CALA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CALA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CALL` reader - DFLL Calibration bits \\[6:0\\]"]
pub type CALL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CALL` writer - DFLL Calibration bits \\[6:0\\]"]
pub type CALL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CALA_SPEC , u8 , u8 , 7 , O > ; impl R { # [doc = "Bits 0:6 - DFLL Calibration bits \\[6:0\\]"]
# [inline (always)]
pub fn call (& self) -> CALL_R { CALL_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - DFLL Calibration bits \\[6:0\\]"]
# [inline (always)]
# [must_use]
pub fn call (& mut self) -> CALL_W < 0 > { CALL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Calibration Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cala](index.html) module"]
pub struct CALA_SPEC ; impl crate :: RegisterSpec for CALA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [cala::R](R) reader structure"]
impl crate :: Readable for CALA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cala::W](W) writer structure"]
impl crate :: Writable for CALA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CALA to value 0"]
impl crate :: Resettable for CALA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CALB (rw) register accessor: an alias for `Reg<CALB_SPEC>`"]
pub type CALB = crate :: Reg < calb :: CALB_SPEC > ; # [doc = "Calibration Register B"]
pub mod calb { # [doc = "Register `CALB` reader"]
pub struct R (crate :: R < CALB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CALB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CALB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CALB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CALB` writer"]
pub struct W (crate :: W < CALB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CALB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CALB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CALB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CALH` reader - DFLL Calibration bits \\[12:7\\]"]
pub type CALH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CALH` writer - DFLL Calibration bits \\[12:7\\]"]
pub type CALH_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CALB_SPEC , u8 , u8 , 6 , O > ; impl R { # [doc = "Bits 0:5 - DFLL Calibration bits \\[12:7\\]"]
# [inline (always)]
pub fn calh (& self) -> CALH_R { CALH_R :: new (self . bits & 0x3f) } } impl W { # [doc = "Bits 0:5 - DFLL Calibration bits \\[12:7\\]"]
# [inline (always)]
# [must_use]
pub fn calh (& mut self) -> CALH_W < 0 > { CALH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Calibration Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calb](index.html) module"]
pub struct CALB_SPEC ; impl crate :: RegisterSpec for CALB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [calb::R](R) reader structure"]
impl crate :: Readable for CALB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [calb::W](W) writer structure"]
impl crate :: Writable for CALB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CALB to value 0"]
impl crate :: Resettable for CALB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMP0 (rw) register accessor: an alias for `Reg<COMP0_SPEC>`"]
pub type COMP0 = crate :: Reg < comp0 :: COMP0_SPEC > ; # [doc = "Oscillator Compare Register 0"]
pub mod comp0 { # [doc = "Register `COMP0` reader"]
pub struct R (crate :: R < COMP0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP0_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP0` writer"]
pub struct W (crate :: W < COMP0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Oscillator Compare Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp0](index.html) module"]
pub struct COMP0_SPEC ; impl crate :: RegisterSpec for COMP0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [comp0::R](R) reader structure"]
impl crate :: Readable for COMP0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp0::W](W) writer structure"]
impl crate :: Writable for COMP0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMP0 to value 0"]
impl crate :: Resettable for COMP0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMP1 (rw) register accessor: an alias for `Reg<COMP1_SPEC>`"]
pub type COMP1 = crate :: Reg < comp1 :: COMP1_SPEC > ; # [doc = "Oscillator Compare Register 1"]
pub mod comp1 { # [doc = "Register `COMP1` reader"]
pub struct R (crate :: R < COMP1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP1_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP1` writer"]
pub struct W (crate :: W < COMP1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Oscillator Compare Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp1](index.html) module"]
pub struct COMP1_SPEC ; impl crate :: RegisterSpec for COMP1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [comp1::R](R) reader structure"]
impl crate :: Readable for COMP1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp1::W](W) writer structure"]
impl crate :: Writable for COMP1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMP1 to value 0"]
impl crate :: Resettable for COMP1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMP2 (rw) register accessor: an alias for `Reg<COMP2_SPEC>`"]
pub type COMP2 = crate :: Reg < comp2 :: COMP2_SPEC > ; # [doc = "Oscillator Compare Register 2"]
pub mod comp2 { # [doc = "Register `COMP2` reader"]
pub struct R (crate :: R < COMP2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP2_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP2` writer"]
pub struct W (crate :: W < COMP2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Oscillator Compare Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp2](index.html) module"]
pub struct COMP2_SPEC ; impl crate :: RegisterSpec for COMP2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [comp2::R](R) reader structure"]
impl crate :: Readable for COMP2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp2::W](W) writer structure"]
impl crate :: Writable for COMP2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMP2 to value 0"]
impl crate :: Resettable for COMP2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - DFLL Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - DFLL Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - DFLL Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - DFLL Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 0 > { ENABLE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "DMA Controller"]
pub struct DMA { _marker : PhantomData < * const () > } unsafe impl Send for DMA { } impl DMA { # [doc = r"Pointer to the register block"]
pub const PTR : * const dma :: RegisterBlock = 0x0100 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dma :: RegisterBlock { Self :: PTR } } impl Deref for DMA { type Target = dma :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DMA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DMA") . finish () } } # [doc = "DMA Controller"]
pub mod dma { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : CTRL , _reserved1 : [u8 ; 0x02]
, # [doc = "0x03 - Transfer Interrupt Status"]
pub intflags : INTFLAGS , # [doc = "0x04 - Status"]
pub status : STATUS , _reserved3 : [u8 ; 0x01]
, # [doc = "0x06 - Temporary Register For 16/24-bit Access"]
pub temp : TEMP , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRIMODE` reader - Channel Priority Mode"]
pub type PRIMODE_R = crate :: FieldReader < u8 , PRIMODE_A > ; # [doc = "Channel Priority Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRIMODE_A { # [doc = "0: Round Robin"]
RR0123 = 0 , # [doc = "1: Channel 0 > Round Robin on channel 1/2/3"]
CH0RR123 = 1 , # [doc = "2: Channel 0 > channel 1 > Round Robin on channel 2/3"]
CH01RR23 = 2 , # [doc = "3: Channel 0 > channel 1 > channel 2 > channel 3"]
CH0123 = 3 , } impl From < PRIMODE_A > for u8 { # [inline (always)]
fn from (variant : PRIMODE_A) -> Self { variant as _ } } impl PRIMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRIMODE_A { match self . bits { 0 => PRIMODE_A :: RR0123 , 1 => PRIMODE_A :: CH0RR123 , 2 => PRIMODE_A :: CH01RR23 , 3 => PRIMODE_A :: CH0123 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RR0123`"]
# [inline (always)]
pub fn is_rr0123 (& self) -> bool { * self == PRIMODE_A :: RR0123 } # [doc = "Checks if the value of the field is `CH0RR123`"]
# [inline (always)]
pub fn is_ch0rr123 (& self) -> bool { * self == PRIMODE_A :: CH0RR123 } # [doc = "Checks if the value of the field is `CH01RR23`"]
# [inline (always)]
pub fn is_ch01rr23 (& self) -> bool { * self == PRIMODE_A :: CH01RR23 } # [doc = "Checks if the value of the field is `CH0123`"]
# [inline (always)]
pub fn is_ch0123 (& self) -> bool { * self == PRIMODE_A :: CH0123 } } # [doc = "Field `PRIMODE` writer - Channel Priority Mode"]
pub type PRIMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , PRIMODE_A , 2 , O > ; impl < 'a , const O : u8 > PRIMODE_W < 'a , O > { # [doc = "Round Robin"]
# [inline (always)]
pub fn rr0123 (self) -> & 'a mut W { self . variant (PRIMODE_A :: RR0123) } # [doc = "Channel 0 > Round Robin on channel 1/2/3"]
# [inline (always)]
pub fn ch0rr123 (self) -> & 'a mut W { self . variant (PRIMODE_A :: CH0RR123) } # [doc = "Channel 0 > channel 1 > Round Robin on channel 2/3"]
# [inline (always)]
pub fn ch01rr23 (self) -> & 'a mut W { self . variant (PRIMODE_A :: CH01RR23) } # [doc = "Channel 0 > channel 1 > channel 2 > channel 3"]
# [inline (always)]
pub fn ch0123 (self) -> & 'a mut W { self . variant (PRIMODE_A :: CH0123) } } # [doc = "Field `DBUFMODE` reader - Double Buffering Mode"]
pub type DBUFMODE_R = crate :: FieldReader < u8 , DBUFMODE_A > ; # [doc = "Double Buffering Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DBUFMODE_A { # [doc = "0: Double buffering disabled"]
DISABLED = 0 , # [doc = "1: Double buffering enabled on channel 0/1"]
CH01 = 1 , # [doc = "2: Double buffering enabled on channel 2/3"]
CH23 = 2 , # [doc = "3: Double buffering enabled on ch. 0/1 and ch. 2/3"]
CH01CH23 = 3 , } impl From < DBUFMODE_A > for u8 { # [inline (always)]
fn from (variant : DBUFMODE_A) -> Self { variant as _ } } impl DBUFMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DBUFMODE_A { match self . bits { 0 => DBUFMODE_A :: DISABLED , 1 => DBUFMODE_A :: CH01 , 2 => DBUFMODE_A :: CH23 , 3 => DBUFMODE_A :: CH01CH23 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == DBUFMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `CH01`"]
# [inline (always)]
pub fn is_ch01 (& self) -> bool { * self == DBUFMODE_A :: CH01 } # [doc = "Checks if the value of the field is `CH23`"]
# [inline (always)]
pub fn is_ch23 (& self) -> bool { * self == DBUFMODE_A :: CH23 } # [doc = "Checks if the value of the field is `CH01CH23`"]
# [inline (always)]
pub fn is_ch01ch23 (& self) -> bool { * self == DBUFMODE_A :: CH01CH23 } } # [doc = "Field `DBUFMODE` writer - Double Buffering Mode"]
pub type DBUFMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , DBUFMODE_A , 2 , O > ; impl < 'a , const O : u8 > DBUFMODE_W < 'a , O > { # [doc = "Double buffering disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (DBUFMODE_A :: DISABLED) } # [doc = "Double buffering enabled on channel 0/1"]
# [inline (always)]
pub fn ch01 (self) -> & 'a mut W { self . variant (DBUFMODE_A :: CH01) } # [doc = "Double buffering enabled on channel 2/3"]
# [inline (always)]
pub fn ch23 (self) -> & 'a mut W { self . variant (DBUFMODE_A :: CH23) } # [doc = "Double buffering enabled on ch. 0/1 and ch. 2/3"]
# [inline (always)]
pub fn ch01ch23 (self) -> & 'a mut W { self . variant (DBUFMODE_A :: CH01CH23) } } # [doc = "Field `RESET` reader - Software Reset"]
pub type RESET_R = crate :: BitReader < bool > ; # [doc = "Field `RESET` writer - Software Reset"]
pub type RESET_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Channel Priority Mode"]
# [inline (always)]
pub fn primode (& self) -> PRIMODE_R { PRIMODE_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Double Buffering Mode"]
# [inline (always)]
pub fn dbufmode (& self) -> DBUFMODE_R { DBUFMODE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 6 - Software Reset"]
# [inline (always)]
pub fn reset (& self) -> RESET_R { RESET_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Channel Priority Mode"]
# [inline (always)]
# [must_use]
pub fn primode (& mut self) -> PRIMODE_W < 0 > { PRIMODE_W :: new (self) } # [doc = "Bits 2:3 - Double Buffering Mode"]
# [inline (always)]
# [must_use]
pub fn dbufmode (& mut self) -> DBUFMODE_W < 2 > { DBUFMODE_W :: new (self) } # [doc = "Bit 6 - Software Reset"]
# [inline (always)]
# [must_use]
pub fn reset (& mut self) -> RESET_W < 6 > { RESET_W :: new (self) } # [doc = "Bit 7 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 7 > { ENABLE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Transfer Interrupt Status"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CH0TRNIF` reader - Channel 0 Transaction Complete Interrupt Flag"]
pub type CH0TRNIF_R = crate :: BitReader < bool > ; # [doc = "Field `CH0TRNIF` writer - Channel 0 Transaction Complete Interrupt Flag"]
pub type CH0TRNIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH1TRNIF` reader - Channel 1 Transaction Complete Interrupt Flag"]
pub type CH1TRNIF_R = crate :: BitReader < bool > ; # [doc = "Field `CH1TRNIF` writer - Channel 1 Transaction Complete Interrupt Flag"]
pub type CH1TRNIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH2TRNIF` reader - Channel 2 Transaction Complete Interrupt Flag"]
pub type CH2TRNIF_R = crate :: BitReader < bool > ; # [doc = "Field `CH2TRNIF` writer - Channel 2 Transaction Complete Interrupt Flag"]
pub type CH2TRNIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH3TRNIF` reader - Channel 3 Transaction Complete Interrupt Flag"]
pub type CH3TRNIF_R = crate :: BitReader < bool > ; # [doc = "Field `CH3TRNIF` writer - Channel 3 Transaction Complete Interrupt Flag"]
pub type CH3TRNIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH0ERRIF` reader - Channel 0 Block Transfer Error Interrupt Flag"]
pub type CH0ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `CH0ERRIF` writer - Channel 0 Block Transfer Error Interrupt Flag"]
pub type CH0ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH1ERRIF` reader - Channel 1 Block Transfer Error Interrupt Flag"]
pub type CH1ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `CH1ERRIF` writer - Channel 1 Block Transfer Error Interrupt Flag"]
pub type CH1ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH2ERRIF` reader - Channel 2 Block Transfer Error Interrupt Flag"]
pub type CH2ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `CH2ERRIF` writer - Channel 2 Block Transfer Error Interrupt Flag"]
pub type CH2ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CH3ERRIF` reader - Channel 3 Block Transfer Error Interrupt Flag"]
pub type CH3ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `CH3ERRIF` writer - Channel 3 Block Transfer Error Interrupt Flag"]
pub type CH3ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Channel 0 Transaction Complete Interrupt Flag"]
# [inline (always)]
pub fn ch0trnif (& self) -> CH0TRNIF_R { CH0TRNIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Transaction Complete Interrupt Flag"]
# [inline (always)]
pub fn ch1trnif (& self) -> CH1TRNIF_R { CH1TRNIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Transaction Complete Interrupt Flag"]
# [inline (always)]
pub fn ch2trnif (& self) -> CH2TRNIF_R { CH2TRNIF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Transaction Complete Interrupt Flag"]
# [inline (always)]
pub fn ch3trnif (& self) -> CH3TRNIF_R { CH3TRNIF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 0 Block Transfer Error Interrupt Flag"]
# [inline (always)]
pub fn ch0errif (& self) -> CH0ERRIF_R { CH0ERRIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 1 Block Transfer Error Interrupt Flag"]
# [inline (always)]
pub fn ch1errif (& self) -> CH1ERRIF_R { CH1ERRIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Channel 2 Block Transfer Error Interrupt Flag"]
# [inline (always)]
pub fn ch2errif (& self) -> CH2ERRIF_R { CH2ERRIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Channel 3 Block Transfer Error Interrupt Flag"]
# [inline (always)]
pub fn ch3errif (& self) -> CH3ERRIF_R { CH3ERRIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Transaction Complete Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch0trnif (& mut self) -> CH0TRNIF_W < 0 > { CH0TRNIF_W :: new (self) } # [doc = "Bit 1 - Channel 1 Transaction Complete Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch1trnif (& mut self) -> CH1TRNIF_W < 1 > { CH1TRNIF_W :: new (self) } # [doc = "Bit 2 - Channel 2 Transaction Complete Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch2trnif (& mut self) -> CH2TRNIF_W < 2 > { CH2TRNIF_W :: new (self) } # [doc = "Bit 3 - Channel 3 Transaction Complete Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch3trnif (& mut self) -> CH3TRNIF_W < 3 > { CH3TRNIF_W :: new (self) } # [doc = "Bit 4 - Channel 0 Block Transfer Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch0errif (& mut self) -> CH0ERRIF_W < 4 > { CH0ERRIF_W :: new (self) } # [doc = "Bit 5 - Channel 1 Block Transfer Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch1errif (& mut self) -> CH1ERRIF_W < 5 > { CH1ERRIF_W :: new (self) } # [doc = "Bit 6 - Channel 2 Block Transfer Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch2errif (& mut self) -> CH2ERRIF_W < 6 > { CH2ERRIF_W :: new (self) } # [doc = "Bit 7 - Channel 3 Block Transfer Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ch3errif (& mut self) -> CH3ERRIF_W < 7 > { CH3ERRIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Transfer Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CH0PEND` reader - Channel 0 Block Transfer Pending"]
pub type CH0PEND_R = crate :: BitReader < bool > ; # [doc = "Field `CH0PEND` writer - Channel 0 Block Transfer Pending"]
pub type CH0PEND_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH1PEND` reader - Channel 1 Block Transfer Pending"]
pub type CH1PEND_R = crate :: BitReader < bool > ; # [doc = "Field `CH1PEND` writer - Channel 1 Block Transfer Pending"]
pub type CH1PEND_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH2PEND` reader - Channel 2 Block Transfer Pending"]
pub type CH2PEND_R = crate :: BitReader < bool > ; # [doc = "Field `CH2PEND` writer - Channel 2 Block Transfer Pending"]
pub type CH2PEND_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH3PEND` reader - Channel 3 Block Transfer Pending"]
pub type CH3PEND_R = crate :: BitReader < bool > ; # [doc = "Field `CH3PEND` writer - Channel 3 Block Transfer Pending"]
pub type CH3PEND_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH0BUSY` reader - Channel 0 Block Transfer Busy"]
pub type CH0BUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CH0BUSY` writer - Channel 0 Block Transfer Busy"]
pub type CH0BUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH1BUSY` reader - Channel 1 Block Transfer Busy"]
pub type CH1BUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CH1BUSY` writer - Channel 1 Block Transfer Busy"]
pub type CH1BUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH2BUSY` reader - Channel 2 Block Transfer Busy"]
pub type CH2BUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CH2BUSY` writer - Channel 2 Block Transfer Busy"]
pub type CH2BUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `CH3BUSY` reader - Channel 3 Block Transfer Busy"]
pub type CH3BUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CH3BUSY` writer - Channel 3 Block Transfer Busy"]
pub type CH3BUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Channel 0 Block Transfer Pending"]
# [inline (always)]
pub fn ch0pend (& self) -> CH0PEND_R { CH0PEND_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Block Transfer Pending"]
# [inline (always)]
pub fn ch1pend (& self) -> CH1PEND_R { CH1PEND_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Block Transfer Pending"]
# [inline (always)]
pub fn ch2pend (& self) -> CH2PEND_R { CH2PEND_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Block Transfer Pending"]
# [inline (always)]
pub fn ch3pend (& self) -> CH3PEND_R { CH3PEND_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 0 Block Transfer Busy"]
# [inline (always)]
pub fn ch0busy (& self) -> CH0BUSY_R { CH0BUSY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 1 Block Transfer Busy"]
# [inline (always)]
pub fn ch1busy (& self) -> CH1BUSY_R { CH1BUSY_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Channel 2 Block Transfer Busy"]
# [inline (always)]
pub fn ch2busy (& self) -> CH2BUSY_R { CH2BUSY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Channel 3 Block Transfer Busy"]
# [inline (always)]
pub fn ch3busy (& self) -> CH3BUSY_R { CH3BUSY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Block Transfer Pending"]
# [inline (always)]
# [must_use]
pub fn ch0pend (& mut self) -> CH0PEND_W < 0 > { CH0PEND_W :: new (self) } # [doc = "Bit 1 - Channel 1 Block Transfer Pending"]
# [inline (always)]
# [must_use]
pub fn ch1pend (& mut self) -> CH1PEND_W < 1 > { CH1PEND_W :: new (self) } # [doc = "Bit 2 - Channel 2 Block Transfer Pending"]
# [inline (always)]
# [must_use]
pub fn ch2pend (& mut self) -> CH2PEND_W < 2 > { CH2PEND_W :: new (self) } # [doc = "Bit 3 - Channel 3 Block Transfer Pending"]
# [inline (always)]
# [must_use]
pub fn ch3pend (& mut self) -> CH3PEND_W < 3 > { CH3PEND_W :: new (self) } # [doc = "Bit 4 - Channel 0 Block Transfer Busy"]
# [inline (always)]
# [must_use]
pub fn ch0busy (& mut self) -> CH0BUSY_W < 4 > { CH0BUSY_W :: new (self) } # [doc = "Bit 5 - Channel 1 Block Transfer Busy"]
# [inline (always)]
# [must_use]
pub fn ch1busy (& mut self) -> CH1BUSY_W < 5 > { CH1BUSY_W :: new (self) } # [doc = "Bit 6 - Channel 2 Block Transfer Busy"]
# [inline (always)]
# [must_use]
pub fn ch2busy (& mut self) -> CH2BUSY_W < 6 > { CH2BUSY_W :: new (self) } # [doc = "Bit 7 - Channel 3 Block Transfer Busy"]
# [inline (always)]
# [must_use]
pub fn ch3busy (& mut self) -> CH3BUSY_W < 7 > { CH3BUSY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16/24-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16/24-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "External Bus Interface"]
pub struct EBI { _marker : PhantomData < * const () > } unsafe impl Send for EBI { } impl EBI { # [doc = r"Pointer to the register block"]
pub const PTR : * const ebi :: RegisterBlock = 0x0440 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ebi :: RegisterBlock { Self :: PTR } } impl Deref for EBI { type Target = ebi :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EBI { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EBI") . finish () } } # [doc = "External Bus Interface"]
pub mod ebi { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : CTRL , # [doc = "0x01 - SDRAM Control Register A"]
pub sdramctrla : SDRAMCTRLA , _reserved2 : [u8 ; 0x02]
, # [doc = "0x04 - SDRAM Refresh Period"]
pub refresh : REFRESH , # [doc = "0x06 - SDRAM Initialization Delay"]
pub initdly : INITDLY , # [doc = "0x08 - SDRAM Control Register B"]
pub sdramctrlb : SDRAMCTRLB , # [doc = "0x09 - SDRAM Control Register C"]
pub sdramctrlc : SDRAMCTRLC , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `IFMODE` reader - Interface Mode"]
pub type IFMODE_R = crate :: FieldReader < u8 , IFMODE_A > ; # [doc = "Interface Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum IFMODE_A { # [doc = "0: EBI Disabled"]
DISABLED = 0 , # [doc = "1: 3-port mode"]
_3PORT = 1 , # [doc = "2: 4-port mode"]
_4PORT = 2 , # [doc = "3: 2-port mode"]
_2PORT = 3 , } impl From < IFMODE_A > for u8 { # [inline (always)]
fn from (variant : IFMODE_A) -> Self { variant as _ } } impl IFMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> IFMODE_A { match self . bits { 0 => IFMODE_A :: DISABLED , 1 => IFMODE_A :: _3PORT , 2 => IFMODE_A :: _4PORT , 3 => IFMODE_A :: _2PORT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == IFMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `_3PORT`"]
# [inline (always)]
pub fn is_3port (& self) -> bool { * self == IFMODE_A :: _3PORT } # [doc = "Checks if the value of the field is `_4PORT`"]
# [inline (always)]
pub fn is_4port (& self) -> bool { * self == IFMODE_A :: _4PORT } # [doc = "Checks if the value of the field is `_2PORT`"]
# [inline (always)]
pub fn is_2port (& self) -> bool { * self == IFMODE_A :: _2PORT } } # [doc = "Field `IFMODE` writer - Interface Mode"]
pub type IFMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , IFMODE_A , 2 , O > ; impl < 'a , const O : u8 > IFMODE_W < 'a , O > { # [doc = "EBI Disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (IFMODE_A :: DISABLED) } # [doc = "3-port mode"]
# [inline (always)]
pub fn _3port (self) -> & 'a mut W { self . variant (IFMODE_A :: _3PORT) } # [doc = "4-port mode"]
# [inline (always)]
pub fn _4port (self) -> & 'a mut W { self . variant (IFMODE_A :: _4PORT) } # [doc = "2-port mode"]
# [inline (always)]
pub fn _2port (self) -> & 'a mut W { self . variant (IFMODE_A :: _2PORT) } } # [doc = "Field `SRMODE` reader - SRAM Mode"]
pub type SRMODE_R = crate :: FieldReader < u8 , SRMODE_A > ; # [doc = "SRAM Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SRMODE_A { # [doc = "0: Addr byte 0 muxed with 1"]
ALE1 = 0 , # [doc = "1: Addr byte 0 muxed with 2"]
ALE2 = 1 , # [doc = "2: Addr byte 0 muxed with 1 and 2"]
ALE12 = 2 , # [doc = "3: No addr muxing"]
NOALE = 3 , } impl From < SRMODE_A > for u8 { # [inline (always)]
fn from (variant : SRMODE_A) -> Self { variant as _ } } impl SRMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SRMODE_A { match self . bits { 0 => SRMODE_A :: ALE1 , 1 => SRMODE_A :: ALE2 , 2 => SRMODE_A :: ALE12 , 3 => SRMODE_A :: NOALE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ALE1`"]
# [inline (always)]
pub fn is_ale1 (& self) -> bool { * self == SRMODE_A :: ALE1 } # [doc = "Checks if the value of the field is `ALE2`"]
# [inline (always)]
pub fn is_ale2 (& self) -> bool { * self == SRMODE_A :: ALE2 } # [doc = "Checks if the value of the field is `ALE12`"]
# [inline (always)]
pub fn is_ale12 (& self) -> bool { * self == SRMODE_A :: ALE12 } # [doc = "Checks if the value of the field is `NOALE`"]
# [inline (always)]
pub fn is_noale (& self) -> bool { * self == SRMODE_A :: NOALE } } # [doc = "Field `SRMODE` writer - SRAM Mode"]
pub type SRMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , SRMODE_A , 2 , O > ; impl < 'a , const O : u8 > SRMODE_W < 'a , O > { # [doc = "Addr byte 0 muxed with 1"]
# [inline (always)]
pub fn ale1 (self) -> & 'a mut W { self . variant (SRMODE_A :: ALE1) } # [doc = "Addr byte 0 muxed with 2"]
# [inline (always)]
pub fn ale2 (self) -> & 'a mut W { self . variant (SRMODE_A :: ALE2) } # [doc = "Addr byte 0 muxed with 1 and 2"]
# [inline (always)]
pub fn ale12 (self) -> & 'a mut W { self . variant (SRMODE_A :: ALE12) } # [doc = "No addr muxing"]
# [inline (always)]
pub fn noale (self) -> & 'a mut W { self . variant (SRMODE_A :: NOALE) } } # [doc = "Field `LPCMODE` reader - SRAM LPC Mode"]
pub type LPCMODE_R = crate :: FieldReader < u8 , LPCMODE_A > ; # [doc = "SRAM LPC Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LPCMODE_A { # [doc = "0: Data muxed with addr byte 0"]
ALE1 = 0 , # [doc = "2: Data muxed with addr byte 0 and 1"]
ALE12 = 2 , } impl From < LPCMODE_A > for u8 { # [inline (always)]
fn from (variant : LPCMODE_A) -> Self { variant as _ } } impl LPCMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LPCMODE_A > { match self . bits { 0 => Some (LPCMODE_A :: ALE1) , 2 => Some (LPCMODE_A :: ALE12) , _ => None , } } # [doc = "Checks if the value of the field is `ALE1`"]
# [inline (always)]
pub fn is_ale1 (& self) -> bool { * self == LPCMODE_A :: ALE1 } # [doc = "Checks if the value of the field is `ALE12`"]
# [inline (always)]
pub fn is_ale12 (& self) -> bool { * self == LPCMODE_A :: ALE12 } } # [doc = "Field `LPCMODE` writer - SRAM LPC Mode"]
pub type LPCMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRL_SPEC , u8 , LPCMODE_A , 2 , O > ; impl < 'a , const O : u8 > LPCMODE_W < 'a , O > { # [doc = "Data muxed with addr byte 0"]
# [inline (always)]
pub fn ale1 (self) -> & 'a mut W { self . variant (LPCMODE_A :: ALE1) } # [doc = "Data muxed with addr byte 0 and 1"]
# [inline (always)]
pub fn ale12 (self) -> & 'a mut W { self . variant (LPCMODE_A :: ALE12) } } # [doc = "Field `SDDATAW` reader - SDRAM Data Width Setting"]
pub type SDDATAW_R = crate :: FieldReader < u8 , SDDATAW_A > ; # [doc = "SDRAM Data Width Setting\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SDDATAW_A { # [doc = "0: 4-bit data bus"]
_4BIT = 0 , # [doc = "1: 8-bit data bus"]
_8BIT = 1 , } impl From < SDDATAW_A > for u8 { # [inline (always)]
fn from (variant : SDDATAW_A) -> Self { variant as _ } } impl SDDATAW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SDDATAW_A > { match self . bits { 0 => Some (SDDATAW_A :: _4BIT) , 1 => Some (SDDATAW_A :: _8BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_4BIT`"]
# [inline (always)]
pub fn is_4bit (& self) -> bool { * self == SDDATAW_A :: _4BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == SDDATAW_A :: _8BIT } } # [doc = "Field `SDDATAW` writer - SDRAM Data Width Setting"]
pub type SDDATAW_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRL_SPEC , u8 , SDDATAW_A , 2 , O > ; impl < 'a , const O : u8 > SDDATAW_W < 'a , O > { # [doc = "4-bit data bus"]
# [inline (always)]
pub fn _4bit (self) -> & 'a mut W { self . variant (SDDATAW_A :: _4BIT) } # [doc = "8-bit data bus"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (SDDATAW_A :: _8BIT) } } impl R { # [doc = "Bits 0:1 - Interface Mode"]
# [inline (always)]
pub fn ifmode (& self) -> IFMODE_R { IFMODE_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - SRAM Mode"]
# [inline (always)]
pub fn srmode (& self) -> SRMODE_R { SRMODE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - SRAM LPC Mode"]
# [inline (always)]
pub fn lpcmode (& self) -> LPCMODE_R { LPCMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - SDRAM Data Width Setting"]
# [inline (always)]
pub fn sddataw (& self) -> SDDATAW_R { SDDATAW_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Interface Mode"]
# [inline (always)]
# [must_use]
pub fn ifmode (& mut self) -> IFMODE_W < 0 > { IFMODE_W :: new (self) } # [doc = "Bits 2:3 - SRAM Mode"]
# [inline (always)]
# [must_use]
pub fn srmode (& mut self) -> SRMODE_W < 2 > { SRMODE_W :: new (self) } # [doc = "Bits 4:5 - SRAM LPC Mode"]
# [inline (always)]
# [must_use]
pub fn lpcmode (& mut self) -> LPCMODE_W < 4 > { LPCMODE_W :: new (self) } # [doc = "Bits 6:7 - SDRAM Data Width Setting"]
# [inline (always)]
# [must_use]
pub fn sddataw (& mut self) -> SDDATAW_W < 6 > { SDDATAW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INITDLY (rw) register accessor: an alias for `Reg<INITDLY_SPEC>`"]
pub type INITDLY = crate :: Reg < initdly :: INITDLY_SPEC > ; # [doc = "SDRAM Initialization Delay"]
pub mod initdly { # [doc = "Register `INITDLY` reader"]
pub struct R (crate :: R < INITDLY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INITDLY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INITDLY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INITDLY_SPEC >) -> Self { R (reader) } } # [doc = "Register `INITDLY` writer"]
pub struct W (crate :: W < INITDLY_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INITDLY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INITDLY_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INITDLY_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "SDRAM Initialization Delay\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [initdly](index.html) module"]
pub struct INITDLY_SPEC ; impl crate :: RegisterSpec for INITDLY_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [initdly::R](R) reader structure"]
impl crate :: Readable for INITDLY_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [initdly::W](W) writer structure"]
impl crate :: Writable for INITDLY_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INITDLY to value 0"]
impl crate :: Resettable for INITDLY_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "REFRESH (rw) register accessor: an alias for `Reg<REFRESH_SPEC>`"]
pub type REFRESH = crate :: Reg < refresh :: REFRESH_SPEC > ; # [doc = "SDRAM Refresh Period"]
pub mod refresh { # [doc = "Register `REFRESH` reader"]
pub struct R (crate :: R < REFRESH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < REFRESH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < REFRESH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < REFRESH_SPEC >) -> Self { R (reader) } } # [doc = "Register `REFRESH` writer"]
pub struct W (crate :: W < REFRESH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < REFRESH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < REFRESH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < REFRESH_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "SDRAM Refresh Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [refresh](index.html) module"]
pub struct REFRESH_SPEC ; impl crate :: RegisterSpec for REFRESH_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [refresh::R](R) reader structure"]
impl crate :: Readable for REFRESH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [refresh::W](W) writer structure"]
impl crate :: Writable for REFRESH_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets REFRESH to value 0"]
impl crate :: Resettable for REFRESH_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SDRAMCTRLA (rw) register accessor: an alias for `Reg<SDRAMCTRLA_SPEC>`"]
pub type SDRAMCTRLA = crate :: Reg < sdramctrla :: SDRAMCTRLA_SPEC > ; # [doc = "SDRAM Control Register A"]
pub mod sdramctrla { # [doc = "Register `SDRAMCTRLA` reader"]
pub struct R (crate :: R < SDRAMCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SDRAMCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SDRAMCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SDRAMCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `SDRAMCTRLA` writer"]
pub struct W (crate :: W < SDRAMCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SDRAMCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SDRAMCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SDRAMCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SDCOL` reader - SDRAM Column Bits Setting"]
pub type SDCOL_R = crate :: FieldReader < u8 , SDCOL_A > ; # [doc = "SDRAM Column Bits Setting\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SDCOL_A { # [doc = "0: 8 column bits"]
_8BIT = 0 , # [doc = "1: 9 column bits"]
_9BIT = 1 , # [doc = "2: 10 column bits"]
_10BIT = 2 , # [doc = "3: 11 column bits"]
_11BIT = 3 , } impl From < SDCOL_A > for u8 { # [inline (always)]
fn from (variant : SDCOL_A) -> Self { variant as _ } } impl SDCOL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SDCOL_A { match self . bits { 0 => SDCOL_A :: _8BIT , 1 => SDCOL_A :: _9BIT , 2 => SDCOL_A :: _10BIT , 3 => SDCOL_A :: _11BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == SDCOL_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == SDCOL_A :: _9BIT } # [doc = "Checks if the value of the field is `_10BIT`"]
# [inline (always)]
pub fn is_10bit (& self) -> bool { * self == SDCOL_A :: _10BIT } # [doc = "Checks if the value of the field is `_11BIT`"]
# [inline (always)]
pub fn is_11bit (& self) -> bool { * self == SDCOL_A :: _11BIT } } # [doc = "Field `SDCOL` writer - SDRAM Column Bits Setting"]
pub type SDCOL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SDRAMCTRLA_SPEC , u8 , SDCOL_A , 2 , O > ; impl < 'a , const O : u8 > SDCOL_W < 'a , O > { # [doc = "8 column bits"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (SDCOL_A :: _8BIT) } # [doc = "9 column bits"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (SDCOL_A :: _9BIT) } # [doc = "10 column bits"]
# [inline (always)]
pub fn _10bit (self) -> & 'a mut W { self . variant (SDCOL_A :: _10BIT) } # [doc = "11 column bits"]
# [inline (always)]
pub fn _11bit (self) -> & 'a mut W { self . variant (SDCOL_A :: _11BIT) } } # [doc = "Field `SDROW` reader - SDRAM ROW Bits Setting"]
pub type SDROW_R = crate :: BitReader < bool > ; # [doc = "Field `SDROW` writer - SDRAM ROW Bits Setting"]
pub type SDROW_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SDRAMCTRLA_SPEC , bool , O > ; # [doc = "Field `SDCAS` reader - SDRAM CAS Latency Setting"]
pub type SDCAS_R = crate :: BitReader < bool > ; # [doc = "Field `SDCAS` writer - SDRAM CAS Latency Setting"]
pub type SDCAS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , SDRAMCTRLA_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - SDRAM Column Bits Setting"]
# [inline (always)]
pub fn sdcol (& self) -> SDCOL_R { SDCOL_R :: new (self . bits & 3) } # [doc = "Bit 2 - SDRAM ROW Bits Setting"]
# [inline (always)]
pub fn sdrow (& self) -> SDROW_R { SDROW_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - SDRAM CAS Latency Setting"]
# [inline (always)]
pub fn sdcas (& self) -> SDCAS_R { SDCAS_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - SDRAM Column Bits Setting"]
# [inline (always)]
# [must_use]
pub fn sdcol (& mut self) -> SDCOL_W < 0 > { SDCOL_W :: new (self) } # [doc = "Bit 2 - SDRAM ROW Bits Setting"]
# [inline (always)]
# [must_use]
pub fn sdrow (& mut self) -> SDROW_W < 2 > { SDROW_W :: new (self) } # [doc = "Bit 3 - SDRAM CAS Latency Setting"]
# [inline (always)]
# [must_use]
pub fn sdcas (& mut self) -> SDCAS_W < 3 > { SDCAS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SDRAM Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sdramctrla](index.html) module"]
pub struct SDRAMCTRLA_SPEC ; impl crate :: RegisterSpec for SDRAMCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sdramctrla::R](R) reader structure"]
impl crate :: Readable for SDRAMCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sdramctrla::W](W) writer structure"]
impl crate :: Writable for SDRAMCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SDRAMCTRLA to value 0"]
impl crate :: Resettable for SDRAMCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SDRAMCTRLB (rw) register accessor: an alias for `Reg<SDRAMCTRLB_SPEC>`"]
pub type SDRAMCTRLB = crate :: Reg < sdramctrlb :: SDRAMCTRLB_SPEC > ; # [doc = "SDRAM Control Register B"]
pub mod sdramctrlb { # [doc = "Register `SDRAMCTRLB` reader"]
pub struct R (crate :: R < SDRAMCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SDRAMCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SDRAMCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SDRAMCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `SDRAMCTRLB` writer"]
pub struct W (crate :: W < SDRAMCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SDRAMCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SDRAMCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SDRAMCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `RPDLY` reader - SDRAM Row-to-Precharge Delay"]
pub type RPDLY_R = crate :: FieldReader < u8 , RPDLY_A > ; # [doc = "SDRAM Row-to-Precharge Delay\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RPDLY_A { # [doc = "0: 0 cycles"]
_0CLK = 0 , # [doc = "1: 1 cycle"]
_1CLK = 1 , # [doc = "2: 2 cycles"]
_2CLK = 2 , # [doc = "3: 3 cycles"]
_3CLK = 3 , # [doc = "4: 4 cycles"]
_4CLK = 4 , # [doc = "5: 5 cycles"]
_5CLK = 5 , # [doc = "6: 6 cycles"]
_6CLK = 6 , # [doc = "7: 7 cycles"]
_7CLK = 7 , } impl From < RPDLY_A > for u8 { # [inline (always)]
fn from (variant : RPDLY_A) -> Self { variant as _ } } impl RPDLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RPDLY_A { match self . bits { 0 => RPDLY_A :: _0CLK , 1 => RPDLY_A :: _1CLK , 2 => RPDLY_A :: _2CLK , 3 => RPDLY_A :: _3CLK , 4 => RPDLY_A :: _4CLK , 5 => RPDLY_A :: _5CLK , 6 => RPDLY_A :: _6CLK , 7 => RPDLY_A :: _7CLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0CLK`"]
# [inline (always)]
pub fn is_0clk (& self) -> bool { * self == RPDLY_A :: _0CLK } # [doc = "Checks if the value of the field is `_1CLK`"]
# [inline (always)]
pub fn is_1clk (& self) -> bool { * self == RPDLY_A :: _1CLK } # [doc = "Checks if the value of the field is `_2CLK`"]
# [inline (always)]
pub fn is_2clk (& self) -> bool { * self == RPDLY_A :: _2CLK } # [doc = "Checks if the value of the field is `_3CLK`"]
# [inline (always)]
pub fn is_3clk (& self) -> bool { * self == RPDLY_A :: _3CLK } # [doc = "Checks if the value of the field is `_4CLK`"]
# [inline (always)]
pub fn is_4clk (& self) -> bool { * self == RPDLY_A :: _4CLK } # [doc = "Checks if the value of the field is `_5CLK`"]
# [inline (always)]
pub fn is_5clk (& self) -> bool { * self == RPDLY_A :: _5CLK } # [doc = "Checks if the value of the field is `_6CLK`"]
# [inline (always)]
pub fn is_6clk (& self) -> bool { * self == RPDLY_A :: _6CLK } # [doc = "Checks if the value of the field is `_7CLK`"]
# [inline (always)]
pub fn is_7clk (& self) -> bool { * self == RPDLY_A :: _7CLK } } # [doc = "Field `RPDLY` writer - SDRAM Row-to-Precharge Delay"]
pub type RPDLY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SDRAMCTRLB_SPEC , u8 , RPDLY_A , 3 , O > ; impl < 'a , const O : u8 > RPDLY_W < 'a , O > { # [doc = "0 cycles"]
# [inline (always)]
pub fn _0clk (self) -> & 'a mut W { self . variant (RPDLY_A :: _0CLK) } # [doc = "1 cycle"]
# [inline (always)]
pub fn _1clk (self) -> & 'a mut W { self . variant (RPDLY_A :: _1CLK) } # [doc = "2 cycles"]
# [inline (always)]
pub fn _2clk (self) -> & 'a mut W { self . variant (RPDLY_A :: _2CLK) } # [doc = "3 cycles"]
# [inline (always)]
pub fn _3clk (self) -> & 'a mut W { self . variant (RPDLY_A :: _3CLK) } # [doc = "4 cycles"]
# [inline (always)]
pub fn _4clk (self) -> & 'a mut W { self . variant (RPDLY_A :: _4CLK) } # [doc = "5 cycles"]
# [inline (always)]
pub fn _5clk (self) -> & 'a mut W { self . variant (RPDLY_A :: _5CLK) } # [doc = "6 cycles"]
# [inline (always)]
pub fn _6clk (self) -> & 'a mut W { self . variant (RPDLY_A :: _6CLK) } # [doc = "7 cycles"]
# [inline (always)]
pub fn _7clk (self) -> & 'a mut W { self . variant (RPDLY_A :: _7CLK) } } # [doc = "Field `ROWCYCDLY` reader - SDRAM Row Cycle Delay"]
pub type ROWCYCDLY_R = crate :: FieldReader < u8 , ROWCYCDLY_A > ; # [doc = "SDRAM Row Cycle Delay\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ROWCYCDLY_A { # [doc = "0: 0 cycles"]
_0CLK = 0 , # [doc = "1: 1 cycle"]
_1CLK = 1 , # [doc = "2: 2 cycles"]
_2CLK = 2 , # [doc = "3: 3 cycles"]
_3CLK = 3 , # [doc = "4: 4 cycles"]
_4CLK = 4 , # [doc = "5: 5 cycles"]
_5CLK = 5 , # [doc = "6: 6 cycles"]
_6CLK = 6 , # [doc = "7: 7 cycles"]
_7CLK = 7 , } impl From < ROWCYCDLY_A > for u8 { # [inline (always)]
fn from (variant : ROWCYCDLY_A) -> Self { variant as _ } } impl ROWCYCDLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ROWCYCDLY_A { match self . bits { 0 => ROWCYCDLY_A :: _0CLK , 1 => ROWCYCDLY_A :: _1CLK , 2 => ROWCYCDLY_A :: _2CLK , 3 => ROWCYCDLY_A :: _3CLK , 4 => ROWCYCDLY_A :: _4CLK , 5 => ROWCYCDLY_A :: _5CLK , 6 => ROWCYCDLY_A :: _6CLK , 7 => ROWCYCDLY_A :: _7CLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0CLK`"]
# [inline (always)]
pub fn is_0clk (& self) -> bool { * self == ROWCYCDLY_A :: _0CLK } # [doc = "Checks if the value of the field is `_1CLK`"]
# [inline (always)]
pub fn is_1clk (& self) -> bool { * self == ROWCYCDLY_A :: _1CLK } # [doc = "Checks if the value of the field is `_2CLK`"]
# [inline (always)]
pub fn is_2clk (& self) -> bool { * self == ROWCYCDLY_A :: _2CLK } # [doc = "Checks if the value of the field is `_3CLK`"]
# [inline (always)]
pub fn is_3clk (& self) -> bool { * self == ROWCYCDLY_A :: _3CLK } # [doc = "Checks if the value of the field is `_4CLK`"]
# [inline (always)]
pub fn is_4clk (& self) -> bool { * self == ROWCYCDLY_A :: _4CLK } # [doc = "Checks if the value of the field is `_5CLK`"]
# [inline (always)]
pub fn is_5clk (& self) -> bool { * self == ROWCYCDLY_A :: _5CLK } # [doc = "Checks if the value of the field is `_6CLK`"]
# [inline (always)]
pub fn is_6clk (& self) -> bool { * self == ROWCYCDLY_A :: _6CLK } # [doc = "Checks if the value of the field is `_7CLK`"]
# [inline (always)]
pub fn is_7clk (& self) -> bool { * self == ROWCYCDLY_A :: _7CLK } } # [doc = "Field `ROWCYCDLY` writer - SDRAM Row Cycle Delay"]
pub type ROWCYCDLY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SDRAMCTRLB_SPEC , u8 , ROWCYCDLY_A , 3 , O > ; impl < 'a , const O : u8 > ROWCYCDLY_W < 'a , O > { # [doc = "0 cycles"]
# [inline (always)]
pub fn _0clk (self) -> & 'a mut W { self . variant (ROWCYCDLY_A :: _0CLK) } # [doc = "1 cycle"]
# [inline (always)]
pub fn _1clk (self) -> & 'a mut W { self . variant (ROWCYCDLY_A :: _1CLK) } # [doc = "2 cycles"]
# [inline (always)]
pub fn _2clk (self) -> & 'a mut W { self . variant (ROWCYCDLY_A :: _2CLK) } # [doc = "3 cycles"]
# [inline (always)]
pub fn _3clk (self) -> & 'a mut W { self . variant (ROWCYCDLY_A :: _3CLK) } # [doc = "4 cycles"]
# [inline (always)]
pub fn _4clk (self) -> & 'a mut W { self . variant (ROWCYCDLY_A :: _4CLK) } # [doc = "5 cycles"]
# [inline (always)]
pub fn _5clk (self) -> & 'a mut W { self . variant (ROWCYCDLY_A :: _5CLK) } # [doc = "6 cycles"]
# [inline (always)]
pub fn _6clk (self) -> & 'a mut W { self . variant (ROWCYCDLY_A :: _6CLK) } # [doc = "7 cycles"]
# [inline (always)]
pub fn _7clk (self) -> & 'a mut W { self . variant (ROWCYCDLY_A :: _7CLK) } } # [doc = "Field `MRDLY` reader - SDRAM Mode Register Delay"]
pub type MRDLY_R = crate :: FieldReader < u8 , MRDLY_A > ; # [doc = "SDRAM Mode Register Delay\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MRDLY_A { # [doc = "0: 0 cycles"]
_0CLK = 0 , # [doc = "1: 1 cycle"]
_1CLK = 1 , # [doc = "2: 2 cycles"]
_2CLK = 2 , # [doc = "3: 3 cycles"]
_3CLK = 3 , } impl From < MRDLY_A > for u8 { # [inline (always)]
fn from (variant : MRDLY_A) -> Self { variant as _ } } impl MRDLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MRDLY_A { match self . bits { 0 => MRDLY_A :: _0CLK , 1 => MRDLY_A :: _1CLK , 2 => MRDLY_A :: _2CLK , 3 => MRDLY_A :: _3CLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0CLK`"]
# [inline (always)]
pub fn is_0clk (& self) -> bool { * self == MRDLY_A :: _0CLK } # [doc = "Checks if the value of the field is `_1CLK`"]
# [inline (always)]
pub fn is_1clk (& self) -> bool { * self == MRDLY_A :: _1CLK } # [doc = "Checks if the value of the field is `_2CLK`"]
# [inline (always)]
pub fn is_2clk (& self) -> bool { * self == MRDLY_A :: _2CLK } # [doc = "Checks if the value of the field is `_3CLK`"]
# [inline (always)]
pub fn is_3clk (& self) -> bool { * self == MRDLY_A :: _3CLK } } # [doc = "Field `MRDLY` writer - SDRAM Mode Register Delay"]
pub type MRDLY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SDRAMCTRLB_SPEC , u8 , MRDLY_A , 2 , O > ; impl < 'a , const O : u8 > MRDLY_W < 'a , O > { # [doc = "0 cycles"]
# [inline (always)]
pub fn _0clk (self) -> & 'a mut W { self . variant (MRDLY_A :: _0CLK) } # [doc = "1 cycle"]
# [inline (always)]
pub fn _1clk (self) -> & 'a mut W { self . variant (MRDLY_A :: _1CLK) } # [doc = "2 cycles"]
# [inline (always)]
pub fn _2clk (self) -> & 'a mut W { self . variant (MRDLY_A :: _2CLK) } # [doc = "3 cycles"]
# [inline (always)]
pub fn _3clk (self) -> & 'a mut W { self . variant (MRDLY_A :: _3CLK) } } impl R { # [doc = "Bits 0:2 - SDRAM Row-to-Precharge Delay"]
# [inline (always)]
pub fn rpdly (& self) -> RPDLY_R { RPDLY_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - SDRAM Row Cycle Delay"]
# [inline (always)]
pub fn rowcycdly (& self) -> ROWCYCDLY_R { ROWCYCDLY_R :: new ((self . bits >> 3) & 7) } # [doc = "Bits 6:7 - SDRAM Mode Register Delay"]
# [inline (always)]
pub fn mrdly (& self) -> MRDLY_R { MRDLY_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - SDRAM Row-to-Precharge Delay"]
# [inline (always)]
# [must_use]
pub fn rpdly (& mut self) -> RPDLY_W < 0 > { RPDLY_W :: new (self) } # [doc = "Bits 3:5 - SDRAM Row Cycle Delay"]
# [inline (always)]
# [must_use]
pub fn rowcycdly (& mut self) -> ROWCYCDLY_W < 3 > { ROWCYCDLY_W :: new (self) } # [doc = "Bits 6:7 - SDRAM Mode Register Delay"]
# [inline (always)]
# [must_use]
pub fn mrdly (& mut self) -> MRDLY_W < 6 > { MRDLY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SDRAM Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sdramctrlb](index.html) module"]
pub struct SDRAMCTRLB_SPEC ; impl crate :: RegisterSpec for SDRAMCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sdramctrlb::R](R) reader structure"]
impl crate :: Readable for SDRAMCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sdramctrlb::W](W) writer structure"]
impl crate :: Writable for SDRAMCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SDRAMCTRLB to value 0"]
impl crate :: Resettable for SDRAMCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "SDRAMCTRLC (rw) register accessor: an alias for `Reg<SDRAMCTRLC_SPEC>`"]
pub type SDRAMCTRLC = crate :: Reg < sdramctrlc :: SDRAMCTRLC_SPEC > ; # [doc = "SDRAM Control Register C"]
pub mod sdramctrlc { # [doc = "Register `SDRAMCTRLC` reader"]
pub struct R (crate :: R < SDRAMCTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SDRAMCTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SDRAMCTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SDRAMCTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `SDRAMCTRLC` writer"]
pub struct W (crate :: W < SDRAMCTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SDRAMCTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SDRAMCTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SDRAMCTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `ROWCOLDLY` reader - SDRAM Row-to-Column Delay"]
pub type ROWCOLDLY_R = crate :: FieldReader < u8 , ROWCOLDLY_A > ; # [doc = "SDRAM Row-to-Column Delay\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ROWCOLDLY_A { # [doc = "0: 0 cycles"]
_0CLK = 0 , # [doc = "1: 1 cycle"]
_1CLK = 1 , # [doc = "2: 2 cycles"]
_2CLK = 2 , # [doc = "3: 3 cycles"]
_3CLK = 3 , # [doc = "4: 4 cycles"]
_4CLK = 4 , # [doc = "5: 5 cycles"]
_5CLK = 5 , # [doc = "6: 6 cycles"]
_6CLK = 6 , # [doc = "7: 7 cycles"]
_7CLK = 7 , } impl From < ROWCOLDLY_A > for u8 { # [inline (always)]
fn from (variant : ROWCOLDLY_A) -> Self { variant as _ } } impl ROWCOLDLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ROWCOLDLY_A { match self . bits { 0 => ROWCOLDLY_A :: _0CLK , 1 => ROWCOLDLY_A :: _1CLK , 2 => ROWCOLDLY_A :: _2CLK , 3 => ROWCOLDLY_A :: _3CLK , 4 => ROWCOLDLY_A :: _4CLK , 5 => ROWCOLDLY_A :: _5CLK , 6 => ROWCOLDLY_A :: _6CLK , 7 => ROWCOLDLY_A :: _7CLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0CLK`"]
# [inline (always)]
pub fn is_0clk (& self) -> bool { * self == ROWCOLDLY_A :: _0CLK } # [doc = "Checks if the value of the field is `_1CLK`"]
# [inline (always)]
pub fn is_1clk (& self) -> bool { * self == ROWCOLDLY_A :: _1CLK } # [doc = "Checks if the value of the field is `_2CLK`"]
# [inline (always)]
pub fn is_2clk (& self) -> bool { * self == ROWCOLDLY_A :: _2CLK } # [doc = "Checks if the value of the field is `_3CLK`"]
# [inline (always)]
pub fn is_3clk (& self) -> bool { * self == ROWCOLDLY_A :: _3CLK } # [doc = "Checks if the value of the field is `_4CLK`"]
# [inline (always)]
pub fn is_4clk (& self) -> bool { * self == ROWCOLDLY_A :: _4CLK } # [doc = "Checks if the value of the field is `_5CLK`"]
# [inline (always)]
pub fn is_5clk (& self) -> bool { * self == ROWCOLDLY_A :: _5CLK } # [doc = "Checks if the value of the field is `_6CLK`"]
# [inline (always)]
pub fn is_6clk (& self) -> bool { * self == ROWCOLDLY_A :: _6CLK } # [doc = "Checks if the value of the field is `_7CLK`"]
# [inline (always)]
pub fn is_7clk (& self) -> bool { * self == ROWCOLDLY_A :: _7CLK } } # [doc = "Field `ROWCOLDLY` writer - SDRAM Row-to-Column Delay"]
pub type ROWCOLDLY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SDRAMCTRLC_SPEC , u8 , ROWCOLDLY_A , 3 , O > ; impl < 'a , const O : u8 > ROWCOLDLY_W < 'a , O > { # [doc = "0 cycles"]
# [inline (always)]
pub fn _0clk (self) -> & 'a mut W { self . variant (ROWCOLDLY_A :: _0CLK) } # [doc = "1 cycle"]
# [inline (always)]
pub fn _1clk (self) -> & 'a mut W { self . variant (ROWCOLDLY_A :: _1CLK) } # [doc = "2 cycles"]
# [inline (always)]
pub fn _2clk (self) -> & 'a mut W { self . variant (ROWCOLDLY_A :: _2CLK) } # [doc = "3 cycles"]
# [inline (always)]
pub fn _3clk (self) -> & 'a mut W { self . variant (ROWCOLDLY_A :: _3CLK) } # [doc = "4 cycles"]
# [inline (always)]
pub fn _4clk (self) -> & 'a mut W { self . variant (ROWCOLDLY_A :: _4CLK) } # [doc = "5 cycles"]
# [inline (always)]
pub fn _5clk (self) -> & 'a mut W { self . variant (ROWCOLDLY_A :: _5CLK) } # [doc = "6 cycles"]
# [inline (always)]
pub fn _6clk (self) -> & 'a mut W { self . variant (ROWCOLDLY_A :: _6CLK) } # [doc = "7 cycles"]
# [inline (always)]
pub fn _7clk (self) -> & 'a mut W { self . variant (ROWCOLDLY_A :: _7CLK) } } # [doc = "Field `ESRDLY` reader - SDRAM Exit-Self-refresh-to-Active Delay"]
pub type ESRDLY_R = crate :: FieldReader < u8 , ESRDLY_A > ; # [doc = "SDRAM Exit-Self-refresh-to-Active Delay\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ESRDLY_A { # [doc = "0: 0 cycles"]
_0CLK = 0 , # [doc = "1: 1 cycle"]
_1CLK = 1 , # [doc = "2: 2 cycles"]
_2CLK = 2 , # [doc = "3: 3 cycles"]
_3CLK = 3 , # [doc = "4: 4 cycles"]
_4CLK = 4 , # [doc = "5: 5 cycles"]
_5CLK = 5 , # [doc = "6: 6 cycles"]
_6CLK = 6 , # [doc = "7: 7 cycles"]
_7CLK = 7 , } impl From < ESRDLY_A > for u8 { # [inline (always)]
fn from (variant : ESRDLY_A) -> Self { variant as _ } } impl ESRDLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ESRDLY_A { match self . bits { 0 => ESRDLY_A :: _0CLK , 1 => ESRDLY_A :: _1CLK , 2 => ESRDLY_A :: _2CLK , 3 => ESRDLY_A :: _3CLK , 4 => ESRDLY_A :: _4CLK , 5 => ESRDLY_A :: _5CLK , 6 => ESRDLY_A :: _6CLK , 7 => ESRDLY_A :: _7CLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0CLK`"]
# [inline (always)]
pub fn is_0clk (& self) -> bool { * self == ESRDLY_A :: _0CLK } # [doc = "Checks if the value of the field is `_1CLK`"]
# [inline (always)]
pub fn is_1clk (& self) -> bool { * self == ESRDLY_A :: _1CLK } # [doc = "Checks if the value of the field is `_2CLK`"]
# [inline (always)]
pub fn is_2clk (& self) -> bool { * self == ESRDLY_A :: _2CLK } # [doc = "Checks if the value of the field is `_3CLK`"]
# [inline (always)]
pub fn is_3clk (& self) -> bool { * self == ESRDLY_A :: _3CLK } # [doc = "Checks if the value of the field is `_4CLK`"]
# [inline (always)]
pub fn is_4clk (& self) -> bool { * self == ESRDLY_A :: _4CLK } # [doc = "Checks if the value of the field is `_5CLK`"]
# [inline (always)]
pub fn is_5clk (& self) -> bool { * self == ESRDLY_A :: _5CLK } # [doc = "Checks if the value of the field is `_6CLK`"]
# [inline (always)]
pub fn is_6clk (& self) -> bool { * self == ESRDLY_A :: _6CLK } # [doc = "Checks if the value of the field is `_7CLK`"]
# [inline (always)]
pub fn is_7clk (& self) -> bool { * self == ESRDLY_A :: _7CLK } } # [doc = "Field `ESRDLY` writer - SDRAM Exit-Self-refresh-to-Active Delay"]
pub type ESRDLY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SDRAMCTRLC_SPEC , u8 , ESRDLY_A , 3 , O > ; impl < 'a , const O : u8 > ESRDLY_W < 'a , O > { # [doc = "0 cycles"]
# [inline (always)]
pub fn _0clk (self) -> & 'a mut W { self . variant (ESRDLY_A :: _0CLK) } # [doc = "1 cycle"]
# [inline (always)]
pub fn _1clk (self) -> & 'a mut W { self . variant (ESRDLY_A :: _1CLK) } # [doc = "2 cycles"]
# [inline (always)]
pub fn _2clk (self) -> & 'a mut W { self . variant (ESRDLY_A :: _2CLK) } # [doc = "3 cycles"]
# [inline (always)]
pub fn _3clk (self) -> & 'a mut W { self . variant (ESRDLY_A :: _3CLK) } # [doc = "4 cycles"]
# [inline (always)]
pub fn _4clk (self) -> & 'a mut W { self . variant (ESRDLY_A :: _4CLK) } # [doc = "5 cycles"]
# [inline (always)]
pub fn _5clk (self) -> & 'a mut W { self . variant (ESRDLY_A :: _5CLK) } # [doc = "6 cycles"]
# [inline (always)]
pub fn _6clk (self) -> & 'a mut W { self . variant (ESRDLY_A :: _6CLK) } # [doc = "7 cycles"]
# [inline (always)]
pub fn _7clk (self) -> & 'a mut W { self . variant (ESRDLY_A :: _7CLK) } } # [doc = "Field `WRDLY` reader - SDRAM Write Recovery Delay"]
pub type WRDLY_R = crate :: FieldReader < u8 , WRDLY_A > ; # [doc = "SDRAM Write Recovery Delay\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WRDLY_A { # [doc = "0: 0 cycles"]
_0CLK = 0 , # [doc = "1: 1 cycle"]
_1CLK = 1 , # [doc = "2: 2 cycles"]
_2CLK = 2 , # [doc = "3: 3 cycles"]
_3CLK = 3 , } impl From < WRDLY_A > for u8 { # [inline (always)]
fn from (variant : WRDLY_A) -> Self { variant as _ } } impl WRDLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WRDLY_A { match self . bits { 0 => WRDLY_A :: _0CLK , 1 => WRDLY_A :: _1CLK , 2 => WRDLY_A :: _2CLK , 3 => WRDLY_A :: _3CLK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0CLK`"]
# [inline (always)]
pub fn is_0clk (& self) -> bool { * self == WRDLY_A :: _0CLK } # [doc = "Checks if the value of the field is `_1CLK`"]
# [inline (always)]
pub fn is_1clk (& self) -> bool { * self == WRDLY_A :: _1CLK } # [doc = "Checks if the value of the field is `_2CLK`"]
# [inline (always)]
pub fn is_2clk (& self) -> bool { * self == WRDLY_A :: _2CLK } # [doc = "Checks if the value of the field is `_3CLK`"]
# [inline (always)]
pub fn is_3clk (& self) -> bool { * self == WRDLY_A :: _3CLK } } # [doc = "Field `WRDLY` writer - SDRAM Write Recovery Delay"]
pub type WRDLY_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , SDRAMCTRLC_SPEC , u8 , WRDLY_A , 2 , O > ; impl < 'a , const O : u8 > WRDLY_W < 'a , O > { # [doc = "0 cycles"]
# [inline (always)]
pub fn _0clk (self) -> & 'a mut W { self . variant (WRDLY_A :: _0CLK) } # [doc = "1 cycle"]
# [inline (always)]
pub fn _1clk (self) -> & 'a mut W { self . variant (WRDLY_A :: _1CLK) } # [doc = "2 cycles"]
# [inline (always)]
pub fn _2clk (self) -> & 'a mut W { self . variant (WRDLY_A :: _2CLK) } # [doc = "3 cycles"]
# [inline (always)]
pub fn _3clk (self) -> & 'a mut W { self . variant (WRDLY_A :: _3CLK) } } impl R { # [doc = "Bits 0:2 - SDRAM Row-to-Column Delay"]
# [inline (always)]
pub fn rowcoldly (& self) -> ROWCOLDLY_R { ROWCOLDLY_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - SDRAM Exit-Self-refresh-to-Active Delay"]
# [inline (always)]
pub fn esrdly (& self) -> ESRDLY_R { ESRDLY_R :: new ((self . bits >> 3) & 7) } # [doc = "Bits 6:7 - SDRAM Write Recovery Delay"]
# [inline (always)]
pub fn wrdly (& self) -> WRDLY_R { WRDLY_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - SDRAM Row-to-Column Delay"]
# [inline (always)]
# [must_use]
pub fn rowcoldly (& mut self) -> ROWCOLDLY_W < 0 > { ROWCOLDLY_W :: new (self) } # [doc = "Bits 3:5 - SDRAM Exit-Self-refresh-to-Active Delay"]
# [inline (always)]
# [must_use]
pub fn esrdly (& mut self) -> ESRDLY_W < 3 > { ESRDLY_W :: new (self) } # [doc = "Bits 6:7 - SDRAM Write Recovery Delay"]
# [inline (always)]
# [must_use]
pub fn wrdly (& mut self) -> WRDLY_W < 6 > { WRDLY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SDRAM Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sdramctrlc](index.html) module"]
pub struct SDRAMCTRLC_SPEC ; impl crate :: RegisterSpec for SDRAMCTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sdramctrlc::R](R) reader structure"]
impl crate :: Readable for SDRAMCTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sdramctrlc::W](W) writer structure"]
impl crate :: Writable for SDRAMCTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets SDRAMCTRLC to value 0"]
impl crate :: Resettable for SDRAMCTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Event System"]
pub struct EVSYS { _marker : PhantomData < * const () > } unsafe impl Send for EVSYS { } impl EVSYS { # [doc = r"Pointer to the register block"]
pub const PTR : * const evsys :: RegisterBlock = 0x0180 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const evsys :: RegisterBlock { Self :: PTR } } impl Deref for EVSYS { type Target = evsys :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EVSYS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EVSYS") . finish () } } # [doc = "Event System"]
pub mod evsys { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Event Channel 0 Multiplexer"]
pub ch0mux : CH0MUX , # [doc = "0x01 - Event Channel 1 Multiplexer"]
pub ch1mux : CH1MUX , # [doc = "0x02 - Event Channel 2 Multiplexer"]
pub ch2mux : CH2MUX , # [doc = "0x03 - Event Channel 3 Multiplexer"]
pub ch3mux : CH3MUX , # [doc = "0x04 - Event Channel 4 Multiplexer"]
pub ch4mux : CH4MUX , # [doc = "0x05 - Event Channel 5 Multiplexer"]
pub ch5mux : CH5MUX , # [doc = "0x06 - Event Channel 6 Multiplexer"]
pub ch6mux : CH6MUX , # [doc = "0x07 - Event Channel 7 Multiplexer"]
pub ch7mux : CH7MUX , # [doc = "0x08 - Channel 0 Control Register"]
pub ch0ctrl : CH0CTRL , # [doc = "0x09 - Channel 1 Control Register"]
pub ch1ctrl : CH1CTRL , # [doc = "0x0a - Channel 2 Control Register"]
pub ch2ctrl : CH2CTRL , # [doc = "0x0b - Channel 3 Control Register"]
pub ch3ctrl : CH3CTRL , # [doc = "0x0c - Channel 4 Control Register"]
pub ch4ctrl : CH4CTRL , # [doc = "0x0d - Channel 5 Control Register"]
pub ch5ctrl : CH5CTRL , # [doc = "0x0e - Channel 6 Control Register"]
pub ch6ctrl : CH6CTRL , # [doc = "0x0f - Channel 7 Control Register"]
pub ch7ctrl : CH7CTRL , # [doc = "0x10 - Event Strobe"]
pub strobe : STROBE , # [doc = "0x11 - Event Data"]
pub data : DATA , } # [doc = "CH0CTRL (rw) register accessor: an alias for `Reg<CH0CTRL_SPEC>`"]
pub type CH0CTRL = crate :: Reg < ch0ctrl :: CH0CTRL_SPEC > ; # [doc = "Channel 0 Control Register"]
pub mod ch0ctrl { # [doc = "Register `CH0CTRL` reader"]
pub struct R (crate :: R < CH0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH0CTRL` writer"]
pub struct W (crate :: W < CH0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIGFILT` reader - Digital Filter"]
pub type DIGFILT_R = crate :: FieldReader < u8 , DIGFILT_A > ; # [doc = "Digital Filter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DIGFILT_A { # [doc = "0: 1 SAMPLE"]
_1SAMPLE = 0 , # [doc = "1: 2 SAMPLES"]
_2SAMPLES = 1 , # [doc = "2: 3 SAMPLES"]
_3SAMPLES = 2 , # [doc = "3: 4 SAMPLES"]
_4SAMPLES = 3 , # [doc = "4: 5 SAMPLES"]
_5SAMPLES = 4 , # [doc = "5: 6 SAMPLES"]
_6SAMPLES = 5 , # [doc = "6: 7 SAMPLES"]
_7SAMPLES = 6 , # [doc = "7: 8 SAMPLES"]
_8SAMPLES = 7 , } impl From < DIGFILT_A > for u8 { # [inline (always)]
fn from (variant : DIGFILT_A) -> Self { variant as _ } } impl DIGFILT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIGFILT_A { match self . bits { 0 => DIGFILT_A :: _1SAMPLE , 1 => DIGFILT_A :: _2SAMPLES , 2 => DIGFILT_A :: _3SAMPLES , 3 => DIGFILT_A :: _4SAMPLES , 4 => DIGFILT_A :: _5SAMPLES , 5 => DIGFILT_A :: _6SAMPLES , 6 => DIGFILT_A :: _7SAMPLES , 7 => DIGFILT_A :: _8SAMPLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1SAMPLE`"]
# [inline (always)]
pub fn is_1sample (& self) -> bool { * self == DIGFILT_A :: _1SAMPLE } # [doc = "Checks if the value of the field is `_2SAMPLES`"]
# [inline (always)]
pub fn is_2samples (& self) -> bool { * self == DIGFILT_A :: _2SAMPLES } # [doc = "Checks if the value of the field is `_3SAMPLES`"]
# [inline (always)]
pub fn is_3samples (& self) -> bool { * self == DIGFILT_A :: _3SAMPLES } # [doc = "Checks if the value of the field is `_4SAMPLES`"]
# [inline (always)]
pub fn is_4samples (& self) -> bool { * self == DIGFILT_A :: _4SAMPLES } # [doc = "Checks if the value of the field is `_5SAMPLES`"]
# [inline (always)]
pub fn is_5samples (& self) -> bool { * self == DIGFILT_A :: _5SAMPLES } # [doc = "Checks if the value of the field is `_6SAMPLES`"]
# [inline (always)]
pub fn is_6samples (& self) -> bool { * self == DIGFILT_A :: _6SAMPLES } # [doc = "Checks if the value of the field is `_7SAMPLES`"]
# [inline (always)]
pub fn is_7samples (& self) -> bool { * self == DIGFILT_A :: _7SAMPLES } # [doc = "Checks if the value of the field is `_8SAMPLES`"]
# [inline (always)]
pub fn is_8samples (& self) -> bool { * self == DIGFILT_A :: _8SAMPLES } } # [doc = "Field `DIGFILT` writer - Digital Filter"]
pub type DIGFILT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH0CTRL_SPEC , u8 , DIGFILT_A , 3 , O > ; impl < 'a , const O : u8 > DIGFILT_W < 'a , O > { # [doc = "1 SAMPLE"]
# [inline (always)]
pub fn _1sample (self) -> & 'a mut W { self . variant (DIGFILT_A :: _1SAMPLE) } # [doc = "2 SAMPLES"]
# [inline (always)]
pub fn _2samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _2SAMPLES) } # [doc = "3 SAMPLES"]
# [inline (always)]
pub fn _3samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _3SAMPLES) } # [doc = "4 SAMPLES"]
# [inline (always)]
pub fn _4samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _4SAMPLES) } # [doc = "5 SAMPLES"]
# [inline (always)]
pub fn _5samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _5SAMPLES) } # [doc = "6 SAMPLES"]
# [inline (always)]
pub fn _6samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _6SAMPLES) } # [doc = "7 SAMPLES"]
# [inline (always)]
pub fn _7samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _7SAMPLES) } # [doc = "8 SAMPLES"]
# [inline (always)]
pub fn _8samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _8SAMPLES) } } # [doc = "Field `QDEN` reader - Quadrature Decoder Enable"]
pub type QDEN_R = crate :: BitReader < bool > ; # [doc = "Field `QDEN` writer - Quadrature Decoder Enable"]
pub type QDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CH0CTRL_SPEC , bool , O > ; # [doc = "Field `QDIEN` reader - Quadrature Decoder Index Enable"]
pub type QDIEN_R = crate :: BitReader < bool > ; # [doc = "Field `QDIEN` writer - Quadrature Decoder Index Enable"]
pub type QDIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CH0CTRL_SPEC , bool , O > ; # [doc = "Field `QDIRM` reader - Quadrature Decoder Index Recognition Mode"]
pub type QDIRM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `QDIRM` writer - Quadrature Decoder Index Recognition Mode"]
pub type QDIRM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH0CTRL_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
pub fn digfilt (& self) -> DIGFILT_R { DIGFILT_R :: new (self . bits & 7) } # [doc = "Bit 3 - Quadrature Decoder Enable"]
# [inline (always)]
pub fn qden (& self) -> QDEN_R { QDEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Quadrature Decoder Index Enable"]
# [inline (always)]
pub fn qdien (& self) -> QDIEN_R { QDIEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Quadrature Decoder Index Recognition Mode"]
# [inline (always)]
pub fn qdirm (& self) -> QDIRM_R { QDIRM_R :: new ((self . bits >> 5) & 3) } } impl W { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
# [must_use]
pub fn digfilt (& mut self) -> DIGFILT_W < 0 > { DIGFILT_W :: new (self) } # [doc = "Bit 3 - Quadrature Decoder Enable"]
# [inline (always)]
# [must_use]
pub fn qden (& mut self) -> QDEN_W < 3 > { QDEN_W :: new (self) } # [doc = "Bit 4 - Quadrature Decoder Index Enable"]
# [inline (always)]
# [must_use]
pub fn qdien (& mut self) -> QDIEN_W < 4 > { QDIEN_W :: new (self) } # [doc = "Bits 5:6 - Quadrature Decoder Index Recognition Mode"]
# [inline (always)]
# [must_use]
pub fn qdirm (& mut self) -> QDIRM_W < 5 > { QDIRM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch0ctrl](index.html) module"]
pub struct CH0CTRL_SPEC ; impl crate :: RegisterSpec for CH0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch0ctrl::R](R) reader structure"]
impl crate :: Readable for CH0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch0ctrl::W](W) writer structure"]
impl crate :: Writable for CH0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH0CTRL to value 0"]
impl crate :: Resettable for CH0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH0MUX (rw) register accessor: an alias for `Reg<CH0MUX_SPEC>`"]
pub type CH0MUX = crate :: Reg < ch0mux :: CH0MUX_SPEC > ; # [doc = "Event Channel 0 Multiplexer"]
pub mod ch0mux { # [doc = "Register `CH0MUX` reader"]
pub struct R (crate :: R < CH0MUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH0MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH0MUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH0MUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH0MUX` writer"]
pub struct W (crate :: W < CH0MUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH0MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH0MUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH0MUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHMUX` reader - Event Channel 0 Multiplexer"]
pub type CHMUX_R = crate :: FieldReader < u8 , CHMUX_A > ; # [doc = "Event Channel 0 Multiplexer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHMUX_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "8: RTC Overflow"]
RTC_OVF = 8 , # [doc = "9: RTC Compare Match"]
RTC_CMP = 9 , # [doc = "16: Analog Comparator A Channel 0"]
ACA_CH0 = 16 , # [doc = "17: Analog Comparator A Channel 1"]
ACA_CH1 = 17 , # [doc = "18: Analog Comparator A Window"]
ACA_WIN = 18 , # [doc = "19: Analog Comparator B Channel 0"]
ACB_CH0 = 19 , # [doc = "20: Analog Comparator B Channel 1"]
ACB_CH1 = 20 , # [doc = "21: Analog Comparator B Window"]
ACB_WIN = 21 , # [doc = "32: ADC A Channel 0"]
ADCA_CH0 = 32 , # [doc = "33: ADC A Channel 1"]
ADCA_CH1 = 33 , # [doc = "34: ADC A Channel 2"]
ADCA_CH2 = 34 , # [doc = "35: ADC A Channel 3"]
ADCA_CH3 = 35 , # [doc = "36: ADC B Channel 0"]
ADCB_CH0 = 36 , # [doc = "37: ADC B Channel 1"]
ADCB_CH1 = 37 , # [doc = "38: ADC B Channel 2"]
ADCB_CH2 = 38 , # [doc = "39: ADC B Channel 3"]
ADCB_CH3 = 39 , # [doc = "80: Port A, Pin0"]
PORTA_PIN0 = 80 , # [doc = "81: Port A, Pin1"]
PORTA_PIN1 = 81 , # [doc = "82: Port A, Pin2"]
PORTA_PIN2 = 82 , # [doc = "83: Port A, Pin3"]
PORTA_PIN3 = 83 , # [doc = "84: Port A, Pin4"]
PORTA_PIN4 = 84 , # [doc = "85: Port A, Pin5"]
PORTA_PIN5 = 85 , # [doc = "86: Port A, Pin6"]
PORTA_PIN6 = 86 , # [doc = "87: Port A, Pin7"]
PORTA_PIN7 = 87 , # [doc = "88: Port B, Pin0"]
PORTB_PIN0 = 88 , # [doc = "89: Port B, Pin1"]
PORTB_PIN1 = 89 , # [doc = "90: Port B, Pin2"]
PORTB_PIN2 = 90 , # [doc = "91: Port B, Pin3"]
PORTB_PIN3 = 91 , # [doc = "92: Port B, Pin4"]
PORTB_PIN4 = 92 , # [doc = "93: Port B, Pin5"]
PORTB_PIN5 = 93 , # [doc = "94: Port B, Pin6"]
PORTB_PIN6 = 94 , # [doc = "95: Port B, Pin7"]
PORTB_PIN7 = 95 , # [doc = "96: Port C, Pin0"]
PORTC_PIN0 = 96 , # [doc = "97: Port C, Pin1"]
PORTC_PIN1 = 97 , # [doc = "98: Port C, Pin2"]
PORTC_PIN2 = 98 , # [doc = "99: Port C, Pin3"]
PORTC_PIN3 = 99 , # [doc = "100: Port C, Pin4"]
PORTC_PIN4 = 100 , # [doc = "101: Port C, Pin5"]
PORTC_PIN5 = 101 , # [doc = "102: Port C, Pin6"]
PORTC_PIN6 = 102 , # [doc = "103: Port C, Pin7"]
PORTC_PIN7 = 103 , # [doc = "104: Port D, Pin0"]
PORTD_PIN0 = 104 , # [doc = "105: Port D, Pin1"]
PORTD_PIN1 = 105 , # [doc = "106: Port D, Pin2"]
PORTD_PIN2 = 106 , # [doc = "107: Port D, Pin3"]
PORTD_PIN3 = 107 , # [doc = "108: Port D, Pin4"]
PORTD_PIN4 = 108 , # [doc = "109: Port D, Pin5"]
PORTD_PIN5 = 109 , # [doc = "110: Port D, Pin6"]
PORTD_PIN6 = 110 , # [doc = "111: Port D, Pin7"]
PORTD_PIN7 = 111 , # [doc = "112: Port E, Pin0"]
PORTE_PIN0 = 112 , # [doc = "113: Port E, Pin1"]
PORTE_PIN1 = 113 , # [doc = "114: Port E, Pin2"]
PORTE_PIN2 = 114 , # [doc = "115: Port E, Pin3"]
PORTE_PIN3 = 115 , # [doc = "116: Port E, Pin4"]
PORTE_PIN4 = 116 , # [doc = "117: Port E, Pin5"]
PORTE_PIN5 = 117 , # [doc = "118: Port E, Pin6"]
PORTE_PIN6 = 118 , # [doc = "119: Port E, Pin7"]
PORTE_PIN7 = 119 , # [doc = "120: Port F, Pin0"]
PORTF_PIN0 = 120 , # [doc = "121: Port F, Pin1"]
PORTF_PIN1 = 121 , # [doc = "122: Port F, Pin2"]
PORTF_PIN2 = 122 , # [doc = "123: Port F, Pin3"]
PORTF_PIN3 = 123 , # [doc = "124: Port F, Pin4"]
PORTF_PIN4 = 124 , # [doc = "125: Port F, Pin5"]
PORTF_PIN5 = 125 , # [doc = "126: Port F, Pin6"]
PORTF_PIN6 = 126 , # [doc = "127: Port F, Pin7"]
PORTF_PIN7 = 127 , # [doc = "128: Prescaler, divide by 1"]
PRESCALER_1 = 128 , # [doc = "129: Prescaler, divide by 2"]
PRESCALER_2 = 129 , # [doc = "130: Prescaler, divide by 4"]
PRESCALER_4 = 130 , # [doc = "131: Prescaler, divide by 8"]
PRESCALER_8 = 131 , # [doc = "132: Prescaler, divide by 16"]
PRESCALER_16 = 132 , # [doc = "133: Prescaler, divide by 32"]
PRESCALER_32 = 133 , # [doc = "134: Prescaler, divide by 64"]
PRESCALER_64 = 134 , # [doc = "135: Prescaler, divide by 128"]
PRESCALER_128 = 135 , # [doc = "136: Prescaler, divide by 256"]
PRESCALER_256 = 136 , # [doc = "137: Prescaler, divide by 512"]
PRESCALER_512 = 137 , # [doc = "138: Prescaler, divide by 1024"]
PRESCALER_1024 = 138 , # [doc = "139: Prescaler, divide by 2048"]
PRESCALER_2048 = 139 , # [doc = "140: Prescaler, divide by 4096"]
PRESCALER_4096 = 140 , # [doc = "141: Prescaler, divide by 8192"]
PRESCALER_8192 = 141 , # [doc = "142: Prescaler, divide by 16384"]
PRESCALER_16384 = 142 , # [doc = "143: Prescaler, divide by 32768"]
PRESCALER_32768 = 143 , # [doc = "192: Timer/Counter C0 Overflow"]
TCC0_OVF = 192 , # [doc = "193: Timer/Counter C0 Error"]
TCC0_ERR = 193 , # [doc = "196: Timer/Counter C0 Compare or Capture A"]
TCC0_CCA = 196 , # [doc = "197: Timer/Counter C0 Compare or Capture B"]
TCC0_CCB = 197 , # [doc = "198: Timer/Counter C0 Compare or Capture C"]
TCC0_CCC = 198 , # [doc = "199: Timer/Counter C0 Compare or Capture D"]
TCC0_CCD = 199 , # [doc = "200: Timer/Counter C1 Overflow"]
TCC1_OVF = 200 , # [doc = "201: Timer/Counter C1 Error"]
TCC1_ERR = 201 , # [doc = "204: Timer/Counter C1 Compare or Capture A"]
TCC1_CCA = 204 , # [doc = "205: Timer/Counter C1 Compare or Capture B"]
TCC1_CCB = 205 , # [doc = "208: Timer/Counter D0 Overflow"]
TCD0_OVF = 208 , # [doc = "209: Timer/Counter D0 Error"]
TCD0_ERR = 209 , # [doc = "212: Timer/Counter D0 Compare or Capture A"]
TCD0_CCA = 212 , # [doc = "213: Timer/Counter D0 Compare or Capture B"]
TCD0_CCB = 213 , # [doc = "214: Timer/Counter D0 Compare or Capture C"]
TCD0_CCC = 214 , # [doc = "215: Timer/Counter D0 Compare or Capture D"]
TCD0_CCD = 215 , # [doc = "216: Timer/Counter D1 Overflow"]
TCD1_OVF = 216 , # [doc = "217: Timer/Counter D1 Error"]
TCD1_ERR = 217 , # [doc = "220: Timer/Counter D1 Compare or Capture A"]
TCD1_CCA = 220 , # [doc = "221: Timer/Counter D1 Compare or Capture B"]
TCD1_CCB = 221 , # [doc = "224: Timer/Counter E0 Overflow"]
TCE0_OVF = 224 , # [doc = "225: Timer/Counter E0 Error"]
TCE0_ERR = 225 , # [doc = "228: Timer/Counter E0 Compare or Capture A"]
TCE0_CCA = 228 , # [doc = "229: Timer/Counter E0 Compare or Capture B"]
TCE0_CCB = 229 , # [doc = "230: Timer/Counter E0 Compare or Capture C"]
TCE0_CCC = 230 , # [doc = "231: Timer/Counter E0 Compare or Capture D"]
TCE0_CCD = 231 , # [doc = "232: Timer/Counter E1 Overflow"]
TCE1_OVF = 232 , # [doc = "233: Timer/Counter E1 Error"]
TCE1_ERR = 233 , # [doc = "236: Timer/Counter E1 Compare or Capture A"]
TCE1_CCA = 236 , # [doc = "237: Timer/Counter E1 Compare or Capture B"]
TCE1_CCB = 237 , # [doc = "240: Timer/Counter F0 Overflow"]
TCF0_OVF = 240 , # [doc = "241: Timer/Counter F0 Error"]
TCF0_ERR = 241 , # [doc = "244: Timer/Counter F0 Compare or Capture A"]
TCF0_CCA = 244 , # [doc = "245: Timer/Counter F0 Compare or Capture B"]
TCF0_CCB = 245 , # [doc = "246: Timer/Counter F0 Compare or Capture C"]
TCF0_CCC = 246 , # [doc = "247: Timer/Counter F0 Compare or Capture D"]
TCF0_CCD = 247 , # [doc = "248: Timer/Counter F1 Overflow"]
TCF1_OVF = 248 , # [doc = "249: Timer/Counter F1 Error"]
TCF1_ERR = 249 , # [doc = "252: Timer/Counter F1 Compare or Capture A"]
TCF1_CCA = 252 , # [doc = "253: Timer/Counter F1 Compare or Capture B"]
TCF1_CCB = 253 , } impl From < CHMUX_A > for u8 { # [inline (always)]
fn from (variant : CHMUX_A) -> Self { variant as _ } } impl CHMUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHMUX_A > { match self . bits { 0 => Some (CHMUX_A :: OFF) , 8 => Some (CHMUX_A :: RTC_OVF) , 9 => Some (CHMUX_A :: RTC_CMP) , 16 => Some (CHMUX_A :: ACA_CH0) , 17 => Some (CHMUX_A :: ACA_CH1) , 18 => Some (CHMUX_A :: ACA_WIN) , 19 => Some (CHMUX_A :: ACB_CH0) , 20 => Some (CHMUX_A :: ACB_CH1) , 21 => Some (CHMUX_A :: ACB_WIN) , 32 => Some (CHMUX_A :: ADCA_CH0) , 33 => Some (CHMUX_A :: ADCA_CH1) , 34 => Some (CHMUX_A :: ADCA_CH2) , 35 => Some (CHMUX_A :: ADCA_CH3) , 36 => Some (CHMUX_A :: ADCB_CH0) , 37 => Some (CHMUX_A :: ADCB_CH1) , 38 => Some (CHMUX_A :: ADCB_CH2) , 39 => Some (CHMUX_A :: ADCB_CH3) , 80 => Some (CHMUX_A :: PORTA_PIN0) , 81 => Some (CHMUX_A :: PORTA_PIN1) , 82 => Some (CHMUX_A :: PORTA_PIN2) , 83 => Some (CHMUX_A :: PORTA_PIN3) , 84 => Some (CHMUX_A :: PORTA_PIN4) , 85 => Some (CHMUX_A :: PORTA_PIN5) , 86 => Some (CHMUX_A :: PORTA_PIN6) , 87 => Some (CHMUX_A :: PORTA_PIN7) , 88 => Some (CHMUX_A :: PORTB_PIN0) , 89 => Some (CHMUX_A :: PORTB_PIN1) , 90 => Some (CHMUX_A :: PORTB_PIN2) , 91 => Some (CHMUX_A :: PORTB_PIN3) , 92 => Some (CHMUX_A :: PORTB_PIN4) , 93 => Some (CHMUX_A :: PORTB_PIN5) , 94 => Some (CHMUX_A :: PORTB_PIN6) , 95 => Some (CHMUX_A :: PORTB_PIN7) , 96 => Some (CHMUX_A :: PORTC_PIN0) , 97 => Some (CHMUX_A :: PORTC_PIN1) , 98 => Some (CHMUX_A :: PORTC_PIN2) , 99 => Some (CHMUX_A :: PORTC_PIN3) , 100 => Some (CHMUX_A :: PORTC_PIN4) , 101 => Some (CHMUX_A :: PORTC_PIN5) , 102 => Some (CHMUX_A :: PORTC_PIN6) , 103 => Some (CHMUX_A :: PORTC_PIN7) , 104 => Some (CHMUX_A :: PORTD_PIN0) , 105 => Some (CHMUX_A :: PORTD_PIN1) , 106 => Some (CHMUX_A :: PORTD_PIN2) , 107 => Some (CHMUX_A :: PORTD_PIN3) , 108 => Some (CHMUX_A :: PORTD_PIN4) , 109 => Some (CHMUX_A :: PORTD_PIN5) , 110 => Some (CHMUX_A :: PORTD_PIN6) , 111 => Some (CHMUX_A :: PORTD_PIN7) , 112 => Some (CHMUX_A :: PORTE_PIN0) , 113 => Some (CHMUX_A :: PORTE_PIN1) , 114 => Some (CHMUX_A :: PORTE_PIN2) , 115 => Some (CHMUX_A :: PORTE_PIN3) , 116 => Some (CHMUX_A :: PORTE_PIN4) , 117 => Some (CHMUX_A :: PORTE_PIN5) , 118 => Some (CHMUX_A :: PORTE_PIN6) , 119 => Some (CHMUX_A :: PORTE_PIN7) , 120 => Some (CHMUX_A :: PORTF_PIN0) , 121 => Some (CHMUX_A :: PORTF_PIN1) , 122 => Some (CHMUX_A :: PORTF_PIN2) , 123 => Some (CHMUX_A :: PORTF_PIN3) , 124 => Some (CHMUX_A :: PORTF_PIN4) , 125 => Some (CHMUX_A :: PORTF_PIN5) , 126 => Some (CHMUX_A :: PORTF_PIN6) , 127 => Some (CHMUX_A :: PORTF_PIN7) , 128 => Some (CHMUX_A :: PRESCALER_1) , 129 => Some (CHMUX_A :: PRESCALER_2) , 130 => Some (CHMUX_A :: PRESCALER_4) , 131 => Some (CHMUX_A :: PRESCALER_8) , 132 => Some (CHMUX_A :: PRESCALER_16) , 133 => Some (CHMUX_A :: PRESCALER_32) , 134 => Some (CHMUX_A :: PRESCALER_64) , 135 => Some (CHMUX_A :: PRESCALER_128) , 136 => Some (CHMUX_A :: PRESCALER_256) , 137 => Some (CHMUX_A :: PRESCALER_512) , 138 => Some (CHMUX_A :: PRESCALER_1024) , 139 => Some (CHMUX_A :: PRESCALER_2048) , 140 => Some (CHMUX_A :: PRESCALER_4096) , 141 => Some (CHMUX_A :: PRESCALER_8192) , 142 => Some (CHMUX_A :: PRESCALER_16384) , 143 => Some (CHMUX_A :: PRESCALER_32768) , 192 => Some (CHMUX_A :: TCC0_OVF) , 193 => Some (CHMUX_A :: TCC0_ERR) , 196 => Some (CHMUX_A :: TCC0_CCA) , 197 => Some (CHMUX_A :: TCC0_CCB) , 198 => Some (CHMUX_A :: TCC0_CCC) , 199 => Some (CHMUX_A :: TCC0_CCD) , 200 => Some (CHMUX_A :: TCC1_OVF) , 201 => Some (CHMUX_A :: TCC1_ERR) , 204 => Some (CHMUX_A :: TCC1_CCA) , 205 => Some (CHMUX_A :: TCC1_CCB) , 208 => Some (CHMUX_A :: TCD0_OVF) , 209 => Some (CHMUX_A :: TCD0_ERR) , 212 => Some (CHMUX_A :: TCD0_CCA) , 213 => Some (CHMUX_A :: TCD0_CCB) , 214 => Some (CHMUX_A :: TCD0_CCC) , 215 => Some (CHMUX_A :: TCD0_CCD) , 216 => Some (CHMUX_A :: TCD1_OVF) , 217 => Some (CHMUX_A :: TCD1_ERR) , 220 => Some (CHMUX_A :: TCD1_CCA) , 221 => Some (CHMUX_A :: TCD1_CCB) , 224 => Some (CHMUX_A :: TCE0_OVF) , 225 => Some (CHMUX_A :: TCE0_ERR) , 228 => Some (CHMUX_A :: TCE0_CCA) , 229 => Some (CHMUX_A :: TCE0_CCB) , 230 => Some (CHMUX_A :: TCE0_CCC) , 231 => Some (CHMUX_A :: TCE0_CCD) , 232 => Some (CHMUX_A :: TCE1_OVF) , 233 => Some (CHMUX_A :: TCE1_ERR) , 236 => Some (CHMUX_A :: TCE1_CCA) , 237 => Some (CHMUX_A :: TCE1_CCB) , 240 => Some (CHMUX_A :: TCF0_OVF) , 241 => Some (CHMUX_A :: TCF0_ERR) , 244 => Some (CHMUX_A :: TCF0_CCA) , 245 => Some (CHMUX_A :: TCF0_CCB) , 246 => Some (CHMUX_A :: TCF0_CCC) , 247 => Some (CHMUX_A :: TCF0_CCD) , 248 => Some (CHMUX_A :: TCF1_OVF) , 249 => Some (CHMUX_A :: TCF1_ERR) , 252 => Some (CHMUX_A :: TCF1_CCA) , 253 => Some (CHMUX_A :: TCF1_CCB) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHMUX_A :: OFF } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == CHMUX_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == CHMUX_A :: RTC_CMP } # [doc = "Checks if the value of the field is `ACA_CH0`"]
# [inline (always)]
pub fn is_aca_ch0 (& self) -> bool { * self == CHMUX_A :: ACA_CH0 } # [doc = "Checks if the value of the field is `ACA_CH1`"]
# [inline (always)]
pub fn is_aca_ch1 (& self) -> bool { * self == CHMUX_A :: ACA_CH1 } # [doc = "Checks if the value of the field is `ACA_WIN`"]
# [inline (always)]
pub fn is_aca_win (& self) -> bool { * self == CHMUX_A :: ACA_WIN } # [doc = "Checks if the value of the field is `ACB_CH0`"]
# [inline (always)]
pub fn is_acb_ch0 (& self) -> bool { * self == CHMUX_A :: ACB_CH0 } # [doc = "Checks if the value of the field is `ACB_CH1`"]
# [inline (always)]
pub fn is_acb_ch1 (& self) -> bool { * self == CHMUX_A :: ACB_CH1 } # [doc = "Checks if the value of the field is `ACB_WIN`"]
# [inline (always)]
pub fn is_acb_win (& self) -> bool { * self == CHMUX_A :: ACB_WIN } # [doc = "Checks if the value of the field is `ADCA_CH0`"]
# [inline (always)]
pub fn is_adca_ch0 (& self) -> bool { * self == CHMUX_A :: ADCA_CH0 } # [doc = "Checks if the value of the field is `ADCA_CH1`"]
# [inline (always)]
pub fn is_adca_ch1 (& self) -> bool { * self == CHMUX_A :: ADCA_CH1 } # [doc = "Checks if the value of the field is `ADCA_CH2`"]
# [inline (always)]
pub fn is_adca_ch2 (& self) -> bool { * self == CHMUX_A :: ADCA_CH2 } # [doc = "Checks if the value of the field is `ADCA_CH3`"]
# [inline (always)]
pub fn is_adca_ch3 (& self) -> bool { * self == CHMUX_A :: ADCA_CH3 } # [doc = "Checks if the value of the field is `ADCB_CH0`"]
# [inline (always)]
pub fn is_adcb_ch0 (& self) -> bool { * self == CHMUX_A :: ADCB_CH0 } # [doc = "Checks if the value of the field is `ADCB_CH1`"]
# [inline (always)]
pub fn is_adcb_ch1 (& self) -> bool { * self == CHMUX_A :: ADCB_CH1 } # [doc = "Checks if the value of the field is `ADCB_CH2`"]
# [inline (always)]
pub fn is_adcb_ch2 (& self) -> bool { * self == CHMUX_A :: ADCB_CH2 } # [doc = "Checks if the value of the field is `ADCB_CH3`"]
# [inline (always)]
pub fn is_adcb_ch3 (& self) -> bool { * self == CHMUX_A :: ADCB_CH3 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN7 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTC_PIN6`"]
# [inline (always)]
pub fn is_portc_pin6 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN6 } # [doc = "Checks if the value of the field is `PORTC_PIN7`"]
# [inline (always)]
pub fn is_portc_pin7 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN7 } # [doc = "Checks if the value of the field is `PORTD_PIN0`"]
# [inline (always)]
pub fn is_portd_pin0 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN0 } # [doc = "Checks if the value of the field is `PORTD_PIN1`"]
# [inline (always)]
pub fn is_portd_pin1 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN1 } # [doc = "Checks if the value of the field is `PORTD_PIN2`"]
# [inline (always)]
pub fn is_portd_pin2 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN2 } # [doc = "Checks if the value of the field is `PORTD_PIN3`"]
# [inline (always)]
pub fn is_portd_pin3 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN3 } # [doc = "Checks if the value of the field is `PORTD_PIN4`"]
# [inline (always)]
pub fn is_portd_pin4 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN4 } # [doc = "Checks if the value of the field is `PORTD_PIN5`"]
# [inline (always)]
pub fn is_portd_pin5 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN5 } # [doc = "Checks if the value of the field is `PORTD_PIN6`"]
# [inline (always)]
pub fn is_portd_pin6 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN6 } # [doc = "Checks if the value of the field is `PORTD_PIN7`"]
# [inline (always)]
pub fn is_portd_pin7 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN7 } # [doc = "Checks if the value of the field is `PORTE_PIN0`"]
# [inline (always)]
pub fn is_porte_pin0 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN0 } # [doc = "Checks if the value of the field is `PORTE_PIN1`"]
# [inline (always)]
pub fn is_porte_pin1 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN1 } # [doc = "Checks if the value of the field is `PORTE_PIN2`"]
# [inline (always)]
pub fn is_porte_pin2 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN2 } # [doc = "Checks if the value of the field is `PORTE_PIN3`"]
# [inline (always)]
pub fn is_porte_pin3 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN3 } # [doc = "Checks if the value of the field is `PORTE_PIN4`"]
# [inline (always)]
pub fn is_porte_pin4 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN4 } # [doc = "Checks if the value of the field is `PORTE_PIN5`"]
# [inline (always)]
pub fn is_porte_pin5 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN5 } # [doc = "Checks if the value of the field is `PORTE_PIN6`"]
# [inline (always)]
pub fn is_porte_pin6 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN6 } # [doc = "Checks if the value of the field is `PORTE_PIN7`"]
# [inline (always)]
pub fn is_porte_pin7 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN7 } # [doc = "Checks if the value of the field is `PORTF_PIN0`"]
# [inline (always)]
pub fn is_portf_pin0 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN0 } # [doc = "Checks if the value of the field is `PORTF_PIN1`"]
# [inline (always)]
pub fn is_portf_pin1 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN1 } # [doc = "Checks if the value of the field is `PORTF_PIN2`"]
# [inline (always)]
pub fn is_portf_pin2 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN2 } # [doc = "Checks if the value of the field is `PORTF_PIN3`"]
# [inline (always)]
pub fn is_portf_pin3 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN3 } # [doc = "Checks if the value of the field is `PORTF_PIN4`"]
# [inline (always)]
pub fn is_portf_pin4 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN4 } # [doc = "Checks if the value of the field is `PORTF_PIN5`"]
# [inline (always)]
pub fn is_portf_pin5 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN5 } # [doc = "Checks if the value of the field is `PORTF_PIN6`"]
# [inline (always)]
pub fn is_portf_pin6 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN6 } # [doc = "Checks if the value of the field is `PORTF_PIN7`"]
# [inline (always)]
pub fn is_portf_pin7 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN7 } # [doc = "Checks if the value of the field is `PRESCALER_1`"]
# [inline (always)]
pub fn is_prescaler_1 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1 } # [doc = "Checks if the value of the field is `PRESCALER_2`"]
# [inline (always)]
pub fn is_prescaler_2 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2 } # [doc = "Checks if the value of the field is `PRESCALER_4`"]
# [inline (always)]
pub fn is_prescaler_4 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4 } # [doc = "Checks if the value of the field is `PRESCALER_8`"]
# [inline (always)]
pub fn is_prescaler_8 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8 } # [doc = "Checks if the value of the field is `PRESCALER_16`"]
# [inline (always)]
pub fn is_prescaler_16 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16 } # [doc = "Checks if the value of the field is `PRESCALER_32`"]
# [inline (always)]
pub fn is_prescaler_32 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32 } # [doc = "Checks if the value of the field is `PRESCALER_64`"]
# [inline (always)]
pub fn is_prescaler_64 (& self) -> bool { * self == CHMUX_A :: PRESCALER_64 } # [doc = "Checks if the value of the field is `PRESCALER_128`"]
# [inline (always)]
pub fn is_prescaler_128 (& self) -> bool { * self == CHMUX_A :: PRESCALER_128 } # [doc = "Checks if the value of the field is `PRESCALER_256`"]
# [inline (always)]
pub fn is_prescaler_256 (& self) -> bool { * self == CHMUX_A :: PRESCALER_256 } # [doc = "Checks if the value of the field is `PRESCALER_512`"]
# [inline (always)]
pub fn is_prescaler_512 (& self) -> bool { * self == CHMUX_A :: PRESCALER_512 } # [doc = "Checks if the value of the field is `PRESCALER_1024`"]
# [inline (always)]
pub fn is_prescaler_1024 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1024 } # [doc = "Checks if the value of the field is `PRESCALER_2048`"]
# [inline (always)]
pub fn is_prescaler_2048 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2048 } # [doc = "Checks if the value of the field is `PRESCALER_4096`"]
# [inline (always)]
pub fn is_prescaler_4096 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4096 } # [doc = "Checks if the value of the field is `PRESCALER_8192`"]
# [inline (always)]
pub fn is_prescaler_8192 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8192 } # [doc = "Checks if the value of the field is `PRESCALER_16384`"]
# [inline (always)]
pub fn is_prescaler_16384 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16384 } # [doc = "Checks if the value of the field is `PRESCALER_32768`"]
# [inline (always)]
pub fn is_prescaler_32768 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32768 } # [doc = "Checks if the value of the field is `TCC0_OVF`"]
# [inline (always)]
pub fn is_tcc0_ovf (& self) -> bool { * self == CHMUX_A :: TCC0_OVF } # [doc = "Checks if the value of the field is `TCC0_ERR`"]
# [inline (always)]
pub fn is_tcc0_err (& self) -> bool { * self == CHMUX_A :: TCC0_ERR } # [doc = "Checks if the value of the field is `TCC0_CCA`"]
# [inline (always)]
pub fn is_tcc0_cca (& self) -> bool { * self == CHMUX_A :: TCC0_CCA } # [doc = "Checks if the value of the field is `TCC0_CCB`"]
# [inline (always)]
pub fn is_tcc0_ccb (& self) -> bool { * self == CHMUX_A :: TCC0_CCB } # [doc = "Checks if the value of the field is `TCC0_CCC`"]
# [inline (always)]
pub fn is_tcc0_ccc (& self) -> bool { * self == CHMUX_A :: TCC0_CCC } # [doc = "Checks if the value of the field is `TCC0_CCD`"]
# [inline (always)]
pub fn is_tcc0_ccd (& self) -> bool { * self == CHMUX_A :: TCC0_CCD } # [doc = "Checks if the value of the field is `TCC1_OVF`"]
# [inline (always)]
pub fn is_tcc1_ovf (& self) -> bool { * self == CHMUX_A :: TCC1_OVF } # [doc = "Checks if the value of the field is `TCC1_ERR`"]
# [inline (always)]
pub fn is_tcc1_err (& self) -> bool { * self == CHMUX_A :: TCC1_ERR } # [doc = "Checks if the value of the field is `TCC1_CCA`"]
# [inline (always)]
pub fn is_tcc1_cca (& self) -> bool { * self == CHMUX_A :: TCC1_CCA } # [doc = "Checks if the value of the field is `TCC1_CCB`"]
# [inline (always)]
pub fn is_tcc1_ccb (& self) -> bool { * self == CHMUX_A :: TCC1_CCB } # [doc = "Checks if the value of the field is `TCD0_OVF`"]
# [inline (always)]
pub fn is_tcd0_ovf (& self) -> bool { * self == CHMUX_A :: TCD0_OVF } # [doc = "Checks if the value of the field is `TCD0_ERR`"]
# [inline (always)]
pub fn is_tcd0_err (& self) -> bool { * self == CHMUX_A :: TCD0_ERR } # [doc = "Checks if the value of the field is `TCD0_CCA`"]
# [inline (always)]
pub fn is_tcd0_cca (& self) -> bool { * self == CHMUX_A :: TCD0_CCA } # [doc = "Checks if the value of the field is `TCD0_CCB`"]
# [inline (always)]
pub fn is_tcd0_ccb (& self) -> bool { * self == CHMUX_A :: TCD0_CCB } # [doc = "Checks if the value of the field is `TCD0_CCC`"]
# [inline (always)]
pub fn is_tcd0_ccc (& self) -> bool { * self == CHMUX_A :: TCD0_CCC } # [doc = "Checks if the value of the field is `TCD0_CCD`"]
# [inline (always)]
pub fn is_tcd0_ccd (& self) -> bool { * self == CHMUX_A :: TCD0_CCD } # [doc = "Checks if the value of the field is `TCD1_OVF`"]
# [inline (always)]
pub fn is_tcd1_ovf (& self) -> bool { * self == CHMUX_A :: TCD1_OVF } # [doc = "Checks if the value of the field is `TCD1_ERR`"]
# [inline (always)]
pub fn is_tcd1_err (& self) -> bool { * self == CHMUX_A :: TCD1_ERR } # [doc = "Checks if the value of the field is `TCD1_CCA`"]
# [inline (always)]
pub fn is_tcd1_cca (& self) -> bool { * self == CHMUX_A :: TCD1_CCA } # [doc = "Checks if the value of the field is `TCD1_CCB`"]
# [inline (always)]
pub fn is_tcd1_ccb (& self) -> bool { * self == CHMUX_A :: TCD1_CCB } # [doc = "Checks if the value of the field is `TCE0_OVF`"]
# [inline (always)]
pub fn is_tce0_ovf (& self) -> bool { * self == CHMUX_A :: TCE0_OVF } # [doc = "Checks if the value of the field is `TCE0_ERR`"]
# [inline (always)]
pub fn is_tce0_err (& self) -> bool { * self == CHMUX_A :: TCE0_ERR } # [doc = "Checks if the value of the field is `TCE0_CCA`"]
# [inline (always)]
pub fn is_tce0_cca (& self) -> bool { * self == CHMUX_A :: TCE0_CCA } # [doc = "Checks if the value of the field is `TCE0_CCB`"]
# [inline (always)]
pub fn is_tce0_ccb (& self) -> bool { * self == CHMUX_A :: TCE0_CCB } # [doc = "Checks if the value of the field is `TCE0_CCC`"]
# [inline (always)]
pub fn is_tce0_ccc (& self) -> bool { * self == CHMUX_A :: TCE0_CCC } # [doc = "Checks if the value of the field is `TCE0_CCD`"]
# [inline (always)]
pub fn is_tce0_ccd (& self) -> bool { * self == CHMUX_A :: TCE0_CCD } # [doc = "Checks if the value of the field is `TCE1_OVF`"]
# [inline (always)]
pub fn is_tce1_ovf (& self) -> bool { * self == CHMUX_A :: TCE1_OVF } # [doc = "Checks if the value of the field is `TCE1_ERR`"]
# [inline (always)]
pub fn is_tce1_err (& self) -> bool { * self == CHMUX_A :: TCE1_ERR } # [doc = "Checks if the value of the field is `TCE1_CCA`"]
# [inline (always)]
pub fn is_tce1_cca (& self) -> bool { * self == CHMUX_A :: TCE1_CCA } # [doc = "Checks if the value of the field is `TCE1_CCB`"]
# [inline (always)]
pub fn is_tce1_ccb (& self) -> bool { * self == CHMUX_A :: TCE1_CCB } # [doc = "Checks if the value of the field is `TCF0_OVF`"]
# [inline (always)]
pub fn is_tcf0_ovf (& self) -> bool { * self == CHMUX_A :: TCF0_OVF } # [doc = "Checks if the value of the field is `TCF0_ERR`"]
# [inline (always)]
pub fn is_tcf0_err (& self) -> bool { * self == CHMUX_A :: TCF0_ERR } # [doc = "Checks if the value of the field is `TCF0_CCA`"]
# [inline (always)]
pub fn is_tcf0_cca (& self) -> bool { * self == CHMUX_A :: TCF0_CCA } # [doc = "Checks if the value of the field is `TCF0_CCB`"]
# [inline (always)]
pub fn is_tcf0_ccb (& self) -> bool { * self == CHMUX_A :: TCF0_CCB } # [doc = "Checks if the value of the field is `TCF0_CCC`"]
# [inline (always)]
pub fn is_tcf0_ccc (& self) -> bool { * self == CHMUX_A :: TCF0_CCC } # [doc = "Checks if the value of the field is `TCF0_CCD`"]
# [inline (always)]
pub fn is_tcf0_ccd (& self) -> bool { * self == CHMUX_A :: TCF0_CCD } # [doc = "Checks if the value of the field is `TCF1_OVF`"]
# [inline (always)]
pub fn is_tcf1_ovf (& self) -> bool { * self == CHMUX_A :: TCF1_OVF } # [doc = "Checks if the value of the field is `TCF1_ERR`"]
# [inline (always)]
pub fn is_tcf1_err (& self) -> bool { * self == CHMUX_A :: TCF1_ERR } # [doc = "Checks if the value of the field is `TCF1_CCA`"]
# [inline (always)]
pub fn is_tcf1_cca (& self) -> bool { * self == CHMUX_A :: TCF1_CCA } # [doc = "Checks if the value of the field is `TCF1_CCB`"]
# [inline (always)]
pub fn is_tcf1_ccb (& self) -> bool { * self == CHMUX_A :: TCF1_CCB } } # [doc = "Field `CHMUX` writer - Event Channel 0 Multiplexer"]
pub type CHMUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CH0MUX_SPEC , u8 , CHMUX_A , 8 , O > ; impl < 'a , const O : u8 > CHMUX_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHMUX_A :: OFF) } # [doc = "RTC Overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_OVF) } # [doc = "RTC Compare Match"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_CMP) } # [doc = "Analog Comparator A Channel 0"]
# [inline (always)]
pub fn aca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH0) } # [doc = "Analog Comparator A Channel 1"]
# [inline (always)]
pub fn aca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH1) } # [doc = "Analog Comparator A Window"]
# [inline (always)]
pub fn aca_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_WIN) } # [doc = "Analog Comparator B Channel 0"]
# [inline (always)]
pub fn acb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH0) } # [doc = "Analog Comparator B Channel 1"]
# [inline (always)]
pub fn acb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH1) } # [doc = "Analog Comparator B Window"]
# [inline (always)]
pub fn acb_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_WIN) } # [doc = "ADC A Channel 0"]
# [inline (always)]
pub fn adca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH0) } # [doc = "ADC A Channel 1"]
# [inline (always)]
pub fn adca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH1) } # [doc = "ADC A Channel 2"]
# [inline (always)]
pub fn adca_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH2) } # [doc = "ADC A Channel 3"]
# [inline (always)]
pub fn adca_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH3) } # [doc = "ADC B Channel 0"]
# [inline (always)]
pub fn adcb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH0) } # [doc = "ADC B Channel 1"]
# [inline (always)]
pub fn adcb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH1) } # [doc = "ADC B Channel 2"]
# [inline (always)]
pub fn adcb_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH2) } # [doc = "ADC B Channel 3"]
# [inline (always)]
pub fn adcb_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH3) } # [doc = "Port A, Pin0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN0) } # [doc = "Port A, Pin1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN1) } # [doc = "Port A, Pin2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN2) } # [doc = "Port A, Pin3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN3) } # [doc = "Port A, Pin4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN4) } # [doc = "Port A, Pin5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN5) } # [doc = "Port A, Pin6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN6) } # [doc = "Port A, Pin7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN7) } # [doc = "Port B, Pin0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN0) } # [doc = "Port B, Pin1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN1) } # [doc = "Port B, Pin2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN2) } # [doc = "Port B, Pin3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN3) } # [doc = "Port B, Pin4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN4) } # [doc = "Port B, Pin5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN5) } # [doc = "Port B, Pin6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN6) } # [doc = "Port B, Pin7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN7) } # [doc = "Port C, Pin0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN0) } # [doc = "Port C, Pin1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN1) } # [doc = "Port C, Pin2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN2) } # [doc = "Port C, Pin3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN3) } # [doc = "Port C, Pin4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN4) } # [doc = "Port C, Pin5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN5) } # [doc = "Port C, Pin6"]
# [inline (always)]
pub fn portc_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN6) } # [doc = "Port C, Pin7"]
# [inline (always)]
pub fn portc_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN7) } # [doc = "Port D, Pin0"]
# [inline (always)]
pub fn portd_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN0) } # [doc = "Port D, Pin1"]
# [inline (always)]
pub fn portd_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN1) } # [doc = "Port D, Pin2"]
# [inline (always)]
pub fn portd_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN2) } # [doc = "Port D, Pin3"]
# [inline (always)]
pub fn portd_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN3) } # [doc = "Port D, Pin4"]
# [inline (always)]
pub fn portd_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN4) } # [doc = "Port D, Pin5"]
# [inline (always)]
pub fn portd_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN5) } # [doc = "Port D, Pin6"]
# [inline (always)]
pub fn portd_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN6) } # [doc = "Port D, Pin7"]
# [inline (always)]
pub fn portd_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN7) } # [doc = "Port E, Pin0"]
# [inline (always)]
pub fn porte_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN0) } # [doc = "Port E, Pin1"]
# [inline (always)]
pub fn porte_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN1) } # [doc = "Port E, Pin2"]
# [inline (always)]
pub fn porte_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN2) } # [doc = "Port E, Pin3"]
# [inline (always)]
pub fn porte_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN3) } # [doc = "Port E, Pin4"]
# [inline (always)]
pub fn porte_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN4) } # [doc = "Port E, Pin5"]
# [inline (always)]
pub fn porte_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN5) } # [doc = "Port E, Pin6"]
# [inline (always)]
pub fn porte_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN6) } # [doc = "Port E, Pin7"]
# [inline (always)]
pub fn porte_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN7) } # [doc = "Port F, Pin0"]
# [inline (always)]
pub fn portf_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN0) } # [doc = "Port F, Pin1"]
# [inline (always)]
pub fn portf_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN1) } # [doc = "Port F, Pin2"]
# [inline (always)]
pub fn portf_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN2) } # [doc = "Port F, Pin3"]
# [inline (always)]
pub fn portf_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN3) } # [doc = "Port F, Pin4"]
# [inline (always)]
pub fn portf_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN4) } # [doc = "Port F, Pin5"]
# [inline (always)]
pub fn portf_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN5) } # [doc = "Port F, Pin6"]
# [inline (always)]
pub fn portf_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN6) } # [doc = "Port F, Pin7"]
# [inline (always)]
pub fn portf_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN7) } # [doc = "Prescaler, divide by 1"]
# [inline (always)]
pub fn prescaler_1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1) } # [doc = "Prescaler, divide by 2"]
# [inline (always)]
pub fn prescaler_2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2) } # [doc = "Prescaler, divide by 4"]
# [inline (always)]
pub fn prescaler_4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4) } # [doc = "Prescaler, divide by 8"]
# [inline (always)]
pub fn prescaler_8 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8) } # [doc = "Prescaler, divide by 16"]
# [inline (always)]
pub fn prescaler_16 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16) } # [doc = "Prescaler, divide by 32"]
# [inline (always)]
pub fn prescaler_32 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32) } # [doc = "Prescaler, divide by 64"]
# [inline (always)]
pub fn prescaler_64 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_64) } # [doc = "Prescaler, divide by 128"]
# [inline (always)]
pub fn prescaler_128 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_128) } # [doc = "Prescaler, divide by 256"]
# [inline (always)]
pub fn prescaler_256 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_256) } # [doc = "Prescaler, divide by 512"]
# [inline (always)]
pub fn prescaler_512 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_512) } # [doc = "Prescaler, divide by 1024"]
# [inline (always)]
pub fn prescaler_1024 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1024) } # [doc = "Prescaler, divide by 2048"]
# [inline (always)]
pub fn prescaler_2048 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2048) } # [doc = "Prescaler, divide by 4096"]
# [inline (always)]
pub fn prescaler_4096 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4096) } # [doc = "Prescaler, divide by 8192"]
# [inline (always)]
pub fn prescaler_8192 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8192) } # [doc = "Prescaler, divide by 16384"]
# [inline (always)]
pub fn prescaler_16384 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16384) } # [doc = "Prescaler, divide by 32768"]
# [inline (always)]
pub fn prescaler_32768 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32768) } # [doc = "Timer/Counter C0 Overflow"]
# [inline (always)]
pub fn tcc0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_OVF) } # [doc = "Timer/Counter C0 Error"]
# [inline (always)]
pub fn tcc0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_ERR) } # [doc = "Timer/Counter C0 Compare or Capture A"]
# [inline (always)]
pub fn tcc0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCA) } # [doc = "Timer/Counter C0 Compare or Capture B"]
# [inline (always)]
pub fn tcc0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCB) } # [doc = "Timer/Counter C0 Compare or Capture C"]
# [inline (always)]
pub fn tcc0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCC) } # [doc = "Timer/Counter C0 Compare or Capture D"]
# [inline (always)]
pub fn tcc0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCD) } # [doc = "Timer/Counter C1 Overflow"]
# [inline (always)]
pub fn tcc1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_OVF) } # [doc = "Timer/Counter C1 Error"]
# [inline (always)]
pub fn tcc1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_ERR) } # [doc = "Timer/Counter C1 Compare or Capture A"]
# [inline (always)]
pub fn tcc1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCA) } # [doc = "Timer/Counter C1 Compare or Capture B"]
# [inline (always)]
pub fn tcc1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCB) } # [doc = "Timer/Counter D0 Overflow"]
# [inline (always)]
pub fn tcd0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_OVF) } # [doc = "Timer/Counter D0 Error"]
# [inline (always)]
pub fn tcd0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_ERR) } # [doc = "Timer/Counter D0 Compare or Capture A"]
# [inline (always)]
pub fn tcd0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCA) } # [doc = "Timer/Counter D0 Compare or Capture B"]
# [inline (always)]
pub fn tcd0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCB) } # [doc = "Timer/Counter D0 Compare or Capture C"]
# [inline (always)]
pub fn tcd0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCC) } # [doc = "Timer/Counter D0 Compare or Capture D"]
# [inline (always)]
pub fn tcd0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCD) } # [doc = "Timer/Counter D1 Overflow"]
# [inline (always)]
pub fn tcd1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_OVF) } # [doc = "Timer/Counter D1 Error"]
# [inline (always)]
pub fn tcd1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_ERR) } # [doc = "Timer/Counter D1 Compare or Capture A"]
# [inline (always)]
pub fn tcd1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCA) } # [doc = "Timer/Counter D1 Compare or Capture B"]
# [inline (always)]
pub fn tcd1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCB) } # [doc = "Timer/Counter E0 Overflow"]
# [inline (always)]
pub fn tce0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_OVF) } # [doc = "Timer/Counter E0 Error"]
# [inline (always)]
pub fn tce0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_ERR) } # [doc = "Timer/Counter E0 Compare or Capture A"]
# [inline (always)]
pub fn tce0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCA) } # [doc = "Timer/Counter E0 Compare or Capture B"]
# [inline (always)]
pub fn tce0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCB) } # [doc = "Timer/Counter E0 Compare or Capture C"]
# [inline (always)]
pub fn tce0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCC) } # [doc = "Timer/Counter E0 Compare or Capture D"]
# [inline (always)]
pub fn tce0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCD) } # [doc = "Timer/Counter E1 Overflow"]
# [inline (always)]
pub fn tce1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_OVF) } # [doc = "Timer/Counter E1 Error"]
# [inline (always)]
pub fn tce1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_ERR) } # [doc = "Timer/Counter E1 Compare or Capture A"]
# [inline (always)]
pub fn tce1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCA) } # [doc = "Timer/Counter E1 Compare or Capture B"]
# [inline (always)]
pub fn tce1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCB) } # [doc = "Timer/Counter F0 Overflow"]
# [inline (always)]
pub fn tcf0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_OVF) } # [doc = "Timer/Counter F0 Error"]
# [inline (always)]
pub fn tcf0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_ERR) } # [doc = "Timer/Counter F0 Compare or Capture A"]
# [inline (always)]
pub fn tcf0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCA) } # [doc = "Timer/Counter F0 Compare or Capture B"]
# [inline (always)]
pub fn tcf0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCB) } # [doc = "Timer/Counter F0 Compare or Capture C"]
# [inline (always)]
pub fn tcf0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCC) } # [doc = "Timer/Counter F0 Compare or Capture D"]
# [inline (always)]
pub fn tcf0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCD) } # [doc = "Timer/Counter F1 Overflow"]
# [inline (always)]
pub fn tcf1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_OVF) } # [doc = "Timer/Counter F1 Error"]
# [inline (always)]
pub fn tcf1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_ERR) } # [doc = "Timer/Counter F1 Compare or Capture A"]
# [inline (always)]
pub fn tcf1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCA) } # [doc = "Timer/Counter F1 Compare or Capture B"]
# [inline (always)]
pub fn tcf1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCB) } } impl R { # [doc = "Bits 0:7 - Event Channel 0 Multiplexer"]
# [inline (always)]
pub fn chmux (& self) -> CHMUX_R { CHMUX_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Event Channel 0 Multiplexer"]
# [inline (always)]
# [must_use]
pub fn chmux (& mut self) -> CHMUX_W < 0 > { CHMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Channel 0 Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch0mux](index.html) module"]
pub struct CH0MUX_SPEC ; impl crate :: RegisterSpec for CH0MUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch0mux::R](R) reader structure"]
impl crate :: Readable for CH0MUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch0mux::W](W) writer structure"]
impl crate :: Writable for CH0MUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH0MUX to value 0"]
impl crate :: Resettable for CH0MUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH1CTRL (rw) register accessor: an alias for `Reg<CH1CTRL_SPEC>`"]
pub type CH1CTRL = crate :: Reg < ch1ctrl :: CH1CTRL_SPEC > ; # [doc = "Channel 1 Control Register"]
pub mod ch1ctrl { # [doc = "Register `CH1CTRL` reader"]
pub struct R (crate :: R < CH1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH1CTRL` writer"]
pub struct W (crate :: W < CH1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIGFILT` reader - Digital Filter"]
pub type DIGFILT_R = crate :: FieldReader < u8 , DIGFILT_A > ; # [doc = "Digital Filter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DIGFILT_A { # [doc = "0: 1 SAMPLE"]
_1SAMPLE = 0 , # [doc = "1: 2 SAMPLES"]
_2SAMPLES = 1 , # [doc = "2: 3 SAMPLES"]
_3SAMPLES = 2 , # [doc = "3: 4 SAMPLES"]
_4SAMPLES = 3 , # [doc = "4: 5 SAMPLES"]
_5SAMPLES = 4 , # [doc = "5: 6 SAMPLES"]
_6SAMPLES = 5 , # [doc = "6: 7 SAMPLES"]
_7SAMPLES = 6 , # [doc = "7: 8 SAMPLES"]
_8SAMPLES = 7 , } impl From < DIGFILT_A > for u8 { # [inline (always)]
fn from (variant : DIGFILT_A) -> Self { variant as _ } } impl DIGFILT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIGFILT_A { match self . bits { 0 => DIGFILT_A :: _1SAMPLE , 1 => DIGFILT_A :: _2SAMPLES , 2 => DIGFILT_A :: _3SAMPLES , 3 => DIGFILT_A :: _4SAMPLES , 4 => DIGFILT_A :: _5SAMPLES , 5 => DIGFILT_A :: _6SAMPLES , 6 => DIGFILT_A :: _7SAMPLES , 7 => DIGFILT_A :: _8SAMPLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1SAMPLE`"]
# [inline (always)]
pub fn is_1sample (& self) -> bool { * self == DIGFILT_A :: _1SAMPLE } # [doc = "Checks if the value of the field is `_2SAMPLES`"]
# [inline (always)]
pub fn is_2samples (& self) -> bool { * self == DIGFILT_A :: _2SAMPLES } # [doc = "Checks if the value of the field is `_3SAMPLES`"]
# [inline (always)]
pub fn is_3samples (& self) -> bool { * self == DIGFILT_A :: _3SAMPLES } # [doc = "Checks if the value of the field is `_4SAMPLES`"]
# [inline (always)]
pub fn is_4samples (& self) -> bool { * self == DIGFILT_A :: _4SAMPLES } # [doc = "Checks if the value of the field is `_5SAMPLES`"]
# [inline (always)]
pub fn is_5samples (& self) -> bool { * self == DIGFILT_A :: _5SAMPLES } # [doc = "Checks if the value of the field is `_6SAMPLES`"]
# [inline (always)]
pub fn is_6samples (& self) -> bool { * self == DIGFILT_A :: _6SAMPLES } # [doc = "Checks if the value of the field is `_7SAMPLES`"]
# [inline (always)]
pub fn is_7samples (& self) -> bool { * self == DIGFILT_A :: _7SAMPLES } # [doc = "Checks if the value of the field is `_8SAMPLES`"]
# [inline (always)]
pub fn is_8samples (& self) -> bool { * self == DIGFILT_A :: _8SAMPLES } } # [doc = "Field `DIGFILT` writer - Digital Filter"]
pub type DIGFILT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH1CTRL_SPEC , u8 , DIGFILT_A , 3 , O > ; impl < 'a , const O : u8 > DIGFILT_W < 'a , O > { # [doc = "1 SAMPLE"]
# [inline (always)]
pub fn _1sample (self) -> & 'a mut W { self . variant (DIGFILT_A :: _1SAMPLE) } # [doc = "2 SAMPLES"]
# [inline (always)]
pub fn _2samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _2SAMPLES) } # [doc = "3 SAMPLES"]
# [inline (always)]
pub fn _3samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _3SAMPLES) } # [doc = "4 SAMPLES"]
# [inline (always)]
pub fn _4samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _4SAMPLES) } # [doc = "5 SAMPLES"]
# [inline (always)]
pub fn _5samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _5SAMPLES) } # [doc = "6 SAMPLES"]
# [inline (always)]
pub fn _6samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _6SAMPLES) } # [doc = "7 SAMPLES"]
# [inline (always)]
pub fn _7samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _7SAMPLES) } # [doc = "8 SAMPLES"]
# [inline (always)]
pub fn _8samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _8SAMPLES) } } impl R { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
pub fn digfilt (& self) -> DIGFILT_R { DIGFILT_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
# [must_use]
pub fn digfilt (& mut self) -> DIGFILT_W < 0 > { DIGFILT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch1ctrl](index.html) module"]
pub struct CH1CTRL_SPEC ; impl crate :: RegisterSpec for CH1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch1ctrl::R](R) reader structure"]
impl crate :: Readable for CH1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch1ctrl::W](W) writer structure"]
impl crate :: Writable for CH1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH1CTRL to value 0"]
impl crate :: Resettable for CH1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH1MUX (rw) register accessor: an alias for `Reg<CH1MUX_SPEC>`"]
pub type CH1MUX = crate :: Reg < ch1mux :: CH1MUX_SPEC > ; # [doc = "Event Channel 1 Multiplexer"]
pub mod ch1mux { # [doc = "Register `CH1MUX` reader"]
pub struct R (crate :: R < CH1MUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH1MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH1MUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH1MUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH1MUX` writer"]
pub struct W (crate :: W < CH1MUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH1MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH1MUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH1MUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHMUX` reader - Event Channel 1 Multiplexer"]
pub type CHMUX_R = crate :: FieldReader < u8 , CHMUX_A > ; # [doc = "Event Channel 1 Multiplexer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHMUX_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "8: RTC Overflow"]
RTC_OVF = 8 , # [doc = "9: RTC Compare Match"]
RTC_CMP = 9 , # [doc = "16: Analog Comparator A Channel 0"]
ACA_CH0 = 16 , # [doc = "17: Analog Comparator A Channel 1"]
ACA_CH1 = 17 , # [doc = "18: Analog Comparator A Window"]
ACA_WIN = 18 , # [doc = "19: Analog Comparator B Channel 0"]
ACB_CH0 = 19 , # [doc = "20: Analog Comparator B Channel 1"]
ACB_CH1 = 20 , # [doc = "21: Analog Comparator B Window"]
ACB_WIN = 21 , # [doc = "32: ADC A Channel 0"]
ADCA_CH0 = 32 , # [doc = "33: ADC A Channel 1"]
ADCA_CH1 = 33 , # [doc = "34: ADC A Channel 2"]
ADCA_CH2 = 34 , # [doc = "35: ADC A Channel 3"]
ADCA_CH3 = 35 , # [doc = "36: ADC B Channel 0"]
ADCB_CH0 = 36 , # [doc = "37: ADC B Channel 1"]
ADCB_CH1 = 37 , # [doc = "38: ADC B Channel 2"]
ADCB_CH2 = 38 , # [doc = "39: ADC B Channel 3"]
ADCB_CH3 = 39 , # [doc = "80: Port A, Pin0"]
PORTA_PIN0 = 80 , # [doc = "81: Port A, Pin1"]
PORTA_PIN1 = 81 , # [doc = "82: Port A, Pin2"]
PORTA_PIN2 = 82 , # [doc = "83: Port A, Pin3"]
PORTA_PIN3 = 83 , # [doc = "84: Port A, Pin4"]
PORTA_PIN4 = 84 , # [doc = "85: Port A, Pin5"]
PORTA_PIN5 = 85 , # [doc = "86: Port A, Pin6"]
PORTA_PIN6 = 86 , # [doc = "87: Port A, Pin7"]
PORTA_PIN7 = 87 , # [doc = "88: Port B, Pin0"]
PORTB_PIN0 = 88 , # [doc = "89: Port B, Pin1"]
PORTB_PIN1 = 89 , # [doc = "90: Port B, Pin2"]
PORTB_PIN2 = 90 , # [doc = "91: Port B, Pin3"]
PORTB_PIN3 = 91 , # [doc = "92: Port B, Pin4"]
PORTB_PIN4 = 92 , # [doc = "93: Port B, Pin5"]
PORTB_PIN5 = 93 , # [doc = "94: Port B, Pin6"]
PORTB_PIN6 = 94 , # [doc = "95: Port B, Pin7"]
PORTB_PIN7 = 95 , # [doc = "96: Port C, Pin0"]
PORTC_PIN0 = 96 , # [doc = "97: Port C, Pin1"]
PORTC_PIN1 = 97 , # [doc = "98: Port C, Pin2"]
PORTC_PIN2 = 98 , # [doc = "99: Port C, Pin3"]
PORTC_PIN3 = 99 , # [doc = "100: Port C, Pin4"]
PORTC_PIN4 = 100 , # [doc = "101: Port C, Pin5"]
PORTC_PIN5 = 101 , # [doc = "102: Port C, Pin6"]
PORTC_PIN6 = 102 , # [doc = "103: Port C, Pin7"]
PORTC_PIN7 = 103 , # [doc = "104: Port D, Pin0"]
PORTD_PIN0 = 104 , # [doc = "105: Port D, Pin1"]
PORTD_PIN1 = 105 , # [doc = "106: Port D, Pin2"]
PORTD_PIN2 = 106 , # [doc = "107: Port D, Pin3"]
PORTD_PIN3 = 107 , # [doc = "108: Port D, Pin4"]
PORTD_PIN4 = 108 , # [doc = "109: Port D, Pin5"]
PORTD_PIN5 = 109 , # [doc = "110: Port D, Pin6"]
PORTD_PIN6 = 110 , # [doc = "111: Port D, Pin7"]
PORTD_PIN7 = 111 , # [doc = "112: Port E, Pin0"]
PORTE_PIN0 = 112 , # [doc = "113: Port E, Pin1"]
PORTE_PIN1 = 113 , # [doc = "114: Port E, Pin2"]
PORTE_PIN2 = 114 , # [doc = "115: Port E, Pin3"]
PORTE_PIN3 = 115 , # [doc = "116: Port E, Pin4"]
PORTE_PIN4 = 116 , # [doc = "117: Port E, Pin5"]
PORTE_PIN5 = 117 , # [doc = "118: Port E, Pin6"]
PORTE_PIN6 = 118 , # [doc = "119: Port E, Pin7"]
PORTE_PIN7 = 119 , # [doc = "120: Port F, Pin0"]
PORTF_PIN0 = 120 , # [doc = "121: Port F, Pin1"]
PORTF_PIN1 = 121 , # [doc = "122: Port F, Pin2"]
PORTF_PIN2 = 122 , # [doc = "123: Port F, Pin3"]
PORTF_PIN3 = 123 , # [doc = "124: Port F, Pin4"]
PORTF_PIN4 = 124 , # [doc = "125: Port F, Pin5"]
PORTF_PIN5 = 125 , # [doc = "126: Port F, Pin6"]
PORTF_PIN6 = 126 , # [doc = "127: Port F, Pin7"]
PORTF_PIN7 = 127 , # [doc = "128: Prescaler, divide by 1"]
PRESCALER_1 = 128 , # [doc = "129: Prescaler, divide by 2"]
PRESCALER_2 = 129 , # [doc = "130: Prescaler, divide by 4"]
PRESCALER_4 = 130 , # [doc = "131: Prescaler, divide by 8"]
PRESCALER_8 = 131 , # [doc = "132: Prescaler, divide by 16"]
PRESCALER_16 = 132 , # [doc = "133: Prescaler, divide by 32"]
PRESCALER_32 = 133 , # [doc = "134: Prescaler, divide by 64"]
PRESCALER_64 = 134 , # [doc = "135: Prescaler, divide by 128"]
PRESCALER_128 = 135 , # [doc = "136: Prescaler, divide by 256"]
PRESCALER_256 = 136 , # [doc = "137: Prescaler, divide by 512"]
PRESCALER_512 = 137 , # [doc = "138: Prescaler, divide by 1024"]
PRESCALER_1024 = 138 , # [doc = "139: Prescaler, divide by 2048"]
PRESCALER_2048 = 139 , # [doc = "140: Prescaler, divide by 4096"]
PRESCALER_4096 = 140 , # [doc = "141: Prescaler, divide by 8192"]
PRESCALER_8192 = 141 , # [doc = "142: Prescaler, divide by 16384"]
PRESCALER_16384 = 142 , # [doc = "143: Prescaler, divide by 32768"]
PRESCALER_32768 = 143 , # [doc = "192: Timer/Counter C0 Overflow"]
TCC0_OVF = 192 , # [doc = "193: Timer/Counter C0 Error"]
TCC0_ERR = 193 , # [doc = "196: Timer/Counter C0 Compare or Capture A"]
TCC0_CCA = 196 , # [doc = "197: Timer/Counter C0 Compare or Capture B"]
TCC0_CCB = 197 , # [doc = "198: Timer/Counter C0 Compare or Capture C"]
TCC0_CCC = 198 , # [doc = "199: Timer/Counter C0 Compare or Capture D"]
TCC0_CCD = 199 , # [doc = "200: Timer/Counter C1 Overflow"]
TCC1_OVF = 200 , # [doc = "201: Timer/Counter C1 Error"]
TCC1_ERR = 201 , # [doc = "204: Timer/Counter C1 Compare or Capture A"]
TCC1_CCA = 204 , # [doc = "205: Timer/Counter C1 Compare or Capture B"]
TCC1_CCB = 205 , # [doc = "208: Timer/Counter D0 Overflow"]
TCD0_OVF = 208 , # [doc = "209: Timer/Counter D0 Error"]
TCD0_ERR = 209 , # [doc = "212: Timer/Counter D0 Compare or Capture A"]
TCD0_CCA = 212 , # [doc = "213: Timer/Counter D0 Compare or Capture B"]
TCD0_CCB = 213 , # [doc = "214: Timer/Counter D0 Compare or Capture C"]
TCD0_CCC = 214 , # [doc = "215: Timer/Counter D0 Compare or Capture D"]
TCD0_CCD = 215 , # [doc = "216: Timer/Counter D1 Overflow"]
TCD1_OVF = 216 , # [doc = "217: Timer/Counter D1 Error"]
TCD1_ERR = 217 , # [doc = "220: Timer/Counter D1 Compare or Capture A"]
TCD1_CCA = 220 , # [doc = "221: Timer/Counter D1 Compare or Capture B"]
TCD1_CCB = 221 , # [doc = "224: Timer/Counter E0 Overflow"]
TCE0_OVF = 224 , # [doc = "225: Timer/Counter E0 Error"]
TCE0_ERR = 225 , # [doc = "228: Timer/Counter E0 Compare or Capture A"]
TCE0_CCA = 228 , # [doc = "229: Timer/Counter E0 Compare or Capture B"]
TCE0_CCB = 229 , # [doc = "230: Timer/Counter E0 Compare or Capture C"]
TCE0_CCC = 230 , # [doc = "231: Timer/Counter E0 Compare or Capture D"]
TCE0_CCD = 231 , # [doc = "232: Timer/Counter E1 Overflow"]
TCE1_OVF = 232 , # [doc = "233: Timer/Counter E1 Error"]
TCE1_ERR = 233 , # [doc = "236: Timer/Counter E1 Compare or Capture A"]
TCE1_CCA = 236 , # [doc = "237: Timer/Counter E1 Compare or Capture B"]
TCE1_CCB = 237 , # [doc = "240: Timer/Counter F0 Overflow"]
TCF0_OVF = 240 , # [doc = "241: Timer/Counter F0 Error"]
TCF0_ERR = 241 , # [doc = "244: Timer/Counter F0 Compare or Capture A"]
TCF0_CCA = 244 , # [doc = "245: Timer/Counter F0 Compare or Capture B"]
TCF0_CCB = 245 , # [doc = "246: Timer/Counter F0 Compare or Capture C"]
TCF0_CCC = 246 , # [doc = "247: Timer/Counter F0 Compare or Capture D"]
TCF0_CCD = 247 , # [doc = "248: Timer/Counter F1 Overflow"]
TCF1_OVF = 248 , # [doc = "249: Timer/Counter F1 Error"]
TCF1_ERR = 249 , # [doc = "252: Timer/Counter F1 Compare or Capture A"]
TCF1_CCA = 252 , # [doc = "253: Timer/Counter F1 Compare or Capture B"]
TCF1_CCB = 253 , } impl From < CHMUX_A > for u8 { # [inline (always)]
fn from (variant : CHMUX_A) -> Self { variant as _ } } impl CHMUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHMUX_A > { match self . bits { 0 => Some (CHMUX_A :: OFF) , 8 => Some (CHMUX_A :: RTC_OVF) , 9 => Some (CHMUX_A :: RTC_CMP) , 16 => Some (CHMUX_A :: ACA_CH0) , 17 => Some (CHMUX_A :: ACA_CH1) , 18 => Some (CHMUX_A :: ACA_WIN) , 19 => Some (CHMUX_A :: ACB_CH0) , 20 => Some (CHMUX_A :: ACB_CH1) , 21 => Some (CHMUX_A :: ACB_WIN) , 32 => Some (CHMUX_A :: ADCA_CH0) , 33 => Some (CHMUX_A :: ADCA_CH1) , 34 => Some (CHMUX_A :: ADCA_CH2) , 35 => Some (CHMUX_A :: ADCA_CH3) , 36 => Some (CHMUX_A :: ADCB_CH0) , 37 => Some (CHMUX_A :: ADCB_CH1) , 38 => Some (CHMUX_A :: ADCB_CH2) , 39 => Some (CHMUX_A :: ADCB_CH3) , 80 => Some (CHMUX_A :: PORTA_PIN0) , 81 => Some (CHMUX_A :: PORTA_PIN1) , 82 => Some (CHMUX_A :: PORTA_PIN2) , 83 => Some (CHMUX_A :: PORTA_PIN3) , 84 => Some (CHMUX_A :: PORTA_PIN4) , 85 => Some (CHMUX_A :: PORTA_PIN5) , 86 => Some (CHMUX_A :: PORTA_PIN6) , 87 => Some (CHMUX_A :: PORTA_PIN7) , 88 => Some (CHMUX_A :: PORTB_PIN0) , 89 => Some (CHMUX_A :: PORTB_PIN1) , 90 => Some (CHMUX_A :: PORTB_PIN2) , 91 => Some (CHMUX_A :: PORTB_PIN3) , 92 => Some (CHMUX_A :: PORTB_PIN4) , 93 => Some (CHMUX_A :: PORTB_PIN5) , 94 => Some (CHMUX_A :: PORTB_PIN6) , 95 => Some (CHMUX_A :: PORTB_PIN7) , 96 => Some (CHMUX_A :: PORTC_PIN0) , 97 => Some (CHMUX_A :: PORTC_PIN1) , 98 => Some (CHMUX_A :: PORTC_PIN2) , 99 => Some (CHMUX_A :: PORTC_PIN3) , 100 => Some (CHMUX_A :: PORTC_PIN4) , 101 => Some (CHMUX_A :: PORTC_PIN5) , 102 => Some (CHMUX_A :: PORTC_PIN6) , 103 => Some (CHMUX_A :: PORTC_PIN7) , 104 => Some (CHMUX_A :: PORTD_PIN0) , 105 => Some (CHMUX_A :: PORTD_PIN1) , 106 => Some (CHMUX_A :: PORTD_PIN2) , 107 => Some (CHMUX_A :: PORTD_PIN3) , 108 => Some (CHMUX_A :: PORTD_PIN4) , 109 => Some (CHMUX_A :: PORTD_PIN5) , 110 => Some (CHMUX_A :: PORTD_PIN6) , 111 => Some (CHMUX_A :: PORTD_PIN7) , 112 => Some (CHMUX_A :: PORTE_PIN0) , 113 => Some (CHMUX_A :: PORTE_PIN1) , 114 => Some (CHMUX_A :: PORTE_PIN2) , 115 => Some (CHMUX_A :: PORTE_PIN3) , 116 => Some (CHMUX_A :: PORTE_PIN4) , 117 => Some (CHMUX_A :: PORTE_PIN5) , 118 => Some (CHMUX_A :: PORTE_PIN6) , 119 => Some (CHMUX_A :: PORTE_PIN7) , 120 => Some (CHMUX_A :: PORTF_PIN0) , 121 => Some (CHMUX_A :: PORTF_PIN1) , 122 => Some (CHMUX_A :: PORTF_PIN2) , 123 => Some (CHMUX_A :: PORTF_PIN3) , 124 => Some (CHMUX_A :: PORTF_PIN4) , 125 => Some (CHMUX_A :: PORTF_PIN5) , 126 => Some (CHMUX_A :: PORTF_PIN6) , 127 => Some (CHMUX_A :: PORTF_PIN7) , 128 => Some (CHMUX_A :: PRESCALER_1) , 129 => Some (CHMUX_A :: PRESCALER_2) , 130 => Some (CHMUX_A :: PRESCALER_4) , 131 => Some (CHMUX_A :: PRESCALER_8) , 132 => Some (CHMUX_A :: PRESCALER_16) , 133 => Some (CHMUX_A :: PRESCALER_32) , 134 => Some (CHMUX_A :: PRESCALER_64) , 135 => Some (CHMUX_A :: PRESCALER_128) , 136 => Some (CHMUX_A :: PRESCALER_256) , 137 => Some (CHMUX_A :: PRESCALER_512) , 138 => Some (CHMUX_A :: PRESCALER_1024) , 139 => Some (CHMUX_A :: PRESCALER_2048) , 140 => Some (CHMUX_A :: PRESCALER_4096) , 141 => Some (CHMUX_A :: PRESCALER_8192) , 142 => Some (CHMUX_A :: PRESCALER_16384) , 143 => Some (CHMUX_A :: PRESCALER_32768) , 192 => Some (CHMUX_A :: TCC0_OVF) , 193 => Some (CHMUX_A :: TCC0_ERR) , 196 => Some (CHMUX_A :: TCC0_CCA) , 197 => Some (CHMUX_A :: TCC0_CCB) , 198 => Some (CHMUX_A :: TCC0_CCC) , 199 => Some (CHMUX_A :: TCC0_CCD) , 200 => Some (CHMUX_A :: TCC1_OVF) , 201 => Some (CHMUX_A :: TCC1_ERR) , 204 => Some (CHMUX_A :: TCC1_CCA) , 205 => Some (CHMUX_A :: TCC1_CCB) , 208 => Some (CHMUX_A :: TCD0_OVF) , 209 => Some (CHMUX_A :: TCD0_ERR) , 212 => Some (CHMUX_A :: TCD0_CCA) , 213 => Some (CHMUX_A :: TCD0_CCB) , 214 => Some (CHMUX_A :: TCD0_CCC) , 215 => Some (CHMUX_A :: TCD0_CCD) , 216 => Some (CHMUX_A :: TCD1_OVF) , 217 => Some (CHMUX_A :: TCD1_ERR) , 220 => Some (CHMUX_A :: TCD1_CCA) , 221 => Some (CHMUX_A :: TCD1_CCB) , 224 => Some (CHMUX_A :: TCE0_OVF) , 225 => Some (CHMUX_A :: TCE0_ERR) , 228 => Some (CHMUX_A :: TCE0_CCA) , 229 => Some (CHMUX_A :: TCE0_CCB) , 230 => Some (CHMUX_A :: TCE0_CCC) , 231 => Some (CHMUX_A :: TCE0_CCD) , 232 => Some (CHMUX_A :: TCE1_OVF) , 233 => Some (CHMUX_A :: TCE1_ERR) , 236 => Some (CHMUX_A :: TCE1_CCA) , 237 => Some (CHMUX_A :: TCE1_CCB) , 240 => Some (CHMUX_A :: TCF0_OVF) , 241 => Some (CHMUX_A :: TCF0_ERR) , 244 => Some (CHMUX_A :: TCF0_CCA) , 245 => Some (CHMUX_A :: TCF0_CCB) , 246 => Some (CHMUX_A :: TCF0_CCC) , 247 => Some (CHMUX_A :: TCF0_CCD) , 248 => Some (CHMUX_A :: TCF1_OVF) , 249 => Some (CHMUX_A :: TCF1_ERR) , 252 => Some (CHMUX_A :: TCF1_CCA) , 253 => Some (CHMUX_A :: TCF1_CCB) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHMUX_A :: OFF } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == CHMUX_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == CHMUX_A :: RTC_CMP } # [doc = "Checks if the value of the field is `ACA_CH0`"]
# [inline (always)]
pub fn is_aca_ch0 (& self) -> bool { * self == CHMUX_A :: ACA_CH0 } # [doc = "Checks if the value of the field is `ACA_CH1`"]
# [inline (always)]
pub fn is_aca_ch1 (& self) -> bool { * self == CHMUX_A :: ACA_CH1 } # [doc = "Checks if the value of the field is `ACA_WIN`"]
# [inline (always)]
pub fn is_aca_win (& self) -> bool { * self == CHMUX_A :: ACA_WIN } # [doc = "Checks if the value of the field is `ACB_CH0`"]
# [inline (always)]
pub fn is_acb_ch0 (& self) -> bool { * self == CHMUX_A :: ACB_CH0 } # [doc = "Checks if the value of the field is `ACB_CH1`"]
# [inline (always)]
pub fn is_acb_ch1 (& self) -> bool { * self == CHMUX_A :: ACB_CH1 } # [doc = "Checks if the value of the field is `ACB_WIN`"]
# [inline (always)]
pub fn is_acb_win (& self) -> bool { * self == CHMUX_A :: ACB_WIN } # [doc = "Checks if the value of the field is `ADCA_CH0`"]
# [inline (always)]
pub fn is_adca_ch0 (& self) -> bool { * self == CHMUX_A :: ADCA_CH0 } # [doc = "Checks if the value of the field is `ADCA_CH1`"]
# [inline (always)]
pub fn is_adca_ch1 (& self) -> bool { * self == CHMUX_A :: ADCA_CH1 } # [doc = "Checks if the value of the field is `ADCA_CH2`"]
# [inline (always)]
pub fn is_adca_ch2 (& self) -> bool { * self == CHMUX_A :: ADCA_CH2 } # [doc = "Checks if the value of the field is `ADCA_CH3`"]
# [inline (always)]
pub fn is_adca_ch3 (& self) -> bool { * self == CHMUX_A :: ADCA_CH3 } # [doc = "Checks if the value of the field is `ADCB_CH0`"]
# [inline (always)]
pub fn is_adcb_ch0 (& self) -> bool { * self == CHMUX_A :: ADCB_CH0 } # [doc = "Checks if the value of the field is `ADCB_CH1`"]
# [inline (always)]
pub fn is_adcb_ch1 (& self) -> bool { * self == CHMUX_A :: ADCB_CH1 } # [doc = "Checks if the value of the field is `ADCB_CH2`"]
# [inline (always)]
pub fn is_adcb_ch2 (& self) -> bool { * self == CHMUX_A :: ADCB_CH2 } # [doc = "Checks if the value of the field is `ADCB_CH3`"]
# [inline (always)]
pub fn is_adcb_ch3 (& self) -> bool { * self == CHMUX_A :: ADCB_CH3 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN7 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTC_PIN6`"]
# [inline (always)]
pub fn is_portc_pin6 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN6 } # [doc = "Checks if the value of the field is `PORTC_PIN7`"]
# [inline (always)]
pub fn is_portc_pin7 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN7 } # [doc = "Checks if the value of the field is `PORTD_PIN0`"]
# [inline (always)]
pub fn is_portd_pin0 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN0 } # [doc = "Checks if the value of the field is `PORTD_PIN1`"]
# [inline (always)]
pub fn is_portd_pin1 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN1 } # [doc = "Checks if the value of the field is `PORTD_PIN2`"]
# [inline (always)]
pub fn is_portd_pin2 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN2 } # [doc = "Checks if the value of the field is `PORTD_PIN3`"]
# [inline (always)]
pub fn is_portd_pin3 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN3 } # [doc = "Checks if the value of the field is `PORTD_PIN4`"]
# [inline (always)]
pub fn is_portd_pin4 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN4 } # [doc = "Checks if the value of the field is `PORTD_PIN5`"]
# [inline (always)]
pub fn is_portd_pin5 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN5 } # [doc = "Checks if the value of the field is `PORTD_PIN6`"]
# [inline (always)]
pub fn is_portd_pin6 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN6 } # [doc = "Checks if the value of the field is `PORTD_PIN7`"]
# [inline (always)]
pub fn is_portd_pin7 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN7 } # [doc = "Checks if the value of the field is `PORTE_PIN0`"]
# [inline (always)]
pub fn is_porte_pin0 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN0 } # [doc = "Checks if the value of the field is `PORTE_PIN1`"]
# [inline (always)]
pub fn is_porte_pin1 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN1 } # [doc = "Checks if the value of the field is `PORTE_PIN2`"]
# [inline (always)]
pub fn is_porte_pin2 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN2 } # [doc = "Checks if the value of the field is `PORTE_PIN3`"]
# [inline (always)]
pub fn is_porte_pin3 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN3 } # [doc = "Checks if the value of the field is `PORTE_PIN4`"]
# [inline (always)]
pub fn is_porte_pin4 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN4 } # [doc = "Checks if the value of the field is `PORTE_PIN5`"]
# [inline (always)]
pub fn is_porte_pin5 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN5 } # [doc = "Checks if the value of the field is `PORTE_PIN6`"]
# [inline (always)]
pub fn is_porte_pin6 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN6 } # [doc = "Checks if the value of the field is `PORTE_PIN7`"]
# [inline (always)]
pub fn is_porte_pin7 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN7 } # [doc = "Checks if the value of the field is `PORTF_PIN0`"]
# [inline (always)]
pub fn is_portf_pin0 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN0 } # [doc = "Checks if the value of the field is `PORTF_PIN1`"]
# [inline (always)]
pub fn is_portf_pin1 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN1 } # [doc = "Checks if the value of the field is `PORTF_PIN2`"]
# [inline (always)]
pub fn is_portf_pin2 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN2 } # [doc = "Checks if the value of the field is `PORTF_PIN3`"]
# [inline (always)]
pub fn is_portf_pin3 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN3 } # [doc = "Checks if the value of the field is `PORTF_PIN4`"]
# [inline (always)]
pub fn is_portf_pin4 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN4 } # [doc = "Checks if the value of the field is `PORTF_PIN5`"]
# [inline (always)]
pub fn is_portf_pin5 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN5 } # [doc = "Checks if the value of the field is `PORTF_PIN6`"]
# [inline (always)]
pub fn is_portf_pin6 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN6 } # [doc = "Checks if the value of the field is `PORTF_PIN7`"]
# [inline (always)]
pub fn is_portf_pin7 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN7 } # [doc = "Checks if the value of the field is `PRESCALER_1`"]
# [inline (always)]
pub fn is_prescaler_1 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1 } # [doc = "Checks if the value of the field is `PRESCALER_2`"]
# [inline (always)]
pub fn is_prescaler_2 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2 } # [doc = "Checks if the value of the field is `PRESCALER_4`"]
# [inline (always)]
pub fn is_prescaler_4 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4 } # [doc = "Checks if the value of the field is `PRESCALER_8`"]
# [inline (always)]
pub fn is_prescaler_8 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8 } # [doc = "Checks if the value of the field is `PRESCALER_16`"]
# [inline (always)]
pub fn is_prescaler_16 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16 } # [doc = "Checks if the value of the field is `PRESCALER_32`"]
# [inline (always)]
pub fn is_prescaler_32 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32 } # [doc = "Checks if the value of the field is `PRESCALER_64`"]
# [inline (always)]
pub fn is_prescaler_64 (& self) -> bool { * self == CHMUX_A :: PRESCALER_64 } # [doc = "Checks if the value of the field is `PRESCALER_128`"]
# [inline (always)]
pub fn is_prescaler_128 (& self) -> bool { * self == CHMUX_A :: PRESCALER_128 } # [doc = "Checks if the value of the field is `PRESCALER_256`"]
# [inline (always)]
pub fn is_prescaler_256 (& self) -> bool { * self == CHMUX_A :: PRESCALER_256 } # [doc = "Checks if the value of the field is `PRESCALER_512`"]
# [inline (always)]
pub fn is_prescaler_512 (& self) -> bool { * self == CHMUX_A :: PRESCALER_512 } # [doc = "Checks if the value of the field is `PRESCALER_1024`"]
# [inline (always)]
pub fn is_prescaler_1024 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1024 } # [doc = "Checks if the value of the field is `PRESCALER_2048`"]
# [inline (always)]
pub fn is_prescaler_2048 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2048 } # [doc = "Checks if the value of the field is `PRESCALER_4096`"]
# [inline (always)]
pub fn is_prescaler_4096 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4096 } # [doc = "Checks if the value of the field is `PRESCALER_8192`"]
# [inline (always)]
pub fn is_prescaler_8192 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8192 } # [doc = "Checks if the value of the field is `PRESCALER_16384`"]
# [inline (always)]
pub fn is_prescaler_16384 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16384 } # [doc = "Checks if the value of the field is `PRESCALER_32768`"]
# [inline (always)]
pub fn is_prescaler_32768 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32768 } # [doc = "Checks if the value of the field is `TCC0_OVF`"]
# [inline (always)]
pub fn is_tcc0_ovf (& self) -> bool { * self == CHMUX_A :: TCC0_OVF } # [doc = "Checks if the value of the field is `TCC0_ERR`"]
# [inline (always)]
pub fn is_tcc0_err (& self) -> bool { * self == CHMUX_A :: TCC0_ERR } # [doc = "Checks if the value of the field is `TCC0_CCA`"]
# [inline (always)]
pub fn is_tcc0_cca (& self) -> bool { * self == CHMUX_A :: TCC0_CCA } # [doc = "Checks if the value of the field is `TCC0_CCB`"]
# [inline (always)]
pub fn is_tcc0_ccb (& self) -> bool { * self == CHMUX_A :: TCC0_CCB } # [doc = "Checks if the value of the field is `TCC0_CCC`"]
# [inline (always)]
pub fn is_tcc0_ccc (& self) -> bool { * self == CHMUX_A :: TCC0_CCC } # [doc = "Checks if the value of the field is `TCC0_CCD`"]
# [inline (always)]
pub fn is_tcc0_ccd (& self) -> bool { * self == CHMUX_A :: TCC0_CCD } # [doc = "Checks if the value of the field is `TCC1_OVF`"]
# [inline (always)]
pub fn is_tcc1_ovf (& self) -> bool { * self == CHMUX_A :: TCC1_OVF } # [doc = "Checks if the value of the field is `TCC1_ERR`"]
# [inline (always)]
pub fn is_tcc1_err (& self) -> bool { * self == CHMUX_A :: TCC1_ERR } # [doc = "Checks if the value of the field is `TCC1_CCA`"]
# [inline (always)]
pub fn is_tcc1_cca (& self) -> bool { * self == CHMUX_A :: TCC1_CCA } # [doc = "Checks if the value of the field is `TCC1_CCB`"]
# [inline (always)]
pub fn is_tcc1_ccb (& self) -> bool { * self == CHMUX_A :: TCC1_CCB } # [doc = "Checks if the value of the field is `TCD0_OVF`"]
# [inline (always)]
pub fn is_tcd0_ovf (& self) -> bool { * self == CHMUX_A :: TCD0_OVF } # [doc = "Checks if the value of the field is `TCD0_ERR`"]
# [inline (always)]
pub fn is_tcd0_err (& self) -> bool { * self == CHMUX_A :: TCD0_ERR } # [doc = "Checks if the value of the field is `TCD0_CCA`"]
# [inline (always)]
pub fn is_tcd0_cca (& self) -> bool { * self == CHMUX_A :: TCD0_CCA } # [doc = "Checks if the value of the field is `TCD0_CCB`"]
# [inline (always)]
pub fn is_tcd0_ccb (& self) -> bool { * self == CHMUX_A :: TCD0_CCB } # [doc = "Checks if the value of the field is `TCD0_CCC`"]
# [inline (always)]
pub fn is_tcd0_ccc (& self) -> bool { * self == CHMUX_A :: TCD0_CCC } # [doc = "Checks if the value of the field is `TCD0_CCD`"]
# [inline (always)]
pub fn is_tcd0_ccd (& self) -> bool { * self == CHMUX_A :: TCD0_CCD } # [doc = "Checks if the value of the field is `TCD1_OVF`"]
# [inline (always)]
pub fn is_tcd1_ovf (& self) -> bool { * self == CHMUX_A :: TCD1_OVF } # [doc = "Checks if the value of the field is `TCD1_ERR`"]
# [inline (always)]
pub fn is_tcd1_err (& self) -> bool { * self == CHMUX_A :: TCD1_ERR } # [doc = "Checks if the value of the field is `TCD1_CCA`"]
# [inline (always)]
pub fn is_tcd1_cca (& self) -> bool { * self == CHMUX_A :: TCD1_CCA } # [doc = "Checks if the value of the field is `TCD1_CCB`"]
# [inline (always)]
pub fn is_tcd1_ccb (& self) -> bool { * self == CHMUX_A :: TCD1_CCB } # [doc = "Checks if the value of the field is `TCE0_OVF`"]
# [inline (always)]
pub fn is_tce0_ovf (& self) -> bool { * self == CHMUX_A :: TCE0_OVF } # [doc = "Checks if the value of the field is `TCE0_ERR`"]
# [inline (always)]
pub fn is_tce0_err (& self) -> bool { * self == CHMUX_A :: TCE0_ERR } # [doc = "Checks if the value of the field is `TCE0_CCA`"]
# [inline (always)]
pub fn is_tce0_cca (& self) -> bool { * self == CHMUX_A :: TCE0_CCA } # [doc = "Checks if the value of the field is `TCE0_CCB`"]
# [inline (always)]
pub fn is_tce0_ccb (& self) -> bool { * self == CHMUX_A :: TCE0_CCB } # [doc = "Checks if the value of the field is `TCE0_CCC`"]
# [inline (always)]
pub fn is_tce0_ccc (& self) -> bool { * self == CHMUX_A :: TCE0_CCC } # [doc = "Checks if the value of the field is `TCE0_CCD`"]
# [inline (always)]
pub fn is_tce0_ccd (& self) -> bool { * self == CHMUX_A :: TCE0_CCD } # [doc = "Checks if the value of the field is `TCE1_OVF`"]
# [inline (always)]
pub fn is_tce1_ovf (& self) -> bool { * self == CHMUX_A :: TCE1_OVF } # [doc = "Checks if the value of the field is `TCE1_ERR`"]
# [inline (always)]
pub fn is_tce1_err (& self) -> bool { * self == CHMUX_A :: TCE1_ERR } # [doc = "Checks if the value of the field is `TCE1_CCA`"]
# [inline (always)]
pub fn is_tce1_cca (& self) -> bool { * self == CHMUX_A :: TCE1_CCA } # [doc = "Checks if the value of the field is `TCE1_CCB`"]
# [inline (always)]
pub fn is_tce1_ccb (& self) -> bool { * self == CHMUX_A :: TCE1_CCB } # [doc = "Checks if the value of the field is `TCF0_OVF`"]
# [inline (always)]
pub fn is_tcf0_ovf (& self) -> bool { * self == CHMUX_A :: TCF0_OVF } # [doc = "Checks if the value of the field is `TCF0_ERR`"]
# [inline (always)]
pub fn is_tcf0_err (& self) -> bool { * self == CHMUX_A :: TCF0_ERR } # [doc = "Checks if the value of the field is `TCF0_CCA`"]
# [inline (always)]
pub fn is_tcf0_cca (& self) -> bool { * self == CHMUX_A :: TCF0_CCA } # [doc = "Checks if the value of the field is `TCF0_CCB`"]
# [inline (always)]
pub fn is_tcf0_ccb (& self) -> bool { * self == CHMUX_A :: TCF0_CCB } # [doc = "Checks if the value of the field is `TCF0_CCC`"]
# [inline (always)]
pub fn is_tcf0_ccc (& self) -> bool { * self == CHMUX_A :: TCF0_CCC } # [doc = "Checks if the value of the field is `TCF0_CCD`"]
# [inline (always)]
pub fn is_tcf0_ccd (& self) -> bool { * self == CHMUX_A :: TCF0_CCD } # [doc = "Checks if the value of the field is `TCF1_OVF`"]
# [inline (always)]
pub fn is_tcf1_ovf (& self) -> bool { * self == CHMUX_A :: TCF1_OVF } # [doc = "Checks if the value of the field is `TCF1_ERR`"]
# [inline (always)]
pub fn is_tcf1_err (& self) -> bool { * self == CHMUX_A :: TCF1_ERR } # [doc = "Checks if the value of the field is `TCF1_CCA`"]
# [inline (always)]
pub fn is_tcf1_cca (& self) -> bool { * self == CHMUX_A :: TCF1_CCA } # [doc = "Checks if the value of the field is `TCF1_CCB`"]
# [inline (always)]
pub fn is_tcf1_ccb (& self) -> bool { * self == CHMUX_A :: TCF1_CCB } } # [doc = "Field `CHMUX` writer - Event Channel 1 Multiplexer"]
pub type CHMUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CH1MUX_SPEC , u8 , CHMUX_A , 8 , O > ; impl < 'a , const O : u8 > CHMUX_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHMUX_A :: OFF) } # [doc = "RTC Overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_OVF) } # [doc = "RTC Compare Match"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_CMP) } # [doc = "Analog Comparator A Channel 0"]
# [inline (always)]
pub fn aca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH0) } # [doc = "Analog Comparator A Channel 1"]
# [inline (always)]
pub fn aca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH1) } # [doc = "Analog Comparator A Window"]
# [inline (always)]
pub fn aca_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_WIN) } # [doc = "Analog Comparator B Channel 0"]
# [inline (always)]
pub fn acb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH0) } # [doc = "Analog Comparator B Channel 1"]
# [inline (always)]
pub fn acb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH1) } # [doc = "Analog Comparator B Window"]
# [inline (always)]
pub fn acb_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_WIN) } # [doc = "ADC A Channel 0"]
# [inline (always)]
pub fn adca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH0) } # [doc = "ADC A Channel 1"]
# [inline (always)]
pub fn adca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH1) } # [doc = "ADC A Channel 2"]
# [inline (always)]
pub fn adca_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH2) } # [doc = "ADC A Channel 3"]
# [inline (always)]
pub fn adca_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH3) } # [doc = "ADC B Channel 0"]
# [inline (always)]
pub fn adcb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH0) } # [doc = "ADC B Channel 1"]
# [inline (always)]
pub fn adcb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH1) } # [doc = "ADC B Channel 2"]
# [inline (always)]
pub fn adcb_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH2) } # [doc = "ADC B Channel 3"]
# [inline (always)]
pub fn adcb_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH3) } # [doc = "Port A, Pin0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN0) } # [doc = "Port A, Pin1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN1) } # [doc = "Port A, Pin2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN2) } # [doc = "Port A, Pin3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN3) } # [doc = "Port A, Pin4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN4) } # [doc = "Port A, Pin5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN5) } # [doc = "Port A, Pin6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN6) } # [doc = "Port A, Pin7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN7) } # [doc = "Port B, Pin0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN0) } # [doc = "Port B, Pin1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN1) } # [doc = "Port B, Pin2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN2) } # [doc = "Port B, Pin3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN3) } # [doc = "Port B, Pin4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN4) } # [doc = "Port B, Pin5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN5) } # [doc = "Port B, Pin6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN6) } # [doc = "Port B, Pin7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN7) } # [doc = "Port C, Pin0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN0) } # [doc = "Port C, Pin1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN1) } # [doc = "Port C, Pin2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN2) } # [doc = "Port C, Pin3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN3) } # [doc = "Port C, Pin4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN4) } # [doc = "Port C, Pin5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN5) } # [doc = "Port C, Pin6"]
# [inline (always)]
pub fn portc_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN6) } # [doc = "Port C, Pin7"]
# [inline (always)]
pub fn portc_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN7) } # [doc = "Port D, Pin0"]
# [inline (always)]
pub fn portd_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN0) } # [doc = "Port D, Pin1"]
# [inline (always)]
pub fn portd_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN1) } # [doc = "Port D, Pin2"]
# [inline (always)]
pub fn portd_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN2) } # [doc = "Port D, Pin3"]
# [inline (always)]
pub fn portd_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN3) } # [doc = "Port D, Pin4"]
# [inline (always)]
pub fn portd_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN4) } # [doc = "Port D, Pin5"]
# [inline (always)]
pub fn portd_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN5) } # [doc = "Port D, Pin6"]
# [inline (always)]
pub fn portd_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN6) } # [doc = "Port D, Pin7"]
# [inline (always)]
pub fn portd_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN7) } # [doc = "Port E, Pin0"]
# [inline (always)]
pub fn porte_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN0) } # [doc = "Port E, Pin1"]
# [inline (always)]
pub fn porte_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN1) } # [doc = "Port E, Pin2"]
# [inline (always)]
pub fn porte_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN2) } # [doc = "Port E, Pin3"]
# [inline (always)]
pub fn porte_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN3) } # [doc = "Port E, Pin4"]
# [inline (always)]
pub fn porte_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN4) } # [doc = "Port E, Pin5"]
# [inline (always)]
pub fn porte_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN5) } # [doc = "Port E, Pin6"]
# [inline (always)]
pub fn porte_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN6) } # [doc = "Port E, Pin7"]
# [inline (always)]
pub fn porte_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN7) } # [doc = "Port F, Pin0"]
# [inline (always)]
pub fn portf_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN0) } # [doc = "Port F, Pin1"]
# [inline (always)]
pub fn portf_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN1) } # [doc = "Port F, Pin2"]
# [inline (always)]
pub fn portf_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN2) } # [doc = "Port F, Pin3"]
# [inline (always)]
pub fn portf_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN3) } # [doc = "Port F, Pin4"]
# [inline (always)]
pub fn portf_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN4) } # [doc = "Port F, Pin5"]
# [inline (always)]
pub fn portf_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN5) } # [doc = "Port F, Pin6"]
# [inline (always)]
pub fn portf_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN6) } # [doc = "Port F, Pin7"]
# [inline (always)]
pub fn portf_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN7) } # [doc = "Prescaler, divide by 1"]
# [inline (always)]
pub fn prescaler_1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1) } # [doc = "Prescaler, divide by 2"]
# [inline (always)]
pub fn prescaler_2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2) } # [doc = "Prescaler, divide by 4"]
# [inline (always)]
pub fn prescaler_4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4) } # [doc = "Prescaler, divide by 8"]
# [inline (always)]
pub fn prescaler_8 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8) } # [doc = "Prescaler, divide by 16"]
# [inline (always)]
pub fn prescaler_16 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16) } # [doc = "Prescaler, divide by 32"]
# [inline (always)]
pub fn prescaler_32 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32) } # [doc = "Prescaler, divide by 64"]
# [inline (always)]
pub fn prescaler_64 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_64) } # [doc = "Prescaler, divide by 128"]
# [inline (always)]
pub fn prescaler_128 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_128) } # [doc = "Prescaler, divide by 256"]
# [inline (always)]
pub fn prescaler_256 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_256) } # [doc = "Prescaler, divide by 512"]
# [inline (always)]
pub fn prescaler_512 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_512) } # [doc = "Prescaler, divide by 1024"]
# [inline (always)]
pub fn prescaler_1024 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1024) } # [doc = "Prescaler, divide by 2048"]
# [inline (always)]
pub fn prescaler_2048 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2048) } # [doc = "Prescaler, divide by 4096"]
# [inline (always)]
pub fn prescaler_4096 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4096) } # [doc = "Prescaler, divide by 8192"]
# [inline (always)]
pub fn prescaler_8192 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8192) } # [doc = "Prescaler, divide by 16384"]
# [inline (always)]
pub fn prescaler_16384 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16384) } # [doc = "Prescaler, divide by 32768"]
# [inline (always)]
pub fn prescaler_32768 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32768) } # [doc = "Timer/Counter C0 Overflow"]
# [inline (always)]
pub fn tcc0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_OVF) } # [doc = "Timer/Counter C0 Error"]
# [inline (always)]
pub fn tcc0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_ERR) } # [doc = "Timer/Counter C0 Compare or Capture A"]
# [inline (always)]
pub fn tcc0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCA) } # [doc = "Timer/Counter C0 Compare or Capture B"]
# [inline (always)]
pub fn tcc0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCB) } # [doc = "Timer/Counter C0 Compare or Capture C"]
# [inline (always)]
pub fn tcc0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCC) } # [doc = "Timer/Counter C0 Compare or Capture D"]
# [inline (always)]
pub fn tcc0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCD) } # [doc = "Timer/Counter C1 Overflow"]
# [inline (always)]
pub fn tcc1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_OVF) } # [doc = "Timer/Counter C1 Error"]
# [inline (always)]
pub fn tcc1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_ERR) } # [doc = "Timer/Counter C1 Compare or Capture A"]
# [inline (always)]
pub fn tcc1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCA) } # [doc = "Timer/Counter C1 Compare or Capture B"]
# [inline (always)]
pub fn tcc1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCB) } # [doc = "Timer/Counter D0 Overflow"]
# [inline (always)]
pub fn tcd0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_OVF) } # [doc = "Timer/Counter D0 Error"]
# [inline (always)]
pub fn tcd0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_ERR) } # [doc = "Timer/Counter D0 Compare or Capture A"]
# [inline (always)]
pub fn tcd0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCA) } # [doc = "Timer/Counter D0 Compare or Capture B"]
# [inline (always)]
pub fn tcd0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCB) } # [doc = "Timer/Counter D0 Compare or Capture C"]
# [inline (always)]
pub fn tcd0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCC) } # [doc = "Timer/Counter D0 Compare or Capture D"]
# [inline (always)]
pub fn tcd0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCD) } # [doc = "Timer/Counter D1 Overflow"]
# [inline (always)]
pub fn tcd1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_OVF) } # [doc = "Timer/Counter D1 Error"]
# [inline (always)]
pub fn tcd1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_ERR) } # [doc = "Timer/Counter D1 Compare or Capture A"]
# [inline (always)]
pub fn tcd1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCA) } # [doc = "Timer/Counter D1 Compare or Capture B"]
# [inline (always)]
pub fn tcd1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCB) } # [doc = "Timer/Counter E0 Overflow"]
# [inline (always)]
pub fn tce0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_OVF) } # [doc = "Timer/Counter E0 Error"]
# [inline (always)]
pub fn tce0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_ERR) } # [doc = "Timer/Counter E0 Compare or Capture A"]
# [inline (always)]
pub fn tce0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCA) } # [doc = "Timer/Counter E0 Compare or Capture B"]
# [inline (always)]
pub fn tce0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCB) } # [doc = "Timer/Counter E0 Compare or Capture C"]
# [inline (always)]
pub fn tce0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCC) } # [doc = "Timer/Counter E0 Compare or Capture D"]
# [inline (always)]
pub fn tce0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCD) } # [doc = "Timer/Counter E1 Overflow"]
# [inline (always)]
pub fn tce1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_OVF) } # [doc = "Timer/Counter E1 Error"]
# [inline (always)]
pub fn tce1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_ERR) } # [doc = "Timer/Counter E1 Compare or Capture A"]
# [inline (always)]
pub fn tce1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCA) } # [doc = "Timer/Counter E1 Compare or Capture B"]
# [inline (always)]
pub fn tce1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCB) } # [doc = "Timer/Counter F0 Overflow"]
# [inline (always)]
pub fn tcf0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_OVF) } # [doc = "Timer/Counter F0 Error"]
# [inline (always)]
pub fn tcf0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_ERR) } # [doc = "Timer/Counter F0 Compare or Capture A"]
# [inline (always)]
pub fn tcf0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCA) } # [doc = "Timer/Counter F0 Compare or Capture B"]
# [inline (always)]
pub fn tcf0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCB) } # [doc = "Timer/Counter F0 Compare or Capture C"]
# [inline (always)]
pub fn tcf0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCC) } # [doc = "Timer/Counter F0 Compare or Capture D"]
# [inline (always)]
pub fn tcf0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCD) } # [doc = "Timer/Counter F1 Overflow"]
# [inline (always)]
pub fn tcf1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_OVF) } # [doc = "Timer/Counter F1 Error"]
# [inline (always)]
pub fn tcf1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_ERR) } # [doc = "Timer/Counter F1 Compare or Capture A"]
# [inline (always)]
pub fn tcf1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCA) } # [doc = "Timer/Counter F1 Compare or Capture B"]
# [inline (always)]
pub fn tcf1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCB) } } impl R { # [doc = "Bits 0:7 - Event Channel 1 Multiplexer"]
# [inline (always)]
pub fn chmux (& self) -> CHMUX_R { CHMUX_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Event Channel 1 Multiplexer"]
# [inline (always)]
# [must_use]
pub fn chmux (& mut self) -> CHMUX_W < 0 > { CHMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Channel 1 Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch1mux](index.html) module"]
pub struct CH1MUX_SPEC ; impl crate :: RegisterSpec for CH1MUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch1mux::R](R) reader structure"]
impl crate :: Readable for CH1MUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch1mux::W](W) writer structure"]
impl crate :: Writable for CH1MUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH1MUX to value 0"]
impl crate :: Resettable for CH1MUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH2CTRL (rw) register accessor: an alias for `Reg<CH2CTRL_SPEC>`"]
pub type CH2CTRL = crate :: Reg < ch2ctrl :: CH2CTRL_SPEC > ; # [doc = "Channel 2 Control Register"]
pub mod ch2ctrl { # [doc = "Register `CH2CTRL` reader"]
pub struct R (crate :: R < CH2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH2CTRL` writer"]
pub struct W (crate :: W < CH2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIGFILT` reader - Digital Filter"]
pub type DIGFILT_R = crate :: FieldReader < u8 , DIGFILT_A > ; # [doc = "Digital Filter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DIGFILT_A { # [doc = "0: 1 SAMPLE"]
_1SAMPLE = 0 , # [doc = "1: 2 SAMPLES"]
_2SAMPLES = 1 , # [doc = "2: 3 SAMPLES"]
_3SAMPLES = 2 , # [doc = "3: 4 SAMPLES"]
_4SAMPLES = 3 , # [doc = "4: 5 SAMPLES"]
_5SAMPLES = 4 , # [doc = "5: 6 SAMPLES"]
_6SAMPLES = 5 , # [doc = "6: 7 SAMPLES"]
_7SAMPLES = 6 , # [doc = "7: 8 SAMPLES"]
_8SAMPLES = 7 , } impl From < DIGFILT_A > for u8 { # [inline (always)]
fn from (variant : DIGFILT_A) -> Self { variant as _ } } impl DIGFILT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIGFILT_A { match self . bits { 0 => DIGFILT_A :: _1SAMPLE , 1 => DIGFILT_A :: _2SAMPLES , 2 => DIGFILT_A :: _3SAMPLES , 3 => DIGFILT_A :: _4SAMPLES , 4 => DIGFILT_A :: _5SAMPLES , 5 => DIGFILT_A :: _6SAMPLES , 6 => DIGFILT_A :: _7SAMPLES , 7 => DIGFILT_A :: _8SAMPLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1SAMPLE`"]
# [inline (always)]
pub fn is_1sample (& self) -> bool { * self == DIGFILT_A :: _1SAMPLE } # [doc = "Checks if the value of the field is `_2SAMPLES`"]
# [inline (always)]
pub fn is_2samples (& self) -> bool { * self == DIGFILT_A :: _2SAMPLES } # [doc = "Checks if the value of the field is `_3SAMPLES`"]
# [inline (always)]
pub fn is_3samples (& self) -> bool { * self == DIGFILT_A :: _3SAMPLES } # [doc = "Checks if the value of the field is `_4SAMPLES`"]
# [inline (always)]
pub fn is_4samples (& self) -> bool { * self == DIGFILT_A :: _4SAMPLES } # [doc = "Checks if the value of the field is `_5SAMPLES`"]
# [inline (always)]
pub fn is_5samples (& self) -> bool { * self == DIGFILT_A :: _5SAMPLES } # [doc = "Checks if the value of the field is `_6SAMPLES`"]
# [inline (always)]
pub fn is_6samples (& self) -> bool { * self == DIGFILT_A :: _6SAMPLES } # [doc = "Checks if the value of the field is `_7SAMPLES`"]
# [inline (always)]
pub fn is_7samples (& self) -> bool { * self == DIGFILT_A :: _7SAMPLES } # [doc = "Checks if the value of the field is `_8SAMPLES`"]
# [inline (always)]
pub fn is_8samples (& self) -> bool { * self == DIGFILT_A :: _8SAMPLES } } # [doc = "Field `DIGFILT` writer - Digital Filter"]
pub type DIGFILT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH2CTRL_SPEC , u8 , DIGFILT_A , 3 , O > ; impl < 'a , const O : u8 > DIGFILT_W < 'a , O > { # [doc = "1 SAMPLE"]
# [inline (always)]
pub fn _1sample (self) -> & 'a mut W { self . variant (DIGFILT_A :: _1SAMPLE) } # [doc = "2 SAMPLES"]
# [inline (always)]
pub fn _2samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _2SAMPLES) } # [doc = "3 SAMPLES"]
# [inline (always)]
pub fn _3samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _3SAMPLES) } # [doc = "4 SAMPLES"]
# [inline (always)]
pub fn _4samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _4SAMPLES) } # [doc = "5 SAMPLES"]
# [inline (always)]
pub fn _5samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _5SAMPLES) } # [doc = "6 SAMPLES"]
# [inline (always)]
pub fn _6samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _6SAMPLES) } # [doc = "7 SAMPLES"]
# [inline (always)]
pub fn _7samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _7SAMPLES) } # [doc = "8 SAMPLES"]
# [inline (always)]
pub fn _8samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _8SAMPLES) } } # [doc = "Field `QDEN` reader - Quadrature Decoder Enable"]
pub type QDEN_R = crate :: BitReader < bool > ; # [doc = "Field `QDEN` writer - Quadrature Decoder Enable"]
pub type QDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CH2CTRL_SPEC , bool , O > ; # [doc = "Field `QDIEN` reader - Quadrature Decoder Index Enable"]
pub type QDIEN_R = crate :: BitReader < bool > ; # [doc = "Field `QDIEN` writer - Quadrature Decoder Index Enable"]
pub type QDIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CH2CTRL_SPEC , bool , O > ; # [doc = "Field `QDIRM` reader - Quadrature Decoder Index Recognition Mode"]
pub type QDIRM_R = crate :: FieldReader < u8 , QDIRM_A > ; # [doc = "Quadrature Decoder Index Recognition Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum QDIRM_A { # [doc = "0: QDPH0 = 0, QDPH90 = 0"]
_00 = 0 , # [doc = "1: QDPH0 = 0, QDPH90 = 1"]
_01 = 1 , # [doc = "2: QDPH0 = 1, QDPH90 = 0"]
_10 = 2 , # [doc = "3: QDPH0 = 1, QDPH90 = 1"]
_11 = 3 , } impl From < QDIRM_A > for u8 { # [inline (always)]
fn from (variant : QDIRM_A) -> Self { variant as _ } } impl QDIRM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> QDIRM_A { match self . bits { 0 => QDIRM_A :: _00 , 1 => QDIRM_A :: _01 , 2 => QDIRM_A :: _10 , 3 => QDIRM_A :: _11 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_00`"]
# [inline (always)]
pub fn is_00 (& self) -> bool { * self == QDIRM_A :: _00 } # [doc = "Checks if the value of the field is `_01`"]
# [inline (always)]
pub fn is_01 (& self) -> bool { * self == QDIRM_A :: _01 } # [doc = "Checks if the value of the field is `_10`"]
# [inline (always)]
pub fn is_10 (& self) -> bool { * self == QDIRM_A :: _10 } # [doc = "Checks if the value of the field is `_11`"]
# [inline (always)]
pub fn is_11 (& self) -> bool { * self == QDIRM_A :: _11 } } # [doc = "Field `QDIRM` writer - Quadrature Decoder Index Recognition Mode"]
pub type QDIRM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH2CTRL_SPEC , u8 , QDIRM_A , 2 , O > ; impl < 'a , const O : u8 > QDIRM_W < 'a , O > { # [doc = "QDPH0 = 0, QDPH90 = 0"]
# [inline (always)]
pub fn _00 (self) -> & 'a mut W { self . variant (QDIRM_A :: _00) } # [doc = "QDPH0 = 0, QDPH90 = 1"]
# [inline (always)]
pub fn _01 (self) -> & 'a mut W { self . variant (QDIRM_A :: _01) } # [doc = "QDPH0 = 1, QDPH90 = 0"]
# [inline (always)]
pub fn _10 (self) -> & 'a mut W { self . variant (QDIRM_A :: _10) } # [doc = "QDPH0 = 1, QDPH90 = 1"]
# [inline (always)]
pub fn _11 (self) -> & 'a mut W { self . variant (QDIRM_A :: _11) } } impl R { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
pub fn digfilt (& self) -> DIGFILT_R { DIGFILT_R :: new (self . bits & 7) } # [doc = "Bit 3 - Quadrature Decoder Enable"]
# [inline (always)]
pub fn qden (& self) -> QDEN_R { QDEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Quadrature Decoder Index Enable"]
# [inline (always)]
pub fn qdien (& self) -> QDIEN_R { QDIEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Quadrature Decoder Index Recognition Mode"]
# [inline (always)]
pub fn qdirm (& self) -> QDIRM_R { QDIRM_R :: new ((self . bits >> 5) & 3) } } impl W { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
# [must_use]
pub fn digfilt (& mut self) -> DIGFILT_W < 0 > { DIGFILT_W :: new (self) } # [doc = "Bit 3 - Quadrature Decoder Enable"]
# [inline (always)]
# [must_use]
pub fn qden (& mut self) -> QDEN_W < 3 > { QDEN_W :: new (self) } # [doc = "Bit 4 - Quadrature Decoder Index Enable"]
# [inline (always)]
# [must_use]
pub fn qdien (& mut self) -> QDIEN_W < 4 > { QDIEN_W :: new (self) } # [doc = "Bits 5:6 - Quadrature Decoder Index Recognition Mode"]
# [inline (always)]
# [must_use]
pub fn qdirm (& mut self) -> QDIRM_W < 5 > { QDIRM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch2ctrl](index.html) module"]
pub struct CH2CTRL_SPEC ; impl crate :: RegisterSpec for CH2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch2ctrl::R](R) reader structure"]
impl crate :: Readable for CH2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch2ctrl::W](W) writer structure"]
impl crate :: Writable for CH2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH2CTRL to value 0"]
impl crate :: Resettable for CH2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH2MUX (rw) register accessor: an alias for `Reg<CH2MUX_SPEC>`"]
pub type CH2MUX = crate :: Reg < ch2mux :: CH2MUX_SPEC > ; # [doc = "Event Channel 2 Multiplexer"]
pub mod ch2mux { # [doc = "Register `CH2MUX` reader"]
pub struct R (crate :: R < CH2MUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH2MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH2MUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH2MUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH2MUX` writer"]
pub struct W (crate :: W < CH2MUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH2MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH2MUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH2MUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHMUX` reader - Event Channel 2 Multiplexer"]
pub type CHMUX_R = crate :: FieldReader < u8 , CHMUX_A > ; # [doc = "Event Channel 2 Multiplexer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHMUX_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "8: RTC Overflow"]
RTC_OVF = 8 , # [doc = "9: RTC Compare Match"]
RTC_CMP = 9 , # [doc = "16: Analog Comparator A Channel 0"]
ACA_CH0 = 16 , # [doc = "17: Analog Comparator A Channel 1"]
ACA_CH1 = 17 , # [doc = "18: Analog Comparator A Window"]
ACA_WIN = 18 , # [doc = "19: Analog Comparator B Channel 0"]
ACB_CH0 = 19 , # [doc = "20: Analog Comparator B Channel 1"]
ACB_CH1 = 20 , # [doc = "21: Analog Comparator B Window"]
ACB_WIN = 21 , # [doc = "32: ADC A Channel 0"]
ADCA_CH0 = 32 , # [doc = "33: ADC A Channel 1"]
ADCA_CH1 = 33 , # [doc = "34: ADC A Channel 2"]
ADCA_CH2 = 34 , # [doc = "35: ADC A Channel 3"]
ADCA_CH3 = 35 , # [doc = "36: ADC B Channel 0"]
ADCB_CH0 = 36 , # [doc = "37: ADC B Channel 1"]
ADCB_CH1 = 37 , # [doc = "38: ADC B Channel 2"]
ADCB_CH2 = 38 , # [doc = "39: ADC B Channel 3"]
ADCB_CH3 = 39 , # [doc = "80: Port A, Pin0"]
PORTA_PIN0 = 80 , # [doc = "81: Port A, Pin1"]
PORTA_PIN1 = 81 , # [doc = "82: Port A, Pin2"]
PORTA_PIN2 = 82 , # [doc = "83: Port A, Pin3"]
PORTA_PIN3 = 83 , # [doc = "84: Port A, Pin4"]
PORTA_PIN4 = 84 , # [doc = "85: Port A, Pin5"]
PORTA_PIN5 = 85 , # [doc = "86: Port A, Pin6"]
PORTA_PIN6 = 86 , # [doc = "87: Port A, Pin7"]
PORTA_PIN7 = 87 , # [doc = "88: Port B, Pin0"]
PORTB_PIN0 = 88 , # [doc = "89: Port B, Pin1"]
PORTB_PIN1 = 89 , # [doc = "90: Port B, Pin2"]
PORTB_PIN2 = 90 , # [doc = "91: Port B, Pin3"]
PORTB_PIN3 = 91 , # [doc = "92: Port B, Pin4"]
PORTB_PIN4 = 92 , # [doc = "93: Port B, Pin5"]
PORTB_PIN5 = 93 , # [doc = "94: Port B, Pin6"]
PORTB_PIN6 = 94 , # [doc = "95: Port B, Pin7"]
PORTB_PIN7 = 95 , # [doc = "96: Port C, Pin0"]
PORTC_PIN0 = 96 , # [doc = "97: Port C, Pin1"]
PORTC_PIN1 = 97 , # [doc = "98: Port C, Pin2"]
PORTC_PIN2 = 98 , # [doc = "99: Port C, Pin3"]
PORTC_PIN3 = 99 , # [doc = "100: Port C, Pin4"]
PORTC_PIN4 = 100 , # [doc = "101: Port C, Pin5"]
PORTC_PIN5 = 101 , # [doc = "102: Port C, Pin6"]
PORTC_PIN6 = 102 , # [doc = "103: Port C, Pin7"]
PORTC_PIN7 = 103 , # [doc = "104: Port D, Pin0"]
PORTD_PIN0 = 104 , # [doc = "105: Port D, Pin1"]
PORTD_PIN1 = 105 , # [doc = "106: Port D, Pin2"]
PORTD_PIN2 = 106 , # [doc = "107: Port D, Pin3"]
PORTD_PIN3 = 107 , # [doc = "108: Port D, Pin4"]
PORTD_PIN4 = 108 , # [doc = "109: Port D, Pin5"]
PORTD_PIN5 = 109 , # [doc = "110: Port D, Pin6"]
PORTD_PIN6 = 110 , # [doc = "111: Port D, Pin7"]
PORTD_PIN7 = 111 , # [doc = "112: Port E, Pin0"]
PORTE_PIN0 = 112 , # [doc = "113: Port E, Pin1"]
PORTE_PIN1 = 113 , # [doc = "114: Port E, Pin2"]
PORTE_PIN2 = 114 , # [doc = "115: Port E, Pin3"]
PORTE_PIN3 = 115 , # [doc = "116: Port E, Pin4"]
PORTE_PIN4 = 116 , # [doc = "117: Port E, Pin5"]
PORTE_PIN5 = 117 , # [doc = "118: Port E, Pin6"]
PORTE_PIN6 = 118 , # [doc = "119: Port E, Pin7"]
PORTE_PIN7 = 119 , # [doc = "120: Port F, Pin0"]
PORTF_PIN0 = 120 , # [doc = "121: Port F, Pin1"]
PORTF_PIN1 = 121 , # [doc = "122: Port F, Pin2"]
PORTF_PIN2 = 122 , # [doc = "123: Port F, Pin3"]
PORTF_PIN3 = 123 , # [doc = "124: Port F, Pin4"]
PORTF_PIN4 = 124 , # [doc = "125: Port F, Pin5"]
PORTF_PIN5 = 125 , # [doc = "126: Port F, Pin6"]
PORTF_PIN6 = 126 , # [doc = "127: Port F, Pin7"]
PORTF_PIN7 = 127 , # [doc = "128: Prescaler, divide by 1"]
PRESCALER_1 = 128 , # [doc = "129: Prescaler, divide by 2"]
PRESCALER_2 = 129 , # [doc = "130: Prescaler, divide by 4"]
PRESCALER_4 = 130 , # [doc = "131: Prescaler, divide by 8"]
PRESCALER_8 = 131 , # [doc = "132: Prescaler, divide by 16"]
PRESCALER_16 = 132 , # [doc = "133: Prescaler, divide by 32"]
PRESCALER_32 = 133 , # [doc = "134: Prescaler, divide by 64"]
PRESCALER_64 = 134 , # [doc = "135: Prescaler, divide by 128"]
PRESCALER_128 = 135 , # [doc = "136: Prescaler, divide by 256"]
PRESCALER_256 = 136 , # [doc = "137: Prescaler, divide by 512"]
PRESCALER_512 = 137 , # [doc = "138: Prescaler, divide by 1024"]
PRESCALER_1024 = 138 , # [doc = "139: Prescaler, divide by 2048"]
PRESCALER_2048 = 139 , # [doc = "140: Prescaler, divide by 4096"]
PRESCALER_4096 = 140 , # [doc = "141: Prescaler, divide by 8192"]
PRESCALER_8192 = 141 , # [doc = "142: Prescaler, divide by 16384"]
PRESCALER_16384 = 142 , # [doc = "143: Prescaler, divide by 32768"]
PRESCALER_32768 = 143 , # [doc = "192: Timer/Counter C0 Overflow"]
TCC0_OVF = 192 , # [doc = "193: Timer/Counter C0 Error"]
TCC0_ERR = 193 , # [doc = "196: Timer/Counter C0 Compare or Capture A"]
TCC0_CCA = 196 , # [doc = "197: Timer/Counter C0 Compare or Capture B"]
TCC0_CCB = 197 , # [doc = "198: Timer/Counter C0 Compare or Capture C"]
TCC0_CCC = 198 , # [doc = "199: Timer/Counter C0 Compare or Capture D"]
TCC0_CCD = 199 , # [doc = "200: Timer/Counter C1 Overflow"]
TCC1_OVF = 200 , # [doc = "201: Timer/Counter C1 Error"]
TCC1_ERR = 201 , # [doc = "204: Timer/Counter C1 Compare or Capture A"]
TCC1_CCA = 204 , # [doc = "205: Timer/Counter C1 Compare or Capture B"]
TCC1_CCB = 205 , # [doc = "208: Timer/Counter D0 Overflow"]
TCD0_OVF = 208 , # [doc = "209: Timer/Counter D0 Error"]
TCD0_ERR = 209 , # [doc = "212: Timer/Counter D0 Compare or Capture A"]
TCD0_CCA = 212 , # [doc = "213: Timer/Counter D0 Compare or Capture B"]
TCD0_CCB = 213 , # [doc = "214: Timer/Counter D0 Compare or Capture C"]
TCD0_CCC = 214 , # [doc = "215: Timer/Counter D0 Compare or Capture D"]
TCD0_CCD = 215 , # [doc = "216: Timer/Counter D1 Overflow"]
TCD1_OVF = 216 , # [doc = "217: Timer/Counter D1 Error"]
TCD1_ERR = 217 , # [doc = "220: Timer/Counter D1 Compare or Capture A"]
TCD1_CCA = 220 , # [doc = "221: Timer/Counter D1 Compare or Capture B"]
TCD1_CCB = 221 , # [doc = "224: Timer/Counter E0 Overflow"]
TCE0_OVF = 224 , # [doc = "225: Timer/Counter E0 Error"]
TCE0_ERR = 225 , # [doc = "228: Timer/Counter E0 Compare or Capture A"]
TCE0_CCA = 228 , # [doc = "229: Timer/Counter E0 Compare or Capture B"]
TCE0_CCB = 229 , # [doc = "230: Timer/Counter E0 Compare or Capture C"]
TCE0_CCC = 230 , # [doc = "231: Timer/Counter E0 Compare or Capture D"]
TCE0_CCD = 231 , # [doc = "232: Timer/Counter E1 Overflow"]
TCE1_OVF = 232 , # [doc = "233: Timer/Counter E1 Error"]
TCE1_ERR = 233 , # [doc = "236: Timer/Counter E1 Compare or Capture A"]
TCE1_CCA = 236 , # [doc = "237: Timer/Counter E1 Compare or Capture B"]
TCE1_CCB = 237 , # [doc = "240: Timer/Counter F0 Overflow"]
TCF0_OVF = 240 , # [doc = "241: Timer/Counter F0 Error"]
TCF0_ERR = 241 , # [doc = "244: Timer/Counter F0 Compare or Capture A"]
TCF0_CCA = 244 , # [doc = "245: Timer/Counter F0 Compare or Capture B"]
TCF0_CCB = 245 , # [doc = "246: Timer/Counter F0 Compare or Capture C"]
TCF0_CCC = 246 , # [doc = "247: Timer/Counter F0 Compare or Capture D"]
TCF0_CCD = 247 , # [doc = "248: Timer/Counter F1 Overflow"]
TCF1_OVF = 248 , # [doc = "249: Timer/Counter F1 Error"]
TCF1_ERR = 249 , # [doc = "252: Timer/Counter F1 Compare or Capture A"]
TCF1_CCA = 252 , # [doc = "253: Timer/Counter F1 Compare or Capture B"]
TCF1_CCB = 253 , } impl From < CHMUX_A > for u8 { # [inline (always)]
fn from (variant : CHMUX_A) -> Self { variant as _ } } impl CHMUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHMUX_A > { match self . bits { 0 => Some (CHMUX_A :: OFF) , 8 => Some (CHMUX_A :: RTC_OVF) , 9 => Some (CHMUX_A :: RTC_CMP) , 16 => Some (CHMUX_A :: ACA_CH0) , 17 => Some (CHMUX_A :: ACA_CH1) , 18 => Some (CHMUX_A :: ACA_WIN) , 19 => Some (CHMUX_A :: ACB_CH0) , 20 => Some (CHMUX_A :: ACB_CH1) , 21 => Some (CHMUX_A :: ACB_WIN) , 32 => Some (CHMUX_A :: ADCA_CH0) , 33 => Some (CHMUX_A :: ADCA_CH1) , 34 => Some (CHMUX_A :: ADCA_CH2) , 35 => Some (CHMUX_A :: ADCA_CH3) , 36 => Some (CHMUX_A :: ADCB_CH0) , 37 => Some (CHMUX_A :: ADCB_CH1) , 38 => Some (CHMUX_A :: ADCB_CH2) , 39 => Some (CHMUX_A :: ADCB_CH3) , 80 => Some (CHMUX_A :: PORTA_PIN0) , 81 => Some (CHMUX_A :: PORTA_PIN1) , 82 => Some (CHMUX_A :: PORTA_PIN2) , 83 => Some (CHMUX_A :: PORTA_PIN3) , 84 => Some (CHMUX_A :: PORTA_PIN4) , 85 => Some (CHMUX_A :: PORTA_PIN5) , 86 => Some (CHMUX_A :: PORTA_PIN6) , 87 => Some (CHMUX_A :: PORTA_PIN7) , 88 => Some (CHMUX_A :: PORTB_PIN0) , 89 => Some (CHMUX_A :: PORTB_PIN1) , 90 => Some (CHMUX_A :: PORTB_PIN2) , 91 => Some (CHMUX_A :: PORTB_PIN3) , 92 => Some (CHMUX_A :: PORTB_PIN4) , 93 => Some (CHMUX_A :: PORTB_PIN5) , 94 => Some (CHMUX_A :: PORTB_PIN6) , 95 => Some (CHMUX_A :: PORTB_PIN7) , 96 => Some (CHMUX_A :: PORTC_PIN0) , 97 => Some (CHMUX_A :: PORTC_PIN1) , 98 => Some (CHMUX_A :: PORTC_PIN2) , 99 => Some (CHMUX_A :: PORTC_PIN3) , 100 => Some (CHMUX_A :: PORTC_PIN4) , 101 => Some (CHMUX_A :: PORTC_PIN5) , 102 => Some (CHMUX_A :: PORTC_PIN6) , 103 => Some (CHMUX_A :: PORTC_PIN7) , 104 => Some (CHMUX_A :: PORTD_PIN0) , 105 => Some (CHMUX_A :: PORTD_PIN1) , 106 => Some (CHMUX_A :: PORTD_PIN2) , 107 => Some (CHMUX_A :: PORTD_PIN3) , 108 => Some (CHMUX_A :: PORTD_PIN4) , 109 => Some (CHMUX_A :: PORTD_PIN5) , 110 => Some (CHMUX_A :: PORTD_PIN6) , 111 => Some (CHMUX_A :: PORTD_PIN7) , 112 => Some (CHMUX_A :: PORTE_PIN0) , 113 => Some (CHMUX_A :: PORTE_PIN1) , 114 => Some (CHMUX_A :: PORTE_PIN2) , 115 => Some (CHMUX_A :: PORTE_PIN3) , 116 => Some (CHMUX_A :: PORTE_PIN4) , 117 => Some (CHMUX_A :: PORTE_PIN5) , 118 => Some (CHMUX_A :: PORTE_PIN6) , 119 => Some (CHMUX_A :: PORTE_PIN7) , 120 => Some (CHMUX_A :: PORTF_PIN0) , 121 => Some (CHMUX_A :: PORTF_PIN1) , 122 => Some (CHMUX_A :: PORTF_PIN2) , 123 => Some (CHMUX_A :: PORTF_PIN3) , 124 => Some (CHMUX_A :: PORTF_PIN4) , 125 => Some (CHMUX_A :: PORTF_PIN5) , 126 => Some (CHMUX_A :: PORTF_PIN6) , 127 => Some (CHMUX_A :: PORTF_PIN7) , 128 => Some (CHMUX_A :: PRESCALER_1) , 129 => Some (CHMUX_A :: PRESCALER_2) , 130 => Some (CHMUX_A :: PRESCALER_4) , 131 => Some (CHMUX_A :: PRESCALER_8) , 132 => Some (CHMUX_A :: PRESCALER_16) , 133 => Some (CHMUX_A :: PRESCALER_32) , 134 => Some (CHMUX_A :: PRESCALER_64) , 135 => Some (CHMUX_A :: PRESCALER_128) , 136 => Some (CHMUX_A :: PRESCALER_256) , 137 => Some (CHMUX_A :: PRESCALER_512) , 138 => Some (CHMUX_A :: PRESCALER_1024) , 139 => Some (CHMUX_A :: PRESCALER_2048) , 140 => Some (CHMUX_A :: PRESCALER_4096) , 141 => Some (CHMUX_A :: PRESCALER_8192) , 142 => Some (CHMUX_A :: PRESCALER_16384) , 143 => Some (CHMUX_A :: PRESCALER_32768) , 192 => Some (CHMUX_A :: TCC0_OVF) , 193 => Some (CHMUX_A :: TCC0_ERR) , 196 => Some (CHMUX_A :: TCC0_CCA) , 197 => Some (CHMUX_A :: TCC0_CCB) , 198 => Some (CHMUX_A :: TCC0_CCC) , 199 => Some (CHMUX_A :: TCC0_CCD) , 200 => Some (CHMUX_A :: TCC1_OVF) , 201 => Some (CHMUX_A :: TCC1_ERR) , 204 => Some (CHMUX_A :: TCC1_CCA) , 205 => Some (CHMUX_A :: TCC1_CCB) , 208 => Some (CHMUX_A :: TCD0_OVF) , 209 => Some (CHMUX_A :: TCD0_ERR) , 212 => Some (CHMUX_A :: TCD0_CCA) , 213 => Some (CHMUX_A :: TCD0_CCB) , 214 => Some (CHMUX_A :: TCD0_CCC) , 215 => Some (CHMUX_A :: TCD0_CCD) , 216 => Some (CHMUX_A :: TCD1_OVF) , 217 => Some (CHMUX_A :: TCD1_ERR) , 220 => Some (CHMUX_A :: TCD1_CCA) , 221 => Some (CHMUX_A :: TCD1_CCB) , 224 => Some (CHMUX_A :: TCE0_OVF) , 225 => Some (CHMUX_A :: TCE0_ERR) , 228 => Some (CHMUX_A :: TCE0_CCA) , 229 => Some (CHMUX_A :: TCE0_CCB) , 230 => Some (CHMUX_A :: TCE0_CCC) , 231 => Some (CHMUX_A :: TCE0_CCD) , 232 => Some (CHMUX_A :: TCE1_OVF) , 233 => Some (CHMUX_A :: TCE1_ERR) , 236 => Some (CHMUX_A :: TCE1_CCA) , 237 => Some (CHMUX_A :: TCE1_CCB) , 240 => Some (CHMUX_A :: TCF0_OVF) , 241 => Some (CHMUX_A :: TCF0_ERR) , 244 => Some (CHMUX_A :: TCF0_CCA) , 245 => Some (CHMUX_A :: TCF0_CCB) , 246 => Some (CHMUX_A :: TCF0_CCC) , 247 => Some (CHMUX_A :: TCF0_CCD) , 248 => Some (CHMUX_A :: TCF1_OVF) , 249 => Some (CHMUX_A :: TCF1_ERR) , 252 => Some (CHMUX_A :: TCF1_CCA) , 253 => Some (CHMUX_A :: TCF1_CCB) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHMUX_A :: OFF } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == CHMUX_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == CHMUX_A :: RTC_CMP } # [doc = "Checks if the value of the field is `ACA_CH0`"]
# [inline (always)]
pub fn is_aca_ch0 (& self) -> bool { * self == CHMUX_A :: ACA_CH0 } # [doc = "Checks if the value of the field is `ACA_CH1`"]
# [inline (always)]
pub fn is_aca_ch1 (& self) -> bool { * self == CHMUX_A :: ACA_CH1 } # [doc = "Checks if the value of the field is `ACA_WIN`"]
# [inline (always)]
pub fn is_aca_win (& self) -> bool { * self == CHMUX_A :: ACA_WIN } # [doc = "Checks if the value of the field is `ACB_CH0`"]
# [inline (always)]
pub fn is_acb_ch0 (& self) -> bool { * self == CHMUX_A :: ACB_CH0 } # [doc = "Checks if the value of the field is `ACB_CH1`"]
# [inline (always)]
pub fn is_acb_ch1 (& self) -> bool { * self == CHMUX_A :: ACB_CH1 } # [doc = "Checks if the value of the field is `ACB_WIN`"]
# [inline (always)]
pub fn is_acb_win (& self) -> bool { * self == CHMUX_A :: ACB_WIN } # [doc = "Checks if the value of the field is `ADCA_CH0`"]
# [inline (always)]
pub fn is_adca_ch0 (& self) -> bool { * self == CHMUX_A :: ADCA_CH0 } # [doc = "Checks if the value of the field is `ADCA_CH1`"]
# [inline (always)]
pub fn is_adca_ch1 (& self) -> bool { * self == CHMUX_A :: ADCA_CH1 } # [doc = "Checks if the value of the field is `ADCA_CH2`"]
# [inline (always)]
pub fn is_adca_ch2 (& self) -> bool { * self == CHMUX_A :: ADCA_CH2 } # [doc = "Checks if the value of the field is `ADCA_CH3`"]
# [inline (always)]
pub fn is_adca_ch3 (& self) -> bool { * self == CHMUX_A :: ADCA_CH3 } # [doc = "Checks if the value of the field is `ADCB_CH0`"]
# [inline (always)]
pub fn is_adcb_ch0 (& self) -> bool { * self == CHMUX_A :: ADCB_CH0 } # [doc = "Checks if the value of the field is `ADCB_CH1`"]
# [inline (always)]
pub fn is_adcb_ch1 (& self) -> bool { * self == CHMUX_A :: ADCB_CH1 } # [doc = "Checks if the value of the field is `ADCB_CH2`"]
# [inline (always)]
pub fn is_adcb_ch2 (& self) -> bool { * self == CHMUX_A :: ADCB_CH2 } # [doc = "Checks if the value of the field is `ADCB_CH3`"]
# [inline (always)]
pub fn is_adcb_ch3 (& self) -> bool { * self == CHMUX_A :: ADCB_CH3 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN7 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTC_PIN6`"]
# [inline (always)]
pub fn is_portc_pin6 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN6 } # [doc = "Checks if the value of the field is `PORTC_PIN7`"]
# [inline (always)]
pub fn is_portc_pin7 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN7 } # [doc = "Checks if the value of the field is `PORTD_PIN0`"]
# [inline (always)]
pub fn is_portd_pin0 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN0 } # [doc = "Checks if the value of the field is `PORTD_PIN1`"]
# [inline (always)]
pub fn is_portd_pin1 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN1 } # [doc = "Checks if the value of the field is `PORTD_PIN2`"]
# [inline (always)]
pub fn is_portd_pin2 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN2 } # [doc = "Checks if the value of the field is `PORTD_PIN3`"]
# [inline (always)]
pub fn is_portd_pin3 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN3 } # [doc = "Checks if the value of the field is `PORTD_PIN4`"]
# [inline (always)]
pub fn is_portd_pin4 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN4 } # [doc = "Checks if the value of the field is `PORTD_PIN5`"]
# [inline (always)]
pub fn is_portd_pin5 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN5 } # [doc = "Checks if the value of the field is `PORTD_PIN6`"]
# [inline (always)]
pub fn is_portd_pin6 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN6 } # [doc = "Checks if the value of the field is `PORTD_PIN7`"]
# [inline (always)]
pub fn is_portd_pin7 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN7 } # [doc = "Checks if the value of the field is `PORTE_PIN0`"]
# [inline (always)]
pub fn is_porte_pin0 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN0 } # [doc = "Checks if the value of the field is `PORTE_PIN1`"]
# [inline (always)]
pub fn is_porte_pin1 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN1 } # [doc = "Checks if the value of the field is `PORTE_PIN2`"]
# [inline (always)]
pub fn is_porte_pin2 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN2 } # [doc = "Checks if the value of the field is `PORTE_PIN3`"]
# [inline (always)]
pub fn is_porte_pin3 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN3 } # [doc = "Checks if the value of the field is `PORTE_PIN4`"]
# [inline (always)]
pub fn is_porte_pin4 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN4 } # [doc = "Checks if the value of the field is `PORTE_PIN5`"]
# [inline (always)]
pub fn is_porte_pin5 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN5 } # [doc = "Checks if the value of the field is `PORTE_PIN6`"]
# [inline (always)]
pub fn is_porte_pin6 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN6 } # [doc = "Checks if the value of the field is `PORTE_PIN7`"]
# [inline (always)]
pub fn is_porte_pin7 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN7 } # [doc = "Checks if the value of the field is `PORTF_PIN0`"]
# [inline (always)]
pub fn is_portf_pin0 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN0 } # [doc = "Checks if the value of the field is `PORTF_PIN1`"]
# [inline (always)]
pub fn is_portf_pin1 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN1 } # [doc = "Checks if the value of the field is `PORTF_PIN2`"]
# [inline (always)]
pub fn is_portf_pin2 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN2 } # [doc = "Checks if the value of the field is `PORTF_PIN3`"]
# [inline (always)]
pub fn is_portf_pin3 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN3 } # [doc = "Checks if the value of the field is `PORTF_PIN4`"]
# [inline (always)]
pub fn is_portf_pin4 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN4 } # [doc = "Checks if the value of the field is `PORTF_PIN5`"]
# [inline (always)]
pub fn is_portf_pin5 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN5 } # [doc = "Checks if the value of the field is `PORTF_PIN6`"]
# [inline (always)]
pub fn is_portf_pin6 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN6 } # [doc = "Checks if the value of the field is `PORTF_PIN7`"]
# [inline (always)]
pub fn is_portf_pin7 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN7 } # [doc = "Checks if the value of the field is `PRESCALER_1`"]
# [inline (always)]
pub fn is_prescaler_1 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1 } # [doc = "Checks if the value of the field is `PRESCALER_2`"]
# [inline (always)]
pub fn is_prescaler_2 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2 } # [doc = "Checks if the value of the field is `PRESCALER_4`"]
# [inline (always)]
pub fn is_prescaler_4 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4 } # [doc = "Checks if the value of the field is `PRESCALER_8`"]
# [inline (always)]
pub fn is_prescaler_8 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8 } # [doc = "Checks if the value of the field is `PRESCALER_16`"]
# [inline (always)]
pub fn is_prescaler_16 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16 } # [doc = "Checks if the value of the field is `PRESCALER_32`"]
# [inline (always)]
pub fn is_prescaler_32 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32 } # [doc = "Checks if the value of the field is `PRESCALER_64`"]
# [inline (always)]
pub fn is_prescaler_64 (& self) -> bool { * self == CHMUX_A :: PRESCALER_64 } # [doc = "Checks if the value of the field is `PRESCALER_128`"]
# [inline (always)]
pub fn is_prescaler_128 (& self) -> bool { * self == CHMUX_A :: PRESCALER_128 } # [doc = "Checks if the value of the field is `PRESCALER_256`"]
# [inline (always)]
pub fn is_prescaler_256 (& self) -> bool { * self == CHMUX_A :: PRESCALER_256 } # [doc = "Checks if the value of the field is `PRESCALER_512`"]
# [inline (always)]
pub fn is_prescaler_512 (& self) -> bool { * self == CHMUX_A :: PRESCALER_512 } # [doc = "Checks if the value of the field is `PRESCALER_1024`"]
# [inline (always)]
pub fn is_prescaler_1024 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1024 } # [doc = "Checks if the value of the field is `PRESCALER_2048`"]
# [inline (always)]
pub fn is_prescaler_2048 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2048 } # [doc = "Checks if the value of the field is `PRESCALER_4096`"]
# [inline (always)]
pub fn is_prescaler_4096 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4096 } # [doc = "Checks if the value of the field is `PRESCALER_8192`"]
# [inline (always)]
pub fn is_prescaler_8192 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8192 } # [doc = "Checks if the value of the field is `PRESCALER_16384`"]
# [inline (always)]
pub fn is_prescaler_16384 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16384 } # [doc = "Checks if the value of the field is `PRESCALER_32768`"]
# [inline (always)]
pub fn is_prescaler_32768 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32768 } # [doc = "Checks if the value of the field is `TCC0_OVF`"]
# [inline (always)]
pub fn is_tcc0_ovf (& self) -> bool { * self == CHMUX_A :: TCC0_OVF } # [doc = "Checks if the value of the field is `TCC0_ERR`"]
# [inline (always)]
pub fn is_tcc0_err (& self) -> bool { * self == CHMUX_A :: TCC0_ERR } # [doc = "Checks if the value of the field is `TCC0_CCA`"]
# [inline (always)]
pub fn is_tcc0_cca (& self) -> bool { * self == CHMUX_A :: TCC0_CCA } # [doc = "Checks if the value of the field is `TCC0_CCB`"]
# [inline (always)]
pub fn is_tcc0_ccb (& self) -> bool { * self == CHMUX_A :: TCC0_CCB } # [doc = "Checks if the value of the field is `TCC0_CCC`"]
# [inline (always)]
pub fn is_tcc0_ccc (& self) -> bool { * self == CHMUX_A :: TCC0_CCC } # [doc = "Checks if the value of the field is `TCC0_CCD`"]
# [inline (always)]
pub fn is_tcc0_ccd (& self) -> bool { * self == CHMUX_A :: TCC0_CCD } # [doc = "Checks if the value of the field is `TCC1_OVF`"]
# [inline (always)]
pub fn is_tcc1_ovf (& self) -> bool { * self == CHMUX_A :: TCC1_OVF } # [doc = "Checks if the value of the field is `TCC1_ERR`"]
# [inline (always)]
pub fn is_tcc1_err (& self) -> bool { * self == CHMUX_A :: TCC1_ERR } # [doc = "Checks if the value of the field is `TCC1_CCA`"]
# [inline (always)]
pub fn is_tcc1_cca (& self) -> bool { * self == CHMUX_A :: TCC1_CCA } # [doc = "Checks if the value of the field is `TCC1_CCB`"]
# [inline (always)]
pub fn is_tcc1_ccb (& self) -> bool { * self == CHMUX_A :: TCC1_CCB } # [doc = "Checks if the value of the field is `TCD0_OVF`"]
# [inline (always)]
pub fn is_tcd0_ovf (& self) -> bool { * self == CHMUX_A :: TCD0_OVF } # [doc = "Checks if the value of the field is `TCD0_ERR`"]
# [inline (always)]
pub fn is_tcd0_err (& self) -> bool { * self == CHMUX_A :: TCD0_ERR } # [doc = "Checks if the value of the field is `TCD0_CCA`"]
# [inline (always)]
pub fn is_tcd0_cca (& self) -> bool { * self == CHMUX_A :: TCD0_CCA } # [doc = "Checks if the value of the field is `TCD0_CCB`"]
# [inline (always)]
pub fn is_tcd0_ccb (& self) -> bool { * self == CHMUX_A :: TCD0_CCB } # [doc = "Checks if the value of the field is `TCD0_CCC`"]
# [inline (always)]
pub fn is_tcd0_ccc (& self) -> bool { * self == CHMUX_A :: TCD0_CCC } # [doc = "Checks if the value of the field is `TCD0_CCD`"]
# [inline (always)]
pub fn is_tcd0_ccd (& self) -> bool { * self == CHMUX_A :: TCD0_CCD } # [doc = "Checks if the value of the field is `TCD1_OVF`"]
# [inline (always)]
pub fn is_tcd1_ovf (& self) -> bool { * self == CHMUX_A :: TCD1_OVF } # [doc = "Checks if the value of the field is `TCD1_ERR`"]
# [inline (always)]
pub fn is_tcd1_err (& self) -> bool { * self == CHMUX_A :: TCD1_ERR } # [doc = "Checks if the value of the field is `TCD1_CCA`"]
# [inline (always)]
pub fn is_tcd1_cca (& self) -> bool { * self == CHMUX_A :: TCD1_CCA } # [doc = "Checks if the value of the field is `TCD1_CCB`"]
# [inline (always)]
pub fn is_tcd1_ccb (& self) -> bool { * self == CHMUX_A :: TCD1_CCB } # [doc = "Checks if the value of the field is `TCE0_OVF`"]
# [inline (always)]
pub fn is_tce0_ovf (& self) -> bool { * self == CHMUX_A :: TCE0_OVF } # [doc = "Checks if the value of the field is `TCE0_ERR`"]
# [inline (always)]
pub fn is_tce0_err (& self) -> bool { * self == CHMUX_A :: TCE0_ERR } # [doc = "Checks if the value of the field is `TCE0_CCA`"]
# [inline (always)]
pub fn is_tce0_cca (& self) -> bool { * self == CHMUX_A :: TCE0_CCA } # [doc = "Checks if the value of the field is `TCE0_CCB`"]
# [inline (always)]
pub fn is_tce0_ccb (& self) -> bool { * self == CHMUX_A :: TCE0_CCB } # [doc = "Checks if the value of the field is `TCE0_CCC`"]
# [inline (always)]
pub fn is_tce0_ccc (& self) -> bool { * self == CHMUX_A :: TCE0_CCC } # [doc = "Checks if the value of the field is `TCE0_CCD`"]
# [inline (always)]
pub fn is_tce0_ccd (& self) -> bool { * self == CHMUX_A :: TCE0_CCD } # [doc = "Checks if the value of the field is `TCE1_OVF`"]
# [inline (always)]
pub fn is_tce1_ovf (& self) -> bool { * self == CHMUX_A :: TCE1_OVF } # [doc = "Checks if the value of the field is `TCE1_ERR`"]
# [inline (always)]
pub fn is_tce1_err (& self) -> bool { * self == CHMUX_A :: TCE1_ERR } # [doc = "Checks if the value of the field is `TCE1_CCA`"]
# [inline (always)]
pub fn is_tce1_cca (& self) -> bool { * self == CHMUX_A :: TCE1_CCA } # [doc = "Checks if the value of the field is `TCE1_CCB`"]
# [inline (always)]
pub fn is_tce1_ccb (& self) -> bool { * self == CHMUX_A :: TCE1_CCB } # [doc = "Checks if the value of the field is `TCF0_OVF`"]
# [inline (always)]
pub fn is_tcf0_ovf (& self) -> bool { * self == CHMUX_A :: TCF0_OVF } # [doc = "Checks if the value of the field is `TCF0_ERR`"]
# [inline (always)]
pub fn is_tcf0_err (& self) -> bool { * self == CHMUX_A :: TCF0_ERR } # [doc = "Checks if the value of the field is `TCF0_CCA`"]
# [inline (always)]
pub fn is_tcf0_cca (& self) -> bool { * self == CHMUX_A :: TCF0_CCA } # [doc = "Checks if the value of the field is `TCF0_CCB`"]
# [inline (always)]
pub fn is_tcf0_ccb (& self) -> bool { * self == CHMUX_A :: TCF0_CCB } # [doc = "Checks if the value of the field is `TCF0_CCC`"]
# [inline (always)]
pub fn is_tcf0_ccc (& self) -> bool { * self == CHMUX_A :: TCF0_CCC } # [doc = "Checks if the value of the field is `TCF0_CCD`"]
# [inline (always)]
pub fn is_tcf0_ccd (& self) -> bool { * self == CHMUX_A :: TCF0_CCD } # [doc = "Checks if the value of the field is `TCF1_OVF`"]
# [inline (always)]
pub fn is_tcf1_ovf (& self) -> bool { * self == CHMUX_A :: TCF1_OVF } # [doc = "Checks if the value of the field is `TCF1_ERR`"]
# [inline (always)]
pub fn is_tcf1_err (& self) -> bool { * self == CHMUX_A :: TCF1_ERR } # [doc = "Checks if the value of the field is `TCF1_CCA`"]
# [inline (always)]
pub fn is_tcf1_cca (& self) -> bool { * self == CHMUX_A :: TCF1_CCA } # [doc = "Checks if the value of the field is `TCF1_CCB`"]
# [inline (always)]
pub fn is_tcf1_ccb (& self) -> bool { * self == CHMUX_A :: TCF1_CCB } } # [doc = "Field `CHMUX` writer - Event Channel 2 Multiplexer"]
pub type CHMUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CH2MUX_SPEC , u8 , CHMUX_A , 8 , O > ; impl < 'a , const O : u8 > CHMUX_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHMUX_A :: OFF) } # [doc = "RTC Overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_OVF) } # [doc = "RTC Compare Match"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_CMP) } # [doc = "Analog Comparator A Channel 0"]
# [inline (always)]
pub fn aca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH0) } # [doc = "Analog Comparator A Channel 1"]
# [inline (always)]
pub fn aca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH1) } # [doc = "Analog Comparator A Window"]
# [inline (always)]
pub fn aca_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_WIN) } # [doc = "Analog Comparator B Channel 0"]
# [inline (always)]
pub fn acb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH0) } # [doc = "Analog Comparator B Channel 1"]
# [inline (always)]
pub fn acb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH1) } # [doc = "Analog Comparator B Window"]
# [inline (always)]
pub fn acb_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_WIN) } # [doc = "ADC A Channel 0"]
# [inline (always)]
pub fn adca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH0) } # [doc = "ADC A Channel 1"]
# [inline (always)]
pub fn adca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH1) } # [doc = "ADC A Channel 2"]
# [inline (always)]
pub fn adca_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH2) } # [doc = "ADC A Channel 3"]
# [inline (always)]
pub fn adca_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH3) } # [doc = "ADC B Channel 0"]
# [inline (always)]
pub fn adcb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH0) } # [doc = "ADC B Channel 1"]
# [inline (always)]
pub fn adcb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH1) } # [doc = "ADC B Channel 2"]
# [inline (always)]
pub fn adcb_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH2) } # [doc = "ADC B Channel 3"]
# [inline (always)]
pub fn adcb_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH3) } # [doc = "Port A, Pin0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN0) } # [doc = "Port A, Pin1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN1) } # [doc = "Port A, Pin2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN2) } # [doc = "Port A, Pin3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN3) } # [doc = "Port A, Pin4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN4) } # [doc = "Port A, Pin5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN5) } # [doc = "Port A, Pin6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN6) } # [doc = "Port A, Pin7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN7) } # [doc = "Port B, Pin0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN0) } # [doc = "Port B, Pin1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN1) } # [doc = "Port B, Pin2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN2) } # [doc = "Port B, Pin3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN3) } # [doc = "Port B, Pin4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN4) } # [doc = "Port B, Pin5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN5) } # [doc = "Port B, Pin6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN6) } # [doc = "Port B, Pin7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN7) } # [doc = "Port C, Pin0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN0) } # [doc = "Port C, Pin1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN1) } # [doc = "Port C, Pin2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN2) } # [doc = "Port C, Pin3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN3) } # [doc = "Port C, Pin4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN4) } # [doc = "Port C, Pin5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN5) } # [doc = "Port C, Pin6"]
# [inline (always)]
pub fn portc_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN6) } # [doc = "Port C, Pin7"]
# [inline (always)]
pub fn portc_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN7) } # [doc = "Port D, Pin0"]
# [inline (always)]
pub fn portd_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN0) } # [doc = "Port D, Pin1"]
# [inline (always)]
pub fn portd_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN1) } # [doc = "Port D, Pin2"]
# [inline (always)]
pub fn portd_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN2) } # [doc = "Port D, Pin3"]
# [inline (always)]
pub fn portd_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN3) } # [doc = "Port D, Pin4"]
# [inline (always)]
pub fn portd_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN4) } # [doc = "Port D, Pin5"]
# [inline (always)]
pub fn portd_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN5) } # [doc = "Port D, Pin6"]
# [inline (always)]
pub fn portd_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN6) } # [doc = "Port D, Pin7"]
# [inline (always)]
pub fn portd_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN7) } # [doc = "Port E, Pin0"]
# [inline (always)]
pub fn porte_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN0) } # [doc = "Port E, Pin1"]
# [inline (always)]
pub fn porte_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN1) } # [doc = "Port E, Pin2"]
# [inline (always)]
pub fn porte_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN2) } # [doc = "Port E, Pin3"]
# [inline (always)]
pub fn porte_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN3) } # [doc = "Port E, Pin4"]
# [inline (always)]
pub fn porte_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN4) } # [doc = "Port E, Pin5"]
# [inline (always)]
pub fn porte_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN5) } # [doc = "Port E, Pin6"]
# [inline (always)]
pub fn porte_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN6) } # [doc = "Port E, Pin7"]
# [inline (always)]
pub fn porte_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN7) } # [doc = "Port F, Pin0"]
# [inline (always)]
pub fn portf_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN0) } # [doc = "Port F, Pin1"]
# [inline (always)]
pub fn portf_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN1) } # [doc = "Port F, Pin2"]
# [inline (always)]
pub fn portf_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN2) } # [doc = "Port F, Pin3"]
# [inline (always)]
pub fn portf_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN3) } # [doc = "Port F, Pin4"]
# [inline (always)]
pub fn portf_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN4) } # [doc = "Port F, Pin5"]
# [inline (always)]
pub fn portf_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN5) } # [doc = "Port F, Pin6"]
# [inline (always)]
pub fn portf_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN6) } # [doc = "Port F, Pin7"]
# [inline (always)]
pub fn portf_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN7) } # [doc = "Prescaler, divide by 1"]
# [inline (always)]
pub fn prescaler_1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1) } # [doc = "Prescaler, divide by 2"]
# [inline (always)]
pub fn prescaler_2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2) } # [doc = "Prescaler, divide by 4"]
# [inline (always)]
pub fn prescaler_4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4) } # [doc = "Prescaler, divide by 8"]
# [inline (always)]
pub fn prescaler_8 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8) } # [doc = "Prescaler, divide by 16"]
# [inline (always)]
pub fn prescaler_16 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16) } # [doc = "Prescaler, divide by 32"]
# [inline (always)]
pub fn prescaler_32 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32) } # [doc = "Prescaler, divide by 64"]
# [inline (always)]
pub fn prescaler_64 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_64) } # [doc = "Prescaler, divide by 128"]
# [inline (always)]
pub fn prescaler_128 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_128) } # [doc = "Prescaler, divide by 256"]
# [inline (always)]
pub fn prescaler_256 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_256) } # [doc = "Prescaler, divide by 512"]
# [inline (always)]
pub fn prescaler_512 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_512) } # [doc = "Prescaler, divide by 1024"]
# [inline (always)]
pub fn prescaler_1024 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1024) } # [doc = "Prescaler, divide by 2048"]
# [inline (always)]
pub fn prescaler_2048 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2048) } # [doc = "Prescaler, divide by 4096"]
# [inline (always)]
pub fn prescaler_4096 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4096) } # [doc = "Prescaler, divide by 8192"]
# [inline (always)]
pub fn prescaler_8192 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8192) } # [doc = "Prescaler, divide by 16384"]
# [inline (always)]
pub fn prescaler_16384 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16384) } # [doc = "Prescaler, divide by 32768"]
# [inline (always)]
pub fn prescaler_32768 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32768) } # [doc = "Timer/Counter C0 Overflow"]
# [inline (always)]
pub fn tcc0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_OVF) } # [doc = "Timer/Counter C0 Error"]
# [inline (always)]
pub fn tcc0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_ERR) } # [doc = "Timer/Counter C0 Compare or Capture A"]
# [inline (always)]
pub fn tcc0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCA) } # [doc = "Timer/Counter C0 Compare or Capture B"]
# [inline (always)]
pub fn tcc0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCB) } # [doc = "Timer/Counter C0 Compare or Capture C"]
# [inline (always)]
pub fn tcc0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCC) } # [doc = "Timer/Counter C0 Compare or Capture D"]
# [inline (always)]
pub fn tcc0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCD) } # [doc = "Timer/Counter C1 Overflow"]
# [inline (always)]
pub fn tcc1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_OVF) } # [doc = "Timer/Counter C1 Error"]
# [inline (always)]
pub fn tcc1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_ERR) } # [doc = "Timer/Counter C1 Compare or Capture A"]
# [inline (always)]
pub fn tcc1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCA) } # [doc = "Timer/Counter C1 Compare or Capture B"]
# [inline (always)]
pub fn tcc1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCB) } # [doc = "Timer/Counter D0 Overflow"]
# [inline (always)]
pub fn tcd0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_OVF) } # [doc = "Timer/Counter D0 Error"]
# [inline (always)]
pub fn tcd0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_ERR) } # [doc = "Timer/Counter D0 Compare or Capture A"]
# [inline (always)]
pub fn tcd0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCA) } # [doc = "Timer/Counter D0 Compare or Capture B"]
# [inline (always)]
pub fn tcd0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCB) } # [doc = "Timer/Counter D0 Compare or Capture C"]
# [inline (always)]
pub fn tcd0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCC) } # [doc = "Timer/Counter D0 Compare or Capture D"]
# [inline (always)]
pub fn tcd0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCD) } # [doc = "Timer/Counter D1 Overflow"]
# [inline (always)]
pub fn tcd1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_OVF) } # [doc = "Timer/Counter D1 Error"]
# [inline (always)]
pub fn tcd1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_ERR) } # [doc = "Timer/Counter D1 Compare or Capture A"]
# [inline (always)]
pub fn tcd1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCA) } # [doc = "Timer/Counter D1 Compare or Capture B"]
# [inline (always)]
pub fn tcd1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCB) } # [doc = "Timer/Counter E0 Overflow"]
# [inline (always)]
pub fn tce0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_OVF) } # [doc = "Timer/Counter E0 Error"]
# [inline (always)]
pub fn tce0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_ERR) } # [doc = "Timer/Counter E0 Compare or Capture A"]
# [inline (always)]
pub fn tce0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCA) } # [doc = "Timer/Counter E0 Compare or Capture B"]
# [inline (always)]
pub fn tce0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCB) } # [doc = "Timer/Counter E0 Compare or Capture C"]
# [inline (always)]
pub fn tce0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCC) } # [doc = "Timer/Counter E0 Compare or Capture D"]
# [inline (always)]
pub fn tce0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCD) } # [doc = "Timer/Counter E1 Overflow"]
# [inline (always)]
pub fn tce1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_OVF) } # [doc = "Timer/Counter E1 Error"]
# [inline (always)]
pub fn tce1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_ERR) } # [doc = "Timer/Counter E1 Compare or Capture A"]
# [inline (always)]
pub fn tce1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCA) } # [doc = "Timer/Counter E1 Compare or Capture B"]
# [inline (always)]
pub fn tce1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCB) } # [doc = "Timer/Counter F0 Overflow"]
# [inline (always)]
pub fn tcf0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_OVF) } # [doc = "Timer/Counter F0 Error"]
# [inline (always)]
pub fn tcf0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_ERR) } # [doc = "Timer/Counter F0 Compare or Capture A"]
# [inline (always)]
pub fn tcf0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCA) } # [doc = "Timer/Counter F0 Compare or Capture B"]
# [inline (always)]
pub fn tcf0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCB) } # [doc = "Timer/Counter F0 Compare or Capture C"]
# [inline (always)]
pub fn tcf0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCC) } # [doc = "Timer/Counter F0 Compare or Capture D"]
# [inline (always)]
pub fn tcf0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCD) } # [doc = "Timer/Counter F1 Overflow"]
# [inline (always)]
pub fn tcf1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_OVF) } # [doc = "Timer/Counter F1 Error"]
# [inline (always)]
pub fn tcf1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_ERR) } # [doc = "Timer/Counter F1 Compare or Capture A"]
# [inline (always)]
pub fn tcf1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCA) } # [doc = "Timer/Counter F1 Compare or Capture B"]
# [inline (always)]
pub fn tcf1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCB) } } impl R { # [doc = "Bits 0:7 - Event Channel 2 Multiplexer"]
# [inline (always)]
pub fn chmux (& self) -> CHMUX_R { CHMUX_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Event Channel 2 Multiplexer"]
# [inline (always)]
# [must_use]
pub fn chmux (& mut self) -> CHMUX_W < 0 > { CHMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Channel 2 Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch2mux](index.html) module"]
pub struct CH2MUX_SPEC ; impl crate :: RegisterSpec for CH2MUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch2mux::R](R) reader structure"]
impl crate :: Readable for CH2MUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch2mux::W](W) writer structure"]
impl crate :: Writable for CH2MUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH2MUX to value 0"]
impl crate :: Resettable for CH2MUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH3CTRL (rw) register accessor: an alias for `Reg<CH3CTRL_SPEC>`"]
pub type CH3CTRL = crate :: Reg < ch3ctrl :: CH3CTRL_SPEC > ; # [doc = "Channel 3 Control Register"]
pub mod ch3ctrl { # [doc = "Register `CH3CTRL` reader"]
pub struct R (crate :: R < CH3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH3CTRL` writer"]
pub struct W (crate :: W < CH3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIGFILT` reader - Digital Filter"]
pub type DIGFILT_R = crate :: FieldReader < u8 , DIGFILT_A > ; # [doc = "Digital Filter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DIGFILT_A { # [doc = "0: 1 SAMPLE"]
_1SAMPLE = 0 , # [doc = "1: 2 SAMPLES"]
_2SAMPLES = 1 , # [doc = "2: 3 SAMPLES"]
_3SAMPLES = 2 , # [doc = "3: 4 SAMPLES"]
_4SAMPLES = 3 , # [doc = "4: 5 SAMPLES"]
_5SAMPLES = 4 , # [doc = "5: 6 SAMPLES"]
_6SAMPLES = 5 , # [doc = "6: 7 SAMPLES"]
_7SAMPLES = 6 , # [doc = "7: 8 SAMPLES"]
_8SAMPLES = 7 , } impl From < DIGFILT_A > for u8 { # [inline (always)]
fn from (variant : DIGFILT_A) -> Self { variant as _ } } impl DIGFILT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIGFILT_A { match self . bits { 0 => DIGFILT_A :: _1SAMPLE , 1 => DIGFILT_A :: _2SAMPLES , 2 => DIGFILT_A :: _3SAMPLES , 3 => DIGFILT_A :: _4SAMPLES , 4 => DIGFILT_A :: _5SAMPLES , 5 => DIGFILT_A :: _6SAMPLES , 6 => DIGFILT_A :: _7SAMPLES , 7 => DIGFILT_A :: _8SAMPLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1SAMPLE`"]
# [inline (always)]
pub fn is_1sample (& self) -> bool { * self == DIGFILT_A :: _1SAMPLE } # [doc = "Checks if the value of the field is `_2SAMPLES`"]
# [inline (always)]
pub fn is_2samples (& self) -> bool { * self == DIGFILT_A :: _2SAMPLES } # [doc = "Checks if the value of the field is `_3SAMPLES`"]
# [inline (always)]
pub fn is_3samples (& self) -> bool { * self == DIGFILT_A :: _3SAMPLES } # [doc = "Checks if the value of the field is `_4SAMPLES`"]
# [inline (always)]
pub fn is_4samples (& self) -> bool { * self == DIGFILT_A :: _4SAMPLES } # [doc = "Checks if the value of the field is `_5SAMPLES`"]
# [inline (always)]
pub fn is_5samples (& self) -> bool { * self == DIGFILT_A :: _5SAMPLES } # [doc = "Checks if the value of the field is `_6SAMPLES`"]
# [inline (always)]
pub fn is_6samples (& self) -> bool { * self == DIGFILT_A :: _6SAMPLES } # [doc = "Checks if the value of the field is `_7SAMPLES`"]
# [inline (always)]
pub fn is_7samples (& self) -> bool { * self == DIGFILT_A :: _7SAMPLES } # [doc = "Checks if the value of the field is `_8SAMPLES`"]
# [inline (always)]
pub fn is_8samples (& self) -> bool { * self == DIGFILT_A :: _8SAMPLES } } # [doc = "Field `DIGFILT` writer - Digital Filter"]
pub type DIGFILT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH3CTRL_SPEC , u8 , DIGFILT_A , 3 , O > ; impl < 'a , const O : u8 > DIGFILT_W < 'a , O > { # [doc = "1 SAMPLE"]
# [inline (always)]
pub fn _1sample (self) -> & 'a mut W { self . variant (DIGFILT_A :: _1SAMPLE) } # [doc = "2 SAMPLES"]
# [inline (always)]
pub fn _2samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _2SAMPLES) } # [doc = "3 SAMPLES"]
# [inline (always)]
pub fn _3samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _3SAMPLES) } # [doc = "4 SAMPLES"]
# [inline (always)]
pub fn _4samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _4SAMPLES) } # [doc = "5 SAMPLES"]
# [inline (always)]
pub fn _5samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _5SAMPLES) } # [doc = "6 SAMPLES"]
# [inline (always)]
pub fn _6samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _6SAMPLES) } # [doc = "7 SAMPLES"]
# [inline (always)]
pub fn _7samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _7SAMPLES) } # [doc = "8 SAMPLES"]
# [inline (always)]
pub fn _8samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _8SAMPLES) } } impl R { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
pub fn digfilt (& self) -> DIGFILT_R { DIGFILT_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
# [must_use]
pub fn digfilt (& mut self) -> DIGFILT_W < 0 > { DIGFILT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch3ctrl](index.html) module"]
pub struct CH3CTRL_SPEC ; impl crate :: RegisterSpec for CH3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch3ctrl::R](R) reader structure"]
impl crate :: Readable for CH3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch3ctrl::W](W) writer structure"]
impl crate :: Writable for CH3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH3CTRL to value 0"]
impl crate :: Resettable for CH3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH3MUX (rw) register accessor: an alias for `Reg<CH3MUX_SPEC>`"]
pub type CH3MUX = crate :: Reg < ch3mux :: CH3MUX_SPEC > ; # [doc = "Event Channel 3 Multiplexer"]
pub mod ch3mux { # [doc = "Register `CH3MUX` reader"]
pub struct R (crate :: R < CH3MUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH3MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH3MUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH3MUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH3MUX` writer"]
pub struct W (crate :: W < CH3MUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH3MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH3MUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH3MUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHMUX` reader - Event Channel 3 Multiplexer"]
pub type CHMUX_R = crate :: FieldReader < u8 , CHMUX_A > ; # [doc = "Event Channel 3 Multiplexer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHMUX_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "8: RTC Overflow"]
RTC_OVF = 8 , # [doc = "9: RTC Compare Match"]
RTC_CMP = 9 , # [doc = "16: Analog Comparator A Channel 0"]
ACA_CH0 = 16 , # [doc = "17: Analog Comparator A Channel 1"]
ACA_CH1 = 17 , # [doc = "18: Analog Comparator A Window"]
ACA_WIN = 18 , # [doc = "19: Analog Comparator B Channel 0"]
ACB_CH0 = 19 , # [doc = "20: Analog Comparator B Channel 1"]
ACB_CH1 = 20 , # [doc = "21: Analog Comparator B Window"]
ACB_WIN = 21 , # [doc = "32: ADC A Channel 0"]
ADCA_CH0 = 32 , # [doc = "33: ADC A Channel 1"]
ADCA_CH1 = 33 , # [doc = "34: ADC A Channel 2"]
ADCA_CH2 = 34 , # [doc = "35: ADC A Channel 3"]
ADCA_CH3 = 35 , # [doc = "36: ADC B Channel 0"]
ADCB_CH0 = 36 , # [doc = "37: ADC B Channel 1"]
ADCB_CH1 = 37 , # [doc = "38: ADC B Channel 2"]
ADCB_CH2 = 38 , # [doc = "39: ADC B Channel 3"]
ADCB_CH3 = 39 , # [doc = "80: Port A, Pin0"]
PORTA_PIN0 = 80 , # [doc = "81: Port A, Pin1"]
PORTA_PIN1 = 81 , # [doc = "82: Port A, Pin2"]
PORTA_PIN2 = 82 , # [doc = "83: Port A, Pin3"]
PORTA_PIN3 = 83 , # [doc = "84: Port A, Pin4"]
PORTA_PIN4 = 84 , # [doc = "85: Port A, Pin5"]
PORTA_PIN5 = 85 , # [doc = "86: Port A, Pin6"]
PORTA_PIN6 = 86 , # [doc = "87: Port A, Pin7"]
PORTA_PIN7 = 87 , # [doc = "88: Port B, Pin0"]
PORTB_PIN0 = 88 , # [doc = "89: Port B, Pin1"]
PORTB_PIN1 = 89 , # [doc = "90: Port B, Pin2"]
PORTB_PIN2 = 90 , # [doc = "91: Port B, Pin3"]
PORTB_PIN3 = 91 , # [doc = "92: Port B, Pin4"]
PORTB_PIN4 = 92 , # [doc = "93: Port B, Pin5"]
PORTB_PIN5 = 93 , # [doc = "94: Port B, Pin6"]
PORTB_PIN6 = 94 , # [doc = "95: Port B, Pin7"]
PORTB_PIN7 = 95 , # [doc = "96: Port C, Pin0"]
PORTC_PIN0 = 96 , # [doc = "97: Port C, Pin1"]
PORTC_PIN1 = 97 , # [doc = "98: Port C, Pin2"]
PORTC_PIN2 = 98 , # [doc = "99: Port C, Pin3"]
PORTC_PIN3 = 99 , # [doc = "100: Port C, Pin4"]
PORTC_PIN4 = 100 , # [doc = "101: Port C, Pin5"]
PORTC_PIN5 = 101 , # [doc = "102: Port C, Pin6"]
PORTC_PIN6 = 102 , # [doc = "103: Port C, Pin7"]
PORTC_PIN7 = 103 , # [doc = "104: Port D, Pin0"]
PORTD_PIN0 = 104 , # [doc = "105: Port D, Pin1"]
PORTD_PIN1 = 105 , # [doc = "106: Port D, Pin2"]
PORTD_PIN2 = 106 , # [doc = "107: Port D, Pin3"]
PORTD_PIN3 = 107 , # [doc = "108: Port D, Pin4"]
PORTD_PIN4 = 108 , # [doc = "109: Port D, Pin5"]
PORTD_PIN5 = 109 , # [doc = "110: Port D, Pin6"]
PORTD_PIN6 = 110 , # [doc = "111: Port D, Pin7"]
PORTD_PIN7 = 111 , # [doc = "112: Port E, Pin0"]
PORTE_PIN0 = 112 , # [doc = "113: Port E, Pin1"]
PORTE_PIN1 = 113 , # [doc = "114: Port E, Pin2"]
PORTE_PIN2 = 114 , # [doc = "115: Port E, Pin3"]
PORTE_PIN3 = 115 , # [doc = "116: Port E, Pin4"]
PORTE_PIN4 = 116 , # [doc = "117: Port E, Pin5"]
PORTE_PIN5 = 117 , # [doc = "118: Port E, Pin6"]
PORTE_PIN6 = 118 , # [doc = "119: Port E, Pin7"]
PORTE_PIN7 = 119 , # [doc = "120: Port F, Pin0"]
PORTF_PIN0 = 120 , # [doc = "121: Port F, Pin1"]
PORTF_PIN1 = 121 , # [doc = "122: Port F, Pin2"]
PORTF_PIN2 = 122 , # [doc = "123: Port F, Pin3"]
PORTF_PIN3 = 123 , # [doc = "124: Port F, Pin4"]
PORTF_PIN4 = 124 , # [doc = "125: Port F, Pin5"]
PORTF_PIN5 = 125 , # [doc = "126: Port F, Pin6"]
PORTF_PIN6 = 126 , # [doc = "127: Port F, Pin7"]
PORTF_PIN7 = 127 , # [doc = "128: Prescaler, divide by 1"]
PRESCALER_1 = 128 , # [doc = "129: Prescaler, divide by 2"]
PRESCALER_2 = 129 , # [doc = "130: Prescaler, divide by 4"]
PRESCALER_4 = 130 , # [doc = "131: Prescaler, divide by 8"]
PRESCALER_8 = 131 , # [doc = "132: Prescaler, divide by 16"]
PRESCALER_16 = 132 , # [doc = "133: Prescaler, divide by 32"]
PRESCALER_32 = 133 , # [doc = "134: Prescaler, divide by 64"]
PRESCALER_64 = 134 , # [doc = "135: Prescaler, divide by 128"]
PRESCALER_128 = 135 , # [doc = "136: Prescaler, divide by 256"]
PRESCALER_256 = 136 , # [doc = "137: Prescaler, divide by 512"]
PRESCALER_512 = 137 , # [doc = "138: Prescaler, divide by 1024"]
PRESCALER_1024 = 138 , # [doc = "139: Prescaler, divide by 2048"]
PRESCALER_2048 = 139 , # [doc = "140: Prescaler, divide by 4096"]
PRESCALER_4096 = 140 , # [doc = "141: Prescaler, divide by 8192"]
PRESCALER_8192 = 141 , # [doc = "142: Prescaler, divide by 16384"]
PRESCALER_16384 = 142 , # [doc = "143: Prescaler, divide by 32768"]
PRESCALER_32768 = 143 , # [doc = "192: Timer/Counter C0 Overflow"]
TCC0_OVF = 192 , # [doc = "193: Timer/Counter C0 Error"]
TCC0_ERR = 193 , # [doc = "196: Timer/Counter C0 Compare or Capture A"]
TCC0_CCA = 196 , # [doc = "197: Timer/Counter C0 Compare or Capture B"]
TCC0_CCB = 197 , # [doc = "198: Timer/Counter C0 Compare or Capture C"]
TCC0_CCC = 198 , # [doc = "199: Timer/Counter C0 Compare or Capture D"]
TCC0_CCD = 199 , # [doc = "200: Timer/Counter C1 Overflow"]
TCC1_OVF = 200 , # [doc = "201: Timer/Counter C1 Error"]
TCC1_ERR = 201 , # [doc = "204: Timer/Counter C1 Compare or Capture A"]
TCC1_CCA = 204 , # [doc = "205: Timer/Counter C1 Compare or Capture B"]
TCC1_CCB = 205 , # [doc = "208: Timer/Counter D0 Overflow"]
TCD0_OVF = 208 , # [doc = "209: Timer/Counter D0 Error"]
TCD0_ERR = 209 , # [doc = "212: Timer/Counter D0 Compare or Capture A"]
TCD0_CCA = 212 , # [doc = "213: Timer/Counter D0 Compare or Capture B"]
TCD0_CCB = 213 , # [doc = "214: Timer/Counter D0 Compare or Capture C"]
TCD0_CCC = 214 , # [doc = "215: Timer/Counter D0 Compare or Capture D"]
TCD0_CCD = 215 , # [doc = "216: Timer/Counter D1 Overflow"]
TCD1_OVF = 216 , # [doc = "217: Timer/Counter D1 Error"]
TCD1_ERR = 217 , # [doc = "220: Timer/Counter D1 Compare or Capture A"]
TCD1_CCA = 220 , # [doc = "221: Timer/Counter D1 Compare or Capture B"]
TCD1_CCB = 221 , # [doc = "224: Timer/Counter E0 Overflow"]
TCE0_OVF = 224 , # [doc = "225: Timer/Counter E0 Error"]
TCE0_ERR = 225 , # [doc = "228: Timer/Counter E0 Compare or Capture A"]
TCE0_CCA = 228 , # [doc = "229: Timer/Counter E0 Compare or Capture B"]
TCE0_CCB = 229 , # [doc = "230: Timer/Counter E0 Compare or Capture C"]
TCE0_CCC = 230 , # [doc = "231: Timer/Counter E0 Compare or Capture D"]
TCE0_CCD = 231 , # [doc = "232: Timer/Counter E1 Overflow"]
TCE1_OVF = 232 , # [doc = "233: Timer/Counter E1 Error"]
TCE1_ERR = 233 , # [doc = "236: Timer/Counter E1 Compare or Capture A"]
TCE1_CCA = 236 , # [doc = "237: Timer/Counter E1 Compare or Capture B"]
TCE1_CCB = 237 , # [doc = "240: Timer/Counter F0 Overflow"]
TCF0_OVF = 240 , # [doc = "241: Timer/Counter F0 Error"]
TCF0_ERR = 241 , # [doc = "244: Timer/Counter F0 Compare or Capture A"]
TCF0_CCA = 244 , # [doc = "245: Timer/Counter F0 Compare or Capture B"]
TCF0_CCB = 245 , # [doc = "246: Timer/Counter F0 Compare or Capture C"]
TCF0_CCC = 246 , # [doc = "247: Timer/Counter F0 Compare or Capture D"]
TCF0_CCD = 247 , # [doc = "248: Timer/Counter F1 Overflow"]
TCF1_OVF = 248 , # [doc = "249: Timer/Counter F1 Error"]
TCF1_ERR = 249 , # [doc = "252: Timer/Counter F1 Compare or Capture A"]
TCF1_CCA = 252 , # [doc = "253: Timer/Counter F1 Compare or Capture B"]
TCF1_CCB = 253 , } impl From < CHMUX_A > for u8 { # [inline (always)]
fn from (variant : CHMUX_A) -> Self { variant as _ } } impl CHMUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHMUX_A > { match self . bits { 0 => Some (CHMUX_A :: OFF) , 8 => Some (CHMUX_A :: RTC_OVF) , 9 => Some (CHMUX_A :: RTC_CMP) , 16 => Some (CHMUX_A :: ACA_CH0) , 17 => Some (CHMUX_A :: ACA_CH1) , 18 => Some (CHMUX_A :: ACA_WIN) , 19 => Some (CHMUX_A :: ACB_CH0) , 20 => Some (CHMUX_A :: ACB_CH1) , 21 => Some (CHMUX_A :: ACB_WIN) , 32 => Some (CHMUX_A :: ADCA_CH0) , 33 => Some (CHMUX_A :: ADCA_CH1) , 34 => Some (CHMUX_A :: ADCA_CH2) , 35 => Some (CHMUX_A :: ADCA_CH3) , 36 => Some (CHMUX_A :: ADCB_CH0) , 37 => Some (CHMUX_A :: ADCB_CH1) , 38 => Some (CHMUX_A :: ADCB_CH2) , 39 => Some (CHMUX_A :: ADCB_CH3) , 80 => Some (CHMUX_A :: PORTA_PIN0) , 81 => Some (CHMUX_A :: PORTA_PIN1) , 82 => Some (CHMUX_A :: PORTA_PIN2) , 83 => Some (CHMUX_A :: PORTA_PIN3) , 84 => Some (CHMUX_A :: PORTA_PIN4) , 85 => Some (CHMUX_A :: PORTA_PIN5) , 86 => Some (CHMUX_A :: PORTA_PIN6) , 87 => Some (CHMUX_A :: PORTA_PIN7) , 88 => Some (CHMUX_A :: PORTB_PIN0) , 89 => Some (CHMUX_A :: PORTB_PIN1) , 90 => Some (CHMUX_A :: PORTB_PIN2) , 91 => Some (CHMUX_A :: PORTB_PIN3) , 92 => Some (CHMUX_A :: PORTB_PIN4) , 93 => Some (CHMUX_A :: PORTB_PIN5) , 94 => Some (CHMUX_A :: PORTB_PIN6) , 95 => Some (CHMUX_A :: PORTB_PIN7) , 96 => Some (CHMUX_A :: PORTC_PIN0) , 97 => Some (CHMUX_A :: PORTC_PIN1) , 98 => Some (CHMUX_A :: PORTC_PIN2) , 99 => Some (CHMUX_A :: PORTC_PIN3) , 100 => Some (CHMUX_A :: PORTC_PIN4) , 101 => Some (CHMUX_A :: PORTC_PIN5) , 102 => Some (CHMUX_A :: PORTC_PIN6) , 103 => Some (CHMUX_A :: PORTC_PIN7) , 104 => Some (CHMUX_A :: PORTD_PIN0) , 105 => Some (CHMUX_A :: PORTD_PIN1) , 106 => Some (CHMUX_A :: PORTD_PIN2) , 107 => Some (CHMUX_A :: PORTD_PIN3) , 108 => Some (CHMUX_A :: PORTD_PIN4) , 109 => Some (CHMUX_A :: PORTD_PIN5) , 110 => Some (CHMUX_A :: PORTD_PIN6) , 111 => Some (CHMUX_A :: PORTD_PIN7) , 112 => Some (CHMUX_A :: PORTE_PIN0) , 113 => Some (CHMUX_A :: PORTE_PIN1) , 114 => Some (CHMUX_A :: PORTE_PIN2) , 115 => Some (CHMUX_A :: PORTE_PIN3) , 116 => Some (CHMUX_A :: PORTE_PIN4) , 117 => Some (CHMUX_A :: PORTE_PIN5) , 118 => Some (CHMUX_A :: PORTE_PIN6) , 119 => Some (CHMUX_A :: PORTE_PIN7) , 120 => Some (CHMUX_A :: PORTF_PIN0) , 121 => Some (CHMUX_A :: PORTF_PIN1) , 122 => Some (CHMUX_A :: PORTF_PIN2) , 123 => Some (CHMUX_A :: PORTF_PIN3) , 124 => Some (CHMUX_A :: PORTF_PIN4) , 125 => Some (CHMUX_A :: PORTF_PIN5) , 126 => Some (CHMUX_A :: PORTF_PIN6) , 127 => Some (CHMUX_A :: PORTF_PIN7) , 128 => Some (CHMUX_A :: PRESCALER_1) , 129 => Some (CHMUX_A :: PRESCALER_2) , 130 => Some (CHMUX_A :: PRESCALER_4) , 131 => Some (CHMUX_A :: PRESCALER_8) , 132 => Some (CHMUX_A :: PRESCALER_16) , 133 => Some (CHMUX_A :: PRESCALER_32) , 134 => Some (CHMUX_A :: PRESCALER_64) , 135 => Some (CHMUX_A :: PRESCALER_128) , 136 => Some (CHMUX_A :: PRESCALER_256) , 137 => Some (CHMUX_A :: PRESCALER_512) , 138 => Some (CHMUX_A :: PRESCALER_1024) , 139 => Some (CHMUX_A :: PRESCALER_2048) , 140 => Some (CHMUX_A :: PRESCALER_4096) , 141 => Some (CHMUX_A :: PRESCALER_8192) , 142 => Some (CHMUX_A :: PRESCALER_16384) , 143 => Some (CHMUX_A :: PRESCALER_32768) , 192 => Some (CHMUX_A :: TCC0_OVF) , 193 => Some (CHMUX_A :: TCC0_ERR) , 196 => Some (CHMUX_A :: TCC0_CCA) , 197 => Some (CHMUX_A :: TCC0_CCB) , 198 => Some (CHMUX_A :: TCC0_CCC) , 199 => Some (CHMUX_A :: TCC0_CCD) , 200 => Some (CHMUX_A :: TCC1_OVF) , 201 => Some (CHMUX_A :: TCC1_ERR) , 204 => Some (CHMUX_A :: TCC1_CCA) , 205 => Some (CHMUX_A :: TCC1_CCB) , 208 => Some (CHMUX_A :: TCD0_OVF) , 209 => Some (CHMUX_A :: TCD0_ERR) , 212 => Some (CHMUX_A :: TCD0_CCA) , 213 => Some (CHMUX_A :: TCD0_CCB) , 214 => Some (CHMUX_A :: TCD0_CCC) , 215 => Some (CHMUX_A :: TCD0_CCD) , 216 => Some (CHMUX_A :: TCD1_OVF) , 217 => Some (CHMUX_A :: TCD1_ERR) , 220 => Some (CHMUX_A :: TCD1_CCA) , 221 => Some (CHMUX_A :: TCD1_CCB) , 224 => Some (CHMUX_A :: TCE0_OVF) , 225 => Some (CHMUX_A :: TCE0_ERR) , 228 => Some (CHMUX_A :: TCE0_CCA) , 229 => Some (CHMUX_A :: TCE0_CCB) , 230 => Some (CHMUX_A :: TCE0_CCC) , 231 => Some (CHMUX_A :: TCE0_CCD) , 232 => Some (CHMUX_A :: TCE1_OVF) , 233 => Some (CHMUX_A :: TCE1_ERR) , 236 => Some (CHMUX_A :: TCE1_CCA) , 237 => Some (CHMUX_A :: TCE1_CCB) , 240 => Some (CHMUX_A :: TCF0_OVF) , 241 => Some (CHMUX_A :: TCF0_ERR) , 244 => Some (CHMUX_A :: TCF0_CCA) , 245 => Some (CHMUX_A :: TCF0_CCB) , 246 => Some (CHMUX_A :: TCF0_CCC) , 247 => Some (CHMUX_A :: TCF0_CCD) , 248 => Some (CHMUX_A :: TCF1_OVF) , 249 => Some (CHMUX_A :: TCF1_ERR) , 252 => Some (CHMUX_A :: TCF1_CCA) , 253 => Some (CHMUX_A :: TCF1_CCB) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHMUX_A :: OFF } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == CHMUX_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == CHMUX_A :: RTC_CMP } # [doc = "Checks if the value of the field is `ACA_CH0`"]
# [inline (always)]
pub fn is_aca_ch0 (& self) -> bool { * self == CHMUX_A :: ACA_CH0 } # [doc = "Checks if the value of the field is `ACA_CH1`"]
# [inline (always)]
pub fn is_aca_ch1 (& self) -> bool { * self == CHMUX_A :: ACA_CH1 } # [doc = "Checks if the value of the field is `ACA_WIN`"]
# [inline (always)]
pub fn is_aca_win (& self) -> bool { * self == CHMUX_A :: ACA_WIN } # [doc = "Checks if the value of the field is `ACB_CH0`"]
# [inline (always)]
pub fn is_acb_ch0 (& self) -> bool { * self == CHMUX_A :: ACB_CH0 } # [doc = "Checks if the value of the field is `ACB_CH1`"]
# [inline (always)]
pub fn is_acb_ch1 (& self) -> bool { * self == CHMUX_A :: ACB_CH1 } # [doc = "Checks if the value of the field is `ACB_WIN`"]
# [inline (always)]
pub fn is_acb_win (& self) -> bool { * self == CHMUX_A :: ACB_WIN } # [doc = "Checks if the value of the field is `ADCA_CH0`"]
# [inline (always)]
pub fn is_adca_ch0 (& self) -> bool { * self == CHMUX_A :: ADCA_CH0 } # [doc = "Checks if the value of the field is `ADCA_CH1`"]
# [inline (always)]
pub fn is_adca_ch1 (& self) -> bool { * self == CHMUX_A :: ADCA_CH1 } # [doc = "Checks if the value of the field is `ADCA_CH2`"]
# [inline (always)]
pub fn is_adca_ch2 (& self) -> bool { * self == CHMUX_A :: ADCA_CH2 } # [doc = "Checks if the value of the field is `ADCA_CH3`"]
# [inline (always)]
pub fn is_adca_ch3 (& self) -> bool { * self == CHMUX_A :: ADCA_CH3 } # [doc = "Checks if the value of the field is `ADCB_CH0`"]
# [inline (always)]
pub fn is_adcb_ch0 (& self) -> bool { * self == CHMUX_A :: ADCB_CH0 } # [doc = "Checks if the value of the field is `ADCB_CH1`"]
# [inline (always)]
pub fn is_adcb_ch1 (& self) -> bool { * self == CHMUX_A :: ADCB_CH1 } # [doc = "Checks if the value of the field is `ADCB_CH2`"]
# [inline (always)]
pub fn is_adcb_ch2 (& self) -> bool { * self == CHMUX_A :: ADCB_CH2 } # [doc = "Checks if the value of the field is `ADCB_CH3`"]
# [inline (always)]
pub fn is_adcb_ch3 (& self) -> bool { * self == CHMUX_A :: ADCB_CH3 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN7 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTC_PIN6`"]
# [inline (always)]
pub fn is_portc_pin6 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN6 } # [doc = "Checks if the value of the field is `PORTC_PIN7`"]
# [inline (always)]
pub fn is_portc_pin7 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN7 } # [doc = "Checks if the value of the field is `PORTD_PIN0`"]
# [inline (always)]
pub fn is_portd_pin0 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN0 } # [doc = "Checks if the value of the field is `PORTD_PIN1`"]
# [inline (always)]
pub fn is_portd_pin1 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN1 } # [doc = "Checks if the value of the field is `PORTD_PIN2`"]
# [inline (always)]
pub fn is_portd_pin2 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN2 } # [doc = "Checks if the value of the field is `PORTD_PIN3`"]
# [inline (always)]
pub fn is_portd_pin3 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN3 } # [doc = "Checks if the value of the field is `PORTD_PIN4`"]
# [inline (always)]
pub fn is_portd_pin4 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN4 } # [doc = "Checks if the value of the field is `PORTD_PIN5`"]
# [inline (always)]
pub fn is_portd_pin5 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN5 } # [doc = "Checks if the value of the field is `PORTD_PIN6`"]
# [inline (always)]
pub fn is_portd_pin6 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN6 } # [doc = "Checks if the value of the field is `PORTD_PIN7`"]
# [inline (always)]
pub fn is_portd_pin7 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN7 } # [doc = "Checks if the value of the field is `PORTE_PIN0`"]
# [inline (always)]
pub fn is_porte_pin0 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN0 } # [doc = "Checks if the value of the field is `PORTE_PIN1`"]
# [inline (always)]
pub fn is_porte_pin1 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN1 } # [doc = "Checks if the value of the field is `PORTE_PIN2`"]
# [inline (always)]
pub fn is_porte_pin2 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN2 } # [doc = "Checks if the value of the field is `PORTE_PIN3`"]
# [inline (always)]
pub fn is_porte_pin3 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN3 } # [doc = "Checks if the value of the field is `PORTE_PIN4`"]
# [inline (always)]
pub fn is_porte_pin4 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN4 } # [doc = "Checks if the value of the field is `PORTE_PIN5`"]
# [inline (always)]
pub fn is_porte_pin5 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN5 } # [doc = "Checks if the value of the field is `PORTE_PIN6`"]
# [inline (always)]
pub fn is_porte_pin6 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN6 } # [doc = "Checks if the value of the field is `PORTE_PIN7`"]
# [inline (always)]
pub fn is_porte_pin7 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN7 } # [doc = "Checks if the value of the field is `PORTF_PIN0`"]
# [inline (always)]
pub fn is_portf_pin0 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN0 } # [doc = "Checks if the value of the field is `PORTF_PIN1`"]
# [inline (always)]
pub fn is_portf_pin1 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN1 } # [doc = "Checks if the value of the field is `PORTF_PIN2`"]
# [inline (always)]
pub fn is_portf_pin2 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN2 } # [doc = "Checks if the value of the field is `PORTF_PIN3`"]
# [inline (always)]
pub fn is_portf_pin3 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN3 } # [doc = "Checks if the value of the field is `PORTF_PIN4`"]
# [inline (always)]
pub fn is_portf_pin4 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN4 } # [doc = "Checks if the value of the field is `PORTF_PIN5`"]
# [inline (always)]
pub fn is_portf_pin5 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN5 } # [doc = "Checks if the value of the field is `PORTF_PIN6`"]
# [inline (always)]
pub fn is_portf_pin6 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN6 } # [doc = "Checks if the value of the field is `PORTF_PIN7`"]
# [inline (always)]
pub fn is_portf_pin7 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN7 } # [doc = "Checks if the value of the field is `PRESCALER_1`"]
# [inline (always)]
pub fn is_prescaler_1 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1 } # [doc = "Checks if the value of the field is `PRESCALER_2`"]
# [inline (always)]
pub fn is_prescaler_2 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2 } # [doc = "Checks if the value of the field is `PRESCALER_4`"]
# [inline (always)]
pub fn is_prescaler_4 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4 } # [doc = "Checks if the value of the field is `PRESCALER_8`"]
# [inline (always)]
pub fn is_prescaler_8 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8 } # [doc = "Checks if the value of the field is `PRESCALER_16`"]
# [inline (always)]
pub fn is_prescaler_16 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16 } # [doc = "Checks if the value of the field is `PRESCALER_32`"]
# [inline (always)]
pub fn is_prescaler_32 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32 } # [doc = "Checks if the value of the field is `PRESCALER_64`"]
# [inline (always)]
pub fn is_prescaler_64 (& self) -> bool { * self == CHMUX_A :: PRESCALER_64 } # [doc = "Checks if the value of the field is `PRESCALER_128`"]
# [inline (always)]
pub fn is_prescaler_128 (& self) -> bool { * self == CHMUX_A :: PRESCALER_128 } # [doc = "Checks if the value of the field is `PRESCALER_256`"]
# [inline (always)]
pub fn is_prescaler_256 (& self) -> bool { * self == CHMUX_A :: PRESCALER_256 } # [doc = "Checks if the value of the field is `PRESCALER_512`"]
# [inline (always)]
pub fn is_prescaler_512 (& self) -> bool { * self == CHMUX_A :: PRESCALER_512 } # [doc = "Checks if the value of the field is `PRESCALER_1024`"]
# [inline (always)]
pub fn is_prescaler_1024 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1024 } # [doc = "Checks if the value of the field is `PRESCALER_2048`"]
# [inline (always)]
pub fn is_prescaler_2048 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2048 } # [doc = "Checks if the value of the field is `PRESCALER_4096`"]
# [inline (always)]
pub fn is_prescaler_4096 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4096 } # [doc = "Checks if the value of the field is `PRESCALER_8192`"]
# [inline (always)]
pub fn is_prescaler_8192 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8192 } # [doc = "Checks if the value of the field is `PRESCALER_16384`"]
# [inline (always)]
pub fn is_prescaler_16384 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16384 } # [doc = "Checks if the value of the field is `PRESCALER_32768`"]
# [inline (always)]
pub fn is_prescaler_32768 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32768 } # [doc = "Checks if the value of the field is `TCC0_OVF`"]
# [inline (always)]
pub fn is_tcc0_ovf (& self) -> bool { * self == CHMUX_A :: TCC0_OVF } # [doc = "Checks if the value of the field is `TCC0_ERR`"]
# [inline (always)]
pub fn is_tcc0_err (& self) -> bool { * self == CHMUX_A :: TCC0_ERR } # [doc = "Checks if the value of the field is `TCC0_CCA`"]
# [inline (always)]
pub fn is_tcc0_cca (& self) -> bool { * self == CHMUX_A :: TCC0_CCA } # [doc = "Checks if the value of the field is `TCC0_CCB`"]
# [inline (always)]
pub fn is_tcc0_ccb (& self) -> bool { * self == CHMUX_A :: TCC0_CCB } # [doc = "Checks if the value of the field is `TCC0_CCC`"]
# [inline (always)]
pub fn is_tcc0_ccc (& self) -> bool { * self == CHMUX_A :: TCC0_CCC } # [doc = "Checks if the value of the field is `TCC0_CCD`"]
# [inline (always)]
pub fn is_tcc0_ccd (& self) -> bool { * self == CHMUX_A :: TCC0_CCD } # [doc = "Checks if the value of the field is `TCC1_OVF`"]
# [inline (always)]
pub fn is_tcc1_ovf (& self) -> bool { * self == CHMUX_A :: TCC1_OVF } # [doc = "Checks if the value of the field is `TCC1_ERR`"]
# [inline (always)]
pub fn is_tcc1_err (& self) -> bool { * self == CHMUX_A :: TCC1_ERR } # [doc = "Checks if the value of the field is `TCC1_CCA`"]
# [inline (always)]
pub fn is_tcc1_cca (& self) -> bool { * self == CHMUX_A :: TCC1_CCA } # [doc = "Checks if the value of the field is `TCC1_CCB`"]
# [inline (always)]
pub fn is_tcc1_ccb (& self) -> bool { * self == CHMUX_A :: TCC1_CCB } # [doc = "Checks if the value of the field is `TCD0_OVF`"]
# [inline (always)]
pub fn is_tcd0_ovf (& self) -> bool { * self == CHMUX_A :: TCD0_OVF } # [doc = "Checks if the value of the field is `TCD0_ERR`"]
# [inline (always)]
pub fn is_tcd0_err (& self) -> bool { * self == CHMUX_A :: TCD0_ERR } # [doc = "Checks if the value of the field is `TCD0_CCA`"]
# [inline (always)]
pub fn is_tcd0_cca (& self) -> bool { * self == CHMUX_A :: TCD0_CCA } # [doc = "Checks if the value of the field is `TCD0_CCB`"]
# [inline (always)]
pub fn is_tcd0_ccb (& self) -> bool { * self == CHMUX_A :: TCD0_CCB } # [doc = "Checks if the value of the field is `TCD0_CCC`"]
# [inline (always)]
pub fn is_tcd0_ccc (& self) -> bool { * self == CHMUX_A :: TCD0_CCC } # [doc = "Checks if the value of the field is `TCD0_CCD`"]
# [inline (always)]
pub fn is_tcd0_ccd (& self) -> bool { * self == CHMUX_A :: TCD0_CCD } # [doc = "Checks if the value of the field is `TCD1_OVF`"]
# [inline (always)]
pub fn is_tcd1_ovf (& self) -> bool { * self == CHMUX_A :: TCD1_OVF } # [doc = "Checks if the value of the field is `TCD1_ERR`"]
# [inline (always)]
pub fn is_tcd1_err (& self) -> bool { * self == CHMUX_A :: TCD1_ERR } # [doc = "Checks if the value of the field is `TCD1_CCA`"]
# [inline (always)]
pub fn is_tcd1_cca (& self) -> bool { * self == CHMUX_A :: TCD1_CCA } # [doc = "Checks if the value of the field is `TCD1_CCB`"]
# [inline (always)]
pub fn is_tcd1_ccb (& self) -> bool { * self == CHMUX_A :: TCD1_CCB } # [doc = "Checks if the value of the field is `TCE0_OVF`"]
# [inline (always)]
pub fn is_tce0_ovf (& self) -> bool { * self == CHMUX_A :: TCE0_OVF } # [doc = "Checks if the value of the field is `TCE0_ERR`"]
# [inline (always)]
pub fn is_tce0_err (& self) -> bool { * self == CHMUX_A :: TCE0_ERR } # [doc = "Checks if the value of the field is `TCE0_CCA`"]
# [inline (always)]
pub fn is_tce0_cca (& self) -> bool { * self == CHMUX_A :: TCE0_CCA } # [doc = "Checks if the value of the field is `TCE0_CCB`"]
# [inline (always)]
pub fn is_tce0_ccb (& self) -> bool { * self == CHMUX_A :: TCE0_CCB } # [doc = "Checks if the value of the field is `TCE0_CCC`"]
# [inline (always)]
pub fn is_tce0_ccc (& self) -> bool { * self == CHMUX_A :: TCE0_CCC } # [doc = "Checks if the value of the field is `TCE0_CCD`"]
# [inline (always)]
pub fn is_tce0_ccd (& self) -> bool { * self == CHMUX_A :: TCE0_CCD } # [doc = "Checks if the value of the field is `TCE1_OVF`"]
# [inline (always)]
pub fn is_tce1_ovf (& self) -> bool { * self == CHMUX_A :: TCE1_OVF } # [doc = "Checks if the value of the field is `TCE1_ERR`"]
# [inline (always)]
pub fn is_tce1_err (& self) -> bool { * self == CHMUX_A :: TCE1_ERR } # [doc = "Checks if the value of the field is `TCE1_CCA`"]
# [inline (always)]
pub fn is_tce1_cca (& self) -> bool { * self == CHMUX_A :: TCE1_CCA } # [doc = "Checks if the value of the field is `TCE1_CCB`"]
# [inline (always)]
pub fn is_tce1_ccb (& self) -> bool { * self == CHMUX_A :: TCE1_CCB } # [doc = "Checks if the value of the field is `TCF0_OVF`"]
# [inline (always)]
pub fn is_tcf0_ovf (& self) -> bool { * self == CHMUX_A :: TCF0_OVF } # [doc = "Checks if the value of the field is `TCF0_ERR`"]
# [inline (always)]
pub fn is_tcf0_err (& self) -> bool { * self == CHMUX_A :: TCF0_ERR } # [doc = "Checks if the value of the field is `TCF0_CCA`"]
# [inline (always)]
pub fn is_tcf0_cca (& self) -> bool { * self == CHMUX_A :: TCF0_CCA } # [doc = "Checks if the value of the field is `TCF0_CCB`"]
# [inline (always)]
pub fn is_tcf0_ccb (& self) -> bool { * self == CHMUX_A :: TCF0_CCB } # [doc = "Checks if the value of the field is `TCF0_CCC`"]
# [inline (always)]
pub fn is_tcf0_ccc (& self) -> bool { * self == CHMUX_A :: TCF0_CCC } # [doc = "Checks if the value of the field is `TCF0_CCD`"]
# [inline (always)]
pub fn is_tcf0_ccd (& self) -> bool { * self == CHMUX_A :: TCF0_CCD } # [doc = "Checks if the value of the field is `TCF1_OVF`"]
# [inline (always)]
pub fn is_tcf1_ovf (& self) -> bool { * self == CHMUX_A :: TCF1_OVF } # [doc = "Checks if the value of the field is `TCF1_ERR`"]
# [inline (always)]
pub fn is_tcf1_err (& self) -> bool { * self == CHMUX_A :: TCF1_ERR } # [doc = "Checks if the value of the field is `TCF1_CCA`"]
# [inline (always)]
pub fn is_tcf1_cca (& self) -> bool { * self == CHMUX_A :: TCF1_CCA } # [doc = "Checks if the value of the field is `TCF1_CCB`"]
# [inline (always)]
pub fn is_tcf1_ccb (& self) -> bool { * self == CHMUX_A :: TCF1_CCB } } # [doc = "Field `CHMUX` writer - Event Channel 3 Multiplexer"]
pub type CHMUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CH3MUX_SPEC , u8 , CHMUX_A , 8 , O > ; impl < 'a , const O : u8 > CHMUX_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHMUX_A :: OFF) } # [doc = "RTC Overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_OVF) } # [doc = "RTC Compare Match"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_CMP) } # [doc = "Analog Comparator A Channel 0"]
# [inline (always)]
pub fn aca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH0) } # [doc = "Analog Comparator A Channel 1"]
# [inline (always)]
pub fn aca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH1) } # [doc = "Analog Comparator A Window"]
# [inline (always)]
pub fn aca_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_WIN) } # [doc = "Analog Comparator B Channel 0"]
# [inline (always)]
pub fn acb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH0) } # [doc = "Analog Comparator B Channel 1"]
# [inline (always)]
pub fn acb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH1) } # [doc = "Analog Comparator B Window"]
# [inline (always)]
pub fn acb_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_WIN) } # [doc = "ADC A Channel 0"]
# [inline (always)]
pub fn adca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH0) } # [doc = "ADC A Channel 1"]
# [inline (always)]
pub fn adca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH1) } # [doc = "ADC A Channel 2"]
# [inline (always)]
pub fn adca_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH2) } # [doc = "ADC A Channel 3"]
# [inline (always)]
pub fn adca_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH3) } # [doc = "ADC B Channel 0"]
# [inline (always)]
pub fn adcb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH0) } # [doc = "ADC B Channel 1"]
# [inline (always)]
pub fn adcb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH1) } # [doc = "ADC B Channel 2"]
# [inline (always)]
pub fn adcb_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH2) } # [doc = "ADC B Channel 3"]
# [inline (always)]
pub fn adcb_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH3) } # [doc = "Port A, Pin0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN0) } # [doc = "Port A, Pin1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN1) } # [doc = "Port A, Pin2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN2) } # [doc = "Port A, Pin3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN3) } # [doc = "Port A, Pin4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN4) } # [doc = "Port A, Pin5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN5) } # [doc = "Port A, Pin6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN6) } # [doc = "Port A, Pin7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN7) } # [doc = "Port B, Pin0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN0) } # [doc = "Port B, Pin1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN1) } # [doc = "Port B, Pin2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN2) } # [doc = "Port B, Pin3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN3) } # [doc = "Port B, Pin4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN4) } # [doc = "Port B, Pin5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN5) } # [doc = "Port B, Pin6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN6) } # [doc = "Port B, Pin7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN7) } # [doc = "Port C, Pin0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN0) } # [doc = "Port C, Pin1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN1) } # [doc = "Port C, Pin2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN2) } # [doc = "Port C, Pin3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN3) } # [doc = "Port C, Pin4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN4) } # [doc = "Port C, Pin5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN5) } # [doc = "Port C, Pin6"]
# [inline (always)]
pub fn portc_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN6) } # [doc = "Port C, Pin7"]
# [inline (always)]
pub fn portc_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN7) } # [doc = "Port D, Pin0"]
# [inline (always)]
pub fn portd_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN0) } # [doc = "Port D, Pin1"]
# [inline (always)]
pub fn portd_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN1) } # [doc = "Port D, Pin2"]
# [inline (always)]
pub fn portd_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN2) } # [doc = "Port D, Pin3"]
# [inline (always)]
pub fn portd_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN3) } # [doc = "Port D, Pin4"]
# [inline (always)]
pub fn portd_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN4) } # [doc = "Port D, Pin5"]
# [inline (always)]
pub fn portd_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN5) } # [doc = "Port D, Pin6"]
# [inline (always)]
pub fn portd_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN6) } # [doc = "Port D, Pin7"]
# [inline (always)]
pub fn portd_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN7) } # [doc = "Port E, Pin0"]
# [inline (always)]
pub fn porte_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN0) } # [doc = "Port E, Pin1"]
# [inline (always)]
pub fn porte_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN1) } # [doc = "Port E, Pin2"]
# [inline (always)]
pub fn porte_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN2) } # [doc = "Port E, Pin3"]
# [inline (always)]
pub fn porte_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN3) } # [doc = "Port E, Pin4"]
# [inline (always)]
pub fn porte_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN4) } # [doc = "Port E, Pin5"]
# [inline (always)]
pub fn porte_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN5) } # [doc = "Port E, Pin6"]
# [inline (always)]
pub fn porte_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN6) } # [doc = "Port E, Pin7"]
# [inline (always)]
pub fn porte_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN7) } # [doc = "Port F, Pin0"]
# [inline (always)]
pub fn portf_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN0) } # [doc = "Port F, Pin1"]
# [inline (always)]
pub fn portf_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN1) } # [doc = "Port F, Pin2"]
# [inline (always)]
pub fn portf_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN2) } # [doc = "Port F, Pin3"]
# [inline (always)]
pub fn portf_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN3) } # [doc = "Port F, Pin4"]
# [inline (always)]
pub fn portf_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN4) } # [doc = "Port F, Pin5"]
# [inline (always)]
pub fn portf_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN5) } # [doc = "Port F, Pin6"]
# [inline (always)]
pub fn portf_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN6) } # [doc = "Port F, Pin7"]
# [inline (always)]
pub fn portf_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN7) } # [doc = "Prescaler, divide by 1"]
# [inline (always)]
pub fn prescaler_1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1) } # [doc = "Prescaler, divide by 2"]
# [inline (always)]
pub fn prescaler_2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2) } # [doc = "Prescaler, divide by 4"]
# [inline (always)]
pub fn prescaler_4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4) } # [doc = "Prescaler, divide by 8"]
# [inline (always)]
pub fn prescaler_8 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8) } # [doc = "Prescaler, divide by 16"]
# [inline (always)]
pub fn prescaler_16 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16) } # [doc = "Prescaler, divide by 32"]
# [inline (always)]
pub fn prescaler_32 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32) } # [doc = "Prescaler, divide by 64"]
# [inline (always)]
pub fn prescaler_64 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_64) } # [doc = "Prescaler, divide by 128"]
# [inline (always)]
pub fn prescaler_128 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_128) } # [doc = "Prescaler, divide by 256"]
# [inline (always)]
pub fn prescaler_256 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_256) } # [doc = "Prescaler, divide by 512"]
# [inline (always)]
pub fn prescaler_512 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_512) } # [doc = "Prescaler, divide by 1024"]
# [inline (always)]
pub fn prescaler_1024 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1024) } # [doc = "Prescaler, divide by 2048"]
# [inline (always)]
pub fn prescaler_2048 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2048) } # [doc = "Prescaler, divide by 4096"]
# [inline (always)]
pub fn prescaler_4096 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4096) } # [doc = "Prescaler, divide by 8192"]
# [inline (always)]
pub fn prescaler_8192 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8192) } # [doc = "Prescaler, divide by 16384"]
# [inline (always)]
pub fn prescaler_16384 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16384) } # [doc = "Prescaler, divide by 32768"]
# [inline (always)]
pub fn prescaler_32768 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32768) } # [doc = "Timer/Counter C0 Overflow"]
# [inline (always)]
pub fn tcc0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_OVF) } # [doc = "Timer/Counter C0 Error"]
# [inline (always)]
pub fn tcc0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_ERR) } # [doc = "Timer/Counter C0 Compare or Capture A"]
# [inline (always)]
pub fn tcc0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCA) } # [doc = "Timer/Counter C0 Compare or Capture B"]
# [inline (always)]
pub fn tcc0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCB) } # [doc = "Timer/Counter C0 Compare or Capture C"]
# [inline (always)]
pub fn tcc0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCC) } # [doc = "Timer/Counter C0 Compare or Capture D"]
# [inline (always)]
pub fn tcc0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCD) } # [doc = "Timer/Counter C1 Overflow"]
# [inline (always)]
pub fn tcc1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_OVF) } # [doc = "Timer/Counter C1 Error"]
# [inline (always)]
pub fn tcc1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_ERR) } # [doc = "Timer/Counter C1 Compare or Capture A"]
# [inline (always)]
pub fn tcc1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCA) } # [doc = "Timer/Counter C1 Compare or Capture B"]
# [inline (always)]
pub fn tcc1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCB) } # [doc = "Timer/Counter D0 Overflow"]
# [inline (always)]
pub fn tcd0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_OVF) } # [doc = "Timer/Counter D0 Error"]
# [inline (always)]
pub fn tcd0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_ERR) } # [doc = "Timer/Counter D0 Compare or Capture A"]
# [inline (always)]
pub fn tcd0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCA) } # [doc = "Timer/Counter D0 Compare or Capture B"]
# [inline (always)]
pub fn tcd0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCB) } # [doc = "Timer/Counter D0 Compare or Capture C"]
# [inline (always)]
pub fn tcd0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCC) } # [doc = "Timer/Counter D0 Compare or Capture D"]
# [inline (always)]
pub fn tcd0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCD) } # [doc = "Timer/Counter D1 Overflow"]
# [inline (always)]
pub fn tcd1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_OVF) } # [doc = "Timer/Counter D1 Error"]
# [inline (always)]
pub fn tcd1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_ERR) } # [doc = "Timer/Counter D1 Compare or Capture A"]
# [inline (always)]
pub fn tcd1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCA) } # [doc = "Timer/Counter D1 Compare or Capture B"]
# [inline (always)]
pub fn tcd1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCB) } # [doc = "Timer/Counter E0 Overflow"]
# [inline (always)]
pub fn tce0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_OVF) } # [doc = "Timer/Counter E0 Error"]
# [inline (always)]
pub fn tce0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_ERR) } # [doc = "Timer/Counter E0 Compare or Capture A"]
# [inline (always)]
pub fn tce0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCA) } # [doc = "Timer/Counter E0 Compare or Capture B"]
# [inline (always)]
pub fn tce0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCB) } # [doc = "Timer/Counter E0 Compare or Capture C"]
# [inline (always)]
pub fn tce0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCC) } # [doc = "Timer/Counter E0 Compare or Capture D"]
# [inline (always)]
pub fn tce0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCD) } # [doc = "Timer/Counter E1 Overflow"]
# [inline (always)]
pub fn tce1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_OVF) } # [doc = "Timer/Counter E1 Error"]
# [inline (always)]
pub fn tce1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_ERR) } # [doc = "Timer/Counter E1 Compare or Capture A"]
# [inline (always)]
pub fn tce1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCA) } # [doc = "Timer/Counter E1 Compare or Capture B"]
# [inline (always)]
pub fn tce1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCB) } # [doc = "Timer/Counter F0 Overflow"]
# [inline (always)]
pub fn tcf0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_OVF) } # [doc = "Timer/Counter F0 Error"]
# [inline (always)]
pub fn tcf0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_ERR) } # [doc = "Timer/Counter F0 Compare or Capture A"]
# [inline (always)]
pub fn tcf0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCA) } # [doc = "Timer/Counter F0 Compare or Capture B"]
# [inline (always)]
pub fn tcf0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCB) } # [doc = "Timer/Counter F0 Compare or Capture C"]
# [inline (always)]
pub fn tcf0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCC) } # [doc = "Timer/Counter F0 Compare or Capture D"]
# [inline (always)]
pub fn tcf0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCD) } # [doc = "Timer/Counter F1 Overflow"]
# [inline (always)]
pub fn tcf1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_OVF) } # [doc = "Timer/Counter F1 Error"]
# [inline (always)]
pub fn tcf1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_ERR) } # [doc = "Timer/Counter F1 Compare or Capture A"]
# [inline (always)]
pub fn tcf1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCA) } # [doc = "Timer/Counter F1 Compare or Capture B"]
# [inline (always)]
pub fn tcf1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCB) } } impl R { # [doc = "Bits 0:7 - Event Channel 3 Multiplexer"]
# [inline (always)]
pub fn chmux (& self) -> CHMUX_R { CHMUX_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Event Channel 3 Multiplexer"]
# [inline (always)]
# [must_use]
pub fn chmux (& mut self) -> CHMUX_W < 0 > { CHMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Channel 3 Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch3mux](index.html) module"]
pub struct CH3MUX_SPEC ; impl crate :: RegisterSpec for CH3MUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch3mux::R](R) reader structure"]
impl crate :: Readable for CH3MUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch3mux::W](W) writer structure"]
impl crate :: Writable for CH3MUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH3MUX to value 0"]
impl crate :: Resettable for CH3MUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH4CTRL (rw) register accessor: an alias for `Reg<CH4CTRL_SPEC>`"]
pub type CH4CTRL = crate :: Reg < ch4ctrl :: CH4CTRL_SPEC > ; # [doc = "Channel 4 Control Register"]
pub mod ch4ctrl { # [doc = "Register `CH4CTRL` reader"]
pub struct R (crate :: R < CH4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH4CTRL` writer"]
pub struct W (crate :: W < CH4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIGFILT` reader - Digital Filter"]
pub type DIGFILT_R = crate :: FieldReader < u8 , DIGFILT_A > ; # [doc = "Digital Filter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DIGFILT_A { # [doc = "0: 1 SAMPLE"]
_1SAMPLE = 0 , # [doc = "1: 2 SAMPLES"]
_2SAMPLES = 1 , # [doc = "2: 3 SAMPLES"]
_3SAMPLES = 2 , # [doc = "3: 4 SAMPLES"]
_4SAMPLES = 3 , # [doc = "4: 5 SAMPLES"]
_5SAMPLES = 4 , # [doc = "5: 6 SAMPLES"]
_6SAMPLES = 5 , # [doc = "6: 7 SAMPLES"]
_7SAMPLES = 6 , # [doc = "7: 8 SAMPLES"]
_8SAMPLES = 7 , } impl From < DIGFILT_A > for u8 { # [inline (always)]
fn from (variant : DIGFILT_A) -> Self { variant as _ } } impl DIGFILT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIGFILT_A { match self . bits { 0 => DIGFILT_A :: _1SAMPLE , 1 => DIGFILT_A :: _2SAMPLES , 2 => DIGFILT_A :: _3SAMPLES , 3 => DIGFILT_A :: _4SAMPLES , 4 => DIGFILT_A :: _5SAMPLES , 5 => DIGFILT_A :: _6SAMPLES , 6 => DIGFILT_A :: _7SAMPLES , 7 => DIGFILT_A :: _8SAMPLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1SAMPLE`"]
# [inline (always)]
pub fn is_1sample (& self) -> bool { * self == DIGFILT_A :: _1SAMPLE } # [doc = "Checks if the value of the field is `_2SAMPLES`"]
# [inline (always)]
pub fn is_2samples (& self) -> bool { * self == DIGFILT_A :: _2SAMPLES } # [doc = "Checks if the value of the field is `_3SAMPLES`"]
# [inline (always)]
pub fn is_3samples (& self) -> bool { * self == DIGFILT_A :: _3SAMPLES } # [doc = "Checks if the value of the field is `_4SAMPLES`"]
# [inline (always)]
pub fn is_4samples (& self) -> bool { * self == DIGFILT_A :: _4SAMPLES } # [doc = "Checks if the value of the field is `_5SAMPLES`"]
# [inline (always)]
pub fn is_5samples (& self) -> bool { * self == DIGFILT_A :: _5SAMPLES } # [doc = "Checks if the value of the field is `_6SAMPLES`"]
# [inline (always)]
pub fn is_6samples (& self) -> bool { * self == DIGFILT_A :: _6SAMPLES } # [doc = "Checks if the value of the field is `_7SAMPLES`"]
# [inline (always)]
pub fn is_7samples (& self) -> bool { * self == DIGFILT_A :: _7SAMPLES } # [doc = "Checks if the value of the field is `_8SAMPLES`"]
# [inline (always)]
pub fn is_8samples (& self) -> bool { * self == DIGFILT_A :: _8SAMPLES } } # [doc = "Field `DIGFILT` writer - Digital Filter"]
pub type DIGFILT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH4CTRL_SPEC , u8 , DIGFILT_A , 3 , O > ; impl < 'a , const O : u8 > DIGFILT_W < 'a , O > { # [doc = "1 SAMPLE"]
# [inline (always)]
pub fn _1sample (self) -> & 'a mut W { self . variant (DIGFILT_A :: _1SAMPLE) } # [doc = "2 SAMPLES"]
# [inline (always)]
pub fn _2samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _2SAMPLES) } # [doc = "3 SAMPLES"]
# [inline (always)]
pub fn _3samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _3SAMPLES) } # [doc = "4 SAMPLES"]
# [inline (always)]
pub fn _4samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _4SAMPLES) } # [doc = "5 SAMPLES"]
# [inline (always)]
pub fn _5samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _5SAMPLES) } # [doc = "6 SAMPLES"]
# [inline (always)]
pub fn _6samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _6SAMPLES) } # [doc = "7 SAMPLES"]
# [inline (always)]
pub fn _7samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _7SAMPLES) } # [doc = "8 SAMPLES"]
# [inline (always)]
pub fn _8samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _8SAMPLES) } } # [doc = "Field `QDEN` reader - Quadrature Decoder Enable"]
pub type QDEN_R = crate :: BitReader < bool > ; # [doc = "Field `QDEN` writer - Quadrature Decoder Enable"]
pub type QDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CH4CTRL_SPEC , bool , O > ; # [doc = "Field `QDIEN` reader - Quadrature Decoder Index Enable"]
pub type QDIEN_R = crate :: BitReader < bool > ; # [doc = "Field `QDIEN` writer - Quadrature Decoder Index Enable"]
pub type QDIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CH4CTRL_SPEC , bool , O > ; # [doc = "Field `QDIRM` reader - Quadrature Decoder Index Recognition Mode"]
pub type QDIRM_R = crate :: FieldReader < u8 , QDIRM_A > ; # [doc = "Quadrature Decoder Index Recognition Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum QDIRM_A { # [doc = "0: QDPH0 = 0, QDPH90 = 0"]
_00 = 0 , # [doc = "1: QDPH0 = 0, QDPH90 = 1"]
_01 = 1 , # [doc = "2: QDPH0 = 1, QDPH90 = 0"]
_10 = 2 , # [doc = "3: QDPH0 = 1, QDPH90 = 1"]
_11 = 3 , } impl From < QDIRM_A > for u8 { # [inline (always)]
fn from (variant : QDIRM_A) -> Self { variant as _ } } impl QDIRM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> QDIRM_A { match self . bits { 0 => QDIRM_A :: _00 , 1 => QDIRM_A :: _01 , 2 => QDIRM_A :: _10 , 3 => QDIRM_A :: _11 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_00`"]
# [inline (always)]
pub fn is_00 (& self) -> bool { * self == QDIRM_A :: _00 } # [doc = "Checks if the value of the field is `_01`"]
# [inline (always)]
pub fn is_01 (& self) -> bool { * self == QDIRM_A :: _01 } # [doc = "Checks if the value of the field is `_10`"]
# [inline (always)]
pub fn is_10 (& self) -> bool { * self == QDIRM_A :: _10 } # [doc = "Checks if the value of the field is `_11`"]
# [inline (always)]
pub fn is_11 (& self) -> bool { * self == QDIRM_A :: _11 } } # [doc = "Field `QDIRM` writer - Quadrature Decoder Index Recognition Mode"]
pub type QDIRM_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH4CTRL_SPEC , u8 , QDIRM_A , 2 , O > ; impl < 'a , const O : u8 > QDIRM_W < 'a , O > { # [doc = "QDPH0 = 0, QDPH90 = 0"]
# [inline (always)]
pub fn _00 (self) -> & 'a mut W { self . variant (QDIRM_A :: _00) } # [doc = "QDPH0 = 0, QDPH90 = 1"]
# [inline (always)]
pub fn _01 (self) -> & 'a mut W { self . variant (QDIRM_A :: _01) } # [doc = "QDPH0 = 1, QDPH90 = 0"]
# [inline (always)]
pub fn _10 (self) -> & 'a mut W { self . variant (QDIRM_A :: _10) } # [doc = "QDPH0 = 1, QDPH90 = 1"]
# [inline (always)]
pub fn _11 (self) -> & 'a mut W { self . variant (QDIRM_A :: _11) } } impl R { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
pub fn digfilt (& self) -> DIGFILT_R { DIGFILT_R :: new (self . bits & 7) } # [doc = "Bit 3 - Quadrature Decoder Enable"]
# [inline (always)]
pub fn qden (& self) -> QDEN_R { QDEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Quadrature Decoder Index Enable"]
# [inline (always)]
pub fn qdien (& self) -> QDIEN_R { QDIEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Quadrature Decoder Index Recognition Mode"]
# [inline (always)]
pub fn qdirm (& self) -> QDIRM_R { QDIRM_R :: new ((self . bits >> 5) & 3) } } impl W { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
# [must_use]
pub fn digfilt (& mut self) -> DIGFILT_W < 0 > { DIGFILT_W :: new (self) } # [doc = "Bit 3 - Quadrature Decoder Enable"]
# [inline (always)]
# [must_use]
pub fn qden (& mut self) -> QDEN_W < 3 > { QDEN_W :: new (self) } # [doc = "Bit 4 - Quadrature Decoder Index Enable"]
# [inline (always)]
# [must_use]
pub fn qdien (& mut self) -> QDIEN_W < 4 > { QDIEN_W :: new (self) } # [doc = "Bits 5:6 - Quadrature Decoder Index Recognition Mode"]
# [inline (always)]
# [must_use]
pub fn qdirm (& mut self) -> QDIRM_W < 5 > { QDIRM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch4ctrl](index.html) module"]
pub struct CH4CTRL_SPEC ; impl crate :: RegisterSpec for CH4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch4ctrl::R](R) reader structure"]
impl crate :: Readable for CH4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch4ctrl::W](W) writer structure"]
impl crate :: Writable for CH4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH4CTRL to value 0"]
impl crate :: Resettable for CH4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH4MUX (rw) register accessor: an alias for `Reg<CH4MUX_SPEC>`"]
pub type CH4MUX = crate :: Reg < ch4mux :: CH4MUX_SPEC > ; # [doc = "Event Channel 4 Multiplexer"]
pub mod ch4mux { # [doc = "Register `CH4MUX` reader"]
pub struct R (crate :: R < CH4MUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH4MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH4MUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH4MUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH4MUX` writer"]
pub struct W (crate :: W < CH4MUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH4MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH4MUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH4MUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHMUX` reader - Event Channel 4 Multiplexer"]
pub type CHMUX_R = crate :: FieldReader < u8 , CHMUX_A > ; # [doc = "Event Channel 4 Multiplexer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHMUX_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "8: RTC Overflow"]
RTC_OVF = 8 , # [doc = "9: RTC Compare Match"]
RTC_CMP = 9 , # [doc = "16: Analog Comparator A Channel 0"]
ACA_CH0 = 16 , # [doc = "17: Analog Comparator A Channel 1"]
ACA_CH1 = 17 , # [doc = "18: Analog Comparator A Window"]
ACA_WIN = 18 , # [doc = "19: Analog Comparator B Channel 0"]
ACB_CH0 = 19 , # [doc = "20: Analog Comparator B Channel 1"]
ACB_CH1 = 20 , # [doc = "21: Analog Comparator B Window"]
ACB_WIN = 21 , # [doc = "32: ADC A Channel 0"]
ADCA_CH0 = 32 , # [doc = "33: ADC A Channel 1"]
ADCA_CH1 = 33 , # [doc = "34: ADC A Channel 2"]
ADCA_CH2 = 34 , # [doc = "35: ADC A Channel 3"]
ADCA_CH3 = 35 , # [doc = "36: ADC B Channel 0"]
ADCB_CH0 = 36 , # [doc = "37: ADC B Channel 1"]
ADCB_CH1 = 37 , # [doc = "38: ADC B Channel 2"]
ADCB_CH2 = 38 , # [doc = "39: ADC B Channel 3"]
ADCB_CH3 = 39 , # [doc = "80: Port A, Pin0"]
PORTA_PIN0 = 80 , # [doc = "81: Port A, Pin1"]
PORTA_PIN1 = 81 , # [doc = "82: Port A, Pin2"]
PORTA_PIN2 = 82 , # [doc = "83: Port A, Pin3"]
PORTA_PIN3 = 83 , # [doc = "84: Port A, Pin4"]
PORTA_PIN4 = 84 , # [doc = "85: Port A, Pin5"]
PORTA_PIN5 = 85 , # [doc = "86: Port A, Pin6"]
PORTA_PIN6 = 86 , # [doc = "87: Port A, Pin7"]
PORTA_PIN7 = 87 , # [doc = "88: Port B, Pin0"]
PORTB_PIN0 = 88 , # [doc = "89: Port B, Pin1"]
PORTB_PIN1 = 89 , # [doc = "90: Port B, Pin2"]
PORTB_PIN2 = 90 , # [doc = "91: Port B, Pin3"]
PORTB_PIN3 = 91 , # [doc = "92: Port B, Pin4"]
PORTB_PIN4 = 92 , # [doc = "93: Port B, Pin5"]
PORTB_PIN5 = 93 , # [doc = "94: Port B, Pin6"]
PORTB_PIN6 = 94 , # [doc = "95: Port B, Pin7"]
PORTB_PIN7 = 95 , # [doc = "96: Port C, Pin0"]
PORTC_PIN0 = 96 , # [doc = "97: Port C, Pin1"]
PORTC_PIN1 = 97 , # [doc = "98: Port C, Pin2"]
PORTC_PIN2 = 98 , # [doc = "99: Port C, Pin3"]
PORTC_PIN3 = 99 , # [doc = "100: Port C, Pin4"]
PORTC_PIN4 = 100 , # [doc = "101: Port C, Pin5"]
PORTC_PIN5 = 101 , # [doc = "102: Port C, Pin6"]
PORTC_PIN6 = 102 , # [doc = "103: Port C, Pin7"]
PORTC_PIN7 = 103 , # [doc = "104: Port D, Pin0"]
PORTD_PIN0 = 104 , # [doc = "105: Port D, Pin1"]
PORTD_PIN1 = 105 , # [doc = "106: Port D, Pin2"]
PORTD_PIN2 = 106 , # [doc = "107: Port D, Pin3"]
PORTD_PIN3 = 107 , # [doc = "108: Port D, Pin4"]
PORTD_PIN4 = 108 , # [doc = "109: Port D, Pin5"]
PORTD_PIN5 = 109 , # [doc = "110: Port D, Pin6"]
PORTD_PIN6 = 110 , # [doc = "111: Port D, Pin7"]
PORTD_PIN7 = 111 , # [doc = "112: Port E, Pin0"]
PORTE_PIN0 = 112 , # [doc = "113: Port E, Pin1"]
PORTE_PIN1 = 113 , # [doc = "114: Port E, Pin2"]
PORTE_PIN2 = 114 , # [doc = "115: Port E, Pin3"]
PORTE_PIN3 = 115 , # [doc = "116: Port E, Pin4"]
PORTE_PIN4 = 116 , # [doc = "117: Port E, Pin5"]
PORTE_PIN5 = 117 , # [doc = "118: Port E, Pin6"]
PORTE_PIN6 = 118 , # [doc = "119: Port E, Pin7"]
PORTE_PIN7 = 119 , # [doc = "120: Port F, Pin0"]
PORTF_PIN0 = 120 , # [doc = "121: Port F, Pin1"]
PORTF_PIN1 = 121 , # [doc = "122: Port F, Pin2"]
PORTF_PIN2 = 122 , # [doc = "123: Port F, Pin3"]
PORTF_PIN3 = 123 , # [doc = "124: Port F, Pin4"]
PORTF_PIN4 = 124 , # [doc = "125: Port F, Pin5"]
PORTF_PIN5 = 125 , # [doc = "126: Port F, Pin6"]
PORTF_PIN6 = 126 , # [doc = "127: Port F, Pin7"]
PORTF_PIN7 = 127 , # [doc = "128: Prescaler, divide by 1"]
PRESCALER_1 = 128 , # [doc = "129: Prescaler, divide by 2"]
PRESCALER_2 = 129 , # [doc = "130: Prescaler, divide by 4"]
PRESCALER_4 = 130 , # [doc = "131: Prescaler, divide by 8"]
PRESCALER_8 = 131 , # [doc = "132: Prescaler, divide by 16"]
PRESCALER_16 = 132 , # [doc = "133: Prescaler, divide by 32"]
PRESCALER_32 = 133 , # [doc = "134: Prescaler, divide by 64"]
PRESCALER_64 = 134 , # [doc = "135: Prescaler, divide by 128"]
PRESCALER_128 = 135 , # [doc = "136: Prescaler, divide by 256"]
PRESCALER_256 = 136 , # [doc = "137: Prescaler, divide by 512"]
PRESCALER_512 = 137 , # [doc = "138: Prescaler, divide by 1024"]
PRESCALER_1024 = 138 , # [doc = "139: Prescaler, divide by 2048"]
PRESCALER_2048 = 139 , # [doc = "140: Prescaler, divide by 4096"]
PRESCALER_4096 = 140 , # [doc = "141: Prescaler, divide by 8192"]
PRESCALER_8192 = 141 , # [doc = "142: Prescaler, divide by 16384"]
PRESCALER_16384 = 142 , # [doc = "143: Prescaler, divide by 32768"]
PRESCALER_32768 = 143 , # [doc = "192: Timer/Counter C0 Overflow"]
TCC0_OVF = 192 , # [doc = "193: Timer/Counter C0 Error"]
TCC0_ERR = 193 , # [doc = "196: Timer/Counter C0 Compare or Capture A"]
TCC0_CCA = 196 , # [doc = "197: Timer/Counter C0 Compare or Capture B"]
TCC0_CCB = 197 , # [doc = "198: Timer/Counter C0 Compare or Capture C"]
TCC0_CCC = 198 , # [doc = "199: Timer/Counter C0 Compare or Capture D"]
TCC0_CCD = 199 , # [doc = "200: Timer/Counter C1 Overflow"]
TCC1_OVF = 200 , # [doc = "201: Timer/Counter C1 Error"]
TCC1_ERR = 201 , # [doc = "204: Timer/Counter C1 Compare or Capture A"]
TCC1_CCA = 204 , # [doc = "205: Timer/Counter C1 Compare or Capture B"]
TCC1_CCB = 205 , # [doc = "208: Timer/Counter D0 Overflow"]
TCD0_OVF = 208 , # [doc = "209: Timer/Counter D0 Error"]
TCD0_ERR = 209 , # [doc = "212: Timer/Counter D0 Compare or Capture A"]
TCD0_CCA = 212 , # [doc = "213: Timer/Counter D0 Compare or Capture B"]
TCD0_CCB = 213 , # [doc = "214: Timer/Counter D0 Compare or Capture C"]
TCD0_CCC = 214 , # [doc = "215: Timer/Counter D0 Compare or Capture D"]
TCD0_CCD = 215 , # [doc = "216: Timer/Counter D1 Overflow"]
TCD1_OVF = 216 , # [doc = "217: Timer/Counter D1 Error"]
TCD1_ERR = 217 , # [doc = "220: Timer/Counter D1 Compare or Capture A"]
TCD1_CCA = 220 , # [doc = "221: Timer/Counter D1 Compare or Capture B"]
TCD1_CCB = 221 , # [doc = "224: Timer/Counter E0 Overflow"]
TCE0_OVF = 224 , # [doc = "225: Timer/Counter E0 Error"]
TCE0_ERR = 225 , # [doc = "228: Timer/Counter E0 Compare or Capture A"]
TCE0_CCA = 228 , # [doc = "229: Timer/Counter E0 Compare or Capture B"]
TCE0_CCB = 229 , # [doc = "230: Timer/Counter E0 Compare or Capture C"]
TCE0_CCC = 230 , # [doc = "231: Timer/Counter E0 Compare or Capture D"]
TCE0_CCD = 231 , # [doc = "232: Timer/Counter E1 Overflow"]
TCE1_OVF = 232 , # [doc = "233: Timer/Counter E1 Error"]
TCE1_ERR = 233 , # [doc = "236: Timer/Counter E1 Compare or Capture A"]
TCE1_CCA = 236 , # [doc = "237: Timer/Counter E1 Compare or Capture B"]
TCE1_CCB = 237 , # [doc = "240: Timer/Counter F0 Overflow"]
TCF0_OVF = 240 , # [doc = "241: Timer/Counter F0 Error"]
TCF0_ERR = 241 , # [doc = "244: Timer/Counter F0 Compare or Capture A"]
TCF0_CCA = 244 , # [doc = "245: Timer/Counter F0 Compare or Capture B"]
TCF0_CCB = 245 , # [doc = "246: Timer/Counter F0 Compare or Capture C"]
TCF0_CCC = 246 , # [doc = "247: Timer/Counter F0 Compare or Capture D"]
TCF0_CCD = 247 , # [doc = "248: Timer/Counter F1 Overflow"]
TCF1_OVF = 248 , # [doc = "249: Timer/Counter F1 Error"]
TCF1_ERR = 249 , # [doc = "252: Timer/Counter F1 Compare or Capture A"]
TCF1_CCA = 252 , # [doc = "253: Timer/Counter F1 Compare or Capture B"]
TCF1_CCB = 253 , } impl From < CHMUX_A > for u8 { # [inline (always)]
fn from (variant : CHMUX_A) -> Self { variant as _ } } impl CHMUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHMUX_A > { match self . bits { 0 => Some (CHMUX_A :: OFF) , 8 => Some (CHMUX_A :: RTC_OVF) , 9 => Some (CHMUX_A :: RTC_CMP) , 16 => Some (CHMUX_A :: ACA_CH0) , 17 => Some (CHMUX_A :: ACA_CH1) , 18 => Some (CHMUX_A :: ACA_WIN) , 19 => Some (CHMUX_A :: ACB_CH0) , 20 => Some (CHMUX_A :: ACB_CH1) , 21 => Some (CHMUX_A :: ACB_WIN) , 32 => Some (CHMUX_A :: ADCA_CH0) , 33 => Some (CHMUX_A :: ADCA_CH1) , 34 => Some (CHMUX_A :: ADCA_CH2) , 35 => Some (CHMUX_A :: ADCA_CH3) , 36 => Some (CHMUX_A :: ADCB_CH0) , 37 => Some (CHMUX_A :: ADCB_CH1) , 38 => Some (CHMUX_A :: ADCB_CH2) , 39 => Some (CHMUX_A :: ADCB_CH3) , 80 => Some (CHMUX_A :: PORTA_PIN0) , 81 => Some (CHMUX_A :: PORTA_PIN1) , 82 => Some (CHMUX_A :: PORTA_PIN2) , 83 => Some (CHMUX_A :: PORTA_PIN3) , 84 => Some (CHMUX_A :: PORTA_PIN4) , 85 => Some (CHMUX_A :: PORTA_PIN5) , 86 => Some (CHMUX_A :: PORTA_PIN6) , 87 => Some (CHMUX_A :: PORTA_PIN7) , 88 => Some (CHMUX_A :: PORTB_PIN0) , 89 => Some (CHMUX_A :: PORTB_PIN1) , 90 => Some (CHMUX_A :: PORTB_PIN2) , 91 => Some (CHMUX_A :: PORTB_PIN3) , 92 => Some (CHMUX_A :: PORTB_PIN4) , 93 => Some (CHMUX_A :: PORTB_PIN5) , 94 => Some (CHMUX_A :: PORTB_PIN6) , 95 => Some (CHMUX_A :: PORTB_PIN7) , 96 => Some (CHMUX_A :: PORTC_PIN0) , 97 => Some (CHMUX_A :: PORTC_PIN1) , 98 => Some (CHMUX_A :: PORTC_PIN2) , 99 => Some (CHMUX_A :: PORTC_PIN3) , 100 => Some (CHMUX_A :: PORTC_PIN4) , 101 => Some (CHMUX_A :: PORTC_PIN5) , 102 => Some (CHMUX_A :: PORTC_PIN6) , 103 => Some (CHMUX_A :: PORTC_PIN7) , 104 => Some (CHMUX_A :: PORTD_PIN0) , 105 => Some (CHMUX_A :: PORTD_PIN1) , 106 => Some (CHMUX_A :: PORTD_PIN2) , 107 => Some (CHMUX_A :: PORTD_PIN3) , 108 => Some (CHMUX_A :: PORTD_PIN4) , 109 => Some (CHMUX_A :: PORTD_PIN5) , 110 => Some (CHMUX_A :: PORTD_PIN6) , 111 => Some (CHMUX_A :: PORTD_PIN7) , 112 => Some (CHMUX_A :: PORTE_PIN0) , 113 => Some (CHMUX_A :: PORTE_PIN1) , 114 => Some (CHMUX_A :: PORTE_PIN2) , 115 => Some (CHMUX_A :: PORTE_PIN3) , 116 => Some (CHMUX_A :: PORTE_PIN4) , 117 => Some (CHMUX_A :: PORTE_PIN5) , 118 => Some (CHMUX_A :: PORTE_PIN6) , 119 => Some (CHMUX_A :: PORTE_PIN7) , 120 => Some (CHMUX_A :: PORTF_PIN0) , 121 => Some (CHMUX_A :: PORTF_PIN1) , 122 => Some (CHMUX_A :: PORTF_PIN2) , 123 => Some (CHMUX_A :: PORTF_PIN3) , 124 => Some (CHMUX_A :: PORTF_PIN4) , 125 => Some (CHMUX_A :: PORTF_PIN5) , 126 => Some (CHMUX_A :: PORTF_PIN6) , 127 => Some (CHMUX_A :: PORTF_PIN7) , 128 => Some (CHMUX_A :: PRESCALER_1) , 129 => Some (CHMUX_A :: PRESCALER_2) , 130 => Some (CHMUX_A :: PRESCALER_4) , 131 => Some (CHMUX_A :: PRESCALER_8) , 132 => Some (CHMUX_A :: PRESCALER_16) , 133 => Some (CHMUX_A :: PRESCALER_32) , 134 => Some (CHMUX_A :: PRESCALER_64) , 135 => Some (CHMUX_A :: PRESCALER_128) , 136 => Some (CHMUX_A :: PRESCALER_256) , 137 => Some (CHMUX_A :: PRESCALER_512) , 138 => Some (CHMUX_A :: PRESCALER_1024) , 139 => Some (CHMUX_A :: PRESCALER_2048) , 140 => Some (CHMUX_A :: PRESCALER_4096) , 141 => Some (CHMUX_A :: PRESCALER_8192) , 142 => Some (CHMUX_A :: PRESCALER_16384) , 143 => Some (CHMUX_A :: PRESCALER_32768) , 192 => Some (CHMUX_A :: TCC0_OVF) , 193 => Some (CHMUX_A :: TCC0_ERR) , 196 => Some (CHMUX_A :: TCC0_CCA) , 197 => Some (CHMUX_A :: TCC0_CCB) , 198 => Some (CHMUX_A :: TCC0_CCC) , 199 => Some (CHMUX_A :: TCC0_CCD) , 200 => Some (CHMUX_A :: TCC1_OVF) , 201 => Some (CHMUX_A :: TCC1_ERR) , 204 => Some (CHMUX_A :: TCC1_CCA) , 205 => Some (CHMUX_A :: TCC1_CCB) , 208 => Some (CHMUX_A :: TCD0_OVF) , 209 => Some (CHMUX_A :: TCD0_ERR) , 212 => Some (CHMUX_A :: TCD0_CCA) , 213 => Some (CHMUX_A :: TCD0_CCB) , 214 => Some (CHMUX_A :: TCD0_CCC) , 215 => Some (CHMUX_A :: TCD0_CCD) , 216 => Some (CHMUX_A :: TCD1_OVF) , 217 => Some (CHMUX_A :: TCD1_ERR) , 220 => Some (CHMUX_A :: TCD1_CCA) , 221 => Some (CHMUX_A :: TCD1_CCB) , 224 => Some (CHMUX_A :: TCE0_OVF) , 225 => Some (CHMUX_A :: TCE0_ERR) , 228 => Some (CHMUX_A :: TCE0_CCA) , 229 => Some (CHMUX_A :: TCE0_CCB) , 230 => Some (CHMUX_A :: TCE0_CCC) , 231 => Some (CHMUX_A :: TCE0_CCD) , 232 => Some (CHMUX_A :: TCE1_OVF) , 233 => Some (CHMUX_A :: TCE1_ERR) , 236 => Some (CHMUX_A :: TCE1_CCA) , 237 => Some (CHMUX_A :: TCE1_CCB) , 240 => Some (CHMUX_A :: TCF0_OVF) , 241 => Some (CHMUX_A :: TCF0_ERR) , 244 => Some (CHMUX_A :: TCF0_CCA) , 245 => Some (CHMUX_A :: TCF0_CCB) , 246 => Some (CHMUX_A :: TCF0_CCC) , 247 => Some (CHMUX_A :: TCF0_CCD) , 248 => Some (CHMUX_A :: TCF1_OVF) , 249 => Some (CHMUX_A :: TCF1_ERR) , 252 => Some (CHMUX_A :: TCF1_CCA) , 253 => Some (CHMUX_A :: TCF1_CCB) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHMUX_A :: OFF } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == CHMUX_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == CHMUX_A :: RTC_CMP } # [doc = "Checks if the value of the field is `ACA_CH0`"]
# [inline (always)]
pub fn is_aca_ch0 (& self) -> bool { * self == CHMUX_A :: ACA_CH0 } # [doc = "Checks if the value of the field is `ACA_CH1`"]
# [inline (always)]
pub fn is_aca_ch1 (& self) -> bool { * self == CHMUX_A :: ACA_CH1 } # [doc = "Checks if the value of the field is `ACA_WIN`"]
# [inline (always)]
pub fn is_aca_win (& self) -> bool { * self == CHMUX_A :: ACA_WIN } # [doc = "Checks if the value of the field is `ACB_CH0`"]
# [inline (always)]
pub fn is_acb_ch0 (& self) -> bool { * self == CHMUX_A :: ACB_CH0 } # [doc = "Checks if the value of the field is `ACB_CH1`"]
# [inline (always)]
pub fn is_acb_ch1 (& self) -> bool { * self == CHMUX_A :: ACB_CH1 } # [doc = "Checks if the value of the field is `ACB_WIN`"]
# [inline (always)]
pub fn is_acb_win (& self) -> bool { * self == CHMUX_A :: ACB_WIN } # [doc = "Checks if the value of the field is `ADCA_CH0`"]
# [inline (always)]
pub fn is_adca_ch0 (& self) -> bool { * self == CHMUX_A :: ADCA_CH0 } # [doc = "Checks if the value of the field is `ADCA_CH1`"]
# [inline (always)]
pub fn is_adca_ch1 (& self) -> bool { * self == CHMUX_A :: ADCA_CH1 } # [doc = "Checks if the value of the field is `ADCA_CH2`"]
# [inline (always)]
pub fn is_adca_ch2 (& self) -> bool { * self == CHMUX_A :: ADCA_CH2 } # [doc = "Checks if the value of the field is `ADCA_CH3`"]
# [inline (always)]
pub fn is_adca_ch3 (& self) -> bool { * self == CHMUX_A :: ADCA_CH3 } # [doc = "Checks if the value of the field is `ADCB_CH0`"]
# [inline (always)]
pub fn is_adcb_ch0 (& self) -> bool { * self == CHMUX_A :: ADCB_CH0 } # [doc = "Checks if the value of the field is `ADCB_CH1`"]
# [inline (always)]
pub fn is_adcb_ch1 (& self) -> bool { * self == CHMUX_A :: ADCB_CH1 } # [doc = "Checks if the value of the field is `ADCB_CH2`"]
# [inline (always)]
pub fn is_adcb_ch2 (& self) -> bool { * self == CHMUX_A :: ADCB_CH2 } # [doc = "Checks if the value of the field is `ADCB_CH3`"]
# [inline (always)]
pub fn is_adcb_ch3 (& self) -> bool { * self == CHMUX_A :: ADCB_CH3 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN7 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTC_PIN6`"]
# [inline (always)]
pub fn is_portc_pin6 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN6 } # [doc = "Checks if the value of the field is `PORTC_PIN7`"]
# [inline (always)]
pub fn is_portc_pin7 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN7 } # [doc = "Checks if the value of the field is `PORTD_PIN0`"]
# [inline (always)]
pub fn is_portd_pin0 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN0 } # [doc = "Checks if the value of the field is `PORTD_PIN1`"]
# [inline (always)]
pub fn is_portd_pin1 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN1 } # [doc = "Checks if the value of the field is `PORTD_PIN2`"]
# [inline (always)]
pub fn is_portd_pin2 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN2 } # [doc = "Checks if the value of the field is `PORTD_PIN3`"]
# [inline (always)]
pub fn is_portd_pin3 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN3 } # [doc = "Checks if the value of the field is `PORTD_PIN4`"]
# [inline (always)]
pub fn is_portd_pin4 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN4 } # [doc = "Checks if the value of the field is `PORTD_PIN5`"]
# [inline (always)]
pub fn is_portd_pin5 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN5 } # [doc = "Checks if the value of the field is `PORTD_PIN6`"]
# [inline (always)]
pub fn is_portd_pin6 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN6 } # [doc = "Checks if the value of the field is `PORTD_PIN7`"]
# [inline (always)]
pub fn is_portd_pin7 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN7 } # [doc = "Checks if the value of the field is `PORTE_PIN0`"]
# [inline (always)]
pub fn is_porte_pin0 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN0 } # [doc = "Checks if the value of the field is `PORTE_PIN1`"]
# [inline (always)]
pub fn is_porte_pin1 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN1 } # [doc = "Checks if the value of the field is `PORTE_PIN2`"]
# [inline (always)]
pub fn is_porte_pin2 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN2 } # [doc = "Checks if the value of the field is `PORTE_PIN3`"]
# [inline (always)]
pub fn is_porte_pin3 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN3 } # [doc = "Checks if the value of the field is `PORTE_PIN4`"]
# [inline (always)]
pub fn is_porte_pin4 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN4 } # [doc = "Checks if the value of the field is `PORTE_PIN5`"]
# [inline (always)]
pub fn is_porte_pin5 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN5 } # [doc = "Checks if the value of the field is `PORTE_PIN6`"]
# [inline (always)]
pub fn is_porte_pin6 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN6 } # [doc = "Checks if the value of the field is `PORTE_PIN7`"]
# [inline (always)]
pub fn is_porte_pin7 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN7 } # [doc = "Checks if the value of the field is `PORTF_PIN0`"]
# [inline (always)]
pub fn is_portf_pin0 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN0 } # [doc = "Checks if the value of the field is `PORTF_PIN1`"]
# [inline (always)]
pub fn is_portf_pin1 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN1 } # [doc = "Checks if the value of the field is `PORTF_PIN2`"]
# [inline (always)]
pub fn is_portf_pin2 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN2 } # [doc = "Checks if the value of the field is `PORTF_PIN3`"]
# [inline (always)]
pub fn is_portf_pin3 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN3 } # [doc = "Checks if the value of the field is `PORTF_PIN4`"]
# [inline (always)]
pub fn is_portf_pin4 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN4 } # [doc = "Checks if the value of the field is `PORTF_PIN5`"]
# [inline (always)]
pub fn is_portf_pin5 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN5 } # [doc = "Checks if the value of the field is `PORTF_PIN6`"]
# [inline (always)]
pub fn is_portf_pin6 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN6 } # [doc = "Checks if the value of the field is `PORTF_PIN7`"]
# [inline (always)]
pub fn is_portf_pin7 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN7 } # [doc = "Checks if the value of the field is `PRESCALER_1`"]
# [inline (always)]
pub fn is_prescaler_1 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1 } # [doc = "Checks if the value of the field is `PRESCALER_2`"]
# [inline (always)]
pub fn is_prescaler_2 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2 } # [doc = "Checks if the value of the field is `PRESCALER_4`"]
# [inline (always)]
pub fn is_prescaler_4 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4 } # [doc = "Checks if the value of the field is `PRESCALER_8`"]
# [inline (always)]
pub fn is_prescaler_8 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8 } # [doc = "Checks if the value of the field is `PRESCALER_16`"]
# [inline (always)]
pub fn is_prescaler_16 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16 } # [doc = "Checks if the value of the field is `PRESCALER_32`"]
# [inline (always)]
pub fn is_prescaler_32 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32 } # [doc = "Checks if the value of the field is `PRESCALER_64`"]
# [inline (always)]
pub fn is_prescaler_64 (& self) -> bool { * self == CHMUX_A :: PRESCALER_64 } # [doc = "Checks if the value of the field is `PRESCALER_128`"]
# [inline (always)]
pub fn is_prescaler_128 (& self) -> bool { * self == CHMUX_A :: PRESCALER_128 } # [doc = "Checks if the value of the field is `PRESCALER_256`"]
# [inline (always)]
pub fn is_prescaler_256 (& self) -> bool { * self == CHMUX_A :: PRESCALER_256 } # [doc = "Checks if the value of the field is `PRESCALER_512`"]
# [inline (always)]
pub fn is_prescaler_512 (& self) -> bool { * self == CHMUX_A :: PRESCALER_512 } # [doc = "Checks if the value of the field is `PRESCALER_1024`"]
# [inline (always)]
pub fn is_prescaler_1024 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1024 } # [doc = "Checks if the value of the field is `PRESCALER_2048`"]
# [inline (always)]
pub fn is_prescaler_2048 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2048 } # [doc = "Checks if the value of the field is `PRESCALER_4096`"]
# [inline (always)]
pub fn is_prescaler_4096 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4096 } # [doc = "Checks if the value of the field is `PRESCALER_8192`"]
# [inline (always)]
pub fn is_prescaler_8192 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8192 } # [doc = "Checks if the value of the field is `PRESCALER_16384`"]
# [inline (always)]
pub fn is_prescaler_16384 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16384 } # [doc = "Checks if the value of the field is `PRESCALER_32768`"]
# [inline (always)]
pub fn is_prescaler_32768 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32768 } # [doc = "Checks if the value of the field is `TCC0_OVF`"]
# [inline (always)]
pub fn is_tcc0_ovf (& self) -> bool { * self == CHMUX_A :: TCC0_OVF } # [doc = "Checks if the value of the field is `TCC0_ERR`"]
# [inline (always)]
pub fn is_tcc0_err (& self) -> bool { * self == CHMUX_A :: TCC0_ERR } # [doc = "Checks if the value of the field is `TCC0_CCA`"]
# [inline (always)]
pub fn is_tcc0_cca (& self) -> bool { * self == CHMUX_A :: TCC0_CCA } # [doc = "Checks if the value of the field is `TCC0_CCB`"]
# [inline (always)]
pub fn is_tcc0_ccb (& self) -> bool { * self == CHMUX_A :: TCC0_CCB } # [doc = "Checks if the value of the field is `TCC0_CCC`"]
# [inline (always)]
pub fn is_tcc0_ccc (& self) -> bool { * self == CHMUX_A :: TCC0_CCC } # [doc = "Checks if the value of the field is `TCC0_CCD`"]
# [inline (always)]
pub fn is_tcc0_ccd (& self) -> bool { * self == CHMUX_A :: TCC0_CCD } # [doc = "Checks if the value of the field is `TCC1_OVF`"]
# [inline (always)]
pub fn is_tcc1_ovf (& self) -> bool { * self == CHMUX_A :: TCC1_OVF } # [doc = "Checks if the value of the field is `TCC1_ERR`"]
# [inline (always)]
pub fn is_tcc1_err (& self) -> bool { * self == CHMUX_A :: TCC1_ERR } # [doc = "Checks if the value of the field is `TCC1_CCA`"]
# [inline (always)]
pub fn is_tcc1_cca (& self) -> bool { * self == CHMUX_A :: TCC1_CCA } # [doc = "Checks if the value of the field is `TCC1_CCB`"]
# [inline (always)]
pub fn is_tcc1_ccb (& self) -> bool { * self == CHMUX_A :: TCC1_CCB } # [doc = "Checks if the value of the field is `TCD0_OVF`"]
# [inline (always)]
pub fn is_tcd0_ovf (& self) -> bool { * self == CHMUX_A :: TCD0_OVF } # [doc = "Checks if the value of the field is `TCD0_ERR`"]
# [inline (always)]
pub fn is_tcd0_err (& self) -> bool { * self == CHMUX_A :: TCD0_ERR } # [doc = "Checks if the value of the field is `TCD0_CCA`"]
# [inline (always)]
pub fn is_tcd0_cca (& self) -> bool { * self == CHMUX_A :: TCD0_CCA } # [doc = "Checks if the value of the field is `TCD0_CCB`"]
# [inline (always)]
pub fn is_tcd0_ccb (& self) -> bool { * self == CHMUX_A :: TCD0_CCB } # [doc = "Checks if the value of the field is `TCD0_CCC`"]
# [inline (always)]
pub fn is_tcd0_ccc (& self) -> bool { * self == CHMUX_A :: TCD0_CCC } # [doc = "Checks if the value of the field is `TCD0_CCD`"]
# [inline (always)]
pub fn is_tcd0_ccd (& self) -> bool { * self == CHMUX_A :: TCD0_CCD } # [doc = "Checks if the value of the field is `TCD1_OVF`"]
# [inline (always)]
pub fn is_tcd1_ovf (& self) -> bool { * self == CHMUX_A :: TCD1_OVF } # [doc = "Checks if the value of the field is `TCD1_ERR`"]
# [inline (always)]
pub fn is_tcd1_err (& self) -> bool { * self == CHMUX_A :: TCD1_ERR } # [doc = "Checks if the value of the field is `TCD1_CCA`"]
# [inline (always)]
pub fn is_tcd1_cca (& self) -> bool { * self == CHMUX_A :: TCD1_CCA } # [doc = "Checks if the value of the field is `TCD1_CCB`"]
# [inline (always)]
pub fn is_tcd1_ccb (& self) -> bool { * self == CHMUX_A :: TCD1_CCB } # [doc = "Checks if the value of the field is `TCE0_OVF`"]
# [inline (always)]
pub fn is_tce0_ovf (& self) -> bool { * self == CHMUX_A :: TCE0_OVF } # [doc = "Checks if the value of the field is `TCE0_ERR`"]
# [inline (always)]
pub fn is_tce0_err (& self) -> bool { * self == CHMUX_A :: TCE0_ERR } # [doc = "Checks if the value of the field is `TCE0_CCA`"]
# [inline (always)]
pub fn is_tce0_cca (& self) -> bool { * self == CHMUX_A :: TCE0_CCA } # [doc = "Checks if the value of the field is `TCE0_CCB`"]
# [inline (always)]
pub fn is_tce0_ccb (& self) -> bool { * self == CHMUX_A :: TCE0_CCB } # [doc = "Checks if the value of the field is `TCE0_CCC`"]
# [inline (always)]
pub fn is_tce0_ccc (& self) -> bool { * self == CHMUX_A :: TCE0_CCC } # [doc = "Checks if the value of the field is `TCE0_CCD`"]
# [inline (always)]
pub fn is_tce0_ccd (& self) -> bool { * self == CHMUX_A :: TCE0_CCD } # [doc = "Checks if the value of the field is `TCE1_OVF`"]
# [inline (always)]
pub fn is_tce1_ovf (& self) -> bool { * self == CHMUX_A :: TCE1_OVF } # [doc = "Checks if the value of the field is `TCE1_ERR`"]
# [inline (always)]
pub fn is_tce1_err (& self) -> bool { * self == CHMUX_A :: TCE1_ERR } # [doc = "Checks if the value of the field is `TCE1_CCA`"]
# [inline (always)]
pub fn is_tce1_cca (& self) -> bool { * self == CHMUX_A :: TCE1_CCA } # [doc = "Checks if the value of the field is `TCE1_CCB`"]
# [inline (always)]
pub fn is_tce1_ccb (& self) -> bool { * self == CHMUX_A :: TCE1_CCB } # [doc = "Checks if the value of the field is `TCF0_OVF`"]
# [inline (always)]
pub fn is_tcf0_ovf (& self) -> bool { * self == CHMUX_A :: TCF0_OVF } # [doc = "Checks if the value of the field is `TCF0_ERR`"]
# [inline (always)]
pub fn is_tcf0_err (& self) -> bool { * self == CHMUX_A :: TCF0_ERR } # [doc = "Checks if the value of the field is `TCF0_CCA`"]
# [inline (always)]
pub fn is_tcf0_cca (& self) -> bool { * self == CHMUX_A :: TCF0_CCA } # [doc = "Checks if the value of the field is `TCF0_CCB`"]
# [inline (always)]
pub fn is_tcf0_ccb (& self) -> bool { * self == CHMUX_A :: TCF0_CCB } # [doc = "Checks if the value of the field is `TCF0_CCC`"]
# [inline (always)]
pub fn is_tcf0_ccc (& self) -> bool { * self == CHMUX_A :: TCF0_CCC } # [doc = "Checks if the value of the field is `TCF0_CCD`"]
# [inline (always)]
pub fn is_tcf0_ccd (& self) -> bool { * self == CHMUX_A :: TCF0_CCD } # [doc = "Checks if the value of the field is `TCF1_OVF`"]
# [inline (always)]
pub fn is_tcf1_ovf (& self) -> bool { * self == CHMUX_A :: TCF1_OVF } # [doc = "Checks if the value of the field is `TCF1_ERR`"]
# [inline (always)]
pub fn is_tcf1_err (& self) -> bool { * self == CHMUX_A :: TCF1_ERR } # [doc = "Checks if the value of the field is `TCF1_CCA`"]
# [inline (always)]
pub fn is_tcf1_cca (& self) -> bool { * self == CHMUX_A :: TCF1_CCA } # [doc = "Checks if the value of the field is `TCF1_CCB`"]
# [inline (always)]
pub fn is_tcf1_ccb (& self) -> bool { * self == CHMUX_A :: TCF1_CCB } } # [doc = "Field `CHMUX` writer - Event Channel 4 Multiplexer"]
pub type CHMUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CH4MUX_SPEC , u8 , CHMUX_A , 8 , O > ; impl < 'a , const O : u8 > CHMUX_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHMUX_A :: OFF) } # [doc = "RTC Overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_OVF) } # [doc = "RTC Compare Match"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_CMP) } # [doc = "Analog Comparator A Channel 0"]
# [inline (always)]
pub fn aca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH0) } # [doc = "Analog Comparator A Channel 1"]
# [inline (always)]
pub fn aca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH1) } # [doc = "Analog Comparator A Window"]
# [inline (always)]
pub fn aca_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_WIN) } # [doc = "Analog Comparator B Channel 0"]
# [inline (always)]
pub fn acb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH0) } # [doc = "Analog Comparator B Channel 1"]
# [inline (always)]
pub fn acb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH1) } # [doc = "Analog Comparator B Window"]
# [inline (always)]
pub fn acb_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_WIN) } # [doc = "ADC A Channel 0"]
# [inline (always)]
pub fn adca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH0) } # [doc = "ADC A Channel 1"]
# [inline (always)]
pub fn adca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH1) } # [doc = "ADC A Channel 2"]
# [inline (always)]
pub fn adca_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH2) } # [doc = "ADC A Channel 3"]
# [inline (always)]
pub fn adca_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH3) } # [doc = "ADC B Channel 0"]
# [inline (always)]
pub fn adcb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH0) } # [doc = "ADC B Channel 1"]
# [inline (always)]
pub fn adcb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH1) } # [doc = "ADC B Channel 2"]
# [inline (always)]
pub fn adcb_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH2) } # [doc = "ADC B Channel 3"]
# [inline (always)]
pub fn adcb_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH3) } # [doc = "Port A, Pin0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN0) } # [doc = "Port A, Pin1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN1) } # [doc = "Port A, Pin2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN2) } # [doc = "Port A, Pin3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN3) } # [doc = "Port A, Pin4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN4) } # [doc = "Port A, Pin5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN5) } # [doc = "Port A, Pin6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN6) } # [doc = "Port A, Pin7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN7) } # [doc = "Port B, Pin0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN0) } # [doc = "Port B, Pin1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN1) } # [doc = "Port B, Pin2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN2) } # [doc = "Port B, Pin3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN3) } # [doc = "Port B, Pin4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN4) } # [doc = "Port B, Pin5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN5) } # [doc = "Port B, Pin6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN6) } # [doc = "Port B, Pin7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN7) } # [doc = "Port C, Pin0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN0) } # [doc = "Port C, Pin1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN1) } # [doc = "Port C, Pin2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN2) } # [doc = "Port C, Pin3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN3) } # [doc = "Port C, Pin4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN4) } # [doc = "Port C, Pin5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN5) } # [doc = "Port C, Pin6"]
# [inline (always)]
pub fn portc_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN6) } # [doc = "Port C, Pin7"]
# [inline (always)]
pub fn portc_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN7) } # [doc = "Port D, Pin0"]
# [inline (always)]
pub fn portd_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN0) } # [doc = "Port D, Pin1"]
# [inline (always)]
pub fn portd_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN1) } # [doc = "Port D, Pin2"]
# [inline (always)]
pub fn portd_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN2) } # [doc = "Port D, Pin3"]
# [inline (always)]
pub fn portd_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN3) } # [doc = "Port D, Pin4"]
# [inline (always)]
pub fn portd_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN4) } # [doc = "Port D, Pin5"]
# [inline (always)]
pub fn portd_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN5) } # [doc = "Port D, Pin6"]
# [inline (always)]
pub fn portd_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN6) } # [doc = "Port D, Pin7"]
# [inline (always)]
pub fn portd_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN7) } # [doc = "Port E, Pin0"]
# [inline (always)]
pub fn porte_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN0) } # [doc = "Port E, Pin1"]
# [inline (always)]
pub fn porte_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN1) } # [doc = "Port E, Pin2"]
# [inline (always)]
pub fn porte_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN2) } # [doc = "Port E, Pin3"]
# [inline (always)]
pub fn porte_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN3) } # [doc = "Port E, Pin4"]
# [inline (always)]
pub fn porte_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN4) } # [doc = "Port E, Pin5"]
# [inline (always)]
pub fn porte_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN5) } # [doc = "Port E, Pin6"]
# [inline (always)]
pub fn porte_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN6) } # [doc = "Port E, Pin7"]
# [inline (always)]
pub fn porte_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN7) } # [doc = "Port F, Pin0"]
# [inline (always)]
pub fn portf_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN0) } # [doc = "Port F, Pin1"]
# [inline (always)]
pub fn portf_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN1) } # [doc = "Port F, Pin2"]
# [inline (always)]
pub fn portf_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN2) } # [doc = "Port F, Pin3"]
# [inline (always)]
pub fn portf_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN3) } # [doc = "Port F, Pin4"]
# [inline (always)]
pub fn portf_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN4) } # [doc = "Port F, Pin5"]
# [inline (always)]
pub fn portf_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN5) } # [doc = "Port F, Pin6"]
# [inline (always)]
pub fn portf_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN6) } # [doc = "Port F, Pin7"]
# [inline (always)]
pub fn portf_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN7) } # [doc = "Prescaler, divide by 1"]
# [inline (always)]
pub fn prescaler_1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1) } # [doc = "Prescaler, divide by 2"]
# [inline (always)]
pub fn prescaler_2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2) } # [doc = "Prescaler, divide by 4"]
# [inline (always)]
pub fn prescaler_4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4) } # [doc = "Prescaler, divide by 8"]
# [inline (always)]
pub fn prescaler_8 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8) } # [doc = "Prescaler, divide by 16"]
# [inline (always)]
pub fn prescaler_16 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16) } # [doc = "Prescaler, divide by 32"]
# [inline (always)]
pub fn prescaler_32 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32) } # [doc = "Prescaler, divide by 64"]
# [inline (always)]
pub fn prescaler_64 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_64) } # [doc = "Prescaler, divide by 128"]
# [inline (always)]
pub fn prescaler_128 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_128) } # [doc = "Prescaler, divide by 256"]
# [inline (always)]
pub fn prescaler_256 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_256) } # [doc = "Prescaler, divide by 512"]
# [inline (always)]
pub fn prescaler_512 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_512) } # [doc = "Prescaler, divide by 1024"]
# [inline (always)]
pub fn prescaler_1024 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1024) } # [doc = "Prescaler, divide by 2048"]
# [inline (always)]
pub fn prescaler_2048 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2048) } # [doc = "Prescaler, divide by 4096"]
# [inline (always)]
pub fn prescaler_4096 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4096) } # [doc = "Prescaler, divide by 8192"]
# [inline (always)]
pub fn prescaler_8192 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8192) } # [doc = "Prescaler, divide by 16384"]
# [inline (always)]
pub fn prescaler_16384 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16384) } # [doc = "Prescaler, divide by 32768"]
# [inline (always)]
pub fn prescaler_32768 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32768) } # [doc = "Timer/Counter C0 Overflow"]
# [inline (always)]
pub fn tcc0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_OVF) } # [doc = "Timer/Counter C0 Error"]
# [inline (always)]
pub fn tcc0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_ERR) } # [doc = "Timer/Counter C0 Compare or Capture A"]
# [inline (always)]
pub fn tcc0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCA) } # [doc = "Timer/Counter C0 Compare or Capture B"]
# [inline (always)]
pub fn tcc0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCB) } # [doc = "Timer/Counter C0 Compare or Capture C"]
# [inline (always)]
pub fn tcc0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCC) } # [doc = "Timer/Counter C0 Compare or Capture D"]
# [inline (always)]
pub fn tcc0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCD) } # [doc = "Timer/Counter C1 Overflow"]
# [inline (always)]
pub fn tcc1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_OVF) } # [doc = "Timer/Counter C1 Error"]
# [inline (always)]
pub fn tcc1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_ERR) } # [doc = "Timer/Counter C1 Compare or Capture A"]
# [inline (always)]
pub fn tcc1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCA) } # [doc = "Timer/Counter C1 Compare or Capture B"]
# [inline (always)]
pub fn tcc1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCB) } # [doc = "Timer/Counter D0 Overflow"]
# [inline (always)]
pub fn tcd0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_OVF) } # [doc = "Timer/Counter D0 Error"]
# [inline (always)]
pub fn tcd0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_ERR) } # [doc = "Timer/Counter D0 Compare or Capture A"]
# [inline (always)]
pub fn tcd0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCA) } # [doc = "Timer/Counter D0 Compare or Capture B"]
# [inline (always)]
pub fn tcd0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCB) } # [doc = "Timer/Counter D0 Compare or Capture C"]
# [inline (always)]
pub fn tcd0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCC) } # [doc = "Timer/Counter D0 Compare or Capture D"]
# [inline (always)]
pub fn tcd0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCD) } # [doc = "Timer/Counter D1 Overflow"]
# [inline (always)]
pub fn tcd1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_OVF) } # [doc = "Timer/Counter D1 Error"]
# [inline (always)]
pub fn tcd1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_ERR) } # [doc = "Timer/Counter D1 Compare or Capture A"]
# [inline (always)]
pub fn tcd1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCA) } # [doc = "Timer/Counter D1 Compare or Capture B"]
# [inline (always)]
pub fn tcd1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCB) } # [doc = "Timer/Counter E0 Overflow"]
# [inline (always)]
pub fn tce0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_OVF) } # [doc = "Timer/Counter E0 Error"]
# [inline (always)]
pub fn tce0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_ERR) } # [doc = "Timer/Counter E0 Compare or Capture A"]
# [inline (always)]
pub fn tce0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCA) } # [doc = "Timer/Counter E0 Compare or Capture B"]
# [inline (always)]
pub fn tce0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCB) } # [doc = "Timer/Counter E0 Compare or Capture C"]
# [inline (always)]
pub fn tce0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCC) } # [doc = "Timer/Counter E0 Compare or Capture D"]
# [inline (always)]
pub fn tce0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCD) } # [doc = "Timer/Counter E1 Overflow"]
# [inline (always)]
pub fn tce1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_OVF) } # [doc = "Timer/Counter E1 Error"]
# [inline (always)]
pub fn tce1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_ERR) } # [doc = "Timer/Counter E1 Compare or Capture A"]
# [inline (always)]
pub fn tce1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCA) } # [doc = "Timer/Counter E1 Compare or Capture B"]
# [inline (always)]
pub fn tce1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCB) } # [doc = "Timer/Counter F0 Overflow"]
# [inline (always)]
pub fn tcf0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_OVF) } # [doc = "Timer/Counter F0 Error"]
# [inline (always)]
pub fn tcf0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_ERR) } # [doc = "Timer/Counter F0 Compare or Capture A"]
# [inline (always)]
pub fn tcf0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCA) } # [doc = "Timer/Counter F0 Compare or Capture B"]
# [inline (always)]
pub fn tcf0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCB) } # [doc = "Timer/Counter F0 Compare or Capture C"]
# [inline (always)]
pub fn tcf0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCC) } # [doc = "Timer/Counter F0 Compare or Capture D"]
# [inline (always)]
pub fn tcf0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCD) } # [doc = "Timer/Counter F1 Overflow"]
# [inline (always)]
pub fn tcf1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_OVF) } # [doc = "Timer/Counter F1 Error"]
# [inline (always)]
pub fn tcf1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_ERR) } # [doc = "Timer/Counter F1 Compare or Capture A"]
# [inline (always)]
pub fn tcf1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCA) } # [doc = "Timer/Counter F1 Compare or Capture B"]
# [inline (always)]
pub fn tcf1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCB) } } impl R { # [doc = "Bits 0:7 - Event Channel 4 Multiplexer"]
# [inline (always)]
pub fn chmux (& self) -> CHMUX_R { CHMUX_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Event Channel 4 Multiplexer"]
# [inline (always)]
# [must_use]
pub fn chmux (& mut self) -> CHMUX_W < 0 > { CHMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Channel 4 Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch4mux](index.html) module"]
pub struct CH4MUX_SPEC ; impl crate :: RegisterSpec for CH4MUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch4mux::R](R) reader structure"]
impl crate :: Readable for CH4MUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch4mux::W](W) writer structure"]
impl crate :: Writable for CH4MUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH4MUX to value 0"]
impl crate :: Resettable for CH4MUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH5CTRL (rw) register accessor: an alias for `Reg<CH5CTRL_SPEC>`"]
pub type CH5CTRL = crate :: Reg < ch5ctrl :: CH5CTRL_SPEC > ; # [doc = "Channel 5 Control Register"]
pub mod ch5ctrl { # [doc = "Register `CH5CTRL` reader"]
pub struct R (crate :: R < CH5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH5CTRL` writer"]
pub struct W (crate :: W < CH5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIGFILT` reader - Digital Filter"]
pub type DIGFILT_R = crate :: FieldReader < u8 , DIGFILT_A > ; # [doc = "Digital Filter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DIGFILT_A { # [doc = "0: 1 SAMPLE"]
_1SAMPLE = 0 , # [doc = "1: 2 SAMPLES"]
_2SAMPLES = 1 , # [doc = "2: 3 SAMPLES"]
_3SAMPLES = 2 , # [doc = "3: 4 SAMPLES"]
_4SAMPLES = 3 , # [doc = "4: 5 SAMPLES"]
_5SAMPLES = 4 , # [doc = "5: 6 SAMPLES"]
_6SAMPLES = 5 , # [doc = "6: 7 SAMPLES"]
_7SAMPLES = 6 , # [doc = "7: 8 SAMPLES"]
_8SAMPLES = 7 , } impl From < DIGFILT_A > for u8 { # [inline (always)]
fn from (variant : DIGFILT_A) -> Self { variant as _ } } impl DIGFILT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIGFILT_A { match self . bits { 0 => DIGFILT_A :: _1SAMPLE , 1 => DIGFILT_A :: _2SAMPLES , 2 => DIGFILT_A :: _3SAMPLES , 3 => DIGFILT_A :: _4SAMPLES , 4 => DIGFILT_A :: _5SAMPLES , 5 => DIGFILT_A :: _6SAMPLES , 6 => DIGFILT_A :: _7SAMPLES , 7 => DIGFILT_A :: _8SAMPLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1SAMPLE`"]
# [inline (always)]
pub fn is_1sample (& self) -> bool { * self == DIGFILT_A :: _1SAMPLE } # [doc = "Checks if the value of the field is `_2SAMPLES`"]
# [inline (always)]
pub fn is_2samples (& self) -> bool { * self == DIGFILT_A :: _2SAMPLES } # [doc = "Checks if the value of the field is `_3SAMPLES`"]
# [inline (always)]
pub fn is_3samples (& self) -> bool { * self == DIGFILT_A :: _3SAMPLES } # [doc = "Checks if the value of the field is `_4SAMPLES`"]
# [inline (always)]
pub fn is_4samples (& self) -> bool { * self == DIGFILT_A :: _4SAMPLES } # [doc = "Checks if the value of the field is `_5SAMPLES`"]
# [inline (always)]
pub fn is_5samples (& self) -> bool { * self == DIGFILT_A :: _5SAMPLES } # [doc = "Checks if the value of the field is `_6SAMPLES`"]
# [inline (always)]
pub fn is_6samples (& self) -> bool { * self == DIGFILT_A :: _6SAMPLES } # [doc = "Checks if the value of the field is `_7SAMPLES`"]
# [inline (always)]
pub fn is_7samples (& self) -> bool { * self == DIGFILT_A :: _7SAMPLES } # [doc = "Checks if the value of the field is `_8SAMPLES`"]
# [inline (always)]
pub fn is_8samples (& self) -> bool { * self == DIGFILT_A :: _8SAMPLES } } # [doc = "Field `DIGFILT` writer - Digital Filter"]
pub type DIGFILT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH5CTRL_SPEC , u8 , DIGFILT_A , 3 , O > ; impl < 'a , const O : u8 > DIGFILT_W < 'a , O > { # [doc = "1 SAMPLE"]
# [inline (always)]
pub fn _1sample (self) -> & 'a mut W { self . variant (DIGFILT_A :: _1SAMPLE) } # [doc = "2 SAMPLES"]
# [inline (always)]
pub fn _2samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _2SAMPLES) } # [doc = "3 SAMPLES"]
# [inline (always)]
pub fn _3samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _3SAMPLES) } # [doc = "4 SAMPLES"]
# [inline (always)]
pub fn _4samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _4SAMPLES) } # [doc = "5 SAMPLES"]
# [inline (always)]
pub fn _5samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _5SAMPLES) } # [doc = "6 SAMPLES"]
# [inline (always)]
pub fn _6samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _6SAMPLES) } # [doc = "7 SAMPLES"]
# [inline (always)]
pub fn _7samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _7SAMPLES) } # [doc = "8 SAMPLES"]
# [inline (always)]
pub fn _8samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _8SAMPLES) } } impl R { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
pub fn digfilt (& self) -> DIGFILT_R { DIGFILT_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
# [must_use]
pub fn digfilt (& mut self) -> DIGFILT_W < 0 > { DIGFILT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch5ctrl](index.html) module"]
pub struct CH5CTRL_SPEC ; impl crate :: RegisterSpec for CH5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch5ctrl::R](R) reader structure"]
impl crate :: Readable for CH5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch5ctrl::W](W) writer structure"]
impl crate :: Writable for CH5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH5CTRL to value 0"]
impl crate :: Resettable for CH5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH5MUX (rw) register accessor: an alias for `Reg<CH5MUX_SPEC>`"]
pub type CH5MUX = crate :: Reg < ch5mux :: CH5MUX_SPEC > ; # [doc = "Event Channel 5 Multiplexer"]
pub mod ch5mux { # [doc = "Register `CH5MUX` reader"]
pub struct R (crate :: R < CH5MUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH5MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH5MUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH5MUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH5MUX` writer"]
pub struct W (crate :: W < CH5MUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH5MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH5MUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH5MUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHMUX` reader - Event Channel 5 Multiplexer"]
pub type CHMUX_R = crate :: FieldReader < u8 , CHMUX_A > ; # [doc = "Event Channel 5 Multiplexer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHMUX_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "8: RTC Overflow"]
RTC_OVF = 8 , # [doc = "9: RTC Compare Match"]
RTC_CMP = 9 , # [doc = "16: Analog Comparator A Channel 0"]
ACA_CH0 = 16 , # [doc = "17: Analog Comparator A Channel 1"]
ACA_CH1 = 17 , # [doc = "18: Analog Comparator A Window"]
ACA_WIN = 18 , # [doc = "19: Analog Comparator B Channel 0"]
ACB_CH0 = 19 , # [doc = "20: Analog Comparator B Channel 1"]
ACB_CH1 = 20 , # [doc = "21: Analog Comparator B Window"]
ACB_WIN = 21 , # [doc = "32: ADC A Channel 0"]
ADCA_CH0 = 32 , # [doc = "33: ADC A Channel 1"]
ADCA_CH1 = 33 , # [doc = "34: ADC A Channel 2"]
ADCA_CH2 = 34 , # [doc = "35: ADC A Channel 3"]
ADCA_CH3 = 35 , # [doc = "36: ADC B Channel 0"]
ADCB_CH0 = 36 , # [doc = "37: ADC B Channel 1"]
ADCB_CH1 = 37 , # [doc = "38: ADC B Channel 2"]
ADCB_CH2 = 38 , # [doc = "39: ADC B Channel 3"]
ADCB_CH3 = 39 , # [doc = "80: Port A, Pin0"]
PORTA_PIN0 = 80 , # [doc = "81: Port A, Pin1"]
PORTA_PIN1 = 81 , # [doc = "82: Port A, Pin2"]
PORTA_PIN2 = 82 , # [doc = "83: Port A, Pin3"]
PORTA_PIN3 = 83 , # [doc = "84: Port A, Pin4"]
PORTA_PIN4 = 84 , # [doc = "85: Port A, Pin5"]
PORTA_PIN5 = 85 , # [doc = "86: Port A, Pin6"]
PORTA_PIN6 = 86 , # [doc = "87: Port A, Pin7"]
PORTA_PIN7 = 87 , # [doc = "88: Port B, Pin0"]
PORTB_PIN0 = 88 , # [doc = "89: Port B, Pin1"]
PORTB_PIN1 = 89 , # [doc = "90: Port B, Pin2"]
PORTB_PIN2 = 90 , # [doc = "91: Port B, Pin3"]
PORTB_PIN3 = 91 , # [doc = "92: Port B, Pin4"]
PORTB_PIN4 = 92 , # [doc = "93: Port B, Pin5"]
PORTB_PIN5 = 93 , # [doc = "94: Port B, Pin6"]
PORTB_PIN6 = 94 , # [doc = "95: Port B, Pin7"]
PORTB_PIN7 = 95 , # [doc = "96: Port C, Pin0"]
PORTC_PIN0 = 96 , # [doc = "97: Port C, Pin1"]
PORTC_PIN1 = 97 , # [doc = "98: Port C, Pin2"]
PORTC_PIN2 = 98 , # [doc = "99: Port C, Pin3"]
PORTC_PIN3 = 99 , # [doc = "100: Port C, Pin4"]
PORTC_PIN4 = 100 , # [doc = "101: Port C, Pin5"]
PORTC_PIN5 = 101 , # [doc = "102: Port C, Pin6"]
PORTC_PIN6 = 102 , # [doc = "103: Port C, Pin7"]
PORTC_PIN7 = 103 , # [doc = "104: Port D, Pin0"]
PORTD_PIN0 = 104 , # [doc = "105: Port D, Pin1"]
PORTD_PIN1 = 105 , # [doc = "106: Port D, Pin2"]
PORTD_PIN2 = 106 , # [doc = "107: Port D, Pin3"]
PORTD_PIN3 = 107 , # [doc = "108: Port D, Pin4"]
PORTD_PIN4 = 108 , # [doc = "109: Port D, Pin5"]
PORTD_PIN5 = 109 , # [doc = "110: Port D, Pin6"]
PORTD_PIN6 = 110 , # [doc = "111: Port D, Pin7"]
PORTD_PIN7 = 111 , # [doc = "112: Port E, Pin0"]
PORTE_PIN0 = 112 , # [doc = "113: Port E, Pin1"]
PORTE_PIN1 = 113 , # [doc = "114: Port E, Pin2"]
PORTE_PIN2 = 114 , # [doc = "115: Port E, Pin3"]
PORTE_PIN3 = 115 , # [doc = "116: Port E, Pin4"]
PORTE_PIN4 = 116 , # [doc = "117: Port E, Pin5"]
PORTE_PIN5 = 117 , # [doc = "118: Port E, Pin6"]
PORTE_PIN6 = 118 , # [doc = "119: Port E, Pin7"]
PORTE_PIN7 = 119 , # [doc = "120: Port F, Pin0"]
PORTF_PIN0 = 120 , # [doc = "121: Port F, Pin1"]
PORTF_PIN1 = 121 , # [doc = "122: Port F, Pin2"]
PORTF_PIN2 = 122 , # [doc = "123: Port F, Pin3"]
PORTF_PIN3 = 123 , # [doc = "124: Port F, Pin4"]
PORTF_PIN4 = 124 , # [doc = "125: Port F, Pin5"]
PORTF_PIN5 = 125 , # [doc = "126: Port F, Pin6"]
PORTF_PIN6 = 126 , # [doc = "127: Port F, Pin7"]
PORTF_PIN7 = 127 , # [doc = "128: Prescaler, divide by 1"]
PRESCALER_1 = 128 , # [doc = "129: Prescaler, divide by 2"]
PRESCALER_2 = 129 , # [doc = "130: Prescaler, divide by 4"]
PRESCALER_4 = 130 , # [doc = "131: Prescaler, divide by 8"]
PRESCALER_8 = 131 , # [doc = "132: Prescaler, divide by 16"]
PRESCALER_16 = 132 , # [doc = "133: Prescaler, divide by 32"]
PRESCALER_32 = 133 , # [doc = "134: Prescaler, divide by 64"]
PRESCALER_64 = 134 , # [doc = "135: Prescaler, divide by 128"]
PRESCALER_128 = 135 , # [doc = "136: Prescaler, divide by 256"]
PRESCALER_256 = 136 , # [doc = "137: Prescaler, divide by 512"]
PRESCALER_512 = 137 , # [doc = "138: Prescaler, divide by 1024"]
PRESCALER_1024 = 138 , # [doc = "139: Prescaler, divide by 2048"]
PRESCALER_2048 = 139 , # [doc = "140: Prescaler, divide by 4096"]
PRESCALER_4096 = 140 , # [doc = "141: Prescaler, divide by 8192"]
PRESCALER_8192 = 141 , # [doc = "142: Prescaler, divide by 16384"]
PRESCALER_16384 = 142 , # [doc = "143: Prescaler, divide by 32768"]
PRESCALER_32768 = 143 , # [doc = "192: Timer/Counter C0 Overflow"]
TCC0_OVF = 192 , # [doc = "193: Timer/Counter C0 Error"]
TCC0_ERR = 193 , # [doc = "196: Timer/Counter C0 Compare or Capture A"]
TCC0_CCA = 196 , # [doc = "197: Timer/Counter C0 Compare or Capture B"]
TCC0_CCB = 197 , # [doc = "198: Timer/Counter C0 Compare or Capture C"]
TCC0_CCC = 198 , # [doc = "199: Timer/Counter C0 Compare or Capture D"]
TCC0_CCD = 199 , # [doc = "200: Timer/Counter C1 Overflow"]
TCC1_OVF = 200 , # [doc = "201: Timer/Counter C1 Error"]
TCC1_ERR = 201 , # [doc = "204: Timer/Counter C1 Compare or Capture A"]
TCC1_CCA = 204 , # [doc = "205: Timer/Counter C1 Compare or Capture B"]
TCC1_CCB = 205 , # [doc = "208: Timer/Counter D0 Overflow"]
TCD0_OVF = 208 , # [doc = "209: Timer/Counter D0 Error"]
TCD0_ERR = 209 , # [doc = "212: Timer/Counter D0 Compare or Capture A"]
TCD0_CCA = 212 , # [doc = "213: Timer/Counter D0 Compare or Capture B"]
TCD0_CCB = 213 , # [doc = "214: Timer/Counter D0 Compare or Capture C"]
TCD0_CCC = 214 , # [doc = "215: Timer/Counter D0 Compare or Capture D"]
TCD0_CCD = 215 , # [doc = "216: Timer/Counter D1 Overflow"]
TCD1_OVF = 216 , # [doc = "217: Timer/Counter D1 Error"]
TCD1_ERR = 217 , # [doc = "220: Timer/Counter D1 Compare or Capture A"]
TCD1_CCA = 220 , # [doc = "221: Timer/Counter D1 Compare or Capture B"]
TCD1_CCB = 221 , # [doc = "224: Timer/Counter E0 Overflow"]
TCE0_OVF = 224 , # [doc = "225: Timer/Counter E0 Error"]
TCE0_ERR = 225 , # [doc = "228: Timer/Counter E0 Compare or Capture A"]
TCE0_CCA = 228 , # [doc = "229: Timer/Counter E0 Compare or Capture B"]
TCE0_CCB = 229 , # [doc = "230: Timer/Counter E0 Compare or Capture C"]
TCE0_CCC = 230 , # [doc = "231: Timer/Counter E0 Compare or Capture D"]
TCE0_CCD = 231 , # [doc = "232: Timer/Counter E1 Overflow"]
TCE1_OVF = 232 , # [doc = "233: Timer/Counter E1 Error"]
TCE1_ERR = 233 , # [doc = "236: Timer/Counter E1 Compare or Capture A"]
TCE1_CCA = 236 , # [doc = "237: Timer/Counter E1 Compare or Capture B"]
TCE1_CCB = 237 , # [doc = "240: Timer/Counter F0 Overflow"]
TCF0_OVF = 240 , # [doc = "241: Timer/Counter F0 Error"]
TCF0_ERR = 241 , # [doc = "244: Timer/Counter F0 Compare or Capture A"]
TCF0_CCA = 244 , # [doc = "245: Timer/Counter F0 Compare or Capture B"]
TCF0_CCB = 245 , # [doc = "246: Timer/Counter F0 Compare or Capture C"]
TCF0_CCC = 246 , # [doc = "247: Timer/Counter F0 Compare or Capture D"]
TCF0_CCD = 247 , # [doc = "248: Timer/Counter F1 Overflow"]
TCF1_OVF = 248 , # [doc = "249: Timer/Counter F1 Error"]
TCF1_ERR = 249 , # [doc = "252: Timer/Counter F1 Compare or Capture A"]
TCF1_CCA = 252 , # [doc = "253: Timer/Counter F1 Compare or Capture B"]
TCF1_CCB = 253 , } impl From < CHMUX_A > for u8 { # [inline (always)]
fn from (variant : CHMUX_A) -> Self { variant as _ } } impl CHMUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHMUX_A > { match self . bits { 0 => Some (CHMUX_A :: OFF) , 8 => Some (CHMUX_A :: RTC_OVF) , 9 => Some (CHMUX_A :: RTC_CMP) , 16 => Some (CHMUX_A :: ACA_CH0) , 17 => Some (CHMUX_A :: ACA_CH1) , 18 => Some (CHMUX_A :: ACA_WIN) , 19 => Some (CHMUX_A :: ACB_CH0) , 20 => Some (CHMUX_A :: ACB_CH1) , 21 => Some (CHMUX_A :: ACB_WIN) , 32 => Some (CHMUX_A :: ADCA_CH0) , 33 => Some (CHMUX_A :: ADCA_CH1) , 34 => Some (CHMUX_A :: ADCA_CH2) , 35 => Some (CHMUX_A :: ADCA_CH3) , 36 => Some (CHMUX_A :: ADCB_CH0) , 37 => Some (CHMUX_A :: ADCB_CH1) , 38 => Some (CHMUX_A :: ADCB_CH2) , 39 => Some (CHMUX_A :: ADCB_CH3) , 80 => Some (CHMUX_A :: PORTA_PIN0) , 81 => Some (CHMUX_A :: PORTA_PIN1) , 82 => Some (CHMUX_A :: PORTA_PIN2) , 83 => Some (CHMUX_A :: PORTA_PIN3) , 84 => Some (CHMUX_A :: PORTA_PIN4) , 85 => Some (CHMUX_A :: PORTA_PIN5) , 86 => Some (CHMUX_A :: PORTA_PIN6) , 87 => Some (CHMUX_A :: PORTA_PIN7) , 88 => Some (CHMUX_A :: PORTB_PIN0) , 89 => Some (CHMUX_A :: PORTB_PIN1) , 90 => Some (CHMUX_A :: PORTB_PIN2) , 91 => Some (CHMUX_A :: PORTB_PIN3) , 92 => Some (CHMUX_A :: PORTB_PIN4) , 93 => Some (CHMUX_A :: PORTB_PIN5) , 94 => Some (CHMUX_A :: PORTB_PIN6) , 95 => Some (CHMUX_A :: PORTB_PIN7) , 96 => Some (CHMUX_A :: PORTC_PIN0) , 97 => Some (CHMUX_A :: PORTC_PIN1) , 98 => Some (CHMUX_A :: PORTC_PIN2) , 99 => Some (CHMUX_A :: PORTC_PIN3) , 100 => Some (CHMUX_A :: PORTC_PIN4) , 101 => Some (CHMUX_A :: PORTC_PIN5) , 102 => Some (CHMUX_A :: PORTC_PIN6) , 103 => Some (CHMUX_A :: PORTC_PIN7) , 104 => Some (CHMUX_A :: PORTD_PIN0) , 105 => Some (CHMUX_A :: PORTD_PIN1) , 106 => Some (CHMUX_A :: PORTD_PIN2) , 107 => Some (CHMUX_A :: PORTD_PIN3) , 108 => Some (CHMUX_A :: PORTD_PIN4) , 109 => Some (CHMUX_A :: PORTD_PIN5) , 110 => Some (CHMUX_A :: PORTD_PIN6) , 111 => Some (CHMUX_A :: PORTD_PIN7) , 112 => Some (CHMUX_A :: PORTE_PIN0) , 113 => Some (CHMUX_A :: PORTE_PIN1) , 114 => Some (CHMUX_A :: PORTE_PIN2) , 115 => Some (CHMUX_A :: PORTE_PIN3) , 116 => Some (CHMUX_A :: PORTE_PIN4) , 117 => Some (CHMUX_A :: PORTE_PIN5) , 118 => Some (CHMUX_A :: PORTE_PIN6) , 119 => Some (CHMUX_A :: PORTE_PIN7) , 120 => Some (CHMUX_A :: PORTF_PIN0) , 121 => Some (CHMUX_A :: PORTF_PIN1) , 122 => Some (CHMUX_A :: PORTF_PIN2) , 123 => Some (CHMUX_A :: PORTF_PIN3) , 124 => Some (CHMUX_A :: PORTF_PIN4) , 125 => Some (CHMUX_A :: PORTF_PIN5) , 126 => Some (CHMUX_A :: PORTF_PIN6) , 127 => Some (CHMUX_A :: PORTF_PIN7) , 128 => Some (CHMUX_A :: PRESCALER_1) , 129 => Some (CHMUX_A :: PRESCALER_2) , 130 => Some (CHMUX_A :: PRESCALER_4) , 131 => Some (CHMUX_A :: PRESCALER_8) , 132 => Some (CHMUX_A :: PRESCALER_16) , 133 => Some (CHMUX_A :: PRESCALER_32) , 134 => Some (CHMUX_A :: PRESCALER_64) , 135 => Some (CHMUX_A :: PRESCALER_128) , 136 => Some (CHMUX_A :: PRESCALER_256) , 137 => Some (CHMUX_A :: PRESCALER_512) , 138 => Some (CHMUX_A :: PRESCALER_1024) , 139 => Some (CHMUX_A :: PRESCALER_2048) , 140 => Some (CHMUX_A :: PRESCALER_4096) , 141 => Some (CHMUX_A :: PRESCALER_8192) , 142 => Some (CHMUX_A :: PRESCALER_16384) , 143 => Some (CHMUX_A :: PRESCALER_32768) , 192 => Some (CHMUX_A :: TCC0_OVF) , 193 => Some (CHMUX_A :: TCC0_ERR) , 196 => Some (CHMUX_A :: TCC0_CCA) , 197 => Some (CHMUX_A :: TCC0_CCB) , 198 => Some (CHMUX_A :: TCC0_CCC) , 199 => Some (CHMUX_A :: TCC0_CCD) , 200 => Some (CHMUX_A :: TCC1_OVF) , 201 => Some (CHMUX_A :: TCC1_ERR) , 204 => Some (CHMUX_A :: TCC1_CCA) , 205 => Some (CHMUX_A :: TCC1_CCB) , 208 => Some (CHMUX_A :: TCD0_OVF) , 209 => Some (CHMUX_A :: TCD0_ERR) , 212 => Some (CHMUX_A :: TCD0_CCA) , 213 => Some (CHMUX_A :: TCD0_CCB) , 214 => Some (CHMUX_A :: TCD0_CCC) , 215 => Some (CHMUX_A :: TCD0_CCD) , 216 => Some (CHMUX_A :: TCD1_OVF) , 217 => Some (CHMUX_A :: TCD1_ERR) , 220 => Some (CHMUX_A :: TCD1_CCA) , 221 => Some (CHMUX_A :: TCD1_CCB) , 224 => Some (CHMUX_A :: TCE0_OVF) , 225 => Some (CHMUX_A :: TCE0_ERR) , 228 => Some (CHMUX_A :: TCE0_CCA) , 229 => Some (CHMUX_A :: TCE0_CCB) , 230 => Some (CHMUX_A :: TCE0_CCC) , 231 => Some (CHMUX_A :: TCE0_CCD) , 232 => Some (CHMUX_A :: TCE1_OVF) , 233 => Some (CHMUX_A :: TCE1_ERR) , 236 => Some (CHMUX_A :: TCE1_CCA) , 237 => Some (CHMUX_A :: TCE1_CCB) , 240 => Some (CHMUX_A :: TCF0_OVF) , 241 => Some (CHMUX_A :: TCF0_ERR) , 244 => Some (CHMUX_A :: TCF0_CCA) , 245 => Some (CHMUX_A :: TCF0_CCB) , 246 => Some (CHMUX_A :: TCF0_CCC) , 247 => Some (CHMUX_A :: TCF0_CCD) , 248 => Some (CHMUX_A :: TCF1_OVF) , 249 => Some (CHMUX_A :: TCF1_ERR) , 252 => Some (CHMUX_A :: TCF1_CCA) , 253 => Some (CHMUX_A :: TCF1_CCB) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHMUX_A :: OFF } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == CHMUX_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == CHMUX_A :: RTC_CMP } # [doc = "Checks if the value of the field is `ACA_CH0`"]
# [inline (always)]
pub fn is_aca_ch0 (& self) -> bool { * self == CHMUX_A :: ACA_CH0 } # [doc = "Checks if the value of the field is `ACA_CH1`"]
# [inline (always)]
pub fn is_aca_ch1 (& self) -> bool { * self == CHMUX_A :: ACA_CH1 } # [doc = "Checks if the value of the field is `ACA_WIN`"]
# [inline (always)]
pub fn is_aca_win (& self) -> bool { * self == CHMUX_A :: ACA_WIN } # [doc = "Checks if the value of the field is `ACB_CH0`"]
# [inline (always)]
pub fn is_acb_ch0 (& self) -> bool { * self == CHMUX_A :: ACB_CH0 } # [doc = "Checks if the value of the field is `ACB_CH1`"]
# [inline (always)]
pub fn is_acb_ch1 (& self) -> bool { * self == CHMUX_A :: ACB_CH1 } # [doc = "Checks if the value of the field is `ACB_WIN`"]
# [inline (always)]
pub fn is_acb_win (& self) -> bool { * self == CHMUX_A :: ACB_WIN } # [doc = "Checks if the value of the field is `ADCA_CH0`"]
# [inline (always)]
pub fn is_adca_ch0 (& self) -> bool { * self == CHMUX_A :: ADCA_CH0 } # [doc = "Checks if the value of the field is `ADCA_CH1`"]
# [inline (always)]
pub fn is_adca_ch1 (& self) -> bool { * self == CHMUX_A :: ADCA_CH1 } # [doc = "Checks if the value of the field is `ADCA_CH2`"]
# [inline (always)]
pub fn is_adca_ch2 (& self) -> bool { * self == CHMUX_A :: ADCA_CH2 } # [doc = "Checks if the value of the field is `ADCA_CH3`"]
# [inline (always)]
pub fn is_adca_ch3 (& self) -> bool { * self == CHMUX_A :: ADCA_CH3 } # [doc = "Checks if the value of the field is `ADCB_CH0`"]
# [inline (always)]
pub fn is_adcb_ch0 (& self) -> bool { * self == CHMUX_A :: ADCB_CH0 } # [doc = "Checks if the value of the field is `ADCB_CH1`"]
# [inline (always)]
pub fn is_adcb_ch1 (& self) -> bool { * self == CHMUX_A :: ADCB_CH1 } # [doc = "Checks if the value of the field is `ADCB_CH2`"]
# [inline (always)]
pub fn is_adcb_ch2 (& self) -> bool { * self == CHMUX_A :: ADCB_CH2 } # [doc = "Checks if the value of the field is `ADCB_CH3`"]
# [inline (always)]
pub fn is_adcb_ch3 (& self) -> bool { * self == CHMUX_A :: ADCB_CH3 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN7 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTC_PIN6`"]
# [inline (always)]
pub fn is_portc_pin6 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN6 } # [doc = "Checks if the value of the field is `PORTC_PIN7`"]
# [inline (always)]
pub fn is_portc_pin7 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN7 } # [doc = "Checks if the value of the field is `PORTD_PIN0`"]
# [inline (always)]
pub fn is_portd_pin0 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN0 } # [doc = "Checks if the value of the field is `PORTD_PIN1`"]
# [inline (always)]
pub fn is_portd_pin1 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN1 } # [doc = "Checks if the value of the field is `PORTD_PIN2`"]
# [inline (always)]
pub fn is_portd_pin2 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN2 } # [doc = "Checks if the value of the field is `PORTD_PIN3`"]
# [inline (always)]
pub fn is_portd_pin3 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN3 } # [doc = "Checks if the value of the field is `PORTD_PIN4`"]
# [inline (always)]
pub fn is_portd_pin4 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN4 } # [doc = "Checks if the value of the field is `PORTD_PIN5`"]
# [inline (always)]
pub fn is_portd_pin5 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN5 } # [doc = "Checks if the value of the field is `PORTD_PIN6`"]
# [inline (always)]
pub fn is_portd_pin6 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN6 } # [doc = "Checks if the value of the field is `PORTD_PIN7`"]
# [inline (always)]
pub fn is_portd_pin7 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN7 } # [doc = "Checks if the value of the field is `PORTE_PIN0`"]
# [inline (always)]
pub fn is_porte_pin0 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN0 } # [doc = "Checks if the value of the field is `PORTE_PIN1`"]
# [inline (always)]
pub fn is_porte_pin1 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN1 } # [doc = "Checks if the value of the field is `PORTE_PIN2`"]
# [inline (always)]
pub fn is_porte_pin2 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN2 } # [doc = "Checks if the value of the field is `PORTE_PIN3`"]
# [inline (always)]
pub fn is_porte_pin3 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN3 } # [doc = "Checks if the value of the field is `PORTE_PIN4`"]
# [inline (always)]
pub fn is_porte_pin4 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN4 } # [doc = "Checks if the value of the field is `PORTE_PIN5`"]
# [inline (always)]
pub fn is_porte_pin5 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN5 } # [doc = "Checks if the value of the field is `PORTE_PIN6`"]
# [inline (always)]
pub fn is_porte_pin6 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN6 } # [doc = "Checks if the value of the field is `PORTE_PIN7`"]
# [inline (always)]
pub fn is_porte_pin7 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN7 } # [doc = "Checks if the value of the field is `PORTF_PIN0`"]
# [inline (always)]
pub fn is_portf_pin0 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN0 } # [doc = "Checks if the value of the field is `PORTF_PIN1`"]
# [inline (always)]
pub fn is_portf_pin1 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN1 } # [doc = "Checks if the value of the field is `PORTF_PIN2`"]
# [inline (always)]
pub fn is_portf_pin2 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN2 } # [doc = "Checks if the value of the field is `PORTF_PIN3`"]
# [inline (always)]
pub fn is_portf_pin3 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN3 } # [doc = "Checks if the value of the field is `PORTF_PIN4`"]
# [inline (always)]
pub fn is_portf_pin4 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN4 } # [doc = "Checks if the value of the field is `PORTF_PIN5`"]
# [inline (always)]
pub fn is_portf_pin5 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN5 } # [doc = "Checks if the value of the field is `PORTF_PIN6`"]
# [inline (always)]
pub fn is_portf_pin6 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN6 } # [doc = "Checks if the value of the field is `PORTF_PIN7`"]
# [inline (always)]
pub fn is_portf_pin7 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN7 } # [doc = "Checks if the value of the field is `PRESCALER_1`"]
# [inline (always)]
pub fn is_prescaler_1 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1 } # [doc = "Checks if the value of the field is `PRESCALER_2`"]
# [inline (always)]
pub fn is_prescaler_2 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2 } # [doc = "Checks if the value of the field is `PRESCALER_4`"]
# [inline (always)]
pub fn is_prescaler_4 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4 } # [doc = "Checks if the value of the field is `PRESCALER_8`"]
# [inline (always)]
pub fn is_prescaler_8 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8 } # [doc = "Checks if the value of the field is `PRESCALER_16`"]
# [inline (always)]
pub fn is_prescaler_16 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16 } # [doc = "Checks if the value of the field is `PRESCALER_32`"]
# [inline (always)]
pub fn is_prescaler_32 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32 } # [doc = "Checks if the value of the field is `PRESCALER_64`"]
# [inline (always)]
pub fn is_prescaler_64 (& self) -> bool { * self == CHMUX_A :: PRESCALER_64 } # [doc = "Checks if the value of the field is `PRESCALER_128`"]
# [inline (always)]
pub fn is_prescaler_128 (& self) -> bool { * self == CHMUX_A :: PRESCALER_128 } # [doc = "Checks if the value of the field is `PRESCALER_256`"]
# [inline (always)]
pub fn is_prescaler_256 (& self) -> bool { * self == CHMUX_A :: PRESCALER_256 } # [doc = "Checks if the value of the field is `PRESCALER_512`"]
# [inline (always)]
pub fn is_prescaler_512 (& self) -> bool { * self == CHMUX_A :: PRESCALER_512 } # [doc = "Checks if the value of the field is `PRESCALER_1024`"]
# [inline (always)]
pub fn is_prescaler_1024 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1024 } # [doc = "Checks if the value of the field is `PRESCALER_2048`"]
# [inline (always)]
pub fn is_prescaler_2048 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2048 } # [doc = "Checks if the value of the field is `PRESCALER_4096`"]
# [inline (always)]
pub fn is_prescaler_4096 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4096 } # [doc = "Checks if the value of the field is `PRESCALER_8192`"]
# [inline (always)]
pub fn is_prescaler_8192 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8192 } # [doc = "Checks if the value of the field is `PRESCALER_16384`"]
# [inline (always)]
pub fn is_prescaler_16384 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16384 } # [doc = "Checks if the value of the field is `PRESCALER_32768`"]
# [inline (always)]
pub fn is_prescaler_32768 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32768 } # [doc = "Checks if the value of the field is `TCC0_OVF`"]
# [inline (always)]
pub fn is_tcc0_ovf (& self) -> bool { * self == CHMUX_A :: TCC0_OVF } # [doc = "Checks if the value of the field is `TCC0_ERR`"]
# [inline (always)]
pub fn is_tcc0_err (& self) -> bool { * self == CHMUX_A :: TCC0_ERR } # [doc = "Checks if the value of the field is `TCC0_CCA`"]
# [inline (always)]
pub fn is_tcc0_cca (& self) -> bool { * self == CHMUX_A :: TCC0_CCA } # [doc = "Checks if the value of the field is `TCC0_CCB`"]
# [inline (always)]
pub fn is_tcc0_ccb (& self) -> bool { * self == CHMUX_A :: TCC0_CCB } # [doc = "Checks if the value of the field is `TCC0_CCC`"]
# [inline (always)]
pub fn is_tcc0_ccc (& self) -> bool { * self == CHMUX_A :: TCC0_CCC } # [doc = "Checks if the value of the field is `TCC0_CCD`"]
# [inline (always)]
pub fn is_tcc0_ccd (& self) -> bool { * self == CHMUX_A :: TCC0_CCD } # [doc = "Checks if the value of the field is `TCC1_OVF`"]
# [inline (always)]
pub fn is_tcc1_ovf (& self) -> bool { * self == CHMUX_A :: TCC1_OVF } # [doc = "Checks if the value of the field is `TCC1_ERR`"]
# [inline (always)]
pub fn is_tcc1_err (& self) -> bool { * self == CHMUX_A :: TCC1_ERR } # [doc = "Checks if the value of the field is `TCC1_CCA`"]
# [inline (always)]
pub fn is_tcc1_cca (& self) -> bool { * self == CHMUX_A :: TCC1_CCA } # [doc = "Checks if the value of the field is `TCC1_CCB`"]
# [inline (always)]
pub fn is_tcc1_ccb (& self) -> bool { * self == CHMUX_A :: TCC1_CCB } # [doc = "Checks if the value of the field is `TCD0_OVF`"]
# [inline (always)]
pub fn is_tcd0_ovf (& self) -> bool { * self == CHMUX_A :: TCD0_OVF } # [doc = "Checks if the value of the field is `TCD0_ERR`"]
# [inline (always)]
pub fn is_tcd0_err (& self) -> bool { * self == CHMUX_A :: TCD0_ERR } # [doc = "Checks if the value of the field is `TCD0_CCA`"]
# [inline (always)]
pub fn is_tcd0_cca (& self) -> bool { * self == CHMUX_A :: TCD0_CCA } # [doc = "Checks if the value of the field is `TCD0_CCB`"]
# [inline (always)]
pub fn is_tcd0_ccb (& self) -> bool { * self == CHMUX_A :: TCD0_CCB } # [doc = "Checks if the value of the field is `TCD0_CCC`"]
# [inline (always)]
pub fn is_tcd0_ccc (& self) -> bool { * self == CHMUX_A :: TCD0_CCC } # [doc = "Checks if the value of the field is `TCD0_CCD`"]
# [inline (always)]
pub fn is_tcd0_ccd (& self) -> bool { * self == CHMUX_A :: TCD0_CCD } # [doc = "Checks if the value of the field is `TCD1_OVF`"]
# [inline (always)]
pub fn is_tcd1_ovf (& self) -> bool { * self == CHMUX_A :: TCD1_OVF } # [doc = "Checks if the value of the field is `TCD1_ERR`"]
# [inline (always)]
pub fn is_tcd1_err (& self) -> bool { * self == CHMUX_A :: TCD1_ERR } # [doc = "Checks if the value of the field is `TCD1_CCA`"]
# [inline (always)]
pub fn is_tcd1_cca (& self) -> bool { * self == CHMUX_A :: TCD1_CCA } # [doc = "Checks if the value of the field is `TCD1_CCB`"]
# [inline (always)]
pub fn is_tcd1_ccb (& self) -> bool { * self == CHMUX_A :: TCD1_CCB } # [doc = "Checks if the value of the field is `TCE0_OVF`"]
# [inline (always)]
pub fn is_tce0_ovf (& self) -> bool { * self == CHMUX_A :: TCE0_OVF } # [doc = "Checks if the value of the field is `TCE0_ERR`"]
# [inline (always)]
pub fn is_tce0_err (& self) -> bool { * self == CHMUX_A :: TCE0_ERR } # [doc = "Checks if the value of the field is `TCE0_CCA`"]
# [inline (always)]
pub fn is_tce0_cca (& self) -> bool { * self == CHMUX_A :: TCE0_CCA } # [doc = "Checks if the value of the field is `TCE0_CCB`"]
# [inline (always)]
pub fn is_tce0_ccb (& self) -> bool { * self == CHMUX_A :: TCE0_CCB } # [doc = "Checks if the value of the field is `TCE0_CCC`"]
# [inline (always)]
pub fn is_tce0_ccc (& self) -> bool { * self == CHMUX_A :: TCE0_CCC } # [doc = "Checks if the value of the field is `TCE0_CCD`"]
# [inline (always)]
pub fn is_tce0_ccd (& self) -> bool { * self == CHMUX_A :: TCE0_CCD } # [doc = "Checks if the value of the field is `TCE1_OVF`"]
# [inline (always)]
pub fn is_tce1_ovf (& self) -> bool { * self == CHMUX_A :: TCE1_OVF } # [doc = "Checks if the value of the field is `TCE1_ERR`"]
# [inline (always)]
pub fn is_tce1_err (& self) -> bool { * self == CHMUX_A :: TCE1_ERR } # [doc = "Checks if the value of the field is `TCE1_CCA`"]
# [inline (always)]
pub fn is_tce1_cca (& self) -> bool { * self == CHMUX_A :: TCE1_CCA } # [doc = "Checks if the value of the field is `TCE1_CCB`"]
# [inline (always)]
pub fn is_tce1_ccb (& self) -> bool { * self == CHMUX_A :: TCE1_CCB } # [doc = "Checks if the value of the field is `TCF0_OVF`"]
# [inline (always)]
pub fn is_tcf0_ovf (& self) -> bool { * self == CHMUX_A :: TCF0_OVF } # [doc = "Checks if the value of the field is `TCF0_ERR`"]
# [inline (always)]
pub fn is_tcf0_err (& self) -> bool { * self == CHMUX_A :: TCF0_ERR } # [doc = "Checks if the value of the field is `TCF0_CCA`"]
# [inline (always)]
pub fn is_tcf0_cca (& self) -> bool { * self == CHMUX_A :: TCF0_CCA } # [doc = "Checks if the value of the field is `TCF0_CCB`"]
# [inline (always)]
pub fn is_tcf0_ccb (& self) -> bool { * self == CHMUX_A :: TCF0_CCB } # [doc = "Checks if the value of the field is `TCF0_CCC`"]
# [inline (always)]
pub fn is_tcf0_ccc (& self) -> bool { * self == CHMUX_A :: TCF0_CCC } # [doc = "Checks if the value of the field is `TCF0_CCD`"]
# [inline (always)]
pub fn is_tcf0_ccd (& self) -> bool { * self == CHMUX_A :: TCF0_CCD } # [doc = "Checks if the value of the field is `TCF1_OVF`"]
# [inline (always)]
pub fn is_tcf1_ovf (& self) -> bool { * self == CHMUX_A :: TCF1_OVF } # [doc = "Checks if the value of the field is `TCF1_ERR`"]
# [inline (always)]
pub fn is_tcf1_err (& self) -> bool { * self == CHMUX_A :: TCF1_ERR } # [doc = "Checks if the value of the field is `TCF1_CCA`"]
# [inline (always)]
pub fn is_tcf1_cca (& self) -> bool { * self == CHMUX_A :: TCF1_CCA } # [doc = "Checks if the value of the field is `TCF1_CCB`"]
# [inline (always)]
pub fn is_tcf1_ccb (& self) -> bool { * self == CHMUX_A :: TCF1_CCB } } # [doc = "Field `CHMUX` writer - Event Channel 5 Multiplexer"]
pub type CHMUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CH5MUX_SPEC , u8 , CHMUX_A , 8 , O > ; impl < 'a , const O : u8 > CHMUX_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHMUX_A :: OFF) } # [doc = "RTC Overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_OVF) } # [doc = "RTC Compare Match"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_CMP) } # [doc = "Analog Comparator A Channel 0"]
# [inline (always)]
pub fn aca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH0) } # [doc = "Analog Comparator A Channel 1"]
# [inline (always)]
pub fn aca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH1) } # [doc = "Analog Comparator A Window"]
# [inline (always)]
pub fn aca_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_WIN) } # [doc = "Analog Comparator B Channel 0"]
# [inline (always)]
pub fn acb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH0) } # [doc = "Analog Comparator B Channel 1"]
# [inline (always)]
pub fn acb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH1) } # [doc = "Analog Comparator B Window"]
# [inline (always)]
pub fn acb_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_WIN) } # [doc = "ADC A Channel 0"]
# [inline (always)]
pub fn adca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH0) } # [doc = "ADC A Channel 1"]
# [inline (always)]
pub fn adca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH1) } # [doc = "ADC A Channel 2"]
# [inline (always)]
pub fn adca_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH2) } # [doc = "ADC A Channel 3"]
# [inline (always)]
pub fn adca_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH3) } # [doc = "ADC B Channel 0"]
# [inline (always)]
pub fn adcb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH0) } # [doc = "ADC B Channel 1"]
# [inline (always)]
pub fn adcb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH1) } # [doc = "ADC B Channel 2"]
# [inline (always)]
pub fn adcb_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH2) } # [doc = "ADC B Channel 3"]
# [inline (always)]
pub fn adcb_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH3) } # [doc = "Port A, Pin0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN0) } # [doc = "Port A, Pin1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN1) } # [doc = "Port A, Pin2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN2) } # [doc = "Port A, Pin3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN3) } # [doc = "Port A, Pin4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN4) } # [doc = "Port A, Pin5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN5) } # [doc = "Port A, Pin6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN6) } # [doc = "Port A, Pin7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN7) } # [doc = "Port B, Pin0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN0) } # [doc = "Port B, Pin1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN1) } # [doc = "Port B, Pin2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN2) } # [doc = "Port B, Pin3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN3) } # [doc = "Port B, Pin4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN4) } # [doc = "Port B, Pin5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN5) } # [doc = "Port B, Pin6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN6) } # [doc = "Port B, Pin7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN7) } # [doc = "Port C, Pin0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN0) } # [doc = "Port C, Pin1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN1) } # [doc = "Port C, Pin2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN2) } # [doc = "Port C, Pin3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN3) } # [doc = "Port C, Pin4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN4) } # [doc = "Port C, Pin5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN5) } # [doc = "Port C, Pin6"]
# [inline (always)]
pub fn portc_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN6) } # [doc = "Port C, Pin7"]
# [inline (always)]
pub fn portc_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN7) } # [doc = "Port D, Pin0"]
# [inline (always)]
pub fn portd_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN0) } # [doc = "Port D, Pin1"]
# [inline (always)]
pub fn portd_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN1) } # [doc = "Port D, Pin2"]
# [inline (always)]
pub fn portd_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN2) } # [doc = "Port D, Pin3"]
# [inline (always)]
pub fn portd_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN3) } # [doc = "Port D, Pin4"]
# [inline (always)]
pub fn portd_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN4) } # [doc = "Port D, Pin5"]
# [inline (always)]
pub fn portd_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN5) } # [doc = "Port D, Pin6"]
# [inline (always)]
pub fn portd_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN6) } # [doc = "Port D, Pin7"]
# [inline (always)]
pub fn portd_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN7) } # [doc = "Port E, Pin0"]
# [inline (always)]
pub fn porte_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN0) } # [doc = "Port E, Pin1"]
# [inline (always)]
pub fn porte_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN1) } # [doc = "Port E, Pin2"]
# [inline (always)]
pub fn porte_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN2) } # [doc = "Port E, Pin3"]
# [inline (always)]
pub fn porte_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN3) } # [doc = "Port E, Pin4"]
# [inline (always)]
pub fn porte_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN4) } # [doc = "Port E, Pin5"]
# [inline (always)]
pub fn porte_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN5) } # [doc = "Port E, Pin6"]
# [inline (always)]
pub fn porte_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN6) } # [doc = "Port E, Pin7"]
# [inline (always)]
pub fn porte_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN7) } # [doc = "Port F, Pin0"]
# [inline (always)]
pub fn portf_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN0) } # [doc = "Port F, Pin1"]
# [inline (always)]
pub fn portf_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN1) } # [doc = "Port F, Pin2"]
# [inline (always)]
pub fn portf_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN2) } # [doc = "Port F, Pin3"]
# [inline (always)]
pub fn portf_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN3) } # [doc = "Port F, Pin4"]
# [inline (always)]
pub fn portf_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN4) } # [doc = "Port F, Pin5"]
# [inline (always)]
pub fn portf_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN5) } # [doc = "Port F, Pin6"]
# [inline (always)]
pub fn portf_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN6) } # [doc = "Port F, Pin7"]
# [inline (always)]
pub fn portf_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN7) } # [doc = "Prescaler, divide by 1"]
# [inline (always)]
pub fn prescaler_1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1) } # [doc = "Prescaler, divide by 2"]
# [inline (always)]
pub fn prescaler_2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2) } # [doc = "Prescaler, divide by 4"]
# [inline (always)]
pub fn prescaler_4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4) } # [doc = "Prescaler, divide by 8"]
# [inline (always)]
pub fn prescaler_8 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8) } # [doc = "Prescaler, divide by 16"]
# [inline (always)]
pub fn prescaler_16 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16) } # [doc = "Prescaler, divide by 32"]
# [inline (always)]
pub fn prescaler_32 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32) } # [doc = "Prescaler, divide by 64"]
# [inline (always)]
pub fn prescaler_64 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_64) } # [doc = "Prescaler, divide by 128"]
# [inline (always)]
pub fn prescaler_128 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_128) } # [doc = "Prescaler, divide by 256"]
# [inline (always)]
pub fn prescaler_256 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_256) } # [doc = "Prescaler, divide by 512"]
# [inline (always)]
pub fn prescaler_512 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_512) } # [doc = "Prescaler, divide by 1024"]
# [inline (always)]
pub fn prescaler_1024 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1024) } # [doc = "Prescaler, divide by 2048"]
# [inline (always)]
pub fn prescaler_2048 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2048) } # [doc = "Prescaler, divide by 4096"]
# [inline (always)]
pub fn prescaler_4096 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4096) } # [doc = "Prescaler, divide by 8192"]
# [inline (always)]
pub fn prescaler_8192 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8192) } # [doc = "Prescaler, divide by 16384"]
# [inline (always)]
pub fn prescaler_16384 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16384) } # [doc = "Prescaler, divide by 32768"]
# [inline (always)]
pub fn prescaler_32768 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32768) } # [doc = "Timer/Counter C0 Overflow"]
# [inline (always)]
pub fn tcc0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_OVF) } # [doc = "Timer/Counter C0 Error"]
# [inline (always)]
pub fn tcc0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_ERR) } # [doc = "Timer/Counter C0 Compare or Capture A"]
# [inline (always)]
pub fn tcc0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCA) } # [doc = "Timer/Counter C0 Compare or Capture B"]
# [inline (always)]
pub fn tcc0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCB) } # [doc = "Timer/Counter C0 Compare or Capture C"]
# [inline (always)]
pub fn tcc0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCC) } # [doc = "Timer/Counter C0 Compare or Capture D"]
# [inline (always)]
pub fn tcc0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCD) } # [doc = "Timer/Counter C1 Overflow"]
# [inline (always)]
pub fn tcc1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_OVF) } # [doc = "Timer/Counter C1 Error"]
# [inline (always)]
pub fn tcc1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_ERR) } # [doc = "Timer/Counter C1 Compare or Capture A"]
# [inline (always)]
pub fn tcc1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCA) } # [doc = "Timer/Counter C1 Compare or Capture B"]
# [inline (always)]
pub fn tcc1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCB) } # [doc = "Timer/Counter D0 Overflow"]
# [inline (always)]
pub fn tcd0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_OVF) } # [doc = "Timer/Counter D0 Error"]
# [inline (always)]
pub fn tcd0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_ERR) } # [doc = "Timer/Counter D0 Compare or Capture A"]
# [inline (always)]
pub fn tcd0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCA) } # [doc = "Timer/Counter D0 Compare or Capture B"]
# [inline (always)]
pub fn tcd0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCB) } # [doc = "Timer/Counter D0 Compare or Capture C"]
# [inline (always)]
pub fn tcd0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCC) } # [doc = "Timer/Counter D0 Compare or Capture D"]
# [inline (always)]
pub fn tcd0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCD) } # [doc = "Timer/Counter D1 Overflow"]
# [inline (always)]
pub fn tcd1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_OVF) } # [doc = "Timer/Counter D1 Error"]
# [inline (always)]
pub fn tcd1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_ERR) } # [doc = "Timer/Counter D1 Compare or Capture A"]
# [inline (always)]
pub fn tcd1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCA) } # [doc = "Timer/Counter D1 Compare or Capture B"]
# [inline (always)]
pub fn tcd1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCB) } # [doc = "Timer/Counter E0 Overflow"]
# [inline (always)]
pub fn tce0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_OVF) } # [doc = "Timer/Counter E0 Error"]
# [inline (always)]
pub fn tce0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_ERR) } # [doc = "Timer/Counter E0 Compare or Capture A"]
# [inline (always)]
pub fn tce0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCA) } # [doc = "Timer/Counter E0 Compare or Capture B"]
# [inline (always)]
pub fn tce0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCB) } # [doc = "Timer/Counter E0 Compare or Capture C"]
# [inline (always)]
pub fn tce0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCC) } # [doc = "Timer/Counter E0 Compare or Capture D"]
# [inline (always)]
pub fn tce0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCD) } # [doc = "Timer/Counter E1 Overflow"]
# [inline (always)]
pub fn tce1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_OVF) } # [doc = "Timer/Counter E1 Error"]
# [inline (always)]
pub fn tce1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_ERR) } # [doc = "Timer/Counter E1 Compare or Capture A"]
# [inline (always)]
pub fn tce1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCA) } # [doc = "Timer/Counter E1 Compare or Capture B"]
# [inline (always)]
pub fn tce1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCB) } # [doc = "Timer/Counter F0 Overflow"]
# [inline (always)]
pub fn tcf0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_OVF) } # [doc = "Timer/Counter F0 Error"]
# [inline (always)]
pub fn tcf0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_ERR) } # [doc = "Timer/Counter F0 Compare or Capture A"]
# [inline (always)]
pub fn tcf0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCA) } # [doc = "Timer/Counter F0 Compare or Capture B"]
# [inline (always)]
pub fn tcf0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCB) } # [doc = "Timer/Counter F0 Compare or Capture C"]
# [inline (always)]
pub fn tcf0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCC) } # [doc = "Timer/Counter F0 Compare or Capture D"]
# [inline (always)]
pub fn tcf0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCD) } # [doc = "Timer/Counter F1 Overflow"]
# [inline (always)]
pub fn tcf1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_OVF) } # [doc = "Timer/Counter F1 Error"]
# [inline (always)]
pub fn tcf1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_ERR) } # [doc = "Timer/Counter F1 Compare or Capture A"]
# [inline (always)]
pub fn tcf1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCA) } # [doc = "Timer/Counter F1 Compare or Capture B"]
# [inline (always)]
pub fn tcf1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCB) } } impl R { # [doc = "Bits 0:7 - Event Channel 5 Multiplexer"]
# [inline (always)]
pub fn chmux (& self) -> CHMUX_R { CHMUX_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Event Channel 5 Multiplexer"]
# [inline (always)]
# [must_use]
pub fn chmux (& mut self) -> CHMUX_W < 0 > { CHMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Channel 5 Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch5mux](index.html) module"]
pub struct CH5MUX_SPEC ; impl crate :: RegisterSpec for CH5MUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch5mux::R](R) reader structure"]
impl crate :: Readable for CH5MUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch5mux::W](W) writer structure"]
impl crate :: Writable for CH5MUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH5MUX to value 0"]
impl crate :: Resettable for CH5MUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH6CTRL (rw) register accessor: an alias for `Reg<CH6CTRL_SPEC>`"]
pub type CH6CTRL = crate :: Reg < ch6ctrl :: CH6CTRL_SPEC > ; # [doc = "Channel 6 Control Register"]
pub mod ch6ctrl { # [doc = "Register `CH6CTRL` reader"]
pub struct R (crate :: R < CH6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH6CTRL` writer"]
pub struct W (crate :: W < CH6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIGFILT` reader - Digital Filter"]
pub type DIGFILT_R = crate :: FieldReader < u8 , DIGFILT_A > ; # [doc = "Digital Filter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DIGFILT_A { # [doc = "0: 1 SAMPLE"]
_1SAMPLE = 0 , # [doc = "1: 2 SAMPLES"]
_2SAMPLES = 1 , # [doc = "2: 3 SAMPLES"]
_3SAMPLES = 2 , # [doc = "3: 4 SAMPLES"]
_4SAMPLES = 3 , # [doc = "4: 5 SAMPLES"]
_5SAMPLES = 4 , # [doc = "5: 6 SAMPLES"]
_6SAMPLES = 5 , # [doc = "6: 7 SAMPLES"]
_7SAMPLES = 6 , # [doc = "7: 8 SAMPLES"]
_8SAMPLES = 7 , } impl From < DIGFILT_A > for u8 { # [inline (always)]
fn from (variant : DIGFILT_A) -> Self { variant as _ } } impl DIGFILT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIGFILT_A { match self . bits { 0 => DIGFILT_A :: _1SAMPLE , 1 => DIGFILT_A :: _2SAMPLES , 2 => DIGFILT_A :: _3SAMPLES , 3 => DIGFILT_A :: _4SAMPLES , 4 => DIGFILT_A :: _5SAMPLES , 5 => DIGFILT_A :: _6SAMPLES , 6 => DIGFILT_A :: _7SAMPLES , 7 => DIGFILT_A :: _8SAMPLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1SAMPLE`"]
# [inline (always)]
pub fn is_1sample (& self) -> bool { * self == DIGFILT_A :: _1SAMPLE } # [doc = "Checks if the value of the field is `_2SAMPLES`"]
# [inline (always)]
pub fn is_2samples (& self) -> bool { * self == DIGFILT_A :: _2SAMPLES } # [doc = "Checks if the value of the field is `_3SAMPLES`"]
# [inline (always)]
pub fn is_3samples (& self) -> bool { * self == DIGFILT_A :: _3SAMPLES } # [doc = "Checks if the value of the field is `_4SAMPLES`"]
# [inline (always)]
pub fn is_4samples (& self) -> bool { * self == DIGFILT_A :: _4SAMPLES } # [doc = "Checks if the value of the field is `_5SAMPLES`"]
# [inline (always)]
pub fn is_5samples (& self) -> bool { * self == DIGFILT_A :: _5SAMPLES } # [doc = "Checks if the value of the field is `_6SAMPLES`"]
# [inline (always)]
pub fn is_6samples (& self) -> bool { * self == DIGFILT_A :: _6SAMPLES } # [doc = "Checks if the value of the field is `_7SAMPLES`"]
# [inline (always)]
pub fn is_7samples (& self) -> bool { * self == DIGFILT_A :: _7SAMPLES } # [doc = "Checks if the value of the field is `_8SAMPLES`"]
# [inline (always)]
pub fn is_8samples (& self) -> bool { * self == DIGFILT_A :: _8SAMPLES } } # [doc = "Field `DIGFILT` writer - Digital Filter"]
pub type DIGFILT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH6CTRL_SPEC , u8 , DIGFILT_A , 3 , O > ; impl < 'a , const O : u8 > DIGFILT_W < 'a , O > { # [doc = "1 SAMPLE"]
# [inline (always)]
pub fn _1sample (self) -> & 'a mut W { self . variant (DIGFILT_A :: _1SAMPLE) } # [doc = "2 SAMPLES"]
# [inline (always)]
pub fn _2samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _2SAMPLES) } # [doc = "3 SAMPLES"]
# [inline (always)]
pub fn _3samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _3SAMPLES) } # [doc = "4 SAMPLES"]
# [inline (always)]
pub fn _4samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _4SAMPLES) } # [doc = "5 SAMPLES"]
# [inline (always)]
pub fn _5samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _5SAMPLES) } # [doc = "6 SAMPLES"]
# [inline (always)]
pub fn _6samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _6SAMPLES) } # [doc = "7 SAMPLES"]
# [inline (always)]
pub fn _7samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _7SAMPLES) } # [doc = "8 SAMPLES"]
# [inline (always)]
pub fn _8samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _8SAMPLES) } } impl R { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
pub fn digfilt (& self) -> DIGFILT_R { DIGFILT_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
# [must_use]
pub fn digfilt (& mut self) -> DIGFILT_W < 0 > { DIGFILT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch6ctrl](index.html) module"]
pub struct CH6CTRL_SPEC ; impl crate :: RegisterSpec for CH6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch6ctrl::R](R) reader structure"]
impl crate :: Readable for CH6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch6ctrl::W](W) writer structure"]
impl crate :: Writable for CH6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH6CTRL to value 0"]
impl crate :: Resettable for CH6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH6MUX (rw) register accessor: an alias for `Reg<CH6MUX_SPEC>`"]
pub type CH6MUX = crate :: Reg < ch6mux :: CH6MUX_SPEC > ; # [doc = "Event Channel 6 Multiplexer"]
pub mod ch6mux { # [doc = "Register `CH6MUX` reader"]
pub struct R (crate :: R < CH6MUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH6MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH6MUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH6MUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH6MUX` writer"]
pub struct W (crate :: W < CH6MUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH6MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH6MUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH6MUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHMUX` reader - Event Channel 6 Multiplexer"]
pub type CHMUX_R = crate :: FieldReader < u8 , CHMUX_A > ; # [doc = "Event Channel 6 Multiplexer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHMUX_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "8: RTC Overflow"]
RTC_OVF = 8 , # [doc = "9: RTC Compare Match"]
RTC_CMP = 9 , # [doc = "16: Analog Comparator A Channel 0"]
ACA_CH0 = 16 , # [doc = "17: Analog Comparator A Channel 1"]
ACA_CH1 = 17 , # [doc = "18: Analog Comparator A Window"]
ACA_WIN = 18 , # [doc = "19: Analog Comparator B Channel 0"]
ACB_CH0 = 19 , # [doc = "20: Analog Comparator B Channel 1"]
ACB_CH1 = 20 , # [doc = "21: Analog Comparator B Window"]
ACB_WIN = 21 , # [doc = "32: ADC A Channel 0"]
ADCA_CH0 = 32 , # [doc = "33: ADC A Channel 1"]
ADCA_CH1 = 33 , # [doc = "34: ADC A Channel 2"]
ADCA_CH2 = 34 , # [doc = "35: ADC A Channel 3"]
ADCA_CH3 = 35 , # [doc = "36: ADC B Channel 0"]
ADCB_CH0 = 36 , # [doc = "37: ADC B Channel 1"]
ADCB_CH1 = 37 , # [doc = "38: ADC B Channel 2"]
ADCB_CH2 = 38 , # [doc = "39: ADC B Channel 3"]
ADCB_CH3 = 39 , # [doc = "80: Port A, Pin0"]
PORTA_PIN0 = 80 , # [doc = "81: Port A, Pin1"]
PORTA_PIN1 = 81 , # [doc = "82: Port A, Pin2"]
PORTA_PIN2 = 82 , # [doc = "83: Port A, Pin3"]
PORTA_PIN3 = 83 , # [doc = "84: Port A, Pin4"]
PORTA_PIN4 = 84 , # [doc = "85: Port A, Pin5"]
PORTA_PIN5 = 85 , # [doc = "86: Port A, Pin6"]
PORTA_PIN6 = 86 , # [doc = "87: Port A, Pin7"]
PORTA_PIN7 = 87 , # [doc = "88: Port B, Pin0"]
PORTB_PIN0 = 88 , # [doc = "89: Port B, Pin1"]
PORTB_PIN1 = 89 , # [doc = "90: Port B, Pin2"]
PORTB_PIN2 = 90 , # [doc = "91: Port B, Pin3"]
PORTB_PIN3 = 91 , # [doc = "92: Port B, Pin4"]
PORTB_PIN4 = 92 , # [doc = "93: Port B, Pin5"]
PORTB_PIN5 = 93 , # [doc = "94: Port B, Pin6"]
PORTB_PIN6 = 94 , # [doc = "95: Port B, Pin7"]
PORTB_PIN7 = 95 , # [doc = "96: Port C, Pin0"]
PORTC_PIN0 = 96 , # [doc = "97: Port C, Pin1"]
PORTC_PIN1 = 97 , # [doc = "98: Port C, Pin2"]
PORTC_PIN2 = 98 , # [doc = "99: Port C, Pin3"]
PORTC_PIN3 = 99 , # [doc = "100: Port C, Pin4"]
PORTC_PIN4 = 100 , # [doc = "101: Port C, Pin5"]
PORTC_PIN5 = 101 , # [doc = "102: Port C, Pin6"]
PORTC_PIN6 = 102 , # [doc = "103: Port C, Pin7"]
PORTC_PIN7 = 103 , # [doc = "104: Port D, Pin0"]
PORTD_PIN0 = 104 , # [doc = "105: Port D, Pin1"]
PORTD_PIN1 = 105 , # [doc = "106: Port D, Pin2"]
PORTD_PIN2 = 106 , # [doc = "107: Port D, Pin3"]
PORTD_PIN3 = 107 , # [doc = "108: Port D, Pin4"]
PORTD_PIN4 = 108 , # [doc = "109: Port D, Pin5"]
PORTD_PIN5 = 109 , # [doc = "110: Port D, Pin6"]
PORTD_PIN6 = 110 , # [doc = "111: Port D, Pin7"]
PORTD_PIN7 = 111 , # [doc = "112: Port E, Pin0"]
PORTE_PIN0 = 112 , # [doc = "113: Port E, Pin1"]
PORTE_PIN1 = 113 , # [doc = "114: Port E, Pin2"]
PORTE_PIN2 = 114 , # [doc = "115: Port E, Pin3"]
PORTE_PIN3 = 115 , # [doc = "116: Port E, Pin4"]
PORTE_PIN4 = 116 , # [doc = "117: Port E, Pin5"]
PORTE_PIN5 = 117 , # [doc = "118: Port E, Pin6"]
PORTE_PIN6 = 118 , # [doc = "119: Port E, Pin7"]
PORTE_PIN7 = 119 , # [doc = "120: Port F, Pin0"]
PORTF_PIN0 = 120 , # [doc = "121: Port F, Pin1"]
PORTF_PIN1 = 121 , # [doc = "122: Port F, Pin2"]
PORTF_PIN2 = 122 , # [doc = "123: Port F, Pin3"]
PORTF_PIN3 = 123 , # [doc = "124: Port F, Pin4"]
PORTF_PIN4 = 124 , # [doc = "125: Port F, Pin5"]
PORTF_PIN5 = 125 , # [doc = "126: Port F, Pin6"]
PORTF_PIN6 = 126 , # [doc = "127: Port F, Pin7"]
PORTF_PIN7 = 127 , # [doc = "128: Prescaler, divide by 1"]
PRESCALER_1 = 128 , # [doc = "129: Prescaler, divide by 2"]
PRESCALER_2 = 129 , # [doc = "130: Prescaler, divide by 4"]
PRESCALER_4 = 130 , # [doc = "131: Prescaler, divide by 8"]
PRESCALER_8 = 131 , # [doc = "132: Prescaler, divide by 16"]
PRESCALER_16 = 132 , # [doc = "133: Prescaler, divide by 32"]
PRESCALER_32 = 133 , # [doc = "134: Prescaler, divide by 64"]
PRESCALER_64 = 134 , # [doc = "135: Prescaler, divide by 128"]
PRESCALER_128 = 135 , # [doc = "136: Prescaler, divide by 256"]
PRESCALER_256 = 136 , # [doc = "137: Prescaler, divide by 512"]
PRESCALER_512 = 137 , # [doc = "138: Prescaler, divide by 1024"]
PRESCALER_1024 = 138 , # [doc = "139: Prescaler, divide by 2048"]
PRESCALER_2048 = 139 , # [doc = "140: Prescaler, divide by 4096"]
PRESCALER_4096 = 140 , # [doc = "141: Prescaler, divide by 8192"]
PRESCALER_8192 = 141 , # [doc = "142: Prescaler, divide by 16384"]
PRESCALER_16384 = 142 , # [doc = "143: Prescaler, divide by 32768"]
PRESCALER_32768 = 143 , # [doc = "192: Timer/Counter C0 Overflow"]
TCC0_OVF = 192 , # [doc = "193: Timer/Counter C0 Error"]
TCC0_ERR = 193 , # [doc = "196: Timer/Counter C0 Compare or Capture A"]
TCC0_CCA = 196 , # [doc = "197: Timer/Counter C0 Compare or Capture B"]
TCC0_CCB = 197 , # [doc = "198: Timer/Counter C0 Compare or Capture C"]
TCC0_CCC = 198 , # [doc = "199: Timer/Counter C0 Compare or Capture D"]
TCC0_CCD = 199 , # [doc = "200: Timer/Counter C1 Overflow"]
TCC1_OVF = 200 , # [doc = "201: Timer/Counter C1 Error"]
TCC1_ERR = 201 , # [doc = "204: Timer/Counter C1 Compare or Capture A"]
TCC1_CCA = 204 , # [doc = "205: Timer/Counter C1 Compare or Capture B"]
TCC1_CCB = 205 , # [doc = "208: Timer/Counter D0 Overflow"]
TCD0_OVF = 208 , # [doc = "209: Timer/Counter D0 Error"]
TCD0_ERR = 209 , # [doc = "212: Timer/Counter D0 Compare or Capture A"]
TCD0_CCA = 212 , # [doc = "213: Timer/Counter D0 Compare or Capture B"]
TCD0_CCB = 213 , # [doc = "214: Timer/Counter D0 Compare or Capture C"]
TCD0_CCC = 214 , # [doc = "215: Timer/Counter D0 Compare or Capture D"]
TCD0_CCD = 215 , # [doc = "216: Timer/Counter D1 Overflow"]
TCD1_OVF = 216 , # [doc = "217: Timer/Counter D1 Error"]
TCD1_ERR = 217 , # [doc = "220: Timer/Counter D1 Compare or Capture A"]
TCD1_CCA = 220 , # [doc = "221: Timer/Counter D1 Compare or Capture B"]
TCD1_CCB = 221 , # [doc = "224: Timer/Counter E0 Overflow"]
TCE0_OVF = 224 , # [doc = "225: Timer/Counter E0 Error"]
TCE0_ERR = 225 , # [doc = "228: Timer/Counter E0 Compare or Capture A"]
TCE0_CCA = 228 , # [doc = "229: Timer/Counter E0 Compare or Capture B"]
TCE0_CCB = 229 , # [doc = "230: Timer/Counter E0 Compare or Capture C"]
TCE0_CCC = 230 , # [doc = "231: Timer/Counter E0 Compare or Capture D"]
TCE0_CCD = 231 , # [doc = "232: Timer/Counter E1 Overflow"]
TCE1_OVF = 232 , # [doc = "233: Timer/Counter E1 Error"]
TCE1_ERR = 233 , # [doc = "236: Timer/Counter E1 Compare or Capture A"]
TCE1_CCA = 236 , # [doc = "237: Timer/Counter E1 Compare or Capture B"]
TCE1_CCB = 237 , # [doc = "240: Timer/Counter F0 Overflow"]
TCF0_OVF = 240 , # [doc = "241: Timer/Counter F0 Error"]
TCF0_ERR = 241 , # [doc = "244: Timer/Counter F0 Compare or Capture A"]
TCF0_CCA = 244 , # [doc = "245: Timer/Counter F0 Compare or Capture B"]
TCF0_CCB = 245 , # [doc = "246: Timer/Counter F0 Compare or Capture C"]
TCF0_CCC = 246 , # [doc = "247: Timer/Counter F0 Compare or Capture D"]
TCF0_CCD = 247 , # [doc = "248: Timer/Counter F1 Overflow"]
TCF1_OVF = 248 , # [doc = "249: Timer/Counter F1 Error"]
TCF1_ERR = 249 , # [doc = "252: Timer/Counter F1 Compare or Capture A"]
TCF1_CCA = 252 , # [doc = "253: Timer/Counter F1 Compare or Capture B"]
TCF1_CCB = 253 , } impl From < CHMUX_A > for u8 { # [inline (always)]
fn from (variant : CHMUX_A) -> Self { variant as _ } } impl CHMUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHMUX_A > { match self . bits { 0 => Some (CHMUX_A :: OFF) , 8 => Some (CHMUX_A :: RTC_OVF) , 9 => Some (CHMUX_A :: RTC_CMP) , 16 => Some (CHMUX_A :: ACA_CH0) , 17 => Some (CHMUX_A :: ACA_CH1) , 18 => Some (CHMUX_A :: ACA_WIN) , 19 => Some (CHMUX_A :: ACB_CH0) , 20 => Some (CHMUX_A :: ACB_CH1) , 21 => Some (CHMUX_A :: ACB_WIN) , 32 => Some (CHMUX_A :: ADCA_CH0) , 33 => Some (CHMUX_A :: ADCA_CH1) , 34 => Some (CHMUX_A :: ADCA_CH2) , 35 => Some (CHMUX_A :: ADCA_CH3) , 36 => Some (CHMUX_A :: ADCB_CH0) , 37 => Some (CHMUX_A :: ADCB_CH1) , 38 => Some (CHMUX_A :: ADCB_CH2) , 39 => Some (CHMUX_A :: ADCB_CH3) , 80 => Some (CHMUX_A :: PORTA_PIN0) , 81 => Some (CHMUX_A :: PORTA_PIN1) , 82 => Some (CHMUX_A :: PORTA_PIN2) , 83 => Some (CHMUX_A :: PORTA_PIN3) , 84 => Some (CHMUX_A :: PORTA_PIN4) , 85 => Some (CHMUX_A :: PORTA_PIN5) , 86 => Some (CHMUX_A :: PORTA_PIN6) , 87 => Some (CHMUX_A :: PORTA_PIN7) , 88 => Some (CHMUX_A :: PORTB_PIN0) , 89 => Some (CHMUX_A :: PORTB_PIN1) , 90 => Some (CHMUX_A :: PORTB_PIN2) , 91 => Some (CHMUX_A :: PORTB_PIN3) , 92 => Some (CHMUX_A :: PORTB_PIN4) , 93 => Some (CHMUX_A :: PORTB_PIN5) , 94 => Some (CHMUX_A :: PORTB_PIN6) , 95 => Some (CHMUX_A :: PORTB_PIN7) , 96 => Some (CHMUX_A :: PORTC_PIN0) , 97 => Some (CHMUX_A :: PORTC_PIN1) , 98 => Some (CHMUX_A :: PORTC_PIN2) , 99 => Some (CHMUX_A :: PORTC_PIN3) , 100 => Some (CHMUX_A :: PORTC_PIN4) , 101 => Some (CHMUX_A :: PORTC_PIN5) , 102 => Some (CHMUX_A :: PORTC_PIN6) , 103 => Some (CHMUX_A :: PORTC_PIN7) , 104 => Some (CHMUX_A :: PORTD_PIN0) , 105 => Some (CHMUX_A :: PORTD_PIN1) , 106 => Some (CHMUX_A :: PORTD_PIN2) , 107 => Some (CHMUX_A :: PORTD_PIN3) , 108 => Some (CHMUX_A :: PORTD_PIN4) , 109 => Some (CHMUX_A :: PORTD_PIN5) , 110 => Some (CHMUX_A :: PORTD_PIN6) , 111 => Some (CHMUX_A :: PORTD_PIN7) , 112 => Some (CHMUX_A :: PORTE_PIN0) , 113 => Some (CHMUX_A :: PORTE_PIN1) , 114 => Some (CHMUX_A :: PORTE_PIN2) , 115 => Some (CHMUX_A :: PORTE_PIN3) , 116 => Some (CHMUX_A :: PORTE_PIN4) , 117 => Some (CHMUX_A :: PORTE_PIN5) , 118 => Some (CHMUX_A :: PORTE_PIN6) , 119 => Some (CHMUX_A :: PORTE_PIN7) , 120 => Some (CHMUX_A :: PORTF_PIN0) , 121 => Some (CHMUX_A :: PORTF_PIN1) , 122 => Some (CHMUX_A :: PORTF_PIN2) , 123 => Some (CHMUX_A :: PORTF_PIN3) , 124 => Some (CHMUX_A :: PORTF_PIN4) , 125 => Some (CHMUX_A :: PORTF_PIN5) , 126 => Some (CHMUX_A :: PORTF_PIN6) , 127 => Some (CHMUX_A :: PORTF_PIN7) , 128 => Some (CHMUX_A :: PRESCALER_1) , 129 => Some (CHMUX_A :: PRESCALER_2) , 130 => Some (CHMUX_A :: PRESCALER_4) , 131 => Some (CHMUX_A :: PRESCALER_8) , 132 => Some (CHMUX_A :: PRESCALER_16) , 133 => Some (CHMUX_A :: PRESCALER_32) , 134 => Some (CHMUX_A :: PRESCALER_64) , 135 => Some (CHMUX_A :: PRESCALER_128) , 136 => Some (CHMUX_A :: PRESCALER_256) , 137 => Some (CHMUX_A :: PRESCALER_512) , 138 => Some (CHMUX_A :: PRESCALER_1024) , 139 => Some (CHMUX_A :: PRESCALER_2048) , 140 => Some (CHMUX_A :: PRESCALER_4096) , 141 => Some (CHMUX_A :: PRESCALER_8192) , 142 => Some (CHMUX_A :: PRESCALER_16384) , 143 => Some (CHMUX_A :: PRESCALER_32768) , 192 => Some (CHMUX_A :: TCC0_OVF) , 193 => Some (CHMUX_A :: TCC0_ERR) , 196 => Some (CHMUX_A :: TCC0_CCA) , 197 => Some (CHMUX_A :: TCC0_CCB) , 198 => Some (CHMUX_A :: TCC0_CCC) , 199 => Some (CHMUX_A :: TCC0_CCD) , 200 => Some (CHMUX_A :: TCC1_OVF) , 201 => Some (CHMUX_A :: TCC1_ERR) , 204 => Some (CHMUX_A :: TCC1_CCA) , 205 => Some (CHMUX_A :: TCC1_CCB) , 208 => Some (CHMUX_A :: TCD0_OVF) , 209 => Some (CHMUX_A :: TCD0_ERR) , 212 => Some (CHMUX_A :: TCD0_CCA) , 213 => Some (CHMUX_A :: TCD0_CCB) , 214 => Some (CHMUX_A :: TCD0_CCC) , 215 => Some (CHMUX_A :: TCD0_CCD) , 216 => Some (CHMUX_A :: TCD1_OVF) , 217 => Some (CHMUX_A :: TCD1_ERR) , 220 => Some (CHMUX_A :: TCD1_CCA) , 221 => Some (CHMUX_A :: TCD1_CCB) , 224 => Some (CHMUX_A :: TCE0_OVF) , 225 => Some (CHMUX_A :: TCE0_ERR) , 228 => Some (CHMUX_A :: TCE0_CCA) , 229 => Some (CHMUX_A :: TCE0_CCB) , 230 => Some (CHMUX_A :: TCE0_CCC) , 231 => Some (CHMUX_A :: TCE0_CCD) , 232 => Some (CHMUX_A :: TCE1_OVF) , 233 => Some (CHMUX_A :: TCE1_ERR) , 236 => Some (CHMUX_A :: TCE1_CCA) , 237 => Some (CHMUX_A :: TCE1_CCB) , 240 => Some (CHMUX_A :: TCF0_OVF) , 241 => Some (CHMUX_A :: TCF0_ERR) , 244 => Some (CHMUX_A :: TCF0_CCA) , 245 => Some (CHMUX_A :: TCF0_CCB) , 246 => Some (CHMUX_A :: TCF0_CCC) , 247 => Some (CHMUX_A :: TCF0_CCD) , 248 => Some (CHMUX_A :: TCF1_OVF) , 249 => Some (CHMUX_A :: TCF1_ERR) , 252 => Some (CHMUX_A :: TCF1_CCA) , 253 => Some (CHMUX_A :: TCF1_CCB) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHMUX_A :: OFF } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == CHMUX_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == CHMUX_A :: RTC_CMP } # [doc = "Checks if the value of the field is `ACA_CH0`"]
# [inline (always)]
pub fn is_aca_ch0 (& self) -> bool { * self == CHMUX_A :: ACA_CH0 } # [doc = "Checks if the value of the field is `ACA_CH1`"]
# [inline (always)]
pub fn is_aca_ch1 (& self) -> bool { * self == CHMUX_A :: ACA_CH1 } # [doc = "Checks if the value of the field is `ACA_WIN`"]
# [inline (always)]
pub fn is_aca_win (& self) -> bool { * self == CHMUX_A :: ACA_WIN } # [doc = "Checks if the value of the field is `ACB_CH0`"]
# [inline (always)]
pub fn is_acb_ch0 (& self) -> bool { * self == CHMUX_A :: ACB_CH0 } # [doc = "Checks if the value of the field is `ACB_CH1`"]
# [inline (always)]
pub fn is_acb_ch1 (& self) -> bool { * self == CHMUX_A :: ACB_CH1 } # [doc = "Checks if the value of the field is `ACB_WIN`"]
# [inline (always)]
pub fn is_acb_win (& self) -> bool { * self == CHMUX_A :: ACB_WIN } # [doc = "Checks if the value of the field is `ADCA_CH0`"]
# [inline (always)]
pub fn is_adca_ch0 (& self) -> bool { * self == CHMUX_A :: ADCA_CH0 } # [doc = "Checks if the value of the field is `ADCA_CH1`"]
# [inline (always)]
pub fn is_adca_ch1 (& self) -> bool { * self == CHMUX_A :: ADCA_CH1 } # [doc = "Checks if the value of the field is `ADCA_CH2`"]
# [inline (always)]
pub fn is_adca_ch2 (& self) -> bool { * self == CHMUX_A :: ADCA_CH2 } # [doc = "Checks if the value of the field is `ADCA_CH3`"]
# [inline (always)]
pub fn is_adca_ch3 (& self) -> bool { * self == CHMUX_A :: ADCA_CH3 } # [doc = "Checks if the value of the field is `ADCB_CH0`"]
# [inline (always)]
pub fn is_adcb_ch0 (& self) -> bool { * self == CHMUX_A :: ADCB_CH0 } # [doc = "Checks if the value of the field is `ADCB_CH1`"]
# [inline (always)]
pub fn is_adcb_ch1 (& self) -> bool { * self == CHMUX_A :: ADCB_CH1 } # [doc = "Checks if the value of the field is `ADCB_CH2`"]
# [inline (always)]
pub fn is_adcb_ch2 (& self) -> bool { * self == CHMUX_A :: ADCB_CH2 } # [doc = "Checks if the value of the field is `ADCB_CH3`"]
# [inline (always)]
pub fn is_adcb_ch3 (& self) -> bool { * self == CHMUX_A :: ADCB_CH3 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN7 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTC_PIN6`"]
# [inline (always)]
pub fn is_portc_pin6 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN6 } # [doc = "Checks if the value of the field is `PORTC_PIN7`"]
# [inline (always)]
pub fn is_portc_pin7 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN7 } # [doc = "Checks if the value of the field is `PORTD_PIN0`"]
# [inline (always)]
pub fn is_portd_pin0 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN0 } # [doc = "Checks if the value of the field is `PORTD_PIN1`"]
# [inline (always)]
pub fn is_portd_pin1 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN1 } # [doc = "Checks if the value of the field is `PORTD_PIN2`"]
# [inline (always)]
pub fn is_portd_pin2 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN2 } # [doc = "Checks if the value of the field is `PORTD_PIN3`"]
# [inline (always)]
pub fn is_portd_pin3 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN3 } # [doc = "Checks if the value of the field is `PORTD_PIN4`"]
# [inline (always)]
pub fn is_portd_pin4 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN4 } # [doc = "Checks if the value of the field is `PORTD_PIN5`"]
# [inline (always)]
pub fn is_portd_pin5 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN5 } # [doc = "Checks if the value of the field is `PORTD_PIN6`"]
# [inline (always)]
pub fn is_portd_pin6 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN6 } # [doc = "Checks if the value of the field is `PORTD_PIN7`"]
# [inline (always)]
pub fn is_portd_pin7 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN7 } # [doc = "Checks if the value of the field is `PORTE_PIN0`"]
# [inline (always)]
pub fn is_porte_pin0 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN0 } # [doc = "Checks if the value of the field is `PORTE_PIN1`"]
# [inline (always)]
pub fn is_porte_pin1 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN1 } # [doc = "Checks if the value of the field is `PORTE_PIN2`"]
# [inline (always)]
pub fn is_porte_pin2 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN2 } # [doc = "Checks if the value of the field is `PORTE_PIN3`"]
# [inline (always)]
pub fn is_porte_pin3 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN3 } # [doc = "Checks if the value of the field is `PORTE_PIN4`"]
# [inline (always)]
pub fn is_porte_pin4 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN4 } # [doc = "Checks if the value of the field is `PORTE_PIN5`"]
# [inline (always)]
pub fn is_porte_pin5 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN5 } # [doc = "Checks if the value of the field is `PORTE_PIN6`"]
# [inline (always)]
pub fn is_porte_pin6 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN6 } # [doc = "Checks if the value of the field is `PORTE_PIN7`"]
# [inline (always)]
pub fn is_porte_pin7 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN7 } # [doc = "Checks if the value of the field is `PORTF_PIN0`"]
# [inline (always)]
pub fn is_portf_pin0 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN0 } # [doc = "Checks if the value of the field is `PORTF_PIN1`"]
# [inline (always)]
pub fn is_portf_pin1 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN1 } # [doc = "Checks if the value of the field is `PORTF_PIN2`"]
# [inline (always)]
pub fn is_portf_pin2 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN2 } # [doc = "Checks if the value of the field is `PORTF_PIN3`"]
# [inline (always)]
pub fn is_portf_pin3 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN3 } # [doc = "Checks if the value of the field is `PORTF_PIN4`"]
# [inline (always)]
pub fn is_portf_pin4 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN4 } # [doc = "Checks if the value of the field is `PORTF_PIN5`"]
# [inline (always)]
pub fn is_portf_pin5 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN5 } # [doc = "Checks if the value of the field is `PORTF_PIN6`"]
# [inline (always)]
pub fn is_portf_pin6 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN6 } # [doc = "Checks if the value of the field is `PORTF_PIN7`"]
# [inline (always)]
pub fn is_portf_pin7 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN7 } # [doc = "Checks if the value of the field is `PRESCALER_1`"]
# [inline (always)]
pub fn is_prescaler_1 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1 } # [doc = "Checks if the value of the field is `PRESCALER_2`"]
# [inline (always)]
pub fn is_prescaler_2 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2 } # [doc = "Checks if the value of the field is `PRESCALER_4`"]
# [inline (always)]
pub fn is_prescaler_4 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4 } # [doc = "Checks if the value of the field is `PRESCALER_8`"]
# [inline (always)]
pub fn is_prescaler_8 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8 } # [doc = "Checks if the value of the field is `PRESCALER_16`"]
# [inline (always)]
pub fn is_prescaler_16 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16 } # [doc = "Checks if the value of the field is `PRESCALER_32`"]
# [inline (always)]
pub fn is_prescaler_32 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32 } # [doc = "Checks if the value of the field is `PRESCALER_64`"]
# [inline (always)]
pub fn is_prescaler_64 (& self) -> bool { * self == CHMUX_A :: PRESCALER_64 } # [doc = "Checks if the value of the field is `PRESCALER_128`"]
# [inline (always)]
pub fn is_prescaler_128 (& self) -> bool { * self == CHMUX_A :: PRESCALER_128 } # [doc = "Checks if the value of the field is `PRESCALER_256`"]
# [inline (always)]
pub fn is_prescaler_256 (& self) -> bool { * self == CHMUX_A :: PRESCALER_256 } # [doc = "Checks if the value of the field is `PRESCALER_512`"]
# [inline (always)]
pub fn is_prescaler_512 (& self) -> bool { * self == CHMUX_A :: PRESCALER_512 } # [doc = "Checks if the value of the field is `PRESCALER_1024`"]
# [inline (always)]
pub fn is_prescaler_1024 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1024 } # [doc = "Checks if the value of the field is `PRESCALER_2048`"]
# [inline (always)]
pub fn is_prescaler_2048 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2048 } # [doc = "Checks if the value of the field is `PRESCALER_4096`"]
# [inline (always)]
pub fn is_prescaler_4096 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4096 } # [doc = "Checks if the value of the field is `PRESCALER_8192`"]
# [inline (always)]
pub fn is_prescaler_8192 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8192 } # [doc = "Checks if the value of the field is `PRESCALER_16384`"]
# [inline (always)]
pub fn is_prescaler_16384 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16384 } # [doc = "Checks if the value of the field is `PRESCALER_32768`"]
# [inline (always)]
pub fn is_prescaler_32768 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32768 } # [doc = "Checks if the value of the field is `TCC0_OVF`"]
# [inline (always)]
pub fn is_tcc0_ovf (& self) -> bool { * self == CHMUX_A :: TCC0_OVF } # [doc = "Checks if the value of the field is `TCC0_ERR`"]
# [inline (always)]
pub fn is_tcc0_err (& self) -> bool { * self == CHMUX_A :: TCC0_ERR } # [doc = "Checks if the value of the field is `TCC0_CCA`"]
# [inline (always)]
pub fn is_tcc0_cca (& self) -> bool { * self == CHMUX_A :: TCC0_CCA } # [doc = "Checks if the value of the field is `TCC0_CCB`"]
# [inline (always)]
pub fn is_tcc0_ccb (& self) -> bool { * self == CHMUX_A :: TCC0_CCB } # [doc = "Checks if the value of the field is `TCC0_CCC`"]
# [inline (always)]
pub fn is_tcc0_ccc (& self) -> bool { * self == CHMUX_A :: TCC0_CCC } # [doc = "Checks if the value of the field is `TCC0_CCD`"]
# [inline (always)]
pub fn is_tcc0_ccd (& self) -> bool { * self == CHMUX_A :: TCC0_CCD } # [doc = "Checks if the value of the field is `TCC1_OVF`"]
# [inline (always)]
pub fn is_tcc1_ovf (& self) -> bool { * self == CHMUX_A :: TCC1_OVF } # [doc = "Checks if the value of the field is `TCC1_ERR`"]
# [inline (always)]
pub fn is_tcc1_err (& self) -> bool { * self == CHMUX_A :: TCC1_ERR } # [doc = "Checks if the value of the field is `TCC1_CCA`"]
# [inline (always)]
pub fn is_tcc1_cca (& self) -> bool { * self == CHMUX_A :: TCC1_CCA } # [doc = "Checks if the value of the field is `TCC1_CCB`"]
# [inline (always)]
pub fn is_tcc1_ccb (& self) -> bool { * self == CHMUX_A :: TCC1_CCB } # [doc = "Checks if the value of the field is `TCD0_OVF`"]
# [inline (always)]
pub fn is_tcd0_ovf (& self) -> bool { * self == CHMUX_A :: TCD0_OVF } # [doc = "Checks if the value of the field is `TCD0_ERR`"]
# [inline (always)]
pub fn is_tcd0_err (& self) -> bool { * self == CHMUX_A :: TCD0_ERR } # [doc = "Checks if the value of the field is `TCD0_CCA`"]
# [inline (always)]
pub fn is_tcd0_cca (& self) -> bool { * self == CHMUX_A :: TCD0_CCA } # [doc = "Checks if the value of the field is `TCD0_CCB`"]
# [inline (always)]
pub fn is_tcd0_ccb (& self) -> bool { * self == CHMUX_A :: TCD0_CCB } # [doc = "Checks if the value of the field is `TCD0_CCC`"]
# [inline (always)]
pub fn is_tcd0_ccc (& self) -> bool { * self == CHMUX_A :: TCD0_CCC } # [doc = "Checks if the value of the field is `TCD0_CCD`"]
# [inline (always)]
pub fn is_tcd0_ccd (& self) -> bool { * self == CHMUX_A :: TCD0_CCD } # [doc = "Checks if the value of the field is `TCD1_OVF`"]
# [inline (always)]
pub fn is_tcd1_ovf (& self) -> bool { * self == CHMUX_A :: TCD1_OVF } # [doc = "Checks if the value of the field is `TCD1_ERR`"]
# [inline (always)]
pub fn is_tcd1_err (& self) -> bool { * self == CHMUX_A :: TCD1_ERR } # [doc = "Checks if the value of the field is `TCD1_CCA`"]
# [inline (always)]
pub fn is_tcd1_cca (& self) -> bool { * self == CHMUX_A :: TCD1_CCA } # [doc = "Checks if the value of the field is `TCD1_CCB`"]
# [inline (always)]
pub fn is_tcd1_ccb (& self) -> bool { * self == CHMUX_A :: TCD1_CCB } # [doc = "Checks if the value of the field is `TCE0_OVF`"]
# [inline (always)]
pub fn is_tce0_ovf (& self) -> bool { * self == CHMUX_A :: TCE0_OVF } # [doc = "Checks if the value of the field is `TCE0_ERR`"]
# [inline (always)]
pub fn is_tce0_err (& self) -> bool { * self == CHMUX_A :: TCE0_ERR } # [doc = "Checks if the value of the field is `TCE0_CCA`"]
# [inline (always)]
pub fn is_tce0_cca (& self) -> bool { * self == CHMUX_A :: TCE0_CCA } # [doc = "Checks if the value of the field is `TCE0_CCB`"]
# [inline (always)]
pub fn is_tce0_ccb (& self) -> bool { * self == CHMUX_A :: TCE0_CCB } # [doc = "Checks if the value of the field is `TCE0_CCC`"]
# [inline (always)]
pub fn is_tce0_ccc (& self) -> bool { * self == CHMUX_A :: TCE0_CCC } # [doc = "Checks if the value of the field is `TCE0_CCD`"]
# [inline (always)]
pub fn is_tce0_ccd (& self) -> bool { * self == CHMUX_A :: TCE0_CCD } # [doc = "Checks if the value of the field is `TCE1_OVF`"]
# [inline (always)]
pub fn is_tce1_ovf (& self) -> bool { * self == CHMUX_A :: TCE1_OVF } # [doc = "Checks if the value of the field is `TCE1_ERR`"]
# [inline (always)]
pub fn is_tce1_err (& self) -> bool { * self == CHMUX_A :: TCE1_ERR } # [doc = "Checks if the value of the field is `TCE1_CCA`"]
# [inline (always)]
pub fn is_tce1_cca (& self) -> bool { * self == CHMUX_A :: TCE1_CCA } # [doc = "Checks if the value of the field is `TCE1_CCB`"]
# [inline (always)]
pub fn is_tce1_ccb (& self) -> bool { * self == CHMUX_A :: TCE1_CCB } # [doc = "Checks if the value of the field is `TCF0_OVF`"]
# [inline (always)]
pub fn is_tcf0_ovf (& self) -> bool { * self == CHMUX_A :: TCF0_OVF } # [doc = "Checks if the value of the field is `TCF0_ERR`"]
# [inline (always)]
pub fn is_tcf0_err (& self) -> bool { * self == CHMUX_A :: TCF0_ERR } # [doc = "Checks if the value of the field is `TCF0_CCA`"]
# [inline (always)]
pub fn is_tcf0_cca (& self) -> bool { * self == CHMUX_A :: TCF0_CCA } # [doc = "Checks if the value of the field is `TCF0_CCB`"]
# [inline (always)]
pub fn is_tcf0_ccb (& self) -> bool { * self == CHMUX_A :: TCF0_CCB } # [doc = "Checks if the value of the field is `TCF0_CCC`"]
# [inline (always)]
pub fn is_tcf0_ccc (& self) -> bool { * self == CHMUX_A :: TCF0_CCC } # [doc = "Checks if the value of the field is `TCF0_CCD`"]
# [inline (always)]
pub fn is_tcf0_ccd (& self) -> bool { * self == CHMUX_A :: TCF0_CCD } # [doc = "Checks if the value of the field is `TCF1_OVF`"]
# [inline (always)]
pub fn is_tcf1_ovf (& self) -> bool { * self == CHMUX_A :: TCF1_OVF } # [doc = "Checks if the value of the field is `TCF1_ERR`"]
# [inline (always)]
pub fn is_tcf1_err (& self) -> bool { * self == CHMUX_A :: TCF1_ERR } # [doc = "Checks if the value of the field is `TCF1_CCA`"]
# [inline (always)]
pub fn is_tcf1_cca (& self) -> bool { * self == CHMUX_A :: TCF1_CCA } # [doc = "Checks if the value of the field is `TCF1_CCB`"]
# [inline (always)]
pub fn is_tcf1_ccb (& self) -> bool { * self == CHMUX_A :: TCF1_CCB } } # [doc = "Field `CHMUX` writer - Event Channel 6 Multiplexer"]
pub type CHMUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CH6MUX_SPEC , u8 , CHMUX_A , 8 , O > ; impl < 'a , const O : u8 > CHMUX_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHMUX_A :: OFF) } # [doc = "RTC Overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_OVF) } # [doc = "RTC Compare Match"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_CMP) } # [doc = "Analog Comparator A Channel 0"]
# [inline (always)]
pub fn aca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH0) } # [doc = "Analog Comparator A Channel 1"]
# [inline (always)]
pub fn aca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH1) } # [doc = "Analog Comparator A Window"]
# [inline (always)]
pub fn aca_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_WIN) } # [doc = "Analog Comparator B Channel 0"]
# [inline (always)]
pub fn acb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH0) } # [doc = "Analog Comparator B Channel 1"]
# [inline (always)]
pub fn acb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH1) } # [doc = "Analog Comparator B Window"]
# [inline (always)]
pub fn acb_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_WIN) } # [doc = "ADC A Channel 0"]
# [inline (always)]
pub fn adca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH0) } # [doc = "ADC A Channel 1"]
# [inline (always)]
pub fn adca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH1) } # [doc = "ADC A Channel 2"]
# [inline (always)]
pub fn adca_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH2) } # [doc = "ADC A Channel 3"]
# [inline (always)]
pub fn adca_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH3) } # [doc = "ADC B Channel 0"]
# [inline (always)]
pub fn adcb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH0) } # [doc = "ADC B Channel 1"]
# [inline (always)]
pub fn adcb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH1) } # [doc = "ADC B Channel 2"]
# [inline (always)]
pub fn adcb_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH2) } # [doc = "ADC B Channel 3"]
# [inline (always)]
pub fn adcb_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH3) } # [doc = "Port A, Pin0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN0) } # [doc = "Port A, Pin1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN1) } # [doc = "Port A, Pin2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN2) } # [doc = "Port A, Pin3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN3) } # [doc = "Port A, Pin4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN4) } # [doc = "Port A, Pin5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN5) } # [doc = "Port A, Pin6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN6) } # [doc = "Port A, Pin7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN7) } # [doc = "Port B, Pin0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN0) } # [doc = "Port B, Pin1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN1) } # [doc = "Port B, Pin2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN2) } # [doc = "Port B, Pin3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN3) } # [doc = "Port B, Pin4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN4) } # [doc = "Port B, Pin5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN5) } # [doc = "Port B, Pin6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN6) } # [doc = "Port B, Pin7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN7) } # [doc = "Port C, Pin0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN0) } # [doc = "Port C, Pin1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN1) } # [doc = "Port C, Pin2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN2) } # [doc = "Port C, Pin3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN3) } # [doc = "Port C, Pin4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN4) } # [doc = "Port C, Pin5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN5) } # [doc = "Port C, Pin6"]
# [inline (always)]
pub fn portc_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN6) } # [doc = "Port C, Pin7"]
# [inline (always)]
pub fn portc_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN7) } # [doc = "Port D, Pin0"]
# [inline (always)]
pub fn portd_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN0) } # [doc = "Port D, Pin1"]
# [inline (always)]
pub fn portd_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN1) } # [doc = "Port D, Pin2"]
# [inline (always)]
pub fn portd_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN2) } # [doc = "Port D, Pin3"]
# [inline (always)]
pub fn portd_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN3) } # [doc = "Port D, Pin4"]
# [inline (always)]
pub fn portd_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN4) } # [doc = "Port D, Pin5"]
# [inline (always)]
pub fn portd_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN5) } # [doc = "Port D, Pin6"]
# [inline (always)]
pub fn portd_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN6) } # [doc = "Port D, Pin7"]
# [inline (always)]
pub fn portd_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN7) } # [doc = "Port E, Pin0"]
# [inline (always)]
pub fn porte_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN0) } # [doc = "Port E, Pin1"]
# [inline (always)]
pub fn porte_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN1) } # [doc = "Port E, Pin2"]
# [inline (always)]
pub fn porte_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN2) } # [doc = "Port E, Pin3"]
# [inline (always)]
pub fn porte_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN3) } # [doc = "Port E, Pin4"]
# [inline (always)]
pub fn porte_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN4) } # [doc = "Port E, Pin5"]
# [inline (always)]
pub fn porte_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN5) } # [doc = "Port E, Pin6"]
# [inline (always)]
pub fn porte_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN6) } # [doc = "Port E, Pin7"]
# [inline (always)]
pub fn porte_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN7) } # [doc = "Port F, Pin0"]
# [inline (always)]
pub fn portf_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN0) } # [doc = "Port F, Pin1"]
# [inline (always)]
pub fn portf_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN1) } # [doc = "Port F, Pin2"]
# [inline (always)]
pub fn portf_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN2) } # [doc = "Port F, Pin3"]
# [inline (always)]
pub fn portf_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN3) } # [doc = "Port F, Pin4"]
# [inline (always)]
pub fn portf_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN4) } # [doc = "Port F, Pin5"]
# [inline (always)]
pub fn portf_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN5) } # [doc = "Port F, Pin6"]
# [inline (always)]
pub fn portf_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN6) } # [doc = "Port F, Pin7"]
# [inline (always)]
pub fn portf_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN7) } # [doc = "Prescaler, divide by 1"]
# [inline (always)]
pub fn prescaler_1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1) } # [doc = "Prescaler, divide by 2"]
# [inline (always)]
pub fn prescaler_2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2) } # [doc = "Prescaler, divide by 4"]
# [inline (always)]
pub fn prescaler_4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4) } # [doc = "Prescaler, divide by 8"]
# [inline (always)]
pub fn prescaler_8 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8) } # [doc = "Prescaler, divide by 16"]
# [inline (always)]
pub fn prescaler_16 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16) } # [doc = "Prescaler, divide by 32"]
# [inline (always)]
pub fn prescaler_32 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32) } # [doc = "Prescaler, divide by 64"]
# [inline (always)]
pub fn prescaler_64 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_64) } # [doc = "Prescaler, divide by 128"]
# [inline (always)]
pub fn prescaler_128 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_128) } # [doc = "Prescaler, divide by 256"]
# [inline (always)]
pub fn prescaler_256 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_256) } # [doc = "Prescaler, divide by 512"]
# [inline (always)]
pub fn prescaler_512 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_512) } # [doc = "Prescaler, divide by 1024"]
# [inline (always)]
pub fn prescaler_1024 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1024) } # [doc = "Prescaler, divide by 2048"]
# [inline (always)]
pub fn prescaler_2048 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2048) } # [doc = "Prescaler, divide by 4096"]
# [inline (always)]
pub fn prescaler_4096 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4096) } # [doc = "Prescaler, divide by 8192"]
# [inline (always)]
pub fn prescaler_8192 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8192) } # [doc = "Prescaler, divide by 16384"]
# [inline (always)]
pub fn prescaler_16384 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16384) } # [doc = "Prescaler, divide by 32768"]
# [inline (always)]
pub fn prescaler_32768 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32768) } # [doc = "Timer/Counter C0 Overflow"]
# [inline (always)]
pub fn tcc0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_OVF) } # [doc = "Timer/Counter C0 Error"]
# [inline (always)]
pub fn tcc0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_ERR) } # [doc = "Timer/Counter C0 Compare or Capture A"]
# [inline (always)]
pub fn tcc0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCA) } # [doc = "Timer/Counter C0 Compare or Capture B"]
# [inline (always)]
pub fn tcc0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCB) } # [doc = "Timer/Counter C0 Compare or Capture C"]
# [inline (always)]
pub fn tcc0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCC) } # [doc = "Timer/Counter C0 Compare or Capture D"]
# [inline (always)]
pub fn tcc0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCD) } # [doc = "Timer/Counter C1 Overflow"]
# [inline (always)]
pub fn tcc1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_OVF) } # [doc = "Timer/Counter C1 Error"]
# [inline (always)]
pub fn tcc1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_ERR) } # [doc = "Timer/Counter C1 Compare or Capture A"]
# [inline (always)]
pub fn tcc1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCA) } # [doc = "Timer/Counter C1 Compare or Capture B"]
# [inline (always)]
pub fn tcc1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCB) } # [doc = "Timer/Counter D0 Overflow"]
# [inline (always)]
pub fn tcd0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_OVF) } # [doc = "Timer/Counter D0 Error"]
# [inline (always)]
pub fn tcd0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_ERR) } # [doc = "Timer/Counter D0 Compare or Capture A"]
# [inline (always)]
pub fn tcd0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCA) } # [doc = "Timer/Counter D0 Compare or Capture B"]
# [inline (always)]
pub fn tcd0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCB) } # [doc = "Timer/Counter D0 Compare or Capture C"]
# [inline (always)]
pub fn tcd0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCC) } # [doc = "Timer/Counter D0 Compare or Capture D"]
# [inline (always)]
pub fn tcd0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCD) } # [doc = "Timer/Counter D1 Overflow"]
# [inline (always)]
pub fn tcd1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_OVF) } # [doc = "Timer/Counter D1 Error"]
# [inline (always)]
pub fn tcd1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_ERR) } # [doc = "Timer/Counter D1 Compare or Capture A"]
# [inline (always)]
pub fn tcd1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCA) } # [doc = "Timer/Counter D1 Compare or Capture B"]
# [inline (always)]
pub fn tcd1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCB) } # [doc = "Timer/Counter E0 Overflow"]
# [inline (always)]
pub fn tce0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_OVF) } # [doc = "Timer/Counter E0 Error"]
# [inline (always)]
pub fn tce0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_ERR) } # [doc = "Timer/Counter E0 Compare or Capture A"]
# [inline (always)]
pub fn tce0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCA) } # [doc = "Timer/Counter E0 Compare or Capture B"]
# [inline (always)]
pub fn tce0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCB) } # [doc = "Timer/Counter E0 Compare or Capture C"]
# [inline (always)]
pub fn tce0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCC) } # [doc = "Timer/Counter E0 Compare or Capture D"]
# [inline (always)]
pub fn tce0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCD) } # [doc = "Timer/Counter E1 Overflow"]
# [inline (always)]
pub fn tce1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_OVF) } # [doc = "Timer/Counter E1 Error"]
# [inline (always)]
pub fn tce1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_ERR) } # [doc = "Timer/Counter E1 Compare or Capture A"]
# [inline (always)]
pub fn tce1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCA) } # [doc = "Timer/Counter E1 Compare or Capture B"]
# [inline (always)]
pub fn tce1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCB) } # [doc = "Timer/Counter F0 Overflow"]
# [inline (always)]
pub fn tcf0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_OVF) } # [doc = "Timer/Counter F0 Error"]
# [inline (always)]
pub fn tcf0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_ERR) } # [doc = "Timer/Counter F0 Compare or Capture A"]
# [inline (always)]
pub fn tcf0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCA) } # [doc = "Timer/Counter F0 Compare or Capture B"]
# [inline (always)]
pub fn tcf0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCB) } # [doc = "Timer/Counter F0 Compare or Capture C"]
# [inline (always)]
pub fn tcf0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCC) } # [doc = "Timer/Counter F0 Compare or Capture D"]
# [inline (always)]
pub fn tcf0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCD) } # [doc = "Timer/Counter F1 Overflow"]
# [inline (always)]
pub fn tcf1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_OVF) } # [doc = "Timer/Counter F1 Error"]
# [inline (always)]
pub fn tcf1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_ERR) } # [doc = "Timer/Counter F1 Compare or Capture A"]
# [inline (always)]
pub fn tcf1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCA) } # [doc = "Timer/Counter F1 Compare or Capture B"]
# [inline (always)]
pub fn tcf1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCB) } } impl R { # [doc = "Bits 0:7 - Event Channel 6 Multiplexer"]
# [inline (always)]
pub fn chmux (& self) -> CHMUX_R { CHMUX_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Event Channel 6 Multiplexer"]
# [inline (always)]
# [must_use]
pub fn chmux (& mut self) -> CHMUX_W < 0 > { CHMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Channel 6 Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch6mux](index.html) module"]
pub struct CH6MUX_SPEC ; impl crate :: RegisterSpec for CH6MUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch6mux::R](R) reader structure"]
impl crate :: Readable for CH6MUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch6mux::W](W) writer structure"]
impl crate :: Writable for CH6MUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH6MUX to value 0"]
impl crate :: Resettable for CH6MUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH7CTRL (rw) register accessor: an alias for `Reg<CH7CTRL_SPEC>`"]
pub type CH7CTRL = crate :: Reg < ch7ctrl :: CH7CTRL_SPEC > ; # [doc = "Channel 7 Control Register"]
pub mod ch7ctrl { # [doc = "Register `CH7CTRL` reader"]
pub struct R (crate :: R < CH7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH7CTRL` writer"]
pub struct W (crate :: W < CH7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIGFILT` reader - Digital Filter"]
pub type DIGFILT_R = crate :: FieldReader < u8 , DIGFILT_A > ; # [doc = "Digital Filter\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DIGFILT_A { # [doc = "0: 1 SAMPLE"]
_1SAMPLE = 0 , # [doc = "1: 2 SAMPLES"]
_2SAMPLES = 1 , # [doc = "2: 3 SAMPLES"]
_3SAMPLES = 2 , # [doc = "3: 4 SAMPLES"]
_4SAMPLES = 3 , # [doc = "4: 5 SAMPLES"]
_5SAMPLES = 4 , # [doc = "5: 6 SAMPLES"]
_6SAMPLES = 5 , # [doc = "6: 7 SAMPLES"]
_7SAMPLES = 6 , # [doc = "7: 8 SAMPLES"]
_8SAMPLES = 7 , } impl From < DIGFILT_A > for u8 { # [inline (always)]
fn from (variant : DIGFILT_A) -> Self { variant as _ } } impl DIGFILT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DIGFILT_A { match self . bits { 0 => DIGFILT_A :: _1SAMPLE , 1 => DIGFILT_A :: _2SAMPLES , 2 => DIGFILT_A :: _3SAMPLES , 3 => DIGFILT_A :: _4SAMPLES , 4 => DIGFILT_A :: _5SAMPLES , 5 => DIGFILT_A :: _6SAMPLES , 6 => DIGFILT_A :: _7SAMPLES , 7 => DIGFILT_A :: _8SAMPLES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_1SAMPLE`"]
# [inline (always)]
pub fn is_1sample (& self) -> bool { * self == DIGFILT_A :: _1SAMPLE } # [doc = "Checks if the value of the field is `_2SAMPLES`"]
# [inline (always)]
pub fn is_2samples (& self) -> bool { * self == DIGFILT_A :: _2SAMPLES } # [doc = "Checks if the value of the field is `_3SAMPLES`"]
# [inline (always)]
pub fn is_3samples (& self) -> bool { * self == DIGFILT_A :: _3SAMPLES } # [doc = "Checks if the value of the field is `_4SAMPLES`"]
# [inline (always)]
pub fn is_4samples (& self) -> bool { * self == DIGFILT_A :: _4SAMPLES } # [doc = "Checks if the value of the field is `_5SAMPLES`"]
# [inline (always)]
pub fn is_5samples (& self) -> bool { * self == DIGFILT_A :: _5SAMPLES } # [doc = "Checks if the value of the field is `_6SAMPLES`"]
# [inline (always)]
pub fn is_6samples (& self) -> bool { * self == DIGFILT_A :: _6SAMPLES } # [doc = "Checks if the value of the field is `_7SAMPLES`"]
# [inline (always)]
pub fn is_7samples (& self) -> bool { * self == DIGFILT_A :: _7SAMPLES } # [doc = "Checks if the value of the field is `_8SAMPLES`"]
# [inline (always)]
pub fn is_8samples (& self) -> bool { * self == DIGFILT_A :: _8SAMPLES } } # [doc = "Field `DIGFILT` writer - Digital Filter"]
pub type DIGFILT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CH7CTRL_SPEC , u8 , DIGFILT_A , 3 , O > ; impl < 'a , const O : u8 > DIGFILT_W < 'a , O > { # [doc = "1 SAMPLE"]
# [inline (always)]
pub fn _1sample (self) -> & 'a mut W { self . variant (DIGFILT_A :: _1SAMPLE) } # [doc = "2 SAMPLES"]
# [inline (always)]
pub fn _2samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _2SAMPLES) } # [doc = "3 SAMPLES"]
# [inline (always)]
pub fn _3samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _3SAMPLES) } # [doc = "4 SAMPLES"]
# [inline (always)]
pub fn _4samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _4SAMPLES) } # [doc = "5 SAMPLES"]
# [inline (always)]
pub fn _5samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _5SAMPLES) } # [doc = "6 SAMPLES"]
# [inline (always)]
pub fn _6samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _6SAMPLES) } # [doc = "7 SAMPLES"]
# [inline (always)]
pub fn _7samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _7SAMPLES) } # [doc = "8 SAMPLES"]
# [inline (always)]
pub fn _8samples (self) -> & 'a mut W { self . variant (DIGFILT_A :: _8SAMPLES) } } impl R { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
pub fn digfilt (& self) -> DIGFILT_R { DIGFILT_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Digital Filter"]
# [inline (always)]
# [must_use]
pub fn digfilt (& mut self) -> DIGFILT_W < 0 > { DIGFILT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch7ctrl](index.html) module"]
pub struct CH7CTRL_SPEC ; impl crate :: RegisterSpec for CH7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch7ctrl::R](R) reader structure"]
impl crate :: Readable for CH7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch7ctrl::W](W) writer structure"]
impl crate :: Writable for CH7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH7CTRL to value 0"]
impl crate :: Resettable for CH7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CH7MUX (rw) register accessor: an alias for `Reg<CH7MUX_SPEC>`"]
pub type CH7MUX = crate :: Reg < ch7mux :: CH7MUX_SPEC > ; # [doc = "Event Channel 7 Multiplexer"]
pub mod ch7mux { # [doc = "Register `CH7MUX` reader"]
pub struct R (crate :: R < CH7MUX_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CH7MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CH7MUX_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CH7MUX_SPEC >) -> Self { R (reader) } } # [doc = "Register `CH7MUX` writer"]
pub struct W (crate :: W < CH7MUX_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CH7MUX_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CH7MUX_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CH7MUX_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHMUX` reader - Event Channel 7 Multiplexer"]
pub type CHMUX_R = crate :: FieldReader < u8 , CHMUX_A > ; # [doc = "Event Channel 7 Multiplexer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHMUX_A { # [doc = "0: Off"]
OFF = 0 , # [doc = "8: RTC Overflow"]
RTC_OVF = 8 , # [doc = "9: RTC Compare Match"]
RTC_CMP = 9 , # [doc = "16: Analog Comparator A Channel 0"]
ACA_CH0 = 16 , # [doc = "17: Analog Comparator A Channel 1"]
ACA_CH1 = 17 , # [doc = "18: Analog Comparator A Window"]
ACA_WIN = 18 , # [doc = "19: Analog Comparator B Channel 0"]
ACB_CH0 = 19 , # [doc = "20: Analog Comparator B Channel 1"]
ACB_CH1 = 20 , # [doc = "21: Analog Comparator B Window"]
ACB_WIN = 21 , # [doc = "32: ADC A Channel 0"]
ADCA_CH0 = 32 , # [doc = "33: ADC A Channel 1"]
ADCA_CH1 = 33 , # [doc = "34: ADC A Channel 2"]
ADCA_CH2 = 34 , # [doc = "35: ADC A Channel 3"]
ADCA_CH3 = 35 , # [doc = "36: ADC B Channel 0"]
ADCB_CH0 = 36 , # [doc = "37: ADC B Channel 1"]
ADCB_CH1 = 37 , # [doc = "38: ADC B Channel 2"]
ADCB_CH2 = 38 , # [doc = "39: ADC B Channel 3"]
ADCB_CH3 = 39 , # [doc = "80: Port A, Pin0"]
PORTA_PIN0 = 80 , # [doc = "81: Port A, Pin1"]
PORTA_PIN1 = 81 , # [doc = "82: Port A, Pin2"]
PORTA_PIN2 = 82 , # [doc = "83: Port A, Pin3"]
PORTA_PIN3 = 83 , # [doc = "84: Port A, Pin4"]
PORTA_PIN4 = 84 , # [doc = "85: Port A, Pin5"]
PORTA_PIN5 = 85 , # [doc = "86: Port A, Pin6"]
PORTA_PIN6 = 86 , # [doc = "87: Port A, Pin7"]
PORTA_PIN7 = 87 , # [doc = "88: Port B, Pin0"]
PORTB_PIN0 = 88 , # [doc = "89: Port B, Pin1"]
PORTB_PIN1 = 89 , # [doc = "90: Port B, Pin2"]
PORTB_PIN2 = 90 , # [doc = "91: Port B, Pin3"]
PORTB_PIN3 = 91 , # [doc = "92: Port B, Pin4"]
PORTB_PIN4 = 92 , # [doc = "93: Port B, Pin5"]
PORTB_PIN5 = 93 , # [doc = "94: Port B, Pin6"]
PORTB_PIN6 = 94 , # [doc = "95: Port B, Pin7"]
PORTB_PIN7 = 95 , # [doc = "96: Port C, Pin0"]
PORTC_PIN0 = 96 , # [doc = "97: Port C, Pin1"]
PORTC_PIN1 = 97 , # [doc = "98: Port C, Pin2"]
PORTC_PIN2 = 98 , # [doc = "99: Port C, Pin3"]
PORTC_PIN3 = 99 , # [doc = "100: Port C, Pin4"]
PORTC_PIN4 = 100 , # [doc = "101: Port C, Pin5"]
PORTC_PIN5 = 101 , # [doc = "102: Port C, Pin6"]
PORTC_PIN6 = 102 , # [doc = "103: Port C, Pin7"]
PORTC_PIN7 = 103 , # [doc = "104: Port D, Pin0"]
PORTD_PIN0 = 104 , # [doc = "105: Port D, Pin1"]
PORTD_PIN1 = 105 , # [doc = "106: Port D, Pin2"]
PORTD_PIN2 = 106 , # [doc = "107: Port D, Pin3"]
PORTD_PIN3 = 107 , # [doc = "108: Port D, Pin4"]
PORTD_PIN4 = 108 , # [doc = "109: Port D, Pin5"]
PORTD_PIN5 = 109 , # [doc = "110: Port D, Pin6"]
PORTD_PIN6 = 110 , # [doc = "111: Port D, Pin7"]
PORTD_PIN7 = 111 , # [doc = "112: Port E, Pin0"]
PORTE_PIN0 = 112 , # [doc = "113: Port E, Pin1"]
PORTE_PIN1 = 113 , # [doc = "114: Port E, Pin2"]
PORTE_PIN2 = 114 , # [doc = "115: Port E, Pin3"]
PORTE_PIN3 = 115 , # [doc = "116: Port E, Pin4"]
PORTE_PIN4 = 116 , # [doc = "117: Port E, Pin5"]
PORTE_PIN5 = 117 , # [doc = "118: Port E, Pin6"]
PORTE_PIN6 = 118 , # [doc = "119: Port E, Pin7"]
PORTE_PIN7 = 119 , # [doc = "120: Port F, Pin0"]
PORTF_PIN0 = 120 , # [doc = "121: Port F, Pin1"]
PORTF_PIN1 = 121 , # [doc = "122: Port F, Pin2"]
PORTF_PIN2 = 122 , # [doc = "123: Port F, Pin3"]
PORTF_PIN3 = 123 , # [doc = "124: Port F, Pin4"]
PORTF_PIN4 = 124 , # [doc = "125: Port F, Pin5"]
PORTF_PIN5 = 125 , # [doc = "126: Port F, Pin6"]
PORTF_PIN6 = 126 , # [doc = "127: Port F, Pin7"]
PORTF_PIN7 = 127 , # [doc = "128: Prescaler, divide by 1"]
PRESCALER_1 = 128 , # [doc = "129: Prescaler, divide by 2"]
PRESCALER_2 = 129 , # [doc = "130: Prescaler, divide by 4"]
PRESCALER_4 = 130 , # [doc = "131: Prescaler, divide by 8"]
PRESCALER_8 = 131 , # [doc = "132: Prescaler, divide by 16"]
PRESCALER_16 = 132 , # [doc = "133: Prescaler, divide by 32"]
PRESCALER_32 = 133 , # [doc = "134: Prescaler, divide by 64"]
PRESCALER_64 = 134 , # [doc = "135: Prescaler, divide by 128"]
PRESCALER_128 = 135 , # [doc = "136: Prescaler, divide by 256"]
PRESCALER_256 = 136 , # [doc = "137: Prescaler, divide by 512"]
PRESCALER_512 = 137 , # [doc = "138: Prescaler, divide by 1024"]
PRESCALER_1024 = 138 , # [doc = "139: Prescaler, divide by 2048"]
PRESCALER_2048 = 139 , # [doc = "140: Prescaler, divide by 4096"]
PRESCALER_4096 = 140 , # [doc = "141: Prescaler, divide by 8192"]
PRESCALER_8192 = 141 , # [doc = "142: Prescaler, divide by 16384"]
PRESCALER_16384 = 142 , # [doc = "143: Prescaler, divide by 32768"]
PRESCALER_32768 = 143 , # [doc = "192: Timer/Counter C0 Overflow"]
TCC0_OVF = 192 , # [doc = "193: Timer/Counter C0 Error"]
TCC0_ERR = 193 , # [doc = "196: Timer/Counter C0 Compare or Capture A"]
TCC0_CCA = 196 , # [doc = "197: Timer/Counter C0 Compare or Capture B"]
TCC0_CCB = 197 , # [doc = "198: Timer/Counter C0 Compare or Capture C"]
TCC0_CCC = 198 , # [doc = "199: Timer/Counter C0 Compare or Capture D"]
TCC0_CCD = 199 , # [doc = "200: Timer/Counter C1 Overflow"]
TCC1_OVF = 200 , # [doc = "201: Timer/Counter C1 Error"]
TCC1_ERR = 201 , # [doc = "204: Timer/Counter C1 Compare or Capture A"]
TCC1_CCA = 204 , # [doc = "205: Timer/Counter C1 Compare or Capture B"]
TCC1_CCB = 205 , # [doc = "208: Timer/Counter D0 Overflow"]
TCD0_OVF = 208 , # [doc = "209: Timer/Counter D0 Error"]
TCD0_ERR = 209 , # [doc = "212: Timer/Counter D0 Compare or Capture A"]
TCD0_CCA = 212 , # [doc = "213: Timer/Counter D0 Compare or Capture B"]
TCD0_CCB = 213 , # [doc = "214: Timer/Counter D0 Compare or Capture C"]
TCD0_CCC = 214 , # [doc = "215: Timer/Counter D0 Compare or Capture D"]
TCD0_CCD = 215 , # [doc = "216: Timer/Counter D1 Overflow"]
TCD1_OVF = 216 , # [doc = "217: Timer/Counter D1 Error"]
TCD1_ERR = 217 , # [doc = "220: Timer/Counter D1 Compare or Capture A"]
TCD1_CCA = 220 , # [doc = "221: Timer/Counter D1 Compare or Capture B"]
TCD1_CCB = 221 , # [doc = "224: Timer/Counter E0 Overflow"]
TCE0_OVF = 224 , # [doc = "225: Timer/Counter E0 Error"]
TCE0_ERR = 225 , # [doc = "228: Timer/Counter E0 Compare or Capture A"]
TCE0_CCA = 228 , # [doc = "229: Timer/Counter E0 Compare or Capture B"]
TCE0_CCB = 229 , # [doc = "230: Timer/Counter E0 Compare or Capture C"]
TCE0_CCC = 230 , # [doc = "231: Timer/Counter E0 Compare or Capture D"]
TCE0_CCD = 231 , # [doc = "232: Timer/Counter E1 Overflow"]
TCE1_OVF = 232 , # [doc = "233: Timer/Counter E1 Error"]
TCE1_ERR = 233 , # [doc = "236: Timer/Counter E1 Compare or Capture A"]
TCE1_CCA = 236 , # [doc = "237: Timer/Counter E1 Compare or Capture B"]
TCE1_CCB = 237 , # [doc = "240: Timer/Counter F0 Overflow"]
TCF0_OVF = 240 , # [doc = "241: Timer/Counter F0 Error"]
TCF0_ERR = 241 , # [doc = "244: Timer/Counter F0 Compare or Capture A"]
TCF0_CCA = 244 , # [doc = "245: Timer/Counter F0 Compare or Capture B"]
TCF0_CCB = 245 , # [doc = "246: Timer/Counter F0 Compare or Capture C"]
TCF0_CCC = 246 , # [doc = "247: Timer/Counter F0 Compare or Capture D"]
TCF0_CCD = 247 , # [doc = "248: Timer/Counter F1 Overflow"]
TCF1_OVF = 248 , # [doc = "249: Timer/Counter F1 Error"]
TCF1_ERR = 249 , # [doc = "252: Timer/Counter F1 Compare or Capture A"]
TCF1_CCA = 252 , # [doc = "253: Timer/Counter F1 Compare or Capture B"]
TCF1_CCB = 253 , } impl From < CHMUX_A > for u8 { # [inline (always)]
fn from (variant : CHMUX_A) -> Self { variant as _ } } impl CHMUX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHMUX_A > { match self . bits { 0 => Some (CHMUX_A :: OFF) , 8 => Some (CHMUX_A :: RTC_OVF) , 9 => Some (CHMUX_A :: RTC_CMP) , 16 => Some (CHMUX_A :: ACA_CH0) , 17 => Some (CHMUX_A :: ACA_CH1) , 18 => Some (CHMUX_A :: ACA_WIN) , 19 => Some (CHMUX_A :: ACB_CH0) , 20 => Some (CHMUX_A :: ACB_CH1) , 21 => Some (CHMUX_A :: ACB_WIN) , 32 => Some (CHMUX_A :: ADCA_CH0) , 33 => Some (CHMUX_A :: ADCA_CH1) , 34 => Some (CHMUX_A :: ADCA_CH2) , 35 => Some (CHMUX_A :: ADCA_CH3) , 36 => Some (CHMUX_A :: ADCB_CH0) , 37 => Some (CHMUX_A :: ADCB_CH1) , 38 => Some (CHMUX_A :: ADCB_CH2) , 39 => Some (CHMUX_A :: ADCB_CH3) , 80 => Some (CHMUX_A :: PORTA_PIN0) , 81 => Some (CHMUX_A :: PORTA_PIN1) , 82 => Some (CHMUX_A :: PORTA_PIN2) , 83 => Some (CHMUX_A :: PORTA_PIN3) , 84 => Some (CHMUX_A :: PORTA_PIN4) , 85 => Some (CHMUX_A :: PORTA_PIN5) , 86 => Some (CHMUX_A :: PORTA_PIN6) , 87 => Some (CHMUX_A :: PORTA_PIN7) , 88 => Some (CHMUX_A :: PORTB_PIN0) , 89 => Some (CHMUX_A :: PORTB_PIN1) , 90 => Some (CHMUX_A :: PORTB_PIN2) , 91 => Some (CHMUX_A :: PORTB_PIN3) , 92 => Some (CHMUX_A :: PORTB_PIN4) , 93 => Some (CHMUX_A :: PORTB_PIN5) , 94 => Some (CHMUX_A :: PORTB_PIN6) , 95 => Some (CHMUX_A :: PORTB_PIN7) , 96 => Some (CHMUX_A :: PORTC_PIN0) , 97 => Some (CHMUX_A :: PORTC_PIN1) , 98 => Some (CHMUX_A :: PORTC_PIN2) , 99 => Some (CHMUX_A :: PORTC_PIN3) , 100 => Some (CHMUX_A :: PORTC_PIN4) , 101 => Some (CHMUX_A :: PORTC_PIN5) , 102 => Some (CHMUX_A :: PORTC_PIN6) , 103 => Some (CHMUX_A :: PORTC_PIN7) , 104 => Some (CHMUX_A :: PORTD_PIN0) , 105 => Some (CHMUX_A :: PORTD_PIN1) , 106 => Some (CHMUX_A :: PORTD_PIN2) , 107 => Some (CHMUX_A :: PORTD_PIN3) , 108 => Some (CHMUX_A :: PORTD_PIN4) , 109 => Some (CHMUX_A :: PORTD_PIN5) , 110 => Some (CHMUX_A :: PORTD_PIN6) , 111 => Some (CHMUX_A :: PORTD_PIN7) , 112 => Some (CHMUX_A :: PORTE_PIN0) , 113 => Some (CHMUX_A :: PORTE_PIN1) , 114 => Some (CHMUX_A :: PORTE_PIN2) , 115 => Some (CHMUX_A :: PORTE_PIN3) , 116 => Some (CHMUX_A :: PORTE_PIN4) , 117 => Some (CHMUX_A :: PORTE_PIN5) , 118 => Some (CHMUX_A :: PORTE_PIN6) , 119 => Some (CHMUX_A :: PORTE_PIN7) , 120 => Some (CHMUX_A :: PORTF_PIN0) , 121 => Some (CHMUX_A :: PORTF_PIN1) , 122 => Some (CHMUX_A :: PORTF_PIN2) , 123 => Some (CHMUX_A :: PORTF_PIN3) , 124 => Some (CHMUX_A :: PORTF_PIN4) , 125 => Some (CHMUX_A :: PORTF_PIN5) , 126 => Some (CHMUX_A :: PORTF_PIN6) , 127 => Some (CHMUX_A :: PORTF_PIN7) , 128 => Some (CHMUX_A :: PRESCALER_1) , 129 => Some (CHMUX_A :: PRESCALER_2) , 130 => Some (CHMUX_A :: PRESCALER_4) , 131 => Some (CHMUX_A :: PRESCALER_8) , 132 => Some (CHMUX_A :: PRESCALER_16) , 133 => Some (CHMUX_A :: PRESCALER_32) , 134 => Some (CHMUX_A :: PRESCALER_64) , 135 => Some (CHMUX_A :: PRESCALER_128) , 136 => Some (CHMUX_A :: PRESCALER_256) , 137 => Some (CHMUX_A :: PRESCALER_512) , 138 => Some (CHMUX_A :: PRESCALER_1024) , 139 => Some (CHMUX_A :: PRESCALER_2048) , 140 => Some (CHMUX_A :: PRESCALER_4096) , 141 => Some (CHMUX_A :: PRESCALER_8192) , 142 => Some (CHMUX_A :: PRESCALER_16384) , 143 => Some (CHMUX_A :: PRESCALER_32768) , 192 => Some (CHMUX_A :: TCC0_OVF) , 193 => Some (CHMUX_A :: TCC0_ERR) , 196 => Some (CHMUX_A :: TCC0_CCA) , 197 => Some (CHMUX_A :: TCC0_CCB) , 198 => Some (CHMUX_A :: TCC0_CCC) , 199 => Some (CHMUX_A :: TCC0_CCD) , 200 => Some (CHMUX_A :: TCC1_OVF) , 201 => Some (CHMUX_A :: TCC1_ERR) , 204 => Some (CHMUX_A :: TCC1_CCA) , 205 => Some (CHMUX_A :: TCC1_CCB) , 208 => Some (CHMUX_A :: TCD0_OVF) , 209 => Some (CHMUX_A :: TCD0_ERR) , 212 => Some (CHMUX_A :: TCD0_CCA) , 213 => Some (CHMUX_A :: TCD0_CCB) , 214 => Some (CHMUX_A :: TCD0_CCC) , 215 => Some (CHMUX_A :: TCD0_CCD) , 216 => Some (CHMUX_A :: TCD1_OVF) , 217 => Some (CHMUX_A :: TCD1_ERR) , 220 => Some (CHMUX_A :: TCD1_CCA) , 221 => Some (CHMUX_A :: TCD1_CCB) , 224 => Some (CHMUX_A :: TCE0_OVF) , 225 => Some (CHMUX_A :: TCE0_ERR) , 228 => Some (CHMUX_A :: TCE0_CCA) , 229 => Some (CHMUX_A :: TCE0_CCB) , 230 => Some (CHMUX_A :: TCE0_CCC) , 231 => Some (CHMUX_A :: TCE0_CCD) , 232 => Some (CHMUX_A :: TCE1_OVF) , 233 => Some (CHMUX_A :: TCE1_ERR) , 236 => Some (CHMUX_A :: TCE1_CCA) , 237 => Some (CHMUX_A :: TCE1_CCB) , 240 => Some (CHMUX_A :: TCF0_OVF) , 241 => Some (CHMUX_A :: TCF0_ERR) , 244 => Some (CHMUX_A :: TCF0_CCA) , 245 => Some (CHMUX_A :: TCF0_CCB) , 246 => Some (CHMUX_A :: TCF0_CCC) , 247 => Some (CHMUX_A :: TCF0_CCD) , 248 => Some (CHMUX_A :: TCF1_OVF) , 249 => Some (CHMUX_A :: TCF1_ERR) , 252 => Some (CHMUX_A :: TCF1_CCA) , 253 => Some (CHMUX_A :: TCF1_CCB) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CHMUX_A :: OFF } # [doc = "Checks if the value of the field is `RTC_OVF`"]
# [inline (always)]
pub fn is_rtc_ovf (& self) -> bool { * self == CHMUX_A :: RTC_OVF } # [doc = "Checks if the value of the field is `RTC_CMP`"]
# [inline (always)]
pub fn is_rtc_cmp (& self) -> bool { * self == CHMUX_A :: RTC_CMP } # [doc = "Checks if the value of the field is `ACA_CH0`"]
# [inline (always)]
pub fn is_aca_ch0 (& self) -> bool { * self == CHMUX_A :: ACA_CH0 } # [doc = "Checks if the value of the field is `ACA_CH1`"]
# [inline (always)]
pub fn is_aca_ch1 (& self) -> bool { * self == CHMUX_A :: ACA_CH1 } # [doc = "Checks if the value of the field is `ACA_WIN`"]
# [inline (always)]
pub fn is_aca_win (& self) -> bool { * self == CHMUX_A :: ACA_WIN } # [doc = "Checks if the value of the field is `ACB_CH0`"]
# [inline (always)]
pub fn is_acb_ch0 (& self) -> bool { * self == CHMUX_A :: ACB_CH0 } # [doc = "Checks if the value of the field is `ACB_CH1`"]
# [inline (always)]
pub fn is_acb_ch1 (& self) -> bool { * self == CHMUX_A :: ACB_CH1 } # [doc = "Checks if the value of the field is `ACB_WIN`"]
# [inline (always)]
pub fn is_acb_win (& self) -> bool { * self == CHMUX_A :: ACB_WIN } # [doc = "Checks if the value of the field is `ADCA_CH0`"]
# [inline (always)]
pub fn is_adca_ch0 (& self) -> bool { * self == CHMUX_A :: ADCA_CH0 } # [doc = "Checks if the value of the field is `ADCA_CH1`"]
# [inline (always)]
pub fn is_adca_ch1 (& self) -> bool { * self == CHMUX_A :: ADCA_CH1 } # [doc = "Checks if the value of the field is `ADCA_CH2`"]
# [inline (always)]
pub fn is_adca_ch2 (& self) -> bool { * self == CHMUX_A :: ADCA_CH2 } # [doc = "Checks if the value of the field is `ADCA_CH3`"]
# [inline (always)]
pub fn is_adca_ch3 (& self) -> bool { * self == CHMUX_A :: ADCA_CH3 } # [doc = "Checks if the value of the field is `ADCB_CH0`"]
# [inline (always)]
pub fn is_adcb_ch0 (& self) -> bool { * self == CHMUX_A :: ADCB_CH0 } # [doc = "Checks if the value of the field is `ADCB_CH1`"]
# [inline (always)]
pub fn is_adcb_ch1 (& self) -> bool { * self == CHMUX_A :: ADCB_CH1 } # [doc = "Checks if the value of the field is `ADCB_CH2`"]
# [inline (always)]
pub fn is_adcb_ch2 (& self) -> bool { * self == CHMUX_A :: ADCB_CH2 } # [doc = "Checks if the value of the field is `ADCB_CH3`"]
# [inline (always)]
pub fn is_adcb_ch3 (& self) -> bool { * self == CHMUX_A :: ADCB_CH3 } # [doc = "Checks if the value of the field is `PORTA_PIN0`"]
# [inline (always)]
pub fn is_porta_pin0 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN0 } # [doc = "Checks if the value of the field is `PORTA_PIN1`"]
# [inline (always)]
pub fn is_porta_pin1 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN1 } # [doc = "Checks if the value of the field is `PORTA_PIN2`"]
# [inline (always)]
pub fn is_porta_pin2 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN2 } # [doc = "Checks if the value of the field is `PORTA_PIN3`"]
# [inline (always)]
pub fn is_porta_pin3 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN3 } # [doc = "Checks if the value of the field is `PORTA_PIN4`"]
# [inline (always)]
pub fn is_porta_pin4 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN4 } # [doc = "Checks if the value of the field is `PORTA_PIN5`"]
# [inline (always)]
pub fn is_porta_pin5 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN5 } # [doc = "Checks if the value of the field is `PORTA_PIN6`"]
# [inline (always)]
pub fn is_porta_pin6 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN6 } # [doc = "Checks if the value of the field is `PORTA_PIN7`"]
# [inline (always)]
pub fn is_porta_pin7 (& self) -> bool { * self == CHMUX_A :: PORTA_PIN7 } # [doc = "Checks if the value of the field is `PORTB_PIN0`"]
# [inline (always)]
pub fn is_portb_pin0 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN0 } # [doc = "Checks if the value of the field is `PORTB_PIN1`"]
# [inline (always)]
pub fn is_portb_pin1 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN1 } # [doc = "Checks if the value of the field is `PORTB_PIN2`"]
# [inline (always)]
pub fn is_portb_pin2 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN2 } # [doc = "Checks if the value of the field is `PORTB_PIN3`"]
# [inline (always)]
pub fn is_portb_pin3 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN3 } # [doc = "Checks if the value of the field is `PORTB_PIN4`"]
# [inline (always)]
pub fn is_portb_pin4 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN4 } # [doc = "Checks if the value of the field is `PORTB_PIN5`"]
# [inline (always)]
pub fn is_portb_pin5 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN5 } # [doc = "Checks if the value of the field is `PORTB_PIN6`"]
# [inline (always)]
pub fn is_portb_pin6 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN6 } # [doc = "Checks if the value of the field is `PORTB_PIN7`"]
# [inline (always)]
pub fn is_portb_pin7 (& self) -> bool { * self == CHMUX_A :: PORTB_PIN7 } # [doc = "Checks if the value of the field is `PORTC_PIN0`"]
# [inline (always)]
pub fn is_portc_pin0 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN0 } # [doc = "Checks if the value of the field is `PORTC_PIN1`"]
# [inline (always)]
pub fn is_portc_pin1 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN1 } # [doc = "Checks if the value of the field is `PORTC_PIN2`"]
# [inline (always)]
pub fn is_portc_pin2 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN2 } # [doc = "Checks if the value of the field is `PORTC_PIN3`"]
# [inline (always)]
pub fn is_portc_pin3 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN3 } # [doc = "Checks if the value of the field is `PORTC_PIN4`"]
# [inline (always)]
pub fn is_portc_pin4 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN4 } # [doc = "Checks if the value of the field is `PORTC_PIN5`"]
# [inline (always)]
pub fn is_portc_pin5 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN5 } # [doc = "Checks if the value of the field is `PORTC_PIN6`"]
# [inline (always)]
pub fn is_portc_pin6 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN6 } # [doc = "Checks if the value of the field is `PORTC_PIN7`"]
# [inline (always)]
pub fn is_portc_pin7 (& self) -> bool { * self == CHMUX_A :: PORTC_PIN7 } # [doc = "Checks if the value of the field is `PORTD_PIN0`"]
# [inline (always)]
pub fn is_portd_pin0 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN0 } # [doc = "Checks if the value of the field is `PORTD_PIN1`"]
# [inline (always)]
pub fn is_portd_pin1 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN1 } # [doc = "Checks if the value of the field is `PORTD_PIN2`"]
# [inline (always)]
pub fn is_portd_pin2 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN2 } # [doc = "Checks if the value of the field is `PORTD_PIN3`"]
# [inline (always)]
pub fn is_portd_pin3 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN3 } # [doc = "Checks if the value of the field is `PORTD_PIN4`"]
# [inline (always)]
pub fn is_portd_pin4 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN4 } # [doc = "Checks if the value of the field is `PORTD_PIN5`"]
# [inline (always)]
pub fn is_portd_pin5 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN5 } # [doc = "Checks if the value of the field is `PORTD_PIN6`"]
# [inline (always)]
pub fn is_portd_pin6 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN6 } # [doc = "Checks if the value of the field is `PORTD_PIN7`"]
# [inline (always)]
pub fn is_portd_pin7 (& self) -> bool { * self == CHMUX_A :: PORTD_PIN7 } # [doc = "Checks if the value of the field is `PORTE_PIN0`"]
# [inline (always)]
pub fn is_porte_pin0 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN0 } # [doc = "Checks if the value of the field is `PORTE_PIN1`"]
# [inline (always)]
pub fn is_porte_pin1 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN1 } # [doc = "Checks if the value of the field is `PORTE_PIN2`"]
# [inline (always)]
pub fn is_porte_pin2 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN2 } # [doc = "Checks if the value of the field is `PORTE_PIN3`"]
# [inline (always)]
pub fn is_porte_pin3 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN3 } # [doc = "Checks if the value of the field is `PORTE_PIN4`"]
# [inline (always)]
pub fn is_porte_pin4 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN4 } # [doc = "Checks if the value of the field is `PORTE_PIN5`"]
# [inline (always)]
pub fn is_porte_pin5 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN5 } # [doc = "Checks if the value of the field is `PORTE_PIN6`"]
# [inline (always)]
pub fn is_porte_pin6 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN6 } # [doc = "Checks if the value of the field is `PORTE_PIN7`"]
# [inline (always)]
pub fn is_porte_pin7 (& self) -> bool { * self == CHMUX_A :: PORTE_PIN7 } # [doc = "Checks if the value of the field is `PORTF_PIN0`"]
# [inline (always)]
pub fn is_portf_pin0 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN0 } # [doc = "Checks if the value of the field is `PORTF_PIN1`"]
# [inline (always)]
pub fn is_portf_pin1 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN1 } # [doc = "Checks if the value of the field is `PORTF_PIN2`"]
# [inline (always)]
pub fn is_portf_pin2 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN2 } # [doc = "Checks if the value of the field is `PORTF_PIN3`"]
# [inline (always)]
pub fn is_portf_pin3 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN3 } # [doc = "Checks if the value of the field is `PORTF_PIN4`"]
# [inline (always)]
pub fn is_portf_pin4 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN4 } # [doc = "Checks if the value of the field is `PORTF_PIN5`"]
# [inline (always)]
pub fn is_portf_pin5 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN5 } # [doc = "Checks if the value of the field is `PORTF_PIN6`"]
# [inline (always)]
pub fn is_portf_pin6 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN6 } # [doc = "Checks if the value of the field is `PORTF_PIN7`"]
# [inline (always)]
pub fn is_portf_pin7 (& self) -> bool { * self == CHMUX_A :: PORTF_PIN7 } # [doc = "Checks if the value of the field is `PRESCALER_1`"]
# [inline (always)]
pub fn is_prescaler_1 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1 } # [doc = "Checks if the value of the field is `PRESCALER_2`"]
# [inline (always)]
pub fn is_prescaler_2 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2 } # [doc = "Checks if the value of the field is `PRESCALER_4`"]
# [inline (always)]
pub fn is_prescaler_4 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4 } # [doc = "Checks if the value of the field is `PRESCALER_8`"]
# [inline (always)]
pub fn is_prescaler_8 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8 } # [doc = "Checks if the value of the field is `PRESCALER_16`"]
# [inline (always)]
pub fn is_prescaler_16 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16 } # [doc = "Checks if the value of the field is `PRESCALER_32`"]
# [inline (always)]
pub fn is_prescaler_32 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32 } # [doc = "Checks if the value of the field is `PRESCALER_64`"]
# [inline (always)]
pub fn is_prescaler_64 (& self) -> bool { * self == CHMUX_A :: PRESCALER_64 } # [doc = "Checks if the value of the field is `PRESCALER_128`"]
# [inline (always)]
pub fn is_prescaler_128 (& self) -> bool { * self == CHMUX_A :: PRESCALER_128 } # [doc = "Checks if the value of the field is `PRESCALER_256`"]
# [inline (always)]
pub fn is_prescaler_256 (& self) -> bool { * self == CHMUX_A :: PRESCALER_256 } # [doc = "Checks if the value of the field is `PRESCALER_512`"]
# [inline (always)]
pub fn is_prescaler_512 (& self) -> bool { * self == CHMUX_A :: PRESCALER_512 } # [doc = "Checks if the value of the field is `PRESCALER_1024`"]
# [inline (always)]
pub fn is_prescaler_1024 (& self) -> bool { * self == CHMUX_A :: PRESCALER_1024 } # [doc = "Checks if the value of the field is `PRESCALER_2048`"]
# [inline (always)]
pub fn is_prescaler_2048 (& self) -> bool { * self == CHMUX_A :: PRESCALER_2048 } # [doc = "Checks if the value of the field is `PRESCALER_4096`"]
# [inline (always)]
pub fn is_prescaler_4096 (& self) -> bool { * self == CHMUX_A :: PRESCALER_4096 } # [doc = "Checks if the value of the field is `PRESCALER_8192`"]
# [inline (always)]
pub fn is_prescaler_8192 (& self) -> bool { * self == CHMUX_A :: PRESCALER_8192 } # [doc = "Checks if the value of the field is `PRESCALER_16384`"]
# [inline (always)]
pub fn is_prescaler_16384 (& self) -> bool { * self == CHMUX_A :: PRESCALER_16384 } # [doc = "Checks if the value of the field is `PRESCALER_32768`"]
# [inline (always)]
pub fn is_prescaler_32768 (& self) -> bool { * self == CHMUX_A :: PRESCALER_32768 } # [doc = "Checks if the value of the field is `TCC0_OVF`"]
# [inline (always)]
pub fn is_tcc0_ovf (& self) -> bool { * self == CHMUX_A :: TCC0_OVF } # [doc = "Checks if the value of the field is `TCC0_ERR`"]
# [inline (always)]
pub fn is_tcc0_err (& self) -> bool { * self == CHMUX_A :: TCC0_ERR } # [doc = "Checks if the value of the field is `TCC0_CCA`"]
# [inline (always)]
pub fn is_tcc0_cca (& self) -> bool { * self == CHMUX_A :: TCC0_CCA } # [doc = "Checks if the value of the field is `TCC0_CCB`"]
# [inline (always)]
pub fn is_tcc0_ccb (& self) -> bool { * self == CHMUX_A :: TCC0_CCB } # [doc = "Checks if the value of the field is `TCC0_CCC`"]
# [inline (always)]
pub fn is_tcc0_ccc (& self) -> bool { * self == CHMUX_A :: TCC0_CCC } # [doc = "Checks if the value of the field is `TCC0_CCD`"]
# [inline (always)]
pub fn is_tcc0_ccd (& self) -> bool { * self == CHMUX_A :: TCC0_CCD } # [doc = "Checks if the value of the field is `TCC1_OVF`"]
# [inline (always)]
pub fn is_tcc1_ovf (& self) -> bool { * self == CHMUX_A :: TCC1_OVF } # [doc = "Checks if the value of the field is `TCC1_ERR`"]
# [inline (always)]
pub fn is_tcc1_err (& self) -> bool { * self == CHMUX_A :: TCC1_ERR } # [doc = "Checks if the value of the field is `TCC1_CCA`"]
# [inline (always)]
pub fn is_tcc1_cca (& self) -> bool { * self == CHMUX_A :: TCC1_CCA } # [doc = "Checks if the value of the field is `TCC1_CCB`"]
# [inline (always)]
pub fn is_tcc1_ccb (& self) -> bool { * self == CHMUX_A :: TCC1_CCB } # [doc = "Checks if the value of the field is `TCD0_OVF`"]
# [inline (always)]
pub fn is_tcd0_ovf (& self) -> bool { * self == CHMUX_A :: TCD0_OVF } # [doc = "Checks if the value of the field is `TCD0_ERR`"]
# [inline (always)]
pub fn is_tcd0_err (& self) -> bool { * self == CHMUX_A :: TCD0_ERR } # [doc = "Checks if the value of the field is `TCD0_CCA`"]
# [inline (always)]
pub fn is_tcd0_cca (& self) -> bool { * self == CHMUX_A :: TCD0_CCA } # [doc = "Checks if the value of the field is `TCD0_CCB`"]
# [inline (always)]
pub fn is_tcd0_ccb (& self) -> bool { * self == CHMUX_A :: TCD0_CCB } # [doc = "Checks if the value of the field is `TCD0_CCC`"]
# [inline (always)]
pub fn is_tcd0_ccc (& self) -> bool { * self == CHMUX_A :: TCD0_CCC } # [doc = "Checks if the value of the field is `TCD0_CCD`"]
# [inline (always)]
pub fn is_tcd0_ccd (& self) -> bool { * self == CHMUX_A :: TCD0_CCD } # [doc = "Checks if the value of the field is `TCD1_OVF`"]
# [inline (always)]
pub fn is_tcd1_ovf (& self) -> bool { * self == CHMUX_A :: TCD1_OVF } # [doc = "Checks if the value of the field is `TCD1_ERR`"]
# [inline (always)]
pub fn is_tcd1_err (& self) -> bool { * self == CHMUX_A :: TCD1_ERR } # [doc = "Checks if the value of the field is `TCD1_CCA`"]
# [inline (always)]
pub fn is_tcd1_cca (& self) -> bool { * self == CHMUX_A :: TCD1_CCA } # [doc = "Checks if the value of the field is `TCD1_CCB`"]
# [inline (always)]
pub fn is_tcd1_ccb (& self) -> bool { * self == CHMUX_A :: TCD1_CCB } # [doc = "Checks if the value of the field is `TCE0_OVF`"]
# [inline (always)]
pub fn is_tce0_ovf (& self) -> bool { * self == CHMUX_A :: TCE0_OVF } # [doc = "Checks if the value of the field is `TCE0_ERR`"]
# [inline (always)]
pub fn is_tce0_err (& self) -> bool { * self == CHMUX_A :: TCE0_ERR } # [doc = "Checks if the value of the field is `TCE0_CCA`"]
# [inline (always)]
pub fn is_tce0_cca (& self) -> bool { * self == CHMUX_A :: TCE0_CCA } # [doc = "Checks if the value of the field is `TCE0_CCB`"]
# [inline (always)]
pub fn is_tce0_ccb (& self) -> bool { * self == CHMUX_A :: TCE0_CCB } # [doc = "Checks if the value of the field is `TCE0_CCC`"]
# [inline (always)]
pub fn is_tce0_ccc (& self) -> bool { * self == CHMUX_A :: TCE0_CCC } # [doc = "Checks if the value of the field is `TCE0_CCD`"]
# [inline (always)]
pub fn is_tce0_ccd (& self) -> bool { * self == CHMUX_A :: TCE0_CCD } # [doc = "Checks if the value of the field is `TCE1_OVF`"]
# [inline (always)]
pub fn is_tce1_ovf (& self) -> bool { * self == CHMUX_A :: TCE1_OVF } # [doc = "Checks if the value of the field is `TCE1_ERR`"]
# [inline (always)]
pub fn is_tce1_err (& self) -> bool { * self == CHMUX_A :: TCE1_ERR } # [doc = "Checks if the value of the field is `TCE1_CCA`"]
# [inline (always)]
pub fn is_tce1_cca (& self) -> bool { * self == CHMUX_A :: TCE1_CCA } # [doc = "Checks if the value of the field is `TCE1_CCB`"]
# [inline (always)]
pub fn is_tce1_ccb (& self) -> bool { * self == CHMUX_A :: TCE1_CCB } # [doc = "Checks if the value of the field is `TCF0_OVF`"]
# [inline (always)]
pub fn is_tcf0_ovf (& self) -> bool { * self == CHMUX_A :: TCF0_OVF } # [doc = "Checks if the value of the field is `TCF0_ERR`"]
# [inline (always)]
pub fn is_tcf0_err (& self) -> bool { * self == CHMUX_A :: TCF0_ERR } # [doc = "Checks if the value of the field is `TCF0_CCA`"]
# [inline (always)]
pub fn is_tcf0_cca (& self) -> bool { * self == CHMUX_A :: TCF0_CCA } # [doc = "Checks if the value of the field is `TCF0_CCB`"]
# [inline (always)]
pub fn is_tcf0_ccb (& self) -> bool { * self == CHMUX_A :: TCF0_CCB } # [doc = "Checks if the value of the field is `TCF0_CCC`"]
# [inline (always)]
pub fn is_tcf0_ccc (& self) -> bool { * self == CHMUX_A :: TCF0_CCC } # [doc = "Checks if the value of the field is `TCF0_CCD`"]
# [inline (always)]
pub fn is_tcf0_ccd (& self) -> bool { * self == CHMUX_A :: TCF0_CCD } # [doc = "Checks if the value of the field is `TCF1_OVF`"]
# [inline (always)]
pub fn is_tcf1_ovf (& self) -> bool { * self == CHMUX_A :: TCF1_OVF } # [doc = "Checks if the value of the field is `TCF1_ERR`"]
# [inline (always)]
pub fn is_tcf1_err (& self) -> bool { * self == CHMUX_A :: TCF1_ERR } # [doc = "Checks if the value of the field is `TCF1_CCA`"]
# [inline (always)]
pub fn is_tcf1_cca (& self) -> bool { * self == CHMUX_A :: TCF1_CCA } # [doc = "Checks if the value of the field is `TCF1_CCB`"]
# [inline (always)]
pub fn is_tcf1_ccb (& self) -> bool { * self == CHMUX_A :: TCF1_CCB } } # [doc = "Field `CHMUX` writer - Event Channel 7 Multiplexer"]
pub type CHMUX_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CH7MUX_SPEC , u8 , CHMUX_A , 8 , O > ; impl < 'a , const O : u8 > CHMUX_W < 'a , O > { # [doc = "Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CHMUX_A :: OFF) } # [doc = "RTC Overflow"]
# [inline (always)]
pub fn rtc_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_OVF) } # [doc = "RTC Compare Match"]
# [inline (always)]
pub fn rtc_cmp (self) -> & 'a mut W { self . variant (CHMUX_A :: RTC_CMP) } # [doc = "Analog Comparator A Channel 0"]
# [inline (always)]
pub fn aca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH0) } # [doc = "Analog Comparator A Channel 1"]
# [inline (always)]
pub fn aca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_CH1) } # [doc = "Analog Comparator A Window"]
# [inline (always)]
pub fn aca_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACA_WIN) } # [doc = "Analog Comparator B Channel 0"]
# [inline (always)]
pub fn acb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH0) } # [doc = "Analog Comparator B Channel 1"]
# [inline (always)]
pub fn acb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_CH1) } # [doc = "Analog Comparator B Window"]
# [inline (always)]
pub fn acb_win (self) -> & 'a mut W { self . variant (CHMUX_A :: ACB_WIN) } # [doc = "ADC A Channel 0"]
# [inline (always)]
pub fn adca_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH0) } # [doc = "ADC A Channel 1"]
# [inline (always)]
pub fn adca_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH1) } # [doc = "ADC A Channel 2"]
# [inline (always)]
pub fn adca_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH2) } # [doc = "ADC A Channel 3"]
# [inline (always)]
pub fn adca_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCA_CH3) } # [doc = "ADC B Channel 0"]
# [inline (always)]
pub fn adcb_ch0 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH0) } # [doc = "ADC B Channel 1"]
# [inline (always)]
pub fn adcb_ch1 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH1) } # [doc = "ADC B Channel 2"]
# [inline (always)]
pub fn adcb_ch2 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH2) } # [doc = "ADC B Channel 3"]
# [inline (always)]
pub fn adcb_ch3 (self) -> & 'a mut W { self . variant (CHMUX_A :: ADCB_CH3) } # [doc = "Port A, Pin0"]
# [inline (always)]
pub fn porta_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN0) } # [doc = "Port A, Pin1"]
# [inline (always)]
pub fn porta_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN1) } # [doc = "Port A, Pin2"]
# [inline (always)]
pub fn porta_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN2) } # [doc = "Port A, Pin3"]
# [inline (always)]
pub fn porta_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN3) } # [doc = "Port A, Pin4"]
# [inline (always)]
pub fn porta_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN4) } # [doc = "Port A, Pin5"]
# [inline (always)]
pub fn porta_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN5) } # [doc = "Port A, Pin6"]
# [inline (always)]
pub fn porta_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN6) } # [doc = "Port A, Pin7"]
# [inline (always)]
pub fn porta_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTA_PIN7) } # [doc = "Port B, Pin0"]
# [inline (always)]
pub fn portb_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN0) } # [doc = "Port B, Pin1"]
# [inline (always)]
pub fn portb_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN1) } # [doc = "Port B, Pin2"]
# [inline (always)]
pub fn portb_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN2) } # [doc = "Port B, Pin3"]
# [inline (always)]
pub fn portb_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN3) } # [doc = "Port B, Pin4"]
# [inline (always)]
pub fn portb_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN4) } # [doc = "Port B, Pin5"]
# [inline (always)]
pub fn portb_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN5) } # [doc = "Port B, Pin6"]
# [inline (always)]
pub fn portb_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN6) } # [doc = "Port B, Pin7"]
# [inline (always)]
pub fn portb_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTB_PIN7) } # [doc = "Port C, Pin0"]
# [inline (always)]
pub fn portc_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN0) } # [doc = "Port C, Pin1"]
# [inline (always)]
pub fn portc_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN1) } # [doc = "Port C, Pin2"]
# [inline (always)]
pub fn portc_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN2) } # [doc = "Port C, Pin3"]
# [inline (always)]
pub fn portc_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN3) } # [doc = "Port C, Pin4"]
# [inline (always)]
pub fn portc_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN4) } # [doc = "Port C, Pin5"]
# [inline (always)]
pub fn portc_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN5) } # [doc = "Port C, Pin6"]
# [inline (always)]
pub fn portc_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN6) } # [doc = "Port C, Pin7"]
# [inline (always)]
pub fn portc_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTC_PIN7) } # [doc = "Port D, Pin0"]
# [inline (always)]
pub fn portd_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN0) } # [doc = "Port D, Pin1"]
# [inline (always)]
pub fn portd_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN1) } # [doc = "Port D, Pin2"]
# [inline (always)]
pub fn portd_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN2) } # [doc = "Port D, Pin3"]
# [inline (always)]
pub fn portd_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN3) } # [doc = "Port D, Pin4"]
# [inline (always)]
pub fn portd_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN4) } # [doc = "Port D, Pin5"]
# [inline (always)]
pub fn portd_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN5) } # [doc = "Port D, Pin6"]
# [inline (always)]
pub fn portd_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN6) } # [doc = "Port D, Pin7"]
# [inline (always)]
pub fn portd_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTD_PIN7) } # [doc = "Port E, Pin0"]
# [inline (always)]
pub fn porte_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN0) } # [doc = "Port E, Pin1"]
# [inline (always)]
pub fn porte_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN1) } # [doc = "Port E, Pin2"]
# [inline (always)]
pub fn porte_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN2) } # [doc = "Port E, Pin3"]
# [inline (always)]
pub fn porte_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN3) } # [doc = "Port E, Pin4"]
# [inline (always)]
pub fn porte_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN4) } # [doc = "Port E, Pin5"]
# [inline (always)]
pub fn porte_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN5) } # [doc = "Port E, Pin6"]
# [inline (always)]
pub fn porte_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN6) } # [doc = "Port E, Pin7"]
# [inline (always)]
pub fn porte_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTE_PIN7) } # [doc = "Port F, Pin0"]
# [inline (always)]
pub fn portf_pin0 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN0) } # [doc = "Port F, Pin1"]
# [inline (always)]
pub fn portf_pin1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN1) } # [doc = "Port F, Pin2"]
# [inline (always)]
pub fn portf_pin2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN2) } # [doc = "Port F, Pin3"]
# [inline (always)]
pub fn portf_pin3 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN3) } # [doc = "Port F, Pin4"]
# [inline (always)]
pub fn portf_pin4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN4) } # [doc = "Port F, Pin5"]
# [inline (always)]
pub fn portf_pin5 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN5) } # [doc = "Port F, Pin6"]
# [inline (always)]
pub fn portf_pin6 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN6) } # [doc = "Port F, Pin7"]
# [inline (always)]
pub fn portf_pin7 (self) -> & 'a mut W { self . variant (CHMUX_A :: PORTF_PIN7) } # [doc = "Prescaler, divide by 1"]
# [inline (always)]
pub fn prescaler_1 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1) } # [doc = "Prescaler, divide by 2"]
# [inline (always)]
pub fn prescaler_2 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2) } # [doc = "Prescaler, divide by 4"]
# [inline (always)]
pub fn prescaler_4 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4) } # [doc = "Prescaler, divide by 8"]
# [inline (always)]
pub fn prescaler_8 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8) } # [doc = "Prescaler, divide by 16"]
# [inline (always)]
pub fn prescaler_16 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16) } # [doc = "Prescaler, divide by 32"]
# [inline (always)]
pub fn prescaler_32 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32) } # [doc = "Prescaler, divide by 64"]
# [inline (always)]
pub fn prescaler_64 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_64) } # [doc = "Prescaler, divide by 128"]
# [inline (always)]
pub fn prescaler_128 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_128) } # [doc = "Prescaler, divide by 256"]
# [inline (always)]
pub fn prescaler_256 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_256) } # [doc = "Prescaler, divide by 512"]
# [inline (always)]
pub fn prescaler_512 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_512) } # [doc = "Prescaler, divide by 1024"]
# [inline (always)]
pub fn prescaler_1024 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_1024) } # [doc = "Prescaler, divide by 2048"]
# [inline (always)]
pub fn prescaler_2048 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_2048) } # [doc = "Prescaler, divide by 4096"]
# [inline (always)]
pub fn prescaler_4096 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_4096) } # [doc = "Prescaler, divide by 8192"]
# [inline (always)]
pub fn prescaler_8192 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_8192) } # [doc = "Prescaler, divide by 16384"]
# [inline (always)]
pub fn prescaler_16384 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_16384) } # [doc = "Prescaler, divide by 32768"]
# [inline (always)]
pub fn prescaler_32768 (self) -> & 'a mut W { self . variant (CHMUX_A :: PRESCALER_32768) } # [doc = "Timer/Counter C0 Overflow"]
# [inline (always)]
pub fn tcc0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_OVF) } # [doc = "Timer/Counter C0 Error"]
# [inline (always)]
pub fn tcc0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_ERR) } # [doc = "Timer/Counter C0 Compare or Capture A"]
# [inline (always)]
pub fn tcc0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCA) } # [doc = "Timer/Counter C0 Compare or Capture B"]
# [inline (always)]
pub fn tcc0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCB) } # [doc = "Timer/Counter C0 Compare or Capture C"]
# [inline (always)]
pub fn tcc0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCC) } # [doc = "Timer/Counter C0 Compare or Capture D"]
# [inline (always)]
pub fn tcc0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC0_CCD) } # [doc = "Timer/Counter C1 Overflow"]
# [inline (always)]
pub fn tcc1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_OVF) } # [doc = "Timer/Counter C1 Error"]
# [inline (always)]
pub fn tcc1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_ERR) } # [doc = "Timer/Counter C1 Compare or Capture A"]
# [inline (always)]
pub fn tcc1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCA) } # [doc = "Timer/Counter C1 Compare or Capture B"]
# [inline (always)]
pub fn tcc1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCC1_CCB) } # [doc = "Timer/Counter D0 Overflow"]
# [inline (always)]
pub fn tcd0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_OVF) } # [doc = "Timer/Counter D0 Error"]
# [inline (always)]
pub fn tcd0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_ERR) } # [doc = "Timer/Counter D0 Compare or Capture A"]
# [inline (always)]
pub fn tcd0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCA) } # [doc = "Timer/Counter D0 Compare or Capture B"]
# [inline (always)]
pub fn tcd0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCB) } # [doc = "Timer/Counter D0 Compare or Capture C"]
# [inline (always)]
pub fn tcd0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCC) } # [doc = "Timer/Counter D0 Compare or Capture D"]
# [inline (always)]
pub fn tcd0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD0_CCD) } # [doc = "Timer/Counter D1 Overflow"]
# [inline (always)]
pub fn tcd1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_OVF) } # [doc = "Timer/Counter D1 Error"]
# [inline (always)]
pub fn tcd1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_ERR) } # [doc = "Timer/Counter D1 Compare or Capture A"]
# [inline (always)]
pub fn tcd1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCA) } # [doc = "Timer/Counter D1 Compare or Capture B"]
# [inline (always)]
pub fn tcd1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCD1_CCB) } # [doc = "Timer/Counter E0 Overflow"]
# [inline (always)]
pub fn tce0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_OVF) } # [doc = "Timer/Counter E0 Error"]
# [inline (always)]
pub fn tce0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_ERR) } # [doc = "Timer/Counter E0 Compare or Capture A"]
# [inline (always)]
pub fn tce0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCA) } # [doc = "Timer/Counter E0 Compare or Capture B"]
# [inline (always)]
pub fn tce0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCB) } # [doc = "Timer/Counter E0 Compare or Capture C"]
# [inline (always)]
pub fn tce0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCC) } # [doc = "Timer/Counter E0 Compare or Capture D"]
# [inline (always)]
pub fn tce0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE0_CCD) } # [doc = "Timer/Counter E1 Overflow"]
# [inline (always)]
pub fn tce1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_OVF) } # [doc = "Timer/Counter E1 Error"]
# [inline (always)]
pub fn tce1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_ERR) } # [doc = "Timer/Counter E1 Compare or Capture A"]
# [inline (always)]
pub fn tce1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCA) } # [doc = "Timer/Counter E1 Compare or Capture B"]
# [inline (always)]
pub fn tce1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCE1_CCB) } # [doc = "Timer/Counter F0 Overflow"]
# [inline (always)]
pub fn tcf0_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_OVF) } # [doc = "Timer/Counter F0 Error"]
# [inline (always)]
pub fn tcf0_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_ERR) } # [doc = "Timer/Counter F0 Compare or Capture A"]
# [inline (always)]
pub fn tcf0_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCA) } # [doc = "Timer/Counter F0 Compare or Capture B"]
# [inline (always)]
pub fn tcf0_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCB) } # [doc = "Timer/Counter F0 Compare or Capture C"]
# [inline (always)]
pub fn tcf0_ccc (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCC) } # [doc = "Timer/Counter F0 Compare or Capture D"]
# [inline (always)]
pub fn tcf0_ccd (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF0_CCD) } # [doc = "Timer/Counter F1 Overflow"]
# [inline (always)]
pub fn tcf1_ovf (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_OVF) } # [doc = "Timer/Counter F1 Error"]
# [inline (always)]
pub fn tcf1_err (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_ERR) } # [doc = "Timer/Counter F1 Compare or Capture A"]
# [inline (always)]
pub fn tcf1_cca (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCA) } # [doc = "Timer/Counter F1 Compare or Capture B"]
# [inline (always)]
pub fn tcf1_ccb (self) -> & 'a mut W { self . variant (CHMUX_A :: TCF1_CCB) } } impl R { # [doc = "Bits 0:7 - Event Channel 7 Multiplexer"]
# [inline (always)]
pub fn chmux (& self) -> CHMUX_R { CHMUX_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Event Channel 7 Multiplexer"]
# [inline (always)]
# [must_use]
pub fn chmux (& mut self) -> CHMUX_W < 0 > { CHMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Channel 7 Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch7mux](index.html) module"]
pub struct CH7MUX_SPEC ; impl crate :: RegisterSpec for CH7MUX_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ch7mux::R](R) reader structure"]
impl crate :: Readable for CH7MUX_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ch7mux::W](W) writer structure"]
impl crate :: Writable for CH7MUX_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CH7MUX to value 0"]
impl crate :: Resettable for CH7MUX_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Event Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Event Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STROBE (rw) register accessor: an alias for `Reg<STROBE_SPEC>`"]
pub type STROBE = crate :: Reg < strobe :: STROBE_SPEC > ; # [doc = "Event Strobe"]
pub mod strobe { # [doc = "Register `STROBE` reader"]
pub struct R (crate :: R < STROBE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STROBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STROBE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STROBE_SPEC >) -> Self { R (reader) } } # [doc = "Register `STROBE` writer"]
pub struct W (crate :: W < STROBE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STROBE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STROBE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STROBE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Event Strobe\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [strobe](index.html) module"]
pub struct STROBE_SPEC ; impl crate :: RegisterSpec for STROBE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [strobe::R](R) reader structure"]
impl crate :: Readable for STROBE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [strobe::W](W) writer structure"]
impl crate :: Writable for STROBE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STROBE to value 0"]
impl crate :: Resettable for STROBE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Non Volatile Memory Controller"]
pub struct FUSE { _marker : PhantomData < * const () > } unsafe impl Send for FUSE { } impl FUSE { # [doc = r"Pointer to the register block"]
pub const PTR : * const fuse :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const fuse :: RegisterBlock { Self :: PTR } } impl Deref for FUSE { type Target = fuse :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for FUSE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("FUSE") . finish () } } # [doc = "Non Volatile Memory Controller"]
pub mod fuse { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - JTAG User ID"]
pub fusebyte0 : FUSEBYTE0 , # [doc = "0x01 - Watchdog Configuration"]
pub fusebyte1 : FUSEBYTE1 , # [doc = "0x02 - Reset Configuration"]
pub fusebyte2 : FUSEBYTE2 , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - Start-up Configuration"]
pub fusebyte4 : FUSEBYTE4 , # [doc = "0x05 - EESAVE and BOD Level"]
pub fusebyte5 : FUSEBYTE5 , } # [doc = "FUSEBYTE0 (rw) register accessor: an alias for `Reg<FUSEBYTE0_SPEC>`"]
pub type FUSEBYTE0 = crate :: Reg < fusebyte0 :: FUSEBYTE0_SPEC > ; # [doc = "JTAG User ID"]
pub mod fusebyte0 { # [doc = "Register `FUSEBYTE0` reader"]
pub struct R (crate :: R < FUSEBYTE0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FUSEBYTE0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FUSEBYTE0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FUSEBYTE0_SPEC >) -> Self { R (reader) } } # [doc = "Register `FUSEBYTE0` writer"]
pub struct W (crate :: W < FUSEBYTE0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FUSEBYTE0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FUSEBYTE0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FUSEBYTE0_SPEC >) -> Self { W (writer) } } # [doc = "Field `JTAGUSERID` reader - JTAG User ID"]
pub type JTAGUSERID_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `JTAGUSERID` writer - JTAG User ID"]
pub type JTAGUSERID_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , FUSEBYTE0_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - JTAG User ID"]
# [inline (always)]
pub fn jtaguserid (& self) -> JTAGUSERID_R { JTAGUSERID_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - JTAG User ID"]
# [inline (always)]
# [must_use]
pub fn jtaguserid (& mut self) -> JTAGUSERID_W < 0 > { JTAGUSERID_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "JTAG User ID\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fusebyte0](index.html) module"]
pub struct FUSEBYTE0_SPEC ; impl crate :: RegisterSpec for FUSEBYTE0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fusebyte0::R](R) reader structure"]
impl crate :: Readable for FUSEBYTE0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fusebyte0::W](W) writer structure"]
impl crate :: Writable for FUSEBYTE0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FUSEBYTE0 to value 0"]
impl crate :: Resettable for FUSEBYTE0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FUSEBYTE1 (rw) register accessor: an alias for `Reg<FUSEBYTE1_SPEC>`"]
pub type FUSEBYTE1 = crate :: Reg < fusebyte1 :: FUSEBYTE1_SPEC > ; # [doc = "Watchdog Configuration"]
pub mod fusebyte1 { # [doc = "Register `FUSEBYTE1` reader"]
pub struct R (crate :: R < FUSEBYTE1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FUSEBYTE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FUSEBYTE1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FUSEBYTE1_SPEC >) -> Self { R (reader) } } # [doc = "Register `FUSEBYTE1` writer"]
pub struct W (crate :: W < FUSEBYTE1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FUSEBYTE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FUSEBYTE1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FUSEBYTE1_SPEC >) -> Self { W (writer) } } # [doc = "Field `WDPER` reader - Watchdog Timeout Period"]
pub type WDPER_R = crate :: FieldReader < u8 , WDPER_A > ; # [doc = "Watchdog Timeout Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WDPER_A { # [doc = "0: 8 cycles (8ms @ 3.3V)"]
_8CLK = 0 , # [doc = "1: 16 cycles (16ms @ 3.3V)"]
_16CLK = 1 , # [doc = "2: 32 cycles (32ms @ 3.3V)"]
_32CLK = 2 , # [doc = "3: 64 cycles (64ms @ 3.3V)"]
_64CLK = 3 , # [doc = "4: 128 cycles (0.125s @ 3.3V)"]
_128CLK = 4 , # [doc = "5: 256 cycles (0.25s @ 3.3V)"]
_256CLK = 5 , # [doc = "6: 512 cycles (0.5s @ 3.3V)"]
_512CLK = 6 , # [doc = "7: 1K cycles (1s @ 3.3V)"]
_1KCLK = 7 , # [doc = "8: 2K cycles (2s @ 3.3V)"]
_2KCLK = 8 , # [doc = "9: 4K cycles (4s @ 3.3V)"]
_4KCLK = 9 , # [doc = "10: 8K cycles (8s @ 3.3V)"]
_8KCLK = 10 , } impl From < WDPER_A > for u8 { # [inline (always)]
fn from (variant : WDPER_A) -> Self { variant as _ } } impl WDPER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WDPER_A > { match self . bits { 0 => Some (WDPER_A :: _8CLK) , 1 => Some (WDPER_A :: _16CLK) , 2 => Some (WDPER_A :: _32CLK) , 3 => Some (WDPER_A :: _64CLK) , 4 => Some (WDPER_A :: _128CLK) , 5 => Some (WDPER_A :: _256CLK) , 6 => Some (WDPER_A :: _512CLK) , 7 => Some (WDPER_A :: _1KCLK) , 8 => Some (WDPER_A :: _2KCLK) , 9 => Some (WDPER_A :: _4KCLK) , 10 => Some (WDPER_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == WDPER_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == WDPER_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == WDPER_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == WDPER_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == WDPER_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == WDPER_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == WDPER_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == WDPER_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == WDPER_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == WDPER_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == WDPER_A :: _8KCLK } } # [doc = "Field `WDPER` writer - Watchdog Timeout Period"]
pub type WDPER_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , FUSEBYTE1_SPEC , u8 , WDPER_A , 4 , O > ; impl < 'a , const O : u8 > WDPER_W < 'a , O > { # [doc = "8 cycles (8ms @ 3.3V)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (WDPER_A :: _8CLK) } # [doc = "16 cycles (16ms @ 3.3V)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (WDPER_A :: _16CLK) } # [doc = "32 cycles (32ms @ 3.3V)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (WDPER_A :: _32CLK) } # [doc = "64 cycles (64ms @ 3.3V)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (WDPER_A :: _64CLK) } # [doc = "128 cycles (0.125s @ 3.3V)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (WDPER_A :: _128CLK) } # [doc = "256 cycles (0.25s @ 3.3V)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (WDPER_A :: _256CLK) } # [doc = "512 cycles (0.5s @ 3.3V)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (WDPER_A :: _512CLK) } # [doc = "1K cycles (1s @ 3.3V)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (WDPER_A :: _1KCLK) } # [doc = "2K cycles (2s @ 3.3V)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (WDPER_A :: _2KCLK) } # [doc = "4K cycles (4s @ 3.3V)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (WDPER_A :: _4KCLK) } # [doc = "8K cycles (8s @ 3.3V)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (WDPER_A :: _8KCLK) } } # [doc = "Field `WDWPER` reader - Watchdog Window Timeout Period"]
pub type WDWPER_R = crate :: FieldReader < u8 , WDWPER_A > ; # [doc = "Watchdog Window Timeout Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WDWPER_A { # [doc = "0: 8 cycles (8ms @ 3.3V)"]
_8CLK = 0 , # [doc = "1: 16 cycles (16ms @ 3.3V)"]
_16CLK = 1 , # [doc = "2: 32 cycles (32ms @ 3.3V)"]
_32CLK = 2 , # [doc = "3: 64 cycles (64ms @ 3.3V)"]
_64CLK = 3 , # [doc = "4: 128 cycles (0.125s @ 3.3V)"]
_128CLK = 4 , # [doc = "5: 256 cycles (0.25s @ 3.3V)"]
_256CLK = 5 , # [doc = "6: 512 cycles (0.5s @ 3.3V)"]
_512CLK = 6 , # [doc = "7: 1K cycles (1s @ 3.3V)"]
_1KCLK = 7 , # [doc = "8: 2K cycles (2s @ 3.3V)"]
_2KCLK = 8 , # [doc = "9: 4K cycles (4s @ 3.3V)"]
_4KCLK = 9 , # [doc = "10: 8K cycles (8s @ 3.3V)"]
_8KCLK = 10 , } impl From < WDWPER_A > for u8 { # [inline (always)]
fn from (variant : WDWPER_A) -> Self { variant as _ } } impl WDWPER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WDWPER_A > { match self . bits { 0 => Some (WDWPER_A :: _8CLK) , 1 => Some (WDWPER_A :: _16CLK) , 2 => Some (WDWPER_A :: _32CLK) , 3 => Some (WDWPER_A :: _64CLK) , 4 => Some (WDWPER_A :: _128CLK) , 5 => Some (WDWPER_A :: _256CLK) , 6 => Some (WDWPER_A :: _512CLK) , 7 => Some (WDWPER_A :: _1KCLK) , 8 => Some (WDWPER_A :: _2KCLK) , 9 => Some (WDWPER_A :: _4KCLK) , 10 => Some (WDWPER_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == WDWPER_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == WDWPER_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == WDWPER_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == WDWPER_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == WDWPER_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == WDWPER_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == WDWPER_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == WDWPER_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == WDWPER_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == WDWPER_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == WDWPER_A :: _8KCLK } } # [doc = "Field `WDWPER` writer - Watchdog Window Timeout Period"]
pub type WDWPER_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , FUSEBYTE1_SPEC , u8 , WDWPER_A , 4 , O > ; impl < 'a , const O : u8 > WDWPER_W < 'a , O > { # [doc = "8 cycles (8ms @ 3.3V)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (WDWPER_A :: _8CLK) } # [doc = "16 cycles (16ms @ 3.3V)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (WDWPER_A :: _16CLK) } # [doc = "32 cycles (32ms @ 3.3V)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (WDWPER_A :: _32CLK) } # [doc = "64 cycles (64ms @ 3.3V)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (WDWPER_A :: _64CLK) } # [doc = "128 cycles (0.125s @ 3.3V)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (WDWPER_A :: _128CLK) } # [doc = "256 cycles (0.25s @ 3.3V)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (WDWPER_A :: _256CLK) } # [doc = "512 cycles (0.5s @ 3.3V)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (WDWPER_A :: _512CLK) } # [doc = "1K cycles (1s @ 3.3V)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (WDWPER_A :: _1KCLK) } # [doc = "2K cycles (2s @ 3.3V)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (WDWPER_A :: _2KCLK) } # [doc = "4K cycles (4s @ 3.3V)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (WDWPER_A :: _4KCLK) } # [doc = "8K cycles (8s @ 3.3V)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (WDWPER_A :: _8KCLK) } } impl R { # [doc = "Bits 0:3 - Watchdog Timeout Period"]
# [inline (always)]
pub fn wdper (& self) -> WDPER_R { WDPER_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Watchdog Window Timeout Period"]
# [inline (always)]
pub fn wdwper (& self) -> WDWPER_R { WDWPER_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Watchdog Timeout Period"]
# [inline (always)]
# [must_use]
pub fn wdper (& mut self) -> WDPER_W < 0 > { WDPER_W :: new (self) } # [doc = "Bits 4:7 - Watchdog Window Timeout Period"]
# [inline (always)]
# [must_use]
pub fn wdwper (& mut self) -> WDWPER_W < 4 > { WDWPER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Watchdog Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fusebyte1](index.html) module"]
pub struct FUSEBYTE1_SPEC ; impl crate :: RegisterSpec for FUSEBYTE1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fusebyte1::R](R) reader structure"]
impl crate :: Readable for FUSEBYTE1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fusebyte1::W](W) writer structure"]
impl crate :: Writable for FUSEBYTE1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FUSEBYTE1 to value 0"]
impl crate :: Resettable for FUSEBYTE1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FUSEBYTE2 (rw) register accessor: an alias for `Reg<FUSEBYTE2_SPEC>`"]
pub type FUSEBYTE2 = crate :: Reg < fusebyte2 :: FUSEBYTE2_SPEC > ; # [doc = "Reset Configuration"]
pub mod fusebyte2 { # [doc = "Register `FUSEBYTE2` reader"]
pub struct R (crate :: R < FUSEBYTE2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FUSEBYTE2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FUSEBYTE2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FUSEBYTE2_SPEC >) -> Self { R (reader) } } # [doc = "Register `FUSEBYTE2` writer"]
pub struct W (crate :: W < FUSEBYTE2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FUSEBYTE2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FUSEBYTE2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FUSEBYTE2_SPEC >) -> Self { W (writer) } } # [doc = "Field `BODPD` reader - BOD Operation in Power-Down Mode"]
pub type BODPD_R = crate :: FieldReader < u8 , BODPD_A > ; # [doc = "BOD Operation in Power-Down Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BODPD_A { # [doc = "1: BOD enabled in sampled mode"]
INSAMPLEDMODE = 1 , # [doc = "2: BOD enabled continuously"]
CONTINOUSLY = 2 , # [doc = "3: BOD Disabled"]
DISABLED = 3 , } impl From < BODPD_A > for u8 { # [inline (always)]
fn from (variant : BODPD_A) -> Self { variant as _ } } impl BODPD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < BODPD_A > { match self . bits { 1 => Some (BODPD_A :: INSAMPLEDMODE) , 2 => Some (BODPD_A :: CONTINOUSLY) , 3 => Some (BODPD_A :: DISABLED) , _ => None , } } # [doc = "Checks if the value of the field is `INSAMPLEDMODE`"]
# [inline (always)]
pub fn is_insampledmode (& self) -> bool { * self == BODPD_A :: INSAMPLEDMODE } # [doc = "Checks if the value of the field is `CONTINOUSLY`"]
# [inline (always)]
pub fn is_continously (& self) -> bool { * self == BODPD_A :: CONTINOUSLY } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == BODPD_A :: DISABLED } } # [doc = "Field `BODPD` writer - BOD Operation in Power-Down Mode"]
pub type BODPD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , FUSEBYTE2_SPEC , u8 , BODPD_A , 2 , O > ; impl < 'a , const O : u8 > BODPD_W < 'a , O > { # [doc = "BOD enabled in sampled mode"]
# [inline (always)]
pub fn insampledmode (self) -> & 'a mut W { self . variant (BODPD_A :: INSAMPLEDMODE) } # [doc = "BOD enabled continuously"]
# [inline (always)]
pub fn continously (self) -> & 'a mut W { self . variant (BODPD_A :: CONTINOUSLY) } # [doc = "BOD Disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (BODPD_A :: DISABLED) } } # [doc = "Field `BOOTRST` reader - Boot Loader Section Reset Vector"]
pub type BOOTRST_R = crate :: BitReader < BOOTRST_A > ; # [doc = "Boot Loader Section Reset Vector\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum BOOTRST_A { # [doc = "0: Boot Loader Reset"]
BOOTLDR = 0 , # [doc = "1: Application Reset"]
APPLICATION = 1 , } impl From < BOOTRST_A > for bool { # [inline (always)]
fn from (variant : BOOTRST_A) -> Self { variant as u8 != 0 } } impl BOOTRST_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BOOTRST_A { match self . bits { false => BOOTRST_A :: BOOTLDR , true => BOOTRST_A :: APPLICATION , } } # [doc = "Checks if the value of the field is `BOOTLDR`"]
# [inline (always)]
pub fn is_bootldr (& self) -> bool { * self == BOOTRST_A :: BOOTLDR } # [doc = "Checks if the value of the field is `APPLICATION`"]
# [inline (always)]
pub fn is_application (& self) -> bool { * self == BOOTRST_A :: APPLICATION } } # [doc = "Field `BOOTRST` writer - Boot Loader Section Reset Vector"]
pub type BOOTRST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FUSEBYTE2_SPEC , BOOTRST_A , O > ; impl < 'a , const O : u8 > BOOTRST_W < 'a , O > { # [doc = "Boot Loader Reset"]
# [inline (always)]
pub fn bootldr (self) -> & 'a mut W { self . variant (BOOTRST_A :: BOOTLDR) } # [doc = "Application Reset"]
# [inline (always)]
pub fn application (self) -> & 'a mut W { self . variant (BOOTRST_A :: APPLICATION) } } impl R { # [doc = "Bits 0:1 - BOD Operation in Power-Down Mode"]
# [inline (always)]
pub fn bodpd (& self) -> BODPD_R { BODPD_R :: new (self . bits & 3) } # [doc = "Bit 6 - Boot Loader Section Reset Vector"]
# [inline (always)]
pub fn bootrst (& self) -> BOOTRST_R { BOOTRST_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - BOD Operation in Power-Down Mode"]
# [inline (always)]
# [must_use]
pub fn bodpd (& mut self) -> BODPD_W < 0 > { BODPD_W :: new (self) } # [doc = "Bit 6 - Boot Loader Section Reset Vector"]
# [inline (always)]
# [must_use]
pub fn bootrst (& mut self) -> BOOTRST_W < 6 > { BOOTRST_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Reset Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fusebyte2](index.html) module"]
pub struct FUSEBYTE2_SPEC ; impl crate :: RegisterSpec for FUSEBYTE2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fusebyte2::R](R) reader structure"]
impl crate :: Readable for FUSEBYTE2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fusebyte2::W](W) writer structure"]
impl crate :: Writable for FUSEBYTE2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FUSEBYTE2 to value 0"]
impl crate :: Resettable for FUSEBYTE2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FUSEBYTE4 (rw) register accessor: an alias for `Reg<FUSEBYTE4_SPEC>`"]
pub type FUSEBYTE4 = crate :: Reg < fusebyte4 :: FUSEBYTE4_SPEC > ; # [doc = "Start-up Configuration"]
pub mod fusebyte4 { # [doc = "Register `FUSEBYTE4` reader"]
pub struct R (crate :: R < FUSEBYTE4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FUSEBYTE4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FUSEBYTE4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FUSEBYTE4_SPEC >) -> Self { R (reader) } } # [doc = "Register `FUSEBYTE4` writer"]
pub struct W (crate :: W < FUSEBYTE4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FUSEBYTE4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FUSEBYTE4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FUSEBYTE4_SPEC >) -> Self { W (writer) } } # [doc = "Field `JTAGEN` reader - JTAG Interface Enable"]
pub type JTAGEN_R = crate :: BitReader < bool > ; # [doc = "Field `JTAGEN` writer - JTAG Interface Enable"]
pub type JTAGEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FUSEBYTE4_SPEC , bool , O > ; # [doc = "Field `WDLOCK` reader - Watchdog Timer Lock"]
pub type WDLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `WDLOCK` writer - Watchdog Timer Lock"]
pub type WDLOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FUSEBYTE4_SPEC , bool , O > ; # [doc = "Field `STARTUPTIME` reader - Start-up Time"]
pub type STARTUPTIME_R = crate :: FieldReader < u8 , STARTUPTIME_A > ; # [doc = "Start-up Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum STARTUPTIME_A { # [doc = "0: 64 ms"]
_64MS = 0 , # [doc = "1: 4 ms"]
_4MS = 1 , # [doc = "3: 0 ms"]
_0MS = 3 , } impl From < STARTUPTIME_A > for u8 { # [inline (always)]
fn from (variant : STARTUPTIME_A) -> Self { variant as _ } } impl STARTUPTIME_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < STARTUPTIME_A > { match self . bits { 0 => Some (STARTUPTIME_A :: _64MS) , 1 => Some (STARTUPTIME_A :: _4MS) , 3 => Some (STARTUPTIME_A :: _0MS) , _ => None , } } # [doc = "Checks if the value of the field is `_64MS`"]
# [inline (always)]
pub fn is_64ms (& self) -> bool { * self == STARTUPTIME_A :: _64MS } # [doc = "Checks if the value of the field is `_4MS`"]
# [inline (always)]
pub fn is_4ms (& self) -> bool { * self == STARTUPTIME_A :: _4MS } # [doc = "Checks if the value of the field is `_0MS`"]
# [inline (always)]
pub fn is_0ms (& self) -> bool { * self == STARTUPTIME_A :: _0MS } } # [doc = "Field `STARTUPTIME` writer - Start-up Time"]
pub type STARTUPTIME_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , FUSEBYTE4_SPEC , u8 , STARTUPTIME_A , 2 , O > ; impl < 'a , const O : u8 > STARTUPTIME_W < 'a , O > { # [doc = "64 ms"]
# [inline (always)]
pub fn _64ms (self) -> & 'a mut W { self . variant (STARTUPTIME_A :: _64MS) } # [doc = "4 ms"]
# [inline (always)]
pub fn _4ms (self) -> & 'a mut W { self . variant (STARTUPTIME_A :: _4MS) } # [doc = "0 ms"]
# [inline (always)]
pub fn _0ms (self) -> & 'a mut W { self . variant (STARTUPTIME_A :: _0MS) } } # [doc = "Field `RSTDISBL` reader - External Reset Disable"]
pub type RSTDISBL_R = crate :: BitReader < bool > ; # [doc = "Field `RSTDISBL` writer - External Reset Disable"]
pub type RSTDISBL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FUSEBYTE4_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - JTAG Interface Enable"]
# [inline (always)]
pub fn jtagen (& self) -> JTAGEN_R { JTAGEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Watchdog Timer Lock"]
# [inline (always)]
pub fn wdlock (& self) -> WDLOCK_R { WDLOCK_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Start-up Time"]
# [inline (always)]
pub fn startuptime (& self) -> STARTUPTIME_R { STARTUPTIME_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - External Reset Disable"]
# [inline (always)]
pub fn rstdisbl (& self) -> RSTDISBL_R { RSTDISBL_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - JTAG Interface Enable"]
# [inline (always)]
# [must_use]
pub fn jtagen (& mut self) -> JTAGEN_W < 0 > { JTAGEN_W :: new (self) } # [doc = "Bit 1 - Watchdog Timer Lock"]
# [inline (always)]
# [must_use]
pub fn wdlock (& mut self) -> WDLOCK_W < 1 > { WDLOCK_W :: new (self) } # [doc = "Bits 2:3 - Start-up Time"]
# [inline (always)]
# [must_use]
pub fn startuptime (& mut self) -> STARTUPTIME_W < 2 > { STARTUPTIME_W :: new (self) } # [doc = "Bit 4 - External Reset Disable"]
# [inline (always)]
# [must_use]
pub fn rstdisbl (& mut self) -> RSTDISBL_W < 4 > { RSTDISBL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Start-up Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fusebyte4](index.html) module"]
pub struct FUSEBYTE4_SPEC ; impl crate :: RegisterSpec for FUSEBYTE4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fusebyte4::R](R) reader structure"]
impl crate :: Readable for FUSEBYTE4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fusebyte4::W](W) writer structure"]
impl crate :: Writable for FUSEBYTE4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FUSEBYTE4 to value 0"]
impl crate :: Resettable for FUSEBYTE4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "FUSEBYTE5 (rw) register accessor: an alias for `Reg<FUSEBYTE5_SPEC>`"]
pub type FUSEBYTE5 = crate :: Reg < fusebyte5 :: FUSEBYTE5_SPEC > ; # [doc = "EESAVE and BOD Level"]
pub mod fusebyte5 { # [doc = "Register `FUSEBYTE5` reader"]
pub struct R (crate :: R < FUSEBYTE5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FUSEBYTE5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FUSEBYTE5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FUSEBYTE5_SPEC >) -> Self { R (reader) } } # [doc = "Register `FUSEBYTE5` writer"]
pub struct W (crate :: W < FUSEBYTE5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FUSEBYTE5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FUSEBYTE5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FUSEBYTE5_SPEC >) -> Self { W (writer) } } # [doc = "Field `BODLEVEL` reader - Brownout Detection Voltage Level"]
pub type BODLEVEL_R = crate :: FieldReader < u8 , BODLEVEL_A > ; # [doc = "Brownout Detection Voltage Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BODLEVEL_A { # [doc = "0: 3.4 V"]
_3V4 = 0 , # [doc = "1: 3.2 V"]
_3V2 = 1 , # [doc = "2: 2.9 V"]
_2V9 = 2 , # [doc = "3: 2.6 V"]
_2V6 = 3 , # [doc = "4: 2.4 V"]
_2V4 = 4 , # [doc = "5: 2.1 V"]
_2V1 = 5 , # [doc = "6: 1.9 V"]
_1V9 = 6 , # [doc = "7: 1.6 V"]
_1V6 = 7 , } impl From < BODLEVEL_A > for u8 { # [inline (always)]
fn from (variant : BODLEVEL_A) -> Self { variant as _ } } impl BODLEVEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BODLEVEL_A { match self . bits { 0 => BODLEVEL_A :: _3V4 , 1 => BODLEVEL_A :: _3V2 , 2 => BODLEVEL_A :: _2V9 , 3 => BODLEVEL_A :: _2V6 , 4 => BODLEVEL_A :: _2V4 , 5 => BODLEVEL_A :: _2V1 , 6 => BODLEVEL_A :: _1V9 , 7 => BODLEVEL_A :: _1V6 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_3V4`"]
# [inline (always)]
pub fn is_3v4 (& self) -> bool { * self == BODLEVEL_A :: _3V4 } # [doc = "Checks if the value of the field is `_3V2`"]
# [inline (always)]
pub fn is_3v2 (& self) -> bool { * self == BODLEVEL_A :: _3V2 } # [doc = "Checks if the value of the field is `_2V9`"]
# [inline (always)]
pub fn is_2v9 (& self) -> bool { * self == BODLEVEL_A :: _2V9 } # [doc = "Checks if the value of the field is `_2V6`"]
# [inline (always)]
pub fn is_2v6 (& self) -> bool { * self == BODLEVEL_A :: _2V6 } # [doc = "Checks if the value of the field is `_2V4`"]
# [inline (always)]
pub fn is_2v4 (& self) -> bool { * self == BODLEVEL_A :: _2V4 } # [doc = "Checks if the value of the field is `_2V1`"]
# [inline (always)]
pub fn is_2v1 (& self) -> bool { * self == BODLEVEL_A :: _2V1 } # [doc = "Checks if the value of the field is `_1V9`"]
# [inline (always)]
pub fn is_1v9 (& self) -> bool { * self == BODLEVEL_A :: _1V9 } # [doc = "Checks if the value of the field is `_1V6`"]
# [inline (always)]
pub fn is_1v6 (& self) -> bool { * self == BODLEVEL_A :: _1V6 } } # [doc = "Field `BODLEVEL` writer - Brownout Detection Voltage Level"]
pub type BODLEVEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , FUSEBYTE5_SPEC , u8 , BODLEVEL_A , 3 , O > ; impl < 'a , const O : u8 > BODLEVEL_W < 'a , O > { # [doc = "3.4 V"]
# [inline (always)]
pub fn _3v4 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _3V4) } # [doc = "3.2 V"]
# [inline (always)]
pub fn _3v2 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _3V2) } # [doc = "2.9 V"]
# [inline (always)]
pub fn _2v9 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V9) } # [doc = "2.6 V"]
# [inline (always)]
pub fn _2v6 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V6) } # [doc = "2.4 V"]
# [inline (always)]
pub fn _2v4 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V4) } # [doc = "2.1 V"]
# [inline (always)]
pub fn _2v1 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _2V1) } # [doc = "1.9 V"]
# [inline (always)]
pub fn _1v9 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _1V9) } # [doc = "1.6 V"]
# [inline (always)]
pub fn _1v6 (self) -> & 'a mut W { self . variant (BODLEVEL_A :: _1V6) } } # [doc = "Field `EESAVE` reader - Preserve EEPROM Through Chip Erase"]
pub type EESAVE_R = crate :: BitReader < bool > ; # [doc = "Field `EESAVE` writer - Preserve EEPROM Through Chip Erase"]
pub type EESAVE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , FUSEBYTE5_SPEC , bool , O > ; # [doc = "Field `BODACT` reader - BOD Operation in Active Mode"]
pub type BODACT_R = crate :: FieldReader < u8 , BODACT_A > ; # [doc = "BOD Operation in Active Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BODACT_A { # [doc = "1: BOD enabled in sampled mode"]
INSAMPLEDMODE = 1 , # [doc = "2: BOD enabled continuously"]
CONTINOUSLY = 2 , # [doc = "3: BOD Disabled"]
DISABLED = 3 , } impl From < BODACT_A > for u8 { # [inline (always)]
fn from (variant : BODACT_A) -> Self { variant as _ } } impl BODACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < BODACT_A > { match self . bits { 1 => Some (BODACT_A :: INSAMPLEDMODE) , 2 => Some (BODACT_A :: CONTINOUSLY) , 3 => Some (BODACT_A :: DISABLED) , _ => None , } } # [doc = "Checks if the value of the field is `INSAMPLEDMODE`"]
# [inline (always)]
pub fn is_insampledmode (& self) -> bool { * self == BODACT_A :: INSAMPLEDMODE } # [doc = "Checks if the value of the field is `CONTINOUSLY`"]
# [inline (always)]
pub fn is_continously (& self) -> bool { * self == BODACT_A :: CONTINOUSLY } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == BODACT_A :: DISABLED } } # [doc = "Field `BODACT` writer - BOD Operation in Active Mode"]
pub type BODACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , FUSEBYTE5_SPEC , u8 , BODACT_A , 2 , O > ; impl < 'a , const O : u8 > BODACT_W < 'a , O > { # [doc = "BOD enabled in sampled mode"]
# [inline (always)]
pub fn insampledmode (self) -> & 'a mut W { self . variant (BODACT_A :: INSAMPLEDMODE) } # [doc = "BOD enabled continuously"]
# [inline (always)]
pub fn continously (self) -> & 'a mut W { self . variant (BODACT_A :: CONTINOUSLY) } # [doc = "BOD Disabled"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (BODACT_A :: DISABLED) } } impl R { # [doc = "Bits 0:2 - Brownout Detection Voltage Level"]
# [inline (always)]
pub fn bodlevel (& self) -> BODLEVEL_R { BODLEVEL_R :: new (self . bits & 7) } # [doc = "Bit 3 - Preserve EEPROM Through Chip Erase"]
# [inline (always)]
pub fn eesave (& self) -> EESAVE_R { EESAVE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - BOD Operation in Active Mode"]
# [inline (always)]
pub fn bodact (& self) -> BODACT_R { BODACT_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:2 - Brownout Detection Voltage Level"]
# [inline (always)]
# [must_use]
pub fn bodlevel (& mut self) -> BODLEVEL_W < 0 > { BODLEVEL_W :: new (self) } # [doc = "Bit 3 - Preserve EEPROM Through Chip Erase"]
# [inline (always)]
# [must_use]
pub fn eesave (& mut self) -> EESAVE_W < 3 > { EESAVE_W :: new (self) } # [doc = "Bits 4:5 - BOD Operation in Active Mode"]
# [inline (always)]
# [must_use]
pub fn bodact (& mut self) -> BODACT_W < 4 > { BODACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "EESAVE and BOD Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fusebyte5](index.html) module"]
pub struct FUSEBYTE5_SPEC ; impl crate :: RegisterSpec for FUSEBYTE5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fusebyte5::R](R) reader structure"]
impl crate :: Readable for FUSEBYTE5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fusebyte5::W](W) writer structure"]
impl crate :: Writable for FUSEBYTE5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets FUSEBYTE5 to value 0"]
impl crate :: Resettable for FUSEBYTE5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "General Purpose IO"]
pub struct GPIO { _marker : PhantomData < * const () > } unsafe impl Send for GPIO { } impl GPIO { # [doc = r"Pointer to the register block"]
pub const PTR : * const gpio :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const gpio :: RegisterBlock { Self :: PTR } } impl Deref for GPIO { type Target = gpio :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for GPIO { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("GPIO") . finish () } } # [doc = "General Purpose IO"]
pub mod gpio { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - General Purpose IO Register 0"]
pub gpior0 : GPIOR0 , # [doc = "0x01 - General Purpose IO Register 1"]
pub gpior1 : GPIOR1 , # [doc = "0x02 - General Purpose IO Register 2"]
pub gpior2 : GPIOR2 , # [doc = "0x03 - General Purpose IO Register 3"]
pub gpior3 : GPIOR3 , # [doc = "0x04 - General Purpose IO Register 4"]
pub gpior4 : GPIOR4 , # [doc = "0x05 - General Purpose IO Register 5"]
pub gpior5 : GPIOR5 , # [doc = "0x06 - General Purpose IO Register 6"]
pub gpior6 : GPIOR6 , # [doc = "0x07 - General Purpose IO Register 7"]
pub gpior7 : GPIOR7 , # [doc = "0x08 - General Purpose IO Register 8"]
pub gpior8 : GPIOR8 , # [doc = "0x09 - General Purpose IO Register 9"]
pub gpior9 : GPIOR9 , # [doc = "0x0a - General Purpose IO Register 10"]
pub gpiora : GPIORA , # [doc = "0x0b - General Purpose IO Register 11"]
pub gpiorb : GPIORB , # [doc = "0x0c - General Purpose IO Register 12"]
pub gpiorc : GPIORC , # [doc = "0x0d - General Purpose IO Register 13"]
pub gpiord : GPIORD , # [doc = "0x0e - General Purpose IO Register 14"]
pub gpiore : GPIORE , # [doc = "0x0f - General Purpose IO Register 15"]
pub gpiorf : GPIORF , } # [doc = "GPIOR0 (rw) register accessor: an alias for `Reg<GPIOR0_SPEC>`"]
pub type GPIOR0 = crate :: Reg < gpior0 :: GPIOR0_SPEC > ; # [doc = "General Purpose IO Register 0"]
pub mod gpior0 { # [doc = "Register `GPIOR0` reader"]
pub struct R (crate :: R < GPIOR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR0` writer"]
pub struct W (crate :: W < GPIOR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior0](index.html) module"]
pub struct GPIOR0_SPEC ; impl crate :: RegisterSpec for GPIOR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior0::R](R) reader structure"]
impl crate :: Readable for GPIOR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior0::W](W) writer structure"]
impl crate :: Writable for GPIOR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR0 to value 0"]
impl crate :: Resettable for GPIOR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR1 (rw) register accessor: an alias for `Reg<GPIOR1_SPEC>`"]
pub type GPIOR1 = crate :: Reg < gpior1 :: GPIOR1_SPEC > ; # [doc = "General Purpose IO Register 1"]
pub mod gpior1 { # [doc = "Register `GPIOR1` reader"]
pub struct R (crate :: R < GPIOR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR1` writer"]
pub struct W (crate :: W < GPIOR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior1](index.html) module"]
pub struct GPIOR1_SPEC ; impl crate :: RegisterSpec for GPIOR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior1::R](R) reader structure"]
impl crate :: Readable for GPIOR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior1::W](W) writer structure"]
impl crate :: Writable for GPIOR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR1 to value 0"]
impl crate :: Resettable for GPIOR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR2 (rw) register accessor: an alias for `Reg<GPIOR2_SPEC>`"]
pub type GPIOR2 = crate :: Reg < gpior2 :: GPIOR2_SPEC > ; # [doc = "General Purpose IO Register 2"]
pub mod gpior2 { # [doc = "Register `GPIOR2` reader"]
pub struct R (crate :: R < GPIOR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR2` writer"]
pub struct W (crate :: W < GPIOR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior2](index.html) module"]
pub struct GPIOR2_SPEC ; impl crate :: RegisterSpec for GPIOR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior2::R](R) reader structure"]
impl crate :: Readable for GPIOR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior2::W](W) writer structure"]
impl crate :: Writable for GPIOR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR2 to value 0"]
impl crate :: Resettable for GPIOR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR3 (rw) register accessor: an alias for `Reg<GPIOR3_SPEC>`"]
pub type GPIOR3 = crate :: Reg < gpior3 :: GPIOR3_SPEC > ; # [doc = "General Purpose IO Register 3"]
pub mod gpior3 { # [doc = "Register `GPIOR3` reader"]
pub struct R (crate :: R < GPIOR3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR3_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR3` writer"]
pub struct W (crate :: W < GPIOR3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior3](index.html) module"]
pub struct GPIOR3_SPEC ; impl crate :: RegisterSpec for GPIOR3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior3::R](R) reader structure"]
impl crate :: Readable for GPIOR3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior3::W](W) writer structure"]
impl crate :: Writable for GPIOR3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR3 to value 0"]
impl crate :: Resettable for GPIOR3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR4 (rw) register accessor: an alias for `Reg<GPIOR4_SPEC>`"]
pub type GPIOR4 = crate :: Reg < gpior4 :: GPIOR4_SPEC > ; # [doc = "General Purpose IO Register 4"]
pub mod gpior4 { # [doc = "Register `GPIOR4` reader"]
pub struct R (crate :: R < GPIOR4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR4_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR4` writer"]
pub struct W (crate :: W < GPIOR4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR4_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior4](index.html) module"]
pub struct GPIOR4_SPEC ; impl crate :: RegisterSpec for GPIOR4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior4::R](R) reader structure"]
impl crate :: Readable for GPIOR4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior4::W](W) writer structure"]
impl crate :: Writable for GPIOR4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR4 to value 0"]
impl crate :: Resettable for GPIOR4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR5 (rw) register accessor: an alias for `Reg<GPIOR5_SPEC>`"]
pub type GPIOR5 = crate :: Reg < gpior5 :: GPIOR5_SPEC > ; # [doc = "General Purpose IO Register 5"]
pub mod gpior5 { # [doc = "Register `GPIOR5` reader"]
pub struct R (crate :: R < GPIOR5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR5_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR5` writer"]
pub struct W (crate :: W < GPIOR5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR5_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior5](index.html) module"]
pub struct GPIOR5_SPEC ; impl crate :: RegisterSpec for GPIOR5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior5::R](R) reader structure"]
impl crate :: Readable for GPIOR5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior5::W](W) writer structure"]
impl crate :: Writable for GPIOR5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR5 to value 0"]
impl crate :: Resettable for GPIOR5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR6 (rw) register accessor: an alias for `Reg<GPIOR6_SPEC>`"]
pub type GPIOR6 = crate :: Reg < gpior6 :: GPIOR6_SPEC > ; # [doc = "General Purpose IO Register 6"]
pub mod gpior6 { # [doc = "Register `GPIOR6` reader"]
pub struct R (crate :: R < GPIOR6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR6_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR6` writer"]
pub struct W (crate :: W < GPIOR6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR6_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior6](index.html) module"]
pub struct GPIOR6_SPEC ; impl crate :: RegisterSpec for GPIOR6_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior6::R](R) reader structure"]
impl crate :: Readable for GPIOR6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior6::W](W) writer structure"]
impl crate :: Writable for GPIOR6_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR6 to value 0"]
impl crate :: Resettable for GPIOR6_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR7 (rw) register accessor: an alias for `Reg<GPIOR7_SPEC>`"]
pub type GPIOR7 = crate :: Reg < gpior7 :: GPIOR7_SPEC > ; # [doc = "General Purpose IO Register 7"]
pub mod gpior7 { # [doc = "Register `GPIOR7` reader"]
pub struct R (crate :: R < GPIOR7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR7_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR7` writer"]
pub struct W (crate :: W < GPIOR7_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR7_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR7_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 7\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior7](index.html) module"]
pub struct GPIOR7_SPEC ; impl crate :: RegisterSpec for GPIOR7_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior7::R](R) reader structure"]
impl crate :: Readable for GPIOR7_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior7::W](W) writer structure"]
impl crate :: Writable for GPIOR7_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR7 to value 0"]
impl crate :: Resettable for GPIOR7_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR8 (rw) register accessor: an alias for `Reg<GPIOR8_SPEC>`"]
pub type GPIOR8 = crate :: Reg < gpior8 :: GPIOR8_SPEC > ; # [doc = "General Purpose IO Register 8"]
pub mod gpior8 { # [doc = "Register `GPIOR8` reader"]
pub struct R (crate :: R < GPIOR8_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR8_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR8_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR8` writer"]
pub struct W (crate :: W < GPIOR8_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR8_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR8_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR8_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 8\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior8](index.html) module"]
pub struct GPIOR8_SPEC ; impl crate :: RegisterSpec for GPIOR8_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior8::R](R) reader structure"]
impl crate :: Readable for GPIOR8_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior8::W](W) writer structure"]
impl crate :: Writable for GPIOR8_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR8 to value 0"]
impl crate :: Resettable for GPIOR8_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIOR9 (rw) register accessor: an alias for `Reg<GPIOR9_SPEC>`"]
pub type GPIOR9 = crate :: Reg < gpior9 :: GPIOR9_SPEC > ; # [doc = "General Purpose IO Register 9"]
pub mod gpior9 { # [doc = "Register `GPIOR9` reader"]
pub struct R (crate :: R < GPIOR9_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIOR9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIOR9_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIOR9_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIOR9` writer"]
pub struct W (crate :: W < GPIOR9_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIOR9_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIOR9_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIOR9_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 9\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpior9](index.html) module"]
pub struct GPIOR9_SPEC ; impl crate :: RegisterSpec for GPIOR9_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpior9::R](R) reader structure"]
impl crate :: Readable for GPIOR9_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpior9::W](W) writer structure"]
impl crate :: Writable for GPIOR9_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIOR9 to value 0"]
impl crate :: Resettable for GPIOR9_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIORA (rw) register accessor: an alias for `Reg<GPIORA_SPEC>`"]
pub type GPIORA = crate :: Reg < gpiora :: GPIORA_SPEC > ; # [doc = "General Purpose IO Register 10"]
pub mod gpiora { # [doc = "Register `GPIORA` reader"]
pub struct R (crate :: R < GPIORA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIORA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIORA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIORA_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIORA` writer"]
pub struct W (crate :: W < GPIORA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIORA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIORA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIORA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 10\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpiora](index.html) module"]
pub struct GPIORA_SPEC ; impl crate :: RegisterSpec for GPIORA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpiora::R](R) reader structure"]
impl crate :: Readable for GPIORA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpiora::W](W) writer structure"]
impl crate :: Writable for GPIORA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIORA to value 0"]
impl crate :: Resettable for GPIORA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIORB (rw) register accessor: an alias for `Reg<GPIORB_SPEC>`"]
pub type GPIORB = crate :: Reg < gpiorb :: GPIORB_SPEC > ; # [doc = "General Purpose IO Register 11"]
pub mod gpiorb { # [doc = "Register `GPIORB` reader"]
pub struct R (crate :: R < GPIORB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIORB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIORB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIORB_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIORB` writer"]
pub struct W (crate :: W < GPIORB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIORB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIORB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIORB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 11\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpiorb](index.html) module"]
pub struct GPIORB_SPEC ; impl crate :: RegisterSpec for GPIORB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpiorb::R](R) reader structure"]
impl crate :: Readable for GPIORB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpiorb::W](W) writer structure"]
impl crate :: Writable for GPIORB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIORB to value 0"]
impl crate :: Resettable for GPIORB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIORC (rw) register accessor: an alias for `Reg<GPIORC_SPEC>`"]
pub type GPIORC = crate :: Reg < gpiorc :: GPIORC_SPEC > ; # [doc = "General Purpose IO Register 12"]
pub mod gpiorc { # [doc = "Register `GPIORC` reader"]
pub struct R (crate :: R < GPIORC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIORC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIORC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIORC_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIORC` writer"]
pub struct W (crate :: W < GPIORC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIORC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIORC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIORC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 12\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpiorc](index.html) module"]
pub struct GPIORC_SPEC ; impl crate :: RegisterSpec for GPIORC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpiorc::R](R) reader structure"]
impl crate :: Readable for GPIORC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpiorc::W](W) writer structure"]
impl crate :: Writable for GPIORC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIORC to value 0"]
impl crate :: Resettable for GPIORC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIORD (rw) register accessor: an alias for `Reg<GPIORD_SPEC>`"]
pub type GPIORD = crate :: Reg < gpiord :: GPIORD_SPEC > ; # [doc = "General Purpose IO Register 13"]
pub mod gpiord { # [doc = "Register `GPIORD` reader"]
pub struct R (crate :: R < GPIORD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIORD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIORD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIORD_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIORD` writer"]
pub struct W (crate :: W < GPIORD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIORD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIORD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIORD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 13\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpiord](index.html) module"]
pub struct GPIORD_SPEC ; impl crate :: RegisterSpec for GPIORD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpiord::R](R) reader structure"]
impl crate :: Readable for GPIORD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpiord::W](W) writer structure"]
impl crate :: Writable for GPIORD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIORD to value 0"]
impl crate :: Resettable for GPIORD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIORE (rw) register accessor: an alias for `Reg<GPIORE_SPEC>`"]
pub type GPIORE = crate :: Reg < gpiore :: GPIORE_SPEC > ; # [doc = "General Purpose IO Register 14"]
pub mod gpiore { # [doc = "Register `GPIORE` reader"]
pub struct R (crate :: R < GPIORE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIORE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIORE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIORE_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIORE` writer"]
pub struct W (crate :: W < GPIORE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIORE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIORE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIORE_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 14\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpiore](index.html) module"]
pub struct GPIORE_SPEC ; impl crate :: RegisterSpec for GPIORE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpiore::R](R) reader structure"]
impl crate :: Readable for GPIORE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpiore::W](W) writer structure"]
impl crate :: Writable for GPIORE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIORE to value 0"]
impl crate :: Resettable for GPIORE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "GPIORF (rw) register accessor: an alias for `Reg<GPIORF_SPEC>`"]
pub type GPIORF = crate :: Reg < gpiorf :: GPIORF_SPEC > ; # [doc = "General Purpose IO Register 15"]
pub mod gpiorf { # [doc = "Register `GPIORF` reader"]
pub struct R (crate :: R < GPIORF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GPIORF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GPIORF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GPIORF_SPEC >) -> Self { R (reader) } } # [doc = "Register `GPIORF` writer"]
pub struct W (crate :: W < GPIORF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GPIORF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GPIORF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GPIORF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "General Purpose IO Register 15\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gpiorf](index.html) module"]
pub struct GPIORF_SPEC ; impl crate :: RegisterSpec for GPIORF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [gpiorf::R](R) reader structure"]
impl crate :: Readable for GPIORF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gpiorf::W](W) writer structure"]
impl crate :: Writable for GPIORF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets GPIORF to value 0"]
impl crate :: Resettable for GPIORF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct HIRESC { _marker : PhantomData < * const () > } unsafe impl Send for HIRESC { } impl HIRESC { # [doc = r"Pointer to the register block"]
pub const PTR : * const hiresc :: RegisterBlock = 0x0890 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const hiresc :: RegisterBlock { Self :: PTR } } impl Deref for HIRESC { type Target = hiresc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for HIRESC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("HIRESC") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod hiresc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrla : CTRLA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `HREN` reader - High Resolution Enable"]
pub type HREN_R = crate :: FieldReader < u8 , HREN_A > ; # [doc = "High Resolution Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HREN_A { # [doc = "0: No Fault Protection"]
NONE = 0 , # [doc = "1: Enable High Resolution on Timer/Counter 0"]
TC0 = 1 , # [doc = "2: Enable High Resolution on Timer/Counter 1"]
TC1 = 2 , # [doc = "3: Enable High Resolution both Timer/Counters"]
BOTH = 3 , } impl From < HREN_A > for u8 { # [inline (always)]
fn from (variant : HREN_A) -> Self { variant as _ } } impl HREN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> HREN_A { match self . bits { 0 => HREN_A :: NONE , 1 => HREN_A :: TC0 , 2 => HREN_A :: TC1 , 3 => HREN_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == HREN_A :: NONE } # [doc = "Checks if the value of the field is `TC0`"]
# [inline (always)]
pub fn is_tc0 (& self) -> bool { * self == HREN_A :: TC0 } # [doc = "Checks if the value of the field is `TC1`"]
# [inline (always)]
pub fn is_tc1 (& self) -> bool { * self == HREN_A :: TC1 } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == HREN_A :: BOTH } } # [doc = "Field `HREN` writer - High Resolution Enable"]
pub type HREN_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , HREN_A , 2 , O > ; impl < 'a , const O : u8 > HREN_W < 'a , O > { # [doc = "No Fault Protection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (HREN_A :: NONE) } # [doc = "Enable High Resolution on Timer/Counter 0"]
# [inline (always)]
pub fn tc0 (self) -> & 'a mut W { self . variant (HREN_A :: TC0) } # [doc = "Enable High Resolution on Timer/Counter 1"]
# [inline (always)]
pub fn tc1 (self) -> & 'a mut W { self . variant (HREN_A :: TC1) } # [doc = "Enable High Resolution both Timer/Counters"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (HREN_A :: BOTH) } } impl R { # [doc = "Bits 0:1 - High Resolution Enable"]
# [inline (always)]
pub fn hren (& self) -> HREN_R { HREN_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - High Resolution Enable"]
# [inline (always)]
# [must_use]
pub fn hren (& mut self) -> HREN_W < 0 > { HREN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct HIRESD { _marker : PhantomData < * const () > } unsafe impl Send for HIRESD { } impl HIRESD { # [doc = r"Pointer to the register block"]
pub const PTR : * const hiresd :: RegisterBlock = 0x0990 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const hiresd :: RegisterBlock { Self :: PTR } } impl Deref for HIRESD { type Target = hiresd :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for HIRESD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("HIRESD") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod hiresd { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrla : CTRLA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `HREN` reader - High Resolution Enable"]
pub type HREN_R = crate :: FieldReader < u8 , HREN_A > ; # [doc = "High Resolution Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HREN_A { # [doc = "0: No Fault Protection"]
NONE = 0 , # [doc = "1: Enable High Resolution on Timer/Counter 0"]
TC0 = 1 , # [doc = "2: Enable High Resolution on Timer/Counter 1"]
TC1 = 2 , # [doc = "3: Enable High Resolution both Timer/Counters"]
BOTH = 3 , } impl From < HREN_A > for u8 { # [inline (always)]
fn from (variant : HREN_A) -> Self { variant as _ } } impl HREN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> HREN_A { match self . bits { 0 => HREN_A :: NONE , 1 => HREN_A :: TC0 , 2 => HREN_A :: TC1 , 3 => HREN_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == HREN_A :: NONE } # [doc = "Checks if the value of the field is `TC0`"]
# [inline (always)]
pub fn is_tc0 (& self) -> bool { * self == HREN_A :: TC0 } # [doc = "Checks if the value of the field is `TC1`"]
# [inline (always)]
pub fn is_tc1 (& self) -> bool { * self == HREN_A :: TC1 } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == HREN_A :: BOTH } } # [doc = "Field `HREN` writer - High Resolution Enable"]
pub type HREN_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , HREN_A , 2 , O > ; impl < 'a , const O : u8 > HREN_W < 'a , O > { # [doc = "No Fault Protection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (HREN_A :: NONE) } # [doc = "Enable High Resolution on Timer/Counter 0"]
# [inline (always)]
pub fn tc0 (self) -> & 'a mut W { self . variant (HREN_A :: TC0) } # [doc = "Enable High Resolution on Timer/Counter 1"]
# [inline (always)]
pub fn tc1 (self) -> & 'a mut W { self . variant (HREN_A :: TC1) } # [doc = "Enable High Resolution both Timer/Counters"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (HREN_A :: BOTH) } } impl R { # [doc = "Bits 0:1 - High Resolution Enable"]
# [inline (always)]
pub fn hren (& self) -> HREN_R { HREN_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - High Resolution Enable"]
# [inline (always)]
# [must_use]
pub fn hren (& mut self) -> HREN_W < 0 > { HREN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct HIRESE { _marker : PhantomData < * const () > } unsafe impl Send for HIRESE { } impl HIRESE { # [doc = r"Pointer to the register block"]
pub const PTR : * const hirese :: RegisterBlock = 0x0a90 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const hirese :: RegisterBlock { Self :: PTR } } impl Deref for HIRESE { type Target = hirese :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for HIRESE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("HIRESE") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod hirese { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrla : CTRLA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `HREN` reader - High Resolution Enable"]
pub type HREN_R = crate :: FieldReader < u8 , HREN_A > ; # [doc = "High Resolution Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HREN_A { # [doc = "0: No Fault Protection"]
NONE = 0 , # [doc = "1: Enable High Resolution on Timer/Counter 0"]
TC0 = 1 , # [doc = "2: Enable High Resolution on Timer/Counter 1"]
TC1 = 2 , # [doc = "3: Enable High Resolution both Timer/Counters"]
BOTH = 3 , } impl From < HREN_A > for u8 { # [inline (always)]
fn from (variant : HREN_A) -> Self { variant as _ } } impl HREN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> HREN_A { match self . bits { 0 => HREN_A :: NONE , 1 => HREN_A :: TC0 , 2 => HREN_A :: TC1 , 3 => HREN_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == HREN_A :: NONE } # [doc = "Checks if the value of the field is `TC0`"]
# [inline (always)]
pub fn is_tc0 (& self) -> bool { * self == HREN_A :: TC0 } # [doc = "Checks if the value of the field is `TC1`"]
# [inline (always)]
pub fn is_tc1 (& self) -> bool { * self == HREN_A :: TC1 } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == HREN_A :: BOTH } } # [doc = "Field `HREN` writer - High Resolution Enable"]
pub type HREN_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , HREN_A , 2 , O > ; impl < 'a , const O : u8 > HREN_W < 'a , O > { # [doc = "No Fault Protection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (HREN_A :: NONE) } # [doc = "Enable High Resolution on Timer/Counter 0"]
# [inline (always)]
pub fn tc0 (self) -> & 'a mut W { self . variant (HREN_A :: TC0) } # [doc = "Enable High Resolution on Timer/Counter 1"]
# [inline (always)]
pub fn tc1 (self) -> & 'a mut W { self . variant (HREN_A :: TC1) } # [doc = "Enable High Resolution both Timer/Counters"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (HREN_A :: BOTH) } } impl R { # [doc = "Bits 0:1 - High Resolution Enable"]
# [inline (always)]
pub fn hren (& self) -> HREN_R { HREN_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - High Resolution Enable"]
# [inline (always)]
# [must_use]
pub fn hren (& mut self) -> HREN_W < 0 > { HREN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct HIRESF { _marker : PhantomData < * const () > } unsafe impl Send for HIRESF { } impl HIRESF { # [doc = r"Pointer to the register block"]
pub const PTR : * const hiresf :: RegisterBlock = 0x0b90 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const hiresf :: RegisterBlock { Self :: PTR } } impl Deref for HIRESF { type Target = hiresf :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for HIRESF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("HIRESF") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod hiresf { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrla : CTRLA , } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `HREN` reader - High Resolution Enable"]
pub type HREN_R = crate :: FieldReader < u8 , HREN_A > ; # [doc = "High Resolution Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum HREN_A { # [doc = "0: No Fault Protection"]
NONE = 0 , # [doc = "1: Enable High Resolution on Timer/Counter 0"]
TC0 = 1 , # [doc = "2: Enable High Resolution on Timer/Counter 1"]
TC1 = 2 , # [doc = "3: Enable High Resolution both Timer/Counters"]
BOTH = 3 , } impl From < HREN_A > for u8 { # [inline (always)]
fn from (variant : HREN_A) -> Self { variant as _ } } impl HREN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> HREN_A { match self . bits { 0 => HREN_A :: NONE , 1 => HREN_A :: TC0 , 2 => HREN_A :: TC1 , 3 => HREN_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == HREN_A :: NONE } # [doc = "Checks if the value of the field is `TC0`"]
# [inline (always)]
pub fn is_tc0 (& self) -> bool { * self == HREN_A :: TC0 } # [doc = "Checks if the value of the field is `TC1`"]
# [inline (always)]
pub fn is_tc1 (& self) -> bool { * self == HREN_A :: TC1 } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == HREN_A :: BOTH } } # [doc = "Field `HREN` writer - High Resolution Enable"]
pub type HREN_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , HREN_A , 2 , O > ; impl < 'a , const O : u8 > HREN_W < 'a , O > { # [doc = "No Fault Protection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (HREN_A :: NONE) } # [doc = "Enable High Resolution on Timer/Counter 0"]
# [inline (always)]
pub fn tc0 (self) -> & 'a mut W { self . variant (HREN_A :: TC0) } # [doc = "Enable High Resolution on Timer/Counter 1"]
# [inline (always)]
pub fn tc1 (self) -> & 'a mut W { self . variant (HREN_A :: TC1) } # [doc = "Enable High Resolution both Timer/Counters"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (HREN_A :: BOTH) } } impl R { # [doc = "Bits 0:1 - High Resolution Enable"]
# [inline (always)]
pub fn hren (& self) -> HREN_R { HREN_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - High Resolution Enable"]
# [inline (always)]
# [must_use]
pub fn hren (& mut self) -> HREN_W < 0 > { HREN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "IR Communication Module"]
pub struct IRCOM { _marker : PhantomData < * const () > } unsafe impl Send for IRCOM { } impl IRCOM { # [doc = r"Pointer to the register block"]
pub const PTR : * const ircom :: RegisterBlock = 0x08f8 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ircom :: RegisterBlock { Self :: PTR } } impl Deref for IRCOM { type Target = ircom :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for IRCOM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("IRCOM") . finish () } } # [doc = "IR Communication Module"]
pub mod ircom { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - IrDA Transmitter Pulse Length Control Register"]
pub txplctrl : TXPLCTRL , # [doc = "0x02 - IrDA Receiver Pulse Length Control Register"]
pub rxplctrl : RXPLCTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Channel Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Channel Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
_0 = 8 , # [doc = "9: Event Channel 1"]
_1 = 9 , # [doc = "10: Event Channel 2"]
_2 = 10 , # [doc = "11: Event Channel 3"]
_3 = 11 , # [doc = "12: Event Channel 4"]
_4 = 12 , # [doc = "13: Event Channel 5"]
_5 = 13 , # [doc = "14: Event Channel 6"]
_6 = 14 , # [doc = "15: Event Channel 7"]
_7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: _0) , 9 => Some (EVSEL_A :: _1) , 10 => Some (EVSEL_A :: _2) , 11 => Some (EVSEL_A :: _3) , 12 => Some (EVSEL_A :: _4) , 13 => Some (EVSEL_A :: _5) , 14 => Some (EVSEL_A :: _6) , 15 => Some (EVSEL_A :: _7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == EVSEL_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == EVSEL_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == EVSEL_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == EVSEL_A :: _3 } # [doc = "Checks if the value of the field is `_4`"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == EVSEL_A :: _4 } # [doc = "Checks if the value of the field is `_5`"]
# [inline (always)]
pub fn is_5 (& self) -> bool { * self == EVSEL_A :: _5 } # [doc = "Checks if the value of the field is `_6`"]
# [inline (always)]
pub fn is_6 (& self) -> bool { * self == EVSEL_A :: _6 } # [doc = "Checks if the value of the field is `_7`"]
# [inline (always)]
pub fn is_7 (& self) -> bool { * self == EVSEL_A :: _7 } } # [doc = "Field `EVSEL` writer - Event Channel Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRL_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (EVSEL_A :: _0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (EVSEL_A :: _1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (EVSEL_A :: _2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (EVSEL_A :: _3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut W { self . variant (EVSEL_A :: _4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn _5 (self) -> & 'a mut W { self . variant (EVSEL_A :: _5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn _6 (self) -> & 'a mut W { self . variant (EVSEL_A :: _6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn _7 (self) -> & 'a mut W { self . variant (EVSEL_A :: _7) } } impl R { # [doc = "Bits 0:3 - Event Channel Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Event Channel Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RXPLCTRL (rw) register accessor: an alias for `Reg<RXPLCTRL_SPEC>`"]
pub type RXPLCTRL = crate :: Reg < rxplctrl :: RXPLCTRL_SPEC > ; # [doc = "IrDA Receiver Pulse Length Control Register"]
pub mod rxplctrl { # [doc = "Register `RXPLCTRL` reader"]
pub struct R (crate :: R < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXPLCTRL` writer"]
pub struct W (crate :: W < RXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXPLCTRL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "IrDA Receiver Pulse Length Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxplctrl](index.html) module"]
pub struct RXPLCTRL_SPEC ; impl crate :: RegisterSpec for RXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxplctrl::R](R) reader structure"]
impl crate :: Readable for RXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxplctrl::W](W) writer structure"]
impl crate :: Writable for RXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RXPLCTRL to value 0"]
impl crate :: Resettable for RXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TXPLCTRL (rw) register accessor: an alias for `Reg<TXPLCTRL_SPEC>`"]
pub type TXPLCTRL = crate :: Reg < txplctrl :: TXPLCTRL_SPEC > ; # [doc = "IrDA Transmitter Pulse Length Control Register"]
pub mod txplctrl { # [doc = "Register `TXPLCTRL` reader"]
pub struct R (crate :: R < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TXPLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TXPLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `TXPLCTRL` writer"]
pub struct W (crate :: W < TXPLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TXPLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TXPLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TXPLCTRL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "IrDA Transmitter Pulse Length Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txplctrl](index.html) module"]
pub struct TXPLCTRL_SPEC ; impl crate :: RegisterSpec for TXPLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [txplctrl::R](R) reader structure"]
impl crate :: Readable for TXPLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [txplctrl::W](W) writer structure"]
impl crate :: Writable for TXPLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TXPLCTRL to value 0"]
impl crate :: Resettable for TXPLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Non Volatile Memory Controller"]
pub struct LOCKBIT { _marker : PhantomData < * const () > } unsafe impl Send for LOCKBIT { } impl LOCKBIT { # [doc = r"Pointer to the register block"]
pub const PTR : * const lockbit :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const lockbit :: RegisterBlock { Self :: PTR } } impl Deref for LOCKBIT { type Target = lockbit :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for LOCKBIT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("LOCKBIT") . finish () } } # [doc = "Non Volatile Memory Controller"]
pub mod lockbit { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Lock Bits"]
pub lockbits : LOCKBITS , } # [doc = "LOCKBITS (rw) register accessor: an alias for `Reg<LOCKBITS_SPEC>`"]
pub type LOCKBITS = crate :: Reg < lockbits :: LOCKBITS_SPEC > ; # [doc = "Lock Bits"]
pub mod lockbits { # [doc = "Register `LOCKBITS` reader"]
pub struct R (crate :: R < LOCKBITS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKBITS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKBITS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKBITS_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCKBITS` writer"]
pub struct W (crate :: W < LOCKBITS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCKBITS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCKBITS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCKBITS_SPEC >) -> Self { W (writer) } } # [doc = "Field `LB` reader - Lock Bits"]
pub type LB_R = crate :: FieldReader < u8 , LB_A > ; # [doc = "Lock Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LB_A { # [doc = "0: Read and write not allowed"]
RWLOCK = 0 , # [doc = "2: Write not allowed"]
WLOCK = 2 , # [doc = "3: No locks"]
NOLOCK = 3 , } impl From < LB_A > for u8 { # [inline (always)]
fn from (variant : LB_A) -> Self { variant as _ } } impl LB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LB_A > { match self . bits { 0 => Some (LB_A :: RWLOCK) , 2 => Some (LB_A :: WLOCK) , 3 => Some (LB_A :: NOLOCK) , _ => None , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == LB_A :: RWLOCK } # [doc = "Checks if the value of the field is `WLOCK`"]
# [inline (always)]
pub fn is_wlock (& self) -> bool { * self == LB_A :: WLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == LB_A :: NOLOCK } } # [doc = "Field `LB` writer - Lock Bits"]
pub type LB_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LOCKBITS_SPEC , u8 , LB_A , 2 , O > ; impl < 'a , const O : u8 > LB_W < 'a , O > { # [doc = "Read and write not allowed"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (LB_A :: RWLOCK) } # [doc = "Write not allowed"]
# [inline (always)]
pub fn wlock (self) -> & 'a mut W { self . variant (LB_A :: WLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (LB_A :: NOLOCK) } } # [doc = "Field `BLBAT` reader - Boot Lock Bits - Application Table"]
pub type BLBAT_R = crate :: FieldReader < u8 , BLBAT_A > ; # [doc = "Boot Lock Bits - Application Table\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLBAT_A { # [doc = "0: Read and write not allowed"]
RWLOCK = 0 , # [doc = "1: Read not allowed"]
RLOCK = 1 , # [doc = "2: Write not allowed"]
WLOCK = 2 , # [doc = "3: No locks"]
NOLOCK = 3 , } impl From < BLBAT_A > for u8 { # [inline (always)]
fn from (variant : BLBAT_A) -> Self { variant as _ } } impl BLBAT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLBAT_A { match self . bits { 0 => BLBAT_A :: RWLOCK , 1 => BLBAT_A :: RLOCK , 2 => BLBAT_A :: WLOCK , 3 => BLBAT_A :: NOLOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == BLBAT_A :: RWLOCK } # [doc = "Checks if the value of the field is `RLOCK`"]
# [inline (always)]
pub fn is_rlock (& self) -> bool { * self == BLBAT_A :: RLOCK } # [doc = "Checks if the value of the field is `WLOCK`"]
# [inline (always)]
pub fn is_wlock (& self) -> bool { * self == BLBAT_A :: WLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == BLBAT_A :: NOLOCK } } # [doc = "Field `BLBAT` writer - Boot Lock Bits - Application Table"]
pub type BLBAT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBITS_SPEC , u8 , BLBAT_A , 2 , O > ; impl < 'a , const O : u8 > BLBAT_W < 'a , O > { # [doc = "Read and write not allowed"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (BLBAT_A :: RWLOCK) } # [doc = "Read not allowed"]
# [inline (always)]
pub fn rlock (self) -> & 'a mut W { self . variant (BLBAT_A :: RLOCK) } # [doc = "Write not allowed"]
# [inline (always)]
pub fn wlock (self) -> & 'a mut W { self . variant (BLBAT_A :: WLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (BLBAT_A :: NOLOCK) } } # [doc = "Field `BLBA` reader - Boot Lock Bits - Application Section"]
pub type BLBA_R = crate :: FieldReader < u8 , BLBA_A > ; # [doc = "Boot Lock Bits - Application Section\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLBA_A { # [doc = "0: Read and write not allowed"]
RWLOCK = 0 , # [doc = "1: Read not allowed"]
RLOCK = 1 , # [doc = "2: Write not allowed"]
WLOCK = 2 , # [doc = "3: No locks"]
NOLOCK = 3 , } impl From < BLBA_A > for u8 { # [inline (always)]
fn from (variant : BLBA_A) -> Self { variant as _ } } impl BLBA_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLBA_A { match self . bits { 0 => BLBA_A :: RWLOCK , 1 => BLBA_A :: RLOCK , 2 => BLBA_A :: WLOCK , 3 => BLBA_A :: NOLOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == BLBA_A :: RWLOCK } # [doc = "Checks if the value of the field is `RLOCK`"]
# [inline (always)]
pub fn is_rlock (& self) -> bool { * self == BLBA_A :: RLOCK } # [doc = "Checks if the value of the field is `WLOCK`"]
# [inline (always)]
pub fn is_wlock (& self) -> bool { * self == BLBA_A :: WLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == BLBA_A :: NOLOCK } } # [doc = "Field `BLBA` writer - Boot Lock Bits - Application Section"]
pub type BLBA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBITS_SPEC , u8 , BLBA_A , 2 , O > ; impl < 'a , const O : u8 > BLBA_W < 'a , O > { # [doc = "Read and write not allowed"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (BLBA_A :: RWLOCK) } # [doc = "Read not allowed"]
# [inline (always)]
pub fn rlock (self) -> & 'a mut W { self . variant (BLBA_A :: RLOCK) } # [doc = "Write not allowed"]
# [inline (always)]
pub fn wlock (self) -> & 'a mut W { self . variant (BLBA_A :: WLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (BLBA_A :: NOLOCK) } } # [doc = "Field `BLBB` reader - Boot Lock Bits - Boot Section"]
pub type BLBB_R = crate :: FieldReader < u8 , BLBB_A > ; # [doc = "Boot Lock Bits - Boot Section\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLBB_A { # [doc = "0: Read and write not allowed"]
RWLOCK = 0 , # [doc = "1: Read not allowed"]
RLOCK = 1 , # [doc = "2: Write not allowed"]
WLOCK = 2 , # [doc = "3: No locks"]
NOLOCK = 3 , } impl From < BLBB_A > for u8 { # [inline (always)]
fn from (variant : BLBB_A) -> Self { variant as _ } } impl BLBB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLBB_A { match self . bits { 0 => BLBB_A :: RWLOCK , 1 => BLBB_A :: RLOCK , 2 => BLBB_A :: WLOCK , 3 => BLBB_A :: NOLOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == BLBB_A :: RWLOCK } # [doc = "Checks if the value of the field is `RLOCK`"]
# [inline (always)]
pub fn is_rlock (& self) -> bool { * self == BLBB_A :: RLOCK } # [doc = "Checks if the value of the field is `WLOCK`"]
# [inline (always)]
pub fn is_wlock (& self) -> bool { * self == BLBB_A :: WLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == BLBB_A :: NOLOCK } } # [doc = "Field `BLBB` writer - Boot Lock Bits - Boot Section"]
pub type BLBB_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBITS_SPEC , u8 , BLBB_A , 2 , O > ; impl < 'a , const O : u8 > BLBB_W < 'a , O > { # [doc = "Read and write not allowed"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (BLBB_A :: RWLOCK) } # [doc = "Read not allowed"]
# [inline (always)]
pub fn rlock (self) -> & 'a mut W { self . variant (BLBB_A :: RLOCK) } # [doc = "Write not allowed"]
# [inline (always)]
pub fn wlock (self) -> & 'a mut W { self . variant (BLBB_A :: WLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (BLBB_A :: NOLOCK) } } impl R { # [doc = "Bits 0:1 - Lock Bits"]
# [inline (always)]
pub fn lb (& self) -> LB_R { LB_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Boot Lock Bits - Application Table"]
# [inline (always)]
pub fn blbat (& self) -> BLBAT_R { BLBAT_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Boot Lock Bits - Application Section"]
# [inline (always)]
pub fn blba (& self) -> BLBA_R { BLBA_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Boot Lock Bits - Boot Section"]
# [inline (always)]
pub fn blbb (& self) -> BLBB_R { BLBB_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Lock Bits"]
# [inline (always)]
# [must_use]
pub fn lb (& mut self) -> LB_W < 0 > { LB_W :: new (self) } # [doc = "Bits 2:3 - Boot Lock Bits - Application Table"]
# [inline (always)]
# [must_use]
pub fn blbat (& mut self) -> BLBAT_W < 2 > { BLBAT_W :: new (self) } # [doc = "Bits 4:5 - Boot Lock Bits - Application Section"]
# [inline (always)]
# [must_use]
pub fn blba (& mut self) -> BLBA_W < 4 > { BLBA_W :: new (self) } # [doc = "Bits 6:7 - Boot Lock Bits - Boot Section"]
# [inline (always)]
# [must_use]
pub fn blbb (& mut self) -> BLBB_W < 6 > { BLBB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Lock Bits\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockbits](index.html) module"]
pub struct LOCKBITS_SPEC ; impl crate :: RegisterSpec for LOCKBITS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lockbits::R](R) reader structure"]
impl crate :: Readable for LOCKBITS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lockbits::W](W) writer structure"]
impl crate :: Writable for LOCKBITS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOCKBITS to value 0"]
impl crate :: Resettable for LOCKBITS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "MCU Control"]
pub struct MCU { _marker : PhantomData < * const () > } unsafe impl Send for MCU { } impl MCU { # [doc = r"Pointer to the register block"]
pub const PTR : * const mcu :: RegisterBlock = 0x90 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const mcu :: RegisterBlock { Self :: PTR } } impl Deref for MCU { type Target = mcu :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for MCU { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("MCU") . finish () } } # [doc = "MCU Control"]
pub mod mcu { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Device ID byte 0"]
pub devid0 : DEVID0 , # [doc = "0x01 - Device ID byte 1"]
pub devid1 : DEVID1 , # [doc = "0x02 - Device ID byte 2"]
pub devid2 : DEVID2 , # [doc = "0x03 - Revision ID"]
pub revid : REVID , # [doc = "0x04 - JTAG User ID"]
pub jtaguid : JTAGUID , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - MCU Control"]
pub mcucr : MCUCR , _reserved6 : [u8 ; 0x01]
, # [doc = "0x08 - Event System Lock"]
pub evsyslock : EVSYSLOCK , # [doc = "0x09 - AWEX Lock"]
pub awexlock : AWEXLOCK , } # [doc = "AWEXLOCK (rw) register accessor: an alias for `Reg<AWEXLOCK_SPEC>`"]
pub type AWEXLOCK = crate :: Reg < awexlock :: AWEXLOCK_SPEC > ; # [doc = "AWEX Lock"]
pub mod awexlock { # [doc = "Register `AWEXLOCK` reader"]
pub struct R (crate :: R < AWEXLOCK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AWEXLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AWEXLOCK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AWEXLOCK_SPEC >) -> Self { R (reader) } } # [doc = "Register `AWEXLOCK` writer"]
pub struct W (crate :: W < AWEXLOCK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AWEXLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AWEXLOCK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AWEXLOCK_SPEC >) -> Self { W (writer) } } # [doc = "Field `AWEXCLOCK` reader - AWeX on T/C C0 Lock"]
pub type AWEXCLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `AWEXCLOCK` writer - AWeX on T/C C0 Lock"]
pub type AWEXCLOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AWEXLOCK_SPEC , bool , O > ; # [doc = "Field `AWEXELOCK` reader - AWeX on T/C E0 Lock"]
pub type AWEXELOCK_R = crate :: BitReader < bool > ; # [doc = "Field `AWEXELOCK` writer - AWeX on T/C E0 Lock"]
pub type AWEXELOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , AWEXLOCK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - AWeX on T/C C0 Lock"]
# [inline (always)]
pub fn awexclock (& self) -> AWEXCLOCK_R { AWEXCLOCK_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - AWeX on T/C E0 Lock"]
# [inline (always)]
pub fn awexelock (& self) -> AWEXELOCK_R { AWEXELOCK_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - AWeX on T/C C0 Lock"]
# [inline (always)]
# [must_use]
pub fn awexclock (& mut self) -> AWEXCLOCK_W < 0 > { AWEXCLOCK_W :: new (self) } # [doc = "Bit 2 - AWeX on T/C E0 Lock"]
# [inline (always)]
# [must_use]
pub fn awexelock (& mut self) -> AWEXELOCK_W < 2 > { AWEXELOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "AWEX Lock\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [awexlock](index.html) module"]
pub struct AWEXLOCK_SPEC ; impl crate :: RegisterSpec for AWEXLOCK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [awexlock::R](R) reader structure"]
impl crate :: Readable for AWEXLOCK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [awexlock::W](W) writer structure"]
impl crate :: Writable for AWEXLOCK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets AWEXLOCK to value 0"]
impl crate :: Resettable for AWEXLOCK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DEVID0 (rw) register accessor: an alias for `Reg<DEVID0_SPEC>`"]
pub type DEVID0 = crate :: Reg < devid0 :: DEVID0_SPEC > ; # [doc = "Device ID byte 0"]
pub mod devid0 { # [doc = "Register `DEVID0` reader"]
pub struct R (crate :: R < DEVID0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVID0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVID0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVID0_SPEC >) -> Self { R (reader) } } # [doc = "Register `DEVID0` writer"]
pub struct W (crate :: W < DEVID0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DEVID0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DEVID0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DEVID0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Device ID byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [devid0](index.html) module"]
pub struct DEVID0_SPEC ; impl crate :: RegisterSpec for DEVID0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [devid0::R](R) reader structure"]
impl crate :: Readable for DEVID0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [devid0::W](W) writer structure"]
impl crate :: Writable for DEVID0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DEVID0 to value 0"]
impl crate :: Resettable for DEVID0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DEVID1 (rw) register accessor: an alias for `Reg<DEVID1_SPEC>`"]
pub type DEVID1 = crate :: Reg < devid1 :: DEVID1_SPEC > ; # [doc = "Device ID byte 1"]
pub mod devid1 { # [doc = "Register `DEVID1` reader"]
pub struct R (crate :: R < DEVID1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVID1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVID1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVID1_SPEC >) -> Self { R (reader) } } # [doc = "Register `DEVID1` writer"]
pub struct W (crate :: W < DEVID1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DEVID1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DEVID1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DEVID1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Device ID byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [devid1](index.html) module"]
pub struct DEVID1_SPEC ; impl crate :: RegisterSpec for DEVID1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [devid1::R](R) reader structure"]
impl crate :: Readable for DEVID1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [devid1::W](W) writer structure"]
impl crate :: Writable for DEVID1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DEVID1 to value 0"]
impl crate :: Resettable for DEVID1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DEVID2 (rw) register accessor: an alias for `Reg<DEVID2_SPEC>`"]
pub type DEVID2 = crate :: Reg < devid2 :: DEVID2_SPEC > ; # [doc = "Device ID byte 2"]
pub mod devid2 { # [doc = "Register `DEVID2` reader"]
pub struct R (crate :: R < DEVID2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVID2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVID2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVID2_SPEC >) -> Self { R (reader) } } # [doc = "Register `DEVID2` writer"]
pub struct W (crate :: W < DEVID2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DEVID2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DEVID2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DEVID2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Device ID byte 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [devid2](index.html) module"]
pub struct DEVID2_SPEC ; impl crate :: RegisterSpec for DEVID2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [devid2::R](R) reader structure"]
impl crate :: Readable for DEVID2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [devid2::W](W) writer structure"]
impl crate :: Writable for DEVID2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DEVID2 to value 0"]
impl crate :: Resettable for DEVID2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "EVSYSLOCK (rw) register accessor: an alias for `Reg<EVSYSLOCK_SPEC>`"]
pub type EVSYSLOCK = crate :: Reg < evsyslock :: EVSYSLOCK_SPEC > ; # [doc = "Event System Lock"]
pub mod evsyslock { # [doc = "Register `EVSYSLOCK` reader"]
pub struct R (crate :: R < EVSYSLOCK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVSYSLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVSYSLOCK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVSYSLOCK_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVSYSLOCK` writer"]
pub struct W (crate :: W < EVSYSLOCK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVSYSLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVSYSLOCK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVSYSLOCK_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSYS0LOCK` reader - Event Channel 0-3 Lock"]
pub type EVSYS0LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `EVSYS0LOCK` writer - Event Channel 0-3 Lock"]
pub type EVSYS0LOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVSYSLOCK_SPEC , bool , O > ; # [doc = "Field `EVSYS1LOCK` reader - Event Channel 4-7 Lock"]
pub type EVSYS1LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `EVSYS1LOCK` writer - Event Channel 4-7 Lock"]
pub type EVSYS1LOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , EVSYSLOCK_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Event Channel 0-3 Lock"]
# [inline (always)]
pub fn evsys0lock (& self) -> EVSYS0LOCK_R { EVSYS0LOCK_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Event Channel 4-7 Lock"]
# [inline (always)]
pub fn evsys1lock (& self) -> EVSYS1LOCK_R { EVSYS1LOCK_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Event Channel 0-3 Lock"]
# [inline (always)]
# [must_use]
pub fn evsys0lock (& mut self) -> EVSYS0LOCK_W < 0 > { EVSYS0LOCK_W :: new (self) } # [doc = "Bit 4 - Event Channel 4-7 Lock"]
# [inline (always)]
# [must_use]
pub fn evsys1lock (& mut self) -> EVSYS1LOCK_W < 4 > { EVSYS1LOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event System Lock\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evsyslock](index.html) module"]
pub struct EVSYSLOCK_SPEC ; impl crate :: RegisterSpec for EVSYSLOCK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evsyslock::R](R) reader structure"]
impl crate :: Readable for EVSYSLOCK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evsyslock::W](W) writer structure"]
impl crate :: Writable for EVSYSLOCK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets EVSYSLOCK to value 0"]
impl crate :: Resettable for EVSYSLOCK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "JTAGUID (rw) register accessor: an alias for `Reg<JTAGUID_SPEC>`"]
pub type JTAGUID = crate :: Reg < jtaguid :: JTAGUID_SPEC > ; # [doc = "JTAG User ID"]
pub mod jtaguid { # [doc = "Register `JTAGUID` reader"]
pub struct R (crate :: R < JTAGUID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < JTAGUID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < JTAGUID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < JTAGUID_SPEC >) -> Self { R (reader) } } # [doc = "Register `JTAGUID` writer"]
pub struct W (crate :: W < JTAGUID_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < JTAGUID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < JTAGUID_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < JTAGUID_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "JTAG User ID\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [jtaguid](index.html) module"]
pub struct JTAGUID_SPEC ; impl crate :: RegisterSpec for JTAGUID_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [jtaguid::R](R) reader structure"]
impl crate :: Readable for JTAGUID_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [jtaguid::W](W) writer structure"]
impl crate :: Writable for JTAGUID_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets JTAGUID to value 0"]
impl crate :: Resettable for JTAGUID_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MCUCR (rw) register accessor: an alias for `Reg<MCUCR_SPEC>`"]
pub type MCUCR = crate :: Reg < mcucr :: MCUCR_SPEC > ; # [doc = "MCU Control"]
pub mod mcucr { # [doc = "Register `MCUCR` reader"]
pub struct R (crate :: R < MCUCR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MCUCR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MCUCR_SPEC >) -> Self { R (reader) } } # [doc = "Register `MCUCR` writer"]
pub struct W (crate :: W < MCUCR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MCUCR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MCUCR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MCUCR_SPEC >) -> Self { W (writer) } } # [doc = "Field `JTAGD` reader - JTAG Disable"]
pub type JTAGD_R = crate :: BitReader < bool > ; # [doc = "Field `JTAGD` writer - JTAG Disable"]
pub type JTAGD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , MCUCR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - JTAG Disable"]
# [inline (always)]
pub fn jtagd (& self) -> JTAGD_R { JTAGD_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - JTAG Disable"]
# [inline (always)]
# [must_use]
pub fn jtagd (& mut self) -> JTAGD_W < 0 > { JTAGD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MCU Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcucr](index.html) module"]
pub struct MCUCR_SPEC ; impl crate :: RegisterSpec for MCUCR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mcucr::R](R) reader structure"]
impl crate :: Readable for MCUCR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mcucr::W](W) writer structure"]
impl crate :: Writable for MCUCR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MCUCR to value 0"]
impl crate :: Resettable for MCUCR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "REVID (rw) register accessor: an alias for `Reg<REVID_SPEC>`"]
pub type REVID = crate :: Reg < revid :: REVID_SPEC > ; # [doc = "Revision ID"]
pub mod revid { # [doc = "Register `REVID` reader"]
pub struct R (crate :: R < REVID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < REVID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < REVID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < REVID_SPEC >) -> Self { R (reader) } } # [doc = "Register `REVID` writer"]
pub struct W (crate :: W < REVID_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < REVID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < REVID_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < REVID_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Revision ID\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [revid](index.html) module"]
pub struct REVID_SPEC ; impl crate :: RegisterSpec for REVID_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [revid::R](R) reader structure"]
impl crate :: Readable for REVID_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [revid::W](W) writer structure"]
impl crate :: Writable for REVID_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets REVID to value 0"]
impl crate :: Resettable for REVID_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Non Volatile Memory Controller"]
pub struct NVM { _marker : PhantomData < * const () > } unsafe impl Send for NVM { } impl NVM { # [doc = r"Pointer to the register block"]
pub const PTR : * const nvm :: RegisterBlock = 0x01c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const nvm :: RegisterBlock { Self :: PTR } } impl Deref for NVM { type Target = nvm :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for NVM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("NVM") . finish () } } # [doc = "Non Volatile Memory Controller"]
pub mod nvm { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Address Register 0"]
pub addr0 : ADDR0 , # [doc = "0x01 - Address Register 1"]
pub addr1 : ADDR1 , # [doc = "0x02 - Address Register 2"]
pub addr2 : ADDR2 , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - Data Register 0"]
pub data0 : DATA0 , # [doc = "0x05 - Data Register 1"]
pub data1 : DATA1 , # [doc = "0x06 - Data Register 2"]
pub data2 : DATA2 , _reserved6 : [u8 ; 0x03]
, # [doc = "0x0a - Command"]
pub cmd : CMD , # [doc = "0x0b - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x0c - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x0d - Interrupt Control"]
pub intctrl : INTCTRL , _reserved10 : [u8 ; 0x01]
, # [doc = "0x0f - Status"]
pub status : STATUS , # [doc = "0x10 - Lock Bits"]
pub lockbits : LOCKBITS , } # [doc = "ADDR0 (rw) register accessor: an alias for `Reg<ADDR0_SPEC>`"]
pub type ADDR0 = crate :: Reg < addr0 :: ADDR0_SPEC > ; # [doc = "Address Register 0"]
pub mod addr0 { # [doc = "Register `ADDR0` reader"]
pub struct R (crate :: R < ADDR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR0` writer"]
pub struct W (crate :: W < ADDR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Address Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr0](index.html) module"]
pub struct ADDR0_SPEC ; impl crate :: RegisterSpec for ADDR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [addr0::R](R) reader structure"]
impl crate :: Readable for ADDR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr0::W](W) writer structure"]
impl crate :: Writable for ADDR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADDR0 to value 0"]
impl crate :: Resettable for ADDR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADDR1 (rw) register accessor: an alias for `Reg<ADDR1_SPEC>`"]
pub type ADDR1 = crate :: Reg < addr1 :: ADDR1_SPEC > ; # [doc = "Address Register 1"]
pub mod addr1 { # [doc = "Register `ADDR1` reader"]
pub struct R (crate :: R < ADDR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR1` writer"]
pub struct W (crate :: W < ADDR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Address Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr1](index.html) module"]
pub struct ADDR1_SPEC ; impl crate :: RegisterSpec for ADDR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [addr1::R](R) reader structure"]
impl crate :: Readable for ADDR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr1::W](W) writer structure"]
impl crate :: Writable for ADDR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADDR1 to value 0"]
impl crate :: Resettable for ADDR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADDR2 (rw) register accessor: an alias for `Reg<ADDR2_SPEC>`"]
pub type ADDR2 = crate :: Reg < addr2 :: ADDR2_SPEC > ; # [doc = "Address Register 2"]
pub mod addr2 { # [doc = "Register `ADDR2` reader"]
pub struct R (crate :: R < ADDR2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR2_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR2` writer"]
pub struct W (crate :: W < ADDR2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Address Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr2](index.html) module"]
pub struct ADDR2_SPEC ; impl crate :: RegisterSpec for ADDR2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [addr2::R](R) reader structure"]
impl crate :: Readable for ADDR2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr2::W](W) writer structure"]
impl crate :: Writable for ADDR2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADDR2 to value 0"]
impl crate :: Resettable for ADDR2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CMD (rw) register accessor: an alias for `Reg<CMD_SPEC>`"]
pub type CMD = crate :: Reg < cmd :: CMD_SPEC > ; # [doc = "Command"]
pub mod cmd { # [doc = "Register `CMD` reader"]
pub struct R (crate :: R < CMD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CMD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CMD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CMD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CMD` writer"]
pub struct W (crate :: W < CMD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CMD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CMD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CMD_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: Noop/Ordinary LPM"]
NO_OPERATION = 0 , # [doc = "1: Read user signature row"]
READ_USER_SIG_ROW = 1 , # [doc = "2: Read calibration row"]
READ_CALIB_ROW = 2 , # [doc = "6: Read EEPROM"]
READ_EEPROM = 6 , # [doc = "7: Read fuse byte"]
READ_FUSES = 7 , # [doc = "8: Write lock bits"]
WRITE_LOCK_BITS = 8 , # [doc = "24: Erase user signature row"]
ERASE_USER_SIG_ROW = 24 , # [doc = "26: Write user signature row"]
WRITE_USER_SIG_ROW = 26 , # [doc = "32: Erase Application Section"]
ERASE_APP = 32 , # [doc = "34: Erase Application Section page"]
ERASE_APP_PAGE = 34 , # [doc = "35: Load Flash page buffer"]
LOAD_FLASH_BUFFER = 35 , # [doc = "36: Write Application Section page"]
WRITE_APP_PAGE = 36 , # [doc = "37: Erase-and-write Application Section page"]
ERASE_WRITE_APP_PAGE = 37 , # [doc = "38: Erase/flush Flash page buffer"]
ERASE_FLASH_BUFFER = 38 , # [doc = "42: Erase Boot Section page"]
ERASE_BOOT_PAGE = 42 , # [doc = "43: Erase Flash Page"]
ERASE_FLASH_PAGE = 43 , # [doc = "44: Write Boot Section page"]
WRITE_BOOT_PAGE = 44 , # [doc = "45: Erase-and-write Boot Section page"]
ERASE_WRITE_BOOT_PAGE = 45 , # [doc = "46: Write Flash Page"]
WRITE_FLASH_PAGE = 46 , # [doc = "47: Erase-and-write Flash Page"]
ERASE_WRITE_FLASH_PAGE = 47 , # [doc = "48: Erase EEPROM"]
ERASE_EEPROM = 48 , # [doc = "50: Erase EEPROM page"]
ERASE_EEPROM_PAGE = 50 , # [doc = "51: Load EEPROM page buffer"]
LOAD_EEPROM_BUFFER = 51 , # [doc = "52: Write EEPROM page"]
WRITE_EEPROM_PAGE = 52 , # [doc = "53: Erase-and-write EEPROM page"]
ERASE_WRITE_EEPROM_PAGE = 53 , # [doc = "54: Erase/flush EEPROM page buffer"]
ERASE_EEPROM_BUFFER = 54 , # [doc = "56: Application section CRC"]
APP_CRC = 56 , # [doc = "57: Boot Section CRC"]
BOOT_CRC = 57 , # [doc = "58: Flash Range CRC"]
FLASH_RANGE_CRC = 58 , # [doc = "64: Erase Chip"]
CHIP_ERASE = 64 , # [doc = "67: Read NVM"]
READ_NVM = 67 , # [doc = "76: Write Fuse byte"]
WRITE_FUSE = 76 , # [doc = "104: Erase Boot Section"]
ERASE_BOOT = 104 , # [doc = "120: Flash CRC"]
FLASH_CRC = 120 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NO_OPERATION) , 1 => Some (CMD_A :: READ_USER_SIG_ROW) , 2 => Some (CMD_A :: READ_CALIB_ROW) , 6 => Some (CMD_A :: READ_EEPROM) , 7 => Some (CMD_A :: READ_FUSES) , 8 => Some (CMD_A :: WRITE_LOCK_BITS) , 24 => Some (CMD_A :: ERASE_USER_SIG_ROW) , 26 => Some (CMD_A :: WRITE_USER_SIG_ROW) , 32 => Some (CMD_A :: ERASE_APP) , 34 => Some (CMD_A :: ERASE_APP_PAGE) , 35 => Some (CMD_A :: LOAD_FLASH_BUFFER) , 36 => Some (CMD_A :: WRITE_APP_PAGE) , 37 => Some (CMD_A :: ERASE_WRITE_APP_PAGE) , 38 => Some (CMD_A :: ERASE_FLASH_BUFFER) , 42 => Some (CMD_A :: ERASE_BOOT_PAGE) , 43 => Some (CMD_A :: ERASE_FLASH_PAGE) , 44 => Some (CMD_A :: WRITE_BOOT_PAGE) , 45 => Some (CMD_A :: ERASE_WRITE_BOOT_PAGE) , 46 => Some (CMD_A :: WRITE_FLASH_PAGE) , 47 => Some (CMD_A :: ERASE_WRITE_FLASH_PAGE) , 48 => Some (CMD_A :: ERASE_EEPROM) , 50 => Some (CMD_A :: ERASE_EEPROM_PAGE) , 51 => Some (CMD_A :: LOAD_EEPROM_BUFFER) , 52 => Some (CMD_A :: WRITE_EEPROM_PAGE) , 53 => Some (CMD_A :: ERASE_WRITE_EEPROM_PAGE) , 54 => Some (CMD_A :: ERASE_EEPROM_BUFFER) , 56 => Some (CMD_A :: APP_CRC) , 57 => Some (CMD_A :: BOOT_CRC) , 58 => Some (CMD_A :: FLASH_RANGE_CRC) , 64 => Some (CMD_A :: CHIP_ERASE) , 67 => Some (CMD_A :: READ_NVM) , 76 => Some (CMD_A :: WRITE_FUSE) , 104 => Some (CMD_A :: ERASE_BOOT) , 120 => Some (CMD_A :: FLASH_CRC) , _ => None , } } # [doc = "Checks if the value of the field is `NO_OPERATION`"]
# [inline (always)]
pub fn is_no_operation (& self) -> bool { * self == CMD_A :: NO_OPERATION } # [doc = "Checks if the value of the field is `READ_USER_SIG_ROW`"]
# [inline (always)]
pub fn is_read_user_sig_row (& self) -> bool { * self == CMD_A :: READ_USER_SIG_ROW } # [doc = "Checks if the value of the field is `READ_CALIB_ROW`"]
# [inline (always)]
pub fn is_read_calib_row (& self) -> bool { * self == CMD_A :: READ_CALIB_ROW } # [doc = "Checks if the value of the field is `READ_EEPROM`"]
# [inline (always)]
pub fn is_read_eeprom (& self) -> bool { * self == CMD_A :: READ_EEPROM } # [doc = "Checks if the value of the field is `READ_FUSES`"]
# [inline (always)]
pub fn is_read_fuses (& self) -> bool { * self == CMD_A :: READ_FUSES } # [doc = "Checks if the value of the field is `WRITE_LOCK_BITS`"]
# [inline (always)]
pub fn is_write_lock_bits (& self) -> bool { * self == CMD_A :: WRITE_LOCK_BITS } # [doc = "Checks if the value of the field is `ERASE_USER_SIG_ROW`"]
# [inline (always)]
pub fn is_erase_user_sig_row (& self) -> bool { * self == CMD_A :: ERASE_USER_SIG_ROW } # [doc = "Checks if the value of the field is `WRITE_USER_SIG_ROW`"]
# [inline (always)]
pub fn is_write_user_sig_row (& self) -> bool { * self == CMD_A :: WRITE_USER_SIG_ROW } # [doc = "Checks if the value of the field is `ERASE_APP`"]
# [inline (always)]
pub fn is_erase_app (& self) -> bool { * self == CMD_A :: ERASE_APP } # [doc = "Checks if the value of the field is `ERASE_APP_PAGE`"]
# [inline (always)]
pub fn is_erase_app_page (& self) -> bool { * self == CMD_A :: ERASE_APP_PAGE } # [doc = "Checks if the value of the field is `LOAD_FLASH_BUFFER`"]
# [inline (always)]
pub fn is_load_flash_buffer (& self) -> bool { * self == CMD_A :: LOAD_FLASH_BUFFER } # [doc = "Checks if the value of the field is `WRITE_APP_PAGE`"]
# [inline (always)]
pub fn is_write_app_page (& self) -> bool { * self == CMD_A :: WRITE_APP_PAGE } # [doc = "Checks if the value of the field is `ERASE_WRITE_APP_PAGE`"]
# [inline (always)]
pub fn is_erase_write_app_page (& self) -> bool { * self == CMD_A :: ERASE_WRITE_APP_PAGE } # [doc = "Checks if the value of the field is `ERASE_FLASH_BUFFER`"]
# [inline (always)]
pub fn is_erase_flash_buffer (& self) -> bool { * self == CMD_A :: ERASE_FLASH_BUFFER } # [doc = "Checks if the value of the field is `ERASE_BOOT_PAGE`"]
# [inline (always)]
pub fn is_erase_boot_page (& self) -> bool { * self == CMD_A :: ERASE_BOOT_PAGE } # [doc = "Checks if the value of the field is `ERASE_FLASH_PAGE`"]
# [inline (always)]
pub fn is_erase_flash_page (& self) -> bool { * self == CMD_A :: ERASE_FLASH_PAGE } # [doc = "Checks if the value of the field is `WRITE_BOOT_PAGE`"]
# [inline (always)]
pub fn is_write_boot_page (& self) -> bool { * self == CMD_A :: WRITE_BOOT_PAGE } # [doc = "Checks if the value of the field is `ERASE_WRITE_BOOT_PAGE`"]
# [inline (always)]
pub fn is_erase_write_boot_page (& self) -> bool { * self == CMD_A :: ERASE_WRITE_BOOT_PAGE } # [doc = "Checks if the value of the field is `WRITE_FLASH_PAGE`"]
# [inline (always)]
pub fn is_write_flash_page (& self) -> bool { * self == CMD_A :: WRITE_FLASH_PAGE } # [doc = "Checks if the value of the field is `ERASE_WRITE_FLASH_PAGE`"]
# [inline (always)]
pub fn is_erase_write_flash_page (& self) -> bool { * self == CMD_A :: ERASE_WRITE_FLASH_PAGE } # [doc = "Checks if the value of the field is `ERASE_EEPROM`"]
# [inline (always)]
pub fn is_erase_eeprom (& self) -> bool { * self == CMD_A :: ERASE_EEPROM } # [doc = "Checks if the value of the field is `ERASE_EEPROM_PAGE`"]
# [inline (always)]
pub fn is_erase_eeprom_page (& self) -> bool { * self == CMD_A :: ERASE_EEPROM_PAGE } # [doc = "Checks if the value of the field is `LOAD_EEPROM_BUFFER`"]
# [inline (always)]
pub fn is_load_eeprom_buffer (& self) -> bool { * self == CMD_A :: LOAD_EEPROM_BUFFER } # [doc = "Checks if the value of the field is `WRITE_EEPROM_PAGE`"]
# [inline (always)]
pub fn is_write_eeprom_page (& self) -> bool { * self == CMD_A :: WRITE_EEPROM_PAGE } # [doc = "Checks if the value of the field is `ERASE_WRITE_EEPROM_PAGE`"]
# [inline (always)]
pub fn is_erase_write_eeprom_page (& self) -> bool { * self == CMD_A :: ERASE_WRITE_EEPROM_PAGE } # [doc = "Checks if the value of the field is `ERASE_EEPROM_BUFFER`"]
# [inline (always)]
pub fn is_erase_eeprom_buffer (& self) -> bool { * self == CMD_A :: ERASE_EEPROM_BUFFER } # [doc = "Checks if the value of the field is `APP_CRC`"]
# [inline (always)]
pub fn is_app_crc (& self) -> bool { * self == CMD_A :: APP_CRC } # [doc = "Checks if the value of the field is `BOOT_CRC`"]
# [inline (always)]
pub fn is_boot_crc (& self) -> bool { * self == CMD_A :: BOOT_CRC } # [doc = "Checks if the value of the field is `FLASH_RANGE_CRC`"]
# [inline (always)]
pub fn is_flash_range_crc (& self) -> bool { * self == CMD_A :: FLASH_RANGE_CRC } # [doc = "Checks if the value of the field is `CHIP_ERASE`"]
# [inline (always)]
pub fn is_chip_erase (& self) -> bool { * self == CMD_A :: CHIP_ERASE } # [doc = "Checks if the value of the field is `READ_NVM`"]
# [inline (always)]
pub fn is_read_nvm (& self) -> bool { * self == CMD_A :: READ_NVM } # [doc = "Checks if the value of the field is `WRITE_FUSE`"]
# [inline (always)]
pub fn is_write_fuse (& self) -> bool { * self == CMD_A :: WRITE_FUSE } # [doc = "Checks if the value of the field is `ERASE_BOOT`"]
# [inline (always)]
pub fn is_erase_boot (& self) -> bool { * self == CMD_A :: ERASE_BOOT } # [doc = "Checks if the value of the field is `FLASH_CRC`"]
# [inline (always)]
pub fn is_flash_crc (& self) -> bool { * self == CMD_A :: FLASH_CRC } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CMD_SPEC , u8 , CMD_A , 7 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "Noop/Ordinary LPM"]
# [inline (always)]
pub fn no_operation (self) -> & 'a mut W { self . variant (CMD_A :: NO_OPERATION) } # [doc = "Read user signature row"]
# [inline (always)]
pub fn read_user_sig_row (self) -> & 'a mut W { self . variant (CMD_A :: READ_USER_SIG_ROW) } # [doc = "Read calibration row"]
# [inline (always)]
pub fn read_calib_row (self) -> & 'a mut W { self . variant (CMD_A :: READ_CALIB_ROW) } # [doc = "Read EEPROM"]
# [inline (always)]
pub fn read_eeprom (self) -> & 'a mut W { self . variant (CMD_A :: READ_EEPROM) } # [doc = "Read fuse byte"]
# [inline (always)]
pub fn read_fuses (self) -> & 'a mut W { self . variant (CMD_A :: READ_FUSES) } # [doc = "Write lock bits"]
# [inline (always)]
pub fn write_lock_bits (self) -> & 'a mut W { self . variant (CMD_A :: WRITE_LOCK_BITS) } # [doc = "Erase user signature row"]
# [inline (always)]
pub fn erase_user_sig_row (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_USER_SIG_ROW) } # [doc = "Write user signature row"]
# [inline (always)]
pub fn write_user_sig_row (self) -> & 'a mut W { self . variant (CMD_A :: WRITE_USER_SIG_ROW) } # [doc = "Erase Application Section"]
# [inline (always)]
pub fn erase_app (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_APP) } # [doc = "Erase Application Section page"]
# [inline (always)]
pub fn erase_app_page (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_APP_PAGE) } # [doc = "Load Flash page buffer"]
# [inline (always)]
pub fn load_flash_buffer (self) -> & 'a mut W { self . variant (CMD_A :: LOAD_FLASH_BUFFER) } # [doc = "Write Application Section page"]
# [inline (always)]
pub fn write_app_page (self) -> & 'a mut W { self . variant (CMD_A :: WRITE_APP_PAGE) } # [doc = "Erase-and-write Application Section page"]
# [inline (always)]
pub fn erase_write_app_page (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_WRITE_APP_PAGE) } # [doc = "Erase/flush Flash page buffer"]
# [inline (always)]
pub fn erase_flash_buffer (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_FLASH_BUFFER) } # [doc = "Erase Boot Section page"]
# [inline (always)]
pub fn erase_boot_page (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_BOOT_PAGE) } # [doc = "Erase Flash Page"]
# [inline (always)]
pub fn erase_flash_page (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_FLASH_PAGE) } # [doc = "Write Boot Section page"]
# [inline (always)]
pub fn write_boot_page (self) -> & 'a mut W { self . variant (CMD_A :: WRITE_BOOT_PAGE) } # [doc = "Erase-and-write Boot Section page"]
# [inline (always)]
pub fn erase_write_boot_page (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_WRITE_BOOT_PAGE) } # [doc = "Write Flash Page"]
# [inline (always)]
pub fn write_flash_page (self) -> & 'a mut W { self . variant (CMD_A :: WRITE_FLASH_PAGE) } # [doc = "Erase-and-write Flash Page"]
# [inline (always)]
pub fn erase_write_flash_page (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_WRITE_FLASH_PAGE) } # [doc = "Erase EEPROM"]
# [inline (always)]
pub fn erase_eeprom (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_EEPROM) } # [doc = "Erase EEPROM page"]
# [inline (always)]
pub fn erase_eeprom_page (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_EEPROM_PAGE) } # [doc = "Load EEPROM page buffer"]
# [inline (always)]
pub fn load_eeprom_buffer (self) -> & 'a mut W { self . variant (CMD_A :: LOAD_EEPROM_BUFFER) } # [doc = "Write EEPROM page"]
# [inline (always)]
pub fn write_eeprom_page (self) -> & 'a mut W { self . variant (CMD_A :: WRITE_EEPROM_PAGE) } # [doc = "Erase-and-write EEPROM page"]
# [inline (always)]
pub fn erase_write_eeprom_page (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_WRITE_EEPROM_PAGE) } # [doc = "Erase/flush EEPROM page buffer"]
# [inline (always)]
pub fn erase_eeprom_buffer (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_EEPROM_BUFFER) } # [doc = "Application section CRC"]
# [inline (always)]
pub fn app_crc (self) -> & 'a mut W { self . variant (CMD_A :: APP_CRC) } # [doc = "Boot Section CRC"]
# [inline (always)]
pub fn boot_crc (self) -> & 'a mut W { self . variant (CMD_A :: BOOT_CRC) } # [doc = "Flash Range CRC"]
# [inline (always)]
pub fn flash_range_crc (self) -> & 'a mut W { self . variant (CMD_A :: FLASH_RANGE_CRC) } # [doc = "Erase Chip"]
# [inline (always)]
pub fn chip_erase (self) -> & 'a mut W { self . variant (CMD_A :: CHIP_ERASE) } # [doc = "Read NVM"]
# [inline (always)]
pub fn read_nvm (self) -> & 'a mut W { self . variant (CMD_A :: READ_NVM) } # [doc = "Write Fuse byte"]
# [inline (always)]
pub fn write_fuse (self) -> & 'a mut W { self . variant (CMD_A :: WRITE_FUSE) } # [doc = "Erase Boot Section"]
# [inline (always)]
pub fn erase_boot (self) -> & 'a mut W { self . variant (CMD_A :: ERASE_BOOT) } # [doc = "Flash CRC"]
# [inline (always)]
pub fn flash_crc (self) -> & 'a mut W { self . variant (CMD_A :: FLASH_CRC) } } impl R { # [doc = "Bits 0:6 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (self . bits & 0x7f) } } impl W { # [doc = "Bits 0:6 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 0 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Command\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmd](index.html) module"]
pub struct CMD_SPEC ; impl crate :: RegisterSpec for CMD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [cmd::R](R) reader structure"]
impl crate :: Readable for CMD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cmd::W](W) writer structure"]
impl crate :: Writable for CMD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CMD to value 0"]
impl crate :: Resettable for CMD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMDEX` reader - Command Execute"]
pub type CMDEX_R = crate :: BitReader < bool > ; # [doc = "Field `CMDEX` writer - Command Execute"]
pub type CMDEX_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Command Execute"]
# [inline (always)]
pub fn cmdex (& self) -> CMDEX_R { CMDEX_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Command Execute"]
# [inline (always)]
# [must_use]
pub fn cmdex (& mut self) -> CMDEX_W < 0 > { CMDEX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPMLOCK` reader - SPM Lock"]
pub type SPMLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `SPMLOCK` writer - SPM Lock"]
pub type SPMLOCK_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `EPRM` reader - EEPROM Power Reduction Enable"]
pub type EPRM_R = crate :: BitReader < bool > ; # [doc = "Field `EPRM` writer - EEPROM Power Reduction Enable"]
pub type EPRM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `FPRM` reader - Flash Power Reduction Enable"]
pub type FPRM_R = crate :: BitReader < bool > ; # [doc = "Field `FPRM` writer - Flash Power Reduction Enable"]
pub type FPRM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `EEMAPEN` reader - EEPROM Mapping Enable"]
pub type EEMAPEN_R = crate :: BitReader < bool > ; # [doc = "Field `EEMAPEN` writer - EEPROM Mapping Enable"]
pub type EEMAPEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - SPM Lock"]
# [inline (always)]
pub fn spmlock (& self) -> SPMLOCK_R { SPMLOCK_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EEPROM Power Reduction Enable"]
# [inline (always)]
pub fn eprm (& self) -> EPRM_R { EPRM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Flash Power Reduction Enable"]
# [inline (always)]
pub fn fprm (& self) -> FPRM_R { FPRM_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - EEPROM Mapping Enable"]
# [inline (always)]
pub fn eemapen (& self) -> EEMAPEN_R { EEMAPEN_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - SPM Lock"]
# [inline (always)]
# [must_use]
pub fn spmlock (& mut self) -> SPMLOCK_W < 0 > { SPMLOCK_W :: new (self) } # [doc = "Bit 1 - EEPROM Power Reduction Enable"]
# [inline (always)]
# [must_use]
pub fn eprm (& mut self) -> EPRM_W < 1 > { EPRM_W :: new (self) } # [doc = "Bit 2 - Flash Power Reduction Enable"]
# [inline (always)]
# [must_use]
pub fn fprm (& mut self) -> FPRM_W < 2 > { FPRM_W :: new (self) } # [doc = "Bit 3 - EEPROM Mapping Enable"]
# [inline (always)]
# [must_use]
pub fn eemapen (& mut self) -> EEMAPEN_W < 3 > { EEMAPEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA0 (rw) register accessor: an alias for `Reg<DATA0_SPEC>`"]
pub type DATA0 = crate :: Reg < data0 :: DATA0_SPEC > ; # [doc = "Data Register 0"]
pub mod data0 { # [doc = "Register `DATA0` reader"]
pub struct R (crate :: R < DATA0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA0_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA0` writer"]
pub struct W (crate :: W < DATA0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data0](index.html) module"]
pub struct DATA0_SPEC ; impl crate :: RegisterSpec for DATA0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data0::R](R) reader structure"]
impl crate :: Readable for DATA0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data0::W](W) writer structure"]
impl crate :: Writable for DATA0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA0 to value 0"]
impl crate :: Resettable for DATA0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA1 (rw) register accessor: an alias for `Reg<DATA1_SPEC>`"]
pub type DATA1 = crate :: Reg < data1 :: DATA1_SPEC > ; # [doc = "Data Register 1"]
pub mod data1 { # [doc = "Register `DATA1` reader"]
pub struct R (crate :: R < DATA1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA1_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA1` writer"]
pub struct W (crate :: W < DATA1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data1](index.html) module"]
pub struct DATA1_SPEC ; impl crate :: RegisterSpec for DATA1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data1::R](R) reader structure"]
impl crate :: Readable for DATA1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data1::W](W) writer structure"]
impl crate :: Writable for DATA1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA1 to value 0"]
impl crate :: Resettable for DATA1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA2 (rw) register accessor: an alias for `Reg<DATA2_SPEC>`"]
pub type DATA2 = crate :: Reg < data2 :: DATA2_SPEC > ; # [doc = "Data Register 2"]
pub mod data2 { # [doc = "Register `DATA2` reader"]
pub struct R (crate :: R < DATA2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA2_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA2` writer"]
pub struct W (crate :: W < DATA2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data2](index.html) module"]
pub struct DATA2_SPEC ; impl crate :: RegisterSpec for DATA2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data2::R](R) reader structure"]
impl crate :: Readable for DATA2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data2::W](W) writer structure"]
impl crate :: Writable for DATA2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA2 to value 0"]
impl crate :: Resettable for DATA2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EELVL` reader - EEPROM Interrupt Level"]
pub type EELVL_R = crate :: FieldReader < u8 , EELVL_A > ; # [doc = "EEPROM Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EELVL_A { # [doc = "0: Interrupt disabled"]
OFF = 0 , # [doc = "1: Low level"]
LO = 1 , # [doc = "2: Medium level"]
MED = 2 , # [doc = "3: High level"]
HI = 3 , } impl From < EELVL_A > for u8 { # [inline (always)]
fn from (variant : EELVL_A) -> Self { variant as _ } } impl EELVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EELVL_A { match self . bits { 0 => EELVL_A :: OFF , 1 => EELVL_A :: LO , 2 => EELVL_A :: MED , 3 => EELVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EELVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == EELVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == EELVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == EELVL_A :: HI } } # [doc = "Field `EELVL` writer - EEPROM Interrupt Level"]
pub type EELVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , EELVL_A , 2 , O > ; impl < 'a , const O : u8 > EELVL_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EELVL_A :: OFF) } # [doc = "Low level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (EELVL_A :: LO) } # [doc = "Medium level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (EELVL_A :: MED) } # [doc = "High level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (EELVL_A :: HI) } } # [doc = "Field `SPMLVL` reader - SPM Interrupt Level"]
pub type SPMLVL_R = crate :: FieldReader < u8 , SPMLVL_A > ; # [doc = "SPM Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SPMLVL_A { # [doc = "0: Interrupt disabled"]
OFF = 0 , # [doc = "1: Low level"]
LO = 1 , # [doc = "2: Medium level"]
MED = 2 , # [doc = "3: High level"]
HI = 3 , } impl From < SPMLVL_A > for u8 { # [inline (always)]
fn from (variant : SPMLVL_A) -> Self { variant as _ } } impl SPMLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SPMLVL_A { match self . bits { 0 => SPMLVL_A :: OFF , 1 => SPMLVL_A :: LO , 2 => SPMLVL_A :: MED , 3 => SPMLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SPMLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == SPMLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == SPMLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == SPMLVL_A :: HI } } # [doc = "Field `SPMLVL` writer - SPM Interrupt Level"]
pub type SPMLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , SPMLVL_A , 2 , O > ; impl < 'a , const O : u8 > SPMLVL_W < 'a , O > { # [doc = "Interrupt disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SPMLVL_A :: OFF) } # [doc = "Low level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (SPMLVL_A :: LO) } # [doc = "Medium level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (SPMLVL_A :: MED) } # [doc = "High level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (SPMLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - EEPROM Interrupt Level"]
# [inline (always)]
pub fn eelvl (& self) -> EELVL_R { EELVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - SPM Interrupt Level"]
# [inline (always)]
pub fn spmlvl (& self) -> SPMLVL_R { SPMLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - EEPROM Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn eelvl (& mut self) -> EELVL_W < 0 > { EELVL_W :: new (self) } # [doc = "Bits 2:3 - SPM Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn spmlvl (& mut self) -> SPMLVL_W < 2 > { SPMLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOCKBITS (rw) register accessor: an alias for `Reg<LOCKBITS_SPEC>`"]
pub type LOCKBITS = crate :: Reg < lockbits :: LOCKBITS_SPEC > ; # [doc = "Lock Bits"]
pub mod lockbits { # [doc = "Register `LOCKBITS` reader"]
pub struct R (crate :: R < LOCKBITS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKBITS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKBITS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKBITS_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCKBITS` writer"]
pub struct W (crate :: W < LOCKBITS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCKBITS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCKBITS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCKBITS_SPEC >) -> Self { W (writer) } } # [doc = "Field `LB` reader - Lock Bits"]
pub type LB_R = crate :: FieldReader < u8 , LB_A > ; # [doc = "Lock Bits\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum LB_A { # [doc = "0: Read and write not allowed"]
RWLOCK = 0 , # [doc = "2: Write not allowed"]
WLOCK = 2 , # [doc = "3: No locks"]
NOLOCK = 3 , } impl From < LB_A > for u8 { # [inline (always)]
fn from (variant : LB_A) -> Self { variant as _ } } impl LB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LB_A > { match self . bits { 0 => Some (LB_A :: RWLOCK) , 2 => Some (LB_A :: WLOCK) , 3 => Some (LB_A :: NOLOCK) , _ => None , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == LB_A :: RWLOCK } # [doc = "Checks if the value of the field is `WLOCK`"]
# [inline (always)]
pub fn is_wlock (& self) -> bool { * self == LB_A :: WLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == LB_A :: NOLOCK } } # [doc = "Field `LB` writer - Lock Bits"]
pub type LB_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , LOCKBITS_SPEC , u8 , LB_A , 2 , O > ; impl < 'a , const O : u8 > LB_W < 'a , O > { # [doc = "Read and write not allowed"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (LB_A :: RWLOCK) } # [doc = "Write not allowed"]
# [inline (always)]
pub fn wlock (self) -> & 'a mut W { self . variant (LB_A :: WLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (LB_A :: NOLOCK) } } # [doc = "Field `BLBAT` reader - Boot Lock Bits - Application Table"]
pub type BLBAT_R = crate :: FieldReader < u8 , BLBAT_A > ; # [doc = "Boot Lock Bits - Application Table\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLBAT_A { # [doc = "0: Read and write not allowed"]
RWLOCK = 0 , # [doc = "1: Read not allowed"]
RLOCK = 1 , # [doc = "2: Write not allowed"]
WLOCK = 2 , # [doc = "3: No locks"]
NOLOCK = 3 , } impl From < BLBAT_A > for u8 { # [inline (always)]
fn from (variant : BLBAT_A) -> Self { variant as _ } } impl BLBAT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLBAT_A { match self . bits { 0 => BLBAT_A :: RWLOCK , 1 => BLBAT_A :: RLOCK , 2 => BLBAT_A :: WLOCK , 3 => BLBAT_A :: NOLOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == BLBAT_A :: RWLOCK } # [doc = "Checks if the value of the field is `RLOCK`"]
# [inline (always)]
pub fn is_rlock (& self) -> bool { * self == BLBAT_A :: RLOCK } # [doc = "Checks if the value of the field is `WLOCK`"]
# [inline (always)]
pub fn is_wlock (& self) -> bool { * self == BLBAT_A :: WLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == BLBAT_A :: NOLOCK } } # [doc = "Field `BLBAT` writer - Boot Lock Bits - Application Table"]
pub type BLBAT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBITS_SPEC , u8 , BLBAT_A , 2 , O > ; impl < 'a , const O : u8 > BLBAT_W < 'a , O > { # [doc = "Read and write not allowed"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (BLBAT_A :: RWLOCK) } # [doc = "Read not allowed"]
# [inline (always)]
pub fn rlock (self) -> & 'a mut W { self . variant (BLBAT_A :: RLOCK) } # [doc = "Write not allowed"]
# [inline (always)]
pub fn wlock (self) -> & 'a mut W { self . variant (BLBAT_A :: WLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (BLBAT_A :: NOLOCK) } } # [doc = "Field `BLBA` reader - Boot Lock Bits - Application Section"]
pub type BLBA_R = crate :: FieldReader < u8 , BLBA_A > ; # [doc = "Boot Lock Bits - Application Section\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLBA_A { # [doc = "0: Read and write not allowed"]
RWLOCK = 0 , # [doc = "1: Read not allowed"]
RLOCK = 1 , # [doc = "2: Write not allowed"]
WLOCK = 2 , # [doc = "3: No locks"]
NOLOCK = 3 , } impl From < BLBA_A > for u8 { # [inline (always)]
fn from (variant : BLBA_A) -> Self { variant as _ } } impl BLBA_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLBA_A { match self . bits { 0 => BLBA_A :: RWLOCK , 1 => BLBA_A :: RLOCK , 2 => BLBA_A :: WLOCK , 3 => BLBA_A :: NOLOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == BLBA_A :: RWLOCK } # [doc = "Checks if the value of the field is `RLOCK`"]
# [inline (always)]
pub fn is_rlock (& self) -> bool { * self == BLBA_A :: RLOCK } # [doc = "Checks if the value of the field is `WLOCK`"]
# [inline (always)]
pub fn is_wlock (& self) -> bool { * self == BLBA_A :: WLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == BLBA_A :: NOLOCK } } # [doc = "Field `BLBA` writer - Boot Lock Bits - Application Section"]
pub type BLBA_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBITS_SPEC , u8 , BLBA_A , 2 , O > ; impl < 'a , const O : u8 > BLBA_W < 'a , O > { # [doc = "Read and write not allowed"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (BLBA_A :: RWLOCK) } # [doc = "Read not allowed"]
# [inline (always)]
pub fn rlock (self) -> & 'a mut W { self . variant (BLBA_A :: RLOCK) } # [doc = "Write not allowed"]
# [inline (always)]
pub fn wlock (self) -> & 'a mut W { self . variant (BLBA_A :: WLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (BLBA_A :: NOLOCK) } } # [doc = "Field `BLBB` reader - Boot Lock Bits - Boot Section"]
pub type BLBB_R = crate :: FieldReader < u8 , BLBB_A > ; # [doc = "Boot Lock Bits - Boot Section\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BLBB_A { # [doc = "0: Read and write not allowed"]
RWLOCK = 0 , # [doc = "1: Read not allowed"]
RLOCK = 1 , # [doc = "2: Write not allowed"]
WLOCK = 2 , # [doc = "3: No locks"]
NOLOCK = 3 , } impl From < BLBB_A > for u8 { # [inline (always)]
fn from (variant : BLBB_A) -> Self { variant as _ } } impl BLBB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLBB_A { match self . bits { 0 => BLBB_A :: RWLOCK , 1 => BLBB_A :: RLOCK , 2 => BLBB_A :: WLOCK , 3 => BLBB_A :: NOLOCK , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `RWLOCK`"]
# [inline (always)]
pub fn is_rwlock (& self) -> bool { * self == BLBB_A :: RWLOCK } # [doc = "Checks if the value of the field is `RLOCK`"]
# [inline (always)]
pub fn is_rlock (& self) -> bool { * self == BLBB_A :: RLOCK } # [doc = "Checks if the value of the field is `WLOCK`"]
# [inline (always)]
pub fn is_wlock (& self) -> bool { * self == BLBB_A :: WLOCK } # [doc = "Checks if the value of the field is `NOLOCK`"]
# [inline (always)]
pub fn is_nolock (& self) -> bool { * self == BLBB_A :: NOLOCK } } # [doc = "Field `BLBB` writer - Boot Lock Bits - Boot Section"]
pub type BLBB_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , LOCKBITS_SPEC , u8 , BLBB_A , 2 , O > ; impl < 'a , const O : u8 > BLBB_W < 'a , O > { # [doc = "Read and write not allowed"]
# [inline (always)]
pub fn rwlock (self) -> & 'a mut W { self . variant (BLBB_A :: RWLOCK) } # [doc = "Read not allowed"]
# [inline (always)]
pub fn rlock (self) -> & 'a mut W { self . variant (BLBB_A :: RLOCK) } # [doc = "Write not allowed"]
# [inline (always)]
pub fn wlock (self) -> & 'a mut W { self . variant (BLBB_A :: WLOCK) } # [doc = "No locks"]
# [inline (always)]
pub fn nolock (self) -> & 'a mut W { self . variant (BLBB_A :: NOLOCK) } } impl R { # [doc = "Bits 0:1 - Lock Bits"]
# [inline (always)]
pub fn lb (& self) -> LB_R { LB_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Boot Lock Bits - Application Table"]
# [inline (always)]
pub fn blbat (& self) -> BLBAT_R { BLBAT_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Boot Lock Bits - Application Section"]
# [inline (always)]
pub fn blba (& self) -> BLBA_R { BLBA_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Boot Lock Bits - Boot Section"]
# [inline (always)]
pub fn blbb (& self) -> BLBB_R { BLBB_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Lock Bits"]
# [inline (always)]
# [must_use]
pub fn lb (& mut self) -> LB_W < 0 > { LB_W :: new (self) } # [doc = "Bits 2:3 - Boot Lock Bits - Application Table"]
# [inline (always)]
# [must_use]
pub fn blbat (& mut self) -> BLBAT_W < 2 > { BLBAT_W :: new (self) } # [doc = "Bits 4:5 - Boot Lock Bits - Application Section"]
# [inline (always)]
# [must_use]
pub fn blba (& mut self) -> BLBA_W < 4 > { BLBA_W :: new (self) } # [doc = "Bits 6:7 - Boot Lock Bits - Boot Section"]
# [inline (always)]
# [must_use]
pub fn blbb (& mut self) -> BLBB_W < 6 > { BLBB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Lock Bits\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockbits](index.html) module"]
pub struct LOCKBITS_SPEC ; impl crate :: RegisterSpec for LOCKBITS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lockbits::R](R) reader structure"]
impl crate :: Readable for LOCKBITS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lockbits::W](W) writer structure"]
impl crate :: Writable for LOCKBITS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOCKBITS to value 0"]
impl crate :: Resettable for LOCKBITS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `FLOAD` reader - Flash Page Buffer Active Loading"]
pub type FLOAD_R = crate :: BitReader < bool > ; # [doc = "Field `FLOAD` writer - Flash Page Buffer Active Loading"]
pub type FLOAD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `EELOAD` reader - EEPROM Page Buffer Active Loading"]
pub type EELOAD_R = crate :: BitReader < bool > ; # [doc = "Field `EELOAD` writer - EEPROM Page Buffer Active Loading"]
pub type EELOAD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FBUSY` reader - Flash Memory Busy"]
pub type FBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `FBUSY` writer - Flash Memory Busy"]
pub type FBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `NVMBUSY` reader - Non-volatile Memory Busy"]
pub type NVMBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `NVMBUSY` writer - Non-volatile Memory Busy"]
pub type NVMBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Flash Page Buffer Active Loading"]
# [inline (always)]
pub fn fload (& self) -> FLOAD_R { FLOAD_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EEPROM Page Buffer Active Loading"]
# [inline (always)]
pub fn eeload (& self) -> EELOAD_R { EELOAD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 6 - Flash Memory Busy"]
# [inline (always)]
pub fn fbusy (& self) -> FBUSY_R { FBUSY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Non-volatile Memory Busy"]
# [inline (always)]
pub fn nvmbusy (& self) -> NVMBUSY_R { NVMBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Flash Page Buffer Active Loading"]
# [inline (always)]
# [must_use]
pub fn fload (& mut self) -> FLOAD_W < 0 > { FLOAD_W :: new (self) } # [doc = "Bit 1 - EEPROM Page Buffer Active Loading"]
# [inline (always)]
# [must_use]
pub fn eeload (& mut self) -> EELOAD_W < 1 > { EELOAD_W :: new (self) } # [doc = "Bit 6 - Flash Memory Busy"]
# [inline (always)]
# [must_use]
pub fn fbusy (& mut self) -> FBUSY_W < 6 > { FBUSY_W :: new (self) } # [doc = "Bit 7 - Non-volatile Memory Busy"]
# [inline (always)]
# [must_use]
pub fn nvmbusy (& mut self) -> NVMBUSY_W < 7 > { NVMBUSY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "On-Chip Debug System"]
pub struct OCD { _marker : PhantomData < * const () > } unsafe impl Send for OCD { } impl OCD { # [doc = r"Pointer to the register block"]
pub const PTR : * const ocd :: RegisterBlock = 0x2e as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ocd :: RegisterBlock { Self :: PTR } } impl Deref for OCD { type Target = ocd :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for OCD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OCD") . finish () } } # [doc = "On-Chip Debug System"]
pub mod ocd { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - OCD Register 0"]
pub ocdr0 : OCDR0 , # [doc = "0x01 - OCD Register 1"]
pub ocdr1 : OCDR1 , } # [doc = "OCDR0 (rw) register accessor: an alias for `Reg<OCDR0_SPEC>`"]
pub type OCDR0 = crate :: Reg < ocdr0 :: OCDR0_SPEC > ; # [doc = "OCD Register 0"]
pub mod ocdr0 { # [doc = "Register `OCDR0` reader"]
pub struct R (crate :: R < OCDR0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCDR0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCDR0_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCDR0` writer"]
pub struct W (crate :: W < OCDR0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCDR0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCDR0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCDR0_SPEC >) -> Self { W (writer) } } # [doc = "Field `OCDRD` reader - OCDR Dirty"]
pub type OCDRD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `OCDRD` writer - OCDR Dirty"]
pub type OCDRD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , OCDR0_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - OCDR Dirty"]
# [inline (always)]
pub fn ocdrd (& self) -> OCDRD_R { OCDRD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - OCDR Dirty"]
# [inline (always)]
# [must_use]
pub fn ocdrd (& mut self) -> OCDRD_W < 0 > { OCDRD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "OCD Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocdr0](index.html) module"]
pub struct OCDR0_SPEC ; impl crate :: RegisterSpec for OCDR0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocdr0::R](R) reader structure"]
impl crate :: Readable for OCDR0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocdr0::W](W) writer structure"]
impl crate :: Writable for OCDR0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCDR0 to value 0"]
impl crate :: Resettable for OCDR0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OCDR1 (rw) register accessor: an alias for `Reg<OCDR1_SPEC>`"]
pub type OCDR1 = crate :: Reg < ocdr1 :: OCDR1_SPEC > ; # [doc = "OCD Register 1"]
pub mod ocdr1 { # [doc = "Register `OCDR1` reader"]
pub struct R (crate :: R < OCDR1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OCDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OCDR1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OCDR1_SPEC >) -> Self { R (reader) } } # [doc = "Register `OCDR1` writer"]
pub struct W (crate :: W < OCDR1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OCDR1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OCDR1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OCDR1_SPEC >) -> Self { W (writer) } } # [doc = "Field `OCDRD` reader - OCDR Dirty"]
pub type OCDRD_R = crate :: BitReader < bool > ; # [doc = "Field `OCDRD` writer - OCDR Dirty"]
pub type OCDRD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , OCDR1_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - OCDR Dirty"]
# [inline (always)]
pub fn ocdrd (& self) -> OCDRD_R { OCDRD_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - OCDR Dirty"]
# [inline (always)]
# [must_use]
pub fn ocdrd (& mut self) -> OCDRD_W < 0 > { OCDRD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "OCD Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ocdr1](index.html) module"]
pub struct OCDR1_SPEC ; impl crate :: RegisterSpec for OCDR1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ocdr1::R](R) reader structure"]
impl crate :: Readable for OCDR1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ocdr1::W](W) writer structure"]
impl crate :: Writable for OCDR1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OCDR1 to value 0"]
impl crate :: Resettable for OCDR1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Oscillator"]
pub struct OSC { _marker : PhantomData < * const () > } unsafe impl Send for OSC { } impl OSC { # [doc = r"Pointer to the register block"]
pub const PTR : * const osc :: RegisterBlock = 0x50 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const osc :: RegisterBlock { Self :: PTR } } impl Deref for OSC { type Target = osc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for OSC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("OSC") . finish () } } # [doc = "Oscillator"]
pub mod osc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - Status Register"]
pub status : STATUS , # [doc = "0x02 - External Oscillator Control Register"]
pub xoscctrl : XOSCCTRL , # [doc = "0x03 - External Oscillator Failure Detection Register"]
pub xoscfail : XOSCFAIL , # [doc = "0x04 - 32kHz Internal Oscillator Calibration Register"]
pub rc32kcal : RC32KCAL , # [doc = "0x05 - PLL Control REgister"]
pub pllctrl : PLLCTRL , # [doc = "0x06 - DFLL Control Register"]
pub dfllctrl : DFLLCTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RC2MEN` reader - Internal 2MHz RC Oscillator Enable"]
pub type RC2MEN_R = crate :: BitReader < bool > ; # [doc = "Field `RC2MEN` writer - Internal 2MHz RC Oscillator Enable"]
pub type RC2MEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `RC32MEN` reader - Internal 32MHz RC Oscillator Enable"]
pub type RC32MEN_R = crate :: BitReader < bool > ; # [doc = "Field `RC32MEN` writer - Internal 32MHz RC Oscillator Enable"]
pub type RC32MEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `RC32KEN` reader - Internal 32kHz RC Oscillator Enable"]
pub type RC32KEN_R = crate :: BitReader < bool > ; # [doc = "Field `RC32KEN` writer - Internal 32kHz RC Oscillator Enable"]
pub type RC32KEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `XOSCEN` reader - External Oscillator Enable"]
pub type XOSCEN_R = crate :: BitReader < bool > ; # [doc = "Field `XOSCEN` writer - External Oscillator Enable"]
pub type XOSCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `PLLEN` reader - PLL Enable"]
pub type PLLEN_R = crate :: BitReader < bool > ; # [doc = "Field `PLLEN` writer - PLL Enable"]
pub type PLLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Internal 2MHz RC Oscillator Enable"]
# [inline (always)]
pub fn rc2men (& self) -> RC2MEN_R { RC2MEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Internal 32MHz RC Oscillator Enable"]
# [inline (always)]
pub fn rc32men (& self) -> RC32MEN_R { RC32MEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Internal 32kHz RC Oscillator Enable"]
# [inline (always)]
pub fn rc32ken (& self) -> RC32KEN_R { RC32KEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - External Oscillator Enable"]
# [inline (always)]
pub fn xoscen (& self) -> XOSCEN_R { XOSCEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - PLL Enable"]
# [inline (always)]
pub fn pllen (& self) -> PLLEN_R { PLLEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Internal 2MHz RC Oscillator Enable"]
# [inline (always)]
# [must_use]
pub fn rc2men (& mut self) -> RC2MEN_W < 0 > { RC2MEN_W :: new (self) } # [doc = "Bit 1 - Internal 32MHz RC Oscillator Enable"]
# [inline (always)]
# [must_use]
pub fn rc32men (& mut self) -> RC32MEN_W < 1 > { RC32MEN_W :: new (self) } # [doc = "Bit 2 - Internal 32kHz RC Oscillator Enable"]
# [inline (always)]
# [must_use]
pub fn rc32ken (& mut self) -> RC32KEN_W < 2 > { RC32KEN_W :: new (self) } # [doc = "Bit 3 - External Oscillator Enable"]
# [inline (always)]
# [must_use]
pub fn xoscen (& mut self) -> XOSCEN_W < 3 > { XOSCEN_W :: new (self) } # [doc = "Bit 4 - PLL Enable"]
# [inline (always)]
# [must_use]
pub fn pllen (& mut self) -> PLLEN_W < 4 > { PLLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DFLLCTRL (rw) register accessor: an alias for `Reg<DFLLCTRL_SPEC>`"]
pub type DFLLCTRL = crate :: Reg < dfllctrl :: DFLLCTRL_SPEC > ; # [doc = "DFLL Control Register"]
pub mod dfllctrl { # [doc = "Register `DFLLCTRL` reader"]
pub struct R (crate :: R < DFLLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DFLLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DFLLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DFLLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DFLLCTRL` writer"]
pub struct W (crate :: W < DFLLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DFLLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DFLLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DFLLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RC2MCREF` reader - 2MHz Calibration Reference"]
pub type RC2MCREF_R = crate :: BitReader < bool > ; # [doc = "Field `RC2MCREF` writer - 2MHz Calibration Reference"]
pub type RC2MCREF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DFLLCTRL_SPEC , bool , O > ; # [doc = "Field `RC32MCREF` reader - 32MHz Calibration Reference"]
pub type RC32MCREF_R = crate :: BitReader < bool > ; # [doc = "Field `RC32MCREF` writer - 32MHz Calibration Reference"]
pub type RC32MCREF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , DFLLCTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - 2MHz Calibration Reference"]
# [inline (always)]
pub fn rc2mcref (& self) -> RC2MCREF_R { RC2MCREF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - 32MHz Calibration Reference"]
# [inline (always)]
pub fn rc32mcref (& self) -> RC32MCREF_R { RC32MCREF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - 2MHz Calibration Reference"]
# [inline (always)]
# [must_use]
pub fn rc2mcref (& mut self) -> RC2MCREF_W < 0 > { RC2MCREF_W :: new (self) } # [doc = "Bit 1 - 32MHz Calibration Reference"]
# [inline (always)]
# [must_use]
pub fn rc32mcref (& mut self) -> RC32MCREF_W < 1 > { RC32MCREF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DFLL Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dfllctrl](index.html) module"]
pub struct DFLLCTRL_SPEC ; impl crate :: RegisterSpec for DFLLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dfllctrl::R](R) reader structure"]
impl crate :: Readable for DFLLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dfllctrl::W](W) writer structure"]
impl crate :: Writable for DFLLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DFLLCTRL to value 0"]
impl crate :: Resettable for DFLLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PLLCTRL (rw) register accessor: an alias for `Reg<PLLCTRL_SPEC>`"]
pub type PLLCTRL = crate :: Reg < pllctrl :: PLLCTRL_SPEC > ; # [doc = "PLL Control REgister"]
pub mod pllctrl { # [doc = "Register `PLLCTRL` reader"]
pub struct R (crate :: R < PLLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PLLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PLLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PLLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PLLCTRL` writer"]
pub struct W (crate :: W < PLLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PLLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PLLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PLLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PLLFAC` reader - Multiplication Factor"]
pub type PLLFAC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PLLFAC` writer - Multiplication Factor"]
pub type PLLFAC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PLLCTRL_SPEC , u8 , u8 , 5 , O > ; # [doc = "Field `PLLSRC` reader - Clock Source"]
pub type PLLSRC_R = crate :: FieldReader < u8 , PLLSRC_A > ; # [doc = "Clock Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PLLSRC_A { # [doc = "0: Internal 2MHz RC Oscillator"]
RC2M = 0 , # [doc = "2: Internal 32MHz RC Oscillator"]
RC32M = 2 , # [doc = "3: External Oscillator"]
XOSC = 3 , } impl From < PLLSRC_A > for u8 { # [inline (always)]
fn from (variant : PLLSRC_A) -> Self { variant as _ } } impl PLLSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PLLSRC_A > { match self . bits { 0 => Some (PLLSRC_A :: RC2M) , 2 => Some (PLLSRC_A :: RC32M) , 3 => Some (PLLSRC_A :: XOSC) , _ => None , } } # [doc = "Checks if the value of the field is `RC2M`"]
# [inline (always)]
pub fn is_rc2m (& self) -> bool { * self == PLLSRC_A :: RC2M } # [doc = "Checks if the value of the field is `RC32M`"]
# [inline (always)]
pub fn is_rc32m (& self) -> bool { * self == PLLSRC_A :: RC32M } # [doc = "Checks if the value of the field is `XOSC`"]
# [inline (always)]
pub fn is_xosc (& self) -> bool { * self == PLLSRC_A :: XOSC } } # [doc = "Field `PLLSRC` writer - Clock Source"]
pub type PLLSRC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PLLCTRL_SPEC , u8 , PLLSRC_A , 2 , O > ; impl < 'a , const O : u8 > PLLSRC_W < 'a , O > { # [doc = "Internal 2MHz RC Oscillator"]
# [inline (always)]
pub fn rc2m (self) -> & 'a mut W { self . variant (PLLSRC_A :: RC2M) } # [doc = "Internal 32MHz RC Oscillator"]
# [inline (always)]
pub fn rc32m (self) -> & 'a mut W { self . variant (PLLSRC_A :: RC32M) } # [doc = "External Oscillator"]
# [inline (always)]
pub fn xosc (self) -> & 'a mut W { self . variant (PLLSRC_A :: XOSC) } } impl R { # [doc = "Bits 0:4 - Multiplication Factor"]
# [inline (always)]
pub fn pllfac (& self) -> PLLFAC_R { PLLFAC_R :: new (self . bits & 0x1f) } # [doc = "Bits 6:7 - Clock Source"]
# [inline (always)]
pub fn pllsrc (& self) -> PLLSRC_R { PLLSRC_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:4 - Multiplication Factor"]
# [inline (always)]
# [must_use]
pub fn pllfac (& mut self) -> PLLFAC_W < 0 > { PLLFAC_W :: new (self) } # [doc = "Bits 6:7 - Clock Source"]
# [inline (always)]
# [must_use]
pub fn pllsrc (& mut self) -> PLLSRC_W < 6 > { PLLSRC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "PLL Control REgister\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pllctrl](index.html) module"]
pub struct PLLCTRL_SPEC ; impl crate :: RegisterSpec for PLLCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pllctrl::R](R) reader structure"]
impl crate :: Readable for PLLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pllctrl::W](W) writer structure"]
impl crate :: Writable for PLLCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PLLCTRL to value 0"]
impl crate :: Resettable for PLLCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RC32KCAL (rw) register accessor: an alias for `Reg<RC32KCAL_SPEC>`"]
pub type RC32KCAL = crate :: Reg < rc32kcal :: RC32KCAL_SPEC > ; # [doc = "32kHz Internal Oscillator Calibration Register"]
pub mod rc32kcal { # [doc = "Register `RC32KCAL` reader"]
pub struct R (crate :: R < RC32KCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RC32KCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RC32KCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RC32KCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RC32KCAL` writer"]
pub struct W (crate :: W < RC32KCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RC32KCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RC32KCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RC32KCAL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "32kHz Internal Oscillator Calibration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rc32kcal](index.html) module"]
pub struct RC32KCAL_SPEC ; impl crate :: RegisterSpec for RC32KCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rc32kcal::R](R) reader structure"]
impl crate :: Readable for RC32KCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rc32kcal::W](W) writer structure"]
impl crate :: Writable for RC32KCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RC32KCAL to value 0"]
impl crate :: Resettable for RC32KCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RC2MRDY` reader - Internal 2MHz RC Oscillator Ready"]
pub type RC2MRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RC2MRDY` writer - Internal 2MHz RC Oscillator Ready"]
pub type RC2MRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RC32MRDY` reader - Internal 32MHz RC Oscillator Ready"]
pub type RC32MRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RC32MRDY` writer - Internal 32MHz RC Oscillator Ready"]
pub type RC32MRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RC32KRDY` reader - Internal 32kHz RC Oscillator Ready"]
pub type RC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RC32KRDY` writer - Internal 32kHz RC Oscillator Ready"]
pub type RC32KRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `XOSCRDY` reader - External Oscillator Ready"]
pub type XOSCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `XOSCRDY` writer - External Oscillator Ready"]
pub type XOSCRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PLLRDY` reader - PLL Ready"]
pub type PLLRDY_R = crate :: BitReader < bool > ; # [doc = "Field `PLLRDY` writer - PLL Ready"]
pub type PLLRDY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Internal 2MHz RC Oscillator Ready"]
# [inline (always)]
pub fn rc2mrdy (& self) -> RC2MRDY_R { RC2MRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Internal 32MHz RC Oscillator Ready"]
# [inline (always)]
pub fn rc32mrdy (& self) -> RC32MRDY_R { RC32MRDY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Internal 32kHz RC Oscillator Ready"]
# [inline (always)]
pub fn rc32krdy (& self) -> RC32KRDY_R { RC32KRDY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - External Oscillator Ready"]
# [inline (always)]
pub fn xoscrdy (& self) -> XOSCRDY_R { XOSCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - PLL Ready"]
# [inline (always)]
pub fn pllrdy (& self) -> PLLRDY_R { PLLRDY_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Internal 2MHz RC Oscillator Ready"]
# [inline (always)]
# [must_use]
pub fn rc2mrdy (& mut self) -> RC2MRDY_W < 0 > { RC2MRDY_W :: new (self) } # [doc = "Bit 1 - Internal 32MHz RC Oscillator Ready"]
# [inline (always)]
# [must_use]
pub fn rc32mrdy (& mut self) -> RC32MRDY_W < 1 > { RC32MRDY_W :: new (self) } # [doc = "Bit 2 - Internal 32kHz RC Oscillator Ready"]
# [inline (always)]
# [must_use]
pub fn rc32krdy (& mut self) -> RC32KRDY_W < 2 > { RC32KRDY_W :: new (self) } # [doc = "Bit 3 - External Oscillator Ready"]
# [inline (always)]
# [must_use]
pub fn xoscrdy (& mut self) -> XOSCRDY_W < 3 > { XOSCRDY_W :: new (self) } # [doc = "Bit 4 - PLL Ready"]
# [inline (always)]
# [must_use]
pub fn pllrdy (& mut self) -> PLLRDY_W < 4 > { PLLRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "XOSCCTRL (rw) register accessor: an alias for `Reg<XOSCCTRL_SPEC>`"]
pub type XOSCCTRL = crate :: Reg < xoscctrl :: XOSCCTRL_SPEC > ; # [doc = "External Oscillator Control Register"]
pub mod xoscctrl { # [doc = "Register `XOSCCTRL` reader"]
pub struct R (crate :: R < XOSCCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XOSCCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XOSCCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XOSCCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `XOSCCTRL` writer"]
pub struct W (crate :: W < XOSCCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XOSCCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XOSCCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XOSCCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `XOSCSEL` reader - External Oscillator Selection and Startup Time"]
pub type XOSCSEL_R = crate :: FieldReader < u8 , XOSCSEL_A > ; # [doc = "External Oscillator Selection and Startup Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum XOSCSEL_A { # [doc = "0: External Clock - 6 CLK"]
EXTCLK = 0 , # [doc = "2: 32kHz TOSC - 32K CLK"]
_32KHZ = 2 , # [doc = "3: 0.4-16MHz XTAL - 256 CLK"]
XTAL_256CLK = 3 , # [doc = "7: 0.4-16MHz XTAL - 1K CLK"]
XTAL_1KCLK = 7 , # [doc = "11: 0.4-16MHz XTAL - 16K CLK"]
XTAL_16KCLK = 11 , } impl From < XOSCSEL_A > for u8 { # [inline (always)]
fn from (variant : XOSCSEL_A) -> Self { variant as _ } } impl XOSCSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < XOSCSEL_A > { match self . bits { 0 => Some (XOSCSEL_A :: EXTCLK) , 2 => Some (XOSCSEL_A :: _32KHZ) , 3 => Some (XOSCSEL_A :: XTAL_256CLK) , 7 => Some (XOSCSEL_A :: XTAL_1KCLK) , 11 => Some (XOSCSEL_A :: XTAL_16KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `EXTCLK`"]
# [inline (always)]
pub fn is_extclk (& self) -> bool { * self == XOSCSEL_A :: EXTCLK } # [doc = "Checks if the value of the field is `_32KHZ`"]
# [inline (always)]
pub fn is_32khz (& self) -> bool { * self == XOSCSEL_A :: _32KHZ } # [doc = "Checks if the value of the field is `XTAL_256CLK`"]
# [inline (always)]
pub fn is_xtal_256clk (& self) -> bool { * self == XOSCSEL_A :: XTAL_256CLK } # [doc = "Checks if the value of the field is `XTAL_1KCLK`"]
# [inline (always)]
pub fn is_xtal_1kclk (& self) -> bool { * self == XOSCSEL_A :: XTAL_1KCLK } # [doc = "Checks if the value of the field is `XTAL_16KCLK`"]
# [inline (always)]
pub fn is_xtal_16kclk (& self) -> bool { * self == XOSCSEL_A :: XTAL_16KCLK } } # [doc = "Field `XOSCSEL` writer - External Oscillator Selection and Startup Time"]
pub type XOSCSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , XOSCCTRL_SPEC , u8 , XOSCSEL_A , 4 , O > ; impl < 'a , const O : u8 > XOSCSEL_W < 'a , O > { # [doc = "External Clock - 6 CLK"]
# [inline (always)]
pub fn extclk (self) -> & 'a mut W { self . variant (XOSCSEL_A :: EXTCLK) } # [doc = "32kHz TOSC - 32K CLK"]
# [inline (always)]
pub fn _32khz (self) -> & 'a mut W { self . variant (XOSCSEL_A :: _32KHZ) } # [doc = "0.4-16MHz XTAL - 256 CLK"]
# [inline (always)]
pub fn xtal_256clk (self) -> & 'a mut W { self . variant (XOSCSEL_A :: XTAL_256CLK) } # [doc = "0.4-16MHz XTAL - 1K CLK"]
# [inline (always)]
pub fn xtal_1kclk (self) -> & 'a mut W { self . variant (XOSCSEL_A :: XTAL_1KCLK) } # [doc = "0.4-16MHz XTAL - 16K CLK"]
# [inline (always)]
pub fn xtal_16kclk (self) -> & 'a mut W { self . variant (XOSCSEL_A :: XTAL_16KCLK) } } # [doc = "Field `X32KLPM` reader - 32kHz XTAL OSC Low-power Mode"]
pub type X32KLPM_R = crate :: BitReader < bool > ; # [doc = "Field `X32KLPM` writer - 32kHz XTAL OSC Low-power Mode"]
pub type X32KLPM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSCCTRL_SPEC , bool , O > ; # [doc = "Field `FRQRANGE` reader - Frequency Range"]
pub type FRQRANGE_R = crate :: FieldReader < u8 , FRQRANGE_A > ; # [doc = "Frequency Range\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum FRQRANGE_A { # [doc = "0: 0.4 - 2 MHz"]
_04TO2 = 0 , # [doc = "1: 2 - 9 MHz"]
_2TO9 = 1 , # [doc = "2: 9 - 12 MHz"]
_9TO12 = 2 , # [doc = "3: 12 - 16 MHz"]
_12TO16 = 3 , } impl From < FRQRANGE_A > for u8 { # [inline (always)]
fn from (variant : FRQRANGE_A) -> Self { variant as _ } } impl FRQRANGE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FRQRANGE_A { match self . bits { 0 => FRQRANGE_A :: _04TO2 , 1 => FRQRANGE_A :: _2TO9 , 2 => FRQRANGE_A :: _9TO12 , 3 => FRQRANGE_A :: _12TO16 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_04TO2`"]
# [inline (always)]
pub fn is_04to2 (& self) -> bool { * self == FRQRANGE_A :: _04TO2 } # [doc = "Checks if the value of the field is `_2TO9`"]
# [inline (always)]
pub fn is_2to9 (& self) -> bool { * self == FRQRANGE_A :: _2TO9 } # [doc = "Checks if the value of the field is `_9TO12`"]
# [inline (always)]
pub fn is_9to12 (& self) -> bool { * self == FRQRANGE_A :: _9TO12 } # [doc = "Checks if the value of the field is `_12TO16`"]
# [inline (always)]
pub fn is_12to16 (& self) -> bool { * self == FRQRANGE_A :: _12TO16 } } # [doc = "Field `FRQRANGE` writer - Frequency Range"]
pub type FRQRANGE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , XOSCCTRL_SPEC , u8 , FRQRANGE_A , 2 , O > ; impl < 'a , const O : u8 > FRQRANGE_W < 'a , O > { # [doc = "0.4 - 2 MHz"]
# [inline (always)]
pub fn _04to2 (self) -> & 'a mut W { self . variant (FRQRANGE_A :: _04TO2) } # [doc = "2 - 9 MHz"]
# [inline (always)]
pub fn _2to9 (self) -> & 'a mut W { self . variant (FRQRANGE_A :: _2TO9) } # [doc = "9 - 12 MHz"]
# [inline (always)]
pub fn _9to12 (self) -> & 'a mut W { self . variant (FRQRANGE_A :: _9TO12) } # [doc = "12 - 16 MHz"]
# [inline (always)]
pub fn _12to16 (self) -> & 'a mut W { self . variant (FRQRANGE_A :: _12TO16) } } impl R { # [doc = "Bits 0:3 - External Oscillator Selection and Startup Time"]
# [inline (always)]
pub fn xoscsel (& self) -> XOSCSEL_R { XOSCSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 5 - 32kHz XTAL OSC Low-power Mode"]
# [inline (always)]
pub fn x32klpm (& self) -> X32KLPM_R { X32KLPM_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 6:7 - Frequency Range"]
# [inline (always)]
pub fn frqrange (& self) -> FRQRANGE_R { FRQRANGE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:3 - External Oscillator Selection and Startup Time"]
# [inline (always)]
# [must_use]
pub fn xoscsel (& mut self) -> XOSCSEL_W < 0 > { XOSCSEL_W :: new (self) } # [doc = "Bit 5 - 32kHz XTAL OSC Low-power Mode"]
# [inline (always)]
# [must_use]
pub fn x32klpm (& mut self) -> X32KLPM_W < 5 > { X32KLPM_W :: new (self) } # [doc = "Bits 6:7 - Frequency Range"]
# [inline (always)]
# [must_use]
pub fn frqrange (& mut self) -> FRQRANGE_W < 6 > { FRQRANGE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Oscillator Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xoscctrl](index.html) module"]
pub struct XOSCCTRL_SPEC ; impl crate :: RegisterSpec for XOSCCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [xoscctrl::R](R) reader structure"]
impl crate :: Readable for XOSCCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xoscctrl::W](W) writer structure"]
impl crate :: Writable for XOSCCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets XOSCCTRL to value 0"]
impl crate :: Resettable for XOSCCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "XOSCFAIL (rw) register accessor: an alias for `Reg<XOSCFAIL_SPEC>`"]
pub type XOSCFAIL = crate :: Reg < xoscfail :: XOSCFAIL_SPEC > ; # [doc = "External Oscillator Failure Detection Register"]
pub mod xoscfail { # [doc = "Register `XOSCFAIL` reader"]
pub struct R (crate :: R < XOSCFAIL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XOSCFAIL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XOSCFAIL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XOSCFAIL_SPEC >) -> Self { R (reader) } } # [doc = "Register `XOSCFAIL` writer"]
pub struct W (crate :: W < XOSCFAIL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XOSCFAIL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XOSCFAIL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XOSCFAIL_SPEC >) -> Self { W (writer) } } # [doc = "Field `XOSCFDEN` reader - Failure Detection Enable"]
pub type XOSCFDEN_R = crate :: BitReader < bool > ; # [doc = "Field `XOSCFDEN` writer - Failure Detection Enable"]
pub type XOSCFDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSCFAIL_SPEC , bool , O > ; # [doc = "Field `XOSCFDIF` reader - Failure Detection Interrupt Flag"]
pub type XOSCFDIF_R = crate :: BitReader < bool > ; # [doc = "Field `XOSCFDIF` writer - Failure Detection Interrupt Flag"]
pub type XOSCFDIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , XOSCFAIL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Failure Detection Enable"]
# [inline (always)]
pub fn xoscfden (& self) -> XOSCFDEN_R { XOSCFDEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Failure Detection Interrupt Flag"]
# [inline (always)]
pub fn xoscfdif (& self) -> XOSCFDIF_R { XOSCFDIF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Failure Detection Enable"]
# [inline (always)]
# [must_use]
pub fn xoscfden (& mut self) -> XOSCFDEN_W < 0 > { XOSCFDEN_W :: new (self) } # [doc = "Bit 1 - Failure Detection Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn xoscfdif (& mut self) -> XOSCFDIF_W < 1 > { XOSCFDIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Oscillator Failure Detection Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xoscfail](index.html) module"]
pub struct XOSCFAIL_SPEC ; impl crate :: RegisterSpec for XOSCFAIL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [xoscfail::R](R) reader structure"]
impl crate :: Readable for XOSCFAIL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xoscfail::W](W) writer structure"]
impl crate :: Writable for XOSCFAIL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets XOSCFAIL to value 0"]
impl crate :: Resettable for XOSCFAIL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Programmable Multi-level Interrupt Controller"]
pub struct PMIC { _marker : PhantomData < * const () > } unsafe impl Send for PMIC { } impl PMIC { # [doc = r"Pointer to the register block"]
pub const PTR : * const pmic :: RegisterBlock = 0xa0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pmic :: RegisterBlock { Self :: PTR } } impl Deref for PMIC { type Target = pmic :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PMIC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PMIC") . finish () } } # [doc = "Programmable Multi-level Interrupt Controller"]
pub mod pmic { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Status Register"]
pub status : STATUS , # [doc = "0x01 - Interrupt Priority"]
pub intpri : INTPRI , # [doc = "0x02 - Control Register"]
pub ctrl : CTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `LOLVLEN` reader - Low Level Enable"]
pub type LOLVLEN_R = crate :: BitReader < bool > ; # [doc = "Field `LOLVLEN` writer - Low Level Enable"]
pub type LOLVLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `MEDLVLEN` reader - Medium Level Enable"]
pub type MEDLVLEN_R = crate :: BitReader < bool > ; # [doc = "Field `MEDLVLEN` writer - Medium Level Enable"]
pub type MEDLVLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `HILVLEN` reader - High Level Enable"]
pub type HILVLEN_R = crate :: BitReader < bool > ; # [doc = "Field `HILVLEN` writer - High Level Enable"]
pub type HILVLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `IVSEL` reader - Interrupt Vector Select"]
pub type IVSEL_R = crate :: BitReader < bool > ; # [doc = "Field `IVSEL` writer - Interrupt Vector Select"]
pub type IVSEL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `RREN` reader - Round-Robin Priority Enable"]
pub type RREN_R = crate :: BitReader < bool > ; # [doc = "Field `RREN` writer - Round-Robin Priority Enable"]
pub type RREN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Level Enable"]
# [inline (always)]
pub fn lolvlen (& self) -> LOLVLEN_R { LOLVLEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Medium Level Enable"]
# [inline (always)]
pub fn medlvlen (& self) -> MEDLVLEN_R { MEDLVLEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - High Level Enable"]
# [inline (always)]
pub fn hilvlen (& self) -> HILVLEN_R { HILVLEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Interrupt Vector Select"]
# [inline (always)]
pub fn ivsel (& self) -> IVSEL_R { IVSEL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Round-Robin Priority Enable"]
# [inline (always)]
pub fn rren (& self) -> RREN_R { RREN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Level Enable"]
# [inline (always)]
# [must_use]
pub fn lolvlen (& mut self) -> LOLVLEN_W < 0 > { LOLVLEN_W :: new (self) } # [doc = "Bit 1 - Medium Level Enable"]
# [inline (always)]
# [must_use]
pub fn medlvlen (& mut self) -> MEDLVLEN_W < 1 > { MEDLVLEN_W :: new (self) } # [doc = "Bit 2 - High Level Enable"]
# [inline (always)]
# [must_use]
pub fn hilvlen (& mut self) -> HILVLEN_W < 2 > { HILVLEN_W :: new (self) } # [doc = "Bit 6 - Interrupt Vector Select"]
# [inline (always)]
# [must_use]
pub fn ivsel (& mut self) -> IVSEL_W < 6 > { IVSEL_W :: new (self) } # [doc = "Bit 7 - Round-Robin Priority Enable"]
# [inline (always)]
# [must_use]
pub fn rren (& mut self) -> RREN_W < 7 > { RREN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTPRI (rw) register accessor: an alias for `Reg<INTPRI_SPEC>`"]
pub type INTPRI = crate :: Reg < intpri :: INTPRI_SPEC > ; # [doc = "Interrupt Priority"]
pub mod intpri { # [doc = "Register `INTPRI` reader"]
pub struct R (crate :: R < INTPRI_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTPRI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTPRI_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTPRI_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTPRI` writer"]
pub struct W (crate :: W < INTPRI_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTPRI_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTPRI_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTPRI_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTPRI` reader - Interrupt Priority"]
pub type INTPRI_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INTPRI` writer - Interrupt Priority"]
pub type INTPRI_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTPRI_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Interrupt Priority"]
# [inline (always)]
pub fn intpri (& self) -> INTPRI_R { INTPRI_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Interrupt Priority"]
# [inline (always)]
# [must_use]
pub fn intpri (& mut self) -> INTPRI_W < 0 > { INTPRI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Interrupt Priority\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intpri](index.html) module"]
pub struct INTPRI_SPEC ; impl crate :: RegisterSpec for INTPRI_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intpri::R](R) reader structure"]
impl crate :: Readable for INTPRI_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intpri::W](W) writer structure"]
impl crate :: Writable for INTPRI_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTPRI to value 0"]
impl crate :: Resettable for INTPRI_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `LOLVLEX` reader - Low Level Interrupt Executing"]
pub type LOLVLEX_R = crate :: BitReader < bool > ; # [doc = "Field `LOLVLEX` writer - Low Level Interrupt Executing"]
pub type LOLVLEX_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `MEDLVLEX` reader - Medium Level Interrupt Executing"]
pub type MEDLVLEX_R = crate :: BitReader < bool > ; # [doc = "Field `MEDLVLEX` writer - Medium Level Interrupt Executing"]
pub type MEDLVLEX_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `HILVLEX` reader - High Level Interrupt Executing"]
pub type HILVLEX_R = crate :: BitReader < bool > ; # [doc = "Field `HILVLEX` writer - High Level Interrupt Executing"]
pub type HILVLEX_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `NMIEX` reader - Non-maskable Interrupt Executing"]
pub type NMIEX_R = crate :: BitReader < bool > ; # [doc = "Field `NMIEX` writer - Non-maskable Interrupt Executing"]
pub type NMIEX_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Low Level Interrupt Executing"]
# [inline (always)]
pub fn lolvlex (& self) -> LOLVLEX_R { LOLVLEX_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Medium Level Interrupt Executing"]
# [inline (always)]
pub fn medlvlex (& self) -> MEDLVLEX_R { MEDLVLEX_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - High Level Interrupt Executing"]
# [inline (always)]
pub fn hilvlex (& self) -> HILVLEX_R { HILVLEX_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Non-maskable Interrupt Executing"]
# [inline (always)]
pub fn nmiex (& self) -> NMIEX_R { NMIEX_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Low Level Interrupt Executing"]
# [inline (always)]
# [must_use]
pub fn lolvlex (& mut self) -> LOLVLEX_W < 0 > { LOLVLEX_W :: new (self) } # [doc = "Bit 1 - Medium Level Interrupt Executing"]
# [inline (always)]
# [must_use]
pub fn medlvlex (& mut self) -> MEDLVLEX_W < 1 > { MEDLVLEX_W :: new (self) } # [doc = "Bit 2 - High Level Interrupt Executing"]
# [inline (always)]
# [must_use]
pub fn hilvlex (& mut self) -> HILVLEX_W < 2 > { HILVLEX_W :: new (self) } # [doc = "Bit 7 - Non-maskable Interrupt Executing"]
# [inline (always)]
# [must_use]
pub fn nmiex (& mut self) -> NMIEX_W < 7 > { NMIEX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTA { _marker : PhantomData < * const () > } unsafe impl Send for PORTA { } impl PORTA { # [doc = r"Pointer to the register block"]
pub const PTR : * const porta :: RegisterBlock = 0x0600 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porta :: RegisterBlock { Self :: PTR } } impl Deref for PORTA { type Target = porta :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTA") . finish () } } # [doc = "Port Configuration"]
pub mod porta { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTB { _marker : PhantomData < * const () > } unsafe impl Send for PORTB { } impl PORTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const portb :: RegisterBlock = 0x0620 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portb :: RegisterBlock { Self :: PTR } } impl Deref for PORTB { type Target = portb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTB") . finish () } } # [doc = "Port Configuration"]
pub mod portb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTC { _marker : PhantomData < * const () > } unsafe impl Send for PORTC { } impl PORTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const portc :: RegisterBlock = 0x0640 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portc :: RegisterBlock { Self :: PTR } } impl Deref for PORTC { type Target = portc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTC") . finish () } } # [doc = "Port Configuration"]
pub mod portc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTD { _marker : PhantomData < * const () > } unsafe impl Send for PORTD { } impl PORTD { # [doc = r"Pointer to the register block"]
pub const PTR : * const portd :: RegisterBlock = 0x0660 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portd :: RegisterBlock { Self :: PTR } } impl Deref for PORTD { type Target = portd :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTD { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTD") . finish () } } # [doc = "Port Configuration"]
pub mod portd { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTE { _marker : PhantomData < * const () > } unsafe impl Send for PORTE { } impl PORTE { # [doc = r"Pointer to the register block"]
pub const PTR : * const porte :: RegisterBlock = 0x0680 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porte :: RegisterBlock { Self :: PTR } } impl Deref for PORTE { type Target = porte :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTE") . finish () } } # [doc = "Port Configuration"]
pub mod porte { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTF { _marker : PhantomData < * const () > } unsafe impl Send for PORTF { } impl PORTF { # [doc = r"Pointer to the register block"]
pub const PTR : * const portf :: RegisterBlock = 0x06a0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portf :: RegisterBlock { Self :: PTR } } impl Deref for PORTF { type Target = portf :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTF") . finish () } } # [doc = "Port Configuration"]
pub mod portf { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTH { _marker : PhantomData < * const () > } unsafe impl Send for PORTH { } impl PORTH { # [doc = r"Pointer to the register block"]
pub const PTR : * const porth :: RegisterBlock = 0x06e0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const porth :: RegisterBlock { Self :: PTR } } impl Deref for PORTH { type Target = porth :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTH { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTH") . finish () } } # [doc = "Port Configuration"]
pub mod porth { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTJ { _marker : PhantomData < * const () > } unsafe impl Send for PORTJ { } impl PORTJ { # [doc = r"Pointer to the register block"]
pub const PTR : * const portj :: RegisterBlock = 0x0700 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portj :: RegisterBlock { Self :: PTR } } impl Deref for PORTJ { type Target = portj :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTJ { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTJ") . finish () } } # [doc = "Port Configuration"]
pub mod portj { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTK { _marker : PhantomData < * const () > } unsafe impl Send for PORTK { } impl PORTK { # [doc = r"Pointer to the register block"]
pub const PTR : * const portk :: RegisterBlock = 0x0720 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portk :: RegisterBlock { Self :: PTR } } impl Deref for PORTK { type Target = portk :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTK { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTK") . finish () } } # [doc = "Port Configuration"]
pub mod portk { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTQ { _marker : PhantomData < * const () > } unsafe impl Send for PORTQ { } impl PORTQ { # [doc = r"Pointer to the register block"]
pub const PTR : * const portq :: RegisterBlock = 0x07c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portq :: RegisterBlock { Self :: PTR } } impl Deref for PORTQ { type Target = portq :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTQ { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTQ") . finish () } } # [doc = "Port Configuration"]
pub mod portq { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORTR { _marker : PhantomData < * const () > } unsafe impl Send for PORTR { } impl PORTR { # [doc = r"Pointer to the register block"]
pub const PTR : * const portr :: RegisterBlock = 0x07e0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const portr :: RegisterBlock { Self :: PTR } } impl Deref for PORTR { type Target = portr :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORTR { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORTR") . finish () } } # [doc = "Port Configuration"]
pub mod portr { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Data Direction Set"]
pub dirset : DIRSET , # [doc = "0x02 - I/O Port Data Direction Clear"]
pub dirclr : DIRCLR , # [doc = "0x03 - I/O Port Data Direction Toggle"]
pub dirtgl : DIRTGL , # [doc = "0x04 - I/O Port Output"]
pub out : OUT , # [doc = "0x05 - I/O Port Output Set"]
pub outset : OUTSET , # [doc = "0x06 - I/O Port Output Clear"]
pub outclr : OUTCLR , # [doc = "0x07 - I/O Port Output Toggle"]
pub outtgl : OUTTGL , # [doc = "0x08 - I/O port Input"]
pub in_ : IN , # [doc = "0x09 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x0a - Port Interrupt 0 Mask"]
pub int0mask : INT0MASK , # [doc = "0x0b - Port Interrupt 1 Mask"]
pub int1mask : INT1MASK , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved13 : [u8 ; 0x03]
, # [doc = "0x10 - Pin 0 Control Register"]
pub pin0ctrl : PIN0CTRL , # [doc = "0x11 - Pin 1 Control Register"]
pub pin1ctrl : PIN1CTRL , # [doc = "0x12 - Pin 2 Control Register"]
pub pin2ctrl : PIN2CTRL , # [doc = "0x13 - Pin 3 Control Register"]
pub pin3ctrl : PIN3CTRL , # [doc = "0x14 - Pin 4 Control Register"]
pub pin4ctrl : PIN4CTRL , # [doc = "0x15 - Pin 5 Control Register"]
pub pin5ctrl : PIN5CTRL , # [doc = "0x16 - Pin 6 Control Register"]
pub pin6ctrl : PIN6CTRL , # [doc = "0x17 - Pin 7 Control Register"]
pub pin7ctrl : PIN7CTRL , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRCLR (rw) register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "I/O Port Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRCLR to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRSET (rw) register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "I/O Port Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRSET to value 0"]
impl crate :: Resettable for DIRSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DIRTGL (rw) register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "I/O Port Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIRTGL to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT0MASK (rw) register accessor: an alias for `Reg<INT0MASK_SPEC>`"]
pub type INT0MASK = crate :: Reg < int0mask :: INT0MASK_SPEC > ; # [doc = "Port Interrupt 0 Mask"]
pub mod int0mask { # [doc = "Register `INT0MASK` reader"]
pub struct R (crate :: R < INT0MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT0MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT0MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT0MASK` writer"]
pub struct W (crate :: W < INT0MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT0MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT0MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT0MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 0 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int0mask](index.html) module"]
pub struct INT0MASK_SPEC ; impl crate :: RegisterSpec for INT0MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int0mask::R](R) reader structure"]
impl crate :: Readable for INT0MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int0mask::W](W) writer structure"]
impl crate :: Writable for INT0MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT0MASK to value 0"]
impl crate :: Resettable for INT0MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INT1MASK (rw) register accessor: an alias for `Reg<INT1MASK_SPEC>`"]
pub type INT1MASK = crate :: Reg < int1mask :: INT1MASK_SPEC > ; # [doc = "Port Interrupt 1 Mask"]
pub mod int1mask { # [doc = "Register `INT1MASK` reader"]
pub struct R (crate :: R < INT1MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INT1MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INT1MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `INT1MASK` writer"]
pub struct W (crate :: W < INT1MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INT1MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INT1MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INT1MASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Port Interrupt 1 Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int1mask](index.html) module"]
pub struct INT1MASK_SPEC ; impl crate :: RegisterSpec for INT1MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [int1mask::R](R) reader structure"]
impl crate :: Readable for INT1MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [int1mask::W](W) writer structure"]
impl crate :: Writable for INT1MASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INT1MASK to value 0"]
impl crate :: Resettable for INT1MASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0LVL` reader - Port Interrupt 0 Level"]
pub type INT0LVL_R = crate :: FieldReader < u8 , INT0LVL_A > ; # [doc = "Port Interrupt 0 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT0LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT0LVL_A > for u8 { # [inline (always)]
fn from (variant : INT0LVL_A) -> Self { variant as _ } } impl INT0LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT0LVL_A { match self . bits { 0 => INT0LVL_A :: OFF , 1 => INT0LVL_A :: LO , 2 => INT0LVL_A :: MED , 3 => INT0LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT0LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT0LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT0LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT0LVL_A :: HI } } # [doc = "Field `INT0LVL` writer - Port Interrupt 0 Level"]
pub type INT0LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT0LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT0LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT0LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT0LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT0LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT0LVL_A :: HI) } } # [doc = "Field `INT1LVL` reader - Port Interrupt 1 Level"]
pub type INT1LVL_R = crate :: FieldReader < u8 , INT1LVL_A > ; # [doc = "Port Interrupt 1 Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INT1LVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INT1LVL_A > for u8 { # [inline (always)]
fn from (variant : INT1LVL_A) -> Self { variant as _ } } impl INT1LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INT1LVL_A { match self . bits { 0 => INT1LVL_A :: OFF , 1 => INT1LVL_A :: LO , 2 => INT1LVL_A :: MED , 3 => INT1LVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INT1LVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INT1LVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INT1LVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INT1LVL_A :: HI } } # [doc = "Field `INT1LVL` writer - Port Interrupt 1 Level"]
pub type INT1LVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INT1LVL_A , 2 , O > ; impl < 'a , const O : u8 > INT1LVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INT1LVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INT1LVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INT1LVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INT1LVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
pub fn int0lvl (& self) -> INT0LVL_R { INT0LVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
pub fn int1lvl (& self) -> INT1LVL_R { INT1LVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Port Interrupt 0 Level"]
# [inline (always)]
# [must_use]
pub fn int0lvl (& mut self) -> INT0LVL_W < 0 > { INT0LVL_W :: new (self) } # [doc = "Bits 2:3 - Port Interrupt 1 Level"]
# [inline (always)]
# [must_use]
pub fn int1lvl (& mut self) -> INT1LVL_W < 2 > { INT1LVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTCLR (rw) register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "I/O Port Output Clear"]
pub mod outclr { # [doc = "Register `OUTCLR` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTCLR to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTSET (rw) register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "I/O Port Output Set"]
pub mod outset { # [doc = "Register `OUTSET` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTSET to value 0"]
impl crate :: Resettable for OUTSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUTTGL (rw) register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "I/O Port Output Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUTTGL to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN0CTRL (rw) register accessor: an alias for `Reg<PIN0CTRL_SPEC>`"]
pub type PIN0CTRL = crate :: Reg < pin0ctrl :: PIN0CTRL_SPEC > ; # [doc = "Pin 0 Control Register"]
pub mod pin0ctrl { # [doc = "Register `PIN0CTRL` reader"]
pub struct R (crate :: R < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN0CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN0CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN0CTRL` writer"]
pub struct W (crate :: W < PIN0CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN0CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN0CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN0CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN0CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN0CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN0CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 0 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin0ctrl](index.html) module"]
pub struct PIN0CTRL_SPEC ; impl crate :: RegisterSpec for PIN0CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin0ctrl::R](R) reader structure"]
impl crate :: Readable for PIN0CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin0ctrl::W](W) writer structure"]
impl crate :: Writable for PIN0CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN0CTRL to value 0"]
impl crate :: Resettable for PIN0CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN1CTRL (rw) register accessor: an alias for `Reg<PIN1CTRL_SPEC>`"]
pub type PIN1CTRL = crate :: Reg < pin1ctrl :: PIN1CTRL_SPEC > ; # [doc = "Pin 1 Control Register"]
pub mod pin1ctrl { # [doc = "Register `PIN1CTRL` reader"]
pub struct R (crate :: R < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN1CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN1CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN1CTRL` writer"]
pub struct W (crate :: W < PIN1CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN1CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN1CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN1CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN1CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN1CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN1CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 1 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin1ctrl](index.html) module"]
pub struct PIN1CTRL_SPEC ; impl crate :: RegisterSpec for PIN1CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin1ctrl::R](R) reader structure"]
impl crate :: Readable for PIN1CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin1ctrl::W](W) writer structure"]
impl crate :: Writable for PIN1CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN1CTRL to value 0"]
impl crate :: Resettable for PIN1CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN2CTRL (rw) register accessor: an alias for `Reg<PIN2CTRL_SPEC>`"]
pub type PIN2CTRL = crate :: Reg < pin2ctrl :: PIN2CTRL_SPEC > ; # [doc = "Pin 2 Control Register"]
pub mod pin2ctrl { # [doc = "Register `PIN2CTRL` reader"]
pub struct R (crate :: R < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN2CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN2CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN2CTRL` writer"]
pub struct W (crate :: W < PIN2CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN2CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN2CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN2CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN2CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN2CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN2CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 2 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin2ctrl](index.html) module"]
pub struct PIN2CTRL_SPEC ; impl crate :: RegisterSpec for PIN2CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin2ctrl::R](R) reader structure"]
impl crate :: Readable for PIN2CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin2ctrl::W](W) writer structure"]
impl crate :: Writable for PIN2CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN2CTRL to value 0"]
impl crate :: Resettable for PIN2CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN3CTRL (rw) register accessor: an alias for `Reg<PIN3CTRL_SPEC>`"]
pub type PIN3CTRL = crate :: Reg < pin3ctrl :: PIN3CTRL_SPEC > ; # [doc = "Pin 3 Control Register"]
pub mod pin3ctrl { # [doc = "Register `PIN3CTRL` reader"]
pub struct R (crate :: R < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN3CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN3CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN3CTRL` writer"]
pub struct W (crate :: W < PIN3CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN3CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN3CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN3CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN3CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN3CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN3CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 3 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin3ctrl](index.html) module"]
pub struct PIN3CTRL_SPEC ; impl crate :: RegisterSpec for PIN3CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin3ctrl::R](R) reader structure"]
impl crate :: Readable for PIN3CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin3ctrl::W](W) writer structure"]
impl crate :: Writable for PIN3CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN3CTRL to value 0"]
impl crate :: Resettable for PIN3CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN4CTRL (rw) register accessor: an alias for `Reg<PIN4CTRL_SPEC>`"]
pub type PIN4CTRL = crate :: Reg < pin4ctrl :: PIN4CTRL_SPEC > ; # [doc = "Pin 4 Control Register"]
pub mod pin4ctrl { # [doc = "Register `PIN4CTRL` reader"]
pub struct R (crate :: R < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN4CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN4CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN4CTRL` writer"]
pub struct W (crate :: W < PIN4CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN4CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN4CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN4CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN4CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN4CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN4CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 4 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin4ctrl](index.html) module"]
pub struct PIN4CTRL_SPEC ; impl crate :: RegisterSpec for PIN4CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin4ctrl::R](R) reader structure"]
impl crate :: Readable for PIN4CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin4ctrl::W](W) writer structure"]
impl crate :: Writable for PIN4CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN4CTRL to value 0"]
impl crate :: Resettable for PIN4CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN5CTRL (rw) register accessor: an alias for `Reg<PIN5CTRL_SPEC>`"]
pub type PIN5CTRL = crate :: Reg < pin5ctrl :: PIN5CTRL_SPEC > ; # [doc = "Pin 5 Control Register"]
pub mod pin5ctrl { # [doc = "Register `PIN5CTRL` reader"]
pub struct R (crate :: R < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN5CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN5CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN5CTRL` writer"]
pub struct W (crate :: W < PIN5CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN5CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN5CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN5CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN5CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN5CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN5CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 5 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin5ctrl](index.html) module"]
pub struct PIN5CTRL_SPEC ; impl crate :: RegisterSpec for PIN5CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin5ctrl::R](R) reader structure"]
impl crate :: Readable for PIN5CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin5ctrl::W](W) writer structure"]
impl crate :: Writable for PIN5CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN5CTRL to value 0"]
impl crate :: Resettable for PIN5CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN6CTRL (rw) register accessor: an alias for `Reg<PIN6CTRL_SPEC>`"]
pub type PIN6CTRL = crate :: Reg < pin6ctrl :: PIN6CTRL_SPEC > ; # [doc = "Pin 6 Control Register"]
pub mod pin6ctrl { # [doc = "Register `PIN6CTRL` reader"]
pub struct R (crate :: R < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN6CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN6CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN6CTRL` writer"]
pub struct W (crate :: W < PIN6CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN6CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN6CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN6CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN6CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN6CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN6CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 6 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin6ctrl](index.html) module"]
pub struct PIN6CTRL_SPEC ; impl crate :: RegisterSpec for PIN6CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin6ctrl::R](R) reader structure"]
impl crate :: Readable for PIN6CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin6ctrl::W](W) writer structure"]
impl crate :: Writable for PIN6CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN6CTRL to value 0"]
impl crate :: Resettable for PIN6CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PIN7CTRL (rw) register accessor: an alias for `Reg<PIN7CTRL_SPEC>`"]
pub type PIN7CTRL = crate :: Reg < pin7ctrl :: PIN7CTRL_SPEC > ; # [doc = "Pin 7 Control Register"]
pub mod pin7ctrl { # [doc = "Register `PIN7CTRL` reader"]
pub struct R (crate :: R < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PIN7CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PIN7CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PIN7CTRL` writer"]
pub struct W (crate :: W < PIN7CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PIN7CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PIN7CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PIN7CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ISC` reader - Input/Sense Configuration"]
pub type ISC_R = crate :: FieldReader < u8 , ISC_A > ; # [doc = "Input/Sense Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ISC_A { # [doc = "0: Sense Both Edges"]
BOTHEDGES = 0 , # [doc = "1: Sense Rising Edge"]
RISING = 1 , # [doc = "2: Sense Falling Edge"]
FALLING = 2 , # [doc = "3: Sense Level (Transparent For Events)"]
LEVEL = 3 , # [doc = "7: Disable Digital Input Buffer"]
INPUT_DISABLE = 7 , } impl From < ISC_A > for u8 { # [inline (always)]
fn from (variant : ISC_A) -> Self { variant as _ } } impl ISC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ISC_A > { match self . bits { 0 => Some (ISC_A :: BOTHEDGES) , 1 => Some (ISC_A :: RISING) , 2 => Some (ISC_A :: FALLING) , 3 => Some (ISC_A :: LEVEL) , 7 => Some (ISC_A :: INPUT_DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `BOTHEDGES`"]
# [inline (always)]
pub fn is_bothedges (& self) -> bool { * self == ISC_A :: BOTHEDGES } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == ISC_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == ISC_A :: FALLING } # [doc = "Checks if the value of the field is `LEVEL`"]
# [inline (always)]
pub fn is_level (& self) -> bool { * self == ISC_A :: LEVEL } # [doc = "Checks if the value of the field is `INPUT_DISABLE`"]
# [inline (always)]
pub fn is_input_disable (& self) -> bool { * self == ISC_A :: INPUT_DISABLE } } # [doc = "Field `ISC` writer - Input/Sense Configuration"]
pub type ISC_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , PIN7CTRL_SPEC , u8 , ISC_A , 3 , O > ; impl < 'a , const O : u8 > ISC_W < 'a , O > { # [doc = "Sense Both Edges"]
# [inline (always)]
pub fn bothedges (self) -> & 'a mut W { self . variant (ISC_A :: BOTHEDGES) } # [doc = "Sense Rising Edge"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (ISC_A :: RISING) } # [doc = "Sense Falling Edge"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (ISC_A :: FALLING) } # [doc = "Sense Level (Transparent For Events)"]
# [inline (always)]
pub fn level (self) -> & 'a mut W { self . variant (ISC_A :: LEVEL) } # [doc = "Disable Digital Input Buffer"]
# [inline (always)]
pub fn input_disable (self) -> & 'a mut W { self . variant (ISC_A :: INPUT_DISABLE) } } # [doc = "Field `OPC` reader - Output/Pull Configuration"]
pub type OPC_R = crate :: FieldReader < u8 , OPC_A > ; # [doc = "Output/Pull Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OPC_A { # [doc = "0: Totempole"]
TOTEM = 0 , # [doc = "1: Totempole w/ Bus keeper on Input and Output"]
BUSKEEPER = 1 , # [doc = "2: Totempole w/ Pull-down on Input"]
PULLDOWN = 2 , # [doc = "3: Totempole w/ Pull-up on Input"]
PULLUP = 3 , # [doc = "4: Wired OR"]
WIREDOR = 4 , # [doc = "5: Wired AND"]
WIREDAND = 5 , # [doc = "6: Wired OR w/ Pull-down"]
WIREDORPULL = 6 , # [doc = "7: Wired AND w/ Pull-up"]
WIREDANDPULL = 7 , } impl From < OPC_A > for u8 { # [inline (always)]
fn from (variant : OPC_A) -> Self { variant as _ } } impl OPC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OPC_A { match self . bits { 0 => OPC_A :: TOTEM , 1 => OPC_A :: BUSKEEPER , 2 => OPC_A :: PULLDOWN , 3 => OPC_A :: PULLUP , 4 => OPC_A :: WIREDOR , 5 => OPC_A :: WIREDAND , 6 => OPC_A :: WIREDORPULL , 7 => OPC_A :: WIREDANDPULL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOTEM`"]
# [inline (always)]
pub fn is_totem (& self) -> bool { * self == OPC_A :: TOTEM } # [doc = "Checks if the value of the field is `BUSKEEPER`"]
# [inline (always)]
pub fn is_buskeeper (& self) -> bool { * self == OPC_A :: BUSKEEPER } # [doc = "Checks if the value of the field is `PULLDOWN`"]
# [inline (always)]
pub fn is_pulldown (& self) -> bool { * self == OPC_A :: PULLDOWN } # [doc = "Checks if the value of the field is `PULLUP`"]
# [inline (always)]
pub fn is_pullup (& self) -> bool { * self == OPC_A :: PULLUP } # [doc = "Checks if the value of the field is `WIREDOR`"]
# [inline (always)]
pub fn is_wiredor (& self) -> bool { * self == OPC_A :: WIREDOR } # [doc = "Checks if the value of the field is `WIREDAND`"]
# [inline (always)]
pub fn is_wiredand (& self) -> bool { * self == OPC_A :: WIREDAND } # [doc = "Checks if the value of the field is `WIREDORPULL`"]
# [inline (always)]
pub fn is_wiredorpull (& self) -> bool { * self == OPC_A :: WIREDORPULL } # [doc = "Checks if the value of the field is `WIREDANDPULL`"]
# [inline (always)]
pub fn is_wiredandpull (& self) -> bool { * self == OPC_A :: WIREDANDPULL } } # [doc = "Field `OPC` writer - Output/Pull Configuration"]
pub type OPC_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , PIN7CTRL_SPEC , u8 , OPC_A , 3 , O > ; impl < 'a , const O : u8 > OPC_W < 'a , O > { # [doc = "Totempole"]
# [inline (always)]
pub fn totem (self) -> & 'a mut W { self . variant (OPC_A :: TOTEM) } # [doc = "Totempole w/ Bus keeper on Input and Output"]
# [inline (always)]
pub fn buskeeper (self) -> & 'a mut W { self . variant (OPC_A :: BUSKEEPER) } # [doc = "Totempole w/ Pull-down on Input"]
# [inline (always)]
pub fn pulldown (self) -> & 'a mut W { self . variant (OPC_A :: PULLDOWN) } # [doc = "Totempole w/ Pull-up on Input"]
# [inline (always)]
pub fn pullup (self) -> & 'a mut W { self . variant (OPC_A :: PULLUP) } # [doc = "Wired OR"]
# [inline (always)]
pub fn wiredor (self) -> & 'a mut W { self . variant (OPC_A :: WIREDOR) } # [doc = "Wired AND"]
# [inline (always)]
pub fn wiredand (self) -> & 'a mut W { self . variant (OPC_A :: WIREDAND) } # [doc = "Wired OR w/ Pull-down"]
# [inline (always)]
pub fn wiredorpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDORPULL) } # [doc = "Wired AND w/ Pull-up"]
# [inline (always)]
pub fn wiredandpull (self) -> & 'a mut W { self . variant (OPC_A :: WIREDANDPULL) } } # [doc = "Field `INVEN` reader - Inverted I/O Enable"]
pub type INVEN_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN` writer - Inverted I/O Enable"]
pub type INVEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; # [doc = "Field `SRLEN` reader - Slew Rate Enable"]
pub type SRLEN_R = crate :: BitReader < bool > ; # [doc = "Field `SRLEN` writer - Slew Rate Enable"]
pub type SRLEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PIN7CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
pub fn isc (& self) -> ISC_R { ISC_R :: new (self . bits & 7) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
pub fn opc (& self) -> OPC_R { OPC_R :: new ((self . bits >> 3) & 7) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
pub fn inven (& self) -> INVEN_R { INVEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
pub fn srlen (& self) -> SRLEN_R { SRLEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input/Sense Configuration"]
# [inline (always)]
# [must_use]
pub fn isc (& mut self) -> ISC_W < 0 > { ISC_W :: new (self) } # [doc = "Bits 3:5 - Output/Pull Configuration"]
# [inline (always)]
# [must_use]
pub fn opc (& mut self) -> OPC_W < 3 > { OPC_W :: new (self) } # [doc = "Bit 6 - Inverted I/O Enable"]
# [inline (always)]
# [must_use]
pub fn inven (& mut self) -> INVEN_W < 6 > { INVEN_W :: new (self) } # [doc = "Bit 7 - Slew Rate Enable"]
# [inline (always)]
# [must_use]
pub fn srlen (& mut self) -> SRLEN_W < 7 > { SRLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin 7 Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pin7ctrl](index.html) module"]
pub struct PIN7CTRL_SPEC ; impl crate :: RegisterSpec for PIN7CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pin7ctrl::R](R) reader structure"]
impl crate :: Readable for PIN7CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pin7ctrl::W](W) writer structure"]
impl crate :: Writable for PIN7CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PIN7CTRL to value 0"]
impl crate :: Resettable for PIN7CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct PORT_CFG { _marker : PhantomData < * const () > } unsafe impl Send for PORT_CFG { } impl PORT_CFG { # [doc = r"Pointer to the register block"]
pub const PTR : * const port_cfg :: RegisterBlock = 0xb0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const port_cfg :: RegisterBlock { Self :: PTR } } impl Deref for PORT_CFG { type Target = port_cfg :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORT_CFG { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORT_CFG") . finish () } } # [doc = "Port Configuration"]
pub mod port_cfg { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Multi-pin Configuration Mask"]
pub mpcmask : MPCMASK , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Virtual Port Control Register A"]
pub vpctrla : VPCTRLA , # [doc = "0x03 - Virtual Port Control Register B"]
pub vpctrlb : VPCTRLB , # [doc = "0x04 - Clock and Event Out Register"]
pub clkevout : CLKEVOUT , } # [doc = "CLKEVOUT (rw) register accessor: an alias for `Reg<CLKEVOUT_SPEC>`"]
pub type CLKEVOUT = crate :: Reg < clkevout :: CLKEVOUT_SPEC > ; # [doc = "Clock and Event Out Register"]
pub mod clkevout { # [doc = "Register `CLKEVOUT` reader"]
pub struct R (crate :: R < CLKEVOUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKEVOUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKEVOUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKEVOUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKEVOUT` writer"]
pub struct W (crate :: W < CLKEVOUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKEVOUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKEVOUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKEVOUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKOUT` reader - Clock Output Port"]
pub type CLKOUT_R = crate :: FieldReader < u8 , CLKOUT_A > ; # [doc = "Clock Output Port\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKOUT_A { # [doc = "0: Clock Output Disabled"]
OFF = 0 , # [doc = "1: Clock Output on Port C pin 7"]
PC7 = 1 , # [doc = "2: Clock Output on Port D pin 7"]
PD7 = 2 , # [doc = "3: Clock Output on Port E pin 7"]
PE7 = 3 , } impl From < CLKOUT_A > for u8 { # [inline (always)]
fn from (variant : CLKOUT_A) -> Self { variant as _ } } impl CLKOUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKOUT_A { match self . bits { 0 => CLKOUT_A :: OFF , 1 => CLKOUT_A :: PC7 , 2 => CLKOUT_A :: PD7 , 3 => CLKOUT_A :: PE7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKOUT_A :: OFF } # [doc = "Checks if the value of the field is `PC7`"]
# [inline (always)]
pub fn is_pc7 (& self) -> bool { * self == CLKOUT_A :: PC7 } # [doc = "Checks if the value of the field is `PD7`"]
# [inline (always)]
pub fn is_pd7 (& self) -> bool { * self == CLKOUT_A :: PD7 } # [doc = "Checks if the value of the field is `PE7`"]
# [inline (always)]
pub fn is_pe7 (& self) -> bool { * self == CLKOUT_A :: PE7 } } # [doc = "Field `CLKOUT` writer - Clock Output Port"]
pub type CLKOUT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CLKEVOUT_SPEC , u8 , CLKOUT_A , 2 , O > ; impl < 'a , const O : u8 > CLKOUT_W < 'a , O > { # [doc = "Clock Output Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKOUT_A :: OFF) } # [doc = "Clock Output on Port C pin 7"]
# [inline (always)]
pub fn pc7 (self) -> & 'a mut W { self . variant (CLKOUT_A :: PC7) } # [doc = "Clock Output on Port D pin 7"]
# [inline (always)]
pub fn pd7 (self) -> & 'a mut W { self . variant (CLKOUT_A :: PD7) } # [doc = "Clock Output on Port E pin 7"]
# [inline (always)]
pub fn pe7 (self) -> & 'a mut W { self . variant (CLKOUT_A :: PE7) } } # [doc = "Field `EVOUT` reader - Event Output Port"]
pub type EVOUT_R = crate :: FieldReader < u8 , EVOUT_A > ; # [doc = "Event Output Port\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVOUT_A { # [doc = "0: Event Output Disabled"]
OFF = 0 , # [doc = "1: Event Channel 7 Output on Port C pin 7"]
PC7 = 1 , # [doc = "2: Event Channel 7 Output on Port D pin 7"]
PD7 = 2 , # [doc = "3: Event Channel 7 Output on Port E pin 7"]
PE7 = 3 , } impl From < EVOUT_A > for u8 { # [inline (always)]
fn from (variant : EVOUT_A) -> Self { variant as _ } } impl EVOUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EVOUT_A { match self . bits { 0 => EVOUT_A :: OFF , 1 => EVOUT_A :: PC7 , 2 => EVOUT_A :: PD7 , 3 => EVOUT_A :: PE7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVOUT_A :: OFF } # [doc = "Checks if the value of the field is `PC7`"]
# [inline (always)]
pub fn is_pc7 (& self) -> bool { * self == EVOUT_A :: PC7 } # [doc = "Checks if the value of the field is `PD7`"]
# [inline (always)]
pub fn is_pd7 (& self) -> bool { * self == EVOUT_A :: PD7 } # [doc = "Checks if the value of the field is `PE7`"]
# [inline (always)]
pub fn is_pe7 (& self) -> bool { * self == EVOUT_A :: PE7 } } # [doc = "Field `EVOUT` writer - Event Output Port"]
pub type EVOUT_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CLKEVOUT_SPEC , u8 , EVOUT_A , 2 , O > ; impl < 'a , const O : u8 > EVOUT_W < 'a , O > { # [doc = "Event Output Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVOUT_A :: OFF) } # [doc = "Event Channel 7 Output on Port C pin 7"]
# [inline (always)]
pub fn pc7 (self) -> & 'a mut W { self . variant (EVOUT_A :: PC7) } # [doc = "Event Channel 7 Output on Port D pin 7"]
# [inline (always)]
pub fn pd7 (self) -> & 'a mut W { self . variant (EVOUT_A :: PD7) } # [doc = "Event Channel 7 Output on Port E pin 7"]
# [inline (always)]
pub fn pe7 (self) -> & 'a mut W { self . variant (EVOUT_A :: PE7) } } impl R { # [doc = "Bits 0:1 - Clock Output Port"]
# [inline (always)]
pub fn clkout (& self) -> CLKOUT_R { CLKOUT_R :: new (self . bits & 3) } # [doc = "Bits 4:5 - Event Output Port"]
# [inline (always)]
pub fn evout (& self) -> EVOUT_R { EVOUT_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Clock Output Port"]
# [inline (always)]
# [must_use]
pub fn clkout (& mut self) -> CLKOUT_W < 0 > { CLKOUT_W :: new (self) } # [doc = "Bits 4:5 - Event Output Port"]
# [inline (always)]
# [must_use]
pub fn evout (& mut self) -> EVOUT_W < 4 > { EVOUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock and Event Out Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clkevout](index.html) module"]
pub struct CLKEVOUT_SPEC ; impl crate :: RegisterSpec for CLKEVOUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [clkevout::R](R) reader structure"]
impl crate :: Readable for CLKEVOUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clkevout::W](W) writer structure"]
impl crate :: Writable for CLKEVOUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CLKEVOUT to value 0"]
impl crate :: Resettable for CLKEVOUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "MPCMASK (rw) register accessor: an alias for `Reg<MPCMASK_SPEC>`"]
pub type MPCMASK = crate :: Reg < mpcmask :: MPCMASK_SPEC > ; # [doc = "Multi-pin Configuration Mask"]
pub mod mpcmask { # [doc = "Register `MPCMASK` reader"]
pub struct R (crate :: R < MPCMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MPCMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MPCMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MPCMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `MPCMASK` writer"]
pub struct W (crate :: W < MPCMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MPCMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MPCMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MPCMASK_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Multi-pin Configuration Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mpcmask](index.html) module"]
pub struct MPCMASK_SPEC ; impl crate :: RegisterSpec for MPCMASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mpcmask::R](R) reader structure"]
impl crate :: Readable for MPCMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mpcmask::W](W) writer structure"]
impl crate :: Writable for MPCMASK_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets MPCMASK to value 0"]
impl crate :: Resettable for MPCMASK_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VPCTRLA (rw) register accessor: an alias for `Reg<VPCTRLA_SPEC>`"]
pub type VPCTRLA = crate :: Reg < vpctrla :: VPCTRLA_SPEC > ; # [doc = "Virtual Port Control Register A"]
pub mod vpctrla { # [doc = "Register `VPCTRLA` reader"]
pub struct R (crate :: R < VPCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VPCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VPCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VPCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `VPCTRLA` writer"]
pub struct W (crate :: W < VPCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < VPCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < VPCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < VPCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `VP0MAP` reader - Virtual Port 0 Mapping"]
pub type VP0MAP_R = crate :: FieldReader < u8 , VP0MAP_A > ; # [doc = "Virtual Port 0 Mapping\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VP0MAP_A { # [doc = "0: Mapped To PORTA"]
PORTA = 0 , # [doc = "1: Mapped To PORTB"]
PORTB = 1 , # [doc = "2: Mapped To PORTC"]
PORTC = 2 , # [doc = "3: Mapped To PORTD"]
PORTD = 3 , # [doc = "4: Mapped To PORTE"]
PORTE = 4 , # [doc = "5: Mapped To PORTF"]
PORTF = 5 , # [doc = "6: Mapped To PORTG"]
PORTG = 6 , # [doc = "7: Mapped To PORTH"]
PORTH = 7 , # [doc = "8: Mapped To PORTJ"]
PORTJ = 8 , # [doc = "9: Mapped To PORTK"]
PORTK = 9 , # [doc = "10: Mapped To PORTL"]
PORTL = 10 , # [doc = "11: Mapped To PORTM"]
PORTM = 11 , # [doc = "12: Mapped To PORTN"]
PORTN = 12 , # [doc = "13: Mapped To PORTP"]
PORTP = 13 , # [doc = "14: Mapped To PORTQ"]
PORTQ = 14 , # [doc = "15: Mapped To PORTR"]
PORTR = 15 , } impl From < VP0MAP_A > for u8 { # [inline (always)]
fn from (variant : VP0MAP_A) -> Self { variant as _ } } impl VP0MAP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> VP0MAP_A { match self . bits { 0 => VP0MAP_A :: PORTA , 1 => VP0MAP_A :: PORTB , 2 => VP0MAP_A :: PORTC , 3 => VP0MAP_A :: PORTD , 4 => VP0MAP_A :: PORTE , 5 => VP0MAP_A :: PORTF , 6 => VP0MAP_A :: PORTG , 7 => VP0MAP_A :: PORTH , 8 => VP0MAP_A :: PORTJ , 9 => VP0MAP_A :: PORTK , 10 => VP0MAP_A :: PORTL , 11 => VP0MAP_A :: PORTM , 12 => VP0MAP_A :: PORTN , 13 => VP0MAP_A :: PORTP , 14 => VP0MAP_A :: PORTQ , 15 => VP0MAP_A :: PORTR , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PORTA`"]
# [inline (always)]
pub fn is_porta (& self) -> bool { * self == VP0MAP_A :: PORTA } # [doc = "Checks if the value of the field is `PORTB`"]
# [inline (always)]
pub fn is_portb (& self) -> bool { * self == VP0MAP_A :: PORTB } # [doc = "Checks if the value of the field is `PORTC`"]
# [inline (always)]
pub fn is_portc (& self) -> bool { * self == VP0MAP_A :: PORTC } # [doc = "Checks if the value of the field is `PORTD`"]
# [inline (always)]
pub fn is_portd (& self) -> bool { * self == VP0MAP_A :: PORTD } # [doc = "Checks if the value of the field is `PORTE`"]
# [inline (always)]
pub fn is_porte (& self) -> bool { * self == VP0MAP_A :: PORTE } # [doc = "Checks if the value of the field is `PORTF`"]
# [inline (always)]
pub fn is_portf (& self) -> bool { * self == VP0MAP_A :: PORTF } # [doc = "Checks if the value of the field is `PORTG`"]
# [inline (always)]
pub fn is_portg (& self) -> bool { * self == VP0MAP_A :: PORTG } # [doc = "Checks if the value of the field is `PORTH`"]
# [inline (always)]
pub fn is_porth (& self) -> bool { * self == VP0MAP_A :: PORTH } # [doc = "Checks if the value of the field is `PORTJ`"]
# [inline (always)]
pub fn is_portj (& self) -> bool { * self == VP0MAP_A :: PORTJ } # [doc = "Checks if the value of the field is `PORTK`"]
# [inline (always)]
pub fn is_portk (& self) -> bool { * self == VP0MAP_A :: PORTK } # [doc = "Checks if the value of the field is `PORTL`"]
# [inline (always)]
pub fn is_portl (& self) -> bool { * self == VP0MAP_A :: PORTL } # [doc = "Checks if the value of the field is `PORTM`"]
# [inline (always)]
pub fn is_portm (& self) -> bool { * self == VP0MAP_A :: PORTM } # [doc = "Checks if the value of the field is `PORTN`"]
# [inline (always)]
pub fn is_portn (& self) -> bool { * self == VP0MAP_A :: PORTN } # [doc = "Checks if the value of the field is `PORTP`"]
# [inline (always)]
pub fn is_portp (& self) -> bool { * self == VP0MAP_A :: PORTP } # [doc = "Checks if the value of the field is `PORTQ`"]
# [inline (always)]
pub fn is_portq (& self) -> bool { * self == VP0MAP_A :: PORTQ } # [doc = "Checks if the value of the field is `PORTR`"]
# [inline (always)]
pub fn is_portr (& self) -> bool { * self == VP0MAP_A :: PORTR } } # [doc = "Field `VP0MAP` writer - Virtual Port 0 Mapping"]
pub type VP0MAP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , VPCTRLA_SPEC , u8 , VP0MAP_A , 4 , O > ; impl < 'a , const O : u8 > VP0MAP_W < 'a , O > { # [doc = "Mapped To PORTA"]
# [inline (always)]
pub fn porta (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTA) } # [doc = "Mapped To PORTB"]
# [inline (always)]
pub fn portb (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTB) } # [doc = "Mapped To PORTC"]
# [inline (always)]
pub fn portc (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTC) } # [doc = "Mapped To PORTD"]
# [inline (always)]
pub fn portd (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTD) } # [doc = "Mapped To PORTE"]
# [inline (always)]
pub fn porte (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTE) } # [doc = "Mapped To PORTF"]
# [inline (always)]
pub fn portf (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTF) } # [doc = "Mapped To PORTG"]
# [inline (always)]
pub fn portg (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTG) } # [doc = "Mapped To PORTH"]
# [inline (always)]
pub fn porth (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTH) } # [doc = "Mapped To PORTJ"]
# [inline (always)]
pub fn portj (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTJ) } # [doc = "Mapped To PORTK"]
# [inline (always)]
pub fn portk (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTK) } # [doc = "Mapped To PORTL"]
# [inline (always)]
pub fn portl (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTL) } # [doc = "Mapped To PORTM"]
# [inline (always)]
pub fn portm (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTM) } # [doc = "Mapped To PORTN"]
# [inline (always)]
pub fn portn (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTN) } # [doc = "Mapped To PORTP"]
# [inline (always)]
pub fn portp (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTP) } # [doc = "Mapped To PORTQ"]
# [inline (always)]
pub fn portq (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTQ) } # [doc = "Mapped To PORTR"]
# [inline (always)]
pub fn portr (self) -> & 'a mut W { self . variant (VP0MAP_A :: PORTR) } } # [doc = "Field `VP1MAP` reader - Virtual Port 1 Mapping"]
pub type VP1MAP_R = crate :: FieldReader < u8 , VP1MAP_A > ; # [doc = "Virtual Port 1 Mapping\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VP1MAP_A { # [doc = "0: Mapped To PORTA"]
PORTA = 0 , # [doc = "1: Mapped To PORTB"]
PORTB = 1 , # [doc = "2: Mapped To PORTC"]
PORTC = 2 , # [doc = "3: Mapped To PORTD"]
PORTD = 3 , # [doc = "4: Mapped To PORTE"]
PORTE = 4 , # [doc = "5: Mapped To PORTF"]
PORTF = 5 , # [doc = "6: Mapped To PORTG"]
PORTG = 6 , # [doc = "7: Mapped To PORTH"]
PORTH = 7 , # [doc = "8: Mapped To PORTJ"]
PORTJ = 8 , # [doc = "9: Mapped To PORTK"]
PORTK = 9 , # [doc = "10: Mapped To PORTL"]
PORTL = 10 , # [doc = "11: Mapped To PORTM"]
PORTM = 11 , # [doc = "12: Mapped To PORTN"]
PORTN = 12 , # [doc = "13: Mapped To PORTP"]
PORTP = 13 , # [doc = "14: Mapped To PORTQ"]
PORTQ = 14 , # [doc = "15: Mapped To PORTR"]
PORTR = 15 , } impl From < VP1MAP_A > for u8 { # [inline (always)]
fn from (variant : VP1MAP_A) -> Self { variant as _ } } impl VP1MAP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> VP1MAP_A { match self . bits { 0 => VP1MAP_A :: PORTA , 1 => VP1MAP_A :: PORTB , 2 => VP1MAP_A :: PORTC , 3 => VP1MAP_A :: PORTD , 4 => VP1MAP_A :: PORTE , 5 => VP1MAP_A :: PORTF , 6 => VP1MAP_A :: PORTG , 7 => VP1MAP_A :: PORTH , 8 => VP1MAP_A :: PORTJ , 9 => VP1MAP_A :: PORTK , 10 => VP1MAP_A :: PORTL , 11 => VP1MAP_A :: PORTM , 12 => VP1MAP_A :: PORTN , 13 => VP1MAP_A :: PORTP , 14 => VP1MAP_A :: PORTQ , 15 => VP1MAP_A :: PORTR , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PORTA`"]
# [inline (always)]
pub fn is_porta (& self) -> bool { * self == VP1MAP_A :: PORTA } # [doc = "Checks if the value of the field is `PORTB`"]
# [inline (always)]
pub fn is_portb (& self) -> bool { * self == VP1MAP_A :: PORTB } # [doc = "Checks if the value of the field is `PORTC`"]
# [inline (always)]
pub fn is_portc (& self) -> bool { * self == VP1MAP_A :: PORTC } # [doc = "Checks if the value of the field is `PORTD`"]
# [inline (always)]
pub fn is_portd (& self) -> bool { * self == VP1MAP_A :: PORTD } # [doc = "Checks if the value of the field is `PORTE`"]
# [inline (always)]
pub fn is_porte (& self) -> bool { * self == VP1MAP_A :: PORTE } # [doc = "Checks if the value of the field is `PORTF`"]
# [inline (always)]
pub fn is_portf (& self) -> bool { * self == VP1MAP_A :: PORTF } # [doc = "Checks if the value of the field is `PORTG`"]
# [inline (always)]
pub fn is_portg (& self) -> bool { * self == VP1MAP_A :: PORTG } # [doc = "Checks if the value of the field is `PORTH`"]
# [inline (always)]
pub fn is_porth (& self) -> bool { * self == VP1MAP_A :: PORTH } # [doc = "Checks if the value of the field is `PORTJ`"]
# [inline (always)]
pub fn is_portj (& self) -> bool { * self == VP1MAP_A :: PORTJ } # [doc = "Checks if the value of the field is `PORTK`"]
# [inline (always)]
pub fn is_portk (& self) -> bool { * self == VP1MAP_A :: PORTK } # [doc = "Checks if the value of the field is `PORTL`"]
# [inline (always)]
pub fn is_portl (& self) -> bool { * self == VP1MAP_A :: PORTL } # [doc = "Checks if the value of the field is `PORTM`"]
# [inline (always)]
pub fn is_portm (& self) -> bool { * self == VP1MAP_A :: PORTM } # [doc = "Checks if the value of the field is `PORTN`"]
# [inline (always)]
pub fn is_portn (& self) -> bool { * self == VP1MAP_A :: PORTN } # [doc = "Checks if the value of the field is `PORTP`"]
# [inline (always)]
pub fn is_portp (& self) -> bool { * self == VP1MAP_A :: PORTP } # [doc = "Checks if the value of the field is `PORTQ`"]
# [inline (always)]
pub fn is_portq (& self) -> bool { * self == VP1MAP_A :: PORTQ } # [doc = "Checks if the value of the field is `PORTR`"]
# [inline (always)]
pub fn is_portr (& self) -> bool { * self == VP1MAP_A :: PORTR } } # [doc = "Field `VP1MAP` writer - Virtual Port 1 Mapping"]
pub type VP1MAP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , VPCTRLA_SPEC , u8 , VP1MAP_A , 4 , O > ; impl < 'a , const O : u8 > VP1MAP_W < 'a , O > { # [doc = "Mapped To PORTA"]
# [inline (always)]
pub fn porta (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTA) } # [doc = "Mapped To PORTB"]
# [inline (always)]
pub fn portb (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTB) } # [doc = "Mapped To PORTC"]
# [inline (always)]
pub fn portc (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTC) } # [doc = "Mapped To PORTD"]
# [inline (always)]
pub fn portd (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTD) } # [doc = "Mapped To PORTE"]
# [inline (always)]
pub fn porte (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTE) } # [doc = "Mapped To PORTF"]
# [inline (always)]
pub fn portf (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTF) } # [doc = "Mapped To PORTG"]
# [inline (always)]
pub fn portg (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTG) } # [doc = "Mapped To PORTH"]
# [inline (always)]
pub fn porth (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTH) } # [doc = "Mapped To PORTJ"]
# [inline (always)]
pub fn portj (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTJ) } # [doc = "Mapped To PORTK"]
# [inline (always)]
pub fn portk (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTK) } # [doc = "Mapped To PORTL"]
# [inline (always)]
pub fn portl (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTL) } # [doc = "Mapped To PORTM"]
# [inline (always)]
pub fn portm (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTM) } # [doc = "Mapped To PORTN"]
# [inline (always)]
pub fn portn (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTN) } # [doc = "Mapped To PORTP"]
# [inline (always)]
pub fn portp (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTP) } # [doc = "Mapped To PORTQ"]
# [inline (always)]
pub fn portq (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTQ) } # [doc = "Mapped To PORTR"]
# [inline (always)]
pub fn portr (self) -> & 'a mut W { self . variant (VP1MAP_A :: PORTR) } } impl R { # [doc = "Bits 0:3 - Virtual Port 0 Mapping"]
# [inline (always)]
pub fn vp0map (& self) -> VP0MAP_R { VP0MAP_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Virtual Port 1 Mapping"]
# [inline (always)]
pub fn vp1map (& self) -> VP1MAP_R { VP1MAP_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Virtual Port 0 Mapping"]
# [inline (always)]
# [must_use]
pub fn vp0map (& mut self) -> VP0MAP_W < 0 > { VP0MAP_W :: new (self) } # [doc = "Bits 4:7 - Virtual Port 1 Mapping"]
# [inline (always)]
# [must_use]
pub fn vp1map (& mut self) -> VP1MAP_W < 4 > { VP1MAP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Virtual Port Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vpctrla](index.html) module"]
pub struct VPCTRLA_SPEC ; impl crate :: RegisterSpec for VPCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [vpctrla::R](R) reader structure"]
impl crate :: Readable for VPCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [vpctrla::W](W) writer structure"]
impl crate :: Writable for VPCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VPCTRLA to value 0"]
impl crate :: Resettable for VPCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "VPCTRLB (rw) register accessor: an alias for `Reg<VPCTRLB_SPEC>`"]
pub type VPCTRLB = crate :: Reg < vpctrlb :: VPCTRLB_SPEC > ; # [doc = "Virtual Port Control Register B"]
pub mod vpctrlb { # [doc = "Register `VPCTRLB` reader"]
pub struct R (crate :: R < VPCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VPCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VPCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VPCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `VPCTRLB` writer"]
pub struct W (crate :: W < VPCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < VPCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < VPCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < VPCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `VP2MAP` reader - Virtual Port 2 Mapping"]
pub type VP2MAP_R = crate :: FieldReader < u8 , VP2MAP_A > ; # [doc = "Virtual Port 2 Mapping\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VP2MAP_A { # [doc = "0: Mapped To PORTA"]
PORTA = 0 , # [doc = "1: Mapped To PORTB"]
PORTB = 1 , # [doc = "2: Mapped To PORTC"]
PORTC = 2 , # [doc = "3: Mapped To PORTD"]
PORTD = 3 , # [doc = "4: Mapped To PORTE"]
PORTE = 4 , # [doc = "5: Mapped To PORTF"]
PORTF = 5 , # [doc = "6: Mapped To PORTG"]
PORTG = 6 , # [doc = "7: Mapped To PORTH"]
PORTH = 7 , # [doc = "8: Mapped To PORTJ"]
PORTJ = 8 , # [doc = "9: Mapped To PORTK"]
PORTK = 9 , # [doc = "10: Mapped To PORTL"]
PORTL = 10 , # [doc = "11: Mapped To PORTM"]
PORTM = 11 , # [doc = "12: Mapped To PORTN"]
PORTN = 12 , # [doc = "13: Mapped To PORTP"]
PORTP = 13 , # [doc = "14: Mapped To PORTQ"]
PORTQ = 14 , # [doc = "15: Mapped To PORTR"]
PORTR = 15 , } impl From < VP2MAP_A > for u8 { # [inline (always)]
fn from (variant : VP2MAP_A) -> Self { variant as _ } } impl VP2MAP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> VP2MAP_A { match self . bits { 0 => VP2MAP_A :: PORTA , 1 => VP2MAP_A :: PORTB , 2 => VP2MAP_A :: PORTC , 3 => VP2MAP_A :: PORTD , 4 => VP2MAP_A :: PORTE , 5 => VP2MAP_A :: PORTF , 6 => VP2MAP_A :: PORTG , 7 => VP2MAP_A :: PORTH , 8 => VP2MAP_A :: PORTJ , 9 => VP2MAP_A :: PORTK , 10 => VP2MAP_A :: PORTL , 11 => VP2MAP_A :: PORTM , 12 => VP2MAP_A :: PORTN , 13 => VP2MAP_A :: PORTP , 14 => VP2MAP_A :: PORTQ , 15 => VP2MAP_A :: PORTR , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PORTA`"]
# [inline (always)]
pub fn is_porta (& self) -> bool { * self == VP2MAP_A :: PORTA } # [doc = "Checks if the value of the field is `PORTB`"]
# [inline (always)]
pub fn is_portb (& self) -> bool { * self == VP2MAP_A :: PORTB } # [doc = "Checks if the value of the field is `PORTC`"]
# [inline (always)]
pub fn is_portc (& self) -> bool { * self == VP2MAP_A :: PORTC } # [doc = "Checks if the value of the field is `PORTD`"]
# [inline (always)]
pub fn is_portd (& self) -> bool { * self == VP2MAP_A :: PORTD } # [doc = "Checks if the value of the field is `PORTE`"]
# [inline (always)]
pub fn is_porte (& self) -> bool { * self == VP2MAP_A :: PORTE } # [doc = "Checks if the value of the field is `PORTF`"]
# [inline (always)]
pub fn is_portf (& self) -> bool { * self == VP2MAP_A :: PORTF } # [doc = "Checks if the value of the field is `PORTG`"]
# [inline (always)]
pub fn is_portg (& self) -> bool { * self == VP2MAP_A :: PORTG } # [doc = "Checks if the value of the field is `PORTH`"]
# [inline (always)]
pub fn is_porth (& self) -> bool { * self == VP2MAP_A :: PORTH } # [doc = "Checks if the value of the field is `PORTJ`"]
# [inline (always)]
pub fn is_portj (& self) -> bool { * self == VP2MAP_A :: PORTJ } # [doc = "Checks if the value of the field is `PORTK`"]
# [inline (always)]
pub fn is_portk (& self) -> bool { * self == VP2MAP_A :: PORTK } # [doc = "Checks if the value of the field is `PORTL`"]
# [inline (always)]
pub fn is_portl (& self) -> bool { * self == VP2MAP_A :: PORTL } # [doc = "Checks if the value of the field is `PORTM`"]
# [inline (always)]
pub fn is_portm (& self) -> bool { * self == VP2MAP_A :: PORTM } # [doc = "Checks if the value of the field is `PORTN`"]
# [inline (always)]
pub fn is_portn (& self) -> bool { * self == VP2MAP_A :: PORTN } # [doc = "Checks if the value of the field is `PORTP`"]
# [inline (always)]
pub fn is_portp (& self) -> bool { * self == VP2MAP_A :: PORTP } # [doc = "Checks if the value of the field is `PORTQ`"]
# [inline (always)]
pub fn is_portq (& self) -> bool { * self == VP2MAP_A :: PORTQ } # [doc = "Checks if the value of the field is `PORTR`"]
# [inline (always)]
pub fn is_portr (& self) -> bool { * self == VP2MAP_A :: PORTR } } # [doc = "Field `VP2MAP` writer - Virtual Port 2 Mapping"]
pub type VP2MAP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , VPCTRLB_SPEC , u8 , VP2MAP_A , 4 , O > ; impl < 'a , const O : u8 > VP2MAP_W < 'a , O > { # [doc = "Mapped To PORTA"]
# [inline (always)]
pub fn porta (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTA) } # [doc = "Mapped To PORTB"]
# [inline (always)]
pub fn portb (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTB) } # [doc = "Mapped To PORTC"]
# [inline (always)]
pub fn portc (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTC) } # [doc = "Mapped To PORTD"]
# [inline (always)]
pub fn portd (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTD) } # [doc = "Mapped To PORTE"]
# [inline (always)]
pub fn porte (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTE) } # [doc = "Mapped To PORTF"]
# [inline (always)]
pub fn portf (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTF) } # [doc = "Mapped To PORTG"]
# [inline (always)]
pub fn portg (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTG) } # [doc = "Mapped To PORTH"]
# [inline (always)]
pub fn porth (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTH) } # [doc = "Mapped To PORTJ"]
# [inline (always)]
pub fn portj (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTJ) } # [doc = "Mapped To PORTK"]
# [inline (always)]
pub fn portk (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTK) } # [doc = "Mapped To PORTL"]
# [inline (always)]
pub fn portl (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTL) } # [doc = "Mapped To PORTM"]
# [inline (always)]
pub fn portm (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTM) } # [doc = "Mapped To PORTN"]
# [inline (always)]
pub fn portn (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTN) } # [doc = "Mapped To PORTP"]
# [inline (always)]
pub fn portp (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTP) } # [doc = "Mapped To PORTQ"]
# [inline (always)]
pub fn portq (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTQ) } # [doc = "Mapped To PORTR"]
# [inline (always)]
pub fn portr (self) -> & 'a mut W { self . variant (VP2MAP_A :: PORTR) } } # [doc = "Field `VP3MAP` reader - Virtual Port 3 Mapping"]
pub type VP3MAP_R = crate :: FieldReader < u8 , VP3MAP_A > ; # [doc = "Virtual Port 3 Mapping\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum VP3MAP_A { # [doc = "0: Mapped To PORTA"]
PORTA = 0 , # [doc = "1: Mapped To PORTB"]
PORTB = 1 , # [doc = "2: Mapped To PORTC"]
PORTC = 2 , # [doc = "3: Mapped To PORTD"]
PORTD = 3 , # [doc = "4: Mapped To PORTE"]
PORTE = 4 , # [doc = "5: Mapped To PORTF"]
PORTF = 5 , # [doc = "6: Mapped To PORTG"]
PORTG = 6 , # [doc = "7: Mapped To PORTH"]
PORTH = 7 , # [doc = "8: Mapped To PORTJ"]
PORTJ = 8 , # [doc = "9: Mapped To PORTK"]
PORTK = 9 , # [doc = "10: Mapped To PORTL"]
PORTL = 10 , # [doc = "11: Mapped To PORTM"]
PORTM = 11 , # [doc = "12: Mapped To PORTN"]
PORTN = 12 , # [doc = "13: Mapped To PORTP"]
PORTP = 13 , # [doc = "14: Mapped To PORTQ"]
PORTQ = 14 , # [doc = "15: Mapped To PORTR"]
PORTR = 15 , } impl From < VP3MAP_A > for u8 { # [inline (always)]
fn from (variant : VP3MAP_A) -> Self { variant as _ } } impl VP3MAP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> VP3MAP_A { match self . bits { 0 => VP3MAP_A :: PORTA , 1 => VP3MAP_A :: PORTB , 2 => VP3MAP_A :: PORTC , 3 => VP3MAP_A :: PORTD , 4 => VP3MAP_A :: PORTE , 5 => VP3MAP_A :: PORTF , 6 => VP3MAP_A :: PORTG , 7 => VP3MAP_A :: PORTH , 8 => VP3MAP_A :: PORTJ , 9 => VP3MAP_A :: PORTK , 10 => VP3MAP_A :: PORTL , 11 => VP3MAP_A :: PORTM , 12 => VP3MAP_A :: PORTN , 13 => VP3MAP_A :: PORTP , 14 => VP3MAP_A :: PORTQ , 15 => VP3MAP_A :: PORTR , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PORTA`"]
# [inline (always)]
pub fn is_porta (& self) -> bool { * self == VP3MAP_A :: PORTA } # [doc = "Checks if the value of the field is `PORTB`"]
# [inline (always)]
pub fn is_portb (& self) -> bool { * self == VP3MAP_A :: PORTB } # [doc = "Checks if the value of the field is `PORTC`"]
# [inline (always)]
pub fn is_portc (& self) -> bool { * self == VP3MAP_A :: PORTC } # [doc = "Checks if the value of the field is `PORTD`"]
# [inline (always)]
pub fn is_portd (& self) -> bool { * self == VP3MAP_A :: PORTD } # [doc = "Checks if the value of the field is `PORTE`"]
# [inline (always)]
pub fn is_porte (& self) -> bool { * self == VP3MAP_A :: PORTE } # [doc = "Checks if the value of the field is `PORTF`"]
# [inline (always)]
pub fn is_portf (& self) -> bool { * self == VP3MAP_A :: PORTF } # [doc = "Checks if the value of the field is `PORTG`"]
# [inline (always)]
pub fn is_portg (& self) -> bool { * self == VP3MAP_A :: PORTG } # [doc = "Checks if the value of the field is `PORTH`"]
# [inline (always)]
pub fn is_porth (& self) -> bool { * self == VP3MAP_A :: PORTH } # [doc = "Checks if the value of the field is `PORTJ`"]
# [inline (always)]
pub fn is_portj (& self) -> bool { * self == VP3MAP_A :: PORTJ } # [doc = "Checks if the value of the field is `PORTK`"]
# [inline (always)]
pub fn is_portk (& self) -> bool { * self == VP3MAP_A :: PORTK } # [doc = "Checks if the value of the field is `PORTL`"]
# [inline (always)]
pub fn is_portl (& self) -> bool { * self == VP3MAP_A :: PORTL } # [doc = "Checks if the value of the field is `PORTM`"]
# [inline (always)]
pub fn is_portm (& self) -> bool { * self == VP3MAP_A :: PORTM } # [doc = "Checks if the value of the field is `PORTN`"]
# [inline (always)]
pub fn is_portn (& self) -> bool { * self == VP3MAP_A :: PORTN } # [doc = "Checks if the value of the field is `PORTP`"]
# [inline (always)]
pub fn is_portp (& self) -> bool { * self == VP3MAP_A :: PORTP } # [doc = "Checks if the value of the field is `PORTQ`"]
# [inline (always)]
pub fn is_portq (& self) -> bool { * self == VP3MAP_A :: PORTQ } # [doc = "Checks if the value of the field is `PORTR`"]
# [inline (always)]
pub fn is_portr (& self) -> bool { * self == VP3MAP_A :: PORTR } } # [doc = "Field `VP3MAP` writer - Virtual Port 3 Mapping"]
pub type VP3MAP_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , VPCTRLB_SPEC , u8 , VP3MAP_A , 4 , O > ; impl < 'a , const O : u8 > VP3MAP_W < 'a , O > { # [doc = "Mapped To PORTA"]
# [inline (always)]
pub fn porta (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTA) } # [doc = "Mapped To PORTB"]
# [inline (always)]
pub fn portb (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTB) } # [doc = "Mapped To PORTC"]
# [inline (always)]
pub fn portc (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTC) } # [doc = "Mapped To PORTD"]
# [inline (always)]
pub fn portd (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTD) } # [doc = "Mapped To PORTE"]
# [inline (always)]
pub fn porte (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTE) } # [doc = "Mapped To PORTF"]
# [inline (always)]
pub fn portf (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTF) } # [doc = "Mapped To PORTG"]
# [inline (always)]
pub fn portg (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTG) } # [doc = "Mapped To PORTH"]
# [inline (always)]
pub fn porth (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTH) } # [doc = "Mapped To PORTJ"]
# [inline (always)]
pub fn portj (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTJ) } # [doc = "Mapped To PORTK"]
# [inline (always)]
pub fn portk (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTK) } # [doc = "Mapped To PORTL"]
# [inline (always)]
pub fn portl (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTL) } # [doc = "Mapped To PORTM"]
# [inline (always)]
pub fn portm (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTM) } # [doc = "Mapped To PORTN"]
# [inline (always)]
pub fn portn (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTN) } # [doc = "Mapped To PORTP"]
# [inline (always)]
pub fn portp (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTP) } # [doc = "Mapped To PORTQ"]
# [inline (always)]
pub fn portq (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTQ) } # [doc = "Mapped To PORTR"]
# [inline (always)]
pub fn portr (self) -> & 'a mut W { self . variant (VP3MAP_A :: PORTR) } } impl R { # [doc = "Bits 0:3 - Virtual Port 2 Mapping"]
# [inline (always)]
pub fn vp2map (& self) -> VP2MAP_R { VP2MAP_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Virtual Port 3 Mapping"]
# [inline (always)]
pub fn vp3map (& self) -> VP3MAP_R { VP3MAP_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Virtual Port 2 Mapping"]
# [inline (always)]
# [must_use]
pub fn vp2map (& mut self) -> VP2MAP_W < 0 > { VP2MAP_W :: new (self) } # [doc = "Bits 4:7 - Virtual Port 3 Mapping"]
# [inline (always)]
# [must_use]
pub fn vp3map (& mut self) -> VP3MAP_W < 4 > { VP3MAP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Virtual Port Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vpctrlb](index.html) module"]
pub struct VPCTRLB_SPEC ; impl crate :: RegisterSpec for VPCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [vpctrlb::R](R) reader structure"]
impl crate :: Readable for VPCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [vpctrlb::W](W) writer structure"]
impl crate :: Writable for VPCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets VPCTRLB to value 0"]
impl crate :: Resettable for VPCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Clock System"]
pub struct PR { _marker : PhantomData < * const () > } unsafe impl Send for PR { } impl PR { # [doc = r"Pointer to the register block"]
pub const PTR : * const pr :: RegisterBlock = 0x70 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pr :: RegisterBlock { Self :: PTR } } impl Deref for PR { type Target = pr :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PR { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PR") . finish () } } # [doc = "Clock System"]
pub mod pr { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - General Power Reduction"]
pub prgen : PRGEN , # [doc = "0x01 - Power Reduction Port A"]
pub prpa : PRPA , # [doc = "0x02 - Power Reduction Port B"]
pub prpb : PRPB , # [doc = "0x03 - Power Reduction Port C"]
pub prpc : PRPC , # [doc = "0x04 - Power Reduction Port D"]
pub prpd : PRPD , # [doc = "0x05 - Power Reduction Port E"]
pub prpe : PRPE , # [doc = "0x06 - Power Reduction Port F"]
pub prpf : PRPF , } # [doc = "PRGEN (rw) register accessor: an alias for `Reg<PRGEN_SPEC>`"]
pub type PRGEN = crate :: Reg < prgen :: PRGEN_SPEC > ; # [doc = "General Power Reduction"]
pub mod prgen { # [doc = "Register `PRGEN` reader"]
pub struct R (crate :: R < PRGEN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRGEN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRGEN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRGEN_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRGEN` writer"]
pub struct W (crate :: W < PRGEN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRGEN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRGEN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRGEN_SPEC >) -> Self { W (writer) } } # [doc = "Field `DMA` reader - DMA-Controller"]
pub type DMA_R = crate :: BitReader < bool > ; # [doc = "Field `DMA` writer - DMA-Controller"]
pub type DMA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRGEN_SPEC , bool , O > ; # [doc = "Field `EVSYS` reader - Event System"]
pub type EVSYS_R = crate :: BitReader < bool > ; # [doc = "Field `EVSYS` writer - Event System"]
pub type EVSYS_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRGEN_SPEC , bool , O > ; # [doc = "Field `RTC` reader - Real-time Counter"]
pub type RTC_R = crate :: BitReader < bool > ; # [doc = "Field `RTC` writer - Real-time Counter"]
pub type RTC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRGEN_SPEC , bool , O > ; # [doc = "Field `EBI` reader - External Bus Interface"]
pub type EBI_R = crate :: BitReader < bool > ; # [doc = "Field `EBI` writer - External Bus Interface"]
pub type EBI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRGEN_SPEC , bool , O > ; # [doc = "Field `AES` reader - AES"]
pub type AES_R = crate :: BitReader < bool > ; # [doc = "Field `AES` writer - AES"]
pub type AES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRGEN_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - DMA-Controller"]
# [inline (always)]
pub fn dma (& self) -> DMA_R { DMA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Event System"]
# [inline (always)]
pub fn evsys (& self) -> EVSYS_R { EVSYS_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Real-time Counter"]
# [inline (always)]
pub fn rtc (& self) -> RTC_R { RTC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - External Bus Interface"]
# [inline (always)]
pub fn ebi (& self) -> EBI_R { EBI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - AES"]
# [inline (always)]
pub fn aes (& self) -> AES_R { AES_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - DMA-Controller"]
# [inline (always)]
# [must_use]
pub fn dma (& mut self) -> DMA_W < 0 > { DMA_W :: new (self) } # [doc = "Bit 1 - Event System"]
# [inline (always)]
# [must_use]
pub fn evsys (& mut self) -> EVSYS_W < 1 > { EVSYS_W :: new (self) } # [doc = "Bit 2 - Real-time Counter"]
# [inline (always)]
# [must_use]
pub fn rtc (& mut self) -> RTC_W < 2 > { RTC_W :: new (self) } # [doc = "Bit 3 - External Bus Interface"]
# [inline (always)]
# [must_use]
pub fn ebi (& mut self) -> EBI_W < 3 > { EBI_W :: new (self) } # [doc = "Bit 4 - AES"]
# [inline (always)]
# [must_use]
pub fn aes (& mut self) -> AES_W < 4 > { AES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "General Power Reduction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prgen](index.html) module"]
pub struct PRGEN_SPEC ; impl crate :: RegisterSpec for PRGEN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prgen::R](R) reader structure"]
impl crate :: Readable for PRGEN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prgen::W](W) writer structure"]
impl crate :: Writable for PRGEN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRGEN to value 0"]
impl crate :: Resettable for PRGEN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRPA (rw) register accessor: an alias for `Reg<PRPA_SPEC>`"]
pub type PRPA = crate :: Reg < prpa :: PRPA_SPEC > ; # [doc = "Power Reduction Port A"]
pub mod prpa { # [doc = "Register `PRPA` reader"]
pub struct R (crate :: R < PRPA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRPA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRPA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRPA_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRPA` writer"]
pub struct W (crate :: W < PRPA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRPA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRPA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRPA_SPEC >) -> Self { W (writer) } } # [doc = "Field `AC` reader - Port A Analog Comparator"]
pub type AC_R = crate :: BitReader < bool > ; # [doc = "Field `AC` writer - Port A Analog Comparator"]
pub type AC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPA_SPEC , bool , O > ; # [doc = "Field `ADC` reader - Port A ADC"]
pub type ADC_R = crate :: BitReader < bool > ; # [doc = "Field `ADC` writer - Port A ADC"]
pub type ADC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPA_SPEC , bool , O > ; # [doc = "Field `DAC` reader - Port A DAC"]
pub type DAC_R = crate :: BitReader < bool > ; # [doc = "Field `DAC` writer - Port A DAC"]
pub type DAC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPA_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port A Analog Comparator"]
# [inline (always)]
pub fn ac (& self) -> AC_R { AC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port A ADC"]
# [inline (always)]
pub fn adc (& self) -> ADC_R { ADC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Port A DAC"]
# [inline (always)]
pub fn dac (& self) -> DAC_R { DAC_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port A Analog Comparator"]
# [inline (always)]
# [must_use]
pub fn ac (& mut self) -> AC_W < 0 > { AC_W :: new (self) } # [doc = "Bit 1 - Port A ADC"]
# [inline (always)]
# [must_use]
pub fn adc (& mut self) -> ADC_W < 1 > { ADC_W :: new (self) } # [doc = "Bit 2 - Port A DAC"]
# [inline (always)]
# [must_use]
pub fn dac (& mut self) -> DAC_W < 2 > { DAC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Port A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prpa](index.html) module"]
pub struct PRPA_SPEC ; impl crate :: RegisterSpec for PRPA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prpa::R](R) reader structure"]
impl crate :: Readable for PRPA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prpa::W](W) writer structure"]
impl crate :: Writable for PRPA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRPA to value 0"]
impl crate :: Resettable for PRPA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRPB (rw) register accessor: an alias for `Reg<PRPB_SPEC>`"]
pub type PRPB = crate :: Reg < prpb :: PRPB_SPEC > ; # [doc = "Power Reduction Port B"]
pub mod prpb { # [doc = "Register `PRPB` reader"]
pub struct R (crate :: R < PRPB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRPB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRPB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRPB_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRPB` writer"]
pub struct W (crate :: W < PRPB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRPB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRPB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRPB_SPEC >) -> Self { W (writer) } } # [doc = "Field `AC` reader - Port B Analog Comparator"]
pub type AC_R = crate :: BitReader < bool > ; # [doc = "Field `AC` writer - Port B Analog Comparator"]
pub type AC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPB_SPEC , bool , O > ; # [doc = "Field `ADC` reader - Port B ADC"]
pub type ADC_R = crate :: BitReader < bool > ; # [doc = "Field `ADC` writer - Port B ADC"]
pub type ADC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPB_SPEC , bool , O > ; # [doc = "Field `DAC` reader - Port B DAC"]
pub type DAC_R = crate :: BitReader < bool > ; # [doc = "Field `DAC` writer - Port B DAC"]
pub type DAC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port B Analog Comparator"]
# [inline (always)]
pub fn ac (& self) -> AC_R { AC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port B ADC"]
# [inline (always)]
pub fn adc (& self) -> ADC_R { ADC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Port B DAC"]
# [inline (always)]
pub fn dac (& self) -> DAC_R { DAC_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port B Analog Comparator"]
# [inline (always)]
# [must_use]
pub fn ac (& mut self) -> AC_W < 0 > { AC_W :: new (self) } # [doc = "Bit 1 - Port B ADC"]
# [inline (always)]
# [must_use]
pub fn adc (& mut self) -> ADC_W < 1 > { ADC_W :: new (self) } # [doc = "Bit 2 - Port B DAC"]
# [inline (always)]
# [must_use]
pub fn dac (& mut self) -> DAC_W < 2 > { DAC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Port B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prpb](index.html) module"]
pub struct PRPB_SPEC ; impl crate :: RegisterSpec for PRPB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prpb::R](R) reader structure"]
impl crate :: Readable for PRPB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prpb::W](W) writer structure"]
impl crate :: Writable for PRPB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRPB to value 0"]
impl crate :: Resettable for PRPB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRPC (rw) register accessor: an alias for `Reg<PRPC_SPEC>`"]
pub type PRPC = crate :: Reg < prpc :: PRPC_SPEC > ; # [doc = "Power Reduction Port C"]
pub mod prpc { # [doc = "Register `PRPC` reader"]
pub struct R (crate :: R < PRPC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRPC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRPC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRPC_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRPC` writer"]
pub struct W (crate :: W < PRPC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRPC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRPC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRPC_SPEC >) -> Self { W (writer) } } # [doc = "Field `TC0` reader - Port C Timer/Counter0"]
pub type TC0_R = crate :: BitReader < bool > ; # [doc = "Field `TC0` writer - Port C Timer/Counter0"]
pub type TC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPC_SPEC , bool , O > ; # [doc = "Field `TC1` reader - Port C Timer/Counter1"]
pub type TC1_R = crate :: BitReader < bool > ; # [doc = "Field `TC1` writer - Port C Timer/Counter1"]
pub type TC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPC_SPEC , bool , O > ; # [doc = "Field `HIRES` reader - Port C AWEX"]
pub type HIRES_R = crate :: BitReader < bool > ; # [doc = "Field `HIRES` writer - Port C AWEX"]
pub type HIRES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPC_SPEC , bool , O > ; # [doc = "Field `SPI` reader - Port C SPI"]
pub type SPI_R = crate :: BitReader < bool > ; # [doc = "Field `SPI` writer - Port C SPI"]
pub type SPI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPC_SPEC , bool , O > ; # [doc = "Field `USART0` reader - Port C USART0"]
pub type USART0_R = crate :: BitReader < bool > ; # [doc = "Field `USART0` writer - Port C USART0"]
pub type USART0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPC_SPEC , bool , O > ; # [doc = "Field `USART1` reader - Port C USART1"]
pub type USART1_R = crate :: BitReader < bool > ; # [doc = "Field `USART1` writer - Port C USART1"]
pub type USART1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPC_SPEC , bool , O > ; # [doc = "Field `TWI` reader - Port C Two-wire Interface"]
pub type TWI_R = crate :: BitReader < bool > ; # [doc = "Field `TWI` writer - Port C Two-wire Interface"]
pub type TWI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port C Timer/Counter0"]
# [inline (always)]
pub fn tc0 (& self) -> TC0_R { TC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port C Timer/Counter1"]
# [inline (always)]
pub fn tc1 (& self) -> TC1_R { TC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Port C AWEX"]
# [inline (always)]
pub fn hires (& self) -> HIRES_R { HIRES_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Port C SPI"]
# [inline (always)]
pub fn spi (& self) -> SPI_R { SPI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Port C USART0"]
# [inline (always)]
pub fn usart0 (& self) -> USART0_R { USART0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Port C USART1"]
# [inline (always)]
pub fn usart1 (& self) -> USART1_R { USART1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Port C Two-wire Interface"]
# [inline (always)]
pub fn twi (& self) -> TWI_R { TWI_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port C Timer/Counter0"]
# [inline (always)]
# [must_use]
pub fn tc0 (& mut self) -> TC0_W < 0 > { TC0_W :: new (self) } # [doc = "Bit 1 - Port C Timer/Counter1"]
# [inline (always)]
# [must_use]
pub fn tc1 (& mut self) -> TC1_W < 1 > { TC1_W :: new (self) } # [doc = "Bit 2 - Port C AWEX"]
# [inline (always)]
# [must_use]
pub fn hires (& mut self) -> HIRES_W < 2 > { HIRES_W :: new (self) } # [doc = "Bit 3 - Port C SPI"]
# [inline (always)]
# [must_use]
pub fn spi (& mut self) -> SPI_W < 3 > { SPI_W :: new (self) } # [doc = "Bit 4 - Port C USART0"]
# [inline (always)]
# [must_use]
pub fn usart0 (& mut self) -> USART0_W < 4 > { USART0_W :: new (self) } # [doc = "Bit 5 - Port C USART1"]
# [inline (always)]
# [must_use]
pub fn usart1 (& mut self) -> USART1_W < 5 > { USART1_W :: new (self) } # [doc = "Bit 6 - Port C Two-wire Interface"]
# [inline (always)]
# [must_use]
pub fn twi (& mut self) -> TWI_W < 6 > { TWI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Port C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prpc](index.html) module"]
pub struct PRPC_SPEC ; impl crate :: RegisterSpec for PRPC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prpc::R](R) reader structure"]
impl crate :: Readable for PRPC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prpc::W](W) writer structure"]
impl crate :: Writable for PRPC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRPC to value 0"]
impl crate :: Resettable for PRPC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRPD (rw) register accessor: an alias for `Reg<PRPD_SPEC>`"]
pub type PRPD = crate :: Reg < prpd :: PRPD_SPEC > ; # [doc = "Power Reduction Port D"]
pub mod prpd { # [doc = "Register `PRPD` reader"]
pub struct R (crate :: R < PRPD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRPD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRPD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRPD_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRPD` writer"]
pub struct W (crate :: W < PRPD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRPD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRPD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRPD_SPEC >) -> Self { W (writer) } } # [doc = "Field `TC0` reader - Port D Timer/Counter0"]
pub type TC0_R = crate :: BitReader < bool > ; # [doc = "Field `TC0` writer - Port D Timer/Counter0"]
pub type TC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPD_SPEC , bool , O > ; # [doc = "Field `TC1` reader - Port D Timer/Counter1"]
pub type TC1_R = crate :: BitReader < bool > ; # [doc = "Field `TC1` writer - Port D Timer/Counter1"]
pub type TC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPD_SPEC , bool , O > ; # [doc = "Field `HIRES` reader - Port D AWEX"]
pub type HIRES_R = crate :: BitReader < bool > ; # [doc = "Field `HIRES` writer - Port D AWEX"]
pub type HIRES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPD_SPEC , bool , O > ; # [doc = "Field `SPI` reader - Port D SPI"]
pub type SPI_R = crate :: BitReader < bool > ; # [doc = "Field `SPI` writer - Port D SPI"]
pub type SPI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPD_SPEC , bool , O > ; # [doc = "Field `USART0` reader - Port D USART0"]
pub type USART0_R = crate :: BitReader < bool > ; # [doc = "Field `USART0` writer - Port D USART0"]
pub type USART0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPD_SPEC , bool , O > ; # [doc = "Field `USART1` reader - Port D USART1"]
pub type USART1_R = crate :: BitReader < bool > ; # [doc = "Field `USART1` writer - Port D USART1"]
pub type USART1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPD_SPEC , bool , O > ; # [doc = "Field `TWI` reader - Port D Two-wire Interface"]
pub type TWI_R = crate :: BitReader < bool > ; # [doc = "Field `TWI` writer - Port D Two-wire Interface"]
pub type TWI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPD_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port D Timer/Counter0"]
# [inline (always)]
pub fn tc0 (& self) -> TC0_R { TC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port D Timer/Counter1"]
# [inline (always)]
pub fn tc1 (& self) -> TC1_R { TC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Port D AWEX"]
# [inline (always)]
pub fn hires (& self) -> HIRES_R { HIRES_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Port D SPI"]
# [inline (always)]
pub fn spi (& self) -> SPI_R { SPI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Port D USART0"]
# [inline (always)]
pub fn usart0 (& self) -> USART0_R { USART0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Port D USART1"]
# [inline (always)]
pub fn usart1 (& self) -> USART1_R { USART1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Port D Two-wire Interface"]
# [inline (always)]
pub fn twi (& self) -> TWI_R { TWI_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port D Timer/Counter0"]
# [inline (always)]
# [must_use]
pub fn tc0 (& mut self) -> TC0_W < 0 > { TC0_W :: new (self) } # [doc = "Bit 1 - Port D Timer/Counter1"]
# [inline (always)]
# [must_use]
pub fn tc1 (& mut self) -> TC1_W < 1 > { TC1_W :: new (self) } # [doc = "Bit 2 - Port D AWEX"]
# [inline (always)]
# [must_use]
pub fn hires (& mut self) -> HIRES_W < 2 > { HIRES_W :: new (self) } # [doc = "Bit 3 - Port D SPI"]
# [inline (always)]
# [must_use]
pub fn spi (& mut self) -> SPI_W < 3 > { SPI_W :: new (self) } # [doc = "Bit 4 - Port D USART0"]
# [inline (always)]
# [must_use]
pub fn usart0 (& mut self) -> USART0_W < 4 > { USART0_W :: new (self) } # [doc = "Bit 5 - Port D USART1"]
# [inline (always)]
# [must_use]
pub fn usart1 (& mut self) -> USART1_W < 5 > { USART1_W :: new (self) } # [doc = "Bit 6 - Port D Two-wire Interface"]
# [inline (always)]
# [must_use]
pub fn twi (& mut self) -> TWI_W < 6 > { TWI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Port D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prpd](index.html) module"]
pub struct PRPD_SPEC ; impl crate :: RegisterSpec for PRPD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prpd::R](R) reader structure"]
impl crate :: Readable for PRPD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prpd::W](W) writer structure"]
impl crate :: Writable for PRPD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRPD to value 0"]
impl crate :: Resettable for PRPD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRPE (rw) register accessor: an alias for `Reg<PRPE_SPEC>`"]
pub type PRPE = crate :: Reg < prpe :: PRPE_SPEC > ; # [doc = "Power Reduction Port E"]
pub mod prpe { # [doc = "Register `PRPE` reader"]
pub struct R (crate :: R < PRPE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRPE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRPE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRPE_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRPE` writer"]
pub struct W (crate :: W < PRPE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRPE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRPE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRPE_SPEC >) -> Self { W (writer) } } # [doc = "Field `TC0` reader - Port E Timer/Counter0"]
pub type TC0_R = crate :: BitReader < bool > ; # [doc = "Field `TC0` writer - Port E Timer/Counter0"]
pub type TC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPE_SPEC , bool , O > ; # [doc = "Field `TC1` reader - Port E Timer/Counter1"]
pub type TC1_R = crate :: BitReader < bool > ; # [doc = "Field `TC1` writer - Port E Timer/Counter1"]
pub type TC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPE_SPEC , bool , O > ; # [doc = "Field `HIRES` reader - Port E AWEX"]
pub type HIRES_R = crate :: BitReader < bool > ; # [doc = "Field `HIRES` writer - Port E AWEX"]
pub type HIRES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPE_SPEC , bool , O > ; # [doc = "Field `SPI` reader - Port E SPI"]
pub type SPI_R = crate :: BitReader < bool > ; # [doc = "Field `SPI` writer - Port E SPI"]
pub type SPI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPE_SPEC , bool , O > ; # [doc = "Field `USART0` reader - Port E USART0"]
pub type USART0_R = crate :: BitReader < bool > ; # [doc = "Field `USART0` writer - Port E USART0"]
pub type USART0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPE_SPEC , bool , O > ; # [doc = "Field `USART1` reader - Port E USART1"]
pub type USART1_R = crate :: BitReader < bool > ; # [doc = "Field `USART1` writer - Port E USART1"]
pub type USART1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPE_SPEC , bool , O > ; # [doc = "Field `TWI` reader - Port E Two-wire Interface"]
pub type TWI_R = crate :: BitReader < bool > ; # [doc = "Field `TWI` writer - Port E Two-wire Interface"]
pub type TWI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port E Timer/Counter0"]
# [inline (always)]
pub fn tc0 (& self) -> TC0_R { TC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port E Timer/Counter1"]
# [inline (always)]
pub fn tc1 (& self) -> TC1_R { TC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Port E AWEX"]
# [inline (always)]
pub fn hires (& self) -> HIRES_R { HIRES_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Port E SPI"]
# [inline (always)]
pub fn spi (& self) -> SPI_R { SPI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Port E USART0"]
# [inline (always)]
pub fn usart0 (& self) -> USART0_R { USART0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Port E USART1"]
# [inline (always)]
pub fn usart1 (& self) -> USART1_R { USART1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Port E Two-wire Interface"]
# [inline (always)]
pub fn twi (& self) -> TWI_R { TWI_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port E Timer/Counter0"]
# [inline (always)]
# [must_use]
pub fn tc0 (& mut self) -> TC0_W < 0 > { TC0_W :: new (self) } # [doc = "Bit 1 - Port E Timer/Counter1"]
# [inline (always)]
# [must_use]
pub fn tc1 (& mut self) -> TC1_W < 1 > { TC1_W :: new (self) } # [doc = "Bit 2 - Port E AWEX"]
# [inline (always)]
# [must_use]
pub fn hires (& mut self) -> HIRES_W < 2 > { HIRES_W :: new (self) } # [doc = "Bit 3 - Port E SPI"]
# [inline (always)]
# [must_use]
pub fn spi (& mut self) -> SPI_W < 3 > { SPI_W :: new (self) } # [doc = "Bit 4 - Port E USART0"]
# [inline (always)]
# [must_use]
pub fn usart0 (& mut self) -> USART0_W < 4 > { USART0_W :: new (self) } # [doc = "Bit 5 - Port E USART1"]
# [inline (always)]
# [must_use]
pub fn usart1 (& mut self) -> USART1_W < 5 > { USART1_W :: new (self) } # [doc = "Bit 6 - Port E Two-wire Interface"]
# [inline (always)]
# [must_use]
pub fn twi (& mut self) -> TWI_W < 6 > { TWI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Port E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prpe](index.html) module"]
pub struct PRPE_SPEC ; impl crate :: RegisterSpec for PRPE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prpe::R](R) reader structure"]
impl crate :: Readable for PRPE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prpe::W](W) writer structure"]
impl crate :: Writable for PRPE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRPE to value 0"]
impl crate :: Resettable for PRPE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PRPF (rw) register accessor: an alias for `Reg<PRPF_SPEC>`"]
pub type PRPF = crate :: Reg < prpf :: PRPF_SPEC > ; # [doc = "Power Reduction Port F"]
pub mod prpf { # [doc = "Register `PRPF` reader"]
pub struct R (crate :: R < PRPF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRPF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRPF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRPF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRPF` writer"]
pub struct W (crate :: W < PRPF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRPF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRPF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRPF_SPEC >) -> Self { W (writer) } } # [doc = "Field `TC0` reader - Port F Timer/Counter0"]
pub type TC0_R = crate :: BitReader < bool > ; # [doc = "Field `TC0` writer - Port F Timer/Counter0"]
pub type TC0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPF_SPEC , bool , O > ; # [doc = "Field `TC1` reader - Port F Timer/Counter1"]
pub type TC1_R = crate :: BitReader < bool > ; # [doc = "Field `TC1` writer - Port F Timer/Counter1"]
pub type TC1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPF_SPEC , bool , O > ; # [doc = "Field `HIRES` reader - Port F AWEX"]
pub type HIRES_R = crate :: BitReader < bool > ; # [doc = "Field `HIRES` writer - Port F AWEX"]
pub type HIRES_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPF_SPEC , bool , O > ; # [doc = "Field `SPI` reader - Port F SPI"]
pub type SPI_R = crate :: BitReader < bool > ; # [doc = "Field `SPI` writer - Port F SPI"]
pub type SPI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPF_SPEC , bool , O > ; # [doc = "Field `USART0` reader - Port F USART0"]
pub type USART0_R = crate :: BitReader < bool > ; # [doc = "Field `USART0` writer - Port F USART0"]
pub type USART0_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPF_SPEC , bool , O > ; # [doc = "Field `USART1` reader - Port F USART1"]
pub type USART1_R = crate :: BitReader < bool > ; # [doc = "Field `USART1` writer - Port F USART1"]
pub type USART1_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPF_SPEC , bool , O > ; # [doc = "Field `TWI` reader - Port F Two-wire Interface"]
pub type TWI_R = crate :: BitReader < bool > ; # [doc = "Field `TWI` writer - Port F Two-wire Interface"]
pub type TWI_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , PRPF_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port F Timer/Counter0"]
# [inline (always)]
pub fn tc0 (& self) -> TC0_R { TC0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port F Timer/Counter1"]
# [inline (always)]
pub fn tc1 (& self) -> TC1_R { TC1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Port F AWEX"]
# [inline (always)]
pub fn hires (& self) -> HIRES_R { HIRES_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Port F SPI"]
# [inline (always)]
pub fn spi (& self) -> SPI_R { SPI_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Port F USART0"]
# [inline (always)]
pub fn usart0 (& self) -> USART0_R { USART0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Port F USART1"]
# [inline (always)]
pub fn usart1 (& self) -> USART1_R { USART1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Port F Two-wire Interface"]
# [inline (always)]
pub fn twi (& self) -> TWI_R { TWI_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port F Timer/Counter0"]
# [inline (always)]
# [must_use]
pub fn tc0 (& mut self) -> TC0_W < 0 > { TC0_W :: new (self) } # [doc = "Bit 1 - Port F Timer/Counter1"]
# [inline (always)]
# [must_use]
pub fn tc1 (& mut self) -> TC1_W < 1 > { TC1_W :: new (self) } # [doc = "Bit 2 - Port F AWEX"]
# [inline (always)]
# [must_use]
pub fn hires (& mut self) -> HIRES_W < 2 > { HIRES_W :: new (self) } # [doc = "Bit 3 - Port F SPI"]
# [inline (always)]
# [must_use]
pub fn spi (& mut self) -> SPI_W < 3 > { SPI_W :: new (self) } # [doc = "Bit 4 - Port F USART0"]
# [inline (always)]
# [must_use]
pub fn usart0 (& mut self) -> USART0_W < 4 > { USART0_W :: new (self) } # [doc = "Bit 5 - Port F USART1"]
# [inline (always)]
# [must_use]
pub fn usart1 (& mut self) -> USART1_W < 5 > { USART1_W :: new (self) } # [doc = "Bit 6 - Port F Two-wire Interface"]
# [inline (always)]
# [must_use]
pub fn twi (& mut self) -> TWI_W < 6 > { TWI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Power Reduction Port F\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prpf](index.html) module"]
pub struct PRPF_SPEC ; impl crate :: RegisterSpec for PRPF_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [prpf::R](R) reader structure"]
impl crate :: Readable for PRPF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prpf::W](W) writer structure"]
impl crate :: Writable for PRPF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PRPF to value 0"]
impl crate :: Resettable for PRPF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Non Volatile Memory Controller"]
pub struct PROD_SIGNATURES { _marker : PhantomData < * const () > } unsafe impl Send for PROD_SIGNATURES { } impl PROD_SIGNATURES { # [doc = r"Pointer to the register block"]
pub const PTR : * const prod_signatures :: RegisterBlock = 0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const prod_signatures :: RegisterBlock { Self :: PTR } } impl Deref for PROD_SIGNATURES { type Target = prod_signatures :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PROD_SIGNATURES { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PROD_SIGNATURES") . finish () } } # [doc = "Non Volatile Memory Controller"]
pub mod prod_signatures { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - RCOSC 2MHz Calibration Value"]
pub rcosc2m : RCOSC2M , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - RCOSC 32kHz Calibration Value"]
pub rcosc32k : RCOSC32K , # [doc = "0x03 - RCOSC 32MHz Calibration Value"]
pub rcosc32m : RCOSC32M , _reserved3 : [u8 ; 0x04]
, # [doc = "0x08 - Lot Number Byte 0, ASCII"]
pub lotnum0 : LOTNUM0 , # [doc = "0x09 - Lot Number Byte 1, ASCII"]
pub lotnum1 : LOTNUM1 , # [doc = "0x0a - Lot Number Byte 2, ASCII"]
pub lotnum2 : LOTNUM2 , # [doc = "0x0b - Lot Number Byte 3, ASCII"]
pub lotnum3 : LOTNUM3 , # [doc = "0x0c - Lot Number Byte 4, ASCII"]
pub lotnum4 : LOTNUM4 , # [doc = "0x0d - Lot Number Byte 5, ASCII"]
pub lotnum5 : LOTNUM5 , _reserved9 : [u8 ; 0x02]
, # [doc = "0x10 - Wafer Number"]
pub wafnum : WAFNUM , _reserved10 : [u8 ; 0x01]
, # [doc = "0x12 - Wafer Coordinate X Byte 0"]
pub coordx0 : COORDX0 , # [doc = "0x13 - Wafer Coordinate X Byte 1"]
pub coordx1 : COORDX1 , # [doc = "0x14 - Wafer Coordinate Y Byte 0"]
pub coordy0 : COORDY0 , # [doc = "0x15 - Wafer Coordinate Y Byte 1"]
pub coordy1 : COORDY1 , _reserved14 : [u8 ; 0x0a]
, # [doc = "0x20 - ADCA Calibration Byte 0"]
pub adcacal0 : ADCACAL0 , # [doc = "0x21 - ADCA Calibration Byte 1"]
pub adcacal1 : ADCACAL1 , _reserved16 : [u8 ; 0x02]
, # [doc = "0x24 - ADCB Calibration Byte 0"]
pub adcbcal0 : ADCBCAL0 , # [doc = "0x25 - ADCB Calibration Byte 1"]
pub adcbcal1 : ADCBCAL1 , _reserved18 : [u8 ; 0x08]
, # [doc = "0x2e - Temperature Sensor Calibration Byte 0"]
pub tempsense0 : TEMPSENSE0 , # [doc = "0x2f - Temperature Sensor Calibration Byte 0"]
pub tempsense1 : TEMPSENSE1 , # [doc = "0x30 - DACA Calibration Byte 0"]
pub dacaoffcal : DACAOFFCAL , # [doc = "0x31 - DACA Calibration Byte 1"]
pub dacagaincal : DACAGAINCAL , # [doc = "0x32 - DACB Calibration Byte 0"]
pub dacboffcal : DACBOFFCAL , # [doc = "0x33 - DACB Calibration Byte 1"]
pub dacbgaincal : DACBGAINCAL , } # [doc = "ADCACAL0 (rw) register accessor: an alias for `Reg<ADCACAL0_SPEC>`"]
pub type ADCACAL0 = crate :: Reg < adcacal0 :: ADCACAL0_SPEC > ; # [doc = "ADCA Calibration Byte 0"]
pub mod adcacal0 { # [doc = "Register `ADCACAL0` reader"]
pub struct R (crate :: R < ADCACAL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCACAL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCACAL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCACAL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCACAL0` writer"]
pub struct W (crate :: W < ADCACAL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCACAL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCACAL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCACAL0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "ADCA Calibration Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcacal0](index.html) module"]
pub struct ADCACAL0_SPEC ; impl crate :: RegisterSpec for ADCACAL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcacal0::R](R) reader structure"]
impl crate :: Readable for ADCACAL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcacal0::W](W) writer structure"]
impl crate :: Writable for ADCACAL0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCACAL0 to value 0"]
impl crate :: Resettable for ADCACAL0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCACAL1 (rw) register accessor: an alias for `Reg<ADCACAL1_SPEC>`"]
pub type ADCACAL1 = crate :: Reg < adcacal1 :: ADCACAL1_SPEC > ; # [doc = "ADCA Calibration Byte 1"]
pub mod adcacal1 { # [doc = "Register `ADCACAL1` reader"]
pub struct R (crate :: R < ADCACAL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCACAL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCACAL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCACAL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCACAL1` writer"]
pub struct W (crate :: W < ADCACAL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCACAL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCACAL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCACAL1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "ADCA Calibration Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcacal1](index.html) module"]
pub struct ADCACAL1_SPEC ; impl crate :: RegisterSpec for ADCACAL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcacal1::R](R) reader structure"]
impl crate :: Readable for ADCACAL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcacal1::W](W) writer structure"]
impl crate :: Writable for ADCACAL1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCACAL1 to value 0"]
impl crate :: Resettable for ADCACAL1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCBCAL0 (rw) register accessor: an alias for `Reg<ADCBCAL0_SPEC>`"]
pub type ADCBCAL0 = crate :: Reg < adcbcal0 :: ADCBCAL0_SPEC > ; # [doc = "ADCB Calibration Byte 0"]
pub mod adcbcal0 { # [doc = "Register `ADCBCAL0` reader"]
pub struct R (crate :: R < ADCBCAL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCBCAL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCBCAL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCBCAL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCBCAL0` writer"]
pub struct W (crate :: W < ADCBCAL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCBCAL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCBCAL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCBCAL0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "ADCB Calibration Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcbcal0](index.html) module"]
pub struct ADCBCAL0_SPEC ; impl crate :: RegisterSpec for ADCBCAL0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcbcal0::R](R) reader structure"]
impl crate :: Readable for ADCBCAL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcbcal0::W](W) writer structure"]
impl crate :: Writable for ADCBCAL0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCBCAL0 to value 0"]
impl crate :: Resettable for ADCBCAL0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "ADCBCAL1 (rw) register accessor: an alias for `Reg<ADCBCAL1_SPEC>`"]
pub type ADCBCAL1 = crate :: Reg < adcbcal1 :: ADCBCAL1_SPEC > ; # [doc = "ADCB Calibration Byte 1"]
pub mod adcbcal1 { # [doc = "Register `ADCBCAL1` reader"]
pub struct R (crate :: R < ADCBCAL1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADCBCAL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADCBCAL1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADCBCAL1_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADCBCAL1` writer"]
pub struct W (crate :: W < ADCBCAL1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADCBCAL1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADCBCAL1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADCBCAL1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "ADCB Calibration Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcbcal1](index.html) module"]
pub struct ADCBCAL1_SPEC ; impl crate :: RegisterSpec for ADCBCAL1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [adcbcal1::R](R) reader structure"]
impl crate :: Readable for ADCBCAL1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [adcbcal1::W](W) writer structure"]
impl crate :: Writable for ADCBCAL1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets ADCBCAL1 to value 0"]
impl crate :: Resettable for ADCBCAL1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COORDX0 (rw) register accessor: an alias for `Reg<COORDX0_SPEC>`"]
pub type COORDX0 = crate :: Reg < coordx0 :: COORDX0_SPEC > ; # [doc = "Wafer Coordinate X Byte 0"]
pub mod coordx0 { # [doc = "Register `COORDX0` reader"]
pub struct R (crate :: R < COORDX0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COORDX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COORDX0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COORDX0_SPEC >) -> Self { R (reader) } } # [doc = "Register `COORDX0` writer"]
pub struct W (crate :: W < COORDX0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COORDX0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COORDX0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COORDX0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Wafer Coordinate X Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [coordx0](index.html) module"]
pub struct COORDX0_SPEC ; impl crate :: RegisterSpec for COORDX0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [coordx0::R](R) reader structure"]
impl crate :: Readable for COORDX0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [coordx0::W](W) writer structure"]
impl crate :: Writable for COORDX0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COORDX0 to value 0"]
impl crate :: Resettable for COORDX0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COORDX1 (rw) register accessor: an alias for `Reg<COORDX1_SPEC>`"]
pub type COORDX1 = crate :: Reg < coordx1 :: COORDX1_SPEC > ; # [doc = "Wafer Coordinate X Byte 1"]
pub mod coordx1 { # [doc = "Register `COORDX1` reader"]
pub struct R (crate :: R < COORDX1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COORDX1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COORDX1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COORDX1_SPEC >) -> Self { R (reader) } } # [doc = "Register `COORDX1` writer"]
pub struct W (crate :: W < COORDX1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COORDX1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COORDX1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COORDX1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Wafer Coordinate X Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [coordx1](index.html) module"]
pub struct COORDX1_SPEC ; impl crate :: RegisterSpec for COORDX1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [coordx1::R](R) reader structure"]
impl crate :: Readable for COORDX1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [coordx1::W](W) writer structure"]
impl crate :: Writable for COORDX1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COORDX1 to value 0"]
impl crate :: Resettable for COORDX1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COORDY0 (rw) register accessor: an alias for `Reg<COORDY0_SPEC>`"]
pub type COORDY0 = crate :: Reg < coordy0 :: COORDY0_SPEC > ; # [doc = "Wafer Coordinate Y Byte 0"]
pub mod coordy0 { # [doc = "Register `COORDY0` reader"]
pub struct R (crate :: R < COORDY0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COORDY0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COORDY0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COORDY0_SPEC >) -> Self { R (reader) } } # [doc = "Register `COORDY0` writer"]
pub struct W (crate :: W < COORDY0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COORDY0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COORDY0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COORDY0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Wafer Coordinate Y Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [coordy0](index.html) module"]
pub struct COORDY0_SPEC ; impl crate :: RegisterSpec for COORDY0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [coordy0::R](R) reader structure"]
impl crate :: Readable for COORDY0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [coordy0::W](W) writer structure"]
impl crate :: Writable for COORDY0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COORDY0 to value 0"]
impl crate :: Resettable for COORDY0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COORDY1 (rw) register accessor: an alias for `Reg<COORDY1_SPEC>`"]
pub type COORDY1 = crate :: Reg < coordy1 :: COORDY1_SPEC > ; # [doc = "Wafer Coordinate Y Byte 1"]
pub mod coordy1 { # [doc = "Register `COORDY1` reader"]
pub struct R (crate :: R < COORDY1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COORDY1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COORDY1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COORDY1_SPEC >) -> Self { R (reader) } } # [doc = "Register `COORDY1` writer"]
pub struct W (crate :: W < COORDY1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COORDY1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COORDY1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COORDY1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Wafer Coordinate Y Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [coordy1](index.html) module"]
pub struct COORDY1_SPEC ; impl crate :: RegisterSpec for COORDY1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [coordy1::R](R) reader structure"]
impl crate :: Readable for COORDY1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [coordy1::W](W) writer structure"]
impl crate :: Writable for COORDY1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COORDY1 to value 0"]
impl crate :: Resettable for COORDY1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DACAGAINCAL (rw) register accessor: an alias for `Reg<DACAGAINCAL_SPEC>`"]
pub type DACAGAINCAL = crate :: Reg < dacagaincal :: DACAGAINCAL_SPEC > ; # [doc = "DACA Calibration Byte 1"]
pub mod dacagaincal { # [doc = "Register `DACAGAINCAL` reader"]
pub struct R (crate :: R < DACAGAINCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DACAGAINCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DACAGAINCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DACAGAINCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DACAGAINCAL` writer"]
pub struct W (crate :: W < DACAGAINCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DACAGAINCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DACAGAINCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DACAGAINCAL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "DACA Calibration Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dacagaincal](index.html) module"]
pub struct DACAGAINCAL_SPEC ; impl crate :: RegisterSpec for DACAGAINCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dacagaincal::R](R) reader structure"]
impl crate :: Readable for DACAGAINCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dacagaincal::W](W) writer structure"]
impl crate :: Writable for DACAGAINCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DACAGAINCAL to value 0"]
impl crate :: Resettable for DACAGAINCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DACAOFFCAL (rw) register accessor: an alias for `Reg<DACAOFFCAL_SPEC>`"]
pub type DACAOFFCAL = crate :: Reg < dacaoffcal :: DACAOFFCAL_SPEC > ; # [doc = "DACA Calibration Byte 0"]
pub mod dacaoffcal { # [doc = "Register `DACAOFFCAL` reader"]
pub struct R (crate :: R < DACAOFFCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DACAOFFCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DACAOFFCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DACAOFFCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DACAOFFCAL` writer"]
pub struct W (crate :: W < DACAOFFCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DACAOFFCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DACAOFFCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DACAOFFCAL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "DACA Calibration Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dacaoffcal](index.html) module"]
pub struct DACAOFFCAL_SPEC ; impl crate :: RegisterSpec for DACAOFFCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dacaoffcal::R](R) reader structure"]
impl crate :: Readable for DACAOFFCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dacaoffcal::W](W) writer structure"]
impl crate :: Writable for DACAOFFCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DACAOFFCAL to value 0"]
impl crate :: Resettable for DACAOFFCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DACBGAINCAL (rw) register accessor: an alias for `Reg<DACBGAINCAL_SPEC>`"]
pub type DACBGAINCAL = crate :: Reg < dacbgaincal :: DACBGAINCAL_SPEC > ; # [doc = "DACB Calibration Byte 1"]
pub mod dacbgaincal { # [doc = "Register `DACBGAINCAL` reader"]
pub struct R (crate :: R < DACBGAINCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DACBGAINCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DACBGAINCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DACBGAINCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DACBGAINCAL` writer"]
pub struct W (crate :: W < DACBGAINCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DACBGAINCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DACBGAINCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DACBGAINCAL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "DACB Calibration Byte 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dacbgaincal](index.html) module"]
pub struct DACBGAINCAL_SPEC ; impl crate :: RegisterSpec for DACBGAINCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dacbgaincal::R](R) reader structure"]
impl crate :: Readable for DACBGAINCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dacbgaincal::W](W) writer structure"]
impl crate :: Writable for DACBGAINCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DACBGAINCAL to value 0"]
impl crate :: Resettable for DACBGAINCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DACBOFFCAL (rw) register accessor: an alias for `Reg<DACBOFFCAL_SPEC>`"]
pub type DACBOFFCAL = crate :: Reg < dacboffcal :: DACBOFFCAL_SPEC > ; # [doc = "DACB Calibration Byte 0"]
pub mod dacboffcal { # [doc = "Register `DACBOFFCAL` reader"]
pub struct R (crate :: R < DACBOFFCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DACBOFFCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DACBOFFCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DACBOFFCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DACBOFFCAL` writer"]
pub struct W (crate :: W < DACBOFFCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DACBOFFCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DACBOFFCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DACBOFFCAL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "DACB Calibration Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dacboffcal](index.html) module"]
pub struct DACBOFFCAL_SPEC ; impl crate :: RegisterSpec for DACBOFFCAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dacboffcal::R](R) reader structure"]
impl crate :: Readable for DACBOFFCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dacboffcal::W](W) writer structure"]
impl crate :: Writable for DACBOFFCAL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DACBOFFCAL to value 0"]
impl crate :: Resettable for DACBOFFCAL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOTNUM0 (rw) register accessor: an alias for `Reg<LOTNUM0_SPEC>`"]
pub type LOTNUM0 = crate :: Reg < lotnum0 :: LOTNUM0_SPEC > ; # [doc = "Lot Number Byte 0, ASCII"]
pub mod lotnum0 { # [doc = "Register `LOTNUM0` reader"]
pub struct R (crate :: R < LOTNUM0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOTNUM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOTNUM0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOTNUM0_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOTNUM0` writer"]
pub struct W (crate :: W < LOTNUM0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOTNUM0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOTNUM0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOTNUM0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Lot Number Byte 0, ASCII\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lotnum0](index.html) module"]
pub struct LOTNUM0_SPEC ; impl crate :: RegisterSpec for LOTNUM0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lotnum0::R](R) reader structure"]
impl crate :: Readable for LOTNUM0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lotnum0::W](W) writer structure"]
impl crate :: Writable for LOTNUM0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOTNUM0 to value 0"]
impl crate :: Resettable for LOTNUM0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOTNUM1 (rw) register accessor: an alias for `Reg<LOTNUM1_SPEC>`"]
pub type LOTNUM1 = crate :: Reg < lotnum1 :: LOTNUM1_SPEC > ; # [doc = "Lot Number Byte 1, ASCII"]
pub mod lotnum1 { # [doc = "Register `LOTNUM1` reader"]
pub struct R (crate :: R < LOTNUM1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOTNUM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOTNUM1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOTNUM1_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOTNUM1` writer"]
pub struct W (crate :: W < LOTNUM1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOTNUM1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOTNUM1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOTNUM1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Lot Number Byte 1, ASCII\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lotnum1](index.html) module"]
pub struct LOTNUM1_SPEC ; impl crate :: RegisterSpec for LOTNUM1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lotnum1::R](R) reader structure"]
impl crate :: Readable for LOTNUM1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lotnum1::W](W) writer structure"]
impl crate :: Writable for LOTNUM1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOTNUM1 to value 0"]
impl crate :: Resettable for LOTNUM1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOTNUM2 (rw) register accessor: an alias for `Reg<LOTNUM2_SPEC>`"]
pub type LOTNUM2 = crate :: Reg < lotnum2 :: LOTNUM2_SPEC > ; # [doc = "Lot Number Byte 2, ASCII"]
pub mod lotnum2 { # [doc = "Register `LOTNUM2` reader"]
pub struct R (crate :: R < LOTNUM2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOTNUM2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOTNUM2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOTNUM2_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOTNUM2` writer"]
pub struct W (crate :: W < LOTNUM2_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOTNUM2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOTNUM2_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOTNUM2_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Lot Number Byte 2, ASCII\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lotnum2](index.html) module"]
pub struct LOTNUM2_SPEC ; impl crate :: RegisterSpec for LOTNUM2_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lotnum2::R](R) reader structure"]
impl crate :: Readable for LOTNUM2_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lotnum2::W](W) writer structure"]
impl crate :: Writable for LOTNUM2_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOTNUM2 to value 0"]
impl crate :: Resettable for LOTNUM2_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOTNUM3 (rw) register accessor: an alias for `Reg<LOTNUM3_SPEC>`"]
pub type LOTNUM3 = crate :: Reg < lotnum3 :: LOTNUM3_SPEC > ; # [doc = "Lot Number Byte 3, ASCII"]
pub mod lotnum3 { # [doc = "Register `LOTNUM3` reader"]
pub struct R (crate :: R < LOTNUM3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOTNUM3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOTNUM3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOTNUM3_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOTNUM3` writer"]
pub struct W (crate :: W < LOTNUM3_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOTNUM3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOTNUM3_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOTNUM3_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Lot Number Byte 3, ASCII\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lotnum3](index.html) module"]
pub struct LOTNUM3_SPEC ; impl crate :: RegisterSpec for LOTNUM3_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lotnum3::R](R) reader structure"]
impl crate :: Readable for LOTNUM3_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lotnum3::W](W) writer structure"]
impl crate :: Writable for LOTNUM3_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOTNUM3 to value 0"]
impl crate :: Resettable for LOTNUM3_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOTNUM4 (rw) register accessor: an alias for `Reg<LOTNUM4_SPEC>`"]
pub type LOTNUM4 = crate :: Reg < lotnum4 :: LOTNUM4_SPEC > ; # [doc = "Lot Number Byte 4, ASCII"]
pub mod lotnum4 { # [doc = "Register `LOTNUM4` reader"]
pub struct R (crate :: R < LOTNUM4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOTNUM4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOTNUM4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOTNUM4_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOTNUM4` writer"]
pub struct W (crate :: W < LOTNUM4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOTNUM4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOTNUM4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOTNUM4_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Lot Number Byte 4, ASCII\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lotnum4](index.html) module"]
pub struct LOTNUM4_SPEC ; impl crate :: RegisterSpec for LOTNUM4_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lotnum4::R](R) reader structure"]
impl crate :: Readable for LOTNUM4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lotnum4::W](W) writer structure"]
impl crate :: Writable for LOTNUM4_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOTNUM4 to value 0"]
impl crate :: Resettable for LOTNUM4_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "LOTNUM5 (rw) register accessor: an alias for `Reg<LOTNUM5_SPEC>`"]
pub type LOTNUM5 = crate :: Reg < lotnum5 :: LOTNUM5_SPEC > ; # [doc = "Lot Number Byte 5, ASCII"]
pub mod lotnum5 { # [doc = "Register `LOTNUM5` reader"]
pub struct R (crate :: R < LOTNUM5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOTNUM5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOTNUM5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOTNUM5_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOTNUM5` writer"]
pub struct W (crate :: W < LOTNUM5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOTNUM5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOTNUM5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOTNUM5_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Lot Number Byte 5, ASCII\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lotnum5](index.html) module"]
pub struct LOTNUM5_SPEC ; impl crate :: RegisterSpec for LOTNUM5_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [lotnum5::R](R) reader structure"]
impl crate :: Readable for LOTNUM5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lotnum5::W](W) writer structure"]
impl crate :: Writable for LOTNUM5_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets LOTNUM5 to value 0"]
impl crate :: Resettable for LOTNUM5_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RCOSC2M (rw) register accessor: an alias for `Reg<RCOSC2M_SPEC>`"]
pub type RCOSC2M = crate :: Reg < rcosc2m :: RCOSC2M_SPEC > ; # [doc = "RCOSC 2MHz Calibration Value"]
pub mod rcosc2m { # [doc = "Register `RCOSC2M` reader"]
pub struct R (crate :: R < RCOSC2M_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RCOSC2M_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RCOSC2M_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RCOSC2M_SPEC >) -> Self { R (reader) } } # [doc = "Register `RCOSC2M` writer"]
pub struct W (crate :: W < RCOSC2M_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RCOSC2M_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RCOSC2M_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RCOSC2M_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "RCOSC 2MHz Calibration Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rcosc2m](index.html) module"]
pub struct RCOSC2M_SPEC ; impl crate :: RegisterSpec for RCOSC2M_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rcosc2m::R](R) reader structure"]
impl crate :: Readable for RCOSC2M_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rcosc2m::W](W) writer structure"]
impl crate :: Writable for RCOSC2M_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RCOSC2M to value 0"]
impl crate :: Resettable for RCOSC2M_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RCOSC32K (rw) register accessor: an alias for `Reg<RCOSC32K_SPEC>`"]
pub type RCOSC32K = crate :: Reg < rcosc32k :: RCOSC32K_SPEC > ; # [doc = "RCOSC 32kHz Calibration Value"]
pub mod rcosc32k { # [doc = "Register `RCOSC32K` reader"]
pub struct R (crate :: R < RCOSC32K_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RCOSC32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RCOSC32K_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RCOSC32K_SPEC >) -> Self { R (reader) } } # [doc = "Register `RCOSC32K` writer"]
pub struct W (crate :: W < RCOSC32K_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RCOSC32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RCOSC32K_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RCOSC32K_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "RCOSC 32kHz Calibration Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rcosc32k](index.html) module"]
pub struct RCOSC32K_SPEC ; impl crate :: RegisterSpec for RCOSC32K_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rcosc32k::R](R) reader structure"]
impl crate :: Readable for RCOSC32K_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rcosc32k::W](W) writer structure"]
impl crate :: Writable for RCOSC32K_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RCOSC32K to value 0"]
impl crate :: Resettable for RCOSC32K_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "RCOSC32M (rw) register accessor: an alias for `Reg<RCOSC32M_SPEC>`"]
pub type RCOSC32M = crate :: Reg < rcosc32m :: RCOSC32M_SPEC > ; # [doc = "RCOSC 32MHz Calibration Value"]
pub mod rcosc32m { # [doc = "Register `RCOSC32M` reader"]
pub struct R (crate :: R < RCOSC32M_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RCOSC32M_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RCOSC32M_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RCOSC32M_SPEC >) -> Self { R (reader) } } # [doc = "Register `RCOSC32M` writer"]
pub struct W (crate :: W < RCOSC32M_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RCOSC32M_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RCOSC32M_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RCOSC32M_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "RCOSC 32MHz Calibration Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rcosc32m](index.html) module"]
pub struct RCOSC32M_SPEC ; impl crate :: RegisterSpec for RCOSC32M_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rcosc32m::R](R) reader structure"]
impl crate :: Readable for RCOSC32M_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rcosc32m::W](W) writer structure"]
impl crate :: Writable for RCOSC32M_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets RCOSC32M to value 0"]
impl crate :: Resettable for RCOSC32M_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMPSENSE0 (rw) register accessor: an alias for `Reg<TEMPSENSE0_SPEC>`"]
pub type TEMPSENSE0 = crate :: Reg < tempsense0 :: TEMPSENSE0_SPEC > ; # [doc = "Temperature Sensor Calibration Byte 0"]
pub mod tempsense0 { # [doc = "Register `TEMPSENSE0` reader"]
pub struct R (crate :: R < TEMPSENSE0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMPSENSE0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMPSENSE0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMPSENSE0_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMPSENSE0` writer"]
pub struct W (crate :: W < TEMPSENSE0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMPSENSE0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMPSENSE0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMPSENSE0_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temperature Sensor Calibration Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tempsense0](index.html) module"]
pub struct TEMPSENSE0_SPEC ; impl crate :: RegisterSpec for TEMPSENSE0_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tempsense0::R](R) reader structure"]
impl crate :: Readable for TEMPSENSE0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tempsense0::W](W) writer structure"]
impl crate :: Writable for TEMPSENSE0_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMPSENSE0 to value 0"]
impl crate :: Resettable for TEMPSENSE0_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMPSENSE1 (rw) register accessor: an alias for `Reg<TEMPSENSE1_SPEC>`"]
pub type TEMPSENSE1 = crate :: Reg < tempsense1 :: TEMPSENSE1_SPEC > ; # [doc = "Temperature Sensor Calibration Byte 0"]
pub mod tempsense1 { # [doc = "Register `TEMPSENSE1` reader"]
pub struct R (crate :: R < TEMPSENSE1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMPSENSE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMPSENSE1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMPSENSE1_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMPSENSE1` writer"]
pub struct W (crate :: W < TEMPSENSE1_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMPSENSE1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMPSENSE1_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMPSENSE1_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temperature Sensor Calibration Byte 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tempsense1](index.html) module"]
pub struct TEMPSENSE1_SPEC ; impl crate :: RegisterSpec for TEMPSENSE1_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [tempsense1::R](R) reader structure"]
impl crate :: Readable for TEMPSENSE1_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [tempsense1::W](W) writer structure"]
impl crate :: Writable for TEMPSENSE1_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMPSENSE1 to value 0"]
impl crate :: Resettable for TEMPSENSE1_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WAFNUM (rw) register accessor: an alias for `Reg<WAFNUM_SPEC>`"]
pub type WAFNUM = crate :: Reg < wafnum :: WAFNUM_SPEC > ; # [doc = "Wafer Number"]
pub mod wafnum { # [doc = "Register `WAFNUM` reader"]
pub struct R (crate :: R < WAFNUM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WAFNUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WAFNUM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WAFNUM_SPEC >) -> Self { R (reader) } } # [doc = "Register `WAFNUM` writer"]
pub struct W (crate :: W < WAFNUM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WAFNUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WAFNUM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WAFNUM_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Wafer Number\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wafnum](index.html) module"]
pub struct WAFNUM_SPEC ; impl crate :: RegisterSpec for WAFNUM_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [wafnum::R](R) reader structure"]
impl crate :: Readable for WAFNUM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wafnum::W](W) writer structure"]
impl crate :: Writable for WAFNUM_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WAFNUM to value 0"]
impl crate :: Resettable for WAFNUM_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Reset"]
pub struct RST { _marker : PhantomData < * const () > } unsafe impl Send for RST { } impl RST { # [doc = r"Pointer to the register block"]
pub const PTR : * const rst :: RegisterBlock = 0x78 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rst :: RegisterBlock { Self :: PTR } } impl Deref for RST { type Target = rst :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RST { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RST") . finish () } } # [doc = "Reset"]
pub mod rst { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Status Register"]
pub status : STATUS , # [doc = "0x01 - Control Register"]
pub ctrl : CTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
# [must_use]
pub fn swrst (& mut self) -> SWRST_W < 0 > { SWRST_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PORF` reader - Power-on Reset Flag"]
pub type PORF_R = crate :: BitReader < bool > ; # [doc = "Field `PORF` writer - Power-on Reset Flag"]
pub type PORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `EXTRF` reader - External Reset Flag"]
pub type EXTRF_R = crate :: BitReader < bool > ; # [doc = "Field `EXTRF` writer - External Reset Flag"]
pub type EXTRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BORF` reader - Brown-out Reset Flag"]
pub type BORF_R = crate :: BitReader < bool > ; # [doc = "Field `BORF` writer - Brown-out Reset Flag"]
pub type BORF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `WDRF` reader - Watchdog Reset Flag"]
pub type WDRF_R = crate :: BitReader < bool > ; # [doc = "Field `WDRF` writer - Watchdog Reset Flag"]
pub type WDRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PDIRF` reader - Programming and Debug Interface Interface Reset Flag"]
pub type PDIRF_R = crate :: BitReader < bool > ; # [doc = "Field `PDIRF` writer - Programming and Debug Interface Interface Reset Flag"]
pub type PDIRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `SRF` reader - Software Reset Flag"]
pub type SRF_R = crate :: BitReader < bool > ; # [doc = "Field `SRF` writer - Software Reset Flag"]
pub type SRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `SDRF` reader - Spike Detection Reset Flag"]
pub type SDRF_R = crate :: BitReader < bool > ; # [doc = "Field `SDRF` writer - Spike Detection Reset Flag"]
pub type SDRF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Power-on Reset Flag"]
# [inline (always)]
pub fn porf (& self) -> PORF_R { PORF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Reset Flag"]
# [inline (always)]
pub fn extrf (& self) -> EXTRF_R { EXTRF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Brown-out Reset Flag"]
# [inline (always)]
pub fn borf (& self) -> BORF_R { BORF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Watchdog Reset Flag"]
# [inline (always)]
pub fn wdrf (& self) -> WDRF_R { WDRF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Programming and Debug Interface Interface Reset Flag"]
# [inline (always)]
pub fn pdirf (& self) -> PDIRF_R { PDIRF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Software Reset Flag"]
# [inline (always)]
pub fn srf (& self) -> SRF_R { SRF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Spike Detection Reset Flag"]
# [inline (always)]
pub fn sdrf (& self) -> SDRF_R { SDRF_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Power-on Reset Flag"]
# [inline (always)]
# [must_use]
pub fn porf (& mut self) -> PORF_W < 0 > { PORF_W :: new (self) } # [doc = "Bit 1 - External Reset Flag"]
# [inline (always)]
# [must_use]
pub fn extrf (& mut self) -> EXTRF_W < 1 > { EXTRF_W :: new (self) } # [doc = "Bit 2 - Brown-out Reset Flag"]
# [inline (always)]
# [must_use]
pub fn borf (& mut self) -> BORF_W < 2 > { BORF_W :: new (self) } # [doc = "Bit 3 - Watchdog Reset Flag"]
# [inline (always)]
# [must_use]
pub fn wdrf (& mut self) -> WDRF_W < 3 > { WDRF_W :: new (self) } # [doc = "Bit 4 - Programming and Debug Interface Interface Reset Flag"]
# [inline (always)]
# [must_use]
pub fn pdirf (& mut self) -> PDIRF_W < 4 > { PDIRF_W :: new (self) } # [doc = "Bit 5 - Software Reset Flag"]
# [inline (always)]
# [must_use]
pub fn srf (& mut self) -> SRF_W < 5 > { SRF_W :: new (self) } # [doc = "Bit 6 - Spike Detection Reset Flag"]
# [inline (always)]
# [must_use]
pub fn sdrf (& mut self) -> SDRF_W < 6 > { SDRF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Real-Time Counter"]
pub struct RTC { _marker : PhantomData < * const () > } unsafe impl Send for RTC { } impl RTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const rtc :: RegisterBlock = 0x0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rtc :: RegisterBlock { Self :: PTR } } impl Deref for RTC { type Target = rtc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RTC") . finish () } } # [doc = "Real-Time Counter"]
pub mod rtc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - Status Register"]
pub status : STATUS , # [doc = "0x02 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x03 - Interrupt Flags"]
pub intflags : INTFLAGS , # [doc = "0x04 - Temporary register"]
pub temp : TEMP , _reserved5 : [u8 ; 0x03]
, # [doc = "0x08 - Count Register"]
pub cnt : CNT , # [doc = "0x0a - Period Register"]
pub per : PER , # [doc = "0x0c - Compare Register"]
pub comp : COMP , } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count Register"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "COMP (rw) register accessor: an alias for `Reg<COMP_SPEC>`"]
pub type COMP = crate :: Reg < comp :: COMP_SPEC > ; # [doc = "Compare Register"]
pub mod comp { # [doc = "Register `COMP` reader"]
pub struct R (crate :: R < COMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP` writer"]
pub struct W (crate :: W < COMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp](index.html) module"]
pub struct COMP_SPEC ; impl crate :: RegisterSpec for COMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [comp::R](R) reader structure"]
impl crate :: Readable for COMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp::W](W) writer structure"]
impl crate :: Writable for COMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets COMP to value 0"]
impl crate :: Resettable for COMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESCALER` reader - Prescaling Factor"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Prescaling Factor\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: RTC Off"]
OFF = 0 , # [doc = "1: RTC Clock"]
DIV1 = 1 , # [doc = "2: RTC Clock / 2"]
DIV2 = 2 , # [doc = "3: RTC Clock / 8"]
DIV8 = 3 , # [doc = "4: RTC Clock / 16"]
DIV16 = 4 , # [doc = "5: RTC Clock / 64"]
DIV64 = 5 , # [doc = "6: RTC Clock / 256"]
DIV256 = 6 , # [doc = "7: RTC Clock / 1024"]
DIV1024 = 7 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: OFF , 1 => PRESCALER_A :: DIV1 , 2 => PRESCALER_A :: DIV2 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == PRESCALER_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } } # [doc = "Field `PRESCALER` writer - Prescaling Factor"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , PRESCALER_A , 3 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "RTC Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (PRESCALER_A :: OFF) } # [doc = "RTC Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "RTC Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "RTC Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "RTC Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "RTC Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "RTC Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "RTC Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } } impl R { # [doc = "Bits 0:2 - Prescaling Factor"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (self . bits & 7) } } impl W { # [doc = "Bits 0:2 - Prescaling Factor"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 0 > { PRESCALER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow Interrupt Level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow Interrupt Level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `COMPINTLVL` reader - Compare Match Interrupt Level"]
pub type COMPINTLVL_R = crate :: FieldReader < u8 , COMPINTLVL_A > ; # [doc = "Compare Match Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum COMPINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < COMPINTLVL_A > for u8 { # [inline (always)]
fn from (variant : COMPINTLVL_A) -> Self { variant as _ } } impl COMPINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> COMPINTLVL_A { match self . bits { 0 => COMPINTLVL_A :: OFF , 1 => COMPINTLVL_A :: LO , 2 => COMPINTLVL_A :: MED , 3 => COMPINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == COMPINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == COMPINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == COMPINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == COMPINTLVL_A :: HI } } # [doc = "Field `COMPINTLVL` writer - Compare Match Interrupt Level"]
pub type COMPINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , COMPINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > COMPINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (COMPINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (COMPINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (COMPINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (COMPINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow Interrupt Level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare Match Interrupt Level"]
# [inline (always)]
pub fn compintlvl (& self) -> COMPINTLVL_R { COMPINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare Match Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn compintlvl (& mut self) -> COMPINTLVL_W < 2 > { COMPINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flags"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `COMPIF` reader - Compare Match Interrupt Flag"]
pub type COMPIF_R = crate :: BitReader < bool > ; # [doc = "Field `COMPIF` writer - Compare Match Interrupt Flag"]
pub type COMPIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare Match Interrupt Flag"]
# [inline (always)]
pub fn compif (& self) -> COMPIF_R { COMPIF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Compare Match Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn compif (& mut self) -> COMPIF_W < 1 > { COMPIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flags\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period Register"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy Flag"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCBUSY` writer - Synchronization Busy Flag"]
pub type SYNCBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Synchronization Busy Flag"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Synchronization Busy Flag"]
# [inline (always)]
# [must_use]
pub fn syncbusy (& mut self) -> SYNCBUSY_W < 0 > { SYNCBUSY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary register"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Sleep Controller"]
pub struct SLEEP { _marker : PhantomData < * const () > } unsafe impl Send for SLEEP { } impl SLEEP { # [doc = r"Pointer to the register block"]
pub const PTR : * const sleep :: RegisterBlock = 0x48 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sleep :: RegisterBlock { Self :: PTR } } impl Deref for SLEEP { type Target = sleep :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SLEEP { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SLEEP") . finish () } } # [doc = "Sleep Controller"]
pub mod sleep { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SEN` reader - Sleep Enable"]
pub type SEN_R = crate :: BitReader < bool > ; # [doc = "Field `SEN` writer - Sleep Enable"]
pub type SEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `SMODE` reader - Sleep Mode"]
pub type SMODE_R = crate :: FieldReader < u8 , SMODE_A > ; # [doc = "Sleep Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SMODE_A { # [doc = "0: Idle mode"]
IDLE = 0 , # [doc = "2: Power-down Mode"]
PDOWN = 2 , # [doc = "3: Power-save Mode"]
PSAVE = 3 , # [doc = "6: Standby Mode"]
STDBY = 6 , # [doc = "7: Extended Standby Mode"]
ESTDBY = 7 , } impl From < SMODE_A > for u8 { # [inline (always)]
fn from (variant : SMODE_A) -> Self { variant as _ } } impl SMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SMODE_A > { match self . bits { 0 => Some (SMODE_A :: IDLE) , 2 => Some (SMODE_A :: PDOWN) , 3 => Some (SMODE_A :: PSAVE) , 6 => Some (SMODE_A :: STDBY) , 7 => Some (SMODE_A :: ESTDBY) , _ => None , } } # [doc = "Checks if the value of the field is `IDLE`"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == SMODE_A :: IDLE } # [doc = "Checks if the value of the field is `PDOWN`"]
# [inline (always)]
pub fn is_pdown (& self) -> bool { * self == SMODE_A :: PDOWN } # [doc = "Checks if the value of the field is `PSAVE`"]
# [inline (always)]
pub fn is_psave (& self) -> bool { * self == SMODE_A :: PSAVE } # [doc = "Checks if the value of the field is `STDBY`"]
# [inline (always)]
pub fn is_stdby (& self) -> bool { * self == SMODE_A :: STDBY } # [doc = "Checks if the value of the field is `ESTDBY`"]
# [inline (always)]
pub fn is_estdby (& self) -> bool { * self == SMODE_A :: ESTDBY } } # [doc = "Field `SMODE` writer - Sleep Mode"]
pub type SMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRL_SPEC , u8 , SMODE_A , 3 , O > ; impl < 'a , const O : u8 > SMODE_W < 'a , O > { # [doc = "Idle mode"]
# [inline (always)]
pub fn idle (self) -> & 'a mut W { self . variant (SMODE_A :: IDLE) } # [doc = "Power-down Mode"]
# [inline (always)]
pub fn pdown (self) -> & 'a mut W { self . variant (SMODE_A :: PDOWN) } # [doc = "Power-save Mode"]
# [inline (always)]
pub fn psave (self) -> & 'a mut W { self . variant (SMODE_A :: PSAVE) } # [doc = "Standby Mode"]
# [inline (always)]
pub fn stdby (self) -> & 'a mut W { self . variant (SMODE_A :: STDBY) } # [doc = "Extended Standby Mode"]
# [inline (always)]
pub fn estdby (self) -> & 'a mut W { self . variant (SMODE_A :: ESTDBY) } } impl R { # [doc = "Bit 0 - Sleep Enable"]
# [inline (always)]
pub fn sen (& self) -> SEN_R { SEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Sleep Mode"]
# [inline (always)]
pub fn smode (& self) -> SMODE_R { SMODE_R :: new ((self . bits >> 1) & 7) } } impl W { # [doc = "Bit 0 - Sleep Enable"]
# [inline (always)]
# [must_use]
pub fn sen (& mut self) -> SEN_W < 0 > { SEN_W :: new (self) } # [doc = "Bits 1:3 - Sleep Mode"]
# [inline (always)]
# [must_use]
pub fn smode (& mut self) -> SMODE_W < 1 > { SMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct SPIC { _marker : PhantomData < * const () > } unsafe impl Send for SPIC { } impl SPIC { # [doc = r"Pointer to the register block"]
pub const PTR : * const spic :: RegisterBlock = 0x08c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spic :: RegisterBlock { Self :: PTR } } impl Deref for SPIC { type Target = spic :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPIC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPIC") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod spic { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x02 - Status Register"]
pub status : STATUS , # [doc = "0x03 - Data Register"]
pub data : DATA , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: System Clock / 4"]
DIV4 = 0 , # [doc = "1: System Clock / 16"]
DIV16 = 1 , # [doc = "2: System Clock / 64"]
DIV64 = 2 , # [doc = "3: System Clock / 128"]
DIV128 = 3 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV4 , 1 => PRESCALER_A :: DIV16 , 2 => PRESCALER_A :: DIV64 , 3 => PRESCALER_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , PRESCALER_A , 2 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "System Clock / 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } } # [doc = "Field `MODE` reader - SPI Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; # [doc = "SPI Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: SPI Mode 0"]
_0 = 0 , # [doc = "1: SPI Mode 1"]
_1 = 1 , # [doc = "2: SPI Mode 2"]
_2 = 2 , # [doc = "3: SPI Mode 3"]
_3 = 3 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MODE_A { match self . bits { 0 => MODE_A :: _0 , 1 => MODE_A :: _1 , 2 => MODE_A :: _2 , 3 => MODE_A :: _3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == MODE_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == MODE_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == MODE_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == MODE_A :: _3 } } # [doc = "Field `MODE` writer - SPI Mode"]
pub type MODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , MODE_A , 2 , O > ; impl < 'a , const O : u8 > MODE_W < 'a , O > { # [doc = "SPI Mode 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (MODE_A :: _0) } # [doc = "SPI Mode 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (MODE_A :: _1) } # [doc = "SPI Mode 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (MODE_A :: _2) } # [doc = "SPI Mode 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (MODE_A :: _3) } } # [doc = "Field `MASTER` reader - Master Operation Enable"]
pub type MASTER_R = crate :: BitReader < bool > ; # [doc = "Field `MASTER` writer - Master Operation Enable"]
pub type MASTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DORD` reader - Data Order Setting"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order Setting"]
pub type DORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `ENABLE` reader - Enable Module"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable Module"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Enable Double Speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Enable Double Speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - SPI Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Master Operation Enable"]
# [inline (always)]
pub fn master (& self) -> MASTER_R { MASTER_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Order Setting"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Enable Module"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Enable Double Speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Prescaler"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 0 > { PRESCALER_W :: new (self) } # [doc = "Bits 2:3 - SPI Mode"]
# [inline (always)]
# [must_use]
pub fn mode (& mut self) -> MODE_W < 2 > { MODE_W :: new (self) } # [doc = "Bit 4 - Master Operation Enable"]
# [inline (always)]
# [must_use]
pub fn master (& mut self) -> MASTER_W < 4 > { MASTER_W :: new (self) } # [doc = "Bit 5 - Data Order Setting"]
# [inline (always)]
# [must_use]
pub fn dord (& mut self) -> DORD_W < 5 > { DORD_W :: new (self) } # [doc = "Bit 6 - Enable Module"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 6 > { ENABLE_W :: new (self) } # [doc = "Bit 7 - Enable Double Speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 7 > { CLK2X_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTLVL` reader - Interrupt level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 0 > { INTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WRCOL` reader - Write Collision"]
pub type WRCOL_R = crate :: BitReader < bool > ; # [doc = "Field `WRCOL` writer - Write Collision"]
pub type WRCOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `IF` reader - Interrupt Flag"]
pub type IF_R = crate :: BitReader < bool > ; # [doc = "Field `IF` writer - Interrupt Flag"]
pub type IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
pub fn wrcol (& self) -> WRCOL_R { WRCOL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
pub fn if_ (& self) -> IF_R { IF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
# [must_use]
pub fn wrcol (& mut self) -> WRCOL_W < 6 > { WRCOL_W :: new (self) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn if_ (& mut self) -> IF_W < 7 > { IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct SPID { _marker : PhantomData < * const () > } unsafe impl Send for SPID { } impl SPID { # [doc = r"Pointer to the register block"]
pub const PTR : * const spid :: RegisterBlock = 0x09c0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spid :: RegisterBlock { Self :: PTR } } impl Deref for SPID { type Target = spid :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPID { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPID") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod spid { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x02 - Status Register"]
pub status : STATUS , # [doc = "0x03 - Data Register"]
pub data : DATA , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: System Clock / 4"]
DIV4 = 0 , # [doc = "1: System Clock / 16"]
DIV16 = 1 , # [doc = "2: System Clock / 64"]
DIV64 = 2 , # [doc = "3: System Clock / 128"]
DIV128 = 3 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV4 , 1 => PRESCALER_A :: DIV16 , 2 => PRESCALER_A :: DIV64 , 3 => PRESCALER_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , PRESCALER_A , 2 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "System Clock / 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } } # [doc = "Field `MODE` reader - SPI Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; # [doc = "SPI Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: SPI Mode 0"]
_0 = 0 , # [doc = "1: SPI Mode 1"]
_1 = 1 , # [doc = "2: SPI Mode 2"]
_2 = 2 , # [doc = "3: SPI Mode 3"]
_3 = 3 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MODE_A { match self . bits { 0 => MODE_A :: _0 , 1 => MODE_A :: _1 , 2 => MODE_A :: _2 , 3 => MODE_A :: _3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == MODE_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == MODE_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == MODE_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == MODE_A :: _3 } } # [doc = "Field `MODE` writer - SPI Mode"]
pub type MODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , MODE_A , 2 , O > ; impl < 'a , const O : u8 > MODE_W < 'a , O > { # [doc = "SPI Mode 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (MODE_A :: _0) } # [doc = "SPI Mode 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (MODE_A :: _1) } # [doc = "SPI Mode 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (MODE_A :: _2) } # [doc = "SPI Mode 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (MODE_A :: _3) } } # [doc = "Field `MASTER` reader - Master Operation Enable"]
pub type MASTER_R = crate :: BitReader < bool > ; # [doc = "Field `MASTER` writer - Master Operation Enable"]
pub type MASTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DORD` reader - Data Order Setting"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order Setting"]
pub type DORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `ENABLE` reader - Enable Module"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable Module"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Enable Double Speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Enable Double Speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - SPI Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Master Operation Enable"]
# [inline (always)]
pub fn master (& self) -> MASTER_R { MASTER_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Order Setting"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Enable Module"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Enable Double Speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Prescaler"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 0 > { PRESCALER_W :: new (self) } # [doc = "Bits 2:3 - SPI Mode"]
# [inline (always)]
# [must_use]
pub fn mode (& mut self) -> MODE_W < 2 > { MODE_W :: new (self) } # [doc = "Bit 4 - Master Operation Enable"]
# [inline (always)]
# [must_use]
pub fn master (& mut self) -> MASTER_W < 4 > { MASTER_W :: new (self) } # [doc = "Bit 5 - Data Order Setting"]
# [inline (always)]
# [must_use]
pub fn dord (& mut self) -> DORD_W < 5 > { DORD_W :: new (self) } # [doc = "Bit 6 - Enable Module"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 6 > { ENABLE_W :: new (self) } # [doc = "Bit 7 - Enable Double Speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 7 > { CLK2X_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTLVL` reader - Interrupt level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 0 > { INTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WRCOL` reader - Write Collision"]
pub type WRCOL_R = crate :: BitReader < bool > ; # [doc = "Field `WRCOL` writer - Write Collision"]
pub type WRCOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `IF` reader - Interrupt Flag"]
pub type IF_R = crate :: BitReader < bool > ; # [doc = "Field `IF` writer - Interrupt Flag"]
pub type IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
pub fn wrcol (& self) -> WRCOL_R { WRCOL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
pub fn if_ (& self) -> IF_R { IF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
# [must_use]
pub fn wrcol (& mut self) -> WRCOL_W < 6 > { WRCOL_W :: new (self) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn if_ (& mut self) -> IF_W < 7 > { IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct SPIE { _marker : PhantomData < * const () > } unsafe impl Send for SPIE { } impl SPIE { # [doc = r"Pointer to the register block"]
pub const PTR : * const spie :: RegisterBlock = 0x0ac0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spie :: RegisterBlock { Self :: PTR } } impl Deref for SPIE { type Target = spie :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPIE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPIE") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod spie { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x02 - Status Register"]
pub status : STATUS , # [doc = "0x03 - Data Register"]
pub data : DATA , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: System Clock / 4"]
DIV4 = 0 , # [doc = "1: System Clock / 16"]
DIV16 = 1 , # [doc = "2: System Clock / 64"]
DIV64 = 2 , # [doc = "3: System Clock / 128"]
DIV128 = 3 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV4 , 1 => PRESCALER_A :: DIV16 , 2 => PRESCALER_A :: DIV64 , 3 => PRESCALER_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , PRESCALER_A , 2 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "System Clock / 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } } # [doc = "Field `MODE` reader - SPI Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; # [doc = "SPI Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: SPI Mode 0"]
_0 = 0 , # [doc = "1: SPI Mode 1"]
_1 = 1 , # [doc = "2: SPI Mode 2"]
_2 = 2 , # [doc = "3: SPI Mode 3"]
_3 = 3 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MODE_A { match self . bits { 0 => MODE_A :: _0 , 1 => MODE_A :: _1 , 2 => MODE_A :: _2 , 3 => MODE_A :: _3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == MODE_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == MODE_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == MODE_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == MODE_A :: _3 } } # [doc = "Field `MODE` writer - SPI Mode"]
pub type MODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , MODE_A , 2 , O > ; impl < 'a , const O : u8 > MODE_W < 'a , O > { # [doc = "SPI Mode 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (MODE_A :: _0) } # [doc = "SPI Mode 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (MODE_A :: _1) } # [doc = "SPI Mode 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (MODE_A :: _2) } # [doc = "SPI Mode 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (MODE_A :: _3) } } # [doc = "Field `MASTER` reader - Master Operation Enable"]
pub type MASTER_R = crate :: BitReader < bool > ; # [doc = "Field `MASTER` writer - Master Operation Enable"]
pub type MASTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DORD` reader - Data Order Setting"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order Setting"]
pub type DORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `ENABLE` reader - Enable Module"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable Module"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Enable Double Speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Enable Double Speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - SPI Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Master Operation Enable"]
# [inline (always)]
pub fn master (& self) -> MASTER_R { MASTER_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Order Setting"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Enable Module"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Enable Double Speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Prescaler"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 0 > { PRESCALER_W :: new (self) } # [doc = "Bits 2:3 - SPI Mode"]
# [inline (always)]
# [must_use]
pub fn mode (& mut self) -> MODE_W < 2 > { MODE_W :: new (self) } # [doc = "Bit 4 - Master Operation Enable"]
# [inline (always)]
# [must_use]
pub fn master (& mut self) -> MASTER_W < 4 > { MASTER_W :: new (self) } # [doc = "Bit 5 - Data Order Setting"]
# [inline (always)]
# [must_use]
pub fn dord (& mut self) -> DORD_W < 5 > { DORD_W :: new (self) } # [doc = "Bit 6 - Enable Module"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 6 > { ENABLE_W :: new (self) } # [doc = "Bit 7 - Enable Double Speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 7 > { CLK2X_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTLVL` reader - Interrupt level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 0 > { INTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WRCOL` reader - Write Collision"]
pub type WRCOL_R = crate :: BitReader < bool > ; # [doc = "Field `WRCOL` writer - Write Collision"]
pub type WRCOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `IF` reader - Interrupt Flag"]
pub type IF_R = crate :: BitReader < bool > ; # [doc = "Field `IF` writer - Interrupt Flag"]
pub type IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
pub fn wrcol (& self) -> WRCOL_R { WRCOL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
pub fn if_ (& self) -> IF_R { IF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
# [must_use]
pub fn wrcol (& mut self) -> WRCOL_W < 6 > { WRCOL_W :: new (self) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn if_ (& mut self) -> IF_W < 7 > { IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Serial Peripheral Interface"]
pub struct SPIF { _marker : PhantomData < * const () > } unsafe impl Send for SPIF { } impl SPIF { # [doc = r"Pointer to the register block"]
pub const PTR : * const spif :: RegisterBlock = 0x0bc0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spif :: RegisterBlock { Self :: PTR } } impl Deref for SPIF { type Target = spif :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SPIF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPIF") . finish () } } # [doc = "Serial Peripheral Interface"]
pub mod spif { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register"]
pub ctrl : CTRL , # [doc = "0x01 - Interrupt Control Register"]
pub intctrl : INTCTRL , # [doc = "0x02 - Status Register"]
pub status : STATUS , # [doc = "0x03 - Data Register"]
pub data : DATA , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: System Clock / 4"]
DIV4 = 0 , # [doc = "1: System Clock / 16"]
DIV16 = 1 , # [doc = "2: System Clock / 64"]
DIV64 = 2 , # [doc = "3: System Clock / 128"]
DIV128 = 3 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV4 , 1 => PRESCALER_A :: DIV16 , 2 => PRESCALER_A :: DIV64 , 3 => PRESCALER_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , PRESCALER_A , 2 , O > ; impl < 'a , const O : u8 > PRESCALER_W < 'a , O > { # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "System Clock / 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "System Clock / 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } } # [doc = "Field `MODE` reader - SPI Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; # [doc = "SPI Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: SPI Mode 0"]
_0 = 0 , # [doc = "1: SPI Mode 1"]
_1 = 1 , # [doc = "2: SPI Mode 2"]
_2 = 2 , # [doc = "3: SPI Mode 3"]
_3 = 3 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MODE_A { match self . bits { 0 => MODE_A :: _0 , 1 => MODE_A :: _1 , 2 => MODE_A :: _2 , 3 => MODE_A :: _3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == MODE_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == MODE_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == MODE_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == MODE_A :: _3 } } # [doc = "Field `MODE` writer - SPI Mode"]
pub type MODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , MODE_A , 2 , O > ; impl < 'a , const O : u8 > MODE_W < 'a , O > { # [doc = "SPI Mode 0"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (MODE_A :: _0) } # [doc = "SPI Mode 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (MODE_A :: _1) } # [doc = "SPI Mode 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (MODE_A :: _2) } # [doc = "SPI Mode 3"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (MODE_A :: _3) } } # [doc = "Field `MASTER` reader - Master Operation Enable"]
pub type MASTER_R = crate :: BitReader < bool > ; # [doc = "Field `MASTER` writer - Master Operation Enable"]
pub type MASTER_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `DORD` reader - Data Order Setting"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order Setting"]
pub type DORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `ENABLE` reader - Enable Module"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable Module"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Enable Double Speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Enable Double Speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; impl R { # [doc = "Bits 0:1 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - SPI Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new ((self . bits >> 2) & 3) } # [doc = "Bit 4 - Master Operation Enable"]
# [inline (always)]
pub fn master (& self) -> MASTER_R { MASTER_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Order Setting"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Enable Module"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Enable Double Speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Prescaler"]
# [inline (always)]
# [must_use]
pub fn prescaler (& mut self) -> PRESCALER_W < 0 > { PRESCALER_W :: new (self) } # [doc = "Bits 2:3 - SPI Mode"]
# [inline (always)]
# [must_use]
pub fn mode (& mut self) -> MODE_W < 2 > { MODE_W :: new (self) } # [doc = "Bit 4 - Master Operation Enable"]
# [inline (always)]
# [must_use]
pub fn master (& mut self) -> MASTER_W < 4 > { MASTER_W :: new (self) } # [doc = "Bit 5 - Data Order Setting"]
# [inline (always)]
# [must_use]
pub fn dord (& mut self) -> DORD_W < 5 > { DORD_W :: new (self) } # [doc = "Bit 6 - Enable Module"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 6 > { ENABLE_W :: new (self) } # [doc = "Bit 7 - Enable Double Speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 7 > { CLK2X_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRL (rw) register accessor: an alias for `Reg<INTCTRL_SPEC>`"]
pub type INTCTRL = crate :: Reg < intctrl :: INTCTRL_SPEC > ; # [doc = "Interrupt Control Register"]
pub mod intctrl { # [doc = "Register `INTCTRL` reader"]
pub struct R (crate :: R < INTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRL` writer"]
pub struct W (crate :: W < INTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `INTLVL` reader - Interrupt level"]
pub type INTLVL_R = crate :: FieldReader < u8 , INTLVL_A > ; # [doc = "Interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum INTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < INTLVL_A > for u8 { # [inline (always)]
fn from (variant : INTLVL_A) -> Self { variant as _ } } impl INTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTLVL_A { match self . bits { 0 => INTLVL_A :: OFF , 1 => INTLVL_A :: LO , 2 => INTLVL_A :: MED , 3 => INTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == INTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == INTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == INTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == INTLVL_A :: HI } } # [doc = "Field `INTLVL` writer - Interrupt level"]
pub type INTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRL_SPEC , u8 , INTLVL_A , 2 , O > ; impl < 'a , const O : u8 > INTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (INTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (INTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (INTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (INTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
pub fn intlvl (& self) -> INTLVL_R { INTLVL_R :: new (self . bits & 3) } } impl W { # [doc = "Bits 0:1 - Interrupt level"]
# [inline (always)]
# [must_use]
pub fn intlvl (& mut self) -> INTLVL_W < 0 > { INTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrl](index.html) module"]
pub struct INTCTRL_SPEC ; impl crate :: RegisterSpec for INTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrl::R](R) reader structure"]
impl crate :: Readable for INTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrl::W](W) writer structure"]
impl crate :: Writable for INTCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRL to value 0"]
impl crate :: Resettable for INTCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `WRCOL` reader - Write Collision"]
pub type WRCOL_R = crate :: BitReader < bool > ; # [doc = "Field `WRCOL` writer - Write Collision"]
pub type WRCOL_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `IF` reader - Interrupt Flag"]
pub type IF_R = crate :: BitReader < bool > ; # [doc = "Field `IF` writer - Interrupt Flag"]
pub type IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
pub fn wrcol (& self) -> WRCOL_R { WRCOL_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
pub fn if_ (& self) -> IF_R { IF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 6 - Write Collision"]
# [inline (always)]
# [must_use]
pub fn wrcol (& mut self) -> WRCOL_W < 6 > { WRCOL_W :: new (self) } # [doc = "Bit 7 - Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn if_ (& mut self) -> IF_W < 7 > { IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct TCC0 { _marker : PhantomData < * const () > } unsafe impl Send for TCC0 { } impl TCC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcc0 :: RegisterBlock = 0x0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcc0 :: RegisterBlock { Self :: PTR } } impl Deref for TCC0 { type Target = tcc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCC0") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod tcc0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control Register D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control Register E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control Register A"]
pub intctrla : INTCTRLA , # [doc = "0x07 - Interrupt Control Register B"]
pub intctrlb : INTCTRLB , # [doc = "0x08 - Control Register F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x09 - Control Register F Set"]
pub ctrlfset : CTRLFSET , # [doc = "0x0a - Control Register G Clear"]
pub ctrlgclr : CTRLGCLR , # [doc = "0x0b - Control Register G Set"]
pub ctrlgset : CTRLGSET , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved12 : [u8 ; 0x02]
, # [doc = "0x0f - Temporary Register For 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare or Capture A"]
pub cca : CCA , # [doc = "0x2a - Compare or Capture B"]
pub ccb : CCB , # [doc = "0x2c - Compare or Capture C"]
pub ccc : CCC , # [doc = "0x2e - Compare or Capture D"]
pub ccd : CCD , _reserved19 : [u8 ; 0x06]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare Or Capture A Buffer"]
pub ccabuf : CCABUF , # [doc = "0x3a - Compare Or Capture B Buffer"]
pub ccbbuf : CCBBUF , # [doc = "0x3c - Compare Or Capture C Buffer"]
pub cccbuf : CCCBUF , # [doc = "0x3e - Compare Or Capture D Buffer"]
pub ccdbuf : CCDBUF , } # [doc = "CCA (rw) register accessor: an alias for `Reg<CCA_SPEC>`"]
pub type CCA = crate :: Reg < cca :: CCA_SPEC > ; # [doc = "Compare or Capture A"]
pub mod cca { # [doc = "Register `CCA` reader"]
pub struct R (crate :: R < CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA` writer"]
pub struct W (crate :: W < CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca](index.html) module"]
pub struct CCA_SPEC ; impl crate :: RegisterSpec for CCA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cca::R](R) reader structure"]
impl crate :: Readable for CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca::W](W) writer structure"]
impl crate :: Writable for CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA to value 0"]
impl crate :: Resettable for CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCABUF (rw) register accessor: an alias for `Reg<CCABUF_SPEC>`"]
pub type CCABUF = crate :: Reg < ccabuf :: CCABUF_SPEC > ; # [doc = "Compare Or Capture A Buffer"]
pub mod ccabuf { # [doc = "Register `CCABUF` reader"]
pub struct R (crate :: R < CCABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCABUF` writer"]
pub struct W (crate :: W < CCABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCABUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture A Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccabuf](index.html) module"]
pub struct CCABUF_SPEC ; impl crate :: RegisterSpec for CCABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccabuf::R](R) reader structure"]
impl crate :: Readable for CCABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccabuf::W](W) writer structure"]
impl crate :: Writable for CCABUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCABUF to value 0"]
impl crate :: Resettable for CCABUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCB (rw) register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare or Capture B"]
pub mod ccb { # [doc = "Register `CCB` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCB to value 0"]
impl crate :: Resettable for CCB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCBBUF (rw) register accessor: an alias for `Reg<CCBBUF_SPEC>`"]
pub type CCBBUF = crate :: Reg < ccbbuf :: CCBBUF_SPEC > ; # [doc = "Compare Or Capture B Buffer"]
pub mod ccbbuf { # [doc = "Register `CCBBUF` reader"]
pub struct R (crate :: R < CCBBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCBBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCBBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCBBUF` writer"]
pub struct W (crate :: W < CCBBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCBBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCBBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture B Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccbbuf](index.html) module"]
pub struct CCBBUF_SPEC ; impl crate :: RegisterSpec for CCBBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccbbuf::R](R) reader structure"]
impl crate :: Readable for CCBBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccbbuf::W](W) writer structure"]
impl crate :: Writable for CCBBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCBBUF to value 0"]
impl crate :: Resettable for CCBBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCC (rw) register accessor: an alias for `Reg<CCC_SPEC>`"]
pub type CCC = crate :: Reg < ccc :: CCC_SPEC > ; # [doc = "Compare or Capture C"]
pub mod ccc { # [doc = "Register `CCC` reader"]
pub struct R (crate :: R < CCC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCC` writer"]
pub struct W (crate :: W < CCC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccc](index.html) module"]
pub struct CCC_SPEC ; impl crate :: RegisterSpec for CCC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccc::R](R) reader structure"]
impl crate :: Readable for CCC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccc::W](W) writer structure"]
impl crate :: Writable for CCC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCC to value 0"]
impl crate :: Resettable for CCC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCCBUF (rw) register accessor: an alias for `Reg<CCCBUF_SPEC>`"]
pub type CCCBUF = crate :: Reg < cccbuf :: CCCBUF_SPEC > ; # [doc = "Compare Or Capture C Buffer"]
pub mod cccbuf { # [doc = "Register `CCCBUF` reader"]
pub struct R (crate :: R < CCCBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCCBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCCBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCCBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCCBUF` writer"]
pub struct W (crate :: W < CCCBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCCBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCCBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCCBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture C Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cccbuf](index.html) module"]
pub struct CCCBUF_SPEC ; impl crate :: RegisterSpec for CCCBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cccbuf::R](R) reader structure"]
impl crate :: Readable for CCCBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cccbuf::W](W) writer structure"]
impl crate :: Writable for CCCBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCCBUF to value 0"]
impl crate :: Resettable for CCCBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCD (rw) register accessor: an alias for `Reg<CCD_SPEC>`"]
pub type CCD = crate :: Reg < ccd :: CCD_SPEC > ; # [doc = "Compare or Capture D"]
pub mod ccd { # [doc = "Register `CCD` reader"]
pub struct R (crate :: R < CCD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCD` writer"]
pub struct W (crate :: W < CCD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccd](index.html) module"]
pub struct CCD_SPEC ; impl crate :: RegisterSpec for CCD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccd::R](R) reader structure"]
impl crate :: Readable for CCD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccd::W](W) writer structure"]
impl crate :: Writable for CCD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCD to value 0"]
impl crate :: Resettable for CCD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCDBUF (rw) register accessor: an alias for `Reg<CCDBUF_SPEC>`"]
pub type CCDBUF = crate :: Reg < ccdbuf :: CCDBUF_SPEC > ; # [doc = "Compare Or Capture D Buffer"]
pub mod ccdbuf { # [doc = "Register `CCDBUF` reader"]
pub struct R (crate :: R < CCDBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCDBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCDBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCDBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCDBUF` writer"]
pub struct W (crate :: W < CCDBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCDBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCDBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCDBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture D Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccdbuf](index.html) module"]
pub struct CCDBUF_SPEC ; impl crate :: RegisterSpec for CCDBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccdbuf::R](R) reader structure"]
impl crate :: Readable for CCDBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccdbuf::W](W) writer structure"]
impl crate :: Writable for CCDBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCDBUF to value 0"]
impl crate :: Resettable for CCDBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Timer Off"]
OFF = 0 , # [doc = "1: System Clock"]
DIV1 = 1 , # [doc = "2: System Clock / 2"]
DIV2 = 2 , # [doc = "3: System Clock / 4"]
DIV4 = 3 , # [doc = "4: System Clock / 8"]
DIV8 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , # [doc = "8: Event Channel 0"]
EVCH0 = 8 , # [doc = "9: Event Channel 1"]
EVCH1 = 9 , # [doc = "10: Event Channel 2"]
EVCH2 = 10 , # [doc = "11: Event Channel 3"]
EVCH3 = 11 , # [doc = "12: Event Channel 4"]
EVCH4 = 12 , # [doc = "13: Event Channel 5"]
EVCH5 = 13 , # [doc = "14: Event Channel 6"]
EVCH6 = 14 , # [doc = "15: Event Channel 7"]
EVCH7 = 15 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OFF , 1 => CLKSEL_A :: DIV1 , 2 => CLKSEL_A :: DIV2 , 3 => CLKSEL_A :: DIV4 , 4 => CLKSEL_A :: DIV8 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , 8 => CLKSEL_A :: EVCH0 , 9 => CLKSEL_A :: EVCH1 , 10 => CLKSEL_A :: EVCH2 , 11 => CLKSEL_A :: EVCH3 , 12 => CLKSEL_A :: EVCH4 , 13 => CLKSEL_A :: EVCH5 , 14 => CLKSEL_A :: EVCH6 , 15 => CLKSEL_A :: EVCH7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKSEL_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } # [doc = "Checks if the value of the field is `EVCH0`"]
# [inline (always)]
pub fn is_evch0 (& self) -> bool { * self == CLKSEL_A :: EVCH0 } # [doc = "Checks if the value of the field is `EVCH1`"]
# [inline (always)]
pub fn is_evch1 (& self) -> bool { * self == CLKSEL_A :: EVCH1 } # [doc = "Checks if the value of the field is `EVCH2`"]
# [inline (always)]
pub fn is_evch2 (& self) -> bool { * self == CLKSEL_A :: EVCH2 } # [doc = "Checks if the value of the field is `EVCH3`"]
# [inline (always)]
pub fn is_evch3 (& self) -> bool { * self == CLKSEL_A :: EVCH3 } # [doc = "Checks if the value of the field is `EVCH4`"]
# [inline (always)]
pub fn is_evch4 (& self) -> bool { * self == CLKSEL_A :: EVCH4 } # [doc = "Checks if the value of the field is `EVCH5`"]
# [inline (always)]
pub fn is_evch5 (& self) -> bool { * self == CLKSEL_A :: EVCH5 } # [doc = "Checks if the value of the field is `EVCH6`"]
# [inline (always)]
pub fn is_evch6 (& self) -> bool { * self == CLKSEL_A :: EVCH6 } # [doc = "Checks if the value of the field is `EVCH7`"]
# [inline (always)]
pub fn is_evch7 (& self) -> bool { * self == CLKSEL_A :: EVCH7 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 4 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKSEL_A :: OFF) } # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn evch0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn evch1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn evch2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn evch3 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn evch4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn evch5 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn evch6 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn evch7 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH7) } } impl R { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope"]
SS = 3 , # [doc = "5: Dual Slope, Update on TOP"]
DS_T = 5 , # [doc = "6: Dual Slope, Update on TOP and BOTTOM"]
DS_TB = 6 , # [doc = "7: Dual Slope, Update on BOTTOM"]
DS_B = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SS) , 5 => Some (WGMODE_A :: DS_T) , 6 => Some (WGMODE_A :: DS_TB) , 7 => Some (WGMODE_A :: DS_B) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == WGMODE_A :: SS } # [doc = "Checks if the value of the field is `DS_T`"]
# [inline (always)]
pub fn is_ds_t (& self) -> bool { * self == WGMODE_A :: DS_T } # [doc = "Checks if the value of the field is `DS_TB`"]
# [inline (always)]
pub fn is_ds_tb (& self) -> bool { * self == WGMODE_A :: DS_TB } # [doc = "Checks if the value of the field is `DS_B`"]
# [inline (always)]
pub fn is_ds_b (& self) -> bool { * self == WGMODE_A :: DS_B } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (WGMODE_A :: SS) } # [doc = "Dual Slope, Update on TOP"]
# [inline (always)]
pub fn ds_t (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_T) } # [doc = "Dual Slope, Update on TOP and BOTTOM"]
# [inline (always)]
pub fn ds_tb (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_TB) } # [doc = "Dual Slope, Update on BOTTOM"]
# [inline (always)]
pub fn ds_b (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_B) } } # [doc = "Field `CCAEN` reader - Compare or Capture A Enable"]
pub type CCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCAEN` writer - Compare or Capture A Enable"]
pub type CCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCBEN` reader - Compare or Capture B Enable"]
pub type CCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCBEN` writer - Compare or Capture B Enable"]
pub type CCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCCEN` reader - Compare or Capture C Enable"]
pub type CCCEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCCEN` writer - Compare or Capture C Enable"]
pub type CCCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCDEN` reader - Compare or Capture D Enable"]
pub type CCDEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCDEN` writer - Compare or Capture D Enable"]
pub type CCDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
pub fn ccaen (& self) -> CCAEN_R { CCAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
pub fn ccben (& self) -> CCBEN_R { CCBEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare or Capture C Enable"]
# [inline (always)]
pub fn cccen (& self) -> CCCEN_R { CCCEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare or Capture D Enable"]
# [inline (always)]
pub fn ccden (& self) -> CCDEN_R { CCDEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
# [must_use]
pub fn ccaen (& mut self) -> CCAEN_W < 4 > { CCAEN_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
# [must_use]
pub fn ccben (& mut self) -> CCBEN_W < 5 > { CCBEN_W :: new (self) } # [doc = "Bit 6 - Compare or Capture C Enable"]
# [inline (always)]
# [must_use]
pub fn cccen (& mut self) -> CCCEN_W < 6 > { CCCEN_W :: new (self) } # [doc = "Bit 7 - Compare or Capture D Enable"]
# [inline (always)]
# [must_use]
pub fn ccden (& mut self) -> CCDEN_W < 7 > { CCDEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPC` reader - Compare C Output Value"]
pub type CMPC_R = crate :: BitReader < bool > ; # [doc = "Field `CMPC` writer - Compare C Output Value"]
pub type CMPC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPD` reader - Compare D Output Value"]
pub type CMPD_R = crate :: BitReader < bool > ; # [doc = "Field `CMPD` writer - Compare D Output Value"]
pub type CMPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare C Output Value"]
# [inline (always)]
pub fn cmpc (& self) -> CMPC_R { CMPC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare D Output Value"]
# [inline (always)]
pub fn cmpd (& self) -> CMPD_R { CMPD_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Bit 2 - Compare C Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpc (& mut self) -> CMPC_W < 2 > { CMPC_W :: new (self) } # [doc = "Bit 3 - Compare D Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpd (& mut self) -> CMPD_W < 3 > { CMPD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control Register D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Source Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
CH0 = 8 , # [doc = "9: Event Channel 1"]
CH1 = 9 , # [doc = "10: Event Channel 2"]
CH2 = 10 , # [doc = "11: Event Channel 3"]
CH3 = 11 , # [doc = "12: Event Channel 4"]
CH4 = 12 , # [doc = "13: Event Channel 5"]
CH5 = 13 , # [doc = "14: Event Channel 6"]
CH6 = 14 , # [doc = "15: Event Channel 7"]
CH7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: CH0) , 9 => Some (EVSEL_A :: CH1) , 10 => Some (EVSEL_A :: CH2) , 11 => Some (EVSEL_A :: CH3) , 12 => Some (EVSEL_A :: CH4) , 13 => Some (EVSEL_A :: CH5) , 14 => Some (EVSEL_A :: CH6) , 15 => Some (EVSEL_A :: CH7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVSEL_A :: CH0 } # [doc = "Checks if the value of the field is `CH1`"]
# [inline (always)]
pub fn is_ch1 (& self) -> bool { * self == EVSEL_A :: CH1 } # [doc = "Checks if the value of the field is `CH2`"]
# [inline (always)]
pub fn is_ch2 (& self) -> bool { * self == EVSEL_A :: CH2 } # [doc = "Checks if the value of the field is `CH3`"]
# [inline (always)]
pub fn is_ch3 (& self) -> bool { * self == EVSEL_A :: CH3 } # [doc = "Checks if the value of the field is `CH4`"]
# [inline (always)]
pub fn is_ch4 (& self) -> bool { * self == EVSEL_A :: CH4 } # [doc = "Checks if the value of the field is `CH5`"]
# [inline (always)]
pub fn is_ch5 (& self) -> bool { * self == EVSEL_A :: CH5 } # [doc = "Checks if the value of the field is `CH6`"]
# [inline (always)]
pub fn is_ch6 (& self) -> bool { * self == EVSEL_A :: CH6 } # [doc = "Checks if the value of the field is `CH7`"]
# [inline (always)]
pub fn is_ch7 (& self) -> bool { * self == EVSEL_A :: CH7 } } # [doc = "Field `EVSEL` writer - Event Source Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn ch1 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn ch2 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn ch3 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn ch4 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn ch5 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn ch6 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn ch7 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH7) } } # [doc = "Field `EVDLY` reader - Event Delay"]
pub type EVDLY_R = crate :: BitReader < bool > ; # [doc = "Field `EVDLY` writer - Event Delay"]
pub type EVDLY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No Event Action"]
OFF = 0 , # [doc = "1: Input Capture"]
CAPT = 1 , # [doc = "2: Externally Controlled Up/Down Count"]
UPDOWN = 2 , # [doc = "3: Quadrature Decode"]
QDEC = 3 , # [doc = "4: Restart"]
RESTART = 4 , # [doc = "5: Frequency Capture"]
FRQ = 5 , # [doc = "6: Pulse-width Capture"]
PW = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: CAPT) , 2 => Some (EVACT_A :: UPDOWN) , 3 => Some (EVACT_A :: QDEC) , 4 => Some (EVACT_A :: RESTART) , 5 => Some (EVACT_A :: FRQ) , 6 => Some (EVACT_A :: PW) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == EVACT_A :: CAPT } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } # [doc = "Checks if the value of the field is `QDEC`"]
# [inline (always)]
pub fn is_qdec (& self) -> bool { * self == EVACT_A :: QDEC } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == EVACT_A :: RESTART } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == EVACT_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == EVACT_A :: PW } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No Event Action"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Input Capture"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (EVACT_A :: CAPT) } # [doc = "Externally Controlled Up/Down Count"]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } # [doc = "Quadrature Decode"]
# [inline (always)]
pub fn qdec (self) -> & 'a mut W { self . variant (EVACT_A :: QDEC) } # [doc = "Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (EVACT_A :: RESTART) } # [doc = "Frequency Capture"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (EVACT_A :: FRQ) } # [doc = "Pulse-width Capture"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (EVACT_A :: PW) } } impl R { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
pub fn evdly (& self) -> EVDLY_R { EVDLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
# [must_use]
pub fn evdly (& mut self) -> EVDLY_W < 4 > { EVDLY_W :: new (self) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 5 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control Register E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BYTEM` reader - Byte Mode"]
pub type BYTEM_R = crate :: BitReader < bool > ; # [doc = "Field `BYTEM` writer - Byte Mode"]
pub type BYTEM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
pub fn bytem (& self) -> BYTEM_R { BYTEM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
# [must_use]
pub fn bytem (& mut self) -> BYTEM_W < 0 > { BYTEM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control Register F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFCLR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control Register F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFSET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGCLR (rw) register accessor: an alias for `Reg<CTRLGCLR_SPEC>`"]
pub type CTRLGCLR = crate :: Reg < ctrlgclr :: CTRLGCLR_SPEC > ; # [doc = "Control Register G Clear"]
pub mod ctrlgclr { # [doc = "Register `CTRLGCLR` reader"]
pub struct R (crate :: R < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGCLR` writer"]
pub struct W (crate :: W < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCCBV` reader - Compare or Capture C Buffer Valid"]
pub type CCCBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCCBV` writer - Compare or Capture C Buffer Valid"]
pub type CCCBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCDBV` reader - Compare or Capture D Buffer Valid"]
pub type CCDBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCDBV` writer - Compare or Capture D Buffer Valid"]
pub type CCDBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
pub fn cccbv (& self) -> CCCBV_R { CCCBV_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
pub fn ccdbv (& self) -> CCDBV_R { CCDBV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cccbv (& mut self) -> CCCBV_W < 3 > { CCCBV_W :: new (self) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccdbv (& mut self) -> CCDBV_W < 4 > { CCDBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgclr](index.html) module"]
pub struct CTRLGCLR_SPEC ; impl crate :: RegisterSpec for CTRLGCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgclr::R](R) reader structure"]
impl crate :: Readable for CTRLGCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgclr::W](W) writer structure"]
impl crate :: Writable for CTRLGCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGCLR to value 0"]
impl crate :: Resettable for CTRLGCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGSET (rw) register accessor: an alias for `Reg<CTRLGSET_SPEC>`"]
pub type CTRLGSET = crate :: Reg < ctrlgset :: CTRLGSET_SPEC > ; # [doc = "Control Register G Set"]
pub mod ctrlgset { # [doc = "Register `CTRLGSET` reader"]
pub struct R (crate :: R < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGSET` writer"]
pub struct W (crate :: W < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCCBV` reader - Compare or Capture C Buffer Valid"]
pub type CCCBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCCBV` writer - Compare or Capture C Buffer Valid"]
pub type CCCBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCDBV` reader - Compare or Capture D Buffer Valid"]
pub type CCDBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCDBV` writer - Compare or Capture D Buffer Valid"]
pub type CCDBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
pub fn cccbv (& self) -> CCCBV_R { CCCBV_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
pub fn ccdbv (& self) -> CCDBV_R { CCDBV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cccbv (& mut self) -> CCCBV_W < 3 > { CCCBV_W :: new (self) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccdbv (& mut self) -> CCDBV_W < 4 > { CCDBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgset](index.html) module"]
pub struct CTRLGSET_SPEC ; impl crate :: RegisterSpec for CTRLGSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgset::R](R) reader structure"]
impl crate :: Readable for CTRLGSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgset::W](W) writer structure"]
impl crate :: Writable for CTRLGSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGSET to value 0"]
impl crate :: Resettable for CTRLGSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLA (rw) register accessor: an alias for `Reg<INTCTRLA_SPEC>`"]
pub type INTCTRLA = crate :: Reg < intctrla :: INTCTRLA_SPEC > ; # [doc = "Interrupt Control Register A"]
pub mod intctrla { # [doc = "Register `INTCTRLA` reader"]
pub struct R (crate :: R < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLA` writer"]
pub struct W (crate :: W < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow interrupt level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow interrupt level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `ERRINTLVL` reader - Error Interrupt Level"]
pub type ERRINTLVL_R = crate :: FieldReader < u8 , ERRINTLVL_A > ; # [doc = "Error Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ERRINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < ERRINTLVL_A > for u8 { # [inline (always)]
fn from (variant : ERRINTLVL_A) -> Self { variant as _ } } impl ERRINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ERRINTLVL_A { match self . bits { 0 => ERRINTLVL_A :: OFF , 1 => ERRINTLVL_A :: LO , 2 => ERRINTLVL_A :: MED , 3 => ERRINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ERRINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == ERRINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == ERRINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == ERRINTLVL_A :: HI } } # [doc = "Field `ERRINTLVL` writer - Error Interrupt Level"]
pub type ERRINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , ERRINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > ERRINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
pub fn errintlvl (& self) -> ERRINTLVL_R { ERRINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn errintlvl (& mut self) -> ERRINTLVL_W < 2 > { ERRINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrla](index.html) module"]
pub struct INTCTRLA_SPEC ; impl crate :: RegisterSpec for INTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrla::R](R) reader structure"]
impl crate :: Readable for INTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrla::W](W) writer structure"]
impl crate :: Writable for INTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLA to value 0"]
impl crate :: Resettable for INTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLB (rw) register accessor: an alias for `Reg<INTCTRLB_SPEC>`"]
pub type INTCTRLB = crate :: Reg < intctrlb :: INTCTRLB_SPEC > ; # [doc = "Interrupt Control Register B"]
pub mod intctrlb { # [doc = "Register `INTCTRLB` reader"]
pub struct R (crate :: R < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLB` writer"]
pub struct W (crate :: W < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCAINTLVL` reader - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_R = crate :: FieldReader < u8 , CCAINTLVL_A > ; # [doc = "Compare or Capture A Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCAINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCAINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCAINTLVL_A) -> Self { variant as _ } } impl CCAINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCAINTLVL_A { match self . bits { 0 => CCAINTLVL_A :: OFF , 1 => CCAINTLVL_A :: LO , 2 => CCAINTLVL_A :: MED , 3 => CCAINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCAINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCAINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCAINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCAINTLVL_A :: HI } } # [doc = "Field `CCAINTLVL` writer - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCAINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCAINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: HI) } } # [doc = "Field `CCBINTLVL` reader - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_R = crate :: FieldReader < u8 , CCBINTLVL_A > ; # [doc = "Compare or Capture B Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCBINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCBINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCBINTLVL_A) -> Self { variant as _ } } impl CCBINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCBINTLVL_A { match self . bits { 0 => CCBINTLVL_A :: OFF , 1 => CCBINTLVL_A :: LO , 2 => CCBINTLVL_A :: MED , 3 => CCBINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCBINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCBINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCBINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCBINTLVL_A :: HI } } # [doc = "Field `CCBINTLVL` writer - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCBINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCBINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: HI) } } # [doc = "Field `CCCINTLVL` reader - Compare or Capture C Interrupt Level"]
pub type CCCINTLVL_R = crate :: FieldReader < u8 , CCCINTLVL_A > ; # [doc = "Compare or Capture C Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCCINTLVL_A) -> Self { variant as _ } } impl CCCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCCINTLVL_A { match self . bits { 0 => CCCINTLVL_A :: OFF , 1 => CCCINTLVL_A :: LO , 2 => CCCINTLVL_A :: MED , 3 => CCCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCCINTLVL_A :: HI } } # [doc = "Field `CCCINTLVL` writer - Compare or Capture C Interrupt Level"]
pub type CCCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: HI) } } # [doc = "Field `CCDINTLVL` reader - Compare or Capture D Interrupt Level"]
pub type CCDINTLVL_R = crate :: FieldReader < u8 , CCDINTLVL_A > ; # [doc = "Compare or Capture D Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCDINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCDINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCDINTLVL_A) -> Self { variant as _ } } impl CCDINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCDINTLVL_A { match self . bits { 0 => CCDINTLVL_A :: OFF , 1 => CCDINTLVL_A :: LO , 2 => CCDINTLVL_A :: MED , 3 => CCDINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCDINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCDINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCDINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCDINTLVL_A :: HI } } # [doc = "Field `CCDINTLVL` writer - Compare or Capture D Interrupt Level"]
pub type CCDINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCDINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCDINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
pub fn ccaintlvl (& self) -> CCAINTLVL_R { CCAINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
pub fn ccbintlvl (& self) -> CCBINTLVL_R { CCBINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare or Capture C Interrupt Level"]
# [inline (always)]
pub fn cccintlvl (& self) -> CCCINTLVL_R { CCCINTLVL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare or Capture D Interrupt Level"]
# [inline (always)]
pub fn ccdintlvl (& self) -> CCDINTLVL_R { CCDINTLVL_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccaintlvl (& mut self) -> CCAINTLVL_W < 0 > { CCAINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccbintlvl (& mut self) -> CCBINTLVL_W < 2 > { CCBINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Compare or Capture C Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn cccintlvl (& mut self) -> CCCINTLVL_W < 4 > { CCCINTLVL_W :: new (self) } # [doc = "Bits 6:7 - Compare or Capture D Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccdintlvl (& mut self) -> CCDINTLVL_W < 6 > { CCDINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrlb](index.html) module"]
pub struct INTCTRLB_SPEC ; impl crate :: RegisterSpec for INTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrlb::R](R) reader structure"]
impl crate :: Readable for INTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrlb::W](W) writer structure"]
impl crate :: Writable for INTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLB to value 0"]
impl crate :: Resettable for INTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `ERRIF` reader - Error Interrupt Flag"]
pub type ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `ERRIF` writer - Error Interrupt Flag"]
pub type ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCAIF` reader - Compare or Capture A Interrupt Flag"]
pub type CCAIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCAIF` writer - Compare or Capture A Interrupt Flag"]
pub type CCAIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCBIF` reader - Compare or Capture B Interrupt Flag"]
pub type CCBIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCBIF` writer - Compare or Capture B Interrupt Flag"]
pub type CCBIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCCIF` reader - Compare or Capture C Interrupt Flag"]
pub type CCCIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCCIF` writer - Compare or Capture C Interrupt Flag"]
pub type CCCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCDIF` reader - Compare or Capture D Interrupt Flag"]
pub type CCDIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCDIF` writer - Compare or Capture D Interrupt Flag"]
pub type CCDIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
pub fn errif (& self) -> ERRIF_R { ERRIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
pub fn ccaif (& self) -> CCAIF_R { CCAIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
pub fn ccbif (& self) -> CCBIF_R { CCBIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare or Capture C Interrupt Flag"]
# [inline (always)]
pub fn cccif (& self) -> CCCIF_R { CCCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare or Capture D Interrupt Flag"]
# [inline (always)]
pub fn ccdif (& self) -> CCDIF_R { CCDIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn errif (& mut self) -> ERRIF_W < 1 > { ERRIF_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccaif (& mut self) -> CCAIF_W < 4 > { CCAIF_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccbif (& mut self) -> CCBIF_W < 5 > { CCBIF_W :: new (self) } # [doc = "Bit 6 - Compare or Capture C Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn cccif (& mut self) -> CCCIF_W < 6 > { CCCIF_W :: new (self) } # [doc = "Bit 7 - Compare or Capture D Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccdif (& mut self) -> CCDIF_W < 7 > { CCDIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct TCC1 { _marker : PhantomData < * const () > } unsafe impl Send for TCC1 { } impl TCC1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcc1 :: RegisterBlock = 0x0840 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcc1 :: RegisterBlock { Self :: PTR } } impl Deref for TCC1 { type Target = tcc1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCC1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCC1") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod tcc1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control Register D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control Register E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control Register A"]
pub intctrla : INTCTRLA , # [doc = "0x07 - Interrupt Control Register B"]
pub intctrlb : INTCTRLB , # [doc = "0x08 - Control Register F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x09 - Control Register F Set"]
pub ctrlfset : CTRLFSET , # [doc = "0x0a - Control Register G Clear"]
pub ctrlgclr : CTRLGCLR , # [doc = "0x0b - Control Register G Set"]
pub ctrlgset : CTRLGSET , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved12 : [u8 ; 0x02]
, # [doc = "0x0f - Temporary Register For 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare or Capture A"]
pub cca : CCA , # [doc = "0x2a - Compare or Capture B"]
pub ccb : CCB , _reserved17 : [u8 ; 0x0a]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare Or Capture A Buffer"]
pub ccabuf : CCABUF , # [doc = "0x3a - Compare Or Capture B Buffer"]
pub ccbbuf : CCBBUF , } # [doc = "CCA (rw) register accessor: an alias for `Reg<CCA_SPEC>`"]
pub type CCA = crate :: Reg < cca :: CCA_SPEC > ; # [doc = "Compare or Capture A"]
pub mod cca { # [doc = "Register `CCA` reader"]
pub struct R (crate :: R < CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA` writer"]
pub struct W (crate :: W < CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca](index.html) module"]
pub struct CCA_SPEC ; impl crate :: RegisterSpec for CCA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cca::R](R) reader structure"]
impl crate :: Readable for CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca::W](W) writer structure"]
impl crate :: Writable for CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA to value 0"]
impl crate :: Resettable for CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCABUF (rw) register accessor: an alias for `Reg<CCABUF_SPEC>`"]
pub type CCABUF = crate :: Reg < ccabuf :: CCABUF_SPEC > ; # [doc = "Compare Or Capture A Buffer"]
pub mod ccabuf { # [doc = "Register `CCABUF` reader"]
pub struct R (crate :: R < CCABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCABUF` writer"]
pub struct W (crate :: W < CCABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCABUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture A Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccabuf](index.html) module"]
pub struct CCABUF_SPEC ; impl crate :: RegisterSpec for CCABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccabuf::R](R) reader structure"]
impl crate :: Readable for CCABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccabuf::W](W) writer structure"]
impl crate :: Writable for CCABUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCABUF to value 0"]
impl crate :: Resettable for CCABUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCB (rw) register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare or Capture B"]
pub mod ccb { # [doc = "Register `CCB` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCB to value 0"]
impl crate :: Resettable for CCB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCBBUF (rw) register accessor: an alias for `Reg<CCBBUF_SPEC>`"]
pub type CCBBUF = crate :: Reg < ccbbuf :: CCBBUF_SPEC > ; # [doc = "Compare Or Capture B Buffer"]
pub mod ccbbuf { # [doc = "Register `CCBBUF` reader"]
pub struct R (crate :: R < CCBBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCBBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCBBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCBBUF` writer"]
pub struct W (crate :: W < CCBBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCBBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCBBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture B Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccbbuf](index.html) module"]
pub struct CCBBUF_SPEC ; impl crate :: RegisterSpec for CCBBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccbbuf::R](R) reader structure"]
impl crate :: Readable for CCBBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccbbuf::W](W) writer structure"]
impl crate :: Writable for CCBBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCBBUF to value 0"]
impl crate :: Resettable for CCBBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Timer Off"]
OFF = 0 , # [doc = "1: System Clock"]
DIV1 = 1 , # [doc = "2: System Clock / 2"]
DIV2 = 2 , # [doc = "3: System Clock / 4"]
DIV4 = 3 , # [doc = "4: System Clock / 8"]
DIV8 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , # [doc = "8: Event Channel 0"]
EVCH0 = 8 , # [doc = "9: Event Channel 1"]
EVCH1 = 9 , # [doc = "10: Event Channel 2"]
EVCH2 = 10 , # [doc = "11: Event Channel 3"]
EVCH3 = 11 , # [doc = "12: Event Channel 4"]
EVCH4 = 12 , # [doc = "13: Event Channel 5"]
EVCH5 = 13 , # [doc = "14: Event Channel 6"]
EVCH6 = 14 , # [doc = "15: Event Channel 7"]
EVCH7 = 15 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OFF , 1 => CLKSEL_A :: DIV1 , 2 => CLKSEL_A :: DIV2 , 3 => CLKSEL_A :: DIV4 , 4 => CLKSEL_A :: DIV8 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , 8 => CLKSEL_A :: EVCH0 , 9 => CLKSEL_A :: EVCH1 , 10 => CLKSEL_A :: EVCH2 , 11 => CLKSEL_A :: EVCH3 , 12 => CLKSEL_A :: EVCH4 , 13 => CLKSEL_A :: EVCH5 , 14 => CLKSEL_A :: EVCH6 , 15 => CLKSEL_A :: EVCH7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKSEL_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } # [doc = "Checks if the value of the field is `EVCH0`"]
# [inline (always)]
pub fn is_evch0 (& self) -> bool { * self == CLKSEL_A :: EVCH0 } # [doc = "Checks if the value of the field is `EVCH1`"]
# [inline (always)]
pub fn is_evch1 (& self) -> bool { * self == CLKSEL_A :: EVCH1 } # [doc = "Checks if the value of the field is `EVCH2`"]
# [inline (always)]
pub fn is_evch2 (& self) -> bool { * self == CLKSEL_A :: EVCH2 } # [doc = "Checks if the value of the field is `EVCH3`"]
# [inline (always)]
pub fn is_evch3 (& self) -> bool { * self == CLKSEL_A :: EVCH3 } # [doc = "Checks if the value of the field is `EVCH4`"]
# [inline (always)]
pub fn is_evch4 (& self) -> bool { * self == CLKSEL_A :: EVCH4 } # [doc = "Checks if the value of the field is `EVCH5`"]
# [inline (always)]
pub fn is_evch5 (& self) -> bool { * self == CLKSEL_A :: EVCH5 } # [doc = "Checks if the value of the field is `EVCH6`"]
# [inline (always)]
pub fn is_evch6 (& self) -> bool { * self == CLKSEL_A :: EVCH6 } # [doc = "Checks if the value of the field is `EVCH7`"]
# [inline (always)]
pub fn is_evch7 (& self) -> bool { * self == CLKSEL_A :: EVCH7 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 4 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKSEL_A :: OFF) } # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn evch0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn evch1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn evch2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn evch3 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn evch4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn evch5 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn evch6 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn evch7 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH7) } } impl R { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope"]
SS = 3 , # [doc = "5: Dual Slope, Update on TOP"]
DS_T = 5 , # [doc = "6: Dual Slope, Update on TOP and BOTTOM"]
DS_TB = 6 , # [doc = "7: Dual Slope, Update on BOTTOM"]
DS_B = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SS) , 5 => Some (WGMODE_A :: DS_T) , 6 => Some (WGMODE_A :: DS_TB) , 7 => Some (WGMODE_A :: DS_B) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == WGMODE_A :: SS } # [doc = "Checks if the value of the field is `DS_T`"]
# [inline (always)]
pub fn is_ds_t (& self) -> bool { * self == WGMODE_A :: DS_T } # [doc = "Checks if the value of the field is `DS_TB`"]
# [inline (always)]
pub fn is_ds_tb (& self) -> bool { * self == WGMODE_A :: DS_TB } # [doc = "Checks if the value of the field is `DS_B`"]
# [inline (always)]
pub fn is_ds_b (& self) -> bool { * self == WGMODE_A :: DS_B } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (WGMODE_A :: SS) } # [doc = "Dual Slope, Update on TOP"]
# [inline (always)]
pub fn ds_t (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_T) } # [doc = "Dual Slope, Update on TOP and BOTTOM"]
# [inline (always)]
pub fn ds_tb (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_TB) } # [doc = "Dual Slope, Update on BOTTOM"]
# [inline (always)]
pub fn ds_b (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_B) } } # [doc = "Field `CCAEN` reader - Compare or Capture A Enable"]
pub type CCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCAEN` writer - Compare or Capture A Enable"]
pub type CCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCBEN` reader - Compare or Capture B Enable"]
pub type CCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCBEN` writer - Compare or Capture B Enable"]
pub type CCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
pub fn ccaen (& self) -> CCAEN_R { CCAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
pub fn ccben (& self) -> CCBEN_R { CCBEN_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
# [must_use]
pub fn ccaen (& mut self) -> CCAEN_W < 4 > { CCAEN_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
# [must_use]
pub fn ccben (& mut self) -> CCBEN_W < 5 > { CCBEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control Register D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Source Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
CH0 = 8 , # [doc = "9: Event Channel 1"]
CH1 = 9 , # [doc = "10: Event Channel 2"]
CH2 = 10 , # [doc = "11: Event Channel 3"]
CH3 = 11 , # [doc = "12: Event Channel 4"]
CH4 = 12 , # [doc = "13: Event Channel 5"]
CH5 = 13 , # [doc = "14: Event Channel 6"]
CH6 = 14 , # [doc = "15: Event Channel 7"]
CH7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: CH0) , 9 => Some (EVSEL_A :: CH1) , 10 => Some (EVSEL_A :: CH2) , 11 => Some (EVSEL_A :: CH3) , 12 => Some (EVSEL_A :: CH4) , 13 => Some (EVSEL_A :: CH5) , 14 => Some (EVSEL_A :: CH6) , 15 => Some (EVSEL_A :: CH7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVSEL_A :: CH0 } # [doc = "Checks if the value of the field is `CH1`"]
# [inline (always)]
pub fn is_ch1 (& self) -> bool { * self == EVSEL_A :: CH1 } # [doc = "Checks if the value of the field is `CH2`"]
# [inline (always)]
pub fn is_ch2 (& self) -> bool { * self == EVSEL_A :: CH2 } # [doc = "Checks if the value of the field is `CH3`"]
# [inline (always)]
pub fn is_ch3 (& self) -> bool { * self == EVSEL_A :: CH3 } # [doc = "Checks if the value of the field is `CH4`"]
# [inline (always)]
pub fn is_ch4 (& self) -> bool { * self == EVSEL_A :: CH4 } # [doc = "Checks if the value of the field is `CH5`"]
# [inline (always)]
pub fn is_ch5 (& self) -> bool { * self == EVSEL_A :: CH5 } # [doc = "Checks if the value of the field is `CH6`"]
# [inline (always)]
pub fn is_ch6 (& self) -> bool { * self == EVSEL_A :: CH6 } # [doc = "Checks if the value of the field is `CH7`"]
# [inline (always)]
pub fn is_ch7 (& self) -> bool { * self == EVSEL_A :: CH7 } } # [doc = "Field `EVSEL` writer - Event Source Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn ch1 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn ch2 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn ch3 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn ch4 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn ch5 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn ch6 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn ch7 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH7) } } # [doc = "Field `EVDLY` reader - Event Delay"]
pub type EVDLY_R = crate :: BitReader < bool > ; # [doc = "Field `EVDLY` writer - Event Delay"]
pub type EVDLY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No Event Action"]
OFF = 0 , # [doc = "1: Input Capture"]
CAPT = 1 , # [doc = "2: Externally Controlled Up/Down Count"]
UPDOWN = 2 , # [doc = "3: Quadrature Decode"]
QDEC = 3 , # [doc = "4: Restart"]
RESTART = 4 , # [doc = "5: Frequency Capture"]
FRQ = 5 , # [doc = "6: Pulse-width Capture"]
PW = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: CAPT) , 2 => Some (EVACT_A :: UPDOWN) , 3 => Some (EVACT_A :: QDEC) , 4 => Some (EVACT_A :: RESTART) , 5 => Some (EVACT_A :: FRQ) , 6 => Some (EVACT_A :: PW) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == EVACT_A :: CAPT } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } # [doc = "Checks if the value of the field is `QDEC`"]
# [inline (always)]
pub fn is_qdec (& self) -> bool { * self == EVACT_A :: QDEC } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == EVACT_A :: RESTART } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == EVACT_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == EVACT_A :: PW } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No Event Action"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Input Capture"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (EVACT_A :: CAPT) } # [doc = "Externally Controlled Up/Down Count"]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } # [doc = "Quadrature Decode"]
# [inline (always)]
pub fn qdec (self) -> & 'a mut W { self . variant (EVACT_A :: QDEC) } # [doc = "Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (EVACT_A :: RESTART) } # [doc = "Frequency Capture"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (EVACT_A :: FRQ) } # [doc = "Pulse-width Capture"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (EVACT_A :: PW) } } impl R { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
pub fn evdly (& self) -> EVDLY_R { EVDLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
# [must_use]
pub fn evdly (& mut self) -> EVDLY_W < 4 > { EVDLY_W :: new (self) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 5 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control Register E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BYTEM` reader - Byte Mode"]
pub type BYTEM_R = crate :: BitReader < bool > ; # [doc = "Field `BYTEM` writer - Byte Mode"]
pub type BYTEM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
pub fn bytem (& self) -> BYTEM_R { BYTEM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
# [must_use]
pub fn bytem (& mut self) -> BYTEM_W < 0 > { BYTEM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control Register F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFCLR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control Register F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFSET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGCLR (rw) register accessor: an alias for `Reg<CTRLGCLR_SPEC>`"]
pub type CTRLGCLR = crate :: Reg < ctrlgclr :: CTRLGCLR_SPEC > ; # [doc = "Control Register G Clear"]
pub mod ctrlgclr { # [doc = "Register `CTRLGCLR` reader"]
pub struct R (crate :: R < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGCLR` writer"]
pub struct W (crate :: W < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgclr](index.html) module"]
pub struct CTRLGCLR_SPEC ; impl crate :: RegisterSpec for CTRLGCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgclr::R](R) reader structure"]
impl crate :: Readable for CTRLGCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgclr::W](W) writer structure"]
impl crate :: Writable for CTRLGCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGCLR to value 0"]
impl crate :: Resettable for CTRLGCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGSET (rw) register accessor: an alias for `Reg<CTRLGSET_SPEC>`"]
pub type CTRLGSET = crate :: Reg < ctrlgset :: CTRLGSET_SPEC > ; # [doc = "Control Register G Set"]
pub mod ctrlgset { # [doc = "Register `CTRLGSET` reader"]
pub struct R (crate :: R < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGSET` writer"]
pub struct W (crate :: W < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgset](index.html) module"]
pub struct CTRLGSET_SPEC ; impl crate :: RegisterSpec for CTRLGSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgset::R](R) reader structure"]
impl crate :: Readable for CTRLGSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgset::W](W) writer structure"]
impl crate :: Writable for CTRLGSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGSET to value 0"]
impl crate :: Resettable for CTRLGSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLA (rw) register accessor: an alias for `Reg<INTCTRLA_SPEC>`"]
pub type INTCTRLA = crate :: Reg < intctrla :: INTCTRLA_SPEC > ; # [doc = "Interrupt Control Register A"]
pub mod intctrla { # [doc = "Register `INTCTRLA` reader"]
pub struct R (crate :: R < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLA` writer"]
pub struct W (crate :: W < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow interrupt level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow interrupt level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `ERRINTLVL` reader - Error Interrupt Level"]
pub type ERRINTLVL_R = crate :: FieldReader < u8 , ERRINTLVL_A > ; # [doc = "Error Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ERRINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < ERRINTLVL_A > for u8 { # [inline (always)]
fn from (variant : ERRINTLVL_A) -> Self { variant as _ } } impl ERRINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ERRINTLVL_A { match self . bits { 0 => ERRINTLVL_A :: OFF , 1 => ERRINTLVL_A :: LO , 2 => ERRINTLVL_A :: MED , 3 => ERRINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ERRINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == ERRINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == ERRINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == ERRINTLVL_A :: HI } } # [doc = "Field `ERRINTLVL` writer - Error Interrupt Level"]
pub type ERRINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , ERRINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > ERRINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
pub fn errintlvl (& self) -> ERRINTLVL_R { ERRINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn errintlvl (& mut self) -> ERRINTLVL_W < 2 > { ERRINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrla](index.html) module"]
pub struct INTCTRLA_SPEC ; impl crate :: RegisterSpec for INTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrla::R](R) reader structure"]
impl crate :: Readable for INTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrla::W](W) writer structure"]
impl crate :: Writable for INTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLA to value 0"]
impl crate :: Resettable for INTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLB (rw) register accessor: an alias for `Reg<INTCTRLB_SPEC>`"]
pub type INTCTRLB = crate :: Reg < intctrlb :: INTCTRLB_SPEC > ; # [doc = "Interrupt Control Register B"]
pub mod intctrlb { # [doc = "Register `INTCTRLB` reader"]
pub struct R (crate :: R < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLB` writer"]
pub struct W (crate :: W < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCAINTLVL` reader - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_R = crate :: FieldReader < u8 , CCAINTLVL_A > ; # [doc = "Compare or Capture A Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCAINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCAINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCAINTLVL_A) -> Self { variant as _ } } impl CCAINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCAINTLVL_A { match self . bits { 0 => CCAINTLVL_A :: OFF , 1 => CCAINTLVL_A :: LO , 2 => CCAINTLVL_A :: MED , 3 => CCAINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCAINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCAINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCAINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCAINTLVL_A :: HI } } # [doc = "Field `CCAINTLVL` writer - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCAINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCAINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: HI) } } # [doc = "Field `CCBINTLVL` reader - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_R = crate :: FieldReader < u8 , CCBINTLVL_A > ; # [doc = "Compare or Capture B Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCBINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCBINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCBINTLVL_A) -> Self { variant as _ } } impl CCBINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCBINTLVL_A { match self . bits { 0 => CCBINTLVL_A :: OFF , 1 => CCBINTLVL_A :: LO , 2 => CCBINTLVL_A :: MED , 3 => CCBINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCBINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCBINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCBINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCBINTLVL_A :: HI } } # [doc = "Field `CCBINTLVL` writer - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCBINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCBINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
pub fn ccaintlvl (& self) -> CCAINTLVL_R { CCAINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
pub fn ccbintlvl (& self) -> CCBINTLVL_R { CCBINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccaintlvl (& mut self) -> CCAINTLVL_W < 0 > { CCAINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccbintlvl (& mut self) -> CCBINTLVL_W < 2 > { CCBINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrlb](index.html) module"]
pub struct INTCTRLB_SPEC ; impl crate :: RegisterSpec for INTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrlb::R](R) reader structure"]
impl crate :: Readable for INTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrlb::W](W) writer structure"]
impl crate :: Writable for INTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLB to value 0"]
impl crate :: Resettable for INTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `ERRIF` reader - Error Interrupt Flag"]
pub type ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `ERRIF` writer - Error Interrupt Flag"]
pub type ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCAIF` reader - Compare or Capture A Interrupt Flag"]
pub type CCAIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCAIF` writer - Compare or Capture A Interrupt Flag"]
pub type CCAIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCBIF` reader - Compare or Capture B Interrupt Flag"]
pub type CCBIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCBIF` writer - Compare or Capture B Interrupt Flag"]
pub type CCBIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
pub fn errif (& self) -> ERRIF_R { ERRIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
pub fn ccaif (& self) -> CCAIF_R { CCAIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
pub fn ccbif (& self) -> CCBIF_R { CCBIF_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn errif (& mut self) -> ERRIF_W < 1 > { ERRIF_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccaif (& mut self) -> CCAIF_W < 4 > { CCAIF_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccbif (& mut self) -> CCBIF_W < 5 > { CCBIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct TCD0 { _marker : PhantomData < * const () > } unsafe impl Send for TCD0 { } impl TCD0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcd0 :: RegisterBlock = 0x0900 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcd0 :: RegisterBlock { Self :: PTR } } impl Deref for TCD0 { type Target = tcd0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCD0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCD0") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod tcd0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control Register D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control Register E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control Register A"]
pub intctrla : INTCTRLA , # [doc = "0x07 - Interrupt Control Register B"]
pub intctrlb : INTCTRLB , # [doc = "0x08 - Control Register F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x09 - Control Register F Set"]
pub ctrlfset : CTRLFSET , # [doc = "0x0a - Control Register G Clear"]
pub ctrlgclr : CTRLGCLR , # [doc = "0x0b - Control Register G Set"]
pub ctrlgset : CTRLGSET , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved12 : [u8 ; 0x02]
, # [doc = "0x0f - Temporary Register For 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare or Capture A"]
pub cca : CCA , # [doc = "0x2a - Compare or Capture B"]
pub ccb : CCB , # [doc = "0x2c - Compare or Capture C"]
pub ccc : CCC , # [doc = "0x2e - Compare or Capture D"]
pub ccd : CCD , _reserved19 : [u8 ; 0x06]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare Or Capture A Buffer"]
pub ccabuf : CCABUF , # [doc = "0x3a - Compare Or Capture B Buffer"]
pub ccbbuf : CCBBUF , # [doc = "0x3c - Compare Or Capture C Buffer"]
pub cccbuf : CCCBUF , # [doc = "0x3e - Compare Or Capture D Buffer"]
pub ccdbuf : CCDBUF , } # [doc = "CCA (rw) register accessor: an alias for `Reg<CCA_SPEC>`"]
pub type CCA = crate :: Reg < cca :: CCA_SPEC > ; # [doc = "Compare or Capture A"]
pub mod cca { # [doc = "Register `CCA` reader"]
pub struct R (crate :: R < CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA` writer"]
pub struct W (crate :: W < CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca](index.html) module"]
pub struct CCA_SPEC ; impl crate :: RegisterSpec for CCA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cca::R](R) reader structure"]
impl crate :: Readable for CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca::W](W) writer structure"]
impl crate :: Writable for CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA to value 0"]
impl crate :: Resettable for CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCABUF (rw) register accessor: an alias for `Reg<CCABUF_SPEC>`"]
pub type CCABUF = crate :: Reg < ccabuf :: CCABUF_SPEC > ; # [doc = "Compare Or Capture A Buffer"]
pub mod ccabuf { # [doc = "Register `CCABUF` reader"]
pub struct R (crate :: R < CCABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCABUF` writer"]
pub struct W (crate :: W < CCABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCABUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture A Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccabuf](index.html) module"]
pub struct CCABUF_SPEC ; impl crate :: RegisterSpec for CCABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccabuf::R](R) reader structure"]
impl crate :: Readable for CCABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccabuf::W](W) writer structure"]
impl crate :: Writable for CCABUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCABUF to value 0"]
impl crate :: Resettable for CCABUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCB (rw) register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare or Capture B"]
pub mod ccb { # [doc = "Register `CCB` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCB to value 0"]
impl crate :: Resettable for CCB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCBBUF (rw) register accessor: an alias for `Reg<CCBBUF_SPEC>`"]
pub type CCBBUF = crate :: Reg < ccbbuf :: CCBBUF_SPEC > ; # [doc = "Compare Or Capture B Buffer"]
pub mod ccbbuf { # [doc = "Register `CCBBUF` reader"]
pub struct R (crate :: R < CCBBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCBBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCBBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCBBUF` writer"]
pub struct W (crate :: W < CCBBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCBBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCBBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture B Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccbbuf](index.html) module"]
pub struct CCBBUF_SPEC ; impl crate :: RegisterSpec for CCBBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccbbuf::R](R) reader structure"]
impl crate :: Readable for CCBBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccbbuf::W](W) writer structure"]
impl crate :: Writable for CCBBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCBBUF to value 0"]
impl crate :: Resettable for CCBBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCC (rw) register accessor: an alias for `Reg<CCC_SPEC>`"]
pub type CCC = crate :: Reg < ccc :: CCC_SPEC > ; # [doc = "Compare or Capture C"]
pub mod ccc { # [doc = "Register `CCC` reader"]
pub struct R (crate :: R < CCC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCC` writer"]
pub struct W (crate :: W < CCC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccc](index.html) module"]
pub struct CCC_SPEC ; impl crate :: RegisterSpec for CCC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccc::R](R) reader structure"]
impl crate :: Readable for CCC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccc::W](W) writer structure"]
impl crate :: Writable for CCC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCC to value 0"]
impl crate :: Resettable for CCC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCCBUF (rw) register accessor: an alias for `Reg<CCCBUF_SPEC>`"]
pub type CCCBUF = crate :: Reg < cccbuf :: CCCBUF_SPEC > ; # [doc = "Compare Or Capture C Buffer"]
pub mod cccbuf { # [doc = "Register `CCCBUF` reader"]
pub struct R (crate :: R < CCCBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCCBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCCBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCCBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCCBUF` writer"]
pub struct W (crate :: W < CCCBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCCBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCCBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCCBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture C Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cccbuf](index.html) module"]
pub struct CCCBUF_SPEC ; impl crate :: RegisterSpec for CCCBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cccbuf::R](R) reader structure"]
impl crate :: Readable for CCCBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cccbuf::W](W) writer structure"]
impl crate :: Writable for CCCBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCCBUF to value 0"]
impl crate :: Resettable for CCCBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCD (rw) register accessor: an alias for `Reg<CCD_SPEC>`"]
pub type CCD = crate :: Reg < ccd :: CCD_SPEC > ; # [doc = "Compare or Capture D"]
pub mod ccd { # [doc = "Register `CCD` reader"]
pub struct R (crate :: R < CCD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCD` writer"]
pub struct W (crate :: W < CCD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccd](index.html) module"]
pub struct CCD_SPEC ; impl crate :: RegisterSpec for CCD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccd::R](R) reader structure"]
impl crate :: Readable for CCD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccd::W](W) writer structure"]
impl crate :: Writable for CCD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCD to value 0"]
impl crate :: Resettable for CCD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCDBUF (rw) register accessor: an alias for `Reg<CCDBUF_SPEC>`"]
pub type CCDBUF = crate :: Reg < ccdbuf :: CCDBUF_SPEC > ; # [doc = "Compare Or Capture D Buffer"]
pub mod ccdbuf { # [doc = "Register `CCDBUF` reader"]
pub struct R (crate :: R < CCDBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCDBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCDBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCDBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCDBUF` writer"]
pub struct W (crate :: W < CCDBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCDBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCDBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCDBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture D Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccdbuf](index.html) module"]
pub struct CCDBUF_SPEC ; impl crate :: RegisterSpec for CCDBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccdbuf::R](R) reader structure"]
impl crate :: Readable for CCDBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccdbuf::W](W) writer structure"]
impl crate :: Writable for CCDBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCDBUF to value 0"]
impl crate :: Resettable for CCDBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Timer Off"]
OFF = 0 , # [doc = "1: System Clock"]
DIV1 = 1 , # [doc = "2: System Clock / 2"]
DIV2 = 2 , # [doc = "3: System Clock / 4"]
DIV4 = 3 , # [doc = "4: System Clock / 8"]
DIV8 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , # [doc = "8: Event Channel 0"]
EVCH0 = 8 , # [doc = "9: Event Channel 1"]
EVCH1 = 9 , # [doc = "10: Event Channel 2"]
EVCH2 = 10 , # [doc = "11: Event Channel 3"]
EVCH3 = 11 , # [doc = "12: Event Channel 4"]
EVCH4 = 12 , # [doc = "13: Event Channel 5"]
EVCH5 = 13 , # [doc = "14: Event Channel 6"]
EVCH6 = 14 , # [doc = "15: Event Channel 7"]
EVCH7 = 15 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OFF , 1 => CLKSEL_A :: DIV1 , 2 => CLKSEL_A :: DIV2 , 3 => CLKSEL_A :: DIV4 , 4 => CLKSEL_A :: DIV8 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , 8 => CLKSEL_A :: EVCH0 , 9 => CLKSEL_A :: EVCH1 , 10 => CLKSEL_A :: EVCH2 , 11 => CLKSEL_A :: EVCH3 , 12 => CLKSEL_A :: EVCH4 , 13 => CLKSEL_A :: EVCH5 , 14 => CLKSEL_A :: EVCH6 , 15 => CLKSEL_A :: EVCH7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKSEL_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } # [doc = "Checks if the value of the field is `EVCH0`"]
# [inline (always)]
pub fn is_evch0 (& self) -> bool { * self == CLKSEL_A :: EVCH0 } # [doc = "Checks if the value of the field is `EVCH1`"]
# [inline (always)]
pub fn is_evch1 (& self) -> bool { * self == CLKSEL_A :: EVCH1 } # [doc = "Checks if the value of the field is `EVCH2`"]
# [inline (always)]
pub fn is_evch2 (& self) -> bool { * self == CLKSEL_A :: EVCH2 } # [doc = "Checks if the value of the field is `EVCH3`"]
# [inline (always)]
pub fn is_evch3 (& self) -> bool { * self == CLKSEL_A :: EVCH3 } # [doc = "Checks if the value of the field is `EVCH4`"]
# [inline (always)]
pub fn is_evch4 (& self) -> bool { * self == CLKSEL_A :: EVCH4 } # [doc = "Checks if the value of the field is `EVCH5`"]
# [inline (always)]
pub fn is_evch5 (& self) -> bool { * self == CLKSEL_A :: EVCH5 } # [doc = "Checks if the value of the field is `EVCH6`"]
# [inline (always)]
pub fn is_evch6 (& self) -> bool { * self == CLKSEL_A :: EVCH6 } # [doc = "Checks if the value of the field is `EVCH7`"]
# [inline (always)]
pub fn is_evch7 (& self) -> bool { * self == CLKSEL_A :: EVCH7 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 4 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKSEL_A :: OFF) } # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn evch0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn evch1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn evch2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn evch3 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn evch4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn evch5 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn evch6 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn evch7 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH7) } } impl R { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope"]
SS = 3 , # [doc = "5: Dual Slope, Update on TOP"]
DS_T = 5 , # [doc = "6: Dual Slope, Update on TOP and BOTTOM"]
DS_TB = 6 , # [doc = "7: Dual Slope, Update on BOTTOM"]
DS_B = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SS) , 5 => Some (WGMODE_A :: DS_T) , 6 => Some (WGMODE_A :: DS_TB) , 7 => Some (WGMODE_A :: DS_B) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == WGMODE_A :: SS } # [doc = "Checks if the value of the field is `DS_T`"]
# [inline (always)]
pub fn is_ds_t (& self) -> bool { * self == WGMODE_A :: DS_T } # [doc = "Checks if the value of the field is `DS_TB`"]
# [inline (always)]
pub fn is_ds_tb (& self) -> bool { * self == WGMODE_A :: DS_TB } # [doc = "Checks if the value of the field is `DS_B`"]
# [inline (always)]
pub fn is_ds_b (& self) -> bool { * self == WGMODE_A :: DS_B } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (WGMODE_A :: SS) } # [doc = "Dual Slope, Update on TOP"]
# [inline (always)]
pub fn ds_t (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_T) } # [doc = "Dual Slope, Update on TOP and BOTTOM"]
# [inline (always)]
pub fn ds_tb (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_TB) } # [doc = "Dual Slope, Update on BOTTOM"]
# [inline (always)]
pub fn ds_b (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_B) } } # [doc = "Field `CCAEN` reader - Compare or Capture A Enable"]
pub type CCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCAEN` writer - Compare or Capture A Enable"]
pub type CCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCBEN` reader - Compare or Capture B Enable"]
pub type CCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCBEN` writer - Compare or Capture B Enable"]
pub type CCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCCEN` reader - Compare or Capture C Enable"]
pub type CCCEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCCEN` writer - Compare or Capture C Enable"]
pub type CCCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCDEN` reader - Compare or Capture D Enable"]
pub type CCDEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCDEN` writer - Compare or Capture D Enable"]
pub type CCDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
pub fn ccaen (& self) -> CCAEN_R { CCAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
pub fn ccben (& self) -> CCBEN_R { CCBEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare or Capture C Enable"]
# [inline (always)]
pub fn cccen (& self) -> CCCEN_R { CCCEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare or Capture D Enable"]
# [inline (always)]
pub fn ccden (& self) -> CCDEN_R { CCDEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
# [must_use]
pub fn ccaen (& mut self) -> CCAEN_W < 4 > { CCAEN_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
# [must_use]
pub fn ccben (& mut self) -> CCBEN_W < 5 > { CCBEN_W :: new (self) } # [doc = "Bit 6 - Compare or Capture C Enable"]
# [inline (always)]
# [must_use]
pub fn cccen (& mut self) -> CCCEN_W < 6 > { CCCEN_W :: new (self) } # [doc = "Bit 7 - Compare or Capture D Enable"]
# [inline (always)]
# [must_use]
pub fn ccden (& mut self) -> CCDEN_W < 7 > { CCDEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPC` reader - Compare C Output Value"]
pub type CMPC_R = crate :: BitReader < bool > ; # [doc = "Field `CMPC` writer - Compare C Output Value"]
pub type CMPC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPD` reader - Compare D Output Value"]
pub type CMPD_R = crate :: BitReader < bool > ; # [doc = "Field `CMPD` writer - Compare D Output Value"]
pub type CMPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare C Output Value"]
# [inline (always)]
pub fn cmpc (& self) -> CMPC_R { CMPC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare D Output Value"]
# [inline (always)]
pub fn cmpd (& self) -> CMPD_R { CMPD_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Bit 2 - Compare C Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpc (& mut self) -> CMPC_W < 2 > { CMPC_W :: new (self) } # [doc = "Bit 3 - Compare D Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpd (& mut self) -> CMPD_W < 3 > { CMPD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control Register D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Source Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
CH0 = 8 , # [doc = "9: Event Channel 1"]
CH1 = 9 , # [doc = "10: Event Channel 2"]
CH2 = 10 , # [doc = "11: Event Channel 3"]
CH3 = 11 , # [doc = "12: Event Channel 4"]
CH4 = 12 , # [doc = "13: Event Channel 5"]
CH5 = 13 , # [doc = "14: Event Channel 6"]
CH6 = 14 , # [doc = "15: Event Channel 7"]
CH7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: CH0) , 9 => Some (EVSEL_A :: CH1) , 10 => Some (EVSEL_A :: CH2) , 11 => Some (EVSEL_A :: CH3) , 12 => Some (EVSEL_A :: CH4) , 13 => Some (EVSEL_A :: CH5) , 14 => Some (EVSEL_A :: CH6) , 15 => Some (EVSEL_A :: CH7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVSEL_A :: CH0 } # [doc = "Checks if the value of the field is `CH1`"]
# [inline (always)]
pub fn is_ch1 (& self) -> bool { * self == EVSEL_A :: CH1 } # [doc = "Checks if the value of the field is `CH2`"]
# [inline (always)]
pub fn is_ch2 (& self) -> bool { * self == EVSEL_A :: CH2 } # [doc = "Checks if the value of the field is `CH3`"]
# [inline (always)]
pub fn is_ch3 (& self) -> bool { * self == EVSEL_A :: CH3 } # [doc = "Checks if the value of the field is `CH4`"]
# [inline (always)]
pub fn is_ch4 (& self) -> bool { * self == EVSEL_A :: CH4 } # [doc = "Checks if the value of the field is `CH5`"]
# [inline (always)]
pub fn is_ch5 (& self) -> bool { * self == EVSEL_A :: CH5 } # [doc = "Checks if the value of the field is `CH6`"]
# [inline (always)]
pub fn is_ch6 (& self) -> bool { * self == EVSEL_A :: CH6 } # [doc = "Checks if the value of the field is `CH7`"]
# [inline (always)]
pub fn is_ch7 (& self) -> bool { * self == EVSEL_A :: CH7 } } # [doc = "Field `EVSEL` writer - Event Source Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn ch1 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn ch2 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn ch3 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn ch4 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn ch5 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn ch6 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn ch7 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH7) } } # [doc = "Field `EVDLY` reader - Event Delay"]
pub type EVDLY_R = crate :: BitReader < bool > ; # [doc = "Field `EVDLY` writer - Event Delay"]
pub type EVDLY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No Event Action"]
OFF = 0 , # [doc = "1: Input Capture"]
CAPT = 1 , # [doc = "2: Externally Controlled Up/Down Count"]
UPDOWN = 2 , # [doc = "3: Quadrature Decode"]
QDEC = 3 , # [doc = "4: Restart"]
RESTART = 4 , # [doc = "5: Frequency Capture"]
FRQ = 5 , # [doc = "6: Pulse-width Capture"]
PW = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: CAPT) , 2 => Some (EVACT_A :: UPDOWN) , 3 => Some (EVACT_A :: QDEC) , 4 => Some (EVACT_A :: RESTART) , 5 => Some (EVACT_A :: FRQ) , 6 => Some (EVACT_A :: PW) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == EVACT_A :: CAPT } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } # [doc = "Checks if the value of the field is `QDEC`"]
# [inline (always)]
pub fn is_qdec (& self) -> bool { * self == EVACT_A :: QDEC } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == EVACT_A :: RESTART } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == EVACT_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == EVACT_A :: PW } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No Event Action"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Input Capture"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (EVACT_A :: CAPT) } # [doc = "Externally Controlled Up/Down Count"]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } # [doc = "Quadrature Decode"]
# [inline (always)]
pub fn qdec (self) -> & 'a mut W { self . variant (EVACT_A :: QDEC) } # [doc = "Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (EVACT_A :: RESTART) } # [doc = "Frequency Capture"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (EVACT_A :: FRQ) } # [doc = "Pulse-width Capture"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (EVACT_A :: PW) } } impl R { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
pub fn evdly (& self) -> EVDLY_R { EVDLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
# [must_use]
pub fn evdly (& mut self) -> EVDLY_W < 4 > { EVDLY_W :: new (self) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 5 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control Register E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BYTEM` reader - Byte Mode"]
pub type BYTEM_R = crate :: BitReader < bool > ; # [doc = "Field `BYTEM` writer - Byte Mode"]
pub type BYTEM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
pub fn bytem (& self) -> BYTEM_R { BYTEM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
# [must_use]
pub fn bytem (& mut self) -> BYTEM_W < 0 > { BYTEM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control Register F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFCLR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control Register F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFSET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGCLR (rw) register accessor: an alias for `Reg<CTRLGCLR_SPEC>`"]
pub type CTRLGCLR = crate :: Reg < ctrlgclr :: CTRLGCLR_SPEC > ; # [doc = "Control Register G Clear"]
pub mod ctrlgclr { # [doc = "Register `CTRLGCLR` reader"]
pub struct R (crate :: R < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGCLR` writer"]
pub struct W (crate :: W < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCCBV` reader - Compare or Capture C Buffer Valid"]
pub type CCCBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCCBV` writer - Compare or Capture C Buffer Valid"]
pub type CCCBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCDBV` reader - Compare or Capture D Buffer Valid"]
pub type CCDBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCDBV` writer - Compare or Capture D Buffer Valid"]
pub type CCDBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
pub fn cccbv (& self) -> CCCBV_R { CCCBV_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
pub fn ccdbv (& self) -> CCDBV_R { CCDBV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cccbv (& mut self) -> CCCBV_W < 3 > { CCCBV_W :: new (self) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccdbv (& mut self) -> CCDBV_W < 4 > { CCDBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgclr](index.html) module"]
pub struct CTRLGCLR_SPEC ; impl crate :: RegisterSpec for CTRLGCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgclr::R](R) reader structure"]
impl crate :: Readable for CTRLGCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgclr::W](W) writer structure"]
impl crate :: Writable for CTRLGCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGCLR to value 0"]
impl crate :: Resettable for CTRLGCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGSET (rw) register accessor: an alias for `Reg<CTRLGSET_SPEC>`"]
pub type CTRLGSET = crate :: Reg < ctrlgset :: CTRLGSET_SPEC > ; # [doc = "Control Register G Set"]
pub mod ctrlgset { # [doc = "Register `CTRLGSET` reader"]
pub struct R (crate :: R < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGSET` writer"]
pub struct W (crate :: W < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCCBV` reader - Compare or Capture C Buffer Valid"]
pub type CCCBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCCBV` writer - Compare or Capture C Buffer Valid"]
pub type CCCBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCDBV` reader - Compare or Capture D Buffer Valid"]
pub type CCDBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCDBV` writer - Compare or Capture D Buffer Valid"]
pub type CCDBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
pub fn cccbv (& self) -> CCCBV_R { CCCBV_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
pub fn ccdbv (& self) -> CCDBV_R { CCDBV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cccbv (& mut self) -> CCCBV_W < 3 > { CCCBV_W :: new (self) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccdbv (& mut self) -> CCDBV_W < 4 > { CCDBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgset](index.html) module"]
pub struct CTRLGSET_SPEC ; impl crate :: RegisterSpec for CTRLGSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgset::R](R) reader structure"]
impl crate :: Readable for CTRLGSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgset::W](W) writer structure"]
impl crate :: Writable for CTRLGSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGSET to value 0"]
impl crate :: Resettable for CTRLGSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLA (rw) register accessor: an alias for `Reg<INTCTRLA_SPEC>`"]
pub type INTCTRLA = crate :: Reg < intctrla :: INTCTRLA_SPEC > ; # [doc = "Interrupt Control Register A"]
pub mod intctrla { # [doc = "Register `INTCTRLA` reader"]
pub struct R (crate :: R < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLA` writer"]
pub struct W (crate :: W < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow interrupt level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow interrupt level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `ERRINTLVL` reader - Error Interrupt Level"]
pub type ERRINTLVL_R = crate :: FieldReader < u8 , ERRINTLVL_A > ; # [doc = "Error Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ERRINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < ERRINTLVL_A > for u8 { # [inline (always)]
fn from (variant : ERRINTLVL_A) -> Self { variant as _ } } impl ERRINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ERRINTLVL_A { match self . bits { 0 => ERRINTLVL_A :: OFF , 1 => ERRINTLVL_A :: LO , 2 => ERRINTLVL_A :: MED , 3 => ERRINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ERRINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == ERRINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == ERRINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == ERRINTLVL_A :: HI } } # [doc = "Field `ERRINTLVL` writer - Error Interrupt Level"]
pub type ERRINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , ERRINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > ERRINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
pub fn errintlvl (& self) -> ERRINTLVL_R { ERRINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn errintlvl (& mut self) -> ERRINTLVL_W < 2 > { ERRINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrla](index.html) module"]
pub struct INTCTRLA_SPEC ; impl crate :: RegisterSpec for INTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrla::R](R) reader structure"]
impl crate :: Readable for INTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrla::W](W) writer structure"]
impl crate :: Writable for INTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLA to value 0"]
impl crate :: Resettable for INTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLB (rw) register accessor: an alias for `Reg<INTCTRLB_SPEC>`"]
pub type INTCTRLB = crate :: Reg < intctrlb :: INTCTRLB_SPEC > ; # [doc = "Interrupt Control Register B"]
pub mod intctrlb { # [doc = "Register `INTCTRLB` reader"]
pub struct R (crate :: R < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLB` writer"]
pub struct W (crate :: W < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCAINTLVL` reader - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_R = crate :: FieldReader < u8 , CCAINTLVL_A > ; # [doc = "Compare or Capture A Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCAINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCAINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCAINTLVL_A) -> Self { variant as _ } } impl CCAINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCAINTLVL_A { match self . bits { 0 => CCAINTLVL_A :: OFF , 1 => CCAINTLVL_A :: LO , 2 => CCAINTLVL_A :: MED , 3 => CCAINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCAINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCAINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCAINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCAINTLVL_A :: HI } } # [doc = "Field `CCAINTLVL` writer - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCAINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCAINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: HI) } } # [doc = "Field `CCBINTLVL` reader - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_R = crate :: FieldReader < u8 , CCBINTLVL_A > ; # [doc = "Compare or Capture B Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCBINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCBINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCBINTLVL_A) -> Self { variant as _ } } impl CCBINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCBINTLVL_A { match self . bits { 0 => CCBINTLVL_A :: OFF , 1 => CCBINTLVL_A :: LO , 2 => CCBINTLVL_A :: MED , 3 => CCBINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCBINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCBINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCBINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCBINTLVL_A :: HI } } # [doc = "Field `CCBINTLVL` writer - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCBINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCBINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: HI) } } # [doc = "Field `CCCINTLVL` reader - Compare or Capture C Interrupt Level"]
pub type CCCINTLVL_R = crate :: FieldReader < u8 , CCCINTLVL_A > ; # [doc = "Compare or Capture C Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCCINTLVL_A) -> Self { variant as _ } } impl CCCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCCINTLVL_A { match self . bits { 0 => CCCINTLVL_A :: OFF , 1 => CCCINTLVL_A :: LO , 2 => CCCINTLVL_A :: MED , 3 => CCCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCCINTLVL_A :: HI } } # [doc = "Field `CCCINTLVL` writer - Compare or Capture C Interrupt Level"]
pub type CCCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: HI) } } # [doc = "Field `CCDINTLVL` reader - Compare or Capture D Interrupt Level"]
pub type CCDINTLVL_R = crate :: FieldReader < u8 , CCDINTLVL_A > ; # [doc = "Compare or Capture D Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCDINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCDINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCDINTLVL_A) -> Self { variant as _ } } impl CCDINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCDINTLVL_A { match self . bits { 0 => CCDINTLVL_A :: OFF , 1 => CCDINTLVL_A :: LO , 2 => CCDINTLVL_A :: MED , 3 => CCDINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCDINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCDINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCDINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCDINTLVL_A :: HI } } # [doc = "Field `CCDINTLVL` writer - Compare or Capture D Interrupt Level"]
pub type CCDINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCDINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCDINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
pub fn ccaintlvl (& self) -> CCAINTLVL_R { CCAINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
pub fn ccbintlvl (& self) -> CCBINTLVL_R { CCBINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare or Capture C Interrupt Level"]
# [inline (always)]
pub fn cccintlvl (& self) -> CCCINTLVL_R { CCCINTLVL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare or Capture D Interrupt Level"]
# [inline (always)]
pub fn ccdintlvl (& self) -> CCDINTLVL_R { CCDINTLVL_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccaintlvl (& mut self) -> CCAINTLVL_W < 0 > { CCAINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccbintlvl (& mut self) -> CCBINTLVL_W < 2 > { CCBINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Compare or Capture C Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn cccintlvl (& mut self) -> CCCINTLVL_W < 4 > { CCCINTLVL_W :: new (self) } # [doc = "Bits 6:7 - Compare or Capture D Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccdintlvl (& mut self) -> CCDINTLVL_W < 6 > { CCDINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrlb](index.html) module"]
pub struct INTCTRLB_SPEC ; impl crate :: RegisterSpec for INTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrlb::R](R) reader structure"]
impl crate :: Readable for INTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrlb::W](W) writer structure"]
impl crate :: Writable for INTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLB to value 0"]
impl crate :: Resettable for INTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `ERRIF` reader - Error Interrupt Flag"]
pub type ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `ERRIF` writer - Error Interrupt Flag"]
pub type ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCAIF` reader - Compare or Capture A Interrupt Flag"]
pub type CCAIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCAIF` writer - Compare or Capture A Interrupt Flag"]
pub type CCAIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCBIF` reader - Compare or Capture B Interrupt Flag"]
pub type CCBIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCBIF` writer - Compare or Capture B Interrupt Flag"]
pub type CCBIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCCIF` reader - Compare or Capture C Interrupt Flag"]
pub type CCCIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCCIF` writer - Compare or Capture C Interrupt Flag"]
pub type CCCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCDIF` reader - Compare or Capture D Interrupt Flag"]
pub type CCDIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCDIF` writer - Compare or Capture D Interrupt Flag"]
pub type CCDIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
pub fn errif (& self) -> ERRIF_R { ERRIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
pub fn ccaif (& self) -> CCAIF_R { CCAIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
pub fn ccbif (& self) -> CCBIF_R { CCBIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare or Capture C Interrupt Flag"]
# [inline (always)]
pub fn cccif (& self) -> CCCIF_R { CCCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare or Capture D Interrupt Flag"]
# [inline (always)]
pub fn ccdif (& self) -> CCDIF_R { CCDIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn errif (& mut self) -> ERRIF_W < 1 > { ERRIF_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccaif (& mut self) -> CCAIF_W < 4 > { CCAIF_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccbif (& mut self) -> CCBIF_W < 5 > { CCBIF_W :: new (self) } # [doc = "Bit 6 - Compare or Capture C Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn cccif (& mut self) -> CCCIF_W < 6 > { CCCIF_W :: new (self) } # [doc = "Bit 7 - Compare or Capture D Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccdif (& mut self) -> CCDIF_W < 7 > { CCDIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct TCD1 { _marker : PhantomData < * const () > } unsafe impl Send for TCD1 { } impl TCD1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcd1 :: RegisterBlock = 0x0940 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcd1 :: RegisterBlock { Self :: PTR } } impl Deref for TCD1 { type Target = tcd1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCD1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCD1") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod tcd1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control Register D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control Register E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control Register A"]
pub intctrla : INTCTRLA , # [doc = "0x07 - Interrupt Control Register B"]
pub intctrlb : INTCTRLB , # [doc = "0x08 - Control Register F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x09 - Control Register F Set"]
pub ctrlfset : CTRLFSET , # [doc = "0x0a - Control Register G Clear"]
pub ctrlgclr : CTRLGCLR , # [doc = "0x0b - Control Register G Set"]
pub ctrlgset : CTRLGSET , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved12 : [u8 ; 0x02]
, # [doc = "0x0f - Temporary Register For 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare or Capture A"]
pub cca : CCA , # [doc = "0x2a - Compare or Capture B"]
pub ccb : CCB , _reserved17 : [u8 ; 0x0a]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare Or Capture A Buffer"]
pub ccabuf : CCABUF , # [doc = "0x3a - Compare Or Capture B Buffer"]
pub ccbbuf : CCBBUF , } # [doc = "CCA (rw) register accessor: an alias for `Reg<CCA_SPEC>`"]
pub type CCA = crate :: Reg < cca :: CCA_SPEC > ; # [doc = "Compare or Capture A"]
pub mod cca { # [doc = "Register `CCA` reader"]
pub struct R (crate :: R < CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA` writer"]
pub struct W (crate :: W < CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca](index.html) module"]
pub struct CCA_SPEC ; impl crate :: RegisterSpec for CCA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cca::R](R) reader structure"]
impl crate :: Readable for CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca::W](W) writer structure"]
impl crate :: Writable for CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA to value 0"]
impl crate :: Resettable for CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCABUF (rw) register accessor: an alias for `Reg<CCABUF_SPEC>`"]
pub type CCABUF = crate :: Reg < ccabuf :: CCABUF_SPEC > ; # [doc = "Compare Or Capture A Buffer"]
pub mod ccabuf { # [doc = "Register `CCABUF` reader"]
pub struct R (crate :: R < CCABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCABUF` writer"]
pub struct W (crate :: W < CCABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCABUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture A Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccabuf](index.html) module"]
pub struct CCABUF_SPEC ; impl crate :: RegisterSpec for CCABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccabuf::R](R) reader structure"]
impl crate :: Readable for CCABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccabuf::W](W) writer structure"]
impl crate :: Writable for CCABUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCABUF to value 0"]
impl crate :: Resettable for CCABUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCB (rw) register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare or Capture B"]
pub mod ccb { # [doc = "Register `CCB` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCB to value 0"]
impl crate :: Resettable for CCB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCBBUF (rw) register accessor: an alias for `Reg<CCBBUF_SPEC>`"]
pub type CCBBUF = crate :: Reg < ccbbuf :: CCBBUF_SPEC > ; # [doc = "Compare Or Capture B Buffer"]
pub mod ccbbuf { # [doc = "Register `CCBBUF` reader"]
pub struct R (crate :: R < CCBBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCBBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCBBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCBBUF` writer"]
pub struct W (crate :: W < CCBBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCBBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCBBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture B Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccbbuf](index.html) module"]
pub struct CCBBUF_SPEC ; impl crate :: RegisterSpec for CCBBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccbbuf::R](R) reader structure"]
impl crate :: Readable for CCBBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccbbuf::W](W) writer structure"]
impl crate :: Writable for CCBBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCBBUF to value 0"]
impl crate :: Resettable for CCBBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Timer Off"]
OFF = 0 , # [doc = "1: System Clock"]
DIV1 = 1 , # [doc = "2: System Clock / 2"]
DIV2 = 2 , # [doc = "3: System Clock / 4"]
DIV4 = 3 , # [doc = "4: System Clock / 8"]
DIV8 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , # [doc = "8: Event Channel 0"]
EVCH0 = 8 , # [doc = "9: Event Channel 1"]
EVCH1 = 9 , # [doc = "10: Event Channel 2"]
EVCH2 = 10 , # [doc = "11: Event Channel 3"]
EVCH3 = 11 , # [doc = "12: Event Channel 4"]
EVCH4 = 12 , # [doc = "13: Event Channel 5"]
EVCH5 = 13 , # [doc = "14: Event Channel 6"]
EVCH6 = 14 , # [doc = "15: Event Channel 7"]
EVCH7 = 15 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OFF , 1 => CLKSEL_A :: DIV1 , 2 => CLKSEL_A :: DIV2 , 3 => CLKSEL_A :: DIV4 , 4 => CLKSEL_A :: DIV8 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , 8 => CLKSEL_A :: EVCH0 , 9 => CLKSEL_A :: EVCH1 , 10 => CLKSEL_A :: EVCH2 , 11 => CLKSEL_A :: EVCH3 , 12 => CLKSEL_A :: EVCH4 , 13 => CLKSEL_A :: EVCH5 , 14 => CLKSEL_A :: EVCH6 , 15 => CLKSEL_A :: EVCH7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKSEL_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } # [doc = "Checks if the value of the field is `EVCH0`"]
# [inline (always)]
pub fn is_evch0 (& self) -> bool { * self == CLKSEL_A :: EVCH0 } # [doc = "Checks if the value of the field is `EVCH1`"]
# [inline (always)]
pub fn is_evch1 (& self) -> bool { * self == CLKSEL_A :: EVCH1 } # [doc = "Checks if the value of the field is `EVCH2`"]
# [inline (always)]
pub fn is_evch2 (& self) -> bool { * self == CLKSEL_A :: EVCH2 } # [doc = "Checks if the value of the field is `EVCH3`"]
# [inline (always)]
pub fn is_evch3 (& self) -> bool { * self == CLKSEL_A :: EVCH3 } # [doc = "Checks if the value of the field is `EVCH4`"]
# [inline (always)]
pub fn is_evch4 (& self) -> bool { * self == CLKSEL_A :: EVCH4 } # [doc = "Checks if the value of the field is `EVCH5`"]
# [inline (always)]
pub fn is_evch5 (& self) -> bool { * self == CLKSEL_A :: EVCH5 } # [doc = "Checks if the value of the field is `EVCH6`"]
# [inline (always)]
pub fn is_evch6 (& self) -> bool { * self == CLKSEL_A :: EVCH6 } # [doc = "Checks if the value of the field is `EVCH7`"]
# [inline (always)]
pub fn is_evch7 (& self) -> bool { * self == CLKSEL_A :: EVCH7 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 4 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKSEL_A :: OFF) } # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn evch0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn evch1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn evch2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn evch3 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn evch4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn evch5 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn evch6 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn evch7 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH7) } } impl R { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope"]
SS = 3 , # [doc = "5: Dual Slope, Update on TOP"]
DS_T = 5 , # [doc = "6: Dual Slope, Update on TOP and BOTTOM"]
DS_TB = 6 , # [doc = "7: Dual Slope, Update on BOTTOM"]
DS_B = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SS) , 5 => Some (WGMODE_A :: DS_T) , 6 => Some (WGMODE_A :: DS_TB) , 7 => Some (WGMODE_A :: DS_B) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == WGMODE_A :: SS } # [doc = "Checks if the value of the field is `DS_T`"]
# [inline (always)]
pub fn is_ds_t (& self) -> bool { * self == WGMODE_A :: DS_T } # [doc = "Checks if the value of the field is `DS_TB`"]
# [inline (always)]
pub fn is_ds_tb (& self) -> bool { * self == WGMODE_A :: DS_TB } # [doc = "Checks if the value of the field is `DS_B`"]
# [inline (always)]
pub fn is_ds_b (& self) -> bool { * self == WGMODE_A :: DS_B } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (WGMODE_A :: SS) } # [doc = "Dual Slope, Update on TOP"]
# [inline (always)]
pub fn ds_t (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_T) } # [doc = "Dual Slope, Update on TOP and BOTTOM"]
# [inline (always)]
pub fn ds_tb (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_TB) } # [doc = "Dual Slope, Update on BOTTOM"]
# [inline (always)]
pub fn ds_b (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_B) } } # [doc = "Field `CCAEN` reader - Compare or Capture A Enable"]
pub type CCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCAEN` writer - Compare or Capture A Enable"]
pub type CCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCBEN` reader - Compare or Capture B Enable"]
pub type CCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCBEN` writer - Compare or Capture B Enable"]
pub type CCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
pub fn ccaen (& self) -> CCAEN_R { CCAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
pub fn ccben (& self) -> CCBEN_R { CCBEN_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
# [must_use]
pub fn ccaen (& mut self) -> CCAEN_W < 4 > { CCAEN_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
# [must_use]
pub fn ccben (& mut self) -> CCBEN_W < 5 > { CCBEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control Register D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Source Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
CH0 = 8 , # [doc = "9: Event Channel 1"]
CH1 = 9 , # [doc = "10: Event Channel 2"]
CH2 = 10 , # [doc = "11: Event Channel 3"]
CH3 = 11 , # [doc = "12: Event Channel 4"]
CH4 = 12 , # [doc = "13: Event Channel 5"]
CH5 = 13 , # [doc = "14: Event Channel 6"]
CH6 = 14 , # [doc = "15: Event Channel 7"]
CH7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: CH0) , 9 => Some (EVSEL_A :: CH1) , 10 => Some (EVSEL_A :: CH2) , 11 => Some (EVSEL_A :: CH3) , 12 => Some (EVSEL_A :: CH4) , 13 => Some (EVSEL_A :: CH5) , 14 => Some (EVSEL_A :: CH6) , 15 => Some (EVSEL_A :: CH7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVSEL_A :: CH0 } # [doc = "Checks if the value of the field is `CH1`"]
# [inline (always)]
pub fn is_ch1 (& self) -> bool { * self == EVSEL_A :: CH1 } # [doc = "Checks if the value of the field is `CH2`"]
# [inline (always)]
pub fn is_ch2 (& self) -> bool { * self == EVSEL_A :: CH2 } # [doc = "Checks if the value of the field is `CH3`"]
# [inline (always)]
pub fn is_ch3 (& self) -> bool { * self == EVSEL_A :: CH3 } # [doc = "Checks if the value of the field is `CH4`"]
# [inline (always)]
pub fn is_ch4 (& self) -> bool { * self == EVSEL_A :: CH4 } # [doc = "Checks if the value of the field is `CH5`"]
# [inline (always)]
pub fn is_ch5 (& self) -> bool { * self == EVSEL_A :: CH5 } # [doc = "Checks if the value of the field is `CH6`"]
# [inline (always)]
pub fn is_ch6 (& self) -> bool { * self == EVSEL_A :: CH6 } # [doc = "Checks if the value of the field is `CH7`"]
# [inline (always)]
pub fn is_ch7 (& self) -> bool { * self == EVSEL_A :: CH7 } } # [doc = "Field `EVSEL` writer - Event Source Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn ch1 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn ch2 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn ch3 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn ch4 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn ch5 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn ch6 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn ch7 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH7) } } # [doc = "Field `EVDLY` reader - Event Delay"]
pub type EVDLY_R = crate :: BitReader < bool > ; # [doc = "Field `EVDLY` writer - Event Delay"]
pub type EVDLY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No Event Action"]
OFF = 0 , # [doc = "1: Input Capture"]
CAPT = 1 , # [doc = "2: Externally Controlled Up/Down Count"]
UPDOWN = 2 , # [doc = "3: Quadrature Decode"]
QDEC = 3 , # [doc = "4: Restart"]
RESTART = 4 , # [doc = "5: Frequency Capture"]
FRQ = 5 , # [doc = "6: Pulse-width Capture"]
PW = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: CAPT) , 2 => Some (EVACT_A :: UPDOWN) , 3 => Some (EVACT_A :: QDEC) , 4 => Some (EVACT_A :: RESTART) , 5 => Some (EVACT_A :: FRQ) , 6 => Some (EVACT_A :: PW) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == EVACT_A :: CAPT } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } # [doc = "Checks if the value of the field is `QDEC`"]
# [inline (always)]
pub fn is_qdec (& self) -> bool { * self == EVACT_A :: QDEC } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == EVACT_A :: RESTART } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == EVACT_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == EVACT_A :: PW } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No Event Action"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Input Capture"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (EVACT_A :: CAPT) } # [doc = "Externally Controlled Up/Down Count"]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } # [doc = "Quadrature Decode"]
# [inline (always)]
pub fn qdec (self) -> & 'a mut W { self . variant (EVACT_A :: QDEC) } # [doc = "Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (EVACT_A :: RESTART) } # [doc = "Frequency Capture"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (EVACT_A :: FRQ) } # [doc = "Pulse-width Capture"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (EVACT_A :: PW) } } impl R { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
pub fn evdly (& self) -> EVDLY_R { EVDLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
# [must_use]
pub fn evdly (& mut self) -> EVDLY_W < 4 > { EVDLY_W :: new (self) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 5 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control Register E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BYTEM` reader - Byte Mode"]
pub type BYTEM_R = crate :: BitReader < bool > ; # [doc = "Field `BYTEM` writer - Byte Mode"]
pub type BYTEM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
pub fn bytem (& self) -> BYTEM_R { BYTEM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
# [must_use]
pub fn bytem (& mut self) -> BYTEM_W < 0 > { BYTEM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control Register F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFCLR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control Register F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFSET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGCLR (rw) register accessor: an alias for `Reg<CTRLGCLR_SPEC>`"]
pub type CTRLGCLR = crate :: Reg < ctrlgclr :: CTRLGCLR_SPEC > ; # [doc = "Control Register G Clear"]
pub mod ctrlgclr { # [doc = "Register `CTRLGCLR` reader"]
pub struct R (crate :: R < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGCLR` writer"]
pub struct W (crate :: W < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgclr](index.html) module"]
pub struct CTRLGCLR_SPEC ; impl crate :: RegisterSpec for CTRLGCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgclr::R](R) reader structure"]
impl crate :: Readable for CTRLGCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgclr::W](W) writer structure"]
impl crate :: Writable for CTRLGCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGCLR to value 0"]
impl crate :: Resettable for CTRLGCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGSET (rw) register accessor: an alias for `Reg<CTRLGSET_SPEC>`"]
pub type CTRLGSET = crate :: Reg < ctrlgset :: CTRLGSET_SPEC > ; # [doc = "Control Register G Set"]
pub mod ctrlgset { # [doc = "Register `CTRLGSET` reader"]
pub struct R (crate :: R < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGSET` writer"]
pub struct W (crate :: W < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgset](index.html) module"]
pub struct CTRLGSET_SPEC ; impl crate :: RegisterSpec for CTRLGSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgset::R](R) reader structure"]
impl crate :: Readable for CTRLGSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgset::W](W) writer structure"]
impl crate :: Writable for CTRLGSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGSET to value 0"]
impl crate :: Resettable for CTRLGSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLA (rw) register accessor: an alias for `Reg<INTCTRLA_SPEC>`"]
pub type INTCTRLA = crate :: Reg < intctrla :: INTCTRLA_SPEC > ; # [doc = "Interrupt Control Register A"]
pub mod intctrla { # [doc = "Register `INTCTRLA` reader"]
pub struct R (crate :: R < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLA` writer"]
pub struct W (crate :: W < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow interrupt level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow interrupt level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `ERRINTLVL` reader - Error Interrupt Level"]
pub type ERRINTLVL_R = crate :: FieldReader < u8 , ERRINTLVL_A > ; # [doc = "Error Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ERRINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < ERRINTLVL_A > for u8 { # [inline (always)]
fn from (variant : ERRINTLVL_A) -> Self { variant as _ } } impl ERRINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ERRINTLVL_A { match self . bits { 0 => ERRINTLVL_A :: OFF , 1 => ERRINTLVL_A :: LO , 2 => ERRINTLVL_A :: MED , 3 => ERRINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ERRINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == ERRINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == ERRINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == ERRINTLVL_A :: HI } } # [doc = "Field `ERRINTLVL` writer - Error Interrupt Level"]
pub type ERRINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , ERRINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > ERRINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
pub fn errintlvl (& self) -> ERRINTLVL_R { ERRINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn errintlvl (& mut self) -> ERRINTLVL_W < 2 > { ERRINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrla](index.html) module"]
pub struct INTCTRLA_SPEC ; impl crate :: RegisterSpec for INTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrla::R](R) reader structure"]
impl crate :: Readable for INTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrla::W](W) writer structure"]
impl crate :: Writable for INTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLA to value 0"]
impl crate :: Resettable for INTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLB (rw) register accessor: an alias for `Reg<INTCTRLB_SPEC>`"]
pub type INTCTRLB = crate :: Reg < intctrlb :: INTCTRLB_SPEC > ; # [doc = "Interrupt Control Register B"]
pub mod intctrlb { # [doc = "Register `INTCTRLB` reader"]
pub struct R (crate :: R < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLB` writer"]
pub struct W (crate :: W < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCAINTLVL` reader - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_R = crate :: FieldReader < u8 , CCAINTLVL_A > ; # [doc = "Compare or Capture A Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCAINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCAINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCAINTLVL_A) -> Self { variant as _ } } impl CCAINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCAINTLVL_A { match self . bits { 0 => CCAINTLVL_A :: OFF , 1 => CCAINTLVL_A :: LO , 2 => CCAINTLVL_A :: MED , 3 => CCAINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCAINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCAINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCAINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCAINTLVL_A :: HI } } # [doc = "Field `CCAINTLVL` writer - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCAINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCAINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: HI) } } # [doc = "Field `CCBINTLVL` reader - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_R = crate :: FieldReader < u8 , CCBINTLVL_A > ; # [doc = "Compare or Capture B Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCBINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCBINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCBINTLVL_A) -> Self { variant as _ } } impl CCBINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCBINTLVL_A { match self . bits { 0 => CCBINTLVL_A :: OFF , 1 => CCBINTLVL_A :: LO , 2 => CCBINTLVL_A :: MED , 3 => CCBINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCBINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCBINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCBINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCBINTLVL_A :: HI } } # [doc = "Field `CCBINTLVL` writer - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCBINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCBINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
pub fn ccaintlvl (& self) -> CCAINTLVL_R { CCAINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
pub fn ccbintlvl (& self) -> CCBINTLVL_R { CCBINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccaintlvl (& mut self) -> CCAINTLVL_W < 0 > { CCAINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccbintlvl (& mut self) -> CCBINTLVL_W < 2 > { CCBINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrlb](index.html) module"]
pub struct INTCTRLB_SPEC ; impl crate :: RegisterSpec for INTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrlb::R](R) reader structure"]
impl crate :: Readable for INTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrlb::W](W) writer structure"]
impl crate :: Writable for INTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLB to value 0"]
impl crate :: Resettable for INTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `ERRIF` reader - Error Interrupt Flag"]
pub type ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `ERRIF` writer - Error Interrupt Flag"]
pub type ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCAIF` reader - Compare or Capture A Interrupt Flag"]
pub type CCAIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCAIF` writer - Compare or Capture A Interrupt Flag"]
pub type CCAIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCBIF` reader - Compare or Capture B Interrupt Flag"]
pub type CCBIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCBIF` writer - Compare or Capture B Interrupt Flag"]
pub type CCBIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
pub fn errif (& self) -> ERRIF_R { ERRIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
pub fn ccaif (& self) -> CCAIF_R { CCAIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
pub fn ccbif (& self) -> CCBIF_R { CCBIF_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn errif (& mut self) -> ERRIF_W < 1 > { ERRIF_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccaif (& mut self) -> CCAIF_W < 4 > { CCAIF_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccbif (& mut self) -> CCBIF_W < 5 > { CCBIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct TCE0 { _marker : PhantomData < * const () > } unsafe impl Send for TCE0 { } impl TCE0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tce0 :: RegisterBlock = 0x0a00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tce0 :: RegisterBlock { Self :: PTR } } impl Deref for TCE0 { type Target = tce0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCE0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCE0") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod tce0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control Register D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control Register E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control Register A"]
pub intctrla : INTCTRLA , # [doc = "0x07 - Interrupt Control Register B"]
pub intctrlb : INTCTRLB , # [doc = "0x08 - Control Register F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x09 - Control Register F Set"]
pub ctrlfset : CTRLFSET , # [doc = "0x0a - Control Register G Clear"]
pub ctrlgclr : CTRLGCLR , # [doc = "0x0b - Control Register G Set"]
pub ctrlgset : CTRLGSET , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved12 : [u8 ; 0x02]
, # [doc = "0x0f - Temporary Register For 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare or Capture A"]
pub cca : CCA , # [doc = "0x2a - Compare or Capture B"]
pub ccb : CCB , # [doc = "0x2c - Compare or Capture C"]
pub ccc : CCC , # [doc = "0x2e - Compare or Capture D"]
pub ccd : CCD , _reserved19 : [u8 ; 0x06]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare Or Capture A Buffer"]
pub ccabuf : CCABUF , # [doc = "0x3a - Compare Or Capture B Buffer"]
pub ccbbuf : CCBBUF , # [doc = "0x3c - Compare Or Capture C Buffer"]
pub cccbuf : CCCBUF , # [doc = "0x3e - Compare Or Capture D Buffer"]
pub ccdbuf : CCDBUF , } # [doc = "CCA (rw) register accessor: an alias for `Reg<CCA_SPEC>`"]
pub type CCA = crate :: Reg < cca :: CCA_SPEC > ; # [doc = "Compare or Capture A"]
pub mod cca { # [doc = "Register `CCA` reader"]
pub struct R (crate :: R < CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA` writer"]
pub struct W (crate :: W < CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca](index.html) module"]
pub struct CCA_SPEC ; impl crate :: RegisterSpec for CCA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cca::R](R) reader structure"]
impl crate :: Readable for CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca::W](W) writer structure"]
impl crate :: Writable for CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA to value 0"]
impl crate :: Resettable for CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCABUF (rw) register accessor: an alias for `Reg<CCABUF_SPEC>`"]
pub type CCABUF = crate :: Reg < ccabuf :: CCABUF_SPEC > ; # [doc = "Compare Or Capture A Buffer"]
pub mod ccabuf { # [doc = "Register `CCABUF` reader"]
pub struct R (crate :: R < CCABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCABUF` writer"]
pub struct W (crate :: W < CCABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCABUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture A Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccabuf](index.html) module"]
pub struct CCABUF_SPEC ; impl crate :: RegisterSpec for CCABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccabuf::R](R) reader structure"]
impl crate :: Readable for CCABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccabuf::W](W) writer structure"]
impl crate :: Writable for CCABUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCABUF to value 0"]
impl crate :: Resettable for CCABUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCB (rw) register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare or Capture B"]
pub mod ccb { # [doc = "Register `CCB` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCB to value 0"]
impl crate :: Resettable for CCB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCBBUF (rw) register accessor: an alias for `Reg<CCBBUF_SPEC>`"]
pub type CCBBUF = crate :: Reg < ccbbuf :: CCBBUF_SPEC > ; # [doc = "Compare Or Capture B Buffer"]
pub mod ccbbuf { # [doc = "Register `CCBBUF` reader"]
pub struct R (crate :: R < CCBBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCBBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCBBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCBBUF` writer"]
pub struct W (crate :: W < CCBBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCBBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCBBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture B Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccbbuf](index.html) module"]
pub struct CCBBUF_SPEC ; impl crate :: RegisterSpec for CCBBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccbbuf::R](R) reader structure"]
impl crate :: Readable for CCBBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccbbuf::W](W) writer structure"]
impl crate :: Writable for CCBBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCBBUF to value 0"]
impl crate :: Resettable for CCBBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCC (rw) register accessor: an alias for `Reg<CCC_SPEC>`"]
pub type CCC = crate :: Reg < ccc :: CCC_SPEC > ; # [doc = "Compare or Capture C"]
pub mod ccc { # [doc = "Register `CCC` reader"]
pub struct R (crate :: R < CCC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCC` writer"]
pub struct W (crate :: W < CCC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccc](index.html) module"]
pub struct CCC_SPEC ; impl crate :: RegisterSpec for CCC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccc::R](R) reader structure"]
impl crate :: Readable for CCC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccc::W](W) writer structure"]
impl crate :: Writable for CCC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCC to value 0"]
impl crate :: Resettable for CCC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCCBUF (rw) register accessor: an alias for `Reg<CCCBUF_SPEC>`"]
pub type CCCBUF = crate :: Reg < cccbuf :: CCCBUF_SPEC > ; # [doc = "Compare Or Capture C Buffer"]
pub mod cccbuf { # [doc = "Register `CCCBUF` reader"]
pub struct R (crate :: R < CCCBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCCBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCCBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCCBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCCBUF` writer"]
pub struct W (crate :: W < CCCBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCCBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCCBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCCBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture C Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cccbuf](index.html) module"]
pub struct CCCBUF_SPEC ; impl crate :: RegisterSpec for CCCBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cccbuf::R](R) reader structure"]
impl crate :: Readable for CCCBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cccbuf::W](W) writer structure"]
impl crate :: Writable for CCCBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCCBUF to value 0"]
impl crate :: Resettable for CCCBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCD (rw) register accessor: an alias for `Reg<CCD_SPEC>`"]
pub type CCD = crate :: Reg < ccd :: CCD_SPEC > ; # [doc = "Compare or Capture D"]
pub mod ccd { # [doc = "Register `CCD` reader"]
pub struct R (crate :: R < CCD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCD` writer"]
pub struct W (crate :: W < CCD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccd](index.html) module"]
pub struct CCD_SPEC ; impl crate :: RegisterSpec for CCD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccd::R](R) reader structure"]
impl crate :: Readable for CCD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccd::W](W) writer structure"]
impl crate :: Writable for CCD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCD to value 0"]
impl crate :: Resettable for CCD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCDBUF (rw) register accessor: an alias for `Reg<CCDBUF_SPEC>`"]
pub type CCDBUF = crate :: Reg < ccdbuf :: CCDBUF_SPEC > ; # [doc = "Compare Or Capture D Buffer"]
pub mod ccdbuf { # [doc = "Register `CCDBUF` reader"]
pub struct R (crate :: R < CCDBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCDBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCDBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCDBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCDBUF` writer"]
pub struct W (crate :: W < CCDBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCDBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCDBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCDBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture D Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccdbuf](index.html) module"]
pub struct CCDBUF_SPEC ; impl crate :: RegisterSpec for CCDBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccdbuf::R](R) reader structure"]
impl crate :: Readable for CCDBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccdbuf::W](W) writer structure"]
impl crate :: Writable for CCDBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCDBUF to value 0"]
impl crate :: Resettable for CCDBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Timer Off"]
OFF = 0 , # [doc = "1: System Clock"]
DIV1 = 1 , # [doc = "2: System Clock / 2"]
DIV2 = 2 , # [doc = "3: System Clock / 4"]
DIV4 = 3 , # [doc = "4: System Clock / 8"]
DIV8 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , # [doc = "8: Event Channel 0"]
EVCH0 = 8 , # [doc = "9: Event Channel 1"]
EVCH1 = 9 , # [doc = "10: Event Channel 2"]
EVCH2 = 10 , # [doc = "11: Event Channel 3"]
EVCH3 = 11 , # [doc = "12: Event Channel 4"]
EVCH4 = 12 , # [doc = "13: Event Channel 5"]
EVCH5 = 13 , # [doc = "14: Event Channel 6"]
EVCH6 = 14 , # [doc = "15: Event Channel 7"]
EVCH7 = 15 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OFF , 1 => CLKSEL_A :: DIV1 , 2 => CLKSEL_A :: DIV2 , 3 => CLKSEL_A :: DIV4 , 4 => CLKSEL_A :: DIV8 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , 8 => CLKSEL_A :: EVCH0 , 9 => CLKSEL_A :: EVCH1 , 10 => CLKSEL_A :: EVCH2 , 11 => CLKSEL_A :: EVCH3 , 12 => CLKSEL_A :: EVCH4 , 13 => CLKSEL_A :: EVCH5 , 14 => CLKSEL_A :: EVCH6 , 15 => CLKSEL_A :: EVCH7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKSEL_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } # [doc = "Checks if the value of the field is `EVCH0`"]
# [inline (always)]
pub fn is_evch0 (& self) -> bool { * self == CLKSEL_A :: EVCH0 } # [doc = "Checks if the value of the field is `EVCH1`"]
# [inline (always)]
pub fn is_evch1 (& self) -> bool { * self == CLKSEL_A :: EVCH1 } # [doc = "Checks if the value of the field is `EVCH2`"]
# [inline (always)]
pub fn is_evch2 (& self) -> bool { * self == CLKSEL_A :: EVCH2 } # [doc = "Checks if the value of the field is `EVCH3`"]
# [inline (always)]
pub fn is_evch3 (& self) -> bool { * self == CLKSEL_A :: EVCH3 } # [doc = "Checks if the value of the field is `EVCH4`"]
# [inline (always)]
pub fn is_evch4 (& self) -> bool { * self == CLKSEL_A :: EVCH4 } # [doc = "Checks if the value of the field is `EVCH5`"]
# [inline (always)]
pub fn is_evch5 (& self) -> bool { * self == CLKSEL_A :: EVCH5 } # [doc = "Checks if the value of the field is `EVCH6`"]
# [inline (always)]
pub fn is_evch6 (& self) -> bool { * self == CLKSEL_A :: EVCH6 } # [doc = "Checks if the value of the field is `EVCH7`"]
# [inline (always)]
pub fn is_evch7 (& self) -> bool { * self == CLKSEL_A :: EVCH7 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 4 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKSEL_A :: OFF) } # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn evch0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn evch1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn evch2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn evch3 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn evch4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn evch5 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn evch6 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn evch7 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH7) } } impl R { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope"]
SS = 3 , # [doc = "5: Dual Slope, Update on TOP"]
DS_T = 5 , # [doc = "6: Dual Slope, Update on TOP and BOTTOM"]
DS_TB = 6 , # [doc = "7: Dual Slope, Update on BOTTOM"]
DS_B = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SS) , 5 => Some (WGMODE_A :: DS_T) , 6 => Some (WGMODE_A :: DS_TB) , 7 => Some (WGMODE_A :: DS_B) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == WGMODE_A :: SS } # [doc = "Checks if the value of the field is `DS_T`"]
# [inline (always)]
pub fn is_ds_t (& self) -> bool { * self == WGMODE_A :: DS_T } # [doc = "Checks if the value of the field is `DS_TB`"]
# [inline (always)]
pub fn is_ds_tb (& self) -> bool { * self == WGMODE_A :: DS_TB } # [doc = "Checks if the value of the field is `DS_B`"]
# [inline (always)]
pub fn is_ds_b (& self) -> bool { * self == WGMODE_A :: DS_B } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (WGMODE_A :: SS) } # [doc = "Dual Slope, Update on TOP"]
# [inline (always)]
pub fn ds_t (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_T) } # [doc = "Dual Slope, Update on TOP and BOTTOM"]
# [inline (always)]
pub fn ds_tb (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_TB) } # [doc = "Dual Slope, Update on BOTTOM"]
# [inline (always)]
pub fn ds_b (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_B) } } # [doc = "Field `CCAEN` reader - Compare or Capture A Enable"]
pub type CCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCAEN` writer - Compare or Capture A Enable"]
pub type CCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCBEN` reader - Compare or Capture B Enable"]
pub type CCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCBEN` writer - Compare or Capture B Enable"]
pub type CCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCCEN` reader - Compare or Capture C Enable"]
pub type CCCEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCCEN` writer - Compare or Capture C Enable"]
pub type CCCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCDEN` reader - Compare or Capture D Enable"]
pub type CCDEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCDEN` writer - Compare or Capture D Enable"]
pub type CCDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
pub fn ccaen (& self) -> CCAEN_R { CCAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
pub fn ccben (& self) -> CCBEN_R { CCBEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare or Capture C Enable"]
# [inline (always)]
pub fn cccen (& self) -> CCCEN_R { CCCEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare or Capture D Enable"]
# [inline (always)]
pub fn ccden (& self) -> CCDEN_R { CCDEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
# [must_use]
pub fn ccaen (& mut self) -> CCAEN_W < 4 > { CCAEN_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
# [must_use]
pub fn ccben (& mut self) -> CCBEN_W < 5 > { CCBEN_W :: new (self) } # [doc = "Bit 6 - Compare or Capture C Enable"]
# [inline (always)]
# [must_use]
pub fn cccen (& mut self) -> CCCEN_W < 6 > { CCCEN_W :: new (self) } # [doc = "Bit 7 - Compare or Capture D Enable"]
# [inline (always)]
# [must_use]
pub fn ccden (& mut self) -> CCDEN_W < 7 > { CCDEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPC` reader - Compare C Output Value"]
pub type CMPC_R = crate :: BitReader < bool > ; # [doc = "Field `CMPC` writer - Compare C Output Value"]
pub type CMPC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPD` reader - Compare D Output Value"]
pub type CMPD_R = crate :: BitReader < bool > ; # [doc = "Field `CMPD` writer - Compare D Output Value"]
pub type CMPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare C Output Value"]
# [inline (always)]
pub fn cmpc (& self) -> CMPC_R { CMPC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare D Output Value"]
# [inline (always)]
pub fn cmpd (& self) -> CMPD_R { CMPD_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Bit 2 - Compare C Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpc (& mut self) -> CMPC_W < 2 > { CMPC_W :: new (self) } # [doc = "Bit 3 - Compare D Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpd (& mut self) -> CMPD_W < 3 > { CMPD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control Register D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Source Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
CH0 = 8 , # [doc = "9: Event Channel 1"]
CH1 = 9 , # [doc = "10: Event Channel 2"]
CH2 = 10 , # [doc = "11: Event Channel 3"]
CH3 = 11 , # [doc = "12: Event Channel 4"]
CH4 = 12 , # [doc = "13: Event Channel 5"]
CH5 = 13 , # [doc = "14: Event Channel 6"]
CH6 = 14 , # [doc = "15: Event Channel 7"]
CH7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: CH0) , 9 => Some (EVSEL_A :: CH1) , 10 => Some (EVSEL_A :: CH2) , 11 => Some (EVSEL_A :: CH3) , 12 => Some (EVSEL_A :: CH4) , 13 => Some (EVSEL_A :: CH5) , 14 => Some (EVSEL_A :: CH6) , 15 => Some (EVSEL_A :: CH7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVSEL_A :: CH0 } # [doc = "Checks if the value of the field is `CH1`"]
# [inline (always)]
pub fn is_ch1 (& self) -> bool { * self == EVSEL_A :: CH1 } # [doc = "Checks if the value of the field is `CH2`"]
# [inline (always)]
pub fn is_ch2 (& self) -> bool { * self == EVSEL_A :: CH2 } # [doc = "Checks if the value of the field is `CH3`"]
# [inline (always)]
pub fn is_ch3 (& self) -> bool { * self == EVSEL_A :: CH3 } # [doc = "Checks if the value of the field is `CH4`"]
# [inline (always)]
pub fn is_ch4 (& self) -> bool { * self == EVSEL_A :: CH4 } # [doc = "Checks if the value of the field is `CH5`"]
# [inline (always)]
pub fn is_ch5 (& self) -> bool { * self == EVSEL_A :: CH5 } # [doc = "Checks if the value of the field is `CH6`"]
# [inline (always)]
pub fn is_ch6 (& self) -> bool { * self == EVSEL_A :: CH6 } # [doc = "Checks if the value of the field is `CH7`"]
# [inline (always)]
pub fn is_ch7 (& self) -> bool { * self == EVSEL_A :: CH7 } } # [doc = "Field `EVSEL` writer - Event Source Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn ch1 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn ch2 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn ch3 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn ch4 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn ch5 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn ch6 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn ch7 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH7) } } # [doc = "Field `EVDLY` reader - Event Delay"]
pub type EVDLY_R = crate :: BitReader < bool > ; # [doc = "Field `EVDLY` writer - Event Delay"]
pub type EVDLY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No Event Action"]
OFF = 0 , # [doc = "1: Input Capture"]
CAPT = 1 , # [doc = "2: Externally Controlled Up/Down Count"]
UPDOWN = 2 , # [doc = "3: Quadrature Decode"]
QDEC = 3 , # [doc = "4: Restart"]
RESTART = 4 , # [doc = "5: Frequency Capture"]
FRQ = 5 , # [doc = "6: Pulse-width Capture"]
PW = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: CAPT) , 2 => Some (EVACT_A :: UPDOWN) , 3 => Some (EVACT_A :: QDEC) , 4 => Some (EVACT_A :: RESTART) , 5 => Some (EVACT_A :: FRQ) , 6 => Some (EVACT_A :: PW) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == EVACT_A :: CAPT } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } # [doc = "Checks if the value of the field is `QDEC`"]
# [inline (always)]
pub fn is_qdec (& self) -> bool { * self == EVACT_A :: QDEC } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == EVACT_A :: RESTART } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == EVACT_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == EVACT_A :: PW } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No Event Action"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Input Capture"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (EVACT_A :: CAPT) } # [doc = "Externally Controlled Up/Down Count"]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } # [doc = "Quadrature Decode"]
# [inline (always)]
pub fn qdec (self) -> & 'a mut W { self . variant (EVACT_A :: QDEC) } # [doc = "Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (EVACT_A :: RESTART) } # [doc = "Frequency Capture"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (EVACT_A :: FRQ) } # [doc = "Pulse-width Capture"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (EVACT_A :: PW) } } impl R { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
pub fn evdly (& self) -> EVDLY_R { EVDLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
# [must_use]
pub fn evdly (& mut self) -> EVDLY_W < 4 > { EVDLY_W :: new (self) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 5 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control Register E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BYTEM` reader - Byte Mode"]
pub type BYTEM_R = crate :: BitReader < bool > ; # [doc = "Field `BYTEM` writer - Byte Mode"]
pub type BYTEM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
pub fn bytem (& self) -> BYTEM_R { BYTEM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
# [must_use]
pub fn bytem (& mut self) -> BYTEM_W < 0 > { BYTEM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control Register F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFCLR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control Register F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFSET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGCLR (rw) register accessor: an alias for `Reg<CTRLGCLR_SPEC>`"]
pub type CTRLGCLR = crate :: Reg < ctrlgclr :: CTRLGCLR_SPEC > ; # [doc = "Control Register G Clear"]
pub mod ctrlgclr { # [doc = "Register `CTRLGCLR` reader"]
pub struct R (crate :: R < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGCLR` writer"]
pub struct W (crate :: W < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCCBV` reader - Compare or Capture C Buffer Valid"]
pub type CCCBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCCBV` writer - Compare or Capture C Buffer Valid"]
pub type CCCBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCDBV` reader - Compare or Capture D Buffer Valid"]
pub type CCDBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCDBV` writer - Compare or Capture D Buffer Valid"]
pub type CCDBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
pub fn cccbv (& self) -> CCCBV_R { CCCBV_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
pub fn ccdbv (& self) -> CCDBV_R { CCDBV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cccbv (& mut self) -> CCCBV_W < 3 > { CCCBV_W :: new (self) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccdbv (& mut self) -> CCDBV_W < 4 > { CCDBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgclr](index.html) module"]
pub struct CTRLGCLR_SPEC ; impl crate :: RegisterSpec for CTRLGCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgclr::R](R) reader structure"]
impl crate :: Readable for CTRLGCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgclr::W](W) writer structure"]
impl crate :: Writable for CTRLGCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGCLR to value 0"]
impl crate :: Resettable for CTRLGCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGSET (rw) register accessor: an alias for `Reg<CTRLGSET_SPEC>`"]
pub type CTRLGSET = crate :: Reg < ctrlgset :: CTRLGSET_SPEC > ; # [doc = "Control Register G Set"]
pub mod ctrlgset { # [doc = "Register `CTRLGSET` reader"]
pub struct R (crate :: R < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGSET` writer"]
pub struct W (crate :: W < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCCBV` reader - Compare or Capture C Buffer Valid"]
pub type CCCBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCCBV` writer - Compare or Capture C Buffer Valid"]
pub type CCCBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCDBV` reader - Compare or Capture D Buffer Valid"]
pub type CCDBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCDBV` writer - Compare or Capture D Buffer Valid"]
pub type CCDBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
pub fn cccbv (& self) -> CCCBV_R { CCCBV_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
pub fn ccdbv (& self) -> CCDBV_R { CCDBV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cccbv (& mut self) -> CCCBV_W < 3 > { CCCBV_W :: new (self) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccdbv (& mut self) -> CCDBV_W < 4 > { CCDBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgset](index.html) module"]
pub struct CTRLGSET_SPEC ; impl crate :: RegisterSpec for CTRLGSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgset::R](R) reader structure"]
impl crate :: Readable for CTRLGSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgset::W](W) writer structure"]
impl crate :: Writable for CTRLGSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGSET to value 0"]
impl crate :: Resettable for CTRLGSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLA (rw) register accessor: an alias for `Reg<INTCTRLA_SPEC>`"]
pub type INTCTRLA = crate :: Reg < intctrla :: INTCTRLA_SPEC > ; # [doc = "Interrupt Control Register A"]
pub mod intctrla { # [doc = "Register `INTCTRLA` reader"]
pub struct R (crate :: R < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLA` writer"]
pub struct W (crate :: W < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow interrupt level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow interrupt level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `ERRINTLVL` reader - Error Interrupt Level"]
pub type ERRINTLVL_R = crate :: FieldReader < u8 , ERRINTLVL_A > ; # [doc = "Error Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ERRINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < ERRINTLVL_A > for u8 { # [inline (always)]
fn from (variant : ERRINTLVL_A) -> Self { variant as _ } } impl ERRINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ERRINTLVL_A { match self . bits { 0 => ERRINTLVL_A :: OFF , 1 => ERRINTLVL_A :: LO , 2 => ERRINTLVL_A :: MED , 3 => ERRINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ERRINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == ERRINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == ERRINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == ERRINTLVL_A :: HI } } # [doc = "Field `ERRINTLVL` writer - Error Interrupt Level"]
pub type ERRINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , ERRINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > ERRINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
pub fn errintlvl (& self) -> ERRINTLVL_R { ERRINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn errintlvl (& mut self) -> ERRINTLVL_W < 2 > { ERRINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrla](index.html) module"]
pub struct INTCTRLA_SPEC ; impl crate :: RegisterSpec for INTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrla::R](R) reader structure"]
impl crate :: Readable for INTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrla::W](W) writer structure"]
impl crate :: Writable for INTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLA to value 0"]
impl crate :: Resettable for INTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLB (rw) register accessor: an alias for `Reg<INTCTRLB_SPEC>`"]
pub type INTCTRLB = crate :: Reg < intctrlb :: INTCTRLB_SPEC > ; # [doc = "Interrupt Control Register B"]
pub mod intctrlb { # [doc = "Register `INTCTRLB` reader"]
pub struct R (crate :: R < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLB` writer"]
pub struct W (crate :: W < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCAINTLVL` reader - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_R = crate :: FieldReader < u8 , CCAINTLVL_A > ; # [doc = "Compare or Capture A Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCAINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCAINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCAINTLVL_A) -> Self { variant as _ } } impl CCAINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCAINTLVL_A { match self . bits { 0 => CCAINTLVL_A :: OFF , 1 => CCAINTLVL_A :: LO , 2 => CCAINTLVL_A :: MED , 3 => CCAINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCAINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCAINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCAINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCAINTLVL_A :: HI } } # [doc = "Field `CCAINTLVL` writer - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCAINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCAINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: HI) } } # [doc = "Field `CCBINTLVL` reader - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_R = crate :: FieldReader < u8 , CCBINTLVL_A > ; # [doc = "Compare or Capture B Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCBINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCBINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCBINTLVL_A) -> Self { variant as _ } } impl CCBINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCBINTLVL_A { match self . bits { 0 => CCBINTLVL_A :: OFF , 1 => CCBINTLVL_A :: LO , 2 => CCBINTLVL_A :: MED , 3 => CCBINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCBINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCBINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCBINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCBINTLVL_A :: HI } } # [doc = "Field `CCBINTLVL` writer - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCBINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCBINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: HI) } } # [doc = "Field `CCCINTLVL` reader - Compare or Capture C Interrupt Level"]
pub type CCCINTLVL_R = crate :: FieldReader < u8 , CCCINTLVL_A > ; # [doc = "Compare or Capture C Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCCINTLVL_A) -> Self { variant as _ } } impl CCCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCCINTLVL_A { match self . bits { 0 => CCCINTLVL_A :: OFF , 1 => CCCINTLVL_A :: LO , 2 => CCCINTLVL_A :: MED , 3 => CCCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCCINTLVL_A :: HI } } # [doc = "Field `CCCINTLVL` writer - Compare or Capture C Interrupt Level"]
pub type CCCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: HI) } } # [doc = "Field `CCDINTLVL` reader - Compare or Capture D Interrupt Level"]
pub type CCDINTLVL_R = crate :: FieldReader < u8 , CCDINTLVL_A > ; # [doc = "Compare or Capture D Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCDINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCDINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCDINTLVL_A) -> Self { variant as _ } } impl CCDINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCDINTLVL_A { match self . bits { 0 => CCDINTLVL_A :: OFF , 1 => CCDINTLVL_A :: LO , 2 => CCDINTLVL_A :: MED , 3 => CCDINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCDINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCDINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCDINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCDINTLVL_A :: HI } } # [doc = "Field `CCDINTLVL` writer - Compare or Capture D Interrupt Level"]
pub type CCDINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCDINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCDINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
pub fn ccaintlvl (& self) -> CCAINTLVL_R { CCAINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
pub fn ccbintlvl (& self) -> CCBINTLVL_R { CCBINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare or Capture C Interrupt Level"]
# [inline (always)]
pub fn cccintlvl (& self) -> CCCINTLVL_R { CCCINTLVL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare or Capture D Interrupt Level"]
# [inline (always)]
pub fn ccdintlvl (& self) -> CCDINTLVL_R { CCDINTLVL_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccaintlvl (& mut self) -> CCAINTLVL_W < 0 > { CCAINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccbintlvl (& mut self) -> CCBINTLVL_W < 2 > { CCBINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Compare or Capture C Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn cccintlvl (& mut self) -> CCCINTLVL_W < 4 > { CCCINTLVL_W :: new (self) } # [doc = "Bits 6:7 - Compare or Capture D Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccdintlvl (& mut self) -> CCDINTLVL_W < 6 > { CCDINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrlb](index.html) module"]
pub struct INTCTRLB_SPEC ; impl crate :: RegisterSpec for INTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrlb::R](R) reader structure"]
impl crate :: Readable for INTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrlb::W](W) writer structure"]
impl crate :: Writable for INTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLB to value 0"]
impl crate :: Resettable for INTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `ERRIF` reader - Error Interrupt Flag"]
pub type ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `ERRIF` writer - Error Interrupt Flag"]
pub type ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCAIF` reader - Compare or Capture A Interrupt Flag"]
pub type CCAIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCAIF` writer - Compare or Capture A Interrupt Flag"]
pub type CCAIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCBIF` reader - Compare or Capture B Interrupt Flag"]
pub type CCBIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCBIF` writer - Compare or Capture B Interrupt Flag"]
pub type CCBIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCCIF` reader - Compare or Capture C Interrupt Flag"]
pub type CCCIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCCIF` writer - Compare or Capture C Interrupt Flag"]
pub type CCCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCDIF` reader - Compare or Capture D Interrupt Flag"]
pub type CCDIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCDIF` writer - Compare or Capture D Interrupt Flag"]
pub type CCDIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
pub fn errif (& self) -> ERRIF_R { ERRIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
pub fn ccaif (& self) -> CCAIF_R { CCAIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
pub fn ccbif (& self) -> CCBIF_R { CCBIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare or Capture C Interrupt Flag"]
# [inline (always)]
pub fn cccif (& self) -> CCCIF_R { CCCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare or Capture D Interrupt Flag"]
# [inline (always)]
pub fn ccdif (& self) -> CCDIF_R { CCDIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn errif (& mut self) -> ERRIF_W < 1 > { ERRIF_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccaif (& mut self) -> CCAIF_W < 4 > { CCAIF_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccbif (& mut self) -> CCBIF_W < 5 > { CCBIF_W :: new (self) } # [doc = "Bit 6 - Compare or Capture C Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn cccif (& mut self) -> CCCIF_W < 6 > { CCCIF_W :: new (self) } # [doc = "Bit 7 - Compare or Capture D Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccdif (& mut self) -> CCDIF_W < 7 > { CCDIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct TCE1 { _marker : PhantomData < * const () > } unsafe impl Send for TCE1 { } impl TCE1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tce1 :: RegisterBlock = 0x0a40 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tce1 :: RegisterBlock { Self :: PTR } } impl Deref for TCE1 { type Target = tce1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCE1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCE1") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod tce1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control Register D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control Register E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control Register A"]
pub intctrla : INTCTRLA , # [doc = "0x07 - Interrupt Control Register B"]
pub intctrlb : INTCTRLB , # [doc = "0x08 - Control Register F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x09 - Control Register F Set"]
pub ctrlfset : CTRLFSET , # [doc = "0x0a - Control Register G Clear"]
pub ctrlgclr : CTRLGCLR , # [doc = "0x0b - Control Register G Set"]
pub ctrlgset : CTRLGSET , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved12 : [u8 ; 0x02]
, # [doc = "0x0f - Temporary Register For 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare or Capture A"]
pub cca : CCA , # [doc = "0x2a - Compare or Capture B"]
pub ccb : CCB , _reserved17 : [u8 ; 0x0a]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare Or Capture A Buffer"]
pub ccabuf : CCABUF , # [doc = "0x3a - Compare Or Capture B Buffer"]
pub ccbbuf : CCBBUF , } # [doc = "CCA (rw) register accessor: an alias for `Reg<CCA_SPEC>`"]
pub type CCA = crate :: Reg < cca :: CCA_SPEC > ; # [doc = "Compare or Capture A"]
pub mod cca { # [doc = "Register `CCA` reader"]
pub struct R (crate :: R < CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA` writer"]
pub struct W (crate :: W < CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca](index.html) module"]
pub struct CCA_SPEC ; impl crate :: RegisterSpec for CCA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cca::R](R) reader structure"]
impl crate :: Readable for CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca::W](W) writer structure"]
impl crate :: Writable for CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA to value 0"]
impl crate :: Resettable for CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCABUF (rw) register accessor: an alias for `Reg<CCABUF_SPEC>`"]
pub type CCABUF = crate :: Reg < ccabuf :: CCABUF_SPEC > ; # [doc = "Compare Or Capture A Buffer"]
pub mod ccabuf { # [doc = "Register `CCABUF` reader"]
pub struct R (crate :: R < CCABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCABUF` writer"]
pub struct W (crate :: W < CCABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCABUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture A Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccabuf](index.html) module"]
pub struct CCABUF_SPEC ; impl crate :: RegisterSpec for CCABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccabuf::R](R) reader structure"]
impl crate :: Readable for CCABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccabuf::W](W) writer structure"]
impl crate :: Writable for CCABUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCABUF to value 0"]
impl crate :: Resettable for CCABUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCB (rw) register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare or Capture B"]
pub mod ccb { # [doc = "Register `CCB` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCB to value 0"]
impl crate :: Resettable for CCB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCBBUF (rw) register accessor: an alias for `Reg<CCBBUF_SPEC>`"]
pub type CCBBUF = crate :: Reg < ccbbuf :: CCBBUF_SPEC > ; # [doc = "Compare Or Capture B Buffer"]
pub mod ccbbuf { # [doc = "Register `CCBBUF` reader"]
pub struct R (crate :: R < CCBBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCBBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCBBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCBBUF` writer"]
pub struct W (crate :: W < CCBBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCBBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCBBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture B Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccbbuf](index.html) module"]
pub struct CCBBUF_SPEC ; impl crate :: RegisterSpec for CCBBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccbbuf::R](R) reader structure"]
impl crate :: Readable for CCBBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccbbuf::W](W) writer structure"]
impl crate :: Writable for CCBBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCBBUF to value 0"]
impl crate :: Resettable for CCBBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Timer Off"]
OFF = 0 , # [doc = "1: System Clock"]
DIV1 = 1 , # [doc = "2: System Clock / 2"]
DIV2 = 2 , # [doc = "3: System Clock / 4"]
DIV4 = 3 , # [doc = "4: System Clock / 8"]
DIV8 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , # [doc = "8: Event Channel 0"]
EVCH0 = 8 , # [doc = "9: Event Channel 1"]
EVCH1 = 9 , # [doc = "10: Event Channel 2"]
EVCH2 = 10 , # [doc = "11: Event Channel 3"]
EVCH3 = 11 , # [doc = "12: Event Channel 4"]
EVCH4 = 12 , # [doc = "13: Event Channel 5"]
EVCH5 = 13 , # [doc = "14: Event Channel 6"]
EVCH6 = 14 , # [doc = "15: Event Channel 7"]
EVCH7 = 15 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OFF , 1 => CLKSEL_A :: DIV1 , 2 => CLKSEL_A :: DIV2 , 3 => CLKSEL_A :: DIV4 , 4 => CLKSEL_A :: DIV8 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , 8 => CLKSEL_A :: EVCH0 , 9 => CLKSEL_A :: EVCH1 , 10 => CLKSEL_A :: EVCH2 , 11 => CLKSEL_A :: EVCH3 , 12 => CLKSEL_A :: EVCH4 , 13 => CLKSEL_A :: EVCH5 , 14 => CLKSEL_A :: EVCH6 , 15 => CLKSEL_A :: EVCH7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKSEL_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } # [doc = "Checks if the value of the field is `EVCH0`"]
# [inline (always)]
pub fn is_evch0 (& self) -> bool { * self == CLKSEL_A :: EVCH0 } # [doc = "Checks if the value of the field is `EVCH1`"]
# [inline (always)]
pub fn is_evch1 (& self) -> bool { * self == CLKSEL_A :: EVCH1 } # [doc = "Checks if the value of the field is `EVCH2`"]
# [inline (always)]
pub fn is_evch2 (& self) -> bool { * self == CLKSEL_A :: EVCH2 } # [doc = "Checks if the value of the field is `EVCH3`"]
# [inline (always)]
pub fn is_evch3 (& self) -> bool { * self == CLKSEL_A :: EVCH3 } # [doc = "Checks if the value of the field is `EVCH4`"]
# [inline (always)]
pub fn is_evch4 (& self) -> bool { * self == CLKSEL_A :: EVCH4 } # [doc = "Checks if the value of the field is `EVCH5`"]
# [inline (always)]
pub fn is_evch5 (& self) -> bool { * self == CLKSEL_A :: EVCH5 } # [doc = "Checks if the value of the field is `EVCH6`"]
# [inline (always)]
pub fn is_evch6 (& self) -> bool { * self == CLKSEL_A :: EVCH6 } # [doc = "Checks if the value of the field is `EVCH7`"]
# [inline (always)]
pub fn is_evch7 (& self) -> bool { * self == CLKSEL_A :: EVCH7 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 4 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKSEL_A :: OFF) } # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn evch0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn evch1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn evch2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn evch3 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn evch4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn evch5 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn evch6 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn evch7 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH7) } } impl R { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope"]
SS = 3 , # [doc = "5: Dual Slope, Update on TOP"]
DS_T = 5 , # [doc = "6: Dual Slope, Update on TOP and BOTTOM"]
DS_TB = 6 , # [doc = "7: Dual Slope, Update on BOTTOM"]
DS_B = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SS) , 5 => Some (WGMODE_A :: DS_T) , 6 => Some (WGMODE_A :: DS_TB) , 7 => Some (WGMODE_A :: DS_B) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == WGMODE_A :: SS } # [doc = "Checks if the value of the field is `DS_T`"]
# [inline (always)]
pub fn is_ds_t (& self) -> bool { * self == WGMODE_A :: DS_T } # [doc = "Checks if the value of the field is `DS_TB`"]
# [inline (always)]
pub fn is_ds_tb (& self) -> bool { * self == WGMODE_A :: DS_TB } # [doc = "Checks if the value of the field is `DS_B`"]
# [inline (always)]
pub fn is_ds_b (& self) -> bool { * self == WGMODE_A :: DS_B } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (WGMODE_A :: SS) } # [doc = "Dual Slope, Update on TOP"]
# [inline (always)]
pub fn ds_t (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_T) } # [doc = "Dual Slope, Update on TOP and BOTTOM"]
# [inline (always)]
pub fn ds_tb (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_TB) } # [doc = "Dual Slope, Update on BOTTOM"]
# [inline (always)]
pub fn ds_b (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_B) } } # [doc = "Field `CCAEN` reader - Compare or Capture A Enable"]
pub type CCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCAEN` writer - Compare or Capture A Enable"]
pub type CCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCBEN` reader - Compare or Capture B Enable"]
pub type CCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCBEN` writer - Compare or Capture B Enable"]
pub type CCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
pub fn ccaen (& self) -> CCAEN_R { CCAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
pub fn ccben (& self) -> CCBEN_R { CCBEN_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
# [must_use]
pub fn ccaen (& mut self) -> CCAEN_W < 4 > { CCAEN_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
# [must_use]
pub fn ccben (& mut self) -> CCBEN_W < 5 > { CCBEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control Register D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Source Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
CH0 = 8 , # [doc = "9: Event Channel 1"]
CH1 = 9 , # [doc = "10: Event Channel 2"]
CH2 = 10 , # [doc = "11: Event Channel 3"]
CH3 = 11 , # [doc = "12: Event Channel 4"]
CH4 = 12 , # [doc = "13: Event Channel 5"]
CH5 = 13 , # [doc = "14: Event Channel 6"]
CH6 = 14 , # [doc = "15: Event Channel 7"]
CH7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: CH0) , 9 => Some (EVSEL_A :: CH1) , 10 => Some (EVSEL_A :: CH2) , 11 => Some (EVSEL_A :: CH3) , 12 => Some (EVSEL_A :: CH4) , 13 => Some (EVSEL_A :: CH5) , 14 => Some (EVSEL_A :: CH6) , 15 => Some (EVSEL_A :: CH7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVSEL_A :: CH0 } # [doc = "Checks if the value of the field is `CH1`"]
# [inline (always)]
pub fn is_ch1 (& self) -> bool { * self == EVSEL_A :: CH1 } # [doc = "Checks if the value of the field is `CH2`"]
# [inline (always)]
pub fn is_ch2 (& self) -> bool { * self == EVSEL_A :: CH2 } # [doc = "Checks if the value of the field is `CH3`"]
# [inline (always)]
pub fn is_ch3 (& self) -> bool { * self == EVSEL_A :: CH3 } # [doc = "Checks if the value of the field is `CH4`"]
# [inline (always)]
pub fn is_ch4 (& self) -> bool { * self == EVSEL_A :: CH4 } # [doc = "Checks if the value of the field is `CH5`"]
# [inline (always)]
pub fn is_ch5 (& self) -> bool { * self == EVSEL_A :: CH5 } # [doc = "Checks if the value of the field is `CH6`"]
# [inline (always)]
pub fn is_ch6 (& self) -> bool { * self == EVSEL_A :: CH6 } # [doc = "Checks if the value of the field is `CH7`"]
# [inline (always)]
pub fn is_ch7 (& self) -> bool { * self == EVSEL_A :: CH7 } } # [doc = "Field `EVSEL` writer - Event Source Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn ch1 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn ch2 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn ch3 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn ch4 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn ch5 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn ch6 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn ch7 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH7) } } # [doc = "Field `EVDLY` reader - Event Delay"]
pub type EVDLY_R = crate :: BitReader < bool > ; # [doc = "Field `EVDLY` writer - Event Delay"]
pub type EVDLY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No Event Action"]
OFF = 0 , # [doc = "1: Input Capture"]
CAPT = 1 , # [doc = "2: Externally Controlled Up/Down Count"]
UPDOWN = 2 , # [doc = "3: Quadrature Decode"]
QDEC = 3 , # [doc = "4: Restart"]
RESTART = 4 , # [doc = "5: Frequency Capture"]
FRQ = 5 , # [doc = "6: Pulse-width Capture"]
PW = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: CAPT) , 2 => Some (EVACT_A :: UPDOWN) , 3 => Some (EVACT_A :: QDEC) , 4 => Some (EVACT_A :: RESTART) , 5 => Some (EVACT_A :: FRQ) , 6 => Some (EVACT_A :: PW) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == EVACT_A :: CAPT } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } # [doc = "Checks if the value of the field is `QDEC`"]
# [inline (always)]
pub fn is_qdec (& self) -> bool { * self == EVACT_A :: QDEC } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == EVACT_A :: RESTART } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == EVACT_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == EVACT_A :: PW } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No Event Action"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Input Capture"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (EVACT_A :: CAPT) } # [doc = "Externally Controlled Up/Down Count"]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } # [doc = "Quadrature Decode"]
# [inline (always)]
pub fn qdec (self) -> & 'a mut W { self . variant (EVACT_A :: QDEC) } # [doc = "Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (EVACT_A :: RESTART) } # [doc = "Frequency Capture"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (EVACT_A :: FRQ) } # [doc = "Pulse-width Capture"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (EVACT_A :: PW) } } impl R { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
pub fn evdly (& self) -> EVDLY_R { EVDLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
# [must_use]
pub fn evdly (& mut self) -> EVDLY_W < 4 > { EVDLY_W :: new (self) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 5 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control Register E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BYTEM` reader - Byte Mode"]
pub type BYTEM_R = crate :: BitReader < bool > ; # [doc = "Field `BYTEM` writer - Byte Mode"]
pub type BYTEM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
pub fn bytem (& self) -> BYTEM_R { BYTEM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
# [must_use]
pub fn bytem (& mut self) -> BYTEM_W < 0 > { BYTEM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control Register F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFCLR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control Register F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFSET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGCLR (rw) register accessor: an alias for `Reg<CTRLGCLR_SPEC>`"]
pub type CTRLGCLR = crate :: Reg < ctrlgclr :: CTRLGCLR_SPEC > ; # [doc = "Control Register G Clear"]
pub mod ctrlgclr { # [doc = "Register `CTRLGCLR` reader"]
pub struct R (crate :: R < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGCLR` writer"]
pub struct W (crate :: W < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgclr](index.html) module"]
pub struct CTRLGCLR_SPEC ; impl crate :: RegisterSpec for CTRLGCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgclr::R](R) reader structure"]
impl crate :: Readable for CTRLGCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgclr::W](W) writer structure"]
impl crate :: Writable for CTRLGCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGCLR to value 0"]
impl crate :: Resettable for CTRLGCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGSET (rw) register accessor: an alias for `Reg<CTRLGSET_SPEC>`"]
pub type CTRLGSET = crate :: Reg < ctrlgset :: CTRLGSET_SPEC > ; # [doc = "Control Register G Set"]
pub mod ctrlgset { # [doc = "Register `CTRLGSET` reader"]
pub struct R (crate :: R < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGSET` writer"]
pub struct W (crate :: W < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgset](index.html) module"]
pub struct CTRLGSET_SPEC ; impl crate :: RegisterSpec for CTRLGSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgset::R](R) reader structure"]
impl crate :: Readable for CTRLGSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgset::W](W) writer structure"]
impl crate :: Writable for CTRLGSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGSET to value 0"]
impl crate :: Resettable for CTRLGSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLA (rw) register accessor: an alias for `Reg<INTCTRLA_SPEC>`"]
pub type INTCTRLA = crate :: Reg < intctrla :: INTCTRLA_SPEC > ; # [doc = "Interrupt Control Register A"]
pub mod intctrla { # [doc = "Register `INTCTRLA` reader"]
pub struct R (crate :: R < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLA` writer"]
pub struct W (crate :: W < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow interrupt level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow interrupt level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `ERRINTLVL` reader - Error Interrupt Level"]
pub type ERRINTLVL_R = crate :: FieldReader < u8 , ERRINTLVL_A > ; # [doc = "Error Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ERRINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < ERRINTLVL_A > for u8 { # [inline (always)]
fn from (variant : ERRINTLVL_A) -> Self { variant as _ } } impl ERRINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ERRINTLVL_A { match self . bits { 0 => ERRINTLVL_A :: OFF , 1 => ERRINTLVL_A :: LO , 2 => ERRINTLVL_A :: MED , 3 => ERRINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ERRINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == ERRINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == ERRINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == ERRINTLVL_A :: HI } } # [doc = "Field `ERRINTLVL` writer - Error Interrupt Level"]
pub type ERRINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , ERRINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > ERRINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
pub fn errintlvl (& self) -> ERRINTLVL_R { ERRINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn errintlvl (& mut self) -> ERRINTLVL_W < 2 > { ERRINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrla](index.html) module"]
pub struct INTCTRLA_SPEC ; impl crate :: RegisterSpec for INTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrla::R](R) reader structure"]
impl crate :: Readable for INTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrla::W](W) writer structure"]
impl crate :: Writable for INTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLA to value 0"]
impl crate :: Resettable for INTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLB (rw) register accessor: an alias for `Reg<INTCTRLB_SPEC>`"]
pub type INTCTRLB = crate :: Reg < intctrlb :: INTCTRLB_SPEC > ; # [doc = "Interrupt Control Register B"]
pub mod intctrlb { # [doc = "Register `INTCTRLB` reader"]
pub struct R (crate :: R < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLB` writer"]
pub struct W (crate :: W < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCAINTLVL` reader - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_R = crate :: FieldReader < u8 , CCAINTLVL_A > ; # [doc = "Compare or Capture A Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCAINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCAINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCAINTLVL_A) -> Self { variant as _ } } impl CCAINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCAINTLVL_A { match self . bits { 0 => CCAINTLVL_A :: OFF , 1 => CCAINTLVL_A :: LO , 2 => CCAINTLVL_A :: MED , 3 => CCAINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCAINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCAINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCAINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCAINTLVL_A :: HI } } # [doc = "Field `CCAINTLVL` writer - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCAINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCAINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: HI) } } # [doc = "Field `CCBINTLVL` reader - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_R = crate :: FieldReader < u8 , CCBINTLVL_A > ; # [doc = "Compare or Capture B Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCBINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCBINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCBINTLVL_A) -> Self { variant as _ } } impl CCBINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCBINTLVL_A { match self . bits { 0 => CCBINTLVL_A :: OFF , 1 => CCBINTLVL_A :: LO , 2 => CCBINTLVL_A :: MED , 3 => CCBINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCBINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCBINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCBINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCBINTLVL_A :: HI } } # [doc = "Field `CCBINTLVL` writer - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCBINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCBINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
pub fn ccaintlvl (& self) -> CCAINTLVL_R { CCAINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
pub fn ccbintlvl (& self) -> CCBINTLVL_R { CCBINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccaintlvl (& mut self) -> CCAINTLVL_W < 0 > { CCAINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccbintlvl (& mut self) -> CCBINTLVL_W < 2 > { CCBINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrlb](index.html) module"]
pub struct INTCTRLB_SPEC ; impl crate :: RegisterSpec for INTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrlb::R](R) reader structure"]
impl crate :: Readable for INTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrlb::W](W) writer structure"]
impl crate :: Writable for INTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLB to value 0"]
impl crate :: Resettable for INTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `ERRIF` reader - Error Interrupt Flag"]
pub type ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `ERRIF` writer - Error Interrupt Flag"]
pub type ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCAIF` reader - Compare or Capture A Interrupt Flag"]
pub type CCAIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCAIF` writer - Compare or Capture A Interrupt Flag"]
pub type CCAIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCBIF` reader - Compare or Capture B Interrupt Flag"]
pub type CCBIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCBIF` writer - Compare or Capture B Interrupt Flag"]
pub type CCBIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
pub fn errif (& self) -> ERRIF_R { ERRIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
pub fn ccaif (& self) -> CCAIF_R { CCAIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
pub fn ccbif (& self) -> CCBIF_R { CCBIF_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn errif (& mut self) -> ERRIF_W < 1 > { ERRIF_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccaif (& mut self) -> CCAIF_W < 4 > { CCAIF_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccbif (& mut self) -> CCBIF_W < 5 > { CCBIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct TCF0 { _marker : PhantomData < * const () > } unsafe impl Send for TCF0 { } impl TCF0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcf0 :: RegisterBlock = 0x0b00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcf0 :: RegisterBlock { Self :: PTR } } impl Deref for TCF0 { type Target = tcf0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCF0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCF0") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod tcf0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control Register D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control Register E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control Register A"]
pub intctrla : INTCTRLA , # [doc = "0x07 - Interrupt Control Register B"]
pub intctrlb : INTCTRLB , # [doc = "0x08 - Control Register F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x09 - Control Register F Set"]
pub ctrlfset : CTRLFSET , # [doc = "0x0a - Control Register G Clear"]
pub ctrlgclr : CTRLGCLR , # [doc = "0x0b - Control Register G Set"]
pub ctrlgset : CTRLGSET , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved12 : [u8 ; 0x02]
, # [doc = "0x0f - Temporary Register For 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare or Capture A"]
pub cca : CCA , # [doc = "0x2a - Compare or Capture B"]
pub ccb : CCB , # [doc = "0x2c - Compare or Capture C"]
pub ccc : CCC , # [doc = "0x2e - Compare or Capture D"]
pub ccd : CCD , _reserved19 : [u8 ; 0x06]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare Or Capture A Buffer"]
pub ccabuf : CCABUF , # [doc = "0x3a - Compare Or Capture B Buffer"]
pub ccbbuf : CCBBUF , # [doc = "0x3c - Compare Or Capture C Buffer"]
pub cccbuf : CCCBUF , # [doc = "0x3e - Compare Or Capture D Buffer"]
pub ccdbuf : CCDBUF , } # [doc = "CCA (rw) register accessor: an alias for `Reg<CCA_SPEC>`"]
pub type CCA = crate :: Reg < cca :: CCA_SPEC > ; # [doc = "Compare or Capture A"]
pub mod cca { # [doc = "Register `CCA` reader"]
pub struct R (crate :: R < CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA` writer"]
pub struct W (crate :: W < CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca](index.html) module"]
pub struct CCA_SPEC ; impl crate :: RegisterSpec for CCA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cca::R](R) reader structure"]
impl crate :: Readable for CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca::W](W) writer structure"]
impl crate :: Writable for CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA to value 0"]
impl crate :: Resettable for CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCABUF (rw) register accessor: an alias for `Reg<CCABUF_SPEC>`"]
pub type CCABUF = crate :: Reg < ccabuf :: CCABUF_SPEC > ; # [doc = "Compare Or Capture A Buffer"]
pub mod ccabuf { # [doc = "Register `CCABUF` reader"]
pub struct R (crate :: R < CCABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCABUF` writer"]
pub struct W (crate :: W < CCABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCABUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture A Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccabuf](index.html) module"]
pub struct CCABUF_SPEC ; impl crate :: RegisterSpec for CCABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccabuf::R](R) reader structure"]
impl crate :: Readable for CCABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccabuf::W](W) writer structure"]
impl crate :: Writable for CCABUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCABUF to value 0"]
impl crate :: Resettable for CCABUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCB (rw) register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare or Capture B"]
pub mod ccb { # [doc = "Register `CCB` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCB to value 0"]
impl crate :: Resettable for CCB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCBBUF (rw) register accessor: an alias for `Reg<CCBBUF_SPEC>`"]
pub type CCBBUF = crate :: Reg < ccbbuf :: CCBBUF_SPEC > ; # [doc = "Compare Or Capture B Buffer"]
pub mod ccbbuf { # [doc = "Register `CCBBUF` reader"]
pub struct R (crate :: R < CCBBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCBBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCBBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCBBUF` writer"]
pub struct W (crate :: W < CCBBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCBBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCBBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture B Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccbbuf](index.html) module"]
pub struct CCBBUF_SPEC ; impl crate :: RegisterSpec for CCBBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccbbuf::R](R) reader structure"]
impl crate :: Readable for CCBBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccbbuf::W](W) writer structure"]
impl crate :: Writable for CCBBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCBBUF to value 0"]
impl crate :: Resettable for CCBBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCC (rw) register accessor: an alias for `Reg<CCC_SPEC>`"]
pub type CCC = crate :: Reg < ccc :: CCC_SPEC > ; # [doc = "Compare or Capture C"]
pub mod ccc { # [doc = "Register `CCC` reader"]
pub struct R (crate :: R < CCC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCC` writer"]
pub struct W (crate :: W < CCC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCC_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccc](index.html) module"]
pub struct CCC_SPEC ; impl crate :: RegisterSpec for CCC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccc::R](R) reader structure"]
impl crate :: Readable for CCC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccc::W](W) writer structure"]
impl crate :: Writable for CCC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCC to value 0"]
impl crate :: Resettable for CCC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCCBUF (rw) register accessor: an alias for `Reg<CCCBUF_SPEC>`"]
pub type CCCBUF = crate :: Reg < cccbuf :: CCCBUF_SPEC > ; # [doc = "Compare Or Capture C Buffer"]
pub mod cccbuf { # [doc = "Register `CCCBUF` reader"]
pub struct R (crate :: R < CCCBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCCBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCCBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCCBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCCBUF` writer"]
pub struct W (crate :: W < CCCBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCCBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCCBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCCBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture C Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cccbuf](index.html) module"]
pub struct CCCBUF_SPEC ; impl crate :: RegisterSpec for CCCBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cccbuf::R](R) reader structure"]
impl crate :: Readable for CCCBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cccbuf::W](W) writer structure"]
impl crate :: Writable for CCCBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCCBUF to value 0"]
impl crate :: Resettable for CCCBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCD (rw) register accessor: an alias for `Reg<CCD_SPEC>`"]
pub type CCD = crate :: Reg < ccd :: CCD_SPEC > ; # [doc = "Compare or Capture D"]
pub mod ccd { # [doc = "Register `CCD` reader"]
pub struct R (crate :: R < CCD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCD` writer"]
pub struct W (crate :: W < CCD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCD_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccd](index.html) module"]
pub struct CCD_SPEC ; impl crate :: RegisterSpec for CCD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccd::R](R) reader structure"]
impl crate :: Readable for CCD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccd::W](W) writer structure"]
impl crate :: Writable for CCD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCD to value 0"]
impl crate :: Resettable for CCD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCDBUF (rw) register accessor: an alias for `Reg<CCDBUF_SPEC>`"]
pub type CCDBUF = crate :: Reg < ccdbuf :: CCDBUF_SPEC > ; # [doc = "Compare Or Capture D Buffer"]
pub mod ccdbuf { # [doc = "Register `CCDBUF` reader"]
pub struct R (crate :: R < CCDBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCDBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCDBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCDBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCDBUF` writer"]
pub struct W (crate :: W < CCDBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCDBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCDBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCDBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture D Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccdbuf](index.html) module"]
pub struct CCDBUF_SPEC ; impl crate :: RegisterSpec for CCDBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccdbuf::R](R) reader structure"]
impl crate :: Readable for CCDBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccdbuf::W](W) writer structure"]
impl crate :: Writable for CCDBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCDBUF to value 0"]
impl crate :: Resettable for CCDBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Timer Off"]
OFF = 0 , # [doc = "1: System Clock"]
DIV1 = 1 , # [doc = "2: System Clock / 2"]
DIV2 = 2 , # [doc = "3: System Clock / 4"]
DIV4 = 3 , # [doc = "4: System Clock / 8"]
DIV8 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , # [doc = "8: Event Channel 0"]
EVCH0 = 8 , # [doc = "9: Event Channel 1"]
EVCH1 = 9 , # [doc = "10: Event Channel 2"]
EVCH2 = 10 , # [doc = "11: Event Channel 3"]
EVCH3 = 11 , # [doc = "12: Event Channel 4"]
EVCH4 = 12 , # [doc = "13: Event Channel 5"]
EVCH5 = 13 , # [doc = "14: Event Channel 6"]
EVCH6 = 14 , # [doc = "15: Event Channel 7"]
EVCH7 = 15 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OFF , 1 => CLKSEL_A :: DIV1 , 2 => CLKSEL_A :: DIV2 , 3 => CLKSEL_A :: DIV4 , 4 => CLKSEL_A :: DIV8 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , 8 => CLKSEL_A :: EVCH0 , 9 => CLKSEL_A :: EVCH1 , 10 => CLKSEL_A :: EVCH2 , 11 => CLKSEL_A :: EVCH3 , 12 => CLKSEL_A :: EVCH4 , 13 => CLKSEL_A :: EVCH5 , 14 => CLKSEL_A :: EVCH6 , 15 => CLKSEL_A :: EVCH7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKSEL_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } # [doc = "Checks if the value of the field is `EVCH0`"]
# [inline (always)]
pub fn is_evch0 (& self) -> bool { * self == CLKSEL_A :: EVCH0 } # [doc = "Checks if the value of the field is `EVCH1`"]
# [inline (always)]
pub fn is_evch1 (& self) -> bool { * self == CLKSEL_A :: EVCH1 } # [doc = "Checks if the value of the field is `EVCH2`"]
# [inline (always)]
pub fn is_evch2 (& self) -> bool { * self == CLKSEL_A :: EVCH2 } # [doc = "Checks if the value of the field is `EVCH3`"]
# [inline (always)]
pub fn is_evch3 (& self) -> bool { * self == CLKSEL_A :: EVCH3 } # [doc = "Checks if the value of the field is `EVCH4`"]
# [inline (always)]
pub fn is_evch4 (& self) -> bool { * self == CLKSEL_A :: EVCH4 } # [doc = "Checks if the value of the field is `EVCH5`"]
# [inline (always)]
pub fn is_evch5 (& self) -> bool { * self == CLKSEL_A :: EVCH5 } # [doc = "Checks if the value of the field is `EVCH6`"]
# [inline (always)]
pub fn is_evch6 (& self) -> bool { * self == CLKSEL_A :: EVCH6 } # [doc = "Checks if the value of the field is `EVCH7`"]
# [inline (always)]
pub fn is_evch7 (& self) -> bool { * self == CLKSEL_A :: EVCH7 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 4 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKSEL_A :: OFF) } # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn evch0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn evch1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn evch2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn evch3 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn evch4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn evch5 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn evch6 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn evch7 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH7) } } impl R { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope"]
SS = 3 , # [doc = "5: Dual Slope, Update on TOP"]
DS_T = 5 , # [doc = "6: Dual Slope, Update on TOP and BOTTOM"]
DS_TB = 6 , # [doc = "7: Dual Slope, Update on BOTTOM"]
DS_B = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SS) , 5 => Some (WGMODE_A :: DS_T) , 6 => Some (WGMODE_A :: DS_TB) , 7 => Some (WGMODE_A :: DS_B) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == WGMODE_A :: SS } # [doc = "Checks if the value of the field is `DS_T`"]
# [inline (always)]
pub fn is_ds_t (& self) -> bool { * self == WGMODE_A :: DS_T } # [doc = "Checks if the value of the field is `DS_TB`"]
# [inline (always)]
pub fn is_ds_tb (& self) -> bool { * self == WGMODE_A :: DS_TB } # [doc = "Checks if the value of the field is `DS_B`"]
# [inline (always)]
pub fn is_ds_b (& self) -> bool { * self == WGMODE_A :: DS_B } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (WGMODE_A :: SS) } # [doc = "Dual Slope, Update on TOP"]
# [inline (always)]
pub fn ds_t (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_T) } # [doc = "Dual Slope, Update on TOP and BOTTOM"]
# [inline (always)]
pub fn ds_tb (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_TB) } # [doc = "Dual Slope, Update on BOTTOM"]
# [inline (always)]
pub fn ds_b (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_B) } } # [doc = "Field `CCAEN` reader - Compare or Capture A Enable"]
pub type CCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCAEN` writer - Compare or Capture A Enable"]
pub type CCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCBEN` reader - Compare or Capture B Enable"]
pub type CCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCBEN` writer - Compare or Capture B Enable"]
pub type CCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCCEN` reader - Compare or Capture C Enable"]
pub type CCCEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCCEN` writer - Compare or Capture C Enable"]
pub type CCCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCDEN` reader - Compare or Capture D Enable"]
pub type CCDEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCDEN` writer - Compare or Capture D Enable"]
pub type CCDEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
pub fn ccaen (& self) -> CCAEN_R { CCAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
pub fn ccben (& self) -> CCBEN_R { CCBEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare or Capture C Enable"]
# [inline (always)]
pub fn cccen (& self) -> CCCEN_R { CCCEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare or Capture D Enable"]
# [inline (always)]
pub fn ccden (& self) -> CCDEN_R { CCDEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
# [must_use]
pub fn ccaen (& mut self) -> CCAEN_W < 4 > { CCAEN_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
# [must_use]
pub fn ccben (& mut self) -> CCBEN_W < 5 > { CCBEN_W :: new (self) } # [doc = "Bit 6 - Compare or Capture C Enable"]
# [inline (always)]
# [must_use]
pub fn cccen (& mut self) -> CCCEN_W < 6 > { CCCEN_W :: new (self) } # [doc = "Bit 7 - Compare or Capture D Enable"]
# [inline (always)]
# [must_use]
pub fn ccden (& mut self) -> CCDEN_W < 7 > { CCDEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPC` reader - Compare C Output Value"]
pub type CMPC_R = crate :: BitReader < bool > ; # [doc = "Field `CMPC` writer - Compare C Output Value"]
pub type CMPC_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPD` reader - Compare D Output Value"]
pub type CMPD_R = crate :: BitReader < bool > ; # [doc = "Field `CMPD` writer - Compare D Output Value"]
pub type CMPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare C Output Value"]
# [inline (always)]
pub fn cmpc (& self) -> CMPC_R { CMPC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare D Output Value"]
# [inline (always)]
pub fn cmpd (& self) -> CMPD_R { CMPD_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Bit 2 - Compare C Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpc (& mut self) -> CMPC_W < 2 > { CMPC_W :: new (self) } # [doc = "Bit 3 - Compare D Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpd (& mut self) -> CMPD_W < 3 > { CMPD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control Register D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Source Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
CH0 = 8 , # [doc = "9: Event Channel 1"]
CH1 = 9 , # [doc = "10: Event Channel 2"]
CH2 = 10 , # [doc = "11: Event Channel 3"]
CH3 = 11 , # [doc = "12: Event Channel 4"]
CH4 = 12 , # [doc = "13: Event Channel 5"]
CH5 = 13 , # [doc = "14: Event Channel 6"]
CH6 = 14 , # [doc = "15: Event Channel 7"]
CH7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: CH0) , 9 => Some (EVSEL_A :: CH1) , 10 => Some (EVSEL_A :: CH2) , 11 => Some (EVSEL_A :: CH3) , 12 => Some (EVSEL_A :: CH4) , 13 => Some (EVSEL_A :: CH5) , 14 => Some (EVSEL_A :: CH6) , 15 => Some (EVSEL_A :: CH7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVSEL_A :: CH0 } # [doc = "Checks if the value of the field is `CH1`"]
# [inline (always)]
pub fn is_ch1 (& self) -> bool { * self == EVSEL_A :: CH1 } # [doc = "Checks if the value of the field is `CH2`"]
# [inline (always)]
pub fn is_ch2 (& self) -> bool { * self == EVSEL_A :: CH2 } # [doc = "Checks if the value of the field is `CH3`"]
# [inline (always)]
pub fn is_ch3 (& self) -> bool { * self == EVSEL_A :: CH3 } # [doc = "Checks if the value of the field is `CH4`"]
# [inline (always)]
pub fn is_ch4 (& self) -> bool { * self == EVSEL_A :: CH4 } # [doc = "Checks if the value of the field is `CH5`"]
# [inline (always)]
pub fn is_ch5 (& self) -> bool { * self == EVSEL_A :: CH5 } # [doc = "Checks if the value of the field is `CH6`"]
# [inline (always)]
pub fn is_ch6 (& self) -> bool { * self == EVSEL_A :: CH6 } # [doc = "Checks if the value of the field is `CH7`"]
# [inline (always)]
pub fn is_ch7 (& self) -> bool { * self == EVSEL_A :: CH7 } } # [doc = "Field `EVSEL` writer - Event Source Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn ch1 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn ch2 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn ch3 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn ch4 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn ch5 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn ch6 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn ch7 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH7) } } # [doc = "Field `EVDLY` reader - Event Delay"]
pub type EVDLY_R = crate :: BitReader < bool > ; # [doc = "Field `EVDLY` writer - Event Delay"]
pub type EVDLY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No Event Action"]
OFF = 0 , # [doc = "1: Input Capture"]
CAPT = 1 , # [doc = "2: Externally Controlled Up/Down Count"]
UPDOWN = 2 , # [doc = "3: Quadrature Decode"]
QDEC = 3 , # [doc = "4: Restart"]
RESTART = 4 , # [doc = "5: Frequency Capture"]
FRQ = 5 , # [doc = "6: Pulse-width Capture"]
PW = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: CAPT) , 2 => Some (EVACT_A :: UPDOWN) , 3 => Some (EVACT_A :: QDEC) , 4 => Some (EVACT_A :: RESTART) , 5 => Some (EVACT_A :: FRQ) , 6 => Some (EVACT_A :: PW) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == EVACT_A :: CAPT } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } # [doc = "Checks if the value of the field is `QDEC`"]
# [inline (always)]
pub fn is_qdec (& self) -> bool { * self == EVACT_A :: QDEC } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == EVACT_A :: RESTART } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == EVACT_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == EVACT_A :: PW } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No Event Action"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Input Capture"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (EVACT_A :: CAPT) } # [doc = "Externally Controlled Up/Down Count"]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } # [doc = "Quadrature Decode"]
# [inline (always)]
pub fn qdec (self) -> & 'a mut W { self . variant (EVACT_A :: QDEC) } # [doc = "Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (EVACT_A :: RESTART) } # [doc = "Frequency Capture"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (EVACT_A :: FRQ) } # [doc = "Pulse-width Capture"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (EVACT_A :: PW) } } impl R { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
pub fn evdly (& self) -> EVDLY_R { EVDLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
# [must_use]
pub fn evdly (& mut self) -> EVDLY_W < 4 > { EVDLY_W :: new (self) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 5 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control Register E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BYTEM` reader - Byte Mode"]
pub type BYTEM_R = crate :: BitReader < bool > ; # [doc = "Field `BYTEM` writer - Byte Mode"]
pub type BYTEM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
pub fn bytem (& self) -> BYTEM_R { BYTEM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
# [must_use]
pub fn bytem (& mut self) -> BYTEM_W < 0 > { BYTEM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control Register F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFCLR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control Register F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFSET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGCLR (rw) register accessor: an alias for `Reg<CTRLGCLR_SPEC>`"]
pub type CTRLGCLR = crate :: Reg < ctrlgclr :: CTRLGCLR_SPEC > ; # [doc = "Control Register G Clear"]
pub mod ctrlgclr { # [doc = "Register `CTRLGCLR` reader"]
pub struct R (crate :: R < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGCLR` writer"]
pub struct W (crate :: W < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCCBV` reader - Compare or Capture C Buffer Valid"]
pub type CCCBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCCBV` writer - Compare or Capture C Buffer Valid"]
pub type CCCBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCDBV` reader - Compare or Capture D Buffer Valid"]
pub type CCDBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCDBV` writer - Compare or Capture D Buffer Valid"]
pub type CCDBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
pub fn cccbv (& self) -> CCCBV_R { CCCBV_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
pub fn ccdbv (& self) -> CCDBV_R { CCDBV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cccbv (& mut self) -> CCCBV_W < 3 > { CCCBV_W :: new (self) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccdbv (& mut self) -> CCDBV_W < 4 > { CCDBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgclr](index.html) module"]
pub struct CTRLGCLR_SPEC ; impl crate :: RegisterSpec for CTRLGCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgclr::R](R) reader structure"]
impl crate :: Readable for CTRLGCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgclr::W](W) writer structure"]
impl crate :: Writable for CTRLGCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGCLR to value 0"]
impl crate :: Resettable for CTRLGCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGSET (rw) register accessor: an alias for `Reg<CTRLGSET_SPEC>`"]
pub type CTRLGSET = crate :: Reg < ctrlgset :: CTRLGSET_SPEC > ; # [doc = "Control Register G Set"]
pub mod ctrlgset { # [doc = "Register `CTRLGSET` reader"]
pub struct R (crate :: R < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGSET` writer"]
pub struct W (crate :: W < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCCBV` reader - Compare or Capture C Buffer Valid"]
pub type CCCBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCCBV` writer - Compare or Capture C Buffer Valid"]
pub type CCCBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCDBV` reader - Compare or Capture D Buffer Valid"]
pub type CCDBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCDBV` writer - Compare or Capture D Buffer Valid"]
pub type CCDBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
pub fn cccbv (& self) -> CCCBV_R { CCCBV_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
pub fn ccdbv (& self) -> CCDBV_R { CCDBV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Bit 3 - Compare or Capture C Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn cccbv (& mut self) -> CCCBV_W < 3 > { CCCBV_W :: new (self) } # [doc = "Bit 4 - Compare or Capture D Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccdbv (& mut self) -> CCDBV_W < 4 > { CCDBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgset](index.html) module"]
pub struct CTRLGSET_SPEC ; impl crate :: RegisterSpec for CTRLGSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgset::R](R) reader structure"]
impl crate :: Readable for CTRLGSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgset::W](W) writer structure"]
impl crate :: Writable for CTRLGSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGSET to value 0"]
impl crate :: Resettable for CTRLGSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLA (rw) register accessor: an alias for `Reg<INTCTRLA_SPEC>`"]
pub type INTCTRLA = crate :: Reg < intctrla :: INTCTRLA_SPEC > ; # [doc = "Interrupt Control Register A"]
pub mod intctrla { # [doc = "Register `INTCTRLA` reader"]
pub struct R (crate :: R < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLA` writer"]
pub struct W (crate :: W < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow interrupt level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow interrupt level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `ERRINTLVL` reader - Error Interrupt Level"]
pub type ERRINTLVL_R = crate :: FieldReader < u8 , ERRINTLVL_A > ; # [doc = "Error Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ERRINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < ERRINTLVL_A > for u8 { # [inline (always)]
fn from (variant : ERRINTLVL_A) -> Self { variant as _ } } impl ERRINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ERRINTLVL_A { match self . bits { 0 => ERRINTLVL_A :: OFF , 1 => ERRINTLVL_A :: LO , 2 => ERRINTLVL_A :: MED , 3 => ERRINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ERRINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == ERRINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == ERRINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == ERRINTLVL_A :: HI } } # [doc = "Field `ERRINTLVL` writer - Error Interrupt Level"]
pub type ERRINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , ERRINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > ERRINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
pub fn errintlvl (& self) -> ERRINTLVL_R { ERRINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn errintlvl (& mut self) -> ERRINTLVL_W < 2 > { ERRINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrla](index.html) module"]
pub struct INTCTRLA_SPEC ; impl crate :: RegisterSpec for INTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrla::R](R) reader structure"]
impl crate :: Readable for INTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrla::W](W) writer structure"]
impl crate :: Writable for INTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLA to value 0"]
impl crate :: Resettable for INTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLB (rw) register accessor: an alias for `Reg<INTCTRLB_SPEC>`"]
pub type INTCTRLB = crate :: Reg < intctrlb :: INTCTRLB_SPEC > ; # [doc = "Interrupt Control Register B"]
pub mod intctrlb { # [doc = "Register `INTCTRLB` reader"]
pub struct R (crate :: R < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLB` writer"]
pub struct W (crate :: W < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCAINTLVL` reader - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_R = crate :: FieldReader < u8 , CCAINTLVL_A > ; # [doc = "Compare or Capture A Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCAINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCAINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCAINTLVL_A) -> Self { variant as _ } } impl CCAINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCAINTLVL_A { match self . bits { 0 => CCAINTLVL_A :: OFF , 1 => CCAINTLVL_A :: LO , 2 => CCAINTLVL_A :: MED , 3 => CCAINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCAINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCAINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCAINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCAINTLVL_A :: HI } } # [doc = "Field `CCAINTLVL` writer - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCAINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCAINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: HI) } } # [doc = "Field `CCBINTLVL` reader - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_R = crate :: FieldReader < u8 , CCBINTLVL_A > ; # [doc = "Compare or Capture B Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCBINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCBINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCBINTLVL_A) -> Self { variant as _ } } impl CCBINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCBINTLVL_A { match self . bits { 0 => CCBINTLVL_A :: OFF , 1 => CCBINTLVL_A :: LO , 2 => CCBINTLVL_A :: MED , 3 => CCBINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCBINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCBINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCBINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCBINTLVL_A :: HI } } # [doc = "Field `CCBINTLVL` writer - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCBINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCBINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: HI) } } # [doc = "Field `CCCINTLVL` reader - Compare or Capture C Interrupt Level"]
pub type CCCINTLVL_R = crate :: FieldReader < u8 , CCCINTLVL_A > ; # [doc = "Compare or Capture C Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCCINTLVL_A) -> Self { variant as _ } } impl CCCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCCINTLVL_A { match self . bits { 0 => CCCINTLVL_A :: OFF , 1 => CCCINTLVL_A :: LO , 2 => CCCINTLVL_A :: MED , 3 => CCCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCCINTLVL_A :: HI } } # [doc = "Field `CCCINTLVL` writer - Compare or Capture C Interrupt Level"]
pub type CCCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCCINTLVL_A :: HI) } } # [doc = "Field `CCDINTLVL` reader - Compare or Capture D Interrupt Level"]
pub type CCDINTLVL_R = crate :: FieldReader < u8 , CCDINTLVL_A > ; # [doc = "Compare or Capture D Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCDINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCDINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCDINTLVL_A) -> Self { variant as _ } } impl CCDINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCDINTLVL_A { match self . bits { 0 => CCDINTLVL_A :: OFF , 1 => CCDINTLVL_A :: LO , 2 => CCDINTLVL_A :: MED , 3 => CCDINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCDINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCDINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCDINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCDINTLVL_A :: HI } } # [doc = "Field `CCDINTLVL` writer - Compare or Capture D Interrupt Level"]
pub type CCDINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCDINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCDINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCDINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
pub fn ccaintlvl (& self) -> CCAINTLVL_R { CCAINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
pub fn ccbintlvl (& self) -> CCBINTLVL_R { CCBINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Compare or Capture C Interrupt Level"]
# [inline (always)]
pub fn cccintlvl (& self) -> CCCINTLVL_R { CCCINTLVL_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Compare or Capture D Interrupt Level"]
# [inline (always)]
pub fn ccdintlvl (& self) -> CCDINTLVL_R { CCDINTLVL_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccaintlvl (& mut self) -> CCAINTLVL_W < 0 > { CCAINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccbintlvl (& mut self) -> CCBINTLVL_W < 2 > { CCBINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Compare or Capture C Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn cccintlvl (& mut self) -> CCCINTLVL_W < 4 > { CCCINTLVL_W :: new (self) } # [doc = "Bits 6:7 - Compare or Capture D Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccdintlvl (& mut self) -> CCDINTLVL_W < 6 > { CCDINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrlb](index.html) module"]
pub struct INTCTRLB_SPEC ; impl crate :: RegisterSpec for INTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrlb::R](R) reader structure"]
impl crate :: Readable for INTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrlb::W](W) writer structure"]
impl crate :: Writable for INTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLB to value 0"]
impl crate :: Resettable for INTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `ERRIF` reader - Error Interrupt Flag"]
pub type ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `ERRIF` writer - Error Interrupt Flag"]
pub type ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCAIF` reader - Compare or Capture A Interrupt Flag"]
pub type CCAIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCAIF` writer - Compare or Capture A Interrupt Flag"]
pub type CCAIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCBIF` reader - Compare or Capture B Interrupt Flag"]
pub type CCBIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCBIF` writer - Compare or Capture B Interrupt Flag"]
pub type CCBIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCCIF` reader - Compare or Capture C Interrupt Flag"]
pub type CCCIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCCIF` writer - Compare or Capture C Interrupt Flag"]
pub type CCCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCDIF` reader - Compare or Capture D Interrupt Flag"]
pub type CCDIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCDIF` writer - Compare or Capture D Interrupt Flag"]
pub type CCDIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
pub fn errif (& self) -> ERRIF_R { ERRIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
pub fn ccaif (& self) -> CCAIF_R { CCAIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
pub fn ccbif (& self) -> CCBIF_R { CCBIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Compare or Capture C Interrupt Flag"]
# [inline (always)]
pub fn cccif (& self) -> CCCIF_R { CCCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Compare or Capture D Interrupt Flag"]
# [inline (always)]
pub fn ccdif (& self) -> CCDIF_R { CCDIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn errif (& mut self) -> ERRIF_W < 1 > { ERRIF_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccaif (& mut self) -> CCAIF_W < 4 > { CCAIF_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccbif (& mut self) -> CCBIF_W < 5 > { CCBIF_W :: new (self) } # [doc = "Bit 6 - Compare or Capture C Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn cccif (& mut self) -> CCCIF_W < 6 > { CCCIF_W :: new (self) } # [doc = "Bit 7 - Compare or Capture D Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccdif (& mut self) -> CCDIF_W < 7 > { CCDIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "16-bit Timer/Counter With PWM"]
pub struct TCF1 { _marker : PhantomData < * const () > } unsafe impl Send for TCF1 { } impl TCF1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcf1 :: RegisterBlock = 0x0b40 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcf1 :: RegisterBlock { Self :: PTR } } impl Deref for TCF1 { type Target = tcf1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCF1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCF1") . finish () } } # [doc = "16-bit Timer/Counter With PWM"]
pub mod tcf1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x01 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x02 - Control register C"]
pub ctrlc : CTRLC , # [doc = "0x03 - Control Register D"]
pub ctrld : CTRLD , # [doc = "0x04 - Control Register E"]
pub ctrle : CTRLE , _reserved5 : [u8 ; 0x01]
, # [doc = "0x06 - Interrupt Control Register A"]
pub intctrla : INTCTRLA , # [doc = "0x07 - Interrupt Control Register B"]
pub intctrlb : INTCTRLB , # [doc = "0x08 - Control Register F Clear"]
pub ctrlfclr : CTRLFCLR , # [doc = "0x09 - Control Register F Set"]
pub ctrlfset : CTRLFSET , # [doc = "0x0a - Control Register G Clear"]
pub ctrlgclr : CTRLGCLR , # [doc = "0x0b - Control Register G Set"]
pub ctrlgset : CTRLGSET , # [doc = "0x0c - Interrupt Flag Register"]
pub intflags : INTFLAGS , _reserved12 : [u8 ; 0x02]
, # [doc = "0x0f - Temporary Register For 16-bit Access"]
pub temp : TEMP , _reserved13 : [u8 ; 0x10]
, # [doc = "0x20 - Count"]
pub cnt : CNT , _reserved14 : [u8 ; 0x04]
, # [doc = "0x26 - Period"]
pub per : PER , # [doc = "0x28 - Compare or Capture A"]
pub cca : CCA , # [doc = "0x2a - Compare or Capture B"]
pub ccb : CCB , _reserved17 : [u8 ; 0x0a]
, # [doc = "0x36 - Period Buffer"]
pub perbuf : PERBUF , # [doc = "0x38 - Compare Or Capture A Buffer"]
pub ccabuf : CCABUF , # [doc = "0x3a - Compare Or Capture B Buffer"]
pub ccbbuf : CCBBUF , } # [doc = "CCA (rw) register accessor: an alias for `Reg<CCA_SPEC>`"]
pub type CCA = crate :: Reg < cca :: CCA_SPEC > ; # [doc = "Compare or Capture A"]
pub mod cca { # [doc = "Register `CCA` reader"]
pub struct R (crate :: R < CCA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCA` writer"]
pub struct W (crate :: W < CCA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cca](index.html) module"]
pub struct CCA_SPEC ; impl crate :: RegisterSpec for CCA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cca::R](R) reader structure"]
impl crate :: Readable for CCA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cca::W](W) writer structure"]
impl crate :: Writable for CCA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCA to value 0"]
impl crate :: Resettable for CCA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCABUF (rw) register accessor: an alias for `Reg<CCABUF_SPEC>`"]
pub type CCABUF = crate :: Reg < ccabuf :: CCABUF_SPEC > ; # [doc = "Compare Or Capture A Buffer"]
pub mod ccabuf { # [doc = "Register `CCABUF` reader"]
pub struct R (crate :: R < CCABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCABUF` writer"]
pub struct W (crate :: W < CCABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCABUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture A Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccabuf](index.html) module"]
pub struct CCABUF_SPEC ; impl crate :: RegisterSpec for CCABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccabuf::R](R) reader structure"]
impl crate :: Readable for CCABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccabuf::W](W) writer structure"]
impl crate :: Writable for CCABUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCABUF to value 0"]
impl crate :: Resettable for CCABUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCB (rw) register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare or Capture B"]
pub mod ccb { # [doc = "Register `CCB` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare or Capture B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCB to value 0"]
impl crate :: Resettable for CCB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CCBBUF (rw) register accessor: an alias for `Reg<CCBBUF_SPEC>`"]
pub type CCBBUF = crate :: Reg < ccbbuf :: CCBBUF_SPEC > ; # [doc = "Compare Or Capture B Buffer"]
pub mod ccbbuf { # [doc = "Register `CCBBUF` reader"]
pub struct R (crate :: R < CCBBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCBBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCBBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCBBUF` writer"]
pub struct W (crate :: W < CCBBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCBBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCBBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCBBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Compare Or Capture B Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccbbuf](index.html) module"]
pub struct CCBBUF_SPEC ; impl crate :: RegisterSpec for CCBBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ccbbuf::R](R) reader structure"]
impl crate :: Readable for CCBBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccbbuf::W](W) writer structure"]
impl crate :: Writable for CCBBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CCBBUF to value 0"]
impl crate :: Resettable for CCBBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CNT (rw) register accessor: an alias for `Reg<CNT_SPEC>`"]
pub type CNT = crate :: Reg < cnt :: CNT_SPEC > ; # [doc = "Count"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub struct R (crate :: R < CNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `CNT` writer"]
pub struct W (crate :: W < CNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CNT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cnt](index.html) module"]
pub struct CNT_SPEC ; impl crate :: RegisterSpec for CNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cnt::R](R) reader structure"]
impl crate :: Readable for CNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cnt::W](W) writer structure"]
impl crate :: Writable for CNT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CNT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `CLKSEL` reader - Clock Selection"]
pub type CLKSEL_R = crate :: FieldReader < u8 , CLKSEL_A > ; # [doc = "Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CLKSEL_A { # [doc = "0: Timer Off"]
OFF = 0 , # [doc = "1: System Clock"]
DIV1 = 1 , # [doc = "2: System Clock / 2"]
DIV2 = 2 , # [doc = "3: System Clock / 4"]
DIV4 = 3 , # [doc = "4: System Clock / 8"]
DIV8 = 4 , # [doc = "5: System Clock / 64"]
DIV64 = 5 , # [doc = "6: System Clock / 256"]
DIV256 = 6 , # [doc = "7: System Clock / 1024"]
DIV1024 = 7 , # [doc = "8: Event Channel 0"]
EVCH0 = 8 , # [doc = "9: Event Channel 1"]
EVCH1 = 9 , # [doc = "10: Event Channel 2"]
EVCH2 = 10 , # [doc = "11: Event Channel 3"]
EVCH3 = 11 , # [doc = "12: Event Channel 4"]
EVCH4 = 12 , # [doc = "13: Event Channel 5"]
EVCH5 = 13 , # [doc = "14: Event Channel 6"]
EVCH6 = 14 , # [doc = "15: Event Channel 7"]
EVCH7 = 15 , } impl From < CLKSEL_A > for u8 { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as _ } } impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { 0 => CLKSEL_A :: OFF , 1 => CLKSEL_A :: DIV1 , 2 => CLKSEL_A :: DIV2 , 3 => CLKSEL_A :: DIV4 , 4 => CLKSEL_A :: DIV8 , 5 => CLKSEL_A :: DIV64 , 6 => CLKSEL_A :: DIV256 , 7 => CLKSEL_A :: DIV1024 , 8 => CLKSEL_A :: EVCH0 , 9 => CLKSEL_A :: EVCH1 , 10 => CLKSEL_A :: EVCH2 , 11 => CLKSEL_A :: EVCH3 , 12 => CLKSEL_A :: EVCH4 , 13 => CLKSEL_A :: EVCH5 , 14 => CLKSEL_A :: EVCH6 , 15 => CLKSEL_A :: EVCH7 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CLKSEL_A :: OFF } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CLKSEL_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CLKSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CLKSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CLKSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CLKSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == CLKSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == CLKSEL_A :: DIV1024 } # [doc = "Checks if the value of the field is `EVCH0`"]
# [inline (always)]
pub fn is_evch0 (& self) -> bool { * self == CLKSEL_A :: EVCH0 } # [doc = "Checks if the value of the field is `EVCH1`"]
# [inline (always)]
pub fn is_evch1 (& self) -> bool { * self == CLKSEL_A :: EVCH1 } # [doc = "Checks if the value of the field is `EVCH2`"]
# [inline (always)]
pub fn is_evch2 (& self) -> bool { * self == CLKSEL_A :: EVCH2 } # [doc = "Checks if the value of the field is `EVCH3`"]
# [inline (always)]
pub fn is_evch3 (& self) -> bool { * self == CLKSEL_A :: EVCH3 } # [doc = "Checks if the value of the field is `EVCH4`"]
# [inline (always)]
pub fn is_evch4 (& self) -> bool { * self == CLKSEL_A :: EVCH4 } # [doc = "Checks if the value of the field is `EVCH5`"]
# [inline (always)]
pub fn is_evch5 (& self) -> bool { * self == CLKSEL_A :: EVCH5 } # [doc = "Checks if the value of the field is `EVCH6`"]
# [inline (always)]
pub fn is_evch6 (& self) -> bool { * self == CLKSEL_A :: EVCH6 } # [doc = "Checks if the value of the field is `EVCH7`"]
# [inline (always)]
pub fn is_evch7 (& self) -> bool { * self == CLKSEL_A :: EVCH7 } } # [doc = "Field `CLKSEL` writer - Clock Selection"]
pub type CLKSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , CLKSEL_A , 4 , O > ; impl < 'a , const O : u8 > CLKSEL_W < 'a , O > { # [doc = "Timer Off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CLKSEL_A :: OFF) } # [doc = "System Clock"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1) } # [doc = "System Clock / 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV2) } # [doc = "System Clock / 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV4) } # [doc = "System Clock / 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV8) } # [doc = "System Clock / 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV64) } # [doc = "System Clock / 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV256) } # [doc = "System Clock / 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (CLKSEL_A :: DIV1024) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn evch0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn evch1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn evch2 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn evch3 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn evch4 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn evch5 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn evch6 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn evch7 (self) -> & 'a mut W { self . variant (CLKSEL_A :: EVCH7) } } impl R { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (self . bits & 0x0f) } } impl W { # [doc = "Bits 0:3 - Clock Selection"]
# [inline (always)]
# [must_use]
pub fn clksel (& mut self) -> CLKSEL_W < 0 > { CLKSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `WGMODE` reader - Waveform generation mode"]
pub type WGMODE_R = crate :: FieldReader < u8 , WGMODE_A > ; # [doc = "Waveform generation mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WGMODE_A { # [doc = "0: Normal Mode"]
NORMAL = 0 , # [doc = "1: Frequency Generation Mode"]
FRQ = 1 , # [doc = "3: Single Slope"]
SS = 3 , # [doc = "5: Dual Slope, Update on TOP"]
DS_T = 5 , # [doc = "6: Dual Slope, Update on TOP and BOTTOM"]
DS_TB = 6 , # [doc = "7: Dual Slope, Update on BOTTOM"]
DS_B = 7 , } impl From < WGMODE_A > for u8 { # [inline (always)]
fn from (variant : WGMODE_A) -> Self { variant as _ } } impl WGMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WGMODE_A > { match self . bits { 0 => Some (WGMODE_A :: NORMAL) , 1 => Some (WGMODE_A :: FRQ) , 3 => Some (WGMODE_A :: SS) , 5 => Some (WGMODE_A :: DS_T) , 6 => Some (WGMODE_A :: DS_TB) , 7 => Some (WGMODE_A :: DS_B) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == WGMODE_A :: NORMAL } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == WGMODE_A :: FRQ } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == WGMODE_A :: SS } # [doc = "Checks if the value of the field is `DS_T`"]
# [inline (always)]
pub fn is_ds_t (& self) -> bool { * self == WGMODE_A :: DS_T } # [doc = "Checks if the value of the field is `DS_TB`"]
# [inline (always)]
pub fn is_ds_tb (& self) -> bool { * self == WGMODE_A :: DS_TB } # [doc = "Checks if the value of the field is `DS_B`"]
# [inline (always)]
pub fn is_ds_b (& self) -> bool { * self == WGMODE_A :: DS_B } } # [doc = "Field `WGMODE` writer - Waveform generation mode"]
pub type WGMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , WGMODE_A , 3 , O > ; impl < 'a , const O : u8 > WGMODE_W < 'a , O > { # [doc = "Normal Mode"]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (WGMODE_A :: NORMAL) } # [doc = "Frequency Generation Mode"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (WGMODE_A :: FRQ) } # [doc = "Single Slope"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (WGMODE_A :: SS) } # [doc = "Dual Slope, Update on TOP"]
# [inline (always)]
pub fn ds_t (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_T) } # [doc = "Dual Slope, Update on TOP and BOTTOM"]
# [inline (always)]
pub fn ds_tb (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_TB) } # [doc = "Dual Slope, Update on BOTTOM"]
# [inline (always)]
pub fn ds_b (self) -> & 'a mut W { self . variant (WGMODE_A :: DS_B) } } # [doc = "Field `CCAEN` reader - Compare or Capture A Enable"]
pub type CCAEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCAEN` writer - Compare or Capture A Enable"]
pub type CCAEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CCBEN` reader - Compare or Capture B Enable"]
pub type CCBEN_R = crate :: BitReader < bool > ; # [doc = "Field `CCBEN` writer - Compare or Capture B Enable"]
pub type CCBEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
pub fn wgmode (& self) -> WGMODE_R { WGMODE_R :: new (self . bits & 7) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
pub fn ccaen (& self) -> CCAEN_R { CCAEN_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
pub fn ccben (& self) -> CCBEN_R { CCBEN_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform generation mode"]
# [inline (always)]
# [must_use]
pub fn wgmode (& mut self) -> WGMODE_W < 0 > { WGMODE_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Enable"]
# [inline (always)]
# [must_use]
pub fn ccaen (& mut self) -> CCAEN_W < 4 > { CCAEN_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Enable"]
# [inline (always)]
# [must_use]
pub fn ccben (& mut self) -> CCBEN_W < 5 > { CCBEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMPA` reader - Compare A Output Value"]
pub type CMPA_R = crate :: BitReader < bool > ; # [doc = "Field `CMPA` writer - Compare A Output Value"]
pub type CMPA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `CMPB` reader - Compare B Output Value"]
pub type CMPB_R = crate :: BitReader < bool > ; # [doc = "Field `CMPB` writer - Compare B Output Value"]
pub type CMPB_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
pub fn cmpa (& self) -> CMPA_R { CMPA_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
pub fn cmpb (& self) -> CMPB_R { CMPB_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare A Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpa (& mut self) -> CMPA_W < 0 > { CMPA_W :: new (self) } # [doc = "Bit 1 - Compare B Output Value"]
# [inline (always)]
# [must_use]
pub fn cmpb (& mut self) -> CMPB_W < 1 > { CMPB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLD (rw) register accessor: an alias for `Reg<CTRLD_SPEC>`"]
pub type CTRLD = crate :: Reg < ctrld :: CTRLD_SPEC > ; # [doc = "Control Register D"]
pub mod ctrld { # [doc = "Register `CTRLD` reader"]
pub struct R (crate :: R < CTRLD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLD_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLD` writer"]
pub struct W (crate :: W < CTRLD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLD_SPEC >) -> Self { W (writer) } } # [doc = "Field `EVSEL` reader - Event Source Select"]
pub type EVSEL_R = crate :: FieldReader < u8 , EVSEL_A > ; # [doc = "Event Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVSEL_A { # [doc = "0: No Event Source"]
OFF = 0 , # [doc = "8: Event Channel 0"]
CH0 = 8 , # [doc = "9: Event Channel 1"]
CH1 = 9 , # [doc = "10: Event Channel 2"]
CH2 = 10 , # [doc = "11: Event Channel 3"]
CH3 = 11 , # [doc = "12: Event Channel 4"]
CH4 = 12 , # [doc = "13: Event Channel 5"]
CH5 = 13 , # [doc = "14: Event Channel 6"]
CH6 = 14 , # [doc = "15: Event Channel 7"]
CH7 = 15 , } impl From < EVSEL_A > for u8 { # [inline (always)]
fn from (variant : EVSEL_A) -> Self { variant as _ } } impl EVSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVSEL_A > { match self . bits { 0 => Some (EVSEL_A :: OFF) , 8 => Some (EVSEL_A :: CH0) , 9 => Some (EVSEL_A :: CH1) , 10 => Some (EVSEL_A :: CH2) , 11 => Some (EVSEL_A :: CH3) , 12 => Some (EVSEL_A :: CH4) , 13 => Some (EVSEL_A :: CH5) , 14 => Some (EVSEL_A :: CH6) , 15 => Some (EVSEL_A :: CH7) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVSEL_A :: OFF } # [doc = "Checks if the value of the field is `CH0`"]
# [inline (always)]
pub fn is_ch0 (& self) -> bool { * self == EVSEL_A :: CH0 } # [doc = "Checks if the value of the field is `CH1`"]
# [inline (always)]
pub fn is_ch1 (& self) -> bool { * self == EVSEL_A :: CH1 } # [doc = "Checks if the value of the field is `CH2`"]
# [inline (always)]
pub fn is_ch2 (& self) -> bool { * self == EVSEL_A :: CH2 } # [doc = "Checks if the value of the field is `CH3`"]
# [inline (always)]
pub fn is_ch3 (& self) -> bool { * self == EVSEL_A :: CH3 } # [doc = "Checks if the value of the field is `CH4`"]
# [inline (always)]
pub fn is_ch4 (& self) -> bool { * self == EVSEL_A :: CH4 } # [doc = "Checks if the value of the field is `CH5`"]
# [inline (always)]
pub fn is_ch5 (& self) -> bool { * self == EVSEL_A :: CH5 } # [doc = "Checks if the value of the field is `CH6`"]
# [inline (always)]
pub fn is_ch6 (& self) -> bool { * self == EVSEL_A :: CH6 } # [doc = "Checks if the value of the field is `CH7`"]
# [inline (always)]
pub fn is_ch7 (& self) -> bool { * self == EVSEL_A :: CH7 } } # [doc = "Field `EVSEL` writer - Event Source Select"]
pub type EVSEL_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVSEL_A , 4 , O > ; impl < 'a , const O : u8 > EVSEL_W < 'a , O > { # [doc = "No Event Source"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVSEL_A :: OFF) } # [doc = "Event Channel 0"]
# [inline (always)]
pub fn ch0 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH0) } # [doc = "Event Channel 1"]
# [inline (always)]
pub fn ch1 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH1) } # [doc = "Event Channel 2"]
# [inline (always)]
pub fn ch2 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH2) } # [doc = "Event Channel 3"]
# [inline (always)]
pub fn ch3 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH3) } # [doc = "Event Channel 4"]
# [inline (always)]
pub fn ch4 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH4) } # [doc = "Event Channel 5"]
# [inline (always)]
pub fn ch5 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH5) } # [doc = "Event Channel 6"]
# [inline (always)]
pub fn ch6 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH6) } # [doc = "Event Channel 7"]
# [inline (always)]
pub fn ch7 (self) -> & 'a mut W { self . variant (EVSEL_A :: CH7) } } # [doc = "Field `EVDLY` reader - Event Delay"]
pub type EVDLY_R = crate :: BitReader < bool > ; # [doc = "Field `EVDLY` writer - Event Delay"]
pub type EVDLY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLD_SPEC , bool , O > ; # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No Event Action"]
OFF = 0 , # [doc = "1: Input Capture"]
CAPT = 1 , # [doc = "2: Externally Controlled Up/Down Count"]
UPDOWN = 2 , # [doc = "3: Quadrature Decode"]
QDEC = 3 , # [doc = "4: Restart"]
RESTART = 4 , # [doc = "5: Frequency Capture"]
FRQ = 5 , # [doc = "6: Pulse-width Capture"]
PW = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: CAPT) , 2 => Some (EVACT_A :: UPDOWN) , 3 => Some (EVACT_A :: QDEC) , 4 => Some (EVACT_A :: RESTART) , 5 => Some (EVACT_A :: FRQ) , 6 => Some (EVACT_A :: PW) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == EVACT_A :: CAPT } # [doc = "Checks if the value of the field is `UPDOWN`"]
# [inline (always)]
pub fn is_updown (& self) -> bool { * self == EVACT_A :: UPDOWN } # [doc = "Checks if the value of the field is `QDEC`"]
# [inline (always)]
pub fn is_qdec (& self) -> bool { * self == EVACT_A :: QDEC } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == EVACT_A :: RESTART } # [doc = "Checks if the value of the field is `FRQ`"]
# [inline (always)]
pub fn is_frq (& self) -> bool { * self == EVACT_A :: FRQ } # [doc = "Checks if the value of the field is `PW`"]
# [inline (always)]
pub fn is_pw (& self) -> bool { * self == EVACT_A :: PW } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLD_SPEC , u8 , EVACT_A , 3 , O > ; impl < 'a , const O : u8 > EVACT_W < 'a , O > { # [doc = "No Event Action"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Input Capture"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (EVACT_A :: CAPT) } # [doc = "Externally Controlled Up/Down Count"]
# [inline (always)]
pub fn updown (self) -> & 'a mut W { self . variant (EVACT_A :: UPDOWN) } # [doc = "Quadrature Decode"]
# [inline (always)]
pub fn qdec (self) -> & 'a mut W { self . variant (EVACT_A :: QDEC) } # [doc = "Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (EVACT_A :: RESTART) } # [doc = "Frequency Capture"]
# [inline (always)]
pub fn frq (self) -> & 'a mut W { self . variant (EVACT_A :: FRQ) } # [doc = "Pulse-width Capture"]
# [inline (always)]
pub fn pw (self) -> & 'a mut W { self . variant (EVACT_A :: PW) } } impl R { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
pub fn evsel (& self) -> EVSEL_R { EVSEL_R :: new (self . bits & 0x0f) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
pub fn evdly (& self) -> EVDLY_R { EVDLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits >> 5) & 7) } } impl W { # [doc = "Bits 0:3 - Event Source Select"]
# [inline (always)]
# [must_use]
pub fn evsel (& mut self) -> EVSEL_W < 0 > { EVSEL_W :: new (self) } # [doc = "Bit 4 - Event Delay"]
# [inline (always)]
# [must_use]
pub fn evdly (& mut self) -> EVDLY_W < 4 > { EVDLY_W :: new (self) } # [doc = "Bits 5:7 - Event Action"]
# [inline (always)]
# [must_use]
pub fn evact (& mut self) -> EVACT_W < 5 > { EVACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register D\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrld](index.html) module"]
pub struct CTRLD_SPEC ; impl crate :: RegisterSpec for CTRLD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrld::R](R) reader structure"]
impl crate :: Readable for CTRLD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrld::W](W) writer structure"]
impl crate :: Writable for CTRLD_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLD to value 0"]
impl crate :: Resettable for CTRLD_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLE (rw) register accessor: an alias for `Reg<CTRLE_SPEC>`"]
pub type CTRLE = crate :: Reg < ctrle :: CTRLE_SPEC > ; # [doc = "Control Register E"]
pub mod ctrle { # [doc = "Register `CTRLE` reader"]
pub struct R (crate :: R < CTRLE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLE_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLE` writer"]
pub struct W (crate :: W < CTRLE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BYTEM` reader - Byte Mode"]
pub type BYTEM_R = crate :: BitReader < bool > ; # [doc = "Field `BYTEM` writer - Byte Mode"]
pub type BYTEM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLE_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
pub fn bytem (& self) -> BYTEM_R { BYTEM_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Byte Mode"]
# [inline (always)]
# [must_use]
pub fn bytem (& mut self) -> BYTEM_W < 0 > { BYTEM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register E\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrle](index.html) module"]
pub struct CTRLE_SPEC ; impl crate :: RegisterSpec for CTRLE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrle::R](R) reader structure"]
impl crate :: Readable for CTRLE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrle::W](W) writer structure"]
impl crate :: Writable for CTRLE_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLE to value 0"]
impl crate :: Resettable for CTRLE_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFCLR (rw) register accessor: an alias for `Reg<CTRLFCLR_SPEC>`"]
pub type CTRLFCLR = crate :: Reg < ctrlfclr :: CTRLFCLR_SPEC > ; # [doc = "Control Register F Clear"]
pub mod ctrlfclr { # [doc = "Register `CTRLFCLR` reader"]
pub struct R (crate :: R < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFCLR` writer"]
pub struct W (crate :: W < CTRLFCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFCLR_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFCLR_SPEC , u8 , u8 , 2 , O > ; impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfclr](index.html) module"]
pub struct CTRLFCLR_SPEC ; impl crate :: RegisterSpec for CTRLFCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfclr::R](R) reader structure"]
impl crate :: Readable for CTRLFCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfclr::W](W) writer structure"]
impl crate :: Writable for CTRLFCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFCLR to value 0"]
impl crate :: Resettable for CTRLFCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLFSET (rw) register accessor: an alias for `Reg<CTRLFSET_SPEC>`"]
pub type CTRLFSET = crate :: Reg < ctrlfset :: CTRLFSET_SPEC > ; # [doc = "Control Register F Set"]
pub mod ctrlfset { # [doc = "Register `CTRLFSET` reader"]
pub struct R (crate :: R < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLFSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLFSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLFSET` writer"]
pub struct W (crate :: W < CTRLFSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLFSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLFSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLFSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Direction"]
pub type DIR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLFSET_SPEC , bool , O > ; # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No Command"]
NONE = 0 , # [doc = "1: Force Update"]
UPDATE = 1 , # [doc = "2: Force Restart"]
RESTART = 2 , # [doc = "3: Force Hard Reset"]
RESET = 3 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMD_A { match self . bits { 0 => CMD_A :: NONE , 1 => CMD_A :: UPDATE , 2 => CMD_A :: RESTART , 3 => CMD_A :: RESET , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `RESTART`"]
# [inline (always)]
pub fn is_restart (& self) -> bool { * self == CMD_A :: RESTART } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == CMD_A :: RESET } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLFSET_SPEC , u8 , CMD_A , 2 , O > ; impl < 'a , const O : u8 > CMD_W < 'a , O > { # [doc = "No Command"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force Update"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force Restart"]
# [inline (always)]
pub fn restart (self) -> & 'a mut W { self . variant (CMD_A :: RESTART) } # [doc = "Force Hard Reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (CMD_A :: RESET) } } impl R { # [doc = "Bit 0 - Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bit 0 - Direction"]
# [inline (always)]
# [must_use]
pub fn dir (& mut self) -> DIR_W < 0 > { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
# [must_use]
pub fn lupd (& mut self) -> LUPD_W < 1 > { LUPD_W :: new (self) } # [doc = "Bits 2:3 - Command"]
# [inline (always)]
# [must_use]
pub fn cmd (& mut self) -> CMD_W < 2 > { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register F Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlfset](index.html) module"]
pub struct CTRLFSET_SPEC ; impl crate :: RegisterSpec for CTRLFSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlfset::R](R) reader structure"]
impl crate :: Readable for CTRLFSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlfset::W](W) writer structure"]
impl crate :: Writable for CTRLFSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLFSET to value 0"]
impl crate :: Resettable for CTRLFSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGCLR (rw) register accessor: an alias for `Reg<CTRLGCLR_SPEC>`"]
pub type CTRLGCLR = crate :: Reg < ctrlgclr :: CTRLGCLR_SPEC > ; # [doc = "Control Register G Clear"]
pub mod ctrlgclr { # [doc = "Register `CTRLGCLR` reader"]
pub struct R (crate :: R < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGCLR` writer"]
pub struct W (crate :: W < CTRLGCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGCLR_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgclr](index.html) module"]
pub struct CTRLGCLR_SPEC ; impl crate :: RegisterSpec for CTRLGCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgclr::R](R) reader structure"]
impl crate :: Readable for CTRLGCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgclr::W](W) writer structure"]
impl crate :: Writable for CTRLGCLR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGCLR to value 0"]
impl crate :: Resettable for CTRLGCLR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLGSET (rw) register accessor: an alias for `Reg<CTRLGSET_SPEC>`"]
pub type CTRLGSET = crate :: Reg < ctrlgset :: CTRLGSET_SPEC > ; # [doc = "Control Register G Set"]
pub mod ctrlgset { # [doc = "Register `CTRLGSET` reader"]
pub struct R (crate :: R < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLGSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLGSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLGSET` writer"]
pub struct W (crate :: W < CTRLGSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLGSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLGSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLGSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCABV` reader - Compare or Capture A Buffer Valid"]
pub type CCABV_R = crate :: BitReader < bool > ; # [doc = "Field `CCABV` writer - Compare or Capture A Buffer Valid"]
pub type CCABV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; # [doc = "Field `CCBBV` reader - Compare or Capture B Buffer Valid"]
pub type CCBBV_R = crate :: BitReader < bool > ; # [doc = "Field `CCBBV` writer - Compare or Capture B Buffer Valid"]
pub type CCBBV_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLGSET_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
pub fn ccabv (& self) -> CCABV_R { CCABV_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
pub fn ccbbv (& self) -> CCBBV_R { CCBBV_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Period Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn perbv (& mut self) -> PERBV_W < 0 > { PERBV_W :: new (self) } # [doc = "Bit 1 - Compare or Capture A Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccabv (& mut self) -> CCABV_W < 1 > { CCABV_W :: new (self) } # [doc = "Bit 2 - Compare or Capture B Buffer Valid"]
# [inline (always)]
# [must_use]
pub fn ccbbv (& mut self) -> CCBBV_W < 2 > { CCBBV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register G Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlgset](index.html) module"]
pub struct CTRLGSET_SPEC ; impl crate :: RegisterSpec for CTRLGSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlgset::R](R) reader structure"]
impl crate :: Readable for CTRLGSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlgset::W](W) writer structure"]
impl crate :: Writable for CTRLGSET_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLGSET to value 0"]
impl crate :: Resettable for CTRLGSET_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLA (rw) register accessor: an alias for `Reg<INTCTRLA_SPEC>`"]
pub type INTCTRLA = crate :: Reg < intctrla :: INTCTRLA_SPEC > ; # [doc = "Interrupt Control Register A"]
pub mod intctrla { # [doc = "Register `INTCTRLA` reader"]
pub struct R (crate :: R < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLA` writer"]
pub struct W (crate :: W < INTCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFINTLVL` reader - Overflow interrupt level"]
pub type OVFINTLVL_R = crate :: FieldReader < u8 , OVFINTLVL_A > ; # [doc = "Overflow interrupt level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum OVFINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < OVFINTLVL_A > for u8 { # [inline (always)]
fn from (variant : OVFINTLVL_A) -> Self { variant as _ } } impl OVFINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> OVFINTLVL_A { match self . bits { 0 => OVFINTLVL_A :: OFF , 1 => OVFINTLVL_A :: LO , 2 => OVFINTLVL_A :: MED , 3 => OVFINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OVFINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == OVFINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == OVFINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == OVFINTLVL_A :: HI } } # [doc = "Field `OVFINTLVL` writer - Overflow interrupt level"]
pub type OVFINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , OVFINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > OVFINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (OVFINTLVL_A :: HI) } } # [doc = "Field `ERRINTLVL` reader - Error Interrupt Level"]
pub type ERRINTLVL_R = crate :: FieldReader < u8 , ERRINTLVL_A > ; # [doc = "Error Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ERRINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < ERRINTLVL_A > for u8 { # [inline (always)]
fn from (variant : ERRINTLVL_A) -> Self { variant as _ } } impl ERRINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> ERRINTLVL_A { match self . bits { 0 => ERRINTLVL_A :: OFF , 1 => ERRINTLVL_A :: LO , 2 => ERRINTLVL_A :: MED , 3 => ERRINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == ERRINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == ERRINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == ERRINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == ERRINTLVL_A :: HI } } # [doc = "Field `ERRINTLVL` writer - Error Interrupt Level"]
pub type ERRINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLA_SPEC , u8 , ERRINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > ERRINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (ERRINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
pub fn ovfintlvl (& self) -> OVFINTLVL_R { OVFINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
pub fn errintlvl (& self) -> ERRINTLVL_R { ERRINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Overflow interrupt level"]
# [inline (always)]
# [must_use]
pub fn ovfintlvl (& mut self) -> OVFINTLVL_W < 0 > { OVFINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Error Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn errintlvl (& mut self) -> ERRINTLVL_W < 2 > { ERRINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrla](index.html) module"]
pub struct INTCTRLA_SPEC ; impl crate :: RegisterSpec for INTCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrla::R](R) reader structure"]
impl crate :: Readable for INTCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrla::W](W) writer structure"]
impl crate :: Writable for INTCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLA to value 0"]
impl crate :: Resettable for INTCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTCTRLB (rw) register accessor: an alias for `Reg<INTCTRLB_SPEC>`"]
pub type INTCTRLB = crate :: Reg < intctrlb :: INTCTRLB_SPEC > ; # [doc = "Interrupt Control Register B"]
pub mod intctrlb { # [doc = "Register `INTCTRLB` reader"]
pub struct R (crate :: R < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTCTRLB` writer"]
pub struct W (crate :: W < INTCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCAINTLVL` reader - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_R = crate :: FieldReader < u8 , CCAINTLVL_A > ; # [doc = "Compare or Capture A Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCAINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCAINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCAINTLVL_A) -> Self { variant as _ } } impl CCAINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCAINTLVL_A { match self . bits { 0 => CCAINTLVL_A :: OFF , 1 => CCAINTLVL_A :: LO , 2 => CCAINTLVL_A :: MED , 3 => CCAINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCAINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCAINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCAINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCAINTLVL_A :: HI } } # [doc = "Field `CCAINTLVL` writer - Compare or Capture A Interrupt Level"]
pub type CCAINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCAINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCAINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCAINTLVL_A :: HI) } } # [doc = "Field `CCBINTLVL` reader - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_R = crate :: FieldReader < u8 , CCBINTLVL_A > ; # [doc = "Compare or Capture B Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CCBINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < CCBINTLVL_A > for u8 { # [inline (always)]
fn from (variant : CCBINTLVL_A) -> Self { variant as _ } } impl CCBINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CCBINTLVL_A { match self . bits { 0 => CCBINTLVL_A :: OFF , 1 => CCBINTLVL_A :: LO , 2 => CCBINTLVL_A :: MED , 3 => CCBINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == CCBINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == CCBINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == CCBINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == CCBINTLVL_A :: HI } } # [doc = "Field `CCBINTLVL` writer - Compare or Capture B Interrupt Level"]
pub type CCBINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , INTCTRLB_SPEC , u8 , CCBINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > CCBINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (CCBINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
pub fn ccaintlvl (& self) -> CCAINTLVL_R { CCAINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
pub fn ccbintlvl (& self) -> CCBINTLVL_R { CCBINTLVL_R :: new ((self . bits >> 2) & 3) } } impl W { # [doc = "Bits 0:1 - Compare or Capture A Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccaintlvl (& mut self) -> CCAINTLVL_W < 0 > { CCAINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Compare or Capture B Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn ccbintlvl (& mut self) -> CCBINTLVL_W < 2 > { CCBINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intctrlb](index.html) module"]
pub struct INTCTRLB_SPEC ; impl crate :: RegisterSpec for INTCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intctrlb::R](R) reader structure"]
impl crate :: Readable for INTCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intctrlb::W](W) writer structure"]
impl crate :: Writable for INTCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTCTRLB to value 0"]
impl crate :: Resettable for INTCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVFIF` reader - Overflow Interrupt Flag"]
pub type OVFIF_R = crate :: BitReader < bool > ; # [doc = "Field `OVFIF` writer - Overflow Interrupt Flag"]
pub type OVFIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `ERRIF` reader - Error Interrupt Flag"]
pub type ERRIF_R = crate :: BitReader < bool > ; # [doc = "Field `ERRIF` writer - Error Interrupt Flag"]
pub type ERRIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCAIF` reader - Compare or Capture A Interrupt Flag"]
pub type CCAIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCAIF` writer - Compare or Capture A Interrupt Flag"]
pub type CCAIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `CCBIF` reader - Compare or Capture B Interrupt Flag"]
pub type CCBIF_R = crate :: BitReader < bool > ; # [doc = "Field `CCBIF` writer - Compare or Capture B Interrupt Flag"]
pub type CCBIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
pub fn ovfif (& self) -> OVFIF_R { OVFIF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
pub fn errif (& self) -> ERRIF_R { ERRIF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
pub fn ccaif (& self) -> CCAIF_R { CCAIF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
pub fn ccbif (& self) -> CCBIF_R { CCBIF_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ovfif (& mut self) -> OVFIF_W < 0 > { OVFIF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn errif (& mut self) -> ERRIF_W < 1 > { ERRIF_W :: new (self) } # [doc = "Bit 4 - Compare or Capture A Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccaif (& mut self) -> CCAIF_W < 4 > { CCAIF_W :: new (self) } # [doc = "Bit 5 - Compare or Capture B Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn ccbif (& mut self) -> CCBIF_W < 5 > { CCBIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PER (rw) register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "PERBUF (rw) register accessor: an alias for `Reg<PERBUF_SPEC>`"]
pub type PERBUF = crate :: Reg < perbuf :: PERBUF_SPEC > ; # [doc = "Period Buffer"]
pub mod perbuf { # [doc = "Register `PERBUF` reader"]
pub struct R (crate :: R < PERBUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERBUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERBUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERBUF` writer"]
pub struct W (crate :: W < PERBUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERBUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERBUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERBUF_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u16) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perbuf](index.html) module"]
pub struct PERBUF_SPEC ; impl crate :: RegisterSpec for PERBUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [perbuf::R](R) reader structure"]
impl crate :: Readable for PERBUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perbuf::W](W) writer structure"]
impl crate :: Writable for PERBUF_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets PERBUF to value 0"]
impl crate :: Resettable for PERBUF_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "TEMP (rw) register accessor: an alias for `Reg<TEMP_SPEC>`"]
pub type TEMP = crate :: Reg < temp :: TEMP_SPEC > ; # [doc = "Temporary Register For 16-bit Access"]
pub mod temp { # [doc = "Register `TEMP` reader"]
pub struct R (crate :: R < TEMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < TEMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < TEMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `TEMP` writer"]
pub struct W (crate :: W < TEMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < TEMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < TEMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < TEMP_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Temporary Register For 16-bit Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [temp](index.html) module"]
pub struct TEMP_SPEC ; impl crate :: RegisterSpec for TEMP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [temp::R](R) reader structure"]
impl crate :: Readable for TEMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [temp::W](W) writer structure"]
impl crate :: Writable for TEMP_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets TEMP to value 0"]
impl crate :: Resettable for TEMP_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Two-Wire Interface"]
pub struct TWIC { _marker : PhantomData < * const () > } unsafe impl Send for TWIC { } impl TWIC { # [doc = r"Pointer to the register block"]
pub const PTR : * const twic :: RegisterBlock = 0x0480 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const twic :: RegisterBlock { Self :: PTR } } impl Deref for TWIC { type Target = twic :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TWIC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TWIC") . finish () } } # [doc = "Two-Wire Interface"]
pub mod twic { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - TWI Common Control Register"]
pub ctrl : CTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "TWI Common Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EDIEN` reader - External Driver Interface Enable"]
pub type EDIEN_R = crate :: BitReader < bool > ; # [doc = "Field `EDIEN` writer - External Driver Interface Enable"]
pub type EDIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `SDAHOLD` reader - SDA Hold Time Enable"]
pub type SDAHOLD_R = crate :: FieldReader < u8 , SDAHOLD_A > ; # [doc = "SDA Hold Time Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SDAHOLD_A { # [doc = "0: SDA hold time off"]
OFF = 0 , # [doc = "1: Typical 50ns hold time"]
_50NS = 1 , # [doc = "2: Typical 300ns hold time"]
_300NS = 2 , # [doc = "3: Typical 400ns hold time"]
_400NS = 3 , } impl From < SDAHOLD_A > for u8 { # [inline (always)]
fn from (variant : SDAHOLD_A) -> Self { variant as _ } } impl SDAHOLD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SDAHOLD_A { match self . bits { 0 => SDAHOLD_A :: OFF , 1 => SDAHOLD_A :: _50NS , 2 => SDAHOLD_A :: _300NS , 3 => SDAHOLD_A :: _400NS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SDAHOLD_A :: OFF } # [doc = "Checks if the value of the field is `_50NS`"]
# [inline (always)]
pub fn is_50ns (& self) -> bool { * self == SDAHOLD_A :: _50NS } # [doc = "Checks if the value of the field is `_300NS`"]
# [inline (always)]
pub fn is_300ns (& self) -> bool { * self == SDAHOLD_A :: _300NS } # [doc = "Checks if the value of the field is `_400NS`"]
# [inline (always)]
pub fn is_400ns (& self) -> bool { * self == SDAHOLD_A :: _400NS } } # [doc = "Field `SDAHOLD` writer - SDA Hold Time Enable"]
pub type SDAHOLD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , SDAHOLD_A , 2 , O > ; impl < 'a , const O : u8 > SDAHOLD_W < 'a , O > { # [doc = "SDA hold time off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SDAHOLD_A :: OFF) } # [doc = "Typical 50ns hold time"]
# [inline (always)]
pub fn _50ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _50NS) } # [doc = "Typical 300ns hold time"]
# [inline (always)]
pub fn _300ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _300NS) } # [doc = "Typical 400ns hold time"]
# [inline (always)]
pub fn _400ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _400NS) } } impl R { # [doc = "Bit 0 - External Driver Interface Enable"]
# [inline (always)]
pub fn edien (& self) -> EDIEN_R { EDIEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - SDA Hold Time Enable"]
# [inline (always)]
pub fn sdahold (& self) -> SDAHOLD_R { SDAHOLD_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - External Driver Interface Enable"]
# [inline (always)]
# [must_use]
pub fn edien (& mut self) -> EDIEN_W < 0 > { EDIEN_W :: new (self) } # [doc = "Bits 1:2 - SDA Hold Time Enable"]
# [inline (always)]
# [must_use]
pub fn sdahold (& mut self) -> SDAHOLD_W < 1 > { SDAHOLD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI Common Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Two-Wire Interface"]
pub struct TWID { _marker : PhantomData < * const () > } unsafe impl Send for TWID { } impl TWID { # [doc = r"Pointer to the register block"]
pub const PTR : * const twid :: RegisterBlock = 0x0490 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const twid :: RegisterBlock { Self :: PTR } } impl Deref for TWID { type Target = twid :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TWID { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TWID") . finish () } } # [doc = "Two-Wire Interface"]
pub mod twid { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - TWI Common Control Register"]
pub ctrl : CTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "TWI Common Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EDIEN` reader - External Driver Interface Enable"]
pub type EDIEN_R = crate :: BitReader < bool > ; # [doc = "Field `EDIEN` writer - External Driver Interface Enable"]
pub type EDIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `SDAHOLD` reader - SDA Hold Time Enable"]
pub type SDAHOLD_R = crate :: FieldReader < u8 , SDAHOLD_A > ; # [doc = "SDA Hold Time Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SDAHOLD_A { # [doc = "0: SDA hold time off"]
OFF = 0 , # [doc = "1: Typical 50ns hold time"]
_50NS = 1 , # [doc = "2: Typical 300ns hold time"]
_300NS = 2 , # [doc = "3: Typical 400ns hold time"]
_400NS = 3 , } impl From < SDAHOLD_A > for u8 { # [inline (always)]
fn from (variant : SDAHOLD_A) -> Self { variant as _ } } impl SDAHOLD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SDAHOLD_A { match self . bits { 0 => SDAHOLD_A :: OFF , 1 => SDAHOLD_A :: _50NS , 2 => SDAHOLD_A :: _300NS , 3 => SDAHOLD_A :: _400NS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SDAHOLD_A :: OFF } # [doc = "Checks if the value of the field is `_50NS`"]
# [inline (always)]
pub fn is_50ns (& self) -> bool { * self == SDAHOLD_A :: _50NS } # [doc = "Checks if the value of the field is `_300NS`"]
# [inline (always)]
pub fn is_300ns (& self) -> bool { * self == SDAHOLD_A :: _300NS } # [doc = "Checks if the value of the field is `_400NS`"]
# [inline (always)]
pub fn is_400ns (& self) -> bool { * self == SDAHOLD_A :: _400NS } } # [doc = "Field `SDAHOLD` writer - SDA Hold Time Enable"]
pub type SDAHOLD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , SDAHOLD_A , 2 , O > ; impl < 'a , const O : u8 > SDAHOLD_W < 'a , O > { # [doc = "SDA hold time off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SDAHOLD_A :: OFF) } # [doc = "Typical 50ns hold time"]
# [inline (always)]
pub fn _50ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _50NS) } # [doc = "Typical 300ns hold time"]
# [inline (always)]
pub fn _300ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _300NS) } # [doc = "Typical 400ns hold time"]
# [inline (always)]
pub fn _400ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _400NS) } } impl R { # [doc = "Bit 0 - External Driver Interface Enable"]
# [inline (always)]
pub fn edien (& self) -> EDIEN_R { EDIEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - SDA Hold Time Enable"]
# [inline (always)]
pub fn sdahold (& self) -> SDAHOLD_R { SDAHOLD_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - External Driver Interface Enable"]
# [inline (always)]
# [must_use]
pub fn edien (& mut self) -> EDIEN_W < 0 > { EDIEN_W :: new (self) } # [doc = "Bits 1:2 - SDA Hold Time Enable"]
# [inline (always)]
# [must_use]
pub fn sdahold (& mut self) -> SDAHOLD_W < 1 > { SDAHOLD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI Common Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Two-Wire Interface"]
pub struct TWIE { _marker : PhantomData < * const () > } unsafe impl Send for TWIE { } impl TWIE { # [doc = r"Pointer to the register block"]
pub const PTR : * const twie :: RegisterBlock = 0x04a0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const twie :: RegisterBlock { Self :: PTR } } impl Deref for TWIE { type Target = twie :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TWIE { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TWIE") . finish () } } # [doc = "Two-Wire Interface"]
pub mod twie { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - TWI Common Control Register"]
pub ctrl : CTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "TWI Common Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EDIEN` reader - External Driver Interface Enable"]
pub type EDIEN_R = crate :: BitReader < bool > ; # [doc = "Field `EDIEN` writer - External Driver Interface Enable"]
pub type EDIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `SDAHOLD` reader - SDA Hold Time Enable"]
pub type SDAHOLD_R = crate :: FieldReader < u8 , SDAHOLD_A > ; # [doc = "SDA Hold Time Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SDAHOLD_A { # [doc = "0: SDA hold time off"]
OFF = 0 , # [doc = "1: Typical 50ns hold time"]
_50NS = 1 , # [doc = "2: Typical 300ns hold time"]
_300NS = 2 , # [doc = "3: Typical 400ns hold time"]
_400NS = 3 , } impl From < SDAHOLD_A > for u8 { # [inline (always)]
fn from (variant : SDAHOLD_A) -> Self { variant as _ } } impl SDAHOLD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SDAHOLD_A { match self . bits { 0 => SDAHOLD_A :: OFF , 1 => SDAHOLD_A :: _50NS , 2 => SDAHOLD_A :: _300NS , 3 => SDAHOLD_A :: _400NS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SDAHOLD_A :: OFF } # [doc = "Checks if the value of the field is `_50NS`"]
# [inline (always)]
pub fn is_50ns (& self) -> bool { * self == SDAHOLD_A :: _50NS } # [doc = "Checks if the value of the field is `_300NS`"]
# [inline (always)]
pub fn is_300ns (& self) -> bool { * self == SDAHOLD_A :: _300NS } # [doc = "Checks if the value of the field is `_400NS`"]
# [inline (always)]
pub fn is_400ns (& self) -> bool { * self == SDAHOLD_A :: _400NS } } # [doc = "Field `SDAHOLD` writer - SDA Hold Time Enable"]
pub type SDAHOLD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , SDAHOLD_A , 2 , O > ; impl < 'a , const O : u8 > SDAHOLD_W < 'a , O > { # [doc = "SDA hold time off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SDAHOLD_A :: OFF) } # [doc = "Typical 50ns hold time"]
# [inline (always)]
pub fn _50ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _50NS) } # [doc = "Typical 300ns hold time"]
# [inline (always)]
pub fn _300ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _300NS) } # [doc = "Typical 400ns hold time"]
# [inline (always)]
pub fn _400ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _400NS) } } impl R { # [doc = "Bit 0 - External Driver Interface Enable"]
# [inline (always)]
pub fn edien (& self) -> EDIEN_R { EDIEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - SDA Hold Time Enable"]
# [inline (always)]
pub fn sdahold (& self) -> SDAHOLD_R { SDAHOLD_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - External Driver Interface Enable"]
# [inline (always)]
# [must_use]
pub fn edien (& mut self) -> EDIEN_W < 0 > { EDIEN_W :: new (self) } # [doc = "Bits 1:2 - SDA Hold Time Enable"]
# [inline (always)]
# [must_use]
pub fn sdahold (& mut self) -> SDAHOLD_W < 1 > { SDAHOLD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI Common Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Two-Wire Interface"]
pub struct TWIF { _marker : PhantomData < * const () > } unsafe impl Send for TWIF { } impl TWIF { # [doc = r"Pointer to the register block"]
pub const PTR : * const twif :: RegisterBlock = 0x04b0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const twif :: RegisterBlock { Self :: PTR } } impl Deref for TWIF { type Target = twif :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TWIF { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TWIF") . finish () } } # [doc = "Two-Wire Interface"]
pub mod twif { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - TWI Common Control Register"]
pub ctrl : CTRL , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "TWI Common Control Register"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EDIEN` reader - External Driver Interface Enable"]
pub type EDIEN_R = crate :: BitReader < bool > ; # [doc = "Field `EDIEN` writer - External Driver Interface Enable"]
pub type EDIEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `SDAHOLD` reader - SDA Hold Time Enable"]
pub type SDAHOLD_R = crate :: FieldReader < u8 , SDAHOLD_A > ; # [doc = "SDA Hold Time Enable\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SDAHOLD_A { # [doc = "0: SDA hold time off"]
OFF = 0 , # [doc = "1: Typical 50ns hold time"]
_50NS = 1 , # [doc = "2: Typical 300ns hold time"]
_300NS = 2 , # [doc = "3: Typical 400ns hold time"]
_400NS = 3 , } impl From < SDAHOLD_A > for u8 { # [inline (always)]
fn from (variant : SDAHOLD_A) -> Self { variant as _ } } impl SDAHOLD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SDAHOLD_A { match self . bits { 0 => SDAHOLD_A :: OFF , 1 => SDAHOLD_A :: _50NS , 2 => SDAHOLD_A :: _300NS , 3 => SDAHOLD_A :: _400NS , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SDAHOLD_A :: OFF } # [doc = "Checks if the value of the field is `_50NS`"]
# [inline (always)]
pub fn is_50ns (& self) -> bool { * self == SDAHOLD_A :: _50NS } # [doc = "Checks if the value of the field is `_300NS`"]
# [inline (always)]
pub fn is_300ns (& self) -> bool { * self == SDAHOLD_A :: _300NS } # [doc = "Checks if the value of the field is `_400NS`"]
# [inline (always)]
pub fn is_400ns (& self) -> bool { * self == SDAHOLD_A :: _400NS } } # [doc = "Field `SDAHOLD` writer - SDA Hold Time Enable"]
pub type SDAHOLD_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRL_SPEC , u8 , SDAHOLD_A , 2 , O > ; impl < 'a , const O : u8 > SDAHOLD_W < 'a , O > { # [doc = "SDA hold time off"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SDAHOLD_A :: OFF) } # [doc = "Typical 50ns hold time"]
# [inline (always)]
pub fn _50ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _50NS) } # [doc = "Typical 300ns hold time"]
# [inline (always)]
pub fn _300ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _300NS) } # [doc = "Typical 400ns hold time"]
# [inline (always)]
pub fn _400ns (self) -> & 'a mut W { self . variant (SDAHOLD_A :: _400NS) } } impl R { # [doc = "Bit 0 - External Driver Interface Enable"]
# [inline (always)]
pub fn edien (& self) -> EDIEN_R { EDIEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - SDA Hold Time Enable"]
# [inline (always)]
pub fn sdahold (& self) -> SDAHOLD_R { SDAHOLD_R :: new ((self . bits >> 1) & 3) } } impl W { # [doc = "Bit 0 - External Driver Interface Enable"]
# [inline (always)]
# [must_use]
pub fn edien (& mut self) -> EDIEN_W < 0 > { EDIEN_W :: new (self) } # [doc = "Bits 1:2 - SDA Hold Time Enable"]
# [inline (always)]
# [must_use]
pub fn sdahold (& mut self) -> SDAHOLD_W < 1 > { SDAHOLD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "TWI Common Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub struct USARTC0 { _marker : PhantomData < * const () > } unsafe impl Send for USARTC0 { } impl USARTC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usartc0 :: RegisterBlock = 0x08a0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usartc0 :: RegisterBlock { Self :: PTR } } impl Deref for USARTC0 { type Target = usartc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USARTC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USARTC0") . finish () } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub mod usartc0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Register"]
pub data : DATA , # [doc = "0x01 - Status Register"]
pub status : STATUS , _reserved2 : [u8 ; 0x01]
, # [doc = "0x03 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x04 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x05 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x06 - Baud Rate Control Register A"]
pub baudctrla : BAUDCTRLA , # [doc = "0x07 - Baud Rate Control Register B"]
pub baudctrlb : BAUDCTRLB , } # [doc = "BAUDCTRLA (rw) register accessor: an alias for `Reg<BAUDCTRLA_SPEC>`"]
pub type BAUDCTRLA = crate :: Reg < baudctrla :: BAUDCTRLA_SPEC > ; # [doc = "Baud Rate Control Register A"]
pub mod baudctrla { # [doc = "Register `BAUDCTRLA` reader"]
pub struct R (crate :: R < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLA` writer"]
pub struct W (crate :: W < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLA_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrla](index.html) module"]
pub struct BAUDCTRLA_SPEC ; impl crate :: RegisterSpec for BAUDCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrla::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrla::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLA to value 0"]
impl crate :: Resettable for BAUDCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BAUDCTRLB (rw) register accessor: an alias for `Reg<BAUDCTRLB_SPEC>`"]
pub type BAUDCTRLB = crate :: Reg < baudctrlb :: BAUDCTRLB_SPEC > ; # [doc = "Baud Rate Control Register B"]
pub mod baudctrlb { # [doc = "Register `BAUDCTRLB` reader"]
pub struct R (crate :: R < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLB` writer"]
pub struct W (crate :: W < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `BSCALE` reader - Baud Rate Scale"]
pub type BSCALE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSCALE` writer - Baud Rate Scale"]
pub type BSCALE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
pub fn bscale (& self) -> BSCALE_R { BSCALE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
# [must_use]
pub fn bscale (& mut self) -> BSCALE_W < 4 > { BSCALE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Baud Rate Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrlb](index.html) module"]
pub struct BAUDCTRLB_SPEC ; impl crate :: RegisterSpec for BAUDCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrlb::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrlb::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLB to value 0"]
impl crate :: Resettable for BAUDCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DREINTLVL` reader - Data Register Empty Interrupt Level"]
pub type DREINTLVL_R = crate :: FieldReader < u8 , DREINTLVL_A > ; # [doc = "Data Register Empty Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DREINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < DREINTLVL_A > for u8 { # [inline (always)]
fn from (variant : DREINTLVL_A) -> Self { variant as _ } } impl DREINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DREINTLVL_A { match self . bits { 0 => DREINTLVL_A :: OFF , 1 => DREINTLVL_A :: LO , 2 => DREINTLVL_A :: MED , 3 => DREINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DREINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == DREINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == DREINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == DREINTLVL_A :: HI } } # [doc = "Field `DREINTLVL` writer - Data Register Empty Interrupt Level"]
pub type DREINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DREINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > DREINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DREINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (DREINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (DREINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (DREINTLVL_A :: HI) } } # [doc = "Field `TXCINTLVL` reader - Transmit Interrupt Level"]
pub type TXCINTLVL_R = crate :: FieldReader < u8 , TXCINTLVL_A > ; # [doc = "Transmit Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < TXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : TXCINTLVL_A) -> Self { variant as _ } } impl TXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXCINTLVL_A { match self . bits { 0 => TXCINTLVL_A :: OFF , 1 => TXCINTLVL_A :: LO , 2 => TXCINTLVL_A :: MED , 3 => TXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == TXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == TXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == TXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == TXCINTLVL_A :: HI } } # [doc = "Field `TXCINTLVL` writer - Transmit Interrupt Level"]
pub type TXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , TXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > TXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: HI) } } # [doc = "Field `RXCINTLVL` reader - Receive Interrupt Level"]
pub type RXCINTLVL_R = crate :: FieldReader < u8 , RXCINTLVL_A > ; # [doc = "Receive Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < RXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : RXCINTLVL_A) -> Self { variant as _ } } impl RXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXCINTLVL_A { match self . bits { 0 => RXCINTLVL_A :: OFF , 1 => RXCINTLVL_A :: LO , 2 => RXCINTLVL_A :: MED , 3 => RXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == RXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == RXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == RXCINTLVL_A :: HI } } # [doc = "Field `RXCINTLVL` writer - Receive Interrupt Level"]
pub type RXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , RXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > RXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
pub fn dreintlvl (& self) -> DREINTLVL_R { DREINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
pub fn txcintlvl (& self) -> TXCINTLVL_R { TXCINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
pub fn rxcintlvl (& self) -> RXCINTLVL_R { RXCINTLVL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn dreintlvl (& mut self) -> DREINTLVL_W < 0 > { DREINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn txcintlvl (& mut self) -> TXCINTLVL_W < 2 > { TXCINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn rxcintlvl (& mut self) -> RXCINTLVL_W < 4 > { RXCINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB8` reader - Transmit bit 8"]
pub type TXB8_R = crate :: BitReader < bool > ; # [doc = "Field `TXB8` writer - Transmit bit 8"]
pub type TXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Double transmission speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Double transmission speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
pub fn txb8 (& self) -> TXB8_R { TXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
# [must_use]
pub fn txb8 (& mut self) -> TXB8_W < 0 > { TXB8_W :: new (self) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 1 > { MPCM_W :: new (self) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 2 > { CLK2X_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 3 > { TXEN_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 4 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "7: Character size: 9 bit"]
_9BIT = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 7 => Some (CHSIZE_A :: _9BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == CHSIZE_A :: _9BIT } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BIT) } } # [doc = "Field `UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Master Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Master Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: IrDA Mode"]
IRDA = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRDA , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRDA`"]
# [inline (always)]
pub fn is_irda (& self) -> bool { * self == CMODE_A :: IRDA } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "IrDA Mode"]
# [inline (always)]
pub fn irda (self) -> & 'a mut W { self . variant (CMODE_A :: IRDA) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXB8` reader - Receive Bit 8"]
pub type RXB8_R = crate :: BitReader < bool > ; # [doc = "Field `RXB8` writer - Receive Bit 8"]
pub type RXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
pub fn rxb8 (& self) -> RXB8_R { RXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb8 (& mut self) -> RXB8_W < 0 > { RXB8_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn perr (& mut self) -> PERR_W < 2 > { PERR_W :: new (self) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 3 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn ferr (& mut self) -> FERR_W < 4 > { FERR_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub struct USARTC1 { _marker : PhantomData < * const () > } unsafe impl Send for USARTC1 { } impl USARTC1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usartc1 :: RegisterBlock = 0x08b0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usartc1 :: RegisterBlock { Self :: PTR } } impl Deref for USARTC1 { type Target = usartc1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USARTC1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USARTC1") . finish () } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub mod usartc1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Register"]
pub data : DATA , # [doc = "0x01 - Status Register"]
pub status : STATUS , _reserved2 : [u8 ; 0x01]
, # [doc = "0x03 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x04 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x05 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x06 - Baud Rate Control Register A"]
pub baudctrla : BAUDCTRLA , # [doc = "0x07 - Baud Rate Control Register B"]
pub baudctrlb : BAUDCTRLB , } # [doc = "BAUDCTRLA (rw) register accessor: an alias for `Reg<BAUDCTRLA_SPEC>`"]
pub type BAUDCTRLA = crate :: Reg < baudctrla :: BAUDCTRLA_SPEC > ; # [doc = "Baud Rate Control Register A"]
pub mod baudctrla { # [doc = "Register `BAUDCTRLA` reader"]
pub struct R (crate :: R < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLA` writer"]
pub struct W (crate :: W < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLA_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrla](index.html) module"]
pub struct BAUDCTRLA_SPEC ; impl crate :: RegisterSpec for BAUDCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrla::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrla::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLA to value 0"]
impl crate :: Resettable for BAUDCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BAUDCTRLB (rw) register accessor: an alias for `Reg<BAUDCTRLB_SPEC>`"]
pub type BAUDCTRLB = crate :: Reg < baudctrlb :: BAUDCTRLB_SPEC > ; # [doc = "Baud Rate Control Register B"]
pub mod baudctrlb { # [doc = "Register `BAUDCTRLB` reader"]
pub struct R (crate :: R < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLB` writer"]
pub struct W (crate :: W < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `BSCALE` reader - Baud Rate Scale"]
pub type BSCALE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSCALE` writer - Baud Rate Scale"]
pub type BSCALE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
pub fn bscale (& self) -> BSCALE_R { BSCALE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
# [must_use]
pub fn bscale (& mut self) -> BSCALE_W < 4 > { BSCALE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Baud Rate Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrlb](index.html) module"]
pub struct BAUDCTRLB_SPEC ; impl crate :: RegisterSpec for BAUDCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrlb::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrlb::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLB to value 0"]
impl crate :: Resettable for BAUDCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DREINTLVL` reader - Data Register Empty Interrupt Level"]
pub type DREINTLVL_R = crate :: FieldReader < u8 , DREINTLVL_A > ; # [doc = "Data Register Empty Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DREINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < DREINTLVL_A > for u8 { # [inline (always)]
fn from (variant : DREINTLVL_A) -> Self { variant as _ } } impl DREINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DREINTLVL_A { match self . bits { 0 => DREINTLVL_A :: OFF , 1 => DREINTLVL_A :: LO , 2 => DREINTLVL_A :: MED , 3 => DREINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DREINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == DREINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == DREINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == DREINTLVL_A :: HI } } # [doc = "Field `DREINTLVL` writer - Data Register Empty Interrupt Level"]
pub type DREINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DREINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > DREINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DREINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (DREINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (DREINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (DREINTLVL_A :: HI) } } # [doc = "Field `TXCINTLVL` reader - Transmit Interrupt Level"]
pub type TXCINTLVL_R = crate :: FieldReader < u8 , TXCINTLVL_A > ; # [doc = "Transmit Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < TXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : TXCINTLVL_A) -> Self { variant as _ } } impl TXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXCINTLVL_A { match self . bits { 0 => TXCINTLVL_A :: OFF , 1 => TXCINTLVL_A :: LO , 2 => TXCINTLVL_A :: MED , 3 => TXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == TXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == TXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == TXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == TXCINTLVL_A :: HI } } # [doc = "Field `TXCINTLVL` writer - Transmit Interrupt Level"]
pub type TXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , TXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > TXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: HI) } } # [doc = "Field `RXCINTLVL` reader - Receive Interrupt Level"]
pub type RXCINTLVL_R = crate :: FieldReader < u8 , RXCINTLVL_A > ; # [doc = "Receive Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < RXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : RXCINTLVL_A) -> Self { variant as _ } } impl RXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXCINTLVL_A { match self . bits { 0 => RXCINTLVL_A :: OFF , 1 => RXCINTLVL_A :: LO , 2 => RXCINTLVL_A :: MED , 3 => RXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == RXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == RXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == RXCINTLVL_A :: HI } } # [doc = "Field `RXCINTLVL` writer - Receive Interrupt Level"]
pub type RXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , RXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > RXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
pub fn dreintlvl (& self) -> DREINTLVL_R { DREINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
pub fn txcintlvl (& self) -> TXCINTLVL_R { TXCINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
pub fn rxcintlvl (& self) -> RXCINTLVL_R { RXCINTLVL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn dreintlvl (& mut self) -> DREINTLVL_W < 0 > { DREINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn txcintlvl (& mut self) -> TXCINTLVL_W < 2 > { TXCINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn rxcintlvl (& mut self) -> RXCINTLVL_W < 4 > { RXCINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB8` reader - Transmit bit 8"]
pub type TXB8_R = crate :: BitReader < bool > ; # [doc = "Field `TXB8` writer - Transmit bit 8"]
pub type TXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Double transmission speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Double transmission speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
pub fn txb8 (& self) -> TXB8_R { TXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
# [must_use]
pub fn txb8 (& mut self) -> TXB8_W < 0 > { TXB8_W :: new (self) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 1 > { MPCM_W :: new (self) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 2 > { CLK2X_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 3 > { TXEN_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 4 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "7: Character size: 9 bit"]
_9BIT = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 7 => Some (CHSIZE_A :: _9BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == CHSIZE_A :: _9BIT } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BIT) } } # [doc = "Field `UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Master Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Master Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: IrDA Mode"]
IRDA = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRDA , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRDA`"]
# [inline (always)]
pub fn is_irda (& self) -> bool { * self == CMODE_A :: IRDA } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "IrDA Mode"]
# [inline (always)]
pub fn irda (self) -> & 'a mut W { self . variant (CMODE_A :: IRDA) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXB8` reader - Receive Bit 8"]
pub type RXB8_R = crate :: BitReader < bool > ; # [doc = "Field `RXB8` writer - Receive Bit 8"]
pub type RXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
pub fn rxb8 (& self) -> RXB8_R { RXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb8 (& mut self) -> RXB8_W < 0 > { RXB8_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn perr (& mut self) -> PERR_W < 2 > { PERR_W :: new (self) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 3 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn ferr (& mut self) -> FERR_W < 4 > { FERR_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub struct USARTD0 { _marker : PhantomData < * const () > } unsafe impl Send for USARTD0 { } impl USARTD0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usartd0 :: RegisterBlock = 0x09a0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usartd0 :: RegisterBlock { Self :: PTR } } impl Deref for USARTD0 { type Target = usartd0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USARTD0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USARTD0") . finish () } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub mod usartd0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Register"]
pub data : DATA , # [doc = "0x01 - Status Register"]
pub status : STATUS , _reserved2 : [u8 ; 0x01]
, # [doc = "0x03 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x04 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x05 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x06 - Baud Rate Control Register A"]
pub baudctrla : BAUDCTRLA , # [doc = "0x07 - Baud Rate Control Register B"]
pub baudctrlb : BAUDCTRLB , } # [doc = "BAUDCTRLA (rw) register accessor: an alias for `Reg<BAUDCTRLA_SPEC>`"]
pub type BAUDCTRLA = crate :: Reg < baudctrla :: BAUDCTRLA_SPEC > ; # [doc = "Baud Rate Control Register A"]
pub mod baudctrla { # [doc = "Register `BAUDCTRLA` reader"]
pub struct R (crate :: R < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLA` writer"]
pub struct W (crate :: W < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLA_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrla](index.html) module"]
pub struct BAUDCTRLA_SPEC ; impl crate :: RegisterSpec for BAUDCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrla::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrla::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLA to value 0"]
impl crate :: Resettable for BAUDCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BAUDCTRLB (rw) register accessor: an alias for `Reg<BAUDCTRLB_SPEC>`"]
pub type BAUDCTRLB = crate :: Reg < baudctrlb :: BAUDCTRLB_SPEC > ; # [doc = "Baud Rate Control Register B"]
pub mod baudctrlb { # [doc = "Register `BAUDCTRLB` reader"]
pub struct R (crate :: R < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLB` writer"]
pub struct W (crate :: W < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `BSCALE` reader - Baud Rate Scale"]
pub type BSCALE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSCALE` writer - Baud Rate Scale"]
pub type BSCALE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
pub fn bscale (& self) -> BSCALE_R { BSCALE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
# [must_use]
pub fn bscale (& mut self) -> BSCALE_W < 4 > { BSCALE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Baud Rate Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrlb](index.html) module"]
pub struct BAUDCTRLB_SPEC ; impl crate :: RegisterSpec for BAUDCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrlb::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrlb::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLB to value 0"]
impl crate :: Resettable for BAUDCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DREINTLVL` reader - Data Register Empty Interrupt Level"]
pub type DREINTLVL_R = crate :: FieldReader < u8 , DREINTLVL_A > ; # [doc = "Data Register Empty Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DREINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < DREINTLVL_A > for u8 { # [inline (always)]
fn from (variant : DREINTLVL_A) -> Self { variant as _ } } impl DREINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DREINTLVL_A { match self . bits { 0 => DREINTLVL_A :: OFF , 1 => DREINTLVL_A :: LO , 2 => DREINTLVL_A :: MED , 3 => DREINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DREINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == DREINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == DREINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == DREINTLVL_A :: HI } } # [doc = "Field `DREINTLVL` writer - Data Register Empty Interrupt Level"]
pub type DREINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DREINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > DREINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DREINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (DREINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (DREINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (DREINTLVL_A :: HI) } } # [doc = "Field `TXCINTLVL` reader - Transmit Interrupt Level"]
pub type TXCINTLVL_R = crate :: FieldReader < u8 , TXCINTLVL_A > ; # [doc = "Transmit Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < TXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : TXCINTLVL_A) -> Self { variant as _ } } impl TXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXCINTLVL_A { match self . bits { 0 => TXCINTLVL_A :: OFF , 1 => TXCINTLVL_A :: LO , 2 => TXCINTLVL_A :: MED , 3 => TXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == TXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == TXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == TXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == TXCINTLVL_A :: HI } } # [doc = "Field `TXCINTLVL` writer - Transmit Interrupt Level"]
pub type TXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , TXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > TXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: HI) } } # [doc = "Field `RXCINTLVL` reader - Receive Interrupt Level"]
pub type RXCINTLVL_R = crate :: FieldReader < u8 , RXCINTLVL_A > ; # [doc = "Receive Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < RXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : RXCINTLVL_A) -> Self { variant as _ } } impl RXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXCINTLVL_A { match self . bits { 0 => RXCINTLVL_A :: OFF , 1 => RXCINTLVL_A :: LO , 2 => RXCINTLVL_A :: MED , 3 => RXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == RXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == RXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == RXCINTLVL_A :: HI } } # [doc = "Field `RXCINTLVL` writer - Receive Interrupt Level"]
pub type RXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , RXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > RXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
pub fn dreintlvl (& self) -> DREINTLVL_R { DREINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
pub fn txcintlvl (& self) -> TXCINTLVL_R { TXCINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
pub fn rxcintlvl (& self) -> RXCINTLVL_R { RXCINTLVL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn dreintlvl (& mut self) -> DREINTLVL_W < 0 > { DREINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn txcintlvl (& mut self) -> TXCINTLVL_W < 2 > { TXCINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn rxcintlvl (& mut self) -> RXCINTLVL_W < 4 > { RXCINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB8` reader - Transmit bit 8"]
pub type TXB8_R = crate :: BitReader < bool > ; # [doc = "Field `TXB8` writer - Transmit bit 8"]
pub type TXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Double transmission speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Double transmission speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
pub fn txb8 (& self) -> TXB8_R { TXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
# [must_use]
pub fn txb8 (& mut self) -> TXB8_W < 0 > { TXB8_W :: new (self) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 1 > { MPCM_W :: new (self) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 2 > { CLK2X_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 3 > { TXEN_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 4 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "7: Character size: 9 bit"]
_9BIT = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 7 => Some (CHSIZE_A :: _9BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == CHSIZE_A :: _9BIT } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BIT) } } # [doc = "Field `UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Master Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Master Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: IrDA Mode"]
IRDA = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRDA , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRDA`"]
# [inline (always)]
pub fn is_irda (& self) -> bool { * self == CMODE_A :: IRDA } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "IrDA Mode"]
# [inline (always)]
pub fn irda (self) -> & 'a mut W { self . variant (CMODE_A :: IRDA) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXB8` reader - Receive Bit 8"]
pub type RXB8_R = crate :: BitReader < bool > ; # [doc = "Field `RXB8` writer - Receive Bit 8"]
pub type RXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
pub fn rxb8 (& self) -> RXB8_R { RXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb8 (& mut self) -> RXB8_W < 0 > { RXB8_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn perr (& mut self) -> PERR_W < 2 > { PERR_W :: new (self) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 3 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn ferr (& mut self) -> FERR_W < 4 > { FERR_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub struct USARTD1 { _marker : PhantomData < * const () > } unsafe impl Send for USARTD1 { } impl USARTD1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usartd1 :: RegisterBlock = 0x09b0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usartd1 :: RegisterBlock { Self :: PTR } } impl Deref for USARTD1 { type Target = usartd1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USARTD1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USARTD1") . finish () } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub mod usartd1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Register"]
pub data : DATA , # [doc = "0x01 - Status Register"]
pub status : STATUS , _reserved2 : [u8 ; 0x01]
, # [doc = "0x03 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x04 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x05 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x06 - Baud Rate Control Register A"]
pub baudctrla : BAUDCTRLA , # [doc = "0x07 - Baud Rate Control Register B"]
pub baudctrlb : BAUDCTRLB , } # [doc = "BAUDCTRLA (rw) register accessor: an alias for `Reg<BAUDCTRLA_SPEC>`"]
pub type BAUDCTRLA = crate :: Reg < baudctrla :: BAUDCTRLA_SPEC > ; # [doc = "Baud Rate Control Register A"]
pub mod baudctrla { # [doc = "Register `BAUDCTRLA` reader"]
pub struct R (crate :: R < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLA` writer"]
pub struct W (crate :: W < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLA_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrla](index.html) module"]
pub struct BAUDCTRLA_SPEC ; impl crate :: RegisterSpec for BAUDCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrla::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrla::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLA to value 0"]
impl crate :: Resettable for BAUDCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BAUDCTRLB (rw) register accessor: an alias for `Reg<BAUDCTRLB_SPEC>`"]
pub type BAUDCTRLB = crate :: Reg < baudctrlb :: BAUDCTRLB_SPEC > ; # [doc = "Baud Rate Control Register B"]
pub mod baudctrlb { # [doc = "Register `BAUDCTRLB` reader"]
pub struct R (crate :: R < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLB` writer"]
pub struct W (crate :: W < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `BSCALE` reader - Baud Rate Scale"]
pub type BSCALE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSCALE` writer - Baud Rate Scale"]
pub type BSCALE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
pub fn bscale (& self) -> BSCALE_R { BSCALE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
# [must_use]
pub fn bscale (& mut self) -> BSCALE_W < 4 > { BSCALE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Baud Rate Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrlb](index.html) module"]
pub struct BAUDCTRLB_SPEC ; impl crate :: RegisterSpec for BAUDCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrlb::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrlb::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLB to value 0"]
impl crate :: Resettable for BAUDCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DREINTLVL` reader - Data Register Empty Interrupt Level"]
pub type DREINTLVL_R = crate :: FieldReader < u8 , DREINTLVL_A > ; # [doc = "Data Register Empty Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DREINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < DREINTLVL_A > for u8 { # [inline (always)]
fn from (variant : DREINTLVL_A) -> Self { variant as _ } } impl DREINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DREINTLVL_A { match self . bits { 0 => DREINTLVL_A :: OFF , 1 => DREINTLVL_A :: LO , 2 => DREINTLVL_A :: MED , 3 => DREINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DREINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == DREINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == DREINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == DREINTLVL_A :: HI } } # [doc = "Field `DREINTLVL` writer - Data Register Empty Interrupt Level"]
pub type DREINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DREINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > DREINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DREINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (DREINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (DREINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (DREINTLVL_A :: HI) } } # [doc = "Field `TXCINTLVL` reader - Transmit Interrupt Level"]
pub type TXCINTLVL_R = crate :: FieldReader < u8 , TXCINTLVL_A > ; # [doc = "Transmit Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < TXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : TXCINTLVL_A) -> Self { variant as _ } } impl TXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXCINTLVL_A { match self . bits { 0 => TXCINTLVL_A :: OFF , 1 => TXCINTLVL_A :: LO , 2 => TXCINTLVL_A :: MED , 3 => TXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == TXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == TXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == TXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == TXCINTLVL_A :: HI } } # [doc = "Field `TXCINTLVL` writer - Transmit Interrupt Level"]
pub type TXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , TXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > TXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: HI) } } # [doc = "Field `RXCINTLVL` reader - Receive Interrupt Level"]
pub type RXCINTLVL_R = crate :: FieldReader < u8 , RXCINTLVL_A > ; # [doc = "Receive Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < RXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : RXCINTLVL_A) -> Self { variant as _ } } impl RXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXCINTLVL_A { match self . bits { 0 => RXCINTLVL_A :: OFF , 1 => RXCINTLVL_A :: LO , 2 => RXCINTLVL_A :: MED , 3 => RXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == RXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == RXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == RXCINTLVL_A :: HI } } # [doc = "Field `RXCINTLVL` writer - Receive Interrupt Level"]
pub type RXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , RXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > RXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
pub fn dreintlvl (& self) -> DREINTLVL_R { DREINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
pub fn txcintlvl (& self) -> TXCINTLVL_R { TXCINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
pub fn rxcintlvl (& self) -> RXCINTLVL_R { RXCINTLVL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn dreintlvl (& mut self) -> DREINTLVL_W < 0 > { DREINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn txcintlvl (& mut self) -> TXCINTLVL_W < 2 > { TXCINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn rxcintlvl (& mut self) -> RXCINTLVL_W < 4 > { RXCINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB8` reader - Transmit bit 8"]
pub type TXB8_R = crate :: BitReader < bool > ; # [doc = "Field `TXB8` writer - Transmit bit 8"]
pub type TXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Double transmission speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Double transmission speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
pub fn txb8 (& self) -> TXB8_R { TXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
# [must_use]
pub fn txb8 (& mut self) -> TXB8_W < 0 > { TXB8_W :: new (self) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 1 > { MPCM_W :: new (self) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 2 > { CLK2X_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 3 > { TXEN_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 4 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "7: Character size: 9 bit"]
_9BIT = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 7 => Some (CHSIZE_A :: _9BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == CHSIZE_A :: _9BIT } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BIT) } } # [doc = "Field `UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Master Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Master Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: IrDA Mode"]
IRDA = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRDA , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRDA`"]
# [inline (always)]
pub fn is_irda (& self) -> bool { * self == CMODE_A :: IRDA } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "IrDA Mode"]
# [inline (always)]
pub fn irda (self) -> & 'a mut W { self . variant (CMODE_A :: IRDA) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXB8` reader - Receive Bit 8"]
pub type RXB8_R = crate :: BitReader < bool > ; # [doc = "Field `RXB8` writer - Receive Bit 8"]
pub type RXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
pub fn rxb8 (& self) -> RXB8_R { RXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb8 (& mut self) -> RXB8_W < 0 > { RXB8_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn perr (& mut self) -> PERR_W < 2 > { PERR_W :: new (self) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 3 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn ferr (& mut self) -> FERR_W < 4 > { FERR_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub struct USARTE0 { _marker : PhantomData < * const () > } unsafe impl Send for USARTE0 { } impl USARTE0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usarte0 :: RegisterBlock = 0x0aa0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usarte0 :: RegisterBlock { Self :: PTR } } impl Deref for USARTE0 { type Target = usarte0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USARTE0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USARTE0") . finish () } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub mod usarte0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Register"]
pub data : DATA , # [doc = "0x01 - Status Register"]
pub status : STATUS , _reserved2 : [u8 ; 0x01]
, # [doc = "0x03 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x04 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x05 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x06 - Baud Rate Control Register A"]
pub baudctrla : BAUDCTRLA , # [doc = "0x07 - Baud Rate Control Register B"]
pub baudctrlb : BAUDCTRLB , } # [doc = "BAUDCTRLA (rw) register accessor: an alias for `Reg<BAUDCTRLA_SPEC>`"]
pub type BAUDCTRLA = crate :: Reg < baudctrla :: BAUDCTRLA_SPEC > ; # [doc = "Baud Rate Control Register A"]
pub mod baudctrla { # [doc = "Register `BAUDCTRLA` reader"]
pub struct R (crate :: R < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLA` writer"]
pub struct W (crate :: W < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLA_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrla](index.html) module"]
pub struct BAUDCTRLA_SPEC ; impl crate :: RegisterSpec for BAUDCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrla::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrla::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLA to value 0"]
impl crate :: Resettable for BAUDCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BAUDCTRLB (rw) register accessor: an alias for `Reg<BAUDCTRLB_SPEC>`"]
pub type BAUDCTRLB = crate :: Reg < baudctrlb :: BAUDCTRLB_SPEC > ; # [doc = "Baud Rate Control Register B"]
pub mod baudctrlb { # [doc = "Register `BAUDCTRLB` reader"]
pub struct R (crate :: R < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLB` writer"]
pub struct W (crate :: W < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `BSCALE` reader - Baud Rate Scale"]
pub type BSCALE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSCALE` writer - Baud Rate Scale"]
pub type BSCALE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
pub fn bscale (& self) -> BSCALE_R { BSCALE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
# [must_use]
pub fn bscale (& mut self) -> BSCALE_W < 4 > { BSCALE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Baud Rate Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrlb](index.html) module"]
pub struct BAUDCTRLB_SPEC ; impl crate :: RegisterSpec for BAUDCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrlb::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrlb::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLB to value 0"]
impl crate :: Resettable for BAUDCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DREINTLVL` reader - Data Register Empty Interrupt Level"]
pub type DREINTLVL_R = crate :: FieldReader < u8 , DREINTLVL_A > ; # [doc = "Data Register Empty Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DREINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < DREINTLVL_A > for u8 { # [inline (always)]
fn from (variant : DREINTLVL_A) -> Self { variant as _ } } impl DREINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DREINTLVL_A { match self . bits { 0 => DREINTLVL_A :: OFF , 1 => DREINTLVL_A :: LO , 2 => DREINTLVL_A :: MED , 3 => DREINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DREINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == DREINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == DREINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == DREINTLVL_A :: HI } } # [doc = "Field `DREINTLVL` writer - Data Register Empty Interrupt Level"]
pub type DREINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DREINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > DREINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DREINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (DREINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (DREINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (DREINTLVL_A :: HI) } } # [doc = "Field `TXCINTLVL` reader - Transmit Interrupt Level"]
pub type TXCINTLVL_R = crate :: FieldReader < u8 , TXCINTLVL_A > ; # [doc = "Transmit Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < TXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : TXCINTLVL_A) -> Self { variant as _ } } impl TXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXCINTLVL_A { match self . bits { 0 => TXCINTLVL_A :: OFF , 1 => TXCINTLVL_A :: LO , 2 => TXCINTLVL_A :: MED , 3 => TXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == TXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == TXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == TXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == TXCINTLVL_A :: HI } } # [doc = "Field `TXCINTLVL` writer - Transmit Interrupt Level"]
pub type TXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , TXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > TXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: HI) } } # [doc = "Field `RXCINTLVL` reader - Receive Interrupt Level"]
pub type RXCINTLVL_R = crate :: FieldReader < u8 , RXCINTLVL_A > ; # [doc = "Receive Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < RXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : RXCINTLVL_A) -> Self { variant as _ } } impl RXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXCINTLVL_A { match self . bits { 0 => RXCINTLVL_A :: OFF , 1 => RXCINTLVL_A :: LO , 2 => RXCINTLVL_A :: MED , 3 => RXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == RXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == RXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == RXCINTLVL_A :: HI } } # [doc = "Field `RXCINTLVL` writer - Receive Interrupt Level"]
pub type RXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , RXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > RXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
pub fn dreintlvl (& self) -> DREINTLVL_R { DREINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
pub fn txcintlvl (& self) -> TXCINTLVL_R { TXCINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
pub fn rxcintlvl (& self) -> RXCINTLVL_R { RXCINTLVL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn dreintlvl (& mut self) -> DREINTLVL_W < 0 > { DREINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn txcintlvl (& mut self) -> TXCINTLVL_W < 2 > { TXCINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn rxcintlvl (& mut self) -> RXCINTLVL_W < 4 > { RXCINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB8` reader - Transmit bit 8"]
pub type TXB8_R = crate :: BitReader < bool > ; # [doc = "Field `TXB8` writer - Transmit bit 8"]
pub type TXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Double transmission speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Double transmission speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
pub fn txb8 (& self) -> TXB8_R { TXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
# [must_use]
pub fn txb8 (& mut self) -> TXB8_W < 0 > { TXB8_W :: new (self) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 1 > { MPCM_W :: new (self) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 2 > { CLK2X_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 3 > { TXEN_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 4 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "7: Character size: 9 bit"]
_9BIT = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 7 => Some (CHSIZE_A :: _9BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == CHSIZE_A :: _9BIT } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BIT) } } # [doc = "Field `UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Master Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Master Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: IrDA Mode"]
IRDA = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRDA , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRDA`"]
# [inline (always)]
pub fn is_irda (& self) -> bool { * self == CMODE_A :: IRDA } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "IrDA Mode"]
# [inline (always)]
pub fn irda (self) -> & 'a mut W { self . variant (CMODE_A :: IRDA) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXB8` reader - Receive Bit 8"]
pub type RXB8_R = crate :: BitReader < bool > ; # [doc = "Field `RXB8` writer - Receive Bit 8"]
pub type RXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
pub fn rxb8 (& self) -> RXB8_R { RXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb8 (& mut self) -> RXB8_W < 0 > { RXB8_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn perr (& mut self) -> PERR_W < 2 > { PERR_W :: new (self) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 3 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn ferr (& mut self) -> FERR_W < 4 > { FERR_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub struct USARTE1 { _marker : PhantomData < * const () > } unsafe impl Send for USARTE1 { } impl USARTE1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usarte1 :: RegisterBlock = 0x0ab0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usarte1 :: RegisterBlock { Self :: PTR } } impl Deref for USARTE1 { type Target = usarte1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USARTE1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USARTE1") . finish () } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub mod usarte1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Register"]
pub data : DATA , # [doc = "0x01 - Status Register"]
pub status : STATUS , _reserved2 : [u8 ; 0x01]
, # [doc = "0x03 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x04 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x05 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x06 - Baud Rate Control Register A"]
pub baudctrla : BAUDCTRLA , # [doc = "0x07 - Baud Rate Control Register B"]
pub baudctrlb : BAUDCTRLB , } # [doc = "BAUDCTRLA (rw) register accessor: an alias for `Reg<BAUDCTRLA_SPEC>`"]
pub type BAUDCTRLA = crate :: Reg < baudctrla :: BAUDCTRLA_SPEC > ; # [doc = "Baud Rate Control Register A"]
pub mod baudctrla { # [doc = "Register `BAUDCTRLA` reader"]
pub struct R (crate :: R < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLA` writer"]
pub struct W (crate :: W < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLA_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrla](index.html) module"]
pub struct BAUDCTRLA_SPEC ; impl crate :: RegisterSpec for BAUDCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrla::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrla::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLA to value 0"]
impl crate :: Resettable for BAUDCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BAUDCTRLB (rw) register accessor: an alias for `Reg<BAUDCTRLB_SPEC>`"]
pub type BAUDCTRLB = crate :: Reg < baudctrlb :: BAUDCTRLB_SPEC > ; # [doc = "Baud Rate Control Register B"]
pub mod baudctrlb { # [doc = "Register `BAUDCTRLB` reader"]
pub struct R (crate :: R < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLB` writer"]
pub struct W (crate :: W < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `BSCALE` reader - Baud Rate Scale"]
pub type BSCALE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSCALE` writer - Baud Rate Scale"]
pub type BSCALE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
pub fn bscale (& self) -> BSCALE_R { BSCALE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
# [must_use]
pub fn bscale (& mut self) -> BSCALE_W < 4 > { BSCALE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Baud Rate Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrlb](index.html) module"]
pub struct BAUDCTRLB_SPEC ; impl crate :: RegisterSpec for BAUDCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrlb::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrlb::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLB to value 0"]
impl crate :: Resettable for BAUDCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DREINTLVL` reader - Data Register Empty Interrupt Level"]
pub type DREINTLVL_R = crate :: FieldReader < u8 , DREINTLVL_A > ; # [doc = "Data Register Empty Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DREINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < DREINTLVL_A > for u8 { # [inline (always)]
fn from (variant : DREINTLVL_A) -> Self { variant as _ } } impl DREINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DREINTLVL_A { match self . bits { 0 => DREINTLVL_A :: OFF , 1 => DREINTLVL_A :: LO , 2 => DREINTLVL_A :: MED , 3 => DREINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DREINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == DREINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == DREINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == DREINTLVL_A :: HI } } # [doc = "Field `DREINTLVL` writer - Data Register Empty Interrupt Level"]
pub type DREINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DREINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > DREINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DREINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (DREINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (DREINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (DREINTLVL_A :: HI) } } # [doc = "Field `TXCINTLVL` reader - Transmit Interrupt Level"]
pub type TXCINTLVL_R = crate :: FieldReader < u8 , TXCINTLVL_A > ; # [doc = "Transmit Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < TXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : TXCINTLVL_A) -> Self { variant as _ } } impl TXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXCINTLVL_A { match self . bits { 0 => TXCINTLVL_A :: OFF , 1 => TXCINTLVL_A :: LO , 2 => TXCINTLVL_A :: MED , 3 => TXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == TXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == TXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == TXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == TXCINTLVL_A :: HI } } # [doc = "Field `TXCINTLVL` writer - Transmit Interrupt Level"]
pub type TXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , TXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > TXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: HI) } } # [doc = "Field `RXCINTLVL` reader - Receive Interrupt Level"]
pub type RXCINTLVL_R = crate :: FieldReader < u8 , RXCINTLVL_A > ; # [doc = "Receive Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < RXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : RXCINTLVL_A) -> Self { variant as _ } } impl RXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXCINTLVL_A { match self . bits { 0 => RXCINTLVL_A :: OFF , 1 => RXCINTLVL_A :: LO , 2 => RXCINTLVL_A :: MED , 3 => RXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == RXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == RXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == RXCINTLVL_A :: HI } } # [doc = "Field `RXCINTLVL` writer - Receive Interrupt Level"]
pub type RXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , RXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > RXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
pub fn dreintlvl (& self) -> DREINTLVL_R { DREINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
pub fn txcintlvl (& self) -> TXCINTLVL_R { TXCINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
pub fn rxcintlvl (& self) -> RXCINTLVL_R { RXCINTLVL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn dreintlvl (& mut self) -> DREINTLVL_W < 0 > { DREINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn txcintlvl (& mut self) -> TXCINTLVL_W < 2 > { TXCINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn rxcintlvl (& mut self) -> RXCINTLVL_W < 4 > { RXCINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB8` reader - Transmit bit 8"]
pub type TXB8_R = crate :: BitReader < bool > ; # [doc = "Field `TXB8` writer - Transmit bit 8"]
pub type TXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Double transmission speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Double transmission speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
pub fn txb8 (& self) -> TXB8_R { TXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
# [must_use]
pub fn txb8 (& mut self) -> TXB8_W < 0 > { TXB8_W :: new (self) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 1 > { MPCM_W :: new (self) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 2 > { CLK2X_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 3 > { TXEN_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 4 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "7: Character size: 9 bit"]
_9BIT = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 7 => Some (CHSIZE_A :: _9BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == CHSIZE_A :: _9BIT } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BIT) } } # [doc = "Field `UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Master Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Master Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: IrDA Mode"]
IRDA = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRDA , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRDA`"]
# [inline (always)]
pub fn is_irda (& self) -> bool { * self == CMODE_A :: IRDA } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "IrDA Mode"]
# [inline (always)]
pub fn irda (self) -> & 'a mut W { self . variant (CMODE_A :: IRDA) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXB8` reader - Receive Bit 8"]
pub type RXB8_R = crate :: BitReader < bool > ; # [doc = "Field `RXB8` writer - Receive Bit 8"]
pub type RXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
pub fn rxb8 (& self) -> RXB8_R { RXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb8 (& mut self) -> RXB8_W < 0 > { RXB8_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn perr (& mut self) -> PERR_W < 2 > { PERR_W :: new (self) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 3 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn ferr (& mut self) -> FERR_W < 4 > { FERR_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub struct USARTF0 { _marker : PhantomData < * const () > } unsafe impl Send for USARTF0 { } impl USARTF0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usartf0 :: RegisterBlock = 0x0ba0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usartf0 :: RegisterBlock { Self :: PTR } } impl Deref for USARTF0 { type Target = usartf0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USARTF0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USARTF0") . finish () } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub mod usartf0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Register"]
pub data : DATA , # [doc = "0x01 - Status Register"]
pub status : STATUS , _reserved2 : [u8 ; 0x01]
, # [doc = "0x03 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x04 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x05 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x06 - Baud Rate Control Register A"]
pub baudctrla : BAUDCTRLA , # [doc = "0x07 - Baud Rate Control Register B"]
pub baudctrlb : BAUDCTRLB , } # [doc = "BAUDCTRLA (rw) register accessor: an alias for `Reg<BAUDCTRLA_SPEC>`"]
pub type BAUDCTRLA = crate :: Reg < baudctrla :: BAUDCTRLA_SPEC > ; # [doc = "Baud Rate Control Register A"]
pub mod baudctrla { # [doc = "Register `BAUDCTRLA` reader"]
pub struct R (crate :: R < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLA` writer"]
pub struct W (crate :: W < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLA_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrla](index.html) module"]
pub struct BAUDCTRLA_SPEC ; impl crate :: RegisterSpec for BAUDCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrla::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrla::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLA to value 0"]
impl crate :: Resettable for BAUDCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BAUDCTRLB (rw) register accessor: an alias for `Reg<BAUDCTRLB_SPEC>`"]
pub type BAUDCTRLB = crate :: Reg < baudctrlb :: BAUDCTRLB_SPEC > ; # [doc = "Baud Rate Control Register B"]
pub mod baudctrlb { # [doc = "Register `BAUDCTRLB` reader"]
pub struct R (crate :: R < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLB` writer"]
pub struct W (crate :: W < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `BSCALE` reader - Baud Rate Scale"]
pub type BSCALE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSCALE` writer - Baud Rate Scale"]
pub type BSCALE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
pub fn bscale (& self) -> BSCALE_R { BSCALE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
# [must_use]
pub fn bscale (& mut self) -> BSCALE_W < 4 > { BSCALE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Baud Rate Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrlb](index.html) module"]
pub struct BAUDCTRLB_SPEC ; impl crate :: RegisterSpec for BAUDCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrlb::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrlb::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLB to value 0"]
impl crate :: Resettable for BAUDCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DREINTLVL` reader - Data Register Empty Interrupt Level"]
pub type DREINTLVL_R = crate :: FieldReader < u8 , DREINTLVL_A > ; # [doc = "Data Register Empty Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DREINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < DREINTLVL_A > for u8 { # [inline (always)]
fn from (variant : DREINTLVL_A) -> Self { variant as _ } } impl DREINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DREINTLVL_A { match self . bits { 0 => DREINTLVL_A :: OFF , 1 => DREINTLVL_A :: LO , 2 => DREINTLVL_A :: MED , 3 => DREINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DREINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == DREINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == DREINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == DREINTLVL_A :: HI } } # [doc = "Field `DREINTLVL` writer - Data Register Empty Interrupt Level"]
pub type DREINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DREINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > DREINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DREINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (DREINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (DREINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (DREINTLVL_A :: HI) } } # [doc = "Field `TXCINTLVL` reader - Transmit Interrupt Level"]
pub type TXCINTLVL_R = crate :: FieldReader < u8 , TXCINTLVL_A > ; # [doc = "Transmit Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < TXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : TXCINTLVL_A) -> Self { variant as _ } } impl TXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXCINTLVL_A { match self . bits { 0 => TXCINTLVL_A :: OFF , 1 => TXCINTLVL_A :: LO , 2 => TXCINTLVL_A :: MED , 3 => TXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == TXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == TXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == TXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == TXCINTLVL_A :: HI } } # [doc = "Field `TXCINTLVL` writer - Transmit Interrupt Level"]
pub type TXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , TXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > TXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: HI) } } # [doc = "Field `RXCINTLVL` reader - Receive Interrupt Level"]
pub type RXCINTLVL_R = crate :: FieldReader < u8 , RXCINTLVL_A > ; # [doc = "Receive Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < RXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : RXCINTLVL_A) -> Self { variant as _ } } impl RXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXCINTLVL_A { match self . bits { 0 => RXCINTLVL_A :: OFF , 1 => RXCINTLVL_A :: LO , 2 => RXCINTLVL_A :: MED , 3 => RXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == RXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == RXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == RXCINTLVL_A :: HI } } # [doc = "Field `RXCINTLVL` writer - Receive Interrupt Level"]
pub type RXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , RXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > RXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
pub fn dreintlvl (& self) -> DREINTLVL_R { DREINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
pub fn txcintlvl (& self) -> TXCINTLVL_R { TXCINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
pub fn rxcintlvl (& self) -> RXCINTLVL_R { RXCINTLVL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn dreintlvl (& mut self) -> DREINTLVL_W < 0 > { DREINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn txcintlvl (& mut self) -> TXCINTLVL_W < 2 > { TXCINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn rxcintlvl (& mut self) -> RXCINTLVL_W < 4 > { RXCINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB8` reader - Transmit bit 8"]
pub type TXB8_R = crate :: BitReader < bool > ; # [doc = "Field `TXB8` writer - Transmit bit 8"]
pub type TXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Double transmission speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Double transmission speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
pub fn txb8 (& self) -> TXB8_R { TXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
# [must_use]
pub fn txb8 (& mut self) -> TXB8_W < 0 > { TXB8_W :: new (self) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 1 > { MPCM_W :: new (self) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 2 > { CLK2X_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 3 > { TXEN_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 4 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "7: Character size: 9 bit"]
_9BIT = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 7 => Some (CHSIZE_A :: _9BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == CHSIZE_A :: _9BIT } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BIT) } } # [doc = "Field `UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Master Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Master Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: IrDA Mode"]
IRDA = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRDA , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRDA`"]
# [inline (always)]
pub fn is_irda (& self) -> bool { * self == CMODE_A :: IRDA } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "IrDA Mode"]
# [inline (always)]
pub fn irda (self) -> & 'a mut W { self . variant (CMODE_A :: IRDA) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXB8` reader - Receive Bit 8"]
pub type RXB8_R = crate :: BitReader < bool > ; # [doc = "Field `RXB8` writer - Receive Bit 8"]
pub type RXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
pub fn rxb8 (& self) -> RXB8_R { RXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb8 (& mut self) -> RXB8_W < 0 > { RXB8_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn perr (& mut self) -> PERR_W < 2 > { PERR_W :: new (self) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 3 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn ferr (& mut self) -> FERR_W < 4 > { FERR_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub struct USARTF1 { _marker : PhantomData < * const () > } unsafe impl Send for USARTF1 { } impl USARTF1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usartf1 :: RegisterBlock = 0x0bb0 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usartf1 :: RegisterBlock { Self :: PTR } } impl Deref for USARTF1 { type Target = usartf1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USARTF1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USARTF1") . finish () } } # [doc = "Universal Asynchronous Receiver-Transmitter"]
pub mod usartf1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Register"]
pub data : DATA , # [doc = "0x01 - Status Register"]
pub status : STATUS , _reserved2 : [u8 ; 0x01]
, # [doc = "0x03 - Control Register A"]
pub ctrla : CTRLA , # [doc = "0x04 - Control Register B"]
pub ctrlb : CTRLB , # [doc = "0x05 - Control Register C"]
pub ctrlc : CTRLC , # [doc = "0x06 - Baud Rate Control Register A"]
pub baudctrla : BAUDCTRLA , # [doc = "0x07 - Baud Rate Control Register B"]
pub baudctrlb : BAUDCTRLB , } # [doc = "BAUDCTRLA (rw) register accessor: an alias for `Reg<BAUDCTRLA_SPEC>`"]
pub type BAUDCTRLA = crate :: Reg < baudctrla :: BAUDCTRLA_SPEC > ; # [doc = "Baud Rate Control Register A"]
pub mod baudctrla { # [doc = "Register `BAUDCTRLA` reader"]
pub struct R (crate :: R < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLA` writer"]
pub struct W (crate :: W < BAUDCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection Bits \\[7:0\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLA_SPEC , u8 , u8 , 8 , O > ; impl R { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Selection Bits \\[7:0\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Baud Rate Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrla](index.html) module"]
pub struct BAUDCTRLA_SPEC ; impl crate :: RegisterSpec for BAUDCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrla::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrla::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLA to value 0"]
impl crate :: Resettable for BAUDCTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "BAUDCTRLB (rw) register accessor: an alias for `Reg<BAUDCTRLB_SPEC>`"]
pub type BAUDCTRLB = crate :: Reg < baudctrlb :: BAUDCTRLB_SPEC > ; # [doc = "Baud Rate Control Register B"]
pub mod baudctrlb { # [doc = "Register `BAUDCTRLB` reader"]
pub struct R (crate :: R < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUDCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUDCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUDCTRLB` writer"]
pub struct W (crate :: W < BAUDCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUDCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUDCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUDCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `BSEL` reader - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSEL` writer - Baud Rate Selection bits\\[11:8\\]"]
pub type BSEL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; # [doc = "Field `BSCALE` reader - Baud Rate Scale"]
pub type BSCALE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BSCALE` writer - Baud Rate Scale"]
pub type BSCALE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , BAUDCTRLB_SPEC , u8 , u8 , 4 , O > ; impl R { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
pub fn bsel (& self) -> BSEL_R { BSEL_R :: new (self . bits & 0x0f) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
pub fn bscale (& self) -> BSCALE_R { BSCALE_R :: new ((self . bits >> 4) & 0x0f) } } impl W { # [doc = "Bits 0:3 - Baud Rate Selection bits\\[11:8\\]"]
# [inline (always)]
# [must_use]
pub fn bsel (& mut self) -> BSEL_W < 0 > { BSEL_W :: new (self) } # [doc = "Bits 4:7 - Baud Rate Scale"]
# [inline (always)]
# [must_use]
pub fn bscale (& mut self) -> BSCALE_W < 4 > { BSCALE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Baud Rate Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudctrlb](index.html) module"]
pub struct BAUDCTRLB_SPEC ; impl crate :: RegisterSpec for BAUDCTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baudctrlb::R](R) reader structure"]
impl crate :: Readable for BAUDCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baudctrlb::W](W) writer structure"]
impl crate :: Writable for BAUDCTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets BAUDCTRLB to value 0"]
impl crate :: Resettable for BAUDCTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLA (rw) register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control Register A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DREINTLVL` reader - Data Register Empty Interrupt Level"]
pub type DREINTLVL_R = crate :: FieldReader < u8 , DREINTLVL_A > ; # [doc = "Data Register Empty Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DREINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < DREINTLVL_A > for u8 { # [inline (always)]
fn from (variant : DREINTLVL_A) -> Self { variant as _ } } impl DREINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DREINTLVL_A { match self . bits { 0 => DREINTLVL_A :: OFF , 1 => DREINTLVL_A :: LO , 2 => DREINTLVL_A :: MED , 3 => DREINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == DREINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == DREINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == DREINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == DREINTLVL_A :: HI } } # [doc = "Field `DREINTLVL` writer - Data Register Empty Interrupt Level"]
pub type DREINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , DREINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > DREINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (DREINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (DREINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (DREINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (DREINTLVL_A :: HI) } } # [doc = "Field `TXCINTLVL` reader - Transmit Interrupt Level"]
pub type TXCINTLVL_R = crate :: FieldReader < u8 , TXCINTLVL_A > ; # [doc = "Transmit Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum TXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < TXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : TXCINTLVL_A) -> Self { variant as _ } } impl TXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXCINTLVL_A { match self . bits { 0 => TXCINTLVL_A :: OFF , 1 => TXCINTLVL_A :: LO , 2 => TXCINTLVL_A :: MED , 3 => TXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == TXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == TXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == TXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == TXCINTLVL_A :: HI } } # [doc = "Field `TXCINTLVL` writer - Transmit Interrupt Level"]
pub type TXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , TXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > TXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (TXCINTLVL_A :: HI) } } # [doc = "Field `RXCINTLVL` reader - Receive Interrupt Level"]
pub type RXCINTLVL_R = crate :: FieldReader < u8 , RXCINTLVL_A > ; # [doc = "Receive Interrupt Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RXCINTLVL_A { # [doc = "0: Interrupt Disabled"]
OFF = 0 , # [doc = "1: Low Level"]
LO = 1 , # [doc = "2: Medium Level"]
MED = 2 , # [doc = "3: High Level"]
HI = 3 , } impl From < RXCINTLVL_A > for u8 { # [inline (always)]
fn from (variant : RXCINTLVL_A) -> Self { variant as _ } } impl RXCINTLVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RXCINTLVL_A { match self . bits { 0 => RXCINTLVL_A :: OFF , 1 => RXCINTLVL_A :: LO , 2 => RXCINTLVL_A :: MED , 3 => RXCINTLVL_A :: HI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == RXCINTLVL_A :: OFF } # [doc = "Checks if the value of the field is `LO`"]
# [inline (always)]
pub fn is_lo (& self) -> bool { * self == RXCINTLVL_A :: LO } # [doc = "Checks if the value of the field is `MED`"]
# [inline (always)]
pub fn is_med (& self) -> bool { * self == RXCINTLVL_A :: MED } # [doc = "Checks if the value of the field is `HI`"]
# [inline (always)]
pub fn is_hi (& self) -> bool { * self == RXCINTLVL_A :: HI } } # [doc = "Field `RXCINTLVL` writer - Receive Interrupt Level"]
pub type RXCINTLVL_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLA_SPEC , u8 , RXCINTLVL_A , 2 , O > ; impl < 'a , const O : u8 > RXCINTLVL_W < 'a , O > { # [doc = "Interrupt Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: OFF) } # [doc = "Low Level"]
# [inline (always)]
pub fn lo (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: LO) } # [doc = "Medium Level"]
# [inline (always)]
pub fn med (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: MED) } # [doc = "High Level"]
# [inline (always)]
pub fn hi (self) -> & 'a mut W { self . variant (RXCINTLVL_A :: HI) } } impl R { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
pub fn dreintlvl (& self) -> DREINTLVL_R { DREINTLVL_R :: new (self . bits & 3) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
pub fn txcintlvl (& self) -> TXCINTLVL_R { TXCINTLVL_R :: new ((self . bits >> 2) & 3) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
pub fn rxcintlvl (& self) -> RXCINTLVL_R { RXCINTLVL_R :: new ((self . bits >> 4) & 3) } } impl W { # [doc = "Bits 0:1 - Data Register Empty Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn dreintlvl (& mut self) -> DREINTLVL_W < 0 > { DREINTLVL_W :: new (self) } # [doc = "Bits 2:3 - Transmit Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn txcintlvl (& mut self) -> TXCINTLVL_W < 2 > { TXCINTLVL_W :: new (self) } # [doc = "Bits 4:5 - Receive Interrupt Level"]
# [inline (always)]
# [must_use]
pub fn rxcintlvl (& mut self) -> RXCINTLVL_W < 4 > { RXCINTLVL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLB (rw) register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control Register B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `TXB8` reader - Transmit bit 8"]
pub type TXB8_R = crate :: BitReader < bool > ; # [doc = "Field `TXB8` writer - Transmit bit 8"]
pub type TXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `MPCM` reader - Multi-processor Communication Mode"]
pub type MPCM_R = crate :: BitReader < bool > ; # [doc = "Field `MPCM` writer - Multi-processor Communication Mode"]
pub type MPCM_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `CLK2X` reader - Double transmission speed"]
pub type CLK2X_R = crate :: BitReader < bool > ; # [doc = "Field `CLK2X` writer - Double transmission speed"]
pub type CLK2X_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
pub fn txb8 (& self) -> TXB8_R { TXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
pub fn mpcm (& self) -> MPCM_R { MPCM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
pub fn clk2x (& self) -> CLK2X_R { CLK2X_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transmit bit 8"]
# [inline (always)]
# [must_use]
pub fn txb8 (& mut self) -> TXB8_W < 0 > { TXB8_W :: new (self) } # [doc = "Bit 1 - Multi-processor Communication Mode"]
# [inline (always)]
# [must_use]
pub fn mpcm (& mut self) -> MPCM_W < 1 > { MPCM_W :: new (self) } # [doc = "Bit 2 - Double transmission speed"]
# [inline (always)]
# [must_use]
pub fn clk2x (& mut self) -> CLK2X_W < 2 > { CLK2X_W :: new (self) } # [doc = "Bit 3 - Transmitter Enable"]
# [inline (always)]
# [must_use]
pub fn txen (& mut self) -> TXEN_W < 3 > { TXEN_W :: new (self) } # [doc = "Bit 4 - Receiver Enable"]
# [inline (always)]
# [must_use]
pub fn rxen (& mut self) -> RXEN_W < 4 > { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "CTRLC (rw) register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control Register C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , CHSIZE_A > ; # [doc = "Character Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CHSIZE_A { # [doc = "0: Character size: 5 bit"]
_5BIT = 0 , # [doc = "1: Character size: 6 bit"]
_6BIT = 1 , # [doc = "2: Character size: 7 bit"]
_7BIT = 2 , # [doc = "3: Character size: 8 bit"]
_8BIT = 3 , # [doc = "7: Character size: 9 bit"]
_9BIT = 7 , } impl From < CHSIZE_A > for u8 { # [inline (always)]
fn from (variant : CHSIZE_A) -> Self { variant as _ } } impl CHSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHSIZE_A > { match self . bits { 0 => Some (CHSIZE_A :: _5BIT) , 1 => Some (CHSIZE_A :: _6BIT) , 2 => Some (CHSIZE_A :: _7BIT) , 3 => Some (CHSIZE_A :: _8BIT) , 7 => Some (CHSIZE_A :: _9BIT) , _ => None , } } # [doc = "Checks if the value of the field is `_5BIT`"]
# [inline (always)]
pub fn is_5bit (& self) -> bool { * self == CHSIZE_A :: _5BIT } # [doc = "Checks if the value of the field is `_6BIT`"]
# [inline (always)]
pub fn is_6bit (& self) -> bool { * self == CHSIZE_A :: _6BIT } # [doc = "Checks if the value of the field is `_7BIT`"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == CHSIZE_A :: _7BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == CHSIZE_A :: _8BIT } # [doc = "Checks if the value of the field is `_9BIT`"]
# [inline (always)]
pub fn is_9bit (& self) -> bool { * self == CHSIZE_A :: _9BIT } } # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , CHSIZE_A , 3 , O > ; impl < 'a , const O : u8 > CHSIZE_W < 'a , O > { # [doc = "Character size: 5 bit"]
# [inline (always)]
pub fn _5bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _5BIT) } # [doc = "Character size: 6 bit"]
# [inline (always)]
pub fn _6bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _6BIT) } # [doc = "Character size: 7 bit"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _7BIT) } # [doc = "Character size: 8 bit"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _8BIT) } # [doc = "Character size: 9 bit"]
# [inline (always)]
pub fn _9bit (self) -> & 'a mut W { self . variant (CHSIZE_A :: _9BIT) } } # [doc = "Field `UCPHA` reader - SPI Master Mode, Clock Phase"]
pub type UCPHA_R = crate :: BitReader < bool > ; # [doc = "Field `UCPHA` writer - SPI Master Mode, Clock Phase"]
pub type UCPHA_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `UDORD` reader - SPI Master Mode, Data Order"]
pub type UDORD_R = crate :: BitReader < bool > ; # [doc = "Field `UDORD` writer - SPI Master Mode, Data Order"]
pub type UDORD_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , O > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: FieldReader < u8 , PMODE_A > ; # [doc = "Parity Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PMODE_A { # [doc = "0: No Parity"]
DISABLED = 0 , # [doc = "2: Even Parity"]
EVEN = 2 , # [doc = "3: Odd Parity"]
ODD = 3 , } impl From < PMODE_A > for u8 { # [inline (always)]
fn from (variant : PMODE_A) -> Self { variant as _ } } impl PMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMODE_A > { match self . bits { 0 => Some (PMODE_A :: DISABLED) , 2 => Some (PMODE_A :: EVEN) , 3 => Some (PMODE_A :: ODD) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == PMODE_A :: DISABLED } # [doc = "Checks if the value of the field is `EVEN`"]
# [inline (always)]
pub fn is_even (& self) -> bool { * self == PMODE_A :: EVEN } # [doc = "Checks if the value of the field is `ODD`"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == PMODE_A :: ODD } } # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRLC_SPEC , u8 , PMODE_A , 2 , O > ; impl < 'a , const O : u8 > PMODE_W < 'a , O > { # [doc = "No Parity"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (PMODE_A :: DISABLED) } # [doc = "Even Parity"]
# [inline (always)]
pub fn even (self) -> & 'a mut W { self . variant (PMODE_A :: EVEN) } # [doc = "Odd Parity"]
# [inline (always)]
pub fn odd (self) -> & 'a mut W { self . variant (PMODE_A :: ODD) } } # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: FieldReader < u8 , CMODE_A > ; # [doc = "Communication Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CMODE_A { # [doc = "0: Asynchronous Mode"]
ASYNCHRONOUS = 0 , # [doc = "1: Synchronous Mode"]
SYNCHRONOUS = 1 , # [doc = "2: IrDA Mode"]
IRDA = 2 , # [doc = "3: Master SPI Mode"]
MSPI = 3 , } impl From < CMODE_A > for u8 { # [inline (always)]
fn from (variant : CMODE_A) -> Self { variant as _ } } impl CMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CMODE_A { match self . bits { 0 => CMODE_A :: ASYNCHRONOUS , 1 => CMODE_A :: SYNCHRONOUS , 2 => CMODE_A :: IRDA , 3 => CMODE_A :: MSPI , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == CMODE_A :: ASYNCHRONOUS } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == CMODE_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `IRDA`"]
# [inline (always)]
pub fn is_irda (& self) -> bool { * self == CMODE_A :: IRDA } # [doc = "Checks if the value of the field is `MSPI`"]
# [inline (always)]
pub fn is_mspi (& self) -> bool { * self == CMODE_A :: MSPI } } # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a , const O : u8 > = crate :: FieldWriterSafe < 'a , u8 , CTRLC_SPEC , u8 , CMODE_A , 2 , O > ; impl < 'a , const O : u8 > CMODE_W < 'a , O > { # [doc = "Asynchronous Mode"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (CMODE_A :: ASYNCHRONOUS) } # [doc = "Synchronous Mode"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (CMODE_A :: SYNCHRONOUS) } # [doc = "IrDA Mode"]
# [inline (always)]
pub fn irda (self) -> & 'a mut W { self . variant (CMODE_A :: IRDA) } # [doc = "Master SPI Mode"]
# [inline (always)]
pub fn mspi (self) -> & 'a mut W { self . variant (CMODE_A :: MSPI) } } impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new (self . bits & 7) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
pub fn ucpha (& self) -> UCPHA_R { UCPHA_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
pub fn udord (& self) -> UDORD_R { UDORD_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new ((self . bits >> 4) & 3) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new ((self . bits >> 6) & 3) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
# [must_use]
pub fn chsize (& mut self) -> CHSIZE_W < 0 > { CHSIZE_W :: new (self) } # [doc = "Bit 1 - SPI Master Mode, Clock Phase"]
# [inline (always)]
# [must_use]
pub fn ucpha (& mut self) -> UCPHA_W < 1 > { UCPHA_W :: new (self) } # [doc = "Bit 2 - SPI Master Mode, Data Order"]
# [inline (always)]
# [must_use]
pub fn udord (& mut self) -> UDORD_W < 2 > { UDORD_W :: new (self) } # [doc = "Bit 3 - Stop Bit Mode"]
# [inline (always)]
# [must_use]
pub fn sbmode (& mut self) -> SBMODE_W < 3 > { SBMODE_W :: new (self) } # [doc = "Bits 4:5 - Parity Mode"]
# [inline (always)]
# [must_use]
pub fn pmode (& mut self) -> PMODE_W < 4 > { PMODE_W :: new (self) } # [doc = "Bits 6:7 - Communication Mode"]
# [inline (always)]
# [must_use]
pub fn cmode (& mut self) -> CMODE_W < 6 > { CMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control Register C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "DATA (rw) register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data Register"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status Register"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXB8` reader - Receive Bit 8"]
pub type RXB8_R = crate :: BitReader < bool > ; # [doc = "Field `RXB8` writer - Receive Bit 8"]
pub type RXB8_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `DREIF` reader - Data Register Empty Flag"]
pub type DREIF_R = crate :: BitReader < bool > ; # [doc = "Field `DREIF` writer - Data Register Empty Flag"]
pub type DREIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `TXCIF` reader - Transmit Interrupt Flag"]
pub type TXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `TXCIF` writer - Transmit Interrupt Flag"]
pub type TXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; # [doc = "Field `RXCIF` reader - Receive Interrupt Flag"]
pub type RXCIF_R = crate :: BitReader < bool > ; # [doc = "Field `RXCIF` writer - Receive Interrupt Flag"]
pub type RXCIF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
pub fn rxb8 (& self) -> RXB8_R { RXB8_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
pub fn dreif (& self) -> DREIF_R { DREIF_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
pub fn txcif (& self) -> TXCIF_R { TXCIF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
pub fn rxcif (& self) -> RXCIF_R { RXCIF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Bit 8"]
# [inline (always)]
# [must_use]
pub fn rxb8 (& mut self) -> RXB8_W < 0 > { RXB8_W :: new (self) } # [doc = "Bit 2 - Parity Error"]
# [inline (always)]
# [must_use]
pub fn perr (& mut self) -> PERR_W < 2 > { PERR_W :: new (self) } # [doc = "Bit 3 - Buffer Overflow"]
# [inline (always)]
# [must_use]
pub fn bufovf (& mut self) -> BUFOVF_W < 3 > { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Frame Error"]
# [inline (always)]
# [must_use]
pub fn ferr (& mut self) -> FERR_W < 4 > { FERR_W :: new (self) } # [doc = "Bit 5 - Data Register Empty Flag"]
# [inline (always)]
# [must_use]
pub fn dreif (& mut self) -> DREIF_W < 5 > { DREIF_W :: new (self) } # [doc = "Bit 6 - Transmit Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn txcif (& mut self) -> TXCIF_W < 6 > { TXCIF_W :: new (self) } # [doc = "Bit 7 - Receive Interrupt Flag"]
# [inline (always)]
# [must_use]
pub fn rxcif (& mut self) -> RXCIF_W < 7 > { RXCIF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct VPORT0 { _marker : PhantomData < * const () > } unsafe impl Send for VPORT0 { } impl VPORT0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const vport0 :: RegisterBlock = 0x10 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vport0 :: RegisterBlock { Self :: PTR } } impl Deref for VPORT0 { type Target = vport0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORT0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORT0") . finish () } } # [doc = "Port Configuration"]
pub mod vport0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Output"]
pub out : OUT , # [doc = "0x02 - I/O Port Input"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flag Register"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O Port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct VPORT1 { _marker : PhantomData < * const () > } unsafe impl Send for VPORT1 { } impl VPORT1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const vport1 :: RegisterBlock = 0x14 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vport1 :: RegisterBlock { Self :: PTR } } impl Deref for VPORT1 { type Target = vport1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORT1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORT1") . finish () } } # [doc = "Port Configuration"]
pub mod vport1 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Output"]
pub out : OUT , # [doc = "0x02 - I/O Port Input"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flag Register"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O Port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct VPORT2 { _marker : PhantomData < * const () > } unsafe impl Send for VPORT2 { } impl VPORT2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const vport2 :: RegisterBlock = 0x18 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vport2 :: RegisterBlock { Self :: PTR } } impl Deref for VPORT2 { type Target = vport2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORT2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORT2") . finish () } } # [doc = "Port Configuration"]
pub mod vport2 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Output"]
pub out : OUT , # [doc = "0x02 - I/O Port Input"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flag Register"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O Port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Port Configuration"]
pub struct VPORT3 { _marker : PhantomData < * const () > } unsafe impl Send for VPORT3 { } impl VPORT3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const vport3 :: RegisterBlock = 0x1c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const vport3 :: RegisterBlock { Self :: PTR } } impl Deref for VPORT3 { type Target = vport3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for VPORT3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("VPORT3") . finish () } } # [doc = "Port Configuration"]
pub mod vport3 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - I/O Port Data Direction"]
pub dir : DIR , # [doc = "0x01 - I/O Port Output"]
pub out : OUT , # [doc = "0x02 - I/O Port Input"]
pub in_ : IN , # [doc = "0x03 - Interrupt Flag Register"]
pub intflags : INTFLAGS , } # [doc = "DIR (rw) register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "I/O Port Data Direction"]
pub mod dir { # [doc = "Register `DIR` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets DIR to value 0"]
impl crate :: Resettable for DIR_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "IN (rw) register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "I/O Port Input"]
pub mod in_ { # [doc = "Register `IN` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Register `IN` writer"]
pub struct W (crate :: W < IN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < IN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < IN_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [in_::W](W) writer structure"]
impl crate :: Writable for IN_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets IN to value 0"]
impl crate :: Resettable for IN_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "INTFLAGS (rw) register accessor: an alias for `Reg<INTFLAGS_SPEC>`"]
pub type INTFLAGS = crate :: Reg < intflags :: INTFLAGS_SPEC > ; # [doc = "Interrupt Flag Register"]
pub mod intflags { # [doc = "Register `INTFLAGS` reader"]
pub struct R (crate :: R < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAGS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAGS_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAGS` writer"]
pub struct W (crate :: W < INTFLAGS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAGS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAGS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAGS_SPEC >) -> Self { W (writer) } } # [doc = "Field `INT0IF` reader - Port Interrupt 0 Flag"]
pub type INT0IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT0IF` writer - Port Interrupt 0 Flag"]
pub type INT0IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; # [doc = "Field `INT1IF` reader - Port Interrupt 1 Flag"]
pub type INT1IF_R = crate :: BitReader < bool > ; # [doc = "Field `INT1IF` writer - Port Interrupt 1 Flag"]
pub type INT1IF_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , INTFLAGS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
pub fn int0if (& self) -> INT0IF_R { INT0IF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
pub fn int1if (& self) -> INT1IF_R { INT1IF_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Port Interrupt 0 Flag"]
# [inline (always)]
# [must_use]
pub fn int0if (& mut self) -> INT0IF_W < 0 > { INT0IF_W :: new (self) } # [doc = "Bit 1 - Port Interrupt 1 Flag"]
# [inline (always)]
# [must_use]
pub fn int1if (& mut self) -> INT1IF_W < 1 > { INT1IF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflags](index.html) module"]
pub struct INTFLAGS_SPEC ; impl crate :: RegisterSpec for INTFLAGS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflags::R](R) reader structure"]
impl crate :: Readable for INTFLAGS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflags::W](W) writer structure"]
impl crate :: Writable for INTFLAGS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets INTFLAGS to value 0"]
impl crate :: Resettable for INTFLAGS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "OUT (rw) register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "I/O Port Output"]
pub mod out { # [doc = "Register `OUT` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub fn bits (& mut self , bits : u8) -> & mut Self { unsafe { self . 0 . bits (bits) } ; self } } # [doc = "I/O Port Output\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets OUT to value 0"]
impl crate :: Resettable for OUT_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [doc = "Watch-Dog Timer"]
pub struct WDT { _marker : PhantomData < * const () > } unsafe impl Send for WDT { } impl WDT { # [doc = r"Pointer to the register block"]
pub const PTR : * const wdt :: RegisterBlock = 0x80 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wdt :: RegisterBlock { Self :: PTR } } impl Deref for WDT { type Target = wdt :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WDT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WDT") . finish () } } # [doc = "Watch-Dog Timer"]
pub mod wdt { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : CTRL , # [doc = "0x01 - Windowed Mode Control"]
pub winctrl : WINCTRL , # [doc = "0x02 - Status"]
pub status : STATUS , } # [doc = "CTRL (rw) register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CEN` reader - Change Enable"]
pub type CEN_R = crate :: BitReader < bool > ; # [doc = "Field `CEN` writer - Change Enable"]
pub type CEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , O > ; # [doc = "Field `PER` reader - Period"]
pub type PER_R = crate :: FieldReader < u8 , PER_A > ; # [doc = "Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum PER_A { # [doc = "0: 8 cycles (8ms @ 3.3V)"]
_8CLK = 0 , # [doc = "1: 16 cycles (16ms @ 3.3V)"]
_16CLK = 1 , # [doc = "2: 32 cycles (32ms @ 3.3V)"]
_32CLK = 2 , # [doc = "3: 64 cycles (64ms @ 3.3V)"]
_64CLK = 3 , # [doc = "4: 128 cycles (0.128s @ 3.3V)"]
_128CLK = 4 , # [doc = "5: 256 cycles (0.256s @ 3.3V)"]
_256CLK = 5 , # [doc = "6: 512 cycles (0.512s @ 3.3V)"]
_512CLK = 6 , # [doc = "7: 1K cycles (1s @ 3.3V)"]
_1KCLK = 7 , # [doc = "8: 2K cycles (2s @ 3.3V)"]
_2KCLK = 8 , # [doc = "9: 4K cycles (4s @ 3.3V)"]
_4KCLK = 9 , # [doc = "10: 8K cycles (8s @ 3.3V)"]
_8KCLK = 10 , } impl From < PER_A > for u8 { # [inline (always)]
fn from (variant : PER_A) -> Self { variant as _ } } impl PER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PER_A > { match self . bits { 0 => Some (PER_A :: _8CLK) , 1 => Some (PER_A :: _16CLK) , 2 => Some (PER_A :: _32CLK) , 3 => Some (PER_A :: _64CLK) , 4 => Some (PER_A :: _128CLK) , 5 => Some (PER_A :: _256CLK) , 6 => Some (PER_A :: _512CLK) , 7 => Some (PER_A :: _1KCLK) , 8 => Some (PER_A :: _2KCLK) , 9 => Some (PER_A :: _4KCLK) , 10 => Some (PER_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == PER_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == PER_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == PER_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == PER_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == PER_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == PER_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == PER_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == PER_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == PER_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == PER_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == PER_A :: _8KCLK } } # [doc = "Field `PER` writer - Period"]
pub type PER_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , CTRL_SPEC , u8 , PER_A , 4 , O > ; impl < 'a , const O : u8 > PER_W < 'a , O > { # [doc = "8 cycles (8ms @ 3.3V)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (PER_A :: _8CLK) } # [doc = "16 cycles (16ms @ 3.3V)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (PER_A :: _16CLK) } # [doc = "32 cycles (32ms @ 3.3V)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (PER_A :: _32CLK) } # [doc = "64 cycles (64ms @ 3.3V)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (PER_A :: _64CLK) } # [doc = "128 cycles (0.128s @ 3.3V)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (PER_A :: _128CLK) } # [doc = "256 cycles (0.256s @ 3.3V)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (PER_A :: _256CLK) } # [doc = "512 cycles (0.512s @ 3.3V)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (PER_A :: _512CLK) } # [doc = "1K cycles (1s @ 3.3V)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (PER_A :: _1KCLK) } # [doc = "2K cycles (2s @ 3.3V)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (PER_A :: _2KCLK) } # [doc = "4K cycles (4s @ 3.3V)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (PER_A :: _4KCLK) } # [doc = "8K cycles (8s @ 3.3V)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (PER_A :: _8KCLK) } } impl R { # [doc = "Bit 0 - Change Enable"]
# [inline (always)]
pub fn cen (& self) -> CEN_R { CEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:5 - Period"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new ((self . bits >> 2) & 0x0f) } } impl W { # [doc = "Bit 0 - Change Enable"]
# [inline (always)]
# [must_use]
pub fn cen (& mut self) -> CEN_W < 0 > { CEN_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
# [must_use]
pub fn enable (& mut self) -> ENABLE_W < 1 > { ENABLE_W :: new (self) } # [doc = "Bits 2:5 - Period"]
# [inline (always)]
# [must_use]
pub fn per (& mut self) -> PER_W < 2 > { PER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "STATUS (rw) register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCBUSY` reader - Syncronization busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCBUSY` writer - Syncronization busy"]
pub type SYNCBUSY_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , STATUS_SPEC , bool , O > ; impl R { # [doc = "Bit 0 - Syncronization busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Syncronization busy"]
# [inline (always)]
# [must_use]
pub fn syncbusy (& mut self) -> SYNCBUSY_W < 0 > { SYNCBUSY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } # [doc = "WINCTRL (rw) register accessor: an alias for `Reg<WINCTRL_SPEC>`"]
pub type WINCTRL = crate :: Reg < winctrl :: WINCTRL_SPEC > ; # [doc = "Windowed Mode Control"]
pub mod winctrl { # [doc = "Register `WINCTRL` reader"]
pub struct R (crate :: R < WINCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINCTRL` writer"]
pub struct W (crate :: W < WINCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `WCEN` reader - Windowed Mode Change Enable"]
pub type WCEN_R = crate :: BitReader < bool > ; # [doc = "Field `WCEN` writer - Windowed Mode Change Enable"]
pub type WCEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WINCTRL_SPEC , bool , O > ; # [doc = "Field `WEN` reader - Windowed Mode Enable"]
pub type WEN_R = crate :: BitReader < bool > ; # [doc = "Field `WEN` writer - Windowed Mode Enable"]
pub type WEN_W < 'a , const O : u8 > = crate :: BitWriter < 'a , u8 , WINCTRL_SPEC , bool , O > ; # [doc = "Field `WPER` reader - Windowed Mode Period"]
pub type WPER_R = crate :: FieldReader < u8 , WPER_A > ; # [doc = "Windowed Mode Period\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WPER_A { # [doc = "0: 8 cycles (8ms @ 3.3V)"]
_8CLK = 0 , # [doc = "1: 16 cycles (16ms @ 3.3V)"]
_16CLK = 1 , # [doc = "2: 32 cycles (32ms @ 3.3V)"]
_32CLK = 2 , # [doc = "3: 64 cycles (64ms @ 3.3V)"]
_64CLK = 3 , # [doc = "4: 128 cycles (0.128s @ 3.3V)"]
_128CLK = 4 , # [doc = "5: 256 cycles (0.256s @ 3.3V)"]
_256CLK = 5 , # [doc = "6: 512 cycles (0.512s @ 3.3V)"]
_512CLK = 6 , # [doc = "7: 1K cycles (1s @ 3.3V)"]
_1KCLK = 7 , # [doc = "8: 2K cycles (2s @ 3.3V)"]
_2KCLK = 8 , # [doc = "9: 4K cycles (4s @ 3.3V)"]
_4KCLK = 9 , # [doc = "10: 8K cycles (8s @ 3.3V)"]
_8KCLK = 10 , } impl From < WPER_A > for u8 { # [inline (always)]
fn from (variant : WPER_A) -> Self { variant as _ } } impl WPER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WPER_A > { match self . bits { 0 => Some (WPER_A :: _8CLK) , 1 => Some (WPER_A :: _16CLK) , 2 => Some (WPER_A :: _32CLK) , 3 => Some (WPER_A :: _64CLK) , 4 => Some (WPER_A :: _128CLK) , 5 => Some (WPER_A :: _256CLK) , 6 => Some (WPER_A :: _512CLK) , 7 => Some (WPER_A :: _1KCLK) , 8 => Some (WPER_A :: _2KCLK) , 9 => Some (WPER_A :: _4KCLK) , 10 => Some (WPER_A :: _8KCLK) , _ => None , } } # [doc = "Checks if the value of the field is `_8CLK`"]
# [inline (always)]
pub fn is_8clk (& self) -> bool { * self == WPER_A :: _8CLK } # [doc = "Checks if the value of the field is `_16CLK`"]
# [inline (always)]
pub fn is_16clk (& self) -> bool { * self == WPER_A :: _16CLK } # [doc = "Checks if the value of the field is `_32CLK`"]
# [inline (always)]
pub fn is_32clk (& self) -> bool { * self == WPER_A :: _32CLK } # [doc = "Checks if the value of the field is `_64CLK`"]
# [inline (always)]
pub fn is_64clk (& self) -> bool { * self == WPER_A :: _64CLK } # [doc = "Checks if the value of the field is `_128CLK`"]
# [inline (always)]
pub fn is_128clk (& self) -> bool { * self == WPER_A :: _128CLK } # [doc = "Checks if the value of the field is `_256CLK`"]
# [inline (always)]
pub fn is_256clk (& self) -> bool { * self == WPER_A :: _256CLK } # [doc = "Checks if the value of the field is `_512CLK`"]
# [inline (always)]
pub fn is_512clk (& self) -> bool { * self == WPER_A :: _512CLK } # [doc = "Checks if the value of the field is `_1KCLK`"]
# [inline (always)]
pub fn is_1kclk (& self) -> bool { * self == WPER_A :: _1KCLK } # [doc = "Checks if the value of the field is `_2KCLK`"]
# [inline (always)]
pub fn is_2kclk (& self) -> bool { * self == WPER_A :: _2KCLK } # [doc = "Checks if the value of the field is `_4KCLK`"]
# [inline (always)]
pub fn is_4kclk (& self) -> bool { * self == WPER_A :: _4KCLK } # [doc = "Checks if the value of the field is `_8KCLK`"]
# [inline (always)]
pub fn is_8kclk (& self) -> bool { * self == WPER_A :: _8KCLK } } # [doc = "Field `WPER` writer - Windowed Mode Period"]
pub type WPER_W < 'a , const O : u8 > = crate :: FieldWriter < 'a , u8 , WINCTRL_SPEC , u8 , WPER_A , 4 , O > ; impl < 'a , const O : u8 > WPER_W < 'a , O > { # [doc = "8 cycles (8ms @ 3.3V)"]
# [inline (always)]
pub fn _8clk (self) -> & 'a mut W { self . variant (WPER_A :: _8CLK) } # [doc = "16 cycles (16ms @ 3.3V)"]
# [inline (always)]
pub fn _16clk (self) -> & 'a mut W { self . variant (WPER_A :: _16CLK) } # [doc = "32 cycles (32ms @ 3.3V)"]
# [inline (always)]
pub fn _32clk (self) -> & 'a mut W { self . variant (WPER_A :: _32CLK) } # [doc = "64 cycles (64ms @ 3.3V)"]
# [inline (always)]
pub fn _64clk (self) -> & 'a mut W { self . variant (WPER_A :: _64CLK) } # [doc = "128 cycles (0.128s @ 3.3V)"]
# [inline (always)]
pub fn _128clk (self) -> & 'a mut W { self . variant (WPER_A :: _128CLK) } # [doc = "256 cycles (0.256s @ 3.3V)"]
# [inline (always)]
pub fn _256clk (self) -> & 'a mut W { self . variant (WPER_A :: _256CLK) } # [doc = "512 cycles (0.512s @ 3.3V)"]
# [inline (always)]
pub fn _512clk (self) -> & 'a mut W { self . variant (WPER_A :: _512CLK) } # [doc = "1K cycles (1s @ 3.3V)"]
# [inline (always)]
pub fn _1kclk (self) -> & 'a mut W { self . variant (WPER_A :: _1KCLK) } # [doc = "2K cycles (2s @ 3.3V)"]
# [inline (always)]
pub fn _2kclk (self) -> & 'a mut W { self . variant (WPER_A :: _2KCLK) } # [doc = "4K cycles (4s @ 3.3V)"]
# [inline (always)]
pub fn _4kclk (self) -> & 'a mut W { self . variant (WPER_A :: _4KCLK) } # [doc = "8K cycles (8s @ 3.3V)"]
# [inline (always)]
pub fn _8kclk (self) -> & 'a mut W { self . variant (WPER_A :: _8KCLK) } } impl R { # [doc = "Bit 0 - Windowed Mode Change Enable"]
# [inline (always)]
pub fn wcen (& self) -> WCEN_R { WCEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Windowed Mode Enable"]
# [inline (always)]
pub fn wen (& self) -> WEN_R { WEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:5 - Windowed Mode Period"]
# [inline (always)]
pub fn wper (& self) -> WPER_R { WPER_R :: new ((self . bits >> 2) & 0x0f) } } impl W { # [doc = "Bit 0 - Windowed Mode Change Enable"]
# [inline (always)]
# [must_use]
pub fn wcen (& mut self) -> WCEN_W < 0 > { WCEN_W :: new (self) } # [doc = "Bit 1 - Windowed Mode Enable"]
# [inline (always)]
# [must_use]
pub fn wen (& mut self) -> WEN_W < 1 > { WEN_W :: new (self) } # [doc = "Bits 2:5 - Windowed Mode Period"]
# [inline (always)]
# [must_use]
pub fn wper (& mut self) -> WPER_W < 2 > { WPER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Windowed Mode Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winctrl](index.html) module"]
pub struct WINCTRL_SPEC ; impl crate :: RegisterSpec for WINCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [winctrl::R](R) reader structure"]
impl crate :: Readable for WINCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winctrl::W](W) writer structure"]
impl crate :: Writable for WINCTRL_SPEC { type Writer = W ; const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = 0 ; } # [doc = "`reset()` method sets WINCTRL to value 0"]
impl crate :: Resettable for WINCTRL_SPEC { const RESET_VALUE : Self :: Ux = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "ACA"]
pub ACA : ACA , # [doc = "ACB"]
pub ACB : ACB , # [doc = "ADCA"]
pub ADCA : ADCA , # [doc = "ADCB"]
pub ADCB : ADCB , # [doc = "AES"]
pub AES : AES , # [doc = "AWEXC"]
pub AWEXC : AWEXC , # [doc = "AWEXE"]
pub AWEXE : AWEXE , # [doc = "CLK"]
pub CLK : CLK , # [doc = "CPU"]
pub CPU : CPU , # [doc = "DACA"]
pub DACA : DACA , # [doc = "DACB"]
pub DACB : DACB , # [doc = "DFLLRC2M"]
pub DFLLRC2M : DFLLRC2M , # [doc = "DFLLRC32M"]
pub DFLLRC32M : DFLLRC32M , # [doc = "DMA"]
pub DMA : DMA , # [doc = "EBI"]
pub EBI : EBI , # [doc = "EVSYS"]
pub EVSYS : EVSYS , # [doc = "FUSE"]
pub FUSE : FUSE , # [doc = "GPIO"]
pub GPIO : GPIO , # [doc = "HIRESC"]
pub HIRESC : HIRESC , # [doc = "HIRESD"]
pub HIRESD : HIRESD , # [doc = "HIRESE"]
pub HIRESE : HIRESE , # [doc = "HIRESF"]
pub HIRESF : HIRESF , # [doc = "IRCOM"]
pub IRCOM : IRCOM , # [doc = "LOCKBIT"]
pub LOCKBIT : LOCKBIT , # [doc = "MCU"]
pub MCU : MCU , # [doc = "NVM"]
pub NVM : NVM , # [doc = "OCD"]
pub OCD : OCD , # [doc = "OSC"]
pub OSC : OSC , # [doc = "PMIC"]
pub PMIC : PMIC , # [doc = "PORTA"]
pub PORTA : PORTA , # [doc = "PORTB"]
pub PORTB : PORTB , # [doc = "PORTC"]
pub PORTC : PORTC , # [doc = "PORTD"]
pub PORTD : PORTD , # [doc = "PORTE"]
pub PORTE : PORTE , # [doc = "PORTF"]
pub PORTF : PORTF , # [doc = "PORTH"]
pub PORTH : PORTH , # [doc = "PORTJ"]
pub PORTJ : PORTJ , # [doc = "PORTK"]
pub PORTK : PORTK , # [doc = "PORTQ"]
pub PORTQ : PORTQ , # [doc = "PORTR"]
pub PORTR : PORTR , # [doc = "PORT_CFG"]
pub PORT_CFG : PORT_CFG , # [doc = "PR"]
pub PR : PR , # [doc = "PROD_SIGNATURES"]
pub PROD_SIGNATURES : PROD_SIGNATURES , # [doc = "RST"]
pub RST : RST , # [doc = "RTC"]
pub RTC : RTC , # [doc = "SLEEP"]
pub SLEEP : SLEEP , # [doc = "SPIC"]
pub SPIC : SPIC , # [doc = "SPID"]
pub SPID : SPID , # [doc = "SPIE"]
pub SPIE : SPIE , # [doc = "SPIF"]
pub SPIF : SPIF , # [doc = "TCC0"]
pub TCC0 : TCC0 , # [doc = "TCC1"]
pub TCC1 : TCC1 , # [doc = "TCD0"]
pub TCD0 : TCD0 , # [doc = "TCD1"]
pub TCD1 : TCD1 , # [doc = "TCE0"]
pub TCE0 : TCE0 , # [doc = "TCE1"]
pub TCE1 : TCE1 , # [doc = "TCF0"]
pub TCF0 : TCF0 , # [doc = "TCF1"]
pub TCF1 : TCF1 , # [doc = "TWIC"]
pub TWIC : TWIC , # [doc = "TWID"]
pub TWID : TWID , # [doc = "TWIE"]
pub TWIE : TWIE , # [doc = "TWIF"]
pub TWIF : TWIF , # [doc = "USARTC0"]
pub USARTC0 : USARTC0 , # [doc = "USARTC1"]
pub USARTC1 : USARTC1 , # [doc = "USARTD0"]
pub USARTD0 : USARTD0 , # [doc = "USARTD1"]
pub USARTD1 : USARTD1 , # [doc = "USARTE0"]
pub USARTE0 : USARTE0 , # [doc = "USARTE1"]
pub USARTE1 : USARTE1 , # [doc = "USARTF0"]
pub USARTF0 : USARTF0 , # [doc = "USARTF1"]
pub USARTF1 : USARTF1 , # [doc = "VPORT0"]
pub VPORT0 : VPORT0 , # [doc = "VPORT1"]
pub VPORT1 : VPORT1 , # [doc = "VPORT2"]
pub VPORT2 : VPORT2 , # [doc = "VPORT3"]
pub VPORT3 : VPORT3 , # [doc = "WDT"]
pub WDT : WDT , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { ACA : ACA { _marker : PhantomData } , ACB : ACB { _marker : PhantomData } , ADCA : ADCA { _marker : PhantomData } , ADCB : ADCB { _marker : PhantomData } , AES : AES { _marker : PhantomData } , AWEXC : AWEXC { _marker : PhantomData } , AWEXE : AWEXE { _marker : PhantomData } , CLK : CLK { _marker : PhantomData } , CPU : CPU { _marker : PhantomData } , DACA : DACA { _marker : PhantomData } , DACB : DACB { _marker : PhantomData } , DFLLRC2M : DFLLRC2M { _marker : PhantomData } , DFLLRC32M : DFLLRC32M { _marker : PhantomData } , DMA : DMA { _marker : PhantomData } , EBI : EBI { _marker : PhantomData } , EVSYS : EVSYS { _marker : PhantomData } , FUSE : FUSE { _marker : PhantomData } , GPIO : GPIO { _marker : PhantomData } , HIRESC : HIRESC { _marker : PhantomData } , HIRESD : HIRESD { _marker : PhantomData } , HIRESE : HIRESE { _marker : PhantomData } , HIRESF : HIRESF { _marker : PhantomData } , IRCOM : IRCOM { _marker : PhantomData } , LOCKBIT : LOCKBIT { _marker : PhantomData } , MCU : MCU { _marker : PhantomData } , NVM : NVM { _marker : PhantomData } , OCD : OCD { _marker : PhantomData } , OSC : OSC { _marker : PhantomData } , PMIC : PMIC { _marker : PhantomData } , PORTA : PORTA { _marker : PhantomData } , PORTB : PORTB { _marker : PhantomData } , PORTC : PORTC { _marker : PhantomData } , PORTD : PORTD { _marker : PhantomData } , PORTE : PORTE { _marker : PhantomData } , PORTF : PORTF { _marker : PhantomData } , PORTH : PORTH { _marker : PhantomData } , PORTJ : PORTJ { _marker : PhantomData } , PORTK : PORTK { _marker : PhantomData } , PORTQ : PORTQ { _marker : PhantomData } , PORTR : PORTR { _marker : PhantomData } , PORT_CFG : PORT_CFG { _marker : PhantomData } , PR : PR { _marker : PhantomData } , PROD_SIGNATURES : PROD_SIGNATURES { _marker : PhantomData } , RST : RST { _marker : PhantomData } , RTC : RTC { _marker : PhantomData } , SLEEP : SLEEP { _marker : PhantomData } , SPIC : SPIC { _marker : PhantomData } , SPID : SPID { _marker : PhantomData } , SPIE : SPIE { _marker : PhantomData } , SPIF : SPIF { _marker : PhantomData } , TCC0 : TCC0 { _marker : PhantomData } , TCC1 : TCC1 { _marker : PhantomData } , TCD0 : TCD0 { _marker : PhantomData } , TCD1 : TCD1 { _marker : PhantomData } , TCE0 : TCE0 { _marker : PhantomData } , TCE1 : TCE1 { _marker : PhantomData } , TCF0 : TCF0 { _marker : PhantomData } , TCF1 : TCF1 { _marker : PhantomData } , TWIC : TWIC { _marker : PhantomData } , TWID : TWID { _marker : PhantomData } , TWIE : TWIE { _marker : PhantomData } , TWIF : TWIF { _marker : PhantomData } , USARTC0 : USARTC0 { _marker : PhantomData } , USARTC1 : USARTC1 { _marker : PhantomData } , USARTD0 : USARTD0 { _marker : PhantomData } , USARTD1 : USARTD1 { _marker : PhantomData } , USARTE0 : USARTE0 { _marker : PhantomData } , USARTE1 : USARTE1 { _marker : PhantomData } , USARTF0 : USARTF0 { _marker : PhantomData } , USARTF1 : USARTF1 { _marker : PhantomData } , VPORT0 : VPORT0 { _marker : PhantomData } , VPORT1 : VPORT1 { _marker : PhantomData } , VPORT2 : VPORT2 { _marker : PhantomData } , VPORT3 : VPORT3 { _marker : PhantomData } , WDT : WDT { _marker : PhantomData } , } } }